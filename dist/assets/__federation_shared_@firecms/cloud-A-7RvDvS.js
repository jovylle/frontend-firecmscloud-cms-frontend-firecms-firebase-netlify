import { importShared } from "../__federation_fn_import-Ca_-J8Zi.js";
import { j as jsxRuntimeExports } from "../jsx-runtime-BcIfvQoK.js";
import { c as c_1, e as equal } from "../index-zKQ-pyZr.js";
import { c as create$1, a as create$2, b as create$3, u as useCreateFormex, g as getIn, F as Formex, l as locales, f as format, s as setIn, d as useFormex, e as useNavigate, h as Field, P as PublicDraggable, C as ConnectedDroppable$1, D as DragDropContext, i as clone, R as Routes, j as Route, k as useLocation, m as useParams, N as NavLink, n as matchRoutes, B as BrowserRouter } from "./core-ChEl3flG.js";
import { AppBar, AppContext, ArrayContainer, ArrayContainerItem, ArrayCustomShapedFieldBinding, ArrayEnumPreview, ArrayItemOptions, ArrayOfMapsPreview, ArrayOfReferencesFieldBinding, ArrayOfReferencesPreview, ArrayOfStorageComponentsPreview, ArrayOfStringsPreview, ArrayOneOfPreview, ArrayPropertyEnumPreview, ArrayPropertyPreview, AsyncPreviewComponent, AuthControllerContext, BlockFieldBinding, BooleanPreview, COLLECTION_PATH_SEPARATOR, CircularProgressCenter, ConfirmationDialog, DEFAULT_FIELD_CONFIGS, DRAWER_WIDTH, DatePreview, DateTimeFieldBinding, DefaultAppBar, DefaultDrawer, DefaultHomePage, Drawer, DrawerLogo, DrawerNavigationItem, EmptyValue, EntityCollectionRowActions, EntityCollectionTable, EntityCollectionView, EntityCollectionViewActions, EntityReference, EntityView, EnumValuesChip, ErrorBoundary, ErrorView, FieldCaption, FieldHelperText, FireCMS, FireCMSLogo, GeoPoint, IconForView, ImagePreview, KeyValueFieldBinding, KeyValuePreview, LabelWithIcon, LabelWithIconAndTooltip, MapFieldBinding, MapPropertyPreview, MarkdownEditorFieldBinding, ModeControllerContext, ModeControllerProvider, MultiSelectFieldBinding, NavigationCard, NavigationCardBinding, NavigationGroup, NavigationRoutes, NotFoundPage, NumberPropertyPreview, PropertyConfigBadge, PropertyFieldBinding, PropertyIdCopyTooltip, PropertyIdCopyTooltipContent, PropertyPreview, PropertyTableCell, ReadOnlyFieldBinding, ReferenceFieldBinding, ReferencePreview, ReferenceSelectionTable, ReferenceWidget, RepeatFieldBinding, Scaffold, SearchIconsView, SelectFieldBinding, SelectableTable, SelectableTableContext, SideDialogs, SkeletonPropertyComponent, SmallNavigationCard, SnackbarProvider, StorageThumbnail, StorageThumbnailInternal, StorageUploadFieldBinding, StringPropertyPreview, SwitchFieldBinding, TextFieldBinding, UrlComponentPreview, Vector, VirtualTable, addInitialSlash, applyPermissionsFunctionIfEmpty, archiveEntityAction, buildAdditionalFieldDelegate, buildCollection, buildEntityCallbacks, buildEnumLabel, buildEnumValueConfig, buildEnumValues, buildFieldConfig, buildIdColumn, buildProperties, buildPropertiesOrBuilder, buildProperty, canCreateEntity, canDeleteEntity, canEditEntity, copyEntityAction, defaultDateFormat, deleteEntityAction, deleteEntityWithCallbacks, editEntityAction, enumToObjectEntries, flattenObject, fullPathToCollectionSegments, getArrayResolvedProperties, getArrayValuesCount, getBracketNotation, getCollectionByPathOrId, getCollectionPathsCombinations, getColorForProperty, getColorScheme, getColumnKeysForProperty, getDefaultFieldConfig, getDefaultFieldId, getDefaultPropertiesOrder, getDefaultValueFor, getDefaultValueForDataType, getDefaultValuesFor, getEntityImagePreviewPropertyKey, getEntityPreviewKeys, getEntityTitlePropertyKey, getFieldConfig, getFieldId, getFormFieldKeys, getHashValue, getIcon, getIconForProperty, getIconForWidget, getIdIcon, getLabelOrConfigFrom, getLastSegment, getPropertiesWithPropertiesOrder, getPropertyInPath, getRandomId, getReferenceFrom, getResolvedPropertyInPath, getSidePanelKey, getValueInPath, hydrateRegExp, iconSynonyms, iconsSearch, isDefaultFieldConfigId, isEmptyObject, isEnumValueDisabled, isHidden, isObject, isPropertyBuilder, isReadOnly, isReferenceProperty, isValidRegExp, joinCollectionLists, makePropertiesEditable, makePropertiesNonEditable, mergeCollection, mergeDeep, openWebsiteAction, pick, plural, printChanged, propertiesToColumns, randomColor, randomString, removeFunctions, removeInPath, removeInitialAndTrailingSlashes, removeInitialSlash, removeNulls, removePropsIfExisting, removeTrailingSlash, removeUndefined, renderSkeletonCaptionText, renderSkeletonIcon, renderSkeletonImageThumbnail, renderSkeletonText, resolveArrayProperty, resolveCollection, resolveCollectionPathIds, resolveDefaultSelectedView, resolveEntityView, resolveEnumValues, resolveNavigationFrom, resolvePermissions, resolveProperties, resolveProperty, resolvePropertyEnum, resolveStorageFilenameString, resolveStoragePathString, sanitizeData, saveEntityWithCallbacks, segmentsToStrippedPath, serializeRegExp, singular, slugify, sortProperties, stripCollectionPath, toKebabCase, toSnakeCase, traverseValueProperty, traverseValuesProperties, unslugify, updateDateAutoValues, useApp, useAuthController, useBrowserTitleAndIcon, useBuildLocalConfigurationPersistence, useBuildModeController, useBuildNavigationController, useClearRestoreValue, useClipboard, useCollectionFetch, useColumnIds, useCustomizationController, useDataSource, useDataSourceEntityCollectionTableController, useDebouncedCallback, useDebouncedData, useDialogsController, useEntityFetch, useFireCMSContext, useLargeLayout, useModeController, useNavigationController, useReferenceDialog, useResolvedNavigationFrom, useSelectableTableController, useSelectionController, useSideDialogContext, useSideDialogsController, useSideEntityController, useSnackbarController, useStorageSource, useTableSearchHelper, useTraceUpdate, useValidateAuthenticator } from "./core-ChEl3flG.js";
import { c as clsx } from "./ui-CZ0AEYFv.js";
import { AbcIcon, AcUnitIcon, AccessAlarmIcon, AccessAlarmsIcon, AccessTimeFilledIcon, AccessTimeIcon, AccessibilityIcon, AccessibilityNewIcon, AccessibleForwardIcon, AccessibleIcon, AccountBalanceIcon, AccountBalanceWalletIcon, AccountBoxIcon, AccountCircleIcon, AccountTreeIcon, AdUnitsIcon, AdbIcon, AddAPhotoIcon, AddAlarmIcon, AddAlertIcon, AddBoxIcon, AddBusinessIcon, AddCardIcon, AddChartIcon, AddCircleIcon, AddCircleOutlineIcon, AddCommentIcon, AddHomeIcon, AddHomeWorkIcon, AddIcCallIcon, AddIcon, AddLinkIcon, AddLocationAltIcon, AddLocationIcon, AddModeratorIcon, AddPhotoAlternateIcon, AddReactionIcon, AddRoadIcon, AddShoppingCartIcon, AddTaskIcon, AddToDriveIcon, AddToHomeScreenIcon, AddToPhotosIcon, AddToQueueIcon, AdfScannerIcon, AdjustIcon, AdminPanelSettingsIcon, AdobeIcon, AdsClickIcon, AgricultureIcon, AirIcon, AirlineSeatFlatAngledIcon, AirlineSeatFlatIcon, AirlineSeatIndividualSuiteIcon, AirlineSeatLegroomExtraIcon, AirlineSeatLegroomNormalIcon, AirlineSeatLegroomReducedIcon, AirlineSeatReclineExtraIcon, AirlineSeatReclineNormalIcon, AirlineStopsIcon, AirlinesIcon, AirplaneTicketIcon, AirplanemodeActiveIcon, AirplanemodeInactiveIcon, AirplanemodeOffIcon, AirplanemodeOnIcon, AirplayIcon, AirportShuttleIcon, AlarmAddIcon, AlarmIcon, AlarmOffIcon, AlarmOnIcon, AlbumIcon, Alert, AlignHorizontalCenterIcon, AlignHorizontalLeftIcon, AlignHorizontalRightIcon, AlignVerticalBottomIcon, AlignVerticalCenterIcon, AlignVerticalTopIcon, AllInboxIcon, AllInclusiveIcon, AllOutIcon, AltRouteIcon, AlternateEmailIcon, AmpStoriesIcon, AnalyticsIcon, AnchorIcon, AndroidIcon, AnimationIcon, AnnouncementIcon, AodIcon, ApartmentIcon, ApiIcon, AppBlockingIcon, AppRegistrationIcon, AppSettingsAltIcon, AppShortcutIcon, AppleIcon, ApprovalIcon, AppsIcon, AppsOutageIcon, ArchitectureIcon, ArchiveIcon, AreaChartIcon, ArrowBackIcon, ArrowBackIosIcon, ArrowBackIosNewIcon, ArrowCircleDownIcon, ArrowCircleLeftIcon, ArrowCircleRightIcon, ArrowCircleUpIcon, ArrowDownwardIcon, ArrowDropDownCircleIcon, ArrowDropDownIcon, ArrowDropUpIcon, ArrowForwardIcon, ArrowForwardIosIcon, ArrowLeftIcon, ArrowOutwardIcon, ArrowRightAltIcon, ArrowRightIcon, ArrowUpwardIcon, ArtTrackIcon, ArticleIcon, AspectRatioIcon, AssessmentIcon, AssignmentIcon, AssignmentIndIcon, AssignmentLateIcon, AssignmentReturnIcon, AssignmentReturnedIcon, AssignmentTurnedInIcon, AssistWalkerIcon, AssistantDirectionIcon, AssistantIcon, AssistantPhotoIcon, AssuredWorkloadIcon, AtmIcon, AttachEmailIcon, AttachFileIcon, AttachMoneyIcon, AttachmentIcon, AttractionsIcon, AttributionIcon, AudioFileIcon, AudiotrackIcon, AutoAwesomeIcon, AutoAwesomeMosaicIcon, AutoAwesomeMotionIcon, AutoDeleteIcon, AutoFixHighIcon, AutoFixNormalIcon, AutoFixOffIcon, AutoGraphIcon, AutoModeIcon, AutoStoriesIcon, Autocomplete, AutocompleteItem, AutofpsSelectIcon, AutorenewIcon, AvTimerIcon, Avatar, BabyChangingStationIcon, BackHandIcon, BackpackIcon, BackspaceIcon, BackupIcon, BackupTableIcon, Badge, BadgeIcon, BakeryDiningIcon, BalanceIcon, BalconyIcon, BallotIcon, BarChartIcon, BatchPredictionIcon, BathroomIcon, BathtubIcon, Battery0BarIcon, Battery1BarIcon, Battery2BarIcon, Battery3BarIcon, Battery4BarIcon, Battery5BarIcon, Battery6BarIcon, BatteryAlertIcon, BatteryChargingFullIcon, BatteryFullIcon, BatterySaverIcon, BatteryStdIcon, BatteryUnknownIcon, BeachAccessIcon, BedIcon, BedroomBabyIcon, BedroomChildIcon, BedroomParentIcon, BedtimeIcon, BedtimeOffIcon, BeenhereIcon, BentoIcon, BikeScooterIcon, BiotechIcon, BlenderIcon, BlindIcon, BlindsClosedIcon, BlindsIcon, BlockIcon, BloodtypeIcon, BluetoothAudioIcon, BluetoothConnectedIcon, BluetoothDisabledIcon, BluetoothDriveIcon, BluetoothIcon, BluetoothSearchingIcon, BlurCircularIcon, BlurLinearIcon, BlurOffIcon, BlurOnIcon, BoltIcon, BookIcon, BookOnlineIcon, BookmarkAddIcon, BookmarkAddedIcon, BookmarkBorderIcon, BookmarkIcon, BookmarkOutlineIcon, BookmarkRemoveIcon, BookmarksIcon, BooleanSwitch, BooleanSwitchWithLabel, BorderAllIcon, BorderBottomIcon, BorderClearIcon, BorderColorIcon, BorderHorizontalIcon, BorderInnerIcon, BorderLeftIcon, BorderOuterIcon, BorderRightIcon, BorderStyleIcon, BorderTopIcon, BorderVerticalIcon, BoyIcon, BrandingWatermarkIcon, BreakfastDiningIcon, Brightness1Icon, Brightness2Icon, Brightness3Icon, Brightness4Icon, Brightness5Icon, Brightness6Icon, Brightness7Icon, BrightnessAutoIcon, BrightnessHighIcon, BrightnessLowIcon, BrightnessMediumIcon, BroadcastOnHomeIcon, BroadcastOnPersonalIcon, BrokenImageIcon, BrowseGalleryIcon, BrowserNotSupportedIcon, BrowserUpdatedIcon, BrunchDiningIcon, BrushIcon, BubbleChartIcon, BugReportIcon, BuildCircleIcon, BuildIcon, BungalowIcon, BurstModeIcon, BusAlertIcon, BusinessCenterIcon, BusinessIcon, Button, CHIP_COLORS, CabinIcon, CableIcon, CachedIcon, CakeIcon, CalculateIcon, CalendarMonthIcon, CalendarTodayIcon, CalendarViewDayIcon, CalendarViewMonthIcon, CalendarViewWeekIcon, CallEndIcon, CallIcon, CallMadeIcon, CallMergeIcon, CallMissedIcon, CallMissedOutgoingIcon, CallReceivedIcon, CallSplitIcon, CallToActionIcon, CameraAltIcon, CameraEnhanceIcon, CameraFrontIcon, CameraIcon, CameraIndoorIcon, CameraOutdoorIcon, CameraRearIcon, CameraRollIcon, CameraswitchIcon, CampaignIcon, CancelIcon, CancelPresentationIcon, CancelScheduleSendIcon, CandlestickChartIcon, CarCrashIcon, CarRentalIcon, CarRepairIcon, Card, CardGiftcardIcon, CardMembershipIcon, CardTravelIcon, CarpenterIcon, CasesIcon, CasinoIcon, CastConnectedIcon, CastForEducationIcon, CastIcon, CastleIcon, CatchingPokemonIcon, CategoryIcon, CelebrationIcon, CellTowerIcon, CellWifiIcon, CenterFocusStrongIcon, CenterFocusWeakIcon, CenteredView, ChairAltIcon, ChairIcon, ChaletIcon, ChangeCircleIcon, ChangeHistoryIcon, ChargingStationIcon, ChatBubbleIcon, ChatBubbleOutlineIcon, ChatIcon, CheckBoxIcon, CheckBoxOutlineBlankIcon, CheckCircleIcon, CheckCircleOutlineIcon, CheckIcon, Checkbox, ChecklistIcon, ChecklistRtlIcon, CheckroomIcon, ChevronLeftIcon, ChevronRightIcon, ChildCareIcon, ChildFriendlyIcon, Chip, ChromeReaderModeIcon, ChurchIcon, CircleIcon, CircleNotificationsIcon, CircularProgress, ClassIcon, CleanHandsIcon, CleaningServicesIcon, ClearAllIcon, ClearIcon, CloseFullscreenIcon, CloseIcon, ClosedCaptionDisabledIcon, ClosedCaptionIcon, ClosedCaptionOffIcon, CloudCircleIcon, CloudDoneIcon, CloudDownloadIcon, CloudIcon, CloudOffIcon, CloudQueueIcon, CloudSyncIcon, CloudUploadIcon, Co2Icon, CoPresentIcon, CodeIcon, CodeOffIcon, CoffeeIcon, CoffeeMakerIcon, Collapse, CollectionsBookmarkIcon, CollectionsIcon, ColorLensIcon, ColorizeIcon, CommentBankIcon, CommentIcon, CommentsDisabledIcon, CommitIcon, CommuteIcon, CompareArrowsIcon, CompareIcon, CompassCalibrationIcon, CompostIcon, CompressIcon, ComputerIcon, ConfirmationNumIcon, ConfirmationNumberIcon, ConnectWithoutContactIcon, ConnectedTvIcon, ConnectingAirportsIcon, ConstructionIcon, ContactEmergencyIcon, ContactMailIcon, ContactPageIcon, ContactPhoneIcon, ContactSupportIcon, ContactlessIcon, ContactsIcon, Container, ContentCopyIcon, ContentCutIcon, ContentPasteGoIcon, ContentPasteIcon, ContentPasteOffIcon, ContentPasteSearchIcon, ContrastIcon, ControlCameraIcon, ControlPointDuplicateIcon, ControlPointIcon, CookieIcon, CopyAllIcon, CopyIcon, CopyrightIcon, CoronavirusIcon, CorporateFareIcon, CottageIcon, CountertopsIcon, CreateIcon, CreateNewFolderIcon, CreditCardIcon, CreditCardOffIcon, CreditScoreIcon, CribIcon, CrisisAlertIcon, Crop169Icon, Crop32Icon, Crop54Icon, Crop75Icon, CropDinIcon, CropFreeIcon, CropIcon, CropLandscapeIcon, CropOriginalIcon, CropPortraitIcon, CropRotateIcon, CropSquareIcon, CrueltyFreeIcon, CssIcon, CurrencyBitcoinIcon, CurrencyExchangeIcon, CurrencyFrancIcon, CurrencyLiraIcon, CurrencyPoundIcon, CurrencyRubleIcon, CurrencyRupeeIcon, CurrencyYenIcon, CurrencyYuanIcon, CurtainsClosedIcon, CurtainsIcon, CutIcon, CycloneIcon, DangerousIcon, DarkModeIcon, DashboardCustomizeIcon, DashboardIcon, DataArrayIcon, DataExplorationIcon, DataObjectIcon, DataSaverOffIcon, DataSaverOnIcon, DataThresholdingIcon, DataUsageIcon, DatasetIcon, DatasetLinkedIcon, DateRangeIcon, DateTimeField, DeblurIcon, DebouncedTextField, DeckIcon, DehazeIcon, DeleteForeverIcon, DeleteIcon, DeleteOutlineIcon, DeleteSweepIcon, DeliveryDiningIcon, DensityLargeIcon, DensityMediumIcon, DensitySmallIcon, DepartureBoardIcon, DescriptionIcon, DeselectIcon, DesignServicesIcon, DeskIcon, DesktopAccessDisabledIcon, DesktopMacIcon, DesktopWindowsIcon, DetailsIcon, DeveloperBoardIcon, DeveloperBoardOffIcon, DeveloperModeIcon, DeviceHubIcon, DeviceThermostatIcon, DeviceUnknownIcon, DevicesFoldIcon, DevicesIcon, DevicesOtherIcon, DialerSipIcon, Dialog, DialogActions, DialogContent, DialogTitle, DialpadIcon, DiamondIcon, DifferenceIcon, DiningIcon, DinnerDiningIcon, DirectionsBikeIcon, DirectionsBoatFilledIcon, DirectionsBoatIcon, DirectionsBusFilledIcon, DirectionsBusIcon, DirectionsCarFilledIcon, DirectionsCarIcon, DirectionsFerryIcon, DirectionsIcon, DirectionsOffIcon, DirectionsRailwayFilledIcon, DirectionsRailwayIcon, DirectionsRunIcon, DirectionsSubwayFilledIcon, DirectionsSubwayIcon, DirectionsTrainIcon, DirectionsTransitFilledIcon, DirectionsTransitIcon, DirectionsWalkIcon, DirtyLensIcon, DisabledByDefaultIcon, DisabledVisibleIcon, DiscFullIcon, DiscordIcon, DiscountIcon, DisplaySettingsIcon, Diversity1Icon, Diversity2Icon, Diversity3Icon, DndForwardslashIcon, DnsIcon, DoDisturbAltIcon, DoDisturbIcon, DoDisturbOffIcon, DoDisturbOnIcon, DoNotDisturbAltIcon, DoNotDisturbIcon, DoNotDisturbOffIcon, DoNotDisturbOnIcon, DoNotDisturbOnTotalSilenceIcon, DoNotStepIcon, DoNotTouchIcon, DockIcon, DocumentScannerIcon, DomainAddIcon, DomainDisabledIcon, DomainIcon, DomainVerificationIcon, DoneAllIcon, DoneIcon, DoneOutlineIcon, DonutLargeIcon, DonutSmallIcon, DoorBackIcon, DoorFrontIcon, DoorSlidingIcon, DoorbellIcon, DoubleArrowIcon, DownhillSkiingIcon, DownloadDoneIcon, DownloadForOfflineIcon, DownloadIcon, DownloadingIcon, DraftsIcon, DragHandleIcon, DragIndicatorIcon, DrawIcon, DriveEtaIcon, DriveFileMoveIcon, DriveFileMoveRtlIcon, DriveFileRenameOutlineIcon, DriveFolderUploadIcon, DryCleaningIcon, DryIcon, DuoIcon, DvrIcon, DynamicFeedIcon, DynamicFormIcon, EMobiledataIcon, EarbudsBatteryIcon, EarbudsIcon, EastIcon, EcoIcon, EdgesensorHighIcon, EdgesensorLowIcon, EditAttributesIcon, EditCalendarIcon, EditIcon, EditLocationAltIcon, EditLocationIcon, EditNoteIcon, EditNotificationsIcon, EditOffIcon, EditRoadIcon, EggAltIcon, EggIcon, EjectIcon, ElderlyIcon, ElderlyWomanIcon, ElectricBikeIcon, ElectricBoltIcon, ElectricCarIcon, ElectricMeterIcon, ElectricMopedIcon, ElectricRickshawIcon, ElectricScooterIcon, ElectricalServicesIcon, ElevatorIcon, EmailIcon, EmergencyIcon, EmergencyRecordingIcon, EmergencyShareIcon, EmojiEmotionsIcon, EmojiEventsIcon, EmojiFlagsIcon, EmojiFoodBeverageIcon, EmojiNatureIcon, EmojiObjectsIcon, EmojiPeopleIcon, EmojiSymbolsIcon, EmojiTransportationIcon, EnergySavingsLeafIcon, EngineeringIcon, EnhancePhotoTranslateIcon, EnhancedEncryptionIcon, EqualizerIcon, ErrorIcon, ErrorOutlineIcon, EscalatorIcon, EscalatorWarningIcon, EuroIcon, EuroSymbolIcon, EvStationIcon, EventAvailableIcon, EventBusyIcon, EventIcon, EventNoteIcon, EventRepeatIcon, EventSeatIcon, ExitToAppIcon, ExpandCircleDownIcon, ExpandIcon, ExpandLessIcon, ExpandMoreIcon, ExpandablePanel, ExplicitIcon, ExploreIcon, ExploreOffIcon, ExposureIcon, ExposureMinus1Icon, ExposureMinus2Icon, ExposureNeg1Icon, ExposureNeg2Icon, ExposurePlus1Icon, ExposurePlus2Icon, ExposureZeroIcon, ExtensionIcon, ExtensionOffIcon, Face2Icon, Face3Icon, Face4Icon, Face5Icon, Face6Icon, FaceIcon, FaceRetouchingNaturalIcon, FaceRetouchingOffIcon, FaceUnlockIcon, FacebookIcon, FactCheckIcon, FactoryIcon, FamilyRestroomIcon, FastForwardIcon, FastRewindIcon, FastfoodIcon, FavoriteBorderIcon, FavoriteIcon, FavoriteOutlineIcon, FaxIcon, FeaturedPlayListIcon, FeaturedVideoIcon, FeedIcon, FeedbackIcon, FemaleIcon, FenceIcon, FestivalIcon, FiberDvrIcon, FiberManualRecordIcon, FiberNewIcon, FiberPinIcon, FiberSmartRecordIcon, FileCopyIcon, FileDownloadDoneIcon, FileDownloadIcon, FileDownloadOffIcon, FileOpenIcon, FilePresentIcon, FileUpload, FileUploadIcon, Filter1Icon, Filter2Icon, Filter3Icon, Filter4Icon, Filter5Icon, Filter6Icon, Filter7Icon, Filter8Icon, Filter9Icon, Filter9PlusIcon, FilterAltIcon, FilterAltOffIcon, FilterBAndWIcon, FilterCenterFocusIcon, FilterDramaIcon, FilterFramesIcon, FilterHdrIcon, FilterIcon, FilterListIcon, FilterListOffIcon, FilterNoneIcon, FilterTiltShiftIcon, FilterVintageIcon, FindInPageIcon, FindReplaceIcon, FingerprintIcon, FireExtinguisherIcon, FireHydrantAltIcon, FireTruckIcon, FireplaceIcon, FirstPageIcon, FitScreenIcon, FitbitIcon, FitnessCenterIcon, FlagCircleIcon, FlagIcon, FlakyIcon, FlareIcon, FlashAutoIcon, FlashOffIcon, FlashOnIcon, FlashlightOffIcon, FlashlightOnIcon, FlatwareIcon, FlightClassIcon, FlightIcon, FlightLandIcon, FlightTakeoffIcon, FlipCameraAndroidIcon, FlipCameraIosIcon, FlipIcon, FlipToBackIcon, FlipToFrontIcon, FloodIcon, FlourescentIcon, FluorescentIcon, FlutterDashIcon, FmdBadIcon, FmdGoodIcon, FolderCopyIcon, FolderDeleteIcon, FolderIcon, FolderOffIcon, FolderOpenIcon, FolderSharedIcon, FolderSpecialIcon, FolderZipIcon, FollowTheSignsIcon, FontDownloadIcon, FontDownloadOffIcon, FoodBankIcon, ForestIcon, ForkLeftIcon, ForkRightIcon, FormatAlignCenterIcon, FormatAlignJustifyIcon, FormatAlignLeftIcon, FormatAlignRightIcon, FormatBoldIcon, FormatClearIcon, FormatColorFillIcon, FormatColorResetIcon, FormatColorTextIcon, FormatIndentDecreaseIcon, FormatIndentIncreaseIcon, FormatItalicIcon, FormatLineSpacingIcon, FormatListBulletedIcon, FormatListNumberedIcon, FormatListNumberedRtlIcon, FormatOverlineIcon, FormatPaintIcon, FormatQuoteIcon, FormatShapesIcon, FormatSizeIcon, FormatStrikethroughIcon, FormatTextdirectionLToRIcon, FormatTextdirectionRToLIcon, FormatUnderlineIcon, FormatUnderlinedIcon, FortIcon, ForumIcon, Forward10Icon, Forward30Icon, Forward5Icon, ForwardIcon, ForwardToInboxIcon, FoundationIcon, FreeBreakfastIcon, FreeCancellationIcon, FrontHandIcon, FullscreenExitIcon, FullscreenIcon, FunctionsIcon, GMobiledataIcon, GTranslateIcon, GamepadIcon, GamesIcon, GarageIcon, GasMeterIcon, GavelIcon, GeneratingTokensIcon, GestureIcon, GetAppIcon, GifBoxIcon, GifIcon, GirlIcon, GitHubIcon, GiteIcon, GolfCourseIcon, GppBadIcon, GppGoodIcon, GppMaybeIcon, GpsFixedIcon, GpsNotFixedIcon, GpsOffIcon, GradeIcon, GradientIcon, GradingIcon, GrainIcon, GraphicEqIcon, GrassIcon, Grid3x3Icon, Grid4x4Icon, GridGoldenratioIcon, GridOffIcon, GridOnIcon, GridViewIcon, GroupAddIcon, GroupIcon, GroupOffIcon, GroupRemoveIcon, GroupWorkIcon, Groups2Icon, Groups3Icon, GroupsIcon, HMobiledataIcon, HPlusMobiledataIcon, HailIcon, HandleIcon, HandshakeIcon, HandymanIcon, HardwareIcon, HdIcon, HdrAutoIcon, HdrAutoSelectIcon, HdrEnhancedSelectIcon, HdrOffIcon, HdrOffSelectIcon, HdrOnIcon, HdrOnSelectIcon, HdrPlusIcon, HdrStrongIcon, HdrWeakIcon, HeadphonesBatteryIcon, HeadphonesIcon, HeadsetIcon, HeadsetMicIcon, HeadsetOffIcon, HealingIcon, HealthAndSafetyIcon, HearingDisabledIcon, HearingIcon, HeartBrokenIcon, HeatPumpIcon, HeightIcon, HelpCenterIcon, HelpIcon, HelpOutlineIcon, HevcIcon, HexagonIcon, HideImageIcon, HideSourceIcon, HighQualityIcon, HighlightAltIcon, HighlightIcon, HighlightOffIcon, HighlightRemoveIcon, HikingIcon, HistoryEduIcon, HistoryIcon, HistoryToggleOffIcon, HiveIcon, HlsIcon, HlsOffIcon, HolidayVillageIcon, HomeIcon, HomeMaxIcon, HomeMiniIcon, HomeRepairServiceIcon, HomeWorkIcon, HorizontalDistributeIcon, HorizontalRuleIcon, HorizontalSplitIcon, HotTubIcon, HotelClassIcon, HotelIcon, HourglassBottomIcon, HourglassDisabledIcon, HourglassEmptyIcon, HourglassFullIcon, HourglassTopIcon, HouseIcon, HouseSidingIcon, HouseboatIcon, HowToRegIcon, HowToVoteIcon, HtmlIcon, HttpIcon, HttpsIcon, HubIcon, HvacIcon, IceSkatingIcon, IcecreamIcon, Icon, IconButton, ImageAspectRatioIcon, ImageIcon, ImageNotSupportedIcon, ImageSearchIcon, ImagesearchRollerIcon, ImportContactsIcon, ImportExportIcon, ImportantDevicesIcon, InboxIcon, IncompleteCircleIcon, IndeterminateCheckBoxIcon, InfoIcon, InfoLabel, InfoOutlineIcon, InputIcon, InputLabel, InsertChartIcon, InsertChartOutlinedIcon, InsertCommentIcon, InsertDriveFileIcon, InsertEmoticonIcon, InsertInvitationIcon, InsertLinkIcon, InsertPageBreakIcon, InsertPhotoIcon, InsightsIcon, InstallDesktopIcon, InstallMobileIcon, IntegrationInstructionsIcon, InterestsIcon, InterpreterModeIcon, Inventory2Icon, InventoryIcon, InvertColorsIcon, InvertColorsOffIcon, InvertColorsOnIcon, IosShareIcon, IronIcon, IsoIcon, JavascriptIcon, JoinFullIcon, JoinInnerIcon, JoinLeftIcon, JoinRightIcon, KayakingIcon, KebabDiningIcon, KeyIcon, KeyOffIcon, KeyboardAltIcon, KeyboardArrowDownIcon, KeyboardArrowLeftIcon, KeyboardArrowRightIcon, KeyboardArrowUpIcon, KeyboardBackspaceIcon, KeyboardCapslockIcon, KeyboardCommandKeyIcon, KeyboardControlIcon, KeyboardControlKeyIcon, KeyboardDoubleArrowDownIcon, KeyboardDoubleArrowLeftIcon, KeyboardDoubleArrowRightIcon, KeyboardDoubleArrowUpIcon, KeyboardHideIcon, KeyboardIcon, KeyboardOptionKeyIcon, KeyboardReturnIcon, KeyboardTabIcon, KeyboardVoiceIcon, KingBedIcon, KitchenIcon, KitesurfingIcon, Label, LabelIcon, LabelImportantIcon, LabelImportantOutlineIcon, LabelOffIcon, LabelOutlineIcon, LanIcon, LandscapeIcon, LandslideIcon, LanguageIcon, LaptopChromebookIcon, LaptopIcon, LaptopMacIcon, LaptopWindowsIcon, LastPageIcon, LaunchIcon, LayersClearIcon, LayersIcon, LeaderboardIcon, LeakAddIcon, LeakRemoveIcon, LeaveBagsAtHomeIcon, LegendToggleIcon, LensBlurIcon, LensIcon, LibraryAddCheckIcon, LibraryAddIcon, LibraryBooksIcon, LibraryMusicIcon, LightIcon, LightModeIcon, LightbulbCircleIcon, LightbulbIcon, LightbulbOutlineIcon, LineAxisIcon, LineStyleIcon, LineWeightIcon, LinearScaleIcon, LinkIcon, LinkOffIcon, LinkedCameraIcon, LiquorIcon, ListAltIcon, ListIcon, LiveHelpIcon, LiveTvIcon, LivingIcon, LoadingButton, LocalActivityIcon, LocalAirportIcon, LocalAtmIcon, LocalAttractionIcon, LocalBarIcon, LocalCafeIcon, LocalCarWashIcon, LocalConvenienceStoreIcon, LocalDiningIcon, LocalDrinkIcon, LocalFireDepartmentIcon, LocalFloristIcon, LocalGasStationIcon, LocalGroceryStoreIcon, LocalHospitalIcon, LocalHotelIcon, LocalLaundryServiceIcon, LocalLibraryIcon, LocalMallIcon, LocalMoviesIcon, LocalOfferIcon, LocalParkingIcon, LocalPharmacyIcon, LocalPhoneIcon, LocalPizzaIcon, LocalPlayIcon, LocalPoliceIcon, LocalPostOfficeIcon, LocalPrintshopIcon, LocalRestaurantIcon, LocalSeeIcon, LocalShippingIcon, LocalTaxiIcon, LocationCityIcon, LocationDisabledIcon, LocationHistoryIcon, LocationOffIcon, LocationOnIcon, LocationSearchingIcon, LockClockIcon, LockIcon, LockOpenIcon, LockOutlineIcon, LockPersonIcon, LockResetIcon, LoginIcon, LogoDevIcon, LogoutIcon, Looks3Icon, Looks4Icon, Looks5Icon, Looks6Icon, LooksIcon, LooksOneIcon, LooksTwoIcon, LoopIcon, LoupeIcon, LowPriorityIcon, LoyaltyIcon, LteMobiledataIcon, LtePlusMobiledataIcon, LuggageIcon, LunchDiningIcon, LyricsIcon, MacroOffIcon, MailIcon, MailLockIcon, MailOutlineIcon, MaleIcon, Man2Icon, Man3Icon, Man4Icon, ManIcon, ManageAccountsIcon, ManageHistoryIcon, ManageSearchIcon, MapIcon, MapsHomeWorkIcon, MapsUgcIcon, MarginIcon, MarkAsUnreadIcon, MarkChatReadIcon, MarkChatUnreadIcon, MarkEmailReadIcon, MarkEmailUnreadIcon, MarkUnreadChatAltIcon, Markdown, MarkunreadIcon, MarkunreadMailboxIcon, MasksIcon, MaximizeIcon, MediaBluetoothOffIcon, MediaBluetoothOnIcon, MediationIcon, MedicalInformationIcon, MedicalServicesIcon, MedicationIcon, MedicationLiquidIcon, MeetingRoomIcon, MemoryIcon, Menu, MenuBookIcon, MenuIcon, MenuItem, MenuOpenIcon, Menubar, MenubarCheckboxItem, MenubarContent, MenubarItem, MenubarItemIndicator, MenubarMenu, MenubarPortal, MenubarRadioGroup, MenubarRadioItem, MenubarSeparator, MenubarShortcut, MenubarSub, MenubarSubContent, MenubarSubTrigger, MenubarSubTriggerIndicator, MenubarTrigger, MergeIcon, MergeTypeIcon, MessageIcon, MessengerIcon, MessengerOutlineIcon, MicExternalOffIcon, MicExternalOnIcon, MicIcon, MicNoneIcon, MicOffIcon, MicrowaveIcon, MilitaryTechIcon, MinimizeIcon, MinorCrashIcon, MiscellaneousServicesIcon, MissedVideoCallIcon, MmsIcon, MobileFriendlyIcon, MobileOffIcon, MobileScreenShareIcon, MobiledataOffIcon, ModeCommentIcon, ModeEditIcon, ModeEditOutlineIcon, ModeFanOffIcon, ModeIcon, ModeNightIcon, ModeOfTravelIcon, ModeStandbyIcon, ModelTrainingIcon, MonetizationOnIcon, MoneyIcon, MoneyOffCsredIcon, MoneyOffIcon, MonitorHeartIcon, MonitorIcon, MonitorWeightIcon, MonochromePhotosIcon, MoodBadIcon, MoodIcon, MopedIcon, MoreHorizIcon, MoreIcon, MoreTimeIcon, MoreVertIcon, MosqueIcon, MotionPhotosAutoIcon, MotionPhotosOffIcon, MotionPhotosOnIcon, MotionPhotosPauseIcon, MotionPhotosPausedIcon, MotorcycleIcon, MouseIcon, MoveDownIcon, MoveToInboxIcon, MoveUpIcon, MovieCreationIcon, MovieFilterIcon, MovieIcon, MovingIcon, MpIcon, MultiSelect, MultiSelectContext, MultiSelectItem, MultilineChartIcon, MultipleStopIcon, MultitrackAudioIcon, MuseumIcon, MusicNoteIcon, MusicOffIcon, MusicVideoIcon, MyLibraryAddIcon, MyLibraryBooksIcon, MyLibraryMusicIcon, MyLocationIcon, NatIcon, NatureIcon, NaturePeopleIcon, NavigateBeforeIcon, NavigateNextIcon, NavigationIcon, NearMeDisabledIcon, NearMeIcon, NearbyErrorIcon, NearbyOffIcon, NestCamWiredStandIcon, NetworkCellIcon, NetworkCheckIcon, NetworkLockedIcon, NetworkPingIcon, NetworkWifi1BarIcon, NetworkWifi2BarIcon, NetworkWifi3BarIcon, NetworkWifiIcon, NewLabelIcon, NewReleasesIcon, NewspaperIcon, NextPlanIcon, NextWeekIcon, NfcIcon, NightShelterIcon, NightlifeIcon, NightlightIcon, NightlightRoundIcon, NightsStayIcon, NoAccountsIcon, NoAdultContentIcon, NoBackpackIcon, NoCellIcon, NoCrashIcon, NoDrinksIcon, NoEncryptionGmailerrorredIcon, NoEncryptionIcon, NoFlashIcon, NoFoodIcon, NoLuggageIcon, NoMealsIcon, NoMeetingRoomIcon, NoPhotographyIcon, NoSimIcon, NoStrollerIcon, NoTransferIcon, NoiseAwareIcon, NoiseControlOffIcon, NordicWalkingIcon, NorthEastIcon, NorthIcon, NorthWestIcon, NotAccessibleIcon, NotInterestedIcon, NotListedLocationIcon, NotStartedIcon, NoteAddIcon, NoteAltIcon, NoteIcon, NotesIcon, NotificationAddIcon, NotificationImportantIcon, NotificationsActiveIcon, NotificationsIcon, NotificationsNoneIcon, NotificationsOffIcon, NotificationsOnIcon, NotificationsPausedIcon, NowWallpaperIcon, NowWidgetsIcon, NumbersIcon, OfflineBoltIcon, OfflinePinIcon, OfflineShareIcon, OilBarrelIcon, OnDeviceTrainingIcon, OndemandVideoIcon, OnlinePredictionIcon, OpacityIcon, OpenInBrowserIcon, OpenInFullIcon, OpenInNewIcon, OpenInNewOffIcon, OpenWithIcon, OtherHousesIcon, OutbondIcon, OutboundIcon, OutboxIcon, OutdoorGrillIcon, OutletIcon, OutlinedFlagIcon, OutputIcon, PaddingIcon, PagesIcon, PageviewIcon, PaidIcon, PaletteIcon, PanToolAltIcon, PanToolIcon, PanoramaFisheyeIcon, PanoramaHorizontalIcon, PanoramaHorizontalSelectIcon, PanoramaIcon, PanoramaPhotosphereIcon, PanoramaPhotosphereSelectIcon, PanoramaVerticalIcon, PanoramaVerticalSelectIcon, PanoramaWideAngleIcon, PanoramaWideAngleSelectIcon, Paper, ParaglidingIcon, ParkIcon, PartyModeIcon, PasswordIcon, PasteIcon, PatternIcon, PauseCircleFilledIcon, PauseCircleIcon, PauseCircleOutlineIcon, PauseIcon, PausePresentationIcon, PaymentIcon, PaymentsIcon, PaypalIcon, PedalBikeIcon, PendingActionsIcon, PendingIcon, PentagonIcon, PeopleAltIcon, PeopleIcon, PeopleOutlineIcon, PercentIcon, PermCameraMicIcon, PermContactCalIcon, PermContactCalendarIcon, PermDataSettingIcon, PermDeviceInfoIcon, PermDeviceInformationIcon, PermIdentityIcon, PermMediaIcon, PermPhoneMsgIcon, PermScanWifiIcon, Person2Icon, Person3Icon, Person4Icon, PersonAddAlt1Icon, PersonAddAltIcon, PersonAddDisabledIcon, PersonAddIcon, PersonIcon, PersonOffIcon, PersonOutlineIcon, PersonPinCircleIcon, PersonPinIcon, PersonRemoveAlt1Icon, PersonRemoveIcon, PersonSearchIcon, PersonalInjuryIcon, PersonalVideoIcon, PestControlIcon, PestControlRodentIcon, PetsIcon, PhishingIcon, PhoneAndroidIcon, PhoneBluetoothSpeakerIcon, PhoneCallbackIcon, PhoneDisabledIcon, PhoneEnabledIcon, PhoneForwardedIcon, PhoneIcon, PhoneInTalkIcon, PhoneIphoneIcon, PhoneLockedIcon, PhoneMissedIcon, PhonePausedIcon, PhonelinkEraseIcon, PhonelinkIcon, PhonelinkLockIcon, PhonelinkOffIcon, PhonelinkRingIcon, PhonelinkSetupIcon, PhotoAlbumIcon, PhotoCameraBackIcon, PhotoCameraFrontIcon, PhotoCameraIcon, PhotoFilterIcon, PhotoIcon, PhotoLibraryIcon, PhotoSizeSelectActualIcon, PhotoSizeSelectLargeIcon, PhotoSizeSelectSmallIcon, PhpIcon, PianoIcon, PianoOffIcon, PictureAsPdfIcon, PictureInPictureAltIcon, PictureInPictureIcon, PieChartIcon, PieChartOutlineIcon, PinDropIcon, PinEndIcon, PinIcon, PinInvokeIcon, PinchIcon, PivotTableChartIcon, PixIcon, PlaceIcon, PlagiarismIcon, PlayArrowIcon, PlayCircleFillIcon, PlayCircleFilledIcon, PlayCircleIcon, PlayCircleOutlineIcon, PlayDisabledIcon, PlayForWorkIcon, PlayLessonIcon, PlaylistAddCheckCircleIcon, PlaylistAddCheckIcon, PlaylistAddCircleIcon, PlaylistAddIcon, PlaylistPlayIcon, PlaylistRemoveIcon, PlumbingIcon, PlusOneIcon, PodcastsIcon, PointOfSaleIcon, PolicyIcon, PollIcon, PolylineIcon, PolymerIcon, PoolIcon, Popover, PortableWifiOffIcon, PortraitIcon, PostAddIcon, PowerIcon, PowerInputIcon, PowerOffIcon, PowerSettingsNewIcon, PrecisionManufacturingIcon, PregnantWomanIcon, PresentToAllIcon, PreviewIcon, PriceChangeIcon, PriceCheckIcon, PrintDisabledIcon, PrintIcon, PriorityHighIcon, PrivacyTipIcon, PrivateConnectivityIcon, ProductionQuantityLimitsIcon, PropaneIcon, PropaneTankIcon, PsychologyAltIcon, PsychologyIcon, PublicIcon, PublicOffIcon, PublishIcon, PublishedWithChangesIcon, PunchClockIcon, PushPinIcon, QrCode2Icon, QrCodeIcon, QrCodeScannerIcon, QueryBuilderIcon, QueryStatsIcon, QuestionAnswerIcon, QuestionMarkIcon, QueueIcon, QueueMusicIcon, QueuePlayNextIcon, QuickContactsDialerIcon, QuickContactsMailIcon, QuickreplyIcon, QuizIcon, QuoraIcon, RMobiledataIcon, RadarIcon, RadioButtonCheckedIcon, RadioButtonOffIcon, RadioButtonOnIcon, RadioButtonUncheckedIcon, RadioGroup, RadioGroupItem, RadioIcon, RailwayAlertIcon, RamenDiningIcon, RampLeftIcon, RampRightIcon, RateReviewIcon, RawOffIcon, RawOnIcon, ReadMoreIcon, RealEstateAgentIcon, ReceiptIcon, ReceiptLongIcon, RecentActorsIcon, RecommendIcon, RecordVoiceOverIcon, RectangleIcon, RecyclingIcon, RedditIcon, RedeemIcon, RedoIcon, ReduceCapacityIcon, RefreshIcon, RememberMeIcon, RemoveCircleIcon, RemoveCircleOutlineIcon, RemoveDoneIcon, RemoveFromQueueIcon, RemoveIcon, RemoveModeratorIcon, RemoveRedEyeIcon, RemoveRoadIcon, RemoveShoppingCartIcon, ReorderIcon, RepartitionIcon, RepeatIcon, RepeatOnIcon, RepeatOneIcon, RepeatOneOnIcon, Replay10Icon, Replay30Icon, Replay5Icon, ReplayCircleFilledIcon, ReplayIcon, ReplyAllIcon, ReplyIcon, ReportGmailerrorredIcon, ReportIcon, ReportOffIcon, ReportProblemIcon, RequestPageIcon, RequestQuoteIcon, ResetTvIcon, RestartAltIcon, RestaurantIcon, RestaurantMenuIcon, RestoreFromTrashIcon, RestoreIcon, RestorePageIcon, ReviewsIcon, RiceBowlIcon, RingVolumeIcon, RocketIcon, RocketLaunchIcon, RollerShadesClosedIcon, RollerShadesIcon, RollerSkatingIcon, RoofingIcon, RoomIcon, RoomPreferencesIcon, RoomServiceIcon, Rotate90DegreesCcwIcon, Rotate90DegreesCwIcon, RotateLeftIcon, RotateRightIcon, RoundaboutLeftIcon, RoundaboutRightIcon, RoundedCornerIcon, RouteIcon, RouterIcon, RowingIcon, RssFeedIcon, RsvpIcon, RttIcon, RuleFolderIcon, RuleIcon, RunCircleIcon, RunningWithErrorsIcon, RvHookupIcon, SafetyCheckIcon, SafetyDividerIcon, SailingIcon, SanitizerIcon, SatelliteAltIcon, SatelliteIcon, SaveAltIcon, SaveAsIcon, SaveIcon, SavedSearchIcon, SavingsIcon, ScaleIcon, ScannerIcon, ScatterPlotIcon, ScheduleIcon, ScheduleSendIcon, SchemaIcon, SchoolIcon, ScienceIcon, ScoreIcon, ScoreboardIcon, ScreenLockLandscapeIcon, ScreenLockPortraitIcon, ScreenLockRotationIcon, ScreenRotationAltIcon, ScreenRotationIcon, ScreenSearchDesktopIcon, ScreenShareIcon, ScreenshotIcon, ScreenshotMonitorIcon, ScubaDivingIcon, SdCardAlertIcon, SdCardIcon, SdIcon, SdStorageIcon, SearchBar, SearchIcon, SearchOffIcon, SecurityIcon, SecurityUpdateGoodIcon, SecurityUpdateIcon, SecurityUpdateWarningIcon, SegmentIcon, Select, SelectAllIcon, SelectGroup, SelectItem, SelfImprovementIcon, SellIcon, SendAndArchiveIcon, SendIcon, SendTimeExtensionIcon, SendToMobileIcon, SensorDoorIcon, SensorOccupiedIcon, SensorWindowIcon, SensorsIcon, SensorsOffIcon, SentimentDissatisfiedIcon, SentimentNeutralIcon, SentimentSatisfiedAltIcon, SentimentSatisfiedIcon, SentimentVeryDissatisfiedIcon, SentimentVerySatisfiedIcon, Separator, SetMealIcon, SettingsAccessibilityIcon, SettingsApplicationsIcon, SettingsBackupRestoreIcon, SettingsBluetoothIcon, SettingsBrightnessIcon, SettingsCellIcon, SettingsDisplayIcon, SettingsEthernetIcon, SettingsIcon, SettingsInputAntennaIcon, SettingsInputComponentIcon, SettingsInputCompositeIcon, SettingsInputHdmiIcon, SettingsInputSvideoIcon, SettingsOverscanIcon, SettingsPhoneIcon, SettingsPowerIcon, SettingsRemoteIcon, SettingsSuggestIcon, SettingsSystemDaydreamIcon, SettingsVoiceIcon, SevereColdIcon, ShapeLineIcon, ShareArrivalTimeIcon, ShareIcon, ShareLocationIcon, Sheet, ShieldIcon, ShieldMoonIcon, Shop2Icon, ShopIcon, ShopTwoIcon, ShopifyIcon, ShoppingBagIcon, ShoppingBasketIcon, ShoppingCartCheckoutIcon, ShoppingCartIcon, ShortTextIcon, ShortcutIcon, ShowChartIcon, ShowerIcon, ShuffleIcon, ShuffleOnIcon, ShutterSpeedIcon, SickIcon, SignLanguageIcon, SignalCellular0BarIcon, SignalCellular4BarIcon, SignalCellularAlt1BarIcon, SignalCellularAlt2BarIcon, SignalCellularAltIcon, SignalCellularConnectedNoInternet0BarIcon, SignalCellularConnectedNoInternet4BarIcon, SignalCellularNoSimIcon, SignalCellularNodataIcon, SignalCellularNullIcon, SignalCellularOffIcon, SignalWifi0BarIcon, SignalWifi4BarIcon, SignalWifi4BarLockIcon, SignalWifiBadIcon, SignalWifiConnectedNoInternet4Icon, SignalWifiOffIcon, SignalWifiStatusbar4BarIcon, SignalWifiStatusbarConnectedNoInternet4Icon, SignalWifiStatusbarNullIcon, SignpostIcon, SimCardAlertIcon, SimCardDownloadIcon, SimCardIcon, SingleBedIcon, SipIcon, SkateboardingIcon, Skeleton, SkipNextIcon, SkipPreviousIcon, SleddingIcon, Slider, SlideshowIcon, SlowMotionVideoIcon, SmartButtonIcon, SmartDisplayIcon, SmartScreenIcon, SmartToyIcon, SmartphoneIcon, SmokeFreeIcon, SmokingRoomsIcon, SmsFailedIcon, SmsIcon, SnapchatIcon, SnippetFolderIcon, SnoozeIcon, SnowboardingIcon, SnowmobileIcon, SnowshoeingIcon, SoapIcon, SocialDistanceIcon, SolarPowerIcon, SortByAlphaIcon, SortIcon, SosIcon, SoupKitchenIcon, SourceIcon, SouthAmericaIcon, SouthEastIcon, SouthIcon, SouthWestIcon, SpaIcon, SpaceBarIcon, SpaceDashboardIcon, SpatialAudioIcon, SpatialAudioOffIcon, SpatialTrackingIcon, SpeakerGroupIcon, SpeakerIcon, SpeakerNotesIcon, SpeakerNotesOffIcon, SpeakerPhoneIcon, SpeedIcon, SpellcheckIcon, SplitscreenIcon, SpokeIcon, SportsBarIcon, SportsBaseballIcon, SportsBasketballIcon, SportsCricketIcon, SportsEsportsIcon, SportsFootballIcon, SportsGolfIcon, SportsGymnasticsIcon, SportsHandballIcon, SportsHockeyIcon, SportsIcon, SportsKabaddiIcon, SportsMartialArtsIcon, SportsMmaIcon, SportsMotorsportsIcon, SportsRugbyIcon, SportsScoreIcon, SportsSoccerIcon, SportsTennisIcon, SportsVolleyballIcon, SquareFootIcon, SquareIcon, SsidChartIcon, StackedBarChartIcon, StackedLineChartIcon, StadiumIcon, StairsIcon, StarBorderIcon, StarBorderPurple500Icon, StarHalfIcon, StarIcon, StarOutlineIcon, StarPurple500Icon, StarRateIcon, StarsIcon, StartIcon, StayCurrentLandscapeIcon, StayCurrentPortraitIcon, StayPrimaryLandscapeIcon, StayPrimaryPortraitIcon, StickyNote2Icon, StopCircleIcon, StopIcon, StopScreenShareIcon, StorageIcon, StoreIcon, StoreMallDirectoryIcon, StorefrontIcon, StormIcon, StraightIcon, StraightenIcon, StreamIcon, StreetviewIcon, StrikethroughSIcon, StrollerIcon, StyleIcon, SubdirectoryArrowLeftIcon, SubdirectoryArrowRightIcon, SubjectIcon, SubscriptIcon, SubscriptionsIcon, SubtitlesIcon, SubtitlesOffIcon, SubwayIcon, SummarizeIcon, SuperscriptIcon, SupervisedUserCircleIcon, SupervisorAccountIcon, SupportAgentIcon, SupportIcon, SurfingIcon, SurroundSoundIcon, SwapCallsIcon, SwapHorizIcon, SwapHorizontalCircleIcon, SwapVertCircleIcon, SwapVertIcon, SwapVerticalCircleIcon, SwipeDownAltIcon, SwipeDownIcon, SwipeIcon, SwipeLeftAltIcon, SwipeLeftIcon, SwipeRightAltIcon, SwipeRightIcon, SwipeUpAltIcon, SwipeUpIcon, SwipeVerticalIcon, SwitchAccessShortcutAddIcon, SwitchAccessShortcutIcon, SwitchAccountIcon, SwitchCameraIcon, SwitchLeftIcon, SwitchRightIcon, SwitchVideoIcon, SynagogueIcon, SyncAltIcon, SyncDisabledIcon, SyncIcon, SyncLockIcon, SyncProblemIcon, SystemSecurityUpdateGoodIcon, SystemSecurityUpdateIcon, SystemSecurityUpdateWarningIcon, SystemUpdateAltIcon, SystemUpdateIcon, SystemUpdateTvIcon, Tab, TabIcon, TabUnselectedIcon, Table, TableBarIcon, TableBody, TableCell, TableChartIcon, TableHeader, TableRestaurantIcon, TableRow, TableRowsIcon, TableViewIcon, TabletAndroidIcon, TabletIcon, TabletMacIcon, Tabs, TagFacesIcon, TagIcon, TakeoutDiningIcon, TapAndPlayIcon, TapasIcon, TaskAltIcon, TaskIcon, TaxiAlertIcon, TelegramIcon, TempleBuddhistIcon, TempleHinduIcon, TerminalIcon, TerrainIcon, TextDecreaseIcon, TextField, TextFieldsIcon, TextFormatIcon, TextIncreaseIcon, TextRotateUpIcon, TextRotateVerticalIcon, TextRotationAngledownIcon, TextRotationAngleupIcon, TextRotationDownIcon, TextRotationNoneIcon, TextSnippetIcon, TextareaAutosize, TextsmsIcon, TextureIcon, TheaterComedyIcon, TheatersIcon, ThermostatAutoIcon, ThermostatIcon, ThumbDownAltIcon, ThumbDownIcon, ThumbDownOffAltIcon, ThumbUpAltIcon, ThumbUpIcon, ThumbUpOffAltIcon, ThumbsUpDownIcon, ThunderstormIcon, TiktokIcon, TimeToLeaveIcon, TimelapseIcon, TimelineIcon, Timer10Icon, Timer10SelectIcon, Timer3Icon, Timer3SelectIcon, TimerIcon, TimerOffIcon, TipsAndUpdatesIcon, TireRepairIcon, TitleIcon, TocIcon, TodayIcon, ToggleOffIcon, ToggleOnIcon, TokenIcon, TollIcon, TonalityIcon, Tooltip, TopicIcon, TornadoIcon, TouchAppIcon, TourIcon, ToysIcon, TrackChangesIcon, TrafficIcon, TrainIcon, TramIcon, TranscribeIcon, TransferWithinAStationIcon, TransformIcon, TransgenderIcon, TransitEnterexitIcon, TranslateIcon, TravelExploreIcon, TrendingDownIcon, TrendingFlatIcon, TrendingNeutralIcon, TrendingUpIcon, TripOriginIcon, TroubleshootIcon, TryIcon, TsunamiIcon, TtyIcon, TuneIcon, TungstenIcon, TurnLeftIcon, TurnRightIcon, TurnSharpLeftIcon, TurnSharpRightIcon, TurnSlightLeftIcon, TurnSlightRightIcon, TurnedInIcon, TurnedInNotIcon, TvIcon, TvOffIcon, TwoWheelerIcon, TypeSpecimenIcon, Typography, UTurnLeftIcon, UTurnRightIcon, UmbrellaIcon, UnarchiveIcon, UndoIcon, UnfoldLessDoubleIcon, UnfoldLessIcon, UnfoldMoreDoubleIcon, UnfoldMoreIcon, UnpublishedIcon, UnsubscribeIcon, UpcomingIcon, UpdateDisabledIcon, UpdateIcon, UpgradeIcon, UploadFileIcon, UploadIcon, UsbIcon, UsbOffIcon, VaccinesIcon, VapeFreeIcon, VapingRoomsIcon, VerifiedIcon, VerifiedUserIcon, VerticalAlignBottomIcon, VerticalAlignCenterIcon, VerticalAlignTopIcon, VerticalDistributeIcon, VerticalShadesClosedIcon, VerticalShadesIcon, VerticalSplitIcon, VibrationIcon, VideoCallIcon, VideoCameraBackIcon, VideoCameraFrontIcon, VideoChatIcon, VideoCollectionIcon, VideoFileIcon, VideoLabelIcon, VideoLibraryIcon, VideoSettingsIcon, VideoStableIcon, VideocamIcon, VideocamOffIcon, VideogameAssetIcon, VideogameAssetOffIcon, ViewAgendaIcon, ViewArrayIcon, ViewCarouselIcon, ViewColumnIcon, ViewComfortableIcon, ViewComfyAltIcon, ViewComfyIcon, ViewCompactAltIcon, ViewCompactIcon, ViewCozyIcon, ViewDayIcon, ViewHeadlineIcon, ViewInArIcon, ViewKanbanIcon, ViewListIcon, ViewModuleIcon, ViewQuiltIcon, ViewSidebarIcon, ViewStreamIcon, ViewTimelineIcon, ViewWeekIcon, VignetteIcon, VillaIcon, VisibilityIcon, VisibilityOffIcon, VoiceChatIcon, VoiceOverOffIcon, VoicemailIcon, VolcanoIcon, VolumeDownIcon, VolumeMuteIcon, VolumeOffIcon, VolumeUpIcon, VolunteerActivismIcon, VpnKeyIcon, VpnKeyOffIcon, VpnLockIcon, VrpanoIcon, WalletGiftcardIcon, WalletIcon, WalletMembershipIcon, WalletTravelIcon, WallpaperIcon, WarehouseIcon, WarningAmberIcon, WarningIcon, WashIcon, WatchIcon, WatchLaterIcon, WatchOffIcon, WaterDamageIcon, WaterDropIcon, WaterIcon, WaterfallChartIcon, WavesIcon, WavingHandIcon, WbAutoIcon, WbCloudyIcon, WbIncandescentIcon, WbIridescentIcon, WbShadeIcon, WbSunnyIcon, WbTwilightIcon, WcIcon, WebAssetIcon, WebAssetOffIcon, WebIcon, WebStoriesIcon, WebhookIcon, WechatIcon, WeekendIcon, WestIcon, WhatshotIcon, WheelchairPickupIcon, WhereToVoteIcon, WidgetsIcon, WidthFullIcon, WidthNormalIcon, WidthWideIcon, Wifi1BarIcon, Wifi2BarIcon, WifiCalling3Icon, WifiCallingIcon, WifiChannelIcon, WifiFindIcon, WifiIcon, WifiLockIcon, WifiOffIcon, WifiPasswordIcon, WifiProtectedSetupIcon, WifiTetheringErrorIcon, WifiTetheringErrorRoundedIcon, WifiTetheringIcon, WifiTetheringOffIcon, WindPowerIcon, WindowIcon, WineBarIcon, Woman2Icon, WomanIcon, WooCommerceIcon, WordpressIcon, WorkHistoryIcon, WorkIcon, WorkOffIcon, WorkOutlineIcon, WorkspacePremiumIcon, WorkspacesIcon, WrapTextIcon, WrongLocationIcon, WysiwygIcon, YardIcon, YoutubeSearchedForIcon, ZoomInIcon, ZoomInMapIcon, ZoomOutIcon, ZoomOutMapIcon, _10kIcon, _10mpIcon, _11mpIcon, _123Icon, _12mpIcon, _13mpIcon, _14mpIcon, _15mpIcon, _16mpIcon, _17mpIcon, _18UpRatingIcon, _18mpIcon, _19mpIcon, _1kIcon, _1kPlusIcon, _1xMobiledataIcon, _20mpIcon, _21mpIcon, _22mpIcon, _23mpIcon, _24mpIcon, _2kIcon, _2kPlusIcon, _2mpIcon, _30fpsIcon, _30fpsSelectIcon, _360Icon, _3dRotationIcon, _3gMobiledataIcon, _3kIcon, _3kPlusIcon, _3mpIcon, _3pIcon, _4gMobiledataIcon, _4gPlusMobiledataIcon, _4kIcon, _4kPlusIcon, _4mpIcon, _5gIcon, _5kIcon, _5kPlusIcon, _5mpIcon, _60fpsIcon, _60fpsSelectIcon, _6FtApartIcon, _6kIcon, _6kPlusIcon, _6mpIcon, _7kIcon, _7kPlusIcon, _7mpIcon, _8kIcon, _8kPlusIcon, _8mpIcon, _9kIcon, _9kPlusIcon, _9mpIcon, cardClickableMixin, cardMixin, cardSelectedMixin, cls, cn, coolIconKeys, debounce, defaultBorderMixin, fieldBackgroundDisabledMixin, fieldBackgroundHoverMixin, fieldBackgroundInvisibleMixin, fieldBackgroundMixin, focusedClasses, focusedDisabled, focusedInvisibleMixin, getColorSchemeForKey, getColorSchemeForSeed, iconKeys, keyToIconComponent, paperMixin, useAutoComplete, useDebounceValue, useIconStyles, useInjectStyles, useOutsideAlerter } from "./ui-CZ0AEYFv.js";
import { FireCMSFirebaseApp, FirebaseLoginView, LoginButton, RECAPTCHA_CONTAINER_ID, buildAlgoliaSearchController, buildCollectionId, buildExternalSearchController, buildPineconeSearchController, cmsToFirestoreModel, cmsToRTDBModel, docToCollection, docsToCollectionTree, firestoreToCMSModel, getFirestoreDataInPath, localSearchControllerBuilder, performAlgoliaTextSearch, performPineconeTextSearch, prepareCollectionForPersistence, setUndefinedToDelete, useAppCheck, useFirebaseAuthController, useFirebaseRTDBDelegate, useFirebaseStorageSource, useFirestoreDelegate, useInitialiseFirebase, useRecaptcha } from "./firebase-Cxa2kXKf.js";
import { M as MarkdownIt } from "../index-CY1eqRJM.js";
const scriptRel = function detectScriptRel() {
  const relList = typeof document !== "undefined" && document.createElement("link").relList;
  return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
}();
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
    promise = Promise.allSettled(
      deps.map((dep) => {
        dep = assetsURL(dep);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
        }
        link.crossOrigin = "";
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e = new Event("vite:preloadError", {
      cancelable: true
    });
    e.payload = err;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err;
    }
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
const React$7 = await importShared("react");
const { useEffect: useEffect$6, useCallback: useCallback$6, useContext: useContext$4, useState: useState$5 } = React$7;
const { removeUndefined: removeUndefined$2, useAuthController: useAuthController$3, toSnakeCase: toSnakeCase$1, FieldCaption: FieldCaption$1, ConfirmationDialog: ConfirmationDialog$1, useNavigationController: useNavigationController$5, useSnackbarController: useSnackbarController$4, useCustomizationController: useCustomizationController$6, defaultDateFormat: defaultDateFormat2 } = await importShared("@firecms/core");
const { getColorSchemeForSeed: getColorSchemeForSeed2, Chip: Chip$2, TextField: TextField$5, TableRow: TableRow$2, TableCell: TableCell$2, Checkbox: Checkbox$2, Tooltip: Tooltip$6, Button: Button$6, Typography: Typography$5, DialogTitle: DialogTitle$5, TableHeader: TableHeader$1, Paper: Paper$3, Table: Table$2, TableBody: TableBody$2, SelectItem: SelectItem$3, Select: Select$3, DialogContent: DialogContent$5, CheckIcon: CheckIcon$2, LoadingButton: LoadingButton$2, DialogActions: DialogActions$4, Dialog: Dialog$5, IconButton: IconButton$6, DeleteIcon: DeleteIcon$1, CenteredView: CenteredView$2, AddIcon: AddIcon$2, Container: Container$2, MultiSelectItem: MultiSelectItem$1, MultiSelect: MultiSelect$1 } = await importShared("@firecms/ui");
const DEFAULT_PERMISSIONS = {
  read: false,
  edit: false,
  create: false,
  delete: false
};
function resolveUserRolePermissions({
  collection: collection2,
  user
}) {
  const roles = user?.roles;
  if (!roles) {
    return DEFAULT_PERMISSIONS;
  } else if (collection2.ownerId === user?.uid) {
    return {
      read: true,
      create: true,
      edit: true,
      delete: true
    };
  } else {
    const basePermissions = {
      read: false,
      create: false,
      edit: false,
      delete: false
    };
    return roles.map((role) => resolveCollectionRole(role, collection2.id)).reduce(mergePermissions, basePermissions);
  }
}
function resolveCollectionRole(role, id) {
  const basePermissions = {
    read: (role.isAdmin || role.defaultPermissions?.read) ?? false,
    create: (role.isAdmin || role.defaultPermissions?.create) ?? false,
    edit: (role.isAdmin || role.defaultPermissions?.edit) ?? false,
    delete: (role.isAdmin || role.defaultPermissions?.delete) ?? false
  };
  const thisCollectionPermissions = role.collectionPermissions?.[id];
  if (thisCollectionPermissions) {
    return mergePermissions(thisCollectionPermissions, basePermissions);
  } else if (role.defaultPermissions) {
    return mergePermissions(role.defaultPermissions, basePermissions);
  } else {
    return basePermissions;
  }
}
const mergePermissions = (permA, permB) => {
  return {
    read: permA.read || permB.read,
    create: permA.create || permB.create,
    edit: permA.edit || permB.edit,
    delete: permA.delete || permB.delete
  };
};
function getUserRoles(roles, fireCMSUser) {
  return !roles ? void 0 : fireCMSUser.roles ? fireCMSUser.roles.map((role) => roles.find((r) => r.id === role.id)).filter(Boolean) : [];
}
const areRolesEqual$1 = (rolesA, rolesB) => {
  const rolesAIds = rolesA.map((r) => r.id);
  const rolesBIds = rolesB.map((r) => r.id);
  return rolesAIds.length === rolesB.length && rolesAIds.every((role) => rolesBIds.includes(role));
};
const UserManagementContext = React$7.createContext({});
function UserManagementProvider(t0) {
  const $2 = c_1(3);
  const {
    children,
    userManagement
  } = t0;
  let t1;
  if ($2[0] !== children || $2[1] !== userManagement) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(UserManagementContext.Provider, { value: userManagement, children });
    $2[0] = children;
    $2[1] = userManagement;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  return t1;
}
const useUserManagement = () => {
  return useContext$4(UserManagementContext);
};
function RoleChip(t0) {
  const $2 = c_1(6);
  const {
    role
  } = t0;
  let colorScheme;
  if (role.isAdmin) {
    colorScheme = "blueDarker";
  } else {
    if (role.id === "editor") {
      colorScheme = "yellowLight";
    } else {
      if (role.id === "viewer") {
        colorScheme = "grayLight";
      } else {
        let t12;
        if ($2[0] !== role.id) {
          t12 = getColorSchemeForSeed2(role.id);
          $2[0] = role.id;
          $2[1] = t12;
        } else {
          t12 = $2[1];
        }
        colorScheme = t12;
      }
    }
  }
  let t1;
  if ($2[2] !== colorScheme || $2[3] !== role.id || $2[4] !== role.name) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(Chip$2, { colorScheme, children: role.name }, role.id);
    $2[2] = colorScheme;
    $2[3] = role.id;
    $2[4] = role.name;
    $2[5] = t1;
  } else {
    t1 = $2[5];
  }
  return t1;
}
const RoleYupSchema = create$1().shape({
  id: create$2().required("Required"),
  name: create$2().required("Required")
});
function canRoleBeEdited(loggedUser) {
  const loggedUserIsAdmin = loggedUser.roles?.map((r) => r.id).includes("admin");
  console.log("loggedUserIsAdmin", loggedUser);
  if (!loggedUserIsAdmin) {
    throw new Error("Only admins can edit roles");
  }
  return true;
}
function RolesDetailsForm(t0) {
  const $2 = c_1(165);
  const {
    open,
    role,
    editable,
    handleClose,
    collections
  } = t0;
  const {
    saveRole
  } = useUserManagement();
  const isNewRole = !role;
  const {
    user: loggedInUser
  } = useAuthController$3();
  const [savingError, setSavingError] = useState$5();
  let t1;
  if ($2[0] !== loggedInUser || $2[1] !== saveRole) {
    t1 = (role_0) => {
      setSavingError(void 0);
      if (!loggedInUser) {
        throw new Error("User not found");
      }
      canRoleBeEdited(loggedInUser);
      return saveRole(role_0);
    };
    $2[0] = loggedInUser;
    $2[1] = saveRole;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  const onRoleUpdated = t1;
  let t2;
  if ($2[3] !== role) {
    t2 = role ?? {
      name: ""
    };
    $2[3] = role;
    $2[4] = t2;
  } else {
    t2 = $2[4];
  }
  let t3;
  if ($2[5] !== handleClose || $2[6] !== onRoleUpdated) {
    t3 = (role_1, formexController) => {
      try {
        return onRoleUpdated(role_1).then(() => {
          formexController.resetForm({
            values: role_1
          });
          handleClose();
        }).catch((e_0) => {
          setSavingError(e_0);
        });
      } catch (t410) {
        const e = t410;
        setSavingError(e);
        return Promise.resolve();
      }
    };
    $2[5] = handleClose;
    $2[6] = onRoleUpdated;
    $2[7] = t3;
  } else {
    t3 = $2[7];
  }
  let t4;
  if ($2[8] !== t2 || $2[9] !== t3) {
    t4 = {
      initialValues: t2,
      onSubmit: t3,
      validation: _temp3$1$2
    };
    $2[8] = t2;
    $2[9] = t3;
    $2[10] = t4;
  } else {
    t4 = $2[10];
  }
  const formex = useCreateFormex(t4);
  const {
    isSubmitting,
    touched,
    values: values_0,
    errors: errors_0,
    handleChange,
    setFieldValue,
    dirty,
    setFieldTouched
  } = formex;
  const isAdmin = values_0.isAdmin ?? false;
  const defaultCreate = values_0.defaultPermissions?.create ?? false;
  const defaultRead = values_0.defaultPermissions?.read ?? false;
  const defaultEdit = values_0.defaultPermissions?.edit ?? false;
  const defaultDelete = values_0.defaultPermissions?.delete ?? false;
  let t5;
  if ($2[11] !== setFieldValue || $2[12] !== touched || $2[13] !== values_0.name) {
    t5 = () => {
      const idTouched = getIn(touched, "id");
      if (!idTouched && values_0.name) {
        setFieldValue("id", toSnakeCase$1(values_0.name));
      }
    };
    $2[11] = setFieldValue;
    $2[12] = touched;
    $2[13] = values_0.name;
    $2[14] = t5;
  } else {
    t5 = $2[14];
  }
  let t6;
  if ($2[15] !== touched || $2[16] !== values_0.name) {
    t6 = [touched, values_0.name];
    $2[15] = touched;
    $2[16] = values_0.name;
    $2[17] = t6;
  } else {
    t6 = $2[17];
  }
  React$7.useEffect(t5, t6);
  let t7;
  let t8;
  if ($2[18] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      height: "100%"
    };
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle$5, { variant: "h4", gutterBottom: false, children: "Role" });
    $2[18] = t7;
    $2[19] = t8;
  } else {
    t7 = $2[18];
    t8 = $2[19];
  }
  const t9 = touched.name && Boolean(errors_0.name);
  const t10 = isAdmin || !editable;
  let t11;
  if ($2[20] !== handleChange || $2[21] !== t10 || $2[22] !== t9 || $2[23] !== values_0.name) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$5, { name: "name", required: true, error: t9, value: values_0.name, disabled: t10, onChange: handleChange, "aria-describedby": "name-helper-text", label: "Name" });
    $2[20] = handleChange;
    $2[21] = t10;
    $2[22] = t9;
    $2[23] = values_0.name;
    $2[24] = t11;
  } else {
    t11 = $2[24];
  }
  const t12 = touched.name && Boolean(errors_0.name) ? errors_0.name : "Name of this role";
  let t13;
  if ($2[25] !== t12) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption$1, { children: t12 });
    $2[25] = t12;
    $2[26] = t13;
  } else {
    t13 = $2[26];
  }
  let t14;
  if ($2[27] !== t11 || $2[28] !== t13) {
    t14 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12 md:col-span-8", children: [
      t11,
      t13
    ] });
    $2[27] = t11;
    $2[28] = t13;
    $2[29] = t14;
  } else {
    t14 = $2[29];
  }
  const t15 = touched.id && Boolean(errors_0.id);
  const t16 = !isNewRole || !editable;
  let t17;
  if ($2[30] !== handleChange || $2[31] !== setFieldTouched) {
    t17 = (e_2) => {
      handleChange(e_2);
      setFieldTouched("id", true);
    };
    $2[30] = handleChange;
    $2[31] = setFieldTouched;
    $2[32] = t17;
  } else {
    t17 = $2[32];
  }
  let t18;
  if ($2[33] !== t15 || $2[34] !== t16 || $2[35] !== t17 || $2[36] !== values_0.id) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$5, { name: "id", required: true, error: t15, value: values_0.id, disabled: t16, onChange: t17, "aria-describedby": "id-helper-text", label: "ID" });
    $2[33] = t15;
    $2[34] = t16;
    $2[35] = t17;
    $2[36] = values_0.id;
    $2[37] = t18;
  } else {
    t18 = $2[37];
  }
  const t19 = touched.id && Boolean(errors_0.id) ? errors_0.id : "ID of this role";
  let t20;
  if ($2[38] !== t19) {
    t20 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption$1, { children: t19 });
    $2[38] = t19;
    $2[39] = t20;
  } else {
    t20 = $2[39];
  }
  let t21;
  if ($2[40] !== t18 || $2[41] !== t20) {
    t21 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12 md:col-span-4", children: [
      t18,
      t20
    ] });
    $2[40] = t18;
    $2[41] = t20;
    $2[42] = t21;
  } else {
    t21 = $2[42];
  }
  let t22;
  if ($2[43] === Symbol.for("react.memo_cache_sentinel")) {
    t22 = /* @__PURE__ */ jsxRuntimeExports.jsxs(TableHeader$1, { className: "rounded-md", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { align: "center", children: "Create entities" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { align: "center", children: "Read entities" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { align: "center", children: "Update entities" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { align: "center", children: "Delete entities" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { align: "center" })
    ] });
    $2[43] = t22;
  } else {
    t22 = $2[43];
  }
  let t23;
  if ($2[44] === Symbol.for("react.memo_cache_sentinel")) {
    t23 = /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { scope: "row", children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "All collections" }) });
    $2[44] = t23;
  } else {
    t23 = $2[44];
  }
  const t24 = isAdmin || !editable;
  const t25 = (isAdmin || defaultCreate) ?? false;
  let t26;
  if ($2[45] !== setFieldValue) {
    t26 = (checked) => setFieldValue("defaultPermissions.create", checked);
    $2[45] = setFieldValue;
    $2[46] = t26;
  } else {
    t26 = $2[46];
  }
  let t27;
  if ($2[47] !== t24 || $2[48] !== t25 || $2[49] !== t26) {
    t27 = /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { align: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$6, { title: "Create entities in collections", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$2, { disabled: t24, checked: t25, onCheckedChange: t26 }) }) });
    $2[47] = t24;
    $2[48] = t25;
    $2[49] = t26;
    $2[50] = t27;
  } else {
    t27 = $2[50];
  }
  const t28 = isAdmin || !editable;
  const t29 = (isAdmin || defaultRead) ?? false;
  let t30;
  if ($2[51] !== setFieldValue) {
    t30 = (checked_0) => setFieldValue("defaultPermissions.read", checked_0);
    $2[51] = setFieldValue;
    $2[52] = t30;
  } else {
    t30 = $2[52];
  }
  let t31;
  if ($2[53] !== t28 || $2[54] !== t29 || $2[55] !== t30) {
    t31 = /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { align: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$6, { title: "Access all data in every collection", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$2, { disabled: t28, checked: t29, onCheckedChange: t30 }) }) });
    $2[53] = t28;
    $2[54] = t29;
    $2[55] = t30;
    $2[56] = t31;
  } else {
    t31 = $2[56];
  }
  const t32 = isAdmin || !editable;
  const t33 = (isAdmin || defaultEdit) ?? false;
  let t34;
  if ($2[57] !== setFieldValue) {
    t34 = (checked_1) => setFieldValue("defaultPermissions.edit", checked_1);
    $2[57] = setFieldValue;
    $2[58] = t34;
  } else {
    t34 = $2[58];
  }
  let t35;
  if ($2[59] !== t32 || $2[60] !== t33 || $2[61] !== t34) {
    t35 = /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { align: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$6, { title: "Update data in any collection", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$2, { disabled: t32, checked: t33, onCheckedChange: t34 }) }) });
    $2[59] = t32;
    $2[60] = t33;
    $2[61] = t34;
    $2[62] = t35;
  } else {
    t35 = $2[62];
  }
  const t36 = isAdmin || !editable;
  const t37 = (isAdmin || defaultDelete) ?? false;
  let t38;
  if ($2[63] !== setFieldValue) {
    t38 = (checked_2) => setFieldValue("defaultPermissions.delete", checked_2);
    $2[63] = setFieldValue;
    $2[64] = t38;
  } else {
    t38 = $2[64];
  }
  let t39;
  if ($2[65] !== t36 || $2[66] !== t37 || $2[67] !== t38) {
    t39 = /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { align: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$6, { title: "Delete data in any collection", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$2, { disabled: t36, checked: t37, onCheckedChange: t38 }) }) });
    $2[65] = t36;
    $2[66] = t37;
    $2[67] = t38;
    $2[68] = t39;
  } else {
    t39 = $2[68];
  }
  let t40;
  if ($2[69] === Symbol.for("react.memo_cache_sentinel")) {
    t40 = /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { align: "center" });
    $2[69] = t40;
  } else {
    t40 = $2[69];
  }
  let t41;
  if ($2[70] !== t27 || $2[71] !== t31 || $2[72] !== t35 || $2[73] !== t39) {
    t41 = /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow$2, { children: [
      t23,
      t27,
      t31,
      t35,
      t39,
      t40
    ] });
    $2[70] = t27;
    $2[71] = t31;
    $2[72] = t35;
    $2[73] = t39;
    $2[74] = t41;
  } else {
    t41 = $2[74];
  }
  let t42;
  if ($2[75] !== collections || $2[76] !== defaultCreate || $2[77] !== defaultDelete || $2[78] !== defaultEdit || $2[79] !== defaultRead || $2[80] !== editable || $2[81] !== isAdmin || $2[82] !== setFieldValue || $2[83] !== values_0) {
    t42 = collections && collections.map((col) => /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow$2, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { scope: "row", children: col.name }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { align: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$2, { disabled: isAdmin || defaultCreate || !editable, checked: (isAdmin || defaultCreate || getIn(values_0, `collectionPermissions.${col.id}.create`)) ?? false, onCheckedChange: (checked_3) => setFieldValue(`collectionPermissions.${col.id}.create`, checked_3) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { align: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$2, { disabled: isAdmin || defaultRead || !editable, checked: (isAdmin || defaultRead || getIn(values_0, `collectionPermissions.${col.id}.read`)) ?? false, onCheckedChange: (checked_4) => setFieldValue(`collectionPermissions.${col.id}.read`, checked_4) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { align: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$2, { disabled: isAdmin || defaultEdit || !editable, checked: (isAdmin || defaultEdit || getIn(values_0, `collectionPermissions.${col.id}.edit`)) ?? false, onCheckedChange: (checked_5) => setFieldValue(`collectionPermissions.${col.id}.edit`, checked_5) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { align: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$2, { disabled: isAdmin || defaultDelete || !editable, checked: (isAdmin || defaultDelete || getIn(values_0, `collectionPermissions.${col.id}.delete`)) ?? false, onCheckedChange: (checked_6) => setFieldValue(`collectionPermissions.${col.id}.delete`, checked_6) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { align: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$6, { title: "Allow all permissions in this collections", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$6, { className: "color-inherit", onClick: () => {
        setFieldValue(`collectionPermissions.${col.id}.create`, true);
        setFieldValue(`collectionPermissions.${col.id}.read`, true);
        setFieldValue(`collectionPermissions.${col.id}.edit`, true);
        setFieldValue(`collectionPermissions.${col.id}.delete`, true);
      }, disabled: isAdmin || !editable, variant: "text", children: "All" }) }) })
    ] }, col.name));
    $2[75] = collections;
    $2[76] = defaultCreate;
    $2[77] = defaultDelete;
    $2[78] = defaultEdit;
    $2[79] = defaultRead;
    $2[80] = editable;
    $2[81] = isAdmin;
    $2[82] = setFieldValue;
    $2[83] = values_0;
    $2[84] = t42;
  } else {
    t42 = $2[84];
  }
  let t43;
  if ($2[85] !== t41 || $2[86] !== t42) {
    t43 = /* @__PURE__ */ jsxRuntimeExports.jsx(Paper$3, { className: "bg-inherit overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table$2, { className: "w-full rounded-md", children: [
      t22,
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TableBody$2, { children: [
        t41,
        t42
      ] })
    ] }) });
    $2[85] = t41;
    $2[86] = t42;
    $2[87] = t43;
  } else {
    t43 = $2[87];
  }
  let t44;
  if ($2[88] === Symbol.for("react.memo_cache_sentinel")) {
    t44 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption$1, { children: "You can customise the permissions that the users related to this role can perform in the entities of each collection" });
    $2[88] = t44;
  } else {
    t44 = $2[88];
  }
  let t45;
  if ($2[89] !== t43) {
    t45 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
      t43,
      t44
    ] });
    $2[89] = t43;
    $2[90] = t45;
  } else {
    t45 = $2[90];
  }
  const t46 = touched.config && Boolean(errors_0.config);
  const t47 = isAdmin || !editable;
  let t48;
  if ($2[91] !== setFieldValue) {
    t48 = (event) => setFieldValue("config.createCollections", event.target.value === "true");
    $2[91] = setFieldValue;
    $2[92] = t48;
  } else {
    t48 = $2[92];
  }
  const t49 = isAdmin || values_0.config?.createCollections ? "true" : "false";
  let t50;
  let t51;
  if ($2[93] === Symbol.for("react.memo_cache_sentinel")) {
    t50 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$3, { value: "true", children: " Yes " });
    t51 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$3, { value: "false", children: " No " });
    $2[93] = t50;
    $2[94] = t51;
  } else {
    t50 = $2[93];
    t51 = $2[94];
  }
  let t52;
  if ($2[95] !== t46 || $2[96] !== t47 || $2[97] !== t48 || $2[98] !== t49) {
    t52 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Select$3, { error: t46, size: "large", fullWidth: true, id: "createCollections", name: "createCollections", label: "Create collections", position: "item-aligned", disabled: t47, onChange: t48, value: t49, renderValue: _temp4$1$1, children: [
      t50,
      t51
    ] });
    $2[95] = t46;
    $2[96] = t47;
    $2[97] = t48;
    $2[98] = t49;
    $2[99] = t52;
  } else {
    t52 = $2[99];
  }
  const t53 = touched.config && Boolean(errors_0.config) ? errors_0.config : "Can the user create collections";
  let t54;
  if ($2[100] !== t53) {
    t54 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption$1, { children: t53 });
    $2[100] = t53;
    $2[101] = t54;
  } else {
    t54 = $2[101];
  }
  let t55;
  if ($2[102] !== t52 || $2[103] !== t54) {
    t55 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12 md:col-span-4", children: [
      t52,
      t54
    ] });
    $2[102] = t52;
    $2[103] = t54;
    $2[104] = t55;
  } else {
    t55 = $2[104];
  }
  const t56 = touched.config && Boolean(errors_0.config);
  const t57 = isAdmin || !editable;
  let t58;
  if ($2[105] !== setFieldValue) {
    t58 = (event_0) => setFieldValue("config.editCollections", event_0.target.value === "own" ? "own" : event_0.target.value === "true");
    $2[105] = setFieldValue;
    $2[106] = t58;
  } else {
    t58 = $2[106];
  }
  const t59 = isAdmin ? "true" : values_0.config?.editCollections === "own" ? "own" : values_0.config?.editCollections ? "true" : "false";
  let t60;
  let t61;
  let t62;
  if ($2[107] === Symbol.for("react.memo_cache_sentinel")) {
    t60 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$3, { value: "true", children: " Yes " });
    t61 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$3, { value: "false", children: " No " });
    t62 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$3, { value: "own", children: " Only his/her own " });
    $2[107] = t60;
    $2[108] = t61;
    $2[109] = t62;
  } else {
    t60 = $2[107];
    t61 = $2[108];
    t62 = $2[109];
  }
  let t63;
  if ($2[110] !== t56 || $2[111] !== t57 || $2[112] !== t58 || $2[113] !== t59) {
    t63 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Select$3, { size: "large", fullWidth: true, error: t56, id: "editCollections", name: "editCollections", label: "Edit collections", disabled: t57, position: "item-aligned", onChange: t58, value: t59, renderValue: _temp5$1, children: [
      t60,
      t61,
      t62
    ] });
    $2[110] = t56;
    $2[111] = t57;
    $2[112] = t58;
    $2[113] = t59;
    $2[114] = t63;
  } else {
    t63 = $2[114];
  }
  const t64 = touched.config && Boolean(errors_0.config) ? errors_0.config : "Can the user edit collections";
  let t65;
  if ($2[115] !== t64) {
    t65 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption$1, { children: t64 });
    $2[115] = t64;
    $2[116] = t65;
  } else {
    t65 = $2[116];
  }
  let t66;
  if ($2[117] !== t63 || $2[118] !== t65) {
    t66 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12 md:col-span-4", children: [
      t63,
      t65
    ] });
    $2[117] = t63;
    $2[118] = t65;
    $2[119] = t66;
  } else {
    t66 = $2[119];
  }
  const t67 = touched.config && Boolean(errors_0.config);
  const t68 = isAdmin || !editable;
  let t69;
  if ($2[120] !== setFieldValue) {
    t69 = (event_1) => setFieldValue("config.deleteCollections", event_1.target.value === "own" ? "own" : event_1.target.value === "true");
    $2[120] = setFieldValue;
    $2[121] = t69;
  } else {
    t69 = $2[121];
  }
  const t70 = isAdmin ? "true" : values_0.config?.deleteCollections === "own" ? "own" : values_0.config?.deleteCollections ? "true" : "false";
  let t71;
  let t72;
  let t73;
  if ($2[122] === Symbol.for("react.memo_cache_sentinel")) {
    t71 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$3, { value: "true", children: " Yes " });
    t72 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$3, { value: "false", children: " No " });
    t73 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$3, { value: "own", children: " Only his/her own " });
    $2[122] = t71;
    $2[123] = t72;
    $2[124] = t73;
  } else {
    t71 = $2[122];
    t72 = $2[123];
    t73 = $2[124];
  }
  let t74;
  if ($2[125] !== t67 || $2[126] !== t68 || $2[127] !== t69 || $2[128] !== t70) {
    t74 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Select$3, { size: "large", fullWidth: true, error: t67, id: "deleteCollections", name: "deleteCollections", label: "Delete collections", disabled: t68, position: "item-aligned", onChange: t69, value: t70, renderValue: _temp6$1, children: [
      t71,
      t72,
      t73
    ] });
    $2[125] = t67;
    $2[126] = t68;
    $2[127] = t69;
    $2[128] = t70;
    $2[129] = t74;
  } else {
    t74 = $2[129];
  }
  const t75 = touched.config && Boolean(errors_0.config) ? errors_0.config : "Can the user delete collections";
  let t76;
  if ($2[130] !== t75) {
    t76 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption$1, { children: t75 });
    $2[130] = t75;
    $2[131] = t76;
  } else {
    t76 = $2[131];
  }
  let t77;
  if ($2[132] !== t74 || $2[133] !== t76) {
    t77 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12 md:col-span-4", children: [
      t74,
      t76
    ] });
    $2[132] = t74;
    $2[133] = t76;
    $2[134] = t77;
  } else {
    t77 = $2[134];
  }
  let t78;
  if ($2[135] !== t14 || $2[136] !== t21 || $2[137] !== t45 || $2[138] !== t55 || $2[139] !== t66 || $2[140] !== t77) {
    t78 = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent$5, { className: "flex-grow", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-12 gap-8", children: [
      t14,
      t21,
      t45,
      t55,
      t66,
      t77
    ] }) });
    $2[135] = t14;
    $2[136] = t21;
    $2[137] = t45;
    $2[138] = t55;
    $2[139] = t66;
    $2[140] = t77;
    $2[141] = t78;
  } else {
    t78 = $2[141];
  }
  let t79;
  if ($2[142] !== savingError) {
    t79 = savingError && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$5, { className: "text-red-500 dark:text-red-500", children: savingError.message ?? "There was an error saving this role" });
    $2[142] = savingError;
    $2[143] = t79;
  } else {
    t79 = $2[143];
  }
  let t80;
  if ($2[144] !== handleClose) {
    t80 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button$6, { variant: "text", onClick: () => {
      handleClose();
    }, children: "Cancel" });
    $2[144] = handleClose;
    $2[145] = t80;
  } else {
    t80 = $2[145];
  }
  const t81 = !dirty;
  let t82;
  if ($2[146] === Symbol.for("react.memo_cache_sentinel")) {
    t82 = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon$2, {});
    $2[146] = t82;
  } else {
    t82 = $2[146];
  }
  const t83 = isNewRole ? "Create role" : "Update";
  let t84;
  if ($2[147] !== isSubmitting || $2[148] !== t81 || $2[149] !== t83) {
    t84 = /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingButton$2, { variant: "filled", color: "primary", type: "submit", disabled: t81, loading: isSubmitting, startIcon: t82, children: t83 });
    $2[147] = isSubmitting;
    $2[148] = t81;
    $2[149] = t83;
    $2[150] = t84;
  } else {
    t84 = $2[150];
  }
  let t85;
  if ($2[151] !== t79 || $2[152] !== t80 || $2[153] !== t84) {
    t85 = /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions$4, { position: "sticky", children: [
      t79,
      t80,
      t84
    ] });
    $2[151] = t79;
    $2[152] = t80;
    $2[153] = t84;
    $2[154] = t85;
  } else {
    t85 = $2[154];
  }
  let t86;
  if ($2[155] !== formex.handleSubmit || $2[156] !== t78 || $2[157] !== t85) {
    t86 = /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { noValidate: true, autoComplete: "off", onSubmit: formex.handleSubmit, style: t7, children: [
      t8,
      t78,
      t85
    ] });
    $2[155] = formex.handleSubmit;
    $2[156] = t78;
    $2[157] = t85;
    $2[158] = t86;
  } else {
    t86 = $2[158];
  }
  let t87;
  if ($2[159] !== formex || $2[160] !== t86) {
    t87 = /* @__PURE__ */ jsxRuntimeExports.jsx(Formex, { value: formex, children: t86 });
    $2[159] = formex;
    $2[160] = t86;
    $2[161] = t87;
  } else {
    t87 = $2[161];
  }
  let t88;
  if ($2[162] !== open || $2[163] !== t87) {
    t88 = /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog$5, { open, maxWidth: "4xl", children: t87 });
    $2[162] = open;
    $2[163] = t87;
    $2[164] = t88;
  } else {
    t88 = $2[164];
  }
  return t88;
}
function _temp6$1(value_1) {
  return value_1 === "own" ? "Own" : value_1 === "true" ? "Yes" : "No";
}
function _temp5$1(value_0) {
  return value_0 === "own" ? "Own" : value_0 === "true" ? "Yes" : "No";
}
function _temp4$1$1(value) {
  return value === "true" ? "Yes" : "No";
}
function _temp3$1$2(values) {
  return RoleYupSchema.validate(values, {
    abortEarly: false
  }).then(_temp$2$2).catch(_temp2$1$3);
}
function _temp2$1$3(e_1) {
  const errors = {};
  e_1.inner.forEach((error) => {
    errors[error.path] = error.message;
  });
  return errors;
}
function _temp$2$2() {
  return {};
}
const DEFAULT_ROLES = [{
  id: "admin",
  name: "Admin",
  isAdmin: true
}, {
  id: "editor",
  name: "Editor",
  isAdmin: false,
  defaultPermissions: {
    read: true,
    create: true,
    edit: true,
    delete: true
  },
  config: {
    createCollections: true,
    editCollections: "own",
    deleteCollections: "own"
  }
}, {
  id: "viewer",
  name: "Viewer",
  isAdmin: false,
  defaultPermissions: {
    read: true,
    create: false,
    edit: false,
    delete: false
  }
}];
function RolesTable(t0) {
  const $2 = c_1(25);
  const {
    onRoleClicked,
    editable
  } = t0;
  const {
    roles,
    saveRole,
    deleteRole,
    allowDefaultRolesCreation
  } = useUserManagement();
  const [roleToBeDeleted, setRoleToBeDeleted] = useState$5(void 0);
  const [deleteInProgress, setDeleteInProgress] = useState$5(false);
  let t1;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsxs(TableHeader$1, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { header: true, className: "w-16" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { header: true, children: "Role" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { header: true, className: "items-center", children: "Is Admin" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { header: true, children: "Default permissions" })
    ] });
    $2[0] = t1;
  } else {
    t1 = $2[0];
  }
  let t2;
  if ($2[1] !== editable || $2[2] !== onRoleClicked || $2[3] !== roles) {
    t2 = roles && roles.map((role) => {
      const canCreateAll = role.isAdmin || role.defaultPermissions?.create;
      const canReadAll = role.isAdmin || role.defaultPermissions?.read;
      const canUpdateAll = role.isAdmin || role.defaultPermissions?.edit;
      const canDeleteAll = role.isAdmin || role.defaultPermissions?.delete;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow$2, { onClick: () => {
        onRoleClicked(role);
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { style: {
          width: "64px"
        }, children: !role.isAdmin && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$6, { asChild: true, title: "Delete this role", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$6, { size: "small", disabled: !editable, onClick: (event) => {
          event.stopPropagation();
          return setRoleToBeDeleted(role);
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteIcon$1, {}) }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(RoleChip, { role }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { className: "items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$2, { checked: role.isAdmin ?? false }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
          canCreateAll && /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Create" }),
          canReadAll && /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Read" }),
          canUpdateAll && /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Update" }),
          canDeleteAll && /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Delete" })
        ] }) })
      ] }, role.name);
    });
    $2[1] = editable;
    $2[2] = onRoleClicked;
    $2[3] = roles;
    $2[4] = t2;
  } else {
    t2 = $2[4];
  }
  let t3;
  if ($2[5] !== allowDefaultRolesCreation || $2[6] !== roles || $2[7] !== saveRole) {
    t3 = (!roles || roles.length === 0) && /* @__PURE__ */ jsxRuntimeExports.jsx(TableRow$2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { colspan: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CenteredView$2, { className: "flex flex-col gap-4 my-8 items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$5, { variant: "label", children: "You don't have any roles yet." }),
      allowDefaultRolesCreation && /* @__PURE__ */ jsxRuntimeExports.jsx(Button$6, { variant: "outlined", onClick: () => {
        DEFAULT_ROLES.forEach((role_0) => {
          saveRole(role_0);
        });
      }, children: "Create default roles" })
    ] }) }) });
    $2[5] = allowDefaultRolesCreation;
    $2[6] = roles;
    $2[7] = saveRole;
    $2[8] = t3;
  } else {
    t3 = $2[8];
  }
  let t4;
  if ($2[9] !== t2 || $2[10] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Table$2, { className: "w-full", children: [
      t1,
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TableBody$2, { children: [
        t2,
        t3
      ] })
    ] });
    $2[9] = t2;
    $2[10] = t3;
    $2[11] = t4;
  } else {
    t4 = $2[11];
  }
  const t5 = Boolean(roleToBeDeleted);
  let t6;
  if ($2[12] !== deleteRole || $2[13] !== roleToBeDeleted) {
    t6 = () => {
      if (roleToBeDeleted) {
        setDeleteInProgress(true);
        deleteRole(roleToBeDeleted).then(() => {
          setRoleToBeDeleted(void 0);
        }).finally(() => {
          setDeleteInProgress(false);
        });
      }
    };
    $2[12] = deleteRole;
    $2[13] = roleToBeDeleted;
    $2[14] = t6;
  } else {
    t6 = $2[14];
  }
  let t7;
  let t8;
  let t9;
  if ($2[15] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = () => {
      setRoleToBeDeleted(void 0);
    };
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "Delete?" });
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "Are you sure you want to delete this role?" });
    $2[15] = t7;
    $2[16] = t8;
    $2[17] = t9;
  } else {
    t7 = $2[15];
    t8 = $2[16];
    t9 = $2[17];
  }
  let t10;
  if ($2[18] !== deleteInProgress || $2[19] !== t5 || $2[20] !== t6) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(ConfirmationDialog$1, { open: t5, loading: deleteInProgress, onAccept: t6, onCancel: t7, title: t8, body: t9 });
    $2[18] = deleteInProgress;
    $2[19] = t5;
    $2[20] = t6;
    $2[21] = t10;
  } else {
    t10 = $2[21];
  }
  let t11;
  if ($2[22] !== t10 || $2[23] !== t4) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full overflow-auto", children: [
      t4,
      t10
    ] });
    $2[22] = t10;
    $2[23] = t4;
    $2[24] = t11;
  } else {
    t11 = $2[24];
  }
  return t11;
}
const RolesView = React$7.memo(function RolesView2(t0) {
  const $2 = c_1(23);
  const {
    children
  } = t0;
  const {
    collections
  } = useNavigationController$5();
  const [dialogOpen, setDialogOpen] = useState$5(false);
  const [selectedRole, setSelectedRole] = useState$5();
  const {
    canEditRoles
  } = useUserManagement();
  let t1;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (user) => {
      setDialogOpen(true);
      setSelectedRole(user);
    };
    $2[0] = t1;
  } else {
    t1 = $2[0];
  }
  const onRoleClicked = t1;
  let t2;
  if ($2[1] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = () => {
      setSelectedRole(void 0);
      setDialogOpen(false);
    };
    $2[1] = t2;
  } else {
    t2 = $2[1];
  }
  const handleClose = t2;
  let t3;
  if ($2[2] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$5, { gutterBottom: true, variant: "h4", className: "flex-grow", component: "h4", children: "Roles" });
    $2[2] = t3;
  } else {
    t3 = $2[2];
  }
  const t4 = !canEditRoles ? "Update plans to customise roles" : void 0;
  const t5 = !canEditRoles;
  let t6;
  let t7;
  if ($2[3] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon$2, {});
    t7 = () => setDialogOpen(true);
    $2[3] = t6;
    $2[4] = t7;
  } else {
    t6 = $2[3];
    t7 = $2[4];
  }
  let t8;
  if ($2[5] !== t5) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button$6, { size: "large", disabled: t5, startIcon: t6, onClick: t7, children: "Add role" });
    $2[5] = t5;
    $2[6] = t8;
  } else {
    t8 = $2[6];
  }
  let t9;
  if ($2[7] !== t4 || $2[8] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center mt-12", children: [
      t3,
      /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$6, { asChild: true, title: t4, children: t8 })
    ] });
    $2[7] = t4;
    $2[8] = t8;
    $2[9] = t9;
  } else {
    t9 = $2[9];
  }
  const t10 = Boolean(canEditRoles);
  let t11;
  if ($2[10] !== t10) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx(RolesTable, { onRoleClicked, editable: t10 });
    $2[10] = t10;
    $2[11] = t11;
  } else {
    t11 = $2[11];
  }
  const t12 = selectedRole?.id ?? "new";
  let t13;
  if ($2[12] !== canEditRoles || $2[13] !== collections || $2[14] !== dialogOpen || $2[15] !== selectedRole || $2[16] !== t12) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsx(RolesDetailsForm, { open: dialogOpen, role: selectedRole, editable: canEditRoles, collections, handleClose }, t12);
    $2[12] = canEditRoles;
    $2[13] = collections;
    $2[14] = dialogOpen;
    $2[15] = selectedRole;
    $2[16] = t12;
    $2[17] = t13;
  } else {
    t13 = $2[17];
  }
  let t14;
  if ($2[18] !== children || $2[19] !== t11 || $2[20] !== t13 || $2[21] !== t9) {
    t14 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$2, { className: "w-full flex flex-col py-4 gap-4", maxWidth: "6xl", children: [
      children,
      t9,
      t11,
      t13
    ] });
    $2[18] = children;
    $2[19] = t11;
    $2[20] = t13;
    $2[21] = t9;
    $2[22] = t14;
  } else {
    t14 = $2[22];
  }
  return t14;
});
const UserYupSchema = create$1().shape({
  displayName: create$2().required("Required"),
  email: create$2().email().required("Required"),
  roles: create$3().min(1)
});
function canUserBeEdited(loggedUser, user, users, roles, prevUser) {
  const admins = users.filter((u) => u.roles?.map((r) => r.id).includes("admin"));
  const loggedUserIsAdmin = loggedUser.roles?.map((r) => r.id).includes("admin");
  const didRolesChange = !prevUser || !areRolesEqual$1(prevUser.roles ?? [], user.roles ?? []);
  if (didRolesChange && !loggedUserIsAdmin) {
    throw new Error("Only admins can change roles");
  }
  const adminRoleRemoved = prevUser && prevUser.roles?.map((r) => r.id).includes("admin") && !user.roles?.map((r) => r.id).includes("admin");
  if (adminRoleRemoved && admins.length === 1) {
    throw new Error("There must be at least one admin");
  }
  return true;
}
function UserDetailsForm(t0) {
  const $2 = c_1(74);
  const {
    open,
    user: userProp,
    handleClose
  } = t0;
  const snackbarController = useSnackbarController$4();
  const {
    user: loggedInUser
  } = useAuthController$3();
  const {
    saveUser,
    users,
    roles
  } = useUserManagement();
  const isNewUser = !userProp;
  let t1;
  if ($2[0] !== loggedInUser || $2[1] !== roles || $2[2] !== saveUser || $2[3] !== userProp || $2[4] !== users) {
    t1 = (savedUser) => {
      if (!loggedInUser) {
        throw new Error("Logged user not found");
      }
      try {
        canUserBeEdited(loggedInUser, savedUser, users, roles, userProp);
        return saveUser(savedUser);
      } catch (t210) {
        const e = t210;
        return Promise.reject(e);
      }
    };
    $2[0] = loggedInUser;
    $2[1] = roles;
    $2[2] = saveUser;
    $2[3] = userProp;
    $2[4] = users;
    $2[5] = t1;
  } else {
    t1 = $2[5];
  }
  const onUserUpdated = t1;
  let t2;
  if ($2[6] !== roles || $2[7] !== userProp) {
    t2 = userProp ?? {
      displayName: "",
      email: "",
      roles: roles.filter(_temp$1$3)
    };
    $2[6] = roles;
    $2[7] = userProp;
    $2[8] = t2;
  } else {
    t2 = $2[8];
  }
  let t3;
  if ($2[9] !== handleClose || $2[10] !== onUserUpdated || $2[11] !== snackbarController) {
    t3 = (user, formexController) => onUserUpdated(user).then(() => {
      handleClose();
      formexController.resetForm({
        values: user
      });
    }).catch((e_1) => {
      snackbarController.open({
        type: "error",
        message: e_1.message
      });
    });
    $2[9] = handleClose;
    $2[10] = onUserUpdated;
    $2[11] = snackbarController;
    $2[12] = t3;
  } else {
    t3 = $2[12];
  }
  let t4;
  if ($2[13] !== t2 || $2[14] !== t3) {
    t4 = {
      initialValues: t2,
      validation: _temp5,
      onSubmit: t3
    };
    $2[13] = t2;
    $2[14] = t3;
    $2[15] = t4;
  } else {
    t4 = $2[15];
  }
  const formex = useCreateFormex(t4);
  const {
    isSubmitting,
    handleChange,
    values: values_0,
    errors,
    setFieldValue,
    dirty,
    handleSubmit,
    submitCount
  } = formex;
  let t5;
  if ($2[16] !== handleClose) {
    t5 = (open_0) => !open_0 ? handleClose() : void 0;
    $2[16] = handleClose;
    $2[17] = t5;
  } else {
    t5 = $2[17];
  }
  let t6;
  let t7;
  if ($2[18] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      height: "100%"
    };
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle$5, { variant: "h4", gutterBottom: false, children: "User" });
    $2[18] = t6;
    $2[19] = t7;
  } else {
    t6 = $2[18];
    t7 = $2[19];
  }
  const t8 = submitCount > 0 && Boolean(errors.displayName);
  const t9 = values_0.displayName ?? "";
  let t10;
  if ($2[20] !== handleChange || $2[21] !== t8 || $2[22] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$5, { name: "displayName", required: true, error: t8, value: t9, onChange: handleChange, "aria-describedby": "name-helper-text", label: "Name" });
    $2[20] = handleChange;
    $2[21] = t8;
    $2[22] = t9;
    $2[23] = t10;
  } else {
    t10 = $2[23];
  }
  const t11 = submitCount > 0 && Boolean(errors.displayName) ? errors.displayName : "Name of this user";
  let t12;
  if ($2[24] !== t11) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption$1, { children: t11 });
    $2[24] = t11;
    $2[25] = t12;
  } else {
    t12 = $2[25];
  }
  let t13;
  if ($2[26] !== t10 || $2[27] !== t12) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
      t10,
      t12
    ] });
    $2[26] = t10;
    $2[27] = t12;
    $2[28] = t13;
  } else {
    t13 = $2[28];
  }
  const t14 = submitCount > 0 && Boolean(errors.email);
  const t15 = values_0.email ?? "";
  let t16;
  if ($2[29] !== handleChange || $2[30] !== t14 || $2[31] !== t15) {
    t16 = /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$5, { required: true, error: t14, name: "email", value: t15, onChange: handleChange, "aria-describedby": "email-helper-text", label: "Email" });
    $2[29] = handleChange;
    $2[30] = t14;
    $2[31] = t15;
    $2[32] = t16;
  } else {
    t16 = $2[32];
  }
  const t17 = submitCount > 0 && Boolean(errors.email) ? errors.email : "Email of this user";
  let t18;
  if ($2[33] !== t17) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption$1, { children: t17 });
    $2[33] = t17;
    $2[34] = t18;
  } else {
    t18 = $2[34];
  }
  let t19;
  if ($2[35] !== t16 || $2[36] !== t18) {
    t19 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
      t16,
      t18
    ] });
    $2[35] = t16;
    $2[36] = t18;
    $2[37] = t19;
  } else {
    t19 = $2[37];
  }
  let t20;
  if ($2[38] !== values_0.roles) {
    t20 = values_0.roles?.map(_temp6) ?? [];
    $2[38] = values_0.roles;
    $2[39] = t20;
  } else {
    t20 = $2[39];
  }
  let t21;
  if ($2[40] !== roles || $2[41] !== setFieldValue) {
    t21 = (value) => setFieldValue("roles", value.map((id) => roles.find((r_1) => r_1.id === id)));
    $2[40] = roles;
    $2[41] = setFieldValue;
    $2[42] = t21;
  } else {
    t21 = $2[42];
  }
  let t22;
  if ($2[43] !== roles) {
    t22 = roles.map(_temp7);
    $2[43] = roles;
    $2[44] = t22;
  } else {
    t22 = $2[44];
  }
  let t23;
  if ($2[45] !== t20 || $2[46] !== t21 || $2[47] !== t22) {
    t23 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSelect$1, { className: "w-full", label: "Roles", value: t20, onValueChange: t21, children: t22 }) });
    $2[45] = t20;
    $2[46] = t21;
    $2[47] = t22;
    $2[48] = t23;
  } else {
    t23 = $2[48];
  }
  let t24;
  if ($2[49] !== t13 || $2[50] !== t19 || $2[51] !== t23) {
    t24 = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent$5, { className: "h-full flex-grow", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-12 gap-8", children: [
      t13,
      t19,
      t23
    ] }) });
    $2[49] = t13;
    $2[50] = t19;
    $2[51] = t23;
    $2[52] = t24;
  } else {
    t24 = $2[52];
  }
  let t25;
  if ($2[53] !== handleClose) {
    t25 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button$6, { variant: "text", onClick: () => {
      handleClose();
    }, children: "Cancel" });
    $2[53] = handleClose;
    $2[54] = t25;
  } else {
    t25 = $2[54];
  }
  const t26 = !dirty;
  let t27;
  if ($2[55] === Symbol.for("react.memo_cache_sentinel")) {
    t27 = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon$2, {});
    $2[55] = t27;
  } else {
    t27 = $2[55];
  }
  const t28 = isNewUser ? "Create user" : "Update";
  let t29;
  if ($2[56] !== isSubmitting || $2[57] !== t26 || $2[58] !== t28) {
    t29 = /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingButton$2, { variant: "filled", color: "primary", type: "submit", disabled: t26, loading: isSubmitting, startIcon: t27, children: t28 });
    $2[56] = isSubmitting;
    $2[57] = t26;
    $2[58] = t28;
    $2[59] = t29;
  } else {
    t29 = $2[59];
  }
  let t30;
  if ($2[60] !== t25 || $2[61] !== t29) {
    t30 = /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions$4, { children: [
      t25,
      t29
    ] });
    $2[60] = t25;
    $2[61] = t29;
    $2[62] = t30;
  } else {
    t30 = $2[62];
  }
  let t31;
  if ($2[63] !== handleSubmit || $2[64] !== t24 || $2[65] !== t30) {
    t31 = /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, autoComplete: "off", noValidate: true, style: t6, children: [
      t7,
      t24,
      t30
    ] });
    $2[63] = handleSubmit;
    $2[64] = t24;
    $2[65] = t30;
    $2[66] = t31;
  } else {
    t31 = $2[66];
  }
  let t32;
  if ($2[67] !== formex || $2[68] !== t31) {
    t32 = /* @__PURE__ */ jsxRuntimeExports.jsx(Formex, { value: formex, children: t31 });
    $2[67] = formex;
    $2[68] = t31;
    $2[69] = t32;
  } else {
    t32 = $2[69];
  }
  let t33;
  if ($2[70] !== open || $2[71] !== t32 || $2[72] !== t5) {
    t33 = /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog$5, { open, onOpenChange: t5, maxWidth: "4xl", children: t32 });
    $2[70] = open;
    $2[71] = t32;
    $2[72] = t5;
    $2[73] = t33;
  } else {
    t33 = $2[73];
  }
  return t33;
}
function _temp7(userRole) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSelectItem$1, { value: userRole.id, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RoleChip, { role: userRole }, userRole?.id) }, userRole.id);
}
function _temp6(r_0) {
  return r_0.id;
}
function _temp5(values) {
  return UserYupSchema.validate(values, {
    abortEarly: false
  }).then(_temp2$a).catch(_temp4$3);
}
function _temp4$3(e_0) {
  return e_0.inner.reduce(_temp3$7, {});
}
function _temp3$7(acc, error) {
  acc[error.path] = error.message;
  return acc;
}
function _temp2$a() {
  return {};
}
function _temp$1$3(r) {
  return r.id === "editor";
}
function UsersTable(t0) {
  const $2 = c_1(28);
  const {
    onUserClicked
  } = t0;
  const {
    users,
    saveUser,
    deleteUser
  } = useUserManagement();
  const authController = useAuthController$3();
  const snackbarController = useSnackbarController$4();
  const customizationController = useCustomizationController$6();
  const dateUtilsLocale = customizationController?.locale ? locales[customizationController?.locale] : void 0;
  const dateFormat = customizationController?.dateTimeFormat ?? defaultDateFormat2;
  const [userToBeDeleted, setUserToBeDeleted] = useState$5(void 0);
  const [deleteInProgress, setDeleteInProgress] = useState$5(false);
  let t1;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsxs(TableHeader$1, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { className: "truncate w-16" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { children: "Email" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { children: "Name" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { children: "Roles" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { children: "Created on" })
    ] });
    $2[0] = t1;
  } else {
    t1 = $2[0];
  }
  let t2;
  if ($2[1] !== dateFormat || $2[2] !== dateUtilsLocale || $2[3] !== onUserClicked || $2[4] !== users) {
    t2 = users && users.map((user) => {
      const userRoles = user.roles;
      const formattedDate = user.created_on ? format(user.created_on, dateFormat, {
        locale: dateUtilsLocale
      }) : "";
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow$2, { onClick: () => {
        onUserClicked(user);
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { className: "w-10", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$6, { asChild: true, title: "Delete this user", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$6, { size: "small", onClick: (event) => {
          event.stopPropagation();
          return setUserToBeDeleted(user);
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteIcon$1, {}) }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { children: user.email }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { className: "font-medium align-left", children: user.displayName }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { className: "align-left", children: userRoles ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-2", children: userRoles.map(_temp$e) }) : null }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { children: formattedDate })
      ] }, "row_" + user.uid);
    });
    $2[1] = dateFormat;
    $2[2] = dateUtilsLocale;
    $2[3] = onUserClicked;
    $2[4] = users;
    $2[5] = t2;
  } else {
    t2 = $2[5];
  }
  let t3;
  if ($2[6] !== authController || $2[7] !== saveUser || $2[8] !== snackbarController || $2[9] !== users) {
    t3 = (!users || users.length === 0) && /* @__PURE__ */ jsxRuntimeExports.jsx(TableRow$2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$2, { colspan: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CenteredView$2, { className: "flex flex-col gap-4 my-8 items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$5, { variant: "label", children: "There are no users yet" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button$6, { variant: "outlined", onClick: () => {
        if (!authController.user?.uid) {
          throw Error("UsersTable, authController misconfiguration");
        }
        saveUser({
          uid: authController.user?.uid,
          email: authController.user?.email,
          displayName: authController.user?.displayName,
          photoURL: authController.user?.photoURL,
          providerId: authController.user?.providerId,
          isAnonymous: authController.user?.isAnonymous,
          roles: [{
            id: "admin",
            name: "Admin"
          }],
          created_on: /* @__PURE__ */ new Date()
        }).then(() => {
          snackbarController.open({
            type: "success",
            message: "User added successfully"
          });
        }).catch((error) => {
          snackbarController.open({
            type: "error",
            message: "Error adding user: " + error.message
          });
        });
      }, children: "Add the logged user as an admin" })
    ] }) }) });
    $2[6] = authController;
    $2[7] = saveUser;
    $2[8] = snackbarController;
    $2[9] = users;
    $2[10] = t3;
  } else {
    t3 = $2[10];
  }
  let t4;
  if ($2[11] !== t2 || $2[12] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Table$2, { className: "w-full", children: [
      t1,
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TableBody$2, { children: [
        t2,
        t3
      ] })
    ] });
    $2[11] = t2;
    $2[12] = t3;
    $2[13] = t4;
  } else {
    t4 = $2[13];
  }
  const t5 = Boolean(userToBeDeleted);
  let t6;
  if ($2[14] !== deleteUser || $2[15] !== snackbarController || $2[16] !== userToBeDeleted) {
    t6 = () => {
      if (userToBeDeleted) {
        setDeleteInProgress(true);
        deleteUser(userToBeDeleted).then(() => {
          setUserToBeDeleted(void 0);
        }).catch((error_0) => {
          snackbarController.open({
            type: "error",
            message: "Error deleting user: " + error_0.message
          });
        }).finally(() => {
          setDeleteInProgress(false);
        });
      }
    };
    $2[14] = deleteUser;
    $2[15] = snackbarController;
    $2[16] = userToBeDeleted;
    $2[17] = t6;
  } else {
    t6 = $2[17];
  }
  let t7;
  let t8;
  let t9;
  if ($2[18] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = () => {
      setUserToBeDeleted(void 0);
    };
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "Delete?" });
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "Are you sure you want to delete this user?" });
    $2[18] = t7;
    $2[19] = t8;
    $2[20] = t9;
  } else {
    t7 = $2[18];
    t8 = $2[19];
    t9 = $2[20];
  }
  let t10;
  if ($2[21] !== deleteInProgress || $2[22] !== t5 || $2[23] !== t6) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(ConfirmationDialog$1, { open: t5, loading: deleteInProgress, onAccept: t6, onCancel: t7, title: t8, body: t9 });
    $2[21] = deleteInProgress;
    $2[22] = t5;
    $2[23] = t6;
    $2[24] = t10;
  } else {
    t10 = $2[24];
  }
  let t11;
  if ($2[25] !== t10 || $2[26] !== t4) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "overflow-auto", children: [
      t4,
      t10
    ] });
    $2[25] = t10;
    $2[26] = t4;
    $2[27] = t11;
  } else {
    t11 = $2[27];
  }
  return t11;
}
function _temp$e(userRole) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RoleChip, { role: userRole }, userRole?.id);
}
const UsersView = function UsersView2(t0) {
  const $2 = c_1(16);
  const {
    children
  } = t0;
  const [dialogOpen, setDialogOpen] = useState$5();
  const [selectedUser, setSelectedUser] = useState$5();
  const {
    users,
    usersLimit
  } = useUserManagement();
  const reachedUsersLimit = usersLimit !== void 0 && users && users.length >= usersLimit;
  let t1;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (user) => {
      setSelectedUser(user);
      setDialogOpen(true);
    };
    $2[0] = t1;
  } else {
    t1 = $2[0];
  }
  const onUserClicked = t1;
  let t2;
  if ($2[1] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = () => {
      setDialogOpen(false);
      setSelectedUser(void 0);
    };
    $2[1] = t2;
  } else {
    t2 = $2[1];
  }
  const handleClose = t2;
  let t3;
  if ($2[2] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$5, { gutterBottom: true, variant: "h4", className: "flex-grow", component: "h4", children: "Users" });
    $2[2] = t3;
  } else {
    t3 = $2[2];
  }
  let t4;
  let t5;
  if ($2[3] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon$2, {});
    t5 = () => setDialogOpen(true);
    $2[3] = t4;
    $2[4] = t5;
  } else {
    t4 = $2[3];
    t5 = $2[4];
  }
  let t6;
  if ($2[5] !== reachedUsersLimit) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center mt-12", children: [
      t3,
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button$6, { size: "large", disabled: reachedUsersLimit, startIcon: t4, onClick: t5, children: "Add user" })
    ] });
    $2[5] = reachedUsersLimit;
    $2[6] = t6;
  } else {
    t6 = $2[6];
  }
  let t7;
  if ($2[7] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(UsersTable, { onUserClicked });
    $2[7] = t7;
  } else {
    t7 = $2[7];
  }
  const t8 = selectedUser?.uid ?? "new";
  const t9 = dialogOpen ?? false;
  let t10;
  if ($2[8] !== selectedUser || $2[9] !== t8 || $2[10] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(UserDetailsForm, { open: t9, user: selectedUser, handleClose }, t8);
    $2[8] = selectedUser;
    $2[9] = t8;
    $2[10] = t9;
    $2[11] = t10;
  } else {
    t10 = $2[11];
  }
  let t11;
  if ($2[12] !== children || $2[13] !== t10 || $2[14] !== t6) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$2, { className: "w-full flex flex-col py-4 gap-4", maxWidth: "6xl", children: [
      children,
      t6,
      t7,
      t10
    ] });
    $2[12] = children;
    $2[13] = t10;
    $2[14] = t6;
    $2[15] = t11;
  } else {
    t11 = $2[15];
  }
  return t11;
};
const { unslugify: unslugify$3, resolveEnumValues: resolveEnumValues$1, mergeDeep: mergeDeep$2 } = await importShared("@firecms/core");
const { DocumentReference: DocumentReference$1 } = await importShared("@firebase/firestore");
function findCommonInitialStringInPath(valuesCount) {
  if (!valuesCount) return void 0;
  function getPath(value) {
    if (typeof value === "string") return value;
    else if (value instanceof DocumentReference$1) return value.path;
    else return void 0;
  }
  const strings = valuesCount.values.map((v2) => getPath(v2)).filter((v2) => !!v2);
  const pathWithSlash = strings.find((s) => s.includes("/"));
  if (!pathWithSlash)
    return void 0;
  const searchedPath = pathWithSlash.substr(0, pathWithSlash.lastIndexOf("/"));
  const yep = valuesCount.values.filter((value) => {
    const path = getPath(value);
    if (!path) return false;
    return path.startsWith(searchedPath);
  }).length > valuesCount.values.length / 3 * 2;
  return yep ? searchedPath : void 0;
}
function extractEnumFromValues(values) {
  if (!Array.isArray(values)) {
    return [];
  }
  const enumValues = values.map((value) => {
    if (typeof value === "string") {
      return { id: value, label: unslugify$3(value) };
    } else
      return null;
  }).filter(Boolean);
  enumValues.sort((a, b) => a.label.localeCompare(b.label));
  return enumValues;
}
const IMAGE_EXTENSIONS = [".jpg", ".jpeg", ".png", ".webp", ".gif", ".avif"];
const AUDIO_EXTENSIONS = [".mp3", ".ogg", ".opus", ".aac"];
const VIDEO_EXTENSIONS = [".avi", ".mp4"];
const emailRegEx = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
function buildStringProperty({
  totalDocsCount,
  valuesResult
}) {
  let stringProperty = {
    dataType: "string"
  };
  if (valuesResult) {
    const totalEntriesCount = valuesResult.values.length;
    const totalValues = Array.from(valuesResult.valuesCount.keys()).length;
    const config2 = {};
    const probablyAURL = valuesResult.values.filter((value) => typeof value === "string" && value.toString().startsWith("http")).length > totalDocsCount / 3 * 2;
    if (probablyAURL) {
      config2.url = true;
    }
    const probablyAnEmail = valuesResult.values.filter((value) => typeof value === "string" && emailRegEx.test(value)).length > totalDocsCount / 3 * 2;
    if (probablyAnEmail) {
      config2.email = true;
    }
    const probablyUserIds = valuesResult.values.filter((value) => typeof value === "string" && value.length === 28 && !value.includes(" ")).length > totalDocsCount / 3 * 2;
    if (probablyUserIds)
      config2.readOnly = true;
    if (!probablyAnEmail && !probablyAURL && !probablyUserIds && !probablyAURL && totalValues < totalEntriesCount / 3) {
      const enumValues = extractEnumFromValues(Array.from(valuesResult.valuesCount.keys()));
      if (Object.keys(enumValues).length > 1)
        config2.enumValues = enumValues;
    }
    if (!probablyAnEmail && !probablyAURL && !probablyUserIds && !probablyAURL && !config2.enumValues) {
      const fileType = probableFileType(valuesResult, totalDocsCount);
      if (fileType) {
        config2.storage = {
          acceptedFiles: [fileType],
          storagePath: findCommonInitialStringInPath(valuesResult) ?? "/"
        };
      }
    }
    if (Object.keys(config2).length > 0)
      stringProperty = {
        ...stringProperty,
        ...config2,
        editable: true
      };
  }
  return stringProperty;
}
function probableFileType(valuesCount, totalDocsCount) {
  const probablyAnImage = valuesCount.values.filter((value) => typeof value === "string" && IMAGE_EXTENSIONS.some((extension) => value.toString().endsWith(extension))).length > totalDocsCount / 3 * 2;
  const probablyAudio = valuesCount.values.filter((value) => typeof value === "string" && AUDIO_EXTENSIONS.some((extension) => value.toString().endsWith(extension))).length > totalDocsCount / 3 * 2;
  const probablyVideo = valuesCount.values.filter((value) => typeof value === "string" && VIDEO_EXTENSIONS.some((extension) => value.toString().endsWith(extension))).length > totalDocsCount / 3 * 2;
  const fileType = probablyAnImage ? "image/*" : probablyAudio ? "audio/*" : probablyVideo ? "video/*" : false;
  return fileType;
}
function buildValidation({
  totalDocsCount,
  valuesResult
}) {
  if (valuesResult) {
    const totalEntriesCount = valuesResult.values.length;
    if (totalDocsCount === totalEntriesCount)
      return {
        required: true
      };
  }
  return void 0;
}
function buildReferenceProperty({
  totalDocsCount,
  valuesResult
}) {
  const property = {
    dataType: "reference",
    path: findCommonInitialStringInPath(valuesResult) ?? "!!!FIX_ME!!!",
    editable: true
  };
  return property;
}
async function buildEntityPropertiesFromData(data, getType2) {
  const typesCount = {};
  const valuesCount = {};
  if (data) {
    data.forEach((entry) => {
      if (entry) {
        Object.entries(entry).forEach(([key2, value]) => {
          increaseMapTypeCount(typesCount, key2, value, getType2);
          increaseValuesCount(valuesCount, key2, value, getType2);
        });
      }
    });
  }
  return buildPropertiesFromCount(data.length, typesCount, valuesCount);
}
function buildPropertyFromData(data, property, getType2) {
  const typesCount = {};
  const valuesCount = {};
  if (data) {
    data.forEach((entry) => {
      increaseTypeCount(property.dataType, typesCount, entry, getType2);
      increaseValuesCount(valuesCount, "inferred_prop", entry, getType2);
    });
  }
  const enumValues = "enumValues" in property ? resolveEnumValues$1(property["enumValues"]) : void 0;
  if (enumValues) {
    const newEnumValues = extractEnumFromValues(Array.from(valuesCount["inferred_prop"].valuesCount.keys()));
    return {
      ...property,
      enumValues: [...newEnumValues, ...enumValues]
    };
  }
  const generatedProperty = buildPropertyFromCount(
    "inferred_prop",
    data.length,
    property.dataType,
    typesCount,
    valuesCount["inferred_prop"]
  );
  return mergeDeep$2(generatedProperty, property);
}
function buildPropertiesOrder(properties, propertiesOrder, priorityKeys) {
  const lowerCasePriorityKeys = (priorityKeys ?? []).map((key2) => key2.toLowerCase());
  function propOrder(s) {
    const k2 = s.toLowerCase();
    if (lowerCasePriorityKeys.includes(k2)) return 4;
    if (k2 === "title" || k2 === "name") return 3;
    if (k2.includes("title") || k2.includes("name")) return 2;
    if (k2.includes("image") || k2.includes("picture")) return 1;
    return 0;
  }
  const keys2 = propertiesOrder ?? Object.keys(properties);
  keys2.sort();
  keys2.sort((a, b) => {
    return propOrder(b) - propOrder(a);
  });
  return keys2;
}
function increaseTypeCount(type, typesCount, fieldValue, getType2) {
  if (type === "map") {
    if (fieldValue) {
      let mapTypesCount = typesCount[type];
      if (!mapTypesCount) {
        mapTypesCount = {};
        typesCount[type] = mapTypesCount;
      }
      Object.entries(fieldValue).forEach(([key2, value]) => {
        increaseMapTypeCount(mapTypesCount, key2, value, getType2);
      });
    }
  } else if (type === "array") {
    let arrayTypesCount = typesCount[type];
    if (!arrayTypesCount) {
      arrayTypesCount = {};
      typesCount[type] = arrayTypesCount;
    }
    if (fieldValue && Array.isArray(fieldValue) && fieldValue.length > 0) {
      const arrayType = getMostProbableTypeInArray(fieldValue, getType2);
      if (arrayType === "map") {
        let mapTypesCount = arrayTypesCount[arrayType];
        if (!mapTypesCount) {
          mapTypesCount = {};
        }
        fieldValue.forEach((value) => {
          Object.entries(value).forEach(
            ([key2, v2]) => increaseMapTypeCount(mapTypesCount, key2, v2, getType2)
          );
        });
        arrayTypesCount[arrayType] = mapTypesCount;
      } else {
        if (!arrayTypesCount[arrayType]) arrayTypesCount[arrayType] = 1;
        else arrayTypesCount[arrayType]++;
      }
    }
  } else {
    if (!typesCount[type]) typesCount[type] = 1;
    else typesCount[type]++;
  }
}
function increaseMapTypeCount(typesCountRecord, key2, fieldValue, getType2) {
  let typesCount = typesCountRecord[key2];
  if (!typesCount) {
    typesCount = {};
    typesCountRecord[key2] = typesCount;
  }
  if (fieldValue != null) {
    const type = getType2(fieldValue);
    increaseTypeCount(type, typesCount, fieldValue, getType2);
  }
}
function increaseValuesCount(typeValuesRecord, key2, fieldValue, getType2) {
  const dataType = getType2(fieldValue);
  let valuesRecord = typeValuesRecord[key2];
  if (!valuesRecord) {
    valuesRecord = {
      values: [],
      valuesCount: /* @__PURE__ */ new Map()
    };
    typeValuesRecord[key2] = valuesRecord;
  }
  if (dataType === "map") {
    let mapValuesRecord = valuesRecord.map;
    if (!mapValuesRecord) {
      mapValuesRecord = {};
      valuesRecord.map = mapValuesRecord;
    }
    if (fieldValue)
      Object.entries(fieldValue).forEach(
        ([key22, value]) => increaseValuesCount(mapValuesRecord, key22, value, getType2)
      );
  } else if (dataType === "array") {
    if (Array.isArray(fieldValue)) {
      fieldValue.forEach((value) => {
        valuesRecord.values.push(value);
        valuesRecord.valuesCount.set(value, (valuesRecord.valuesCount.get(value) ?? 0) + 1);
      });
    }
  } else {
    if (fieldValue) {
      valuesRecord.values.push(fieldValue);
      valuesRecord.valuesCount.set(fieldValue, (valuesRecord.valuesCount.get(fieldValue) ?? 0) + 1);
    }
  }
}
function getHighestTypesCount(typesCount) {
  let highestCount = 0;
  Object.entries(typesCount).forEach(([type, count]) => {
    let countValue = 0;
    if (type === "map") {
      countValue = getHighestRecordCount(count);
    } else if (type === "array") {
      countValue = getHighestTypesCount(count);
    } else {
      countValue = count;
    }
    if (countValue > highestCount) {
      highestCount = countValue;
    }
  });
  return highestCount;
}
function getHighestRecordCount(record) {
  return Object.entries(record).map(([key2, typesCount]) => getHighestTypesCount(typesCount)).reduce((a, b) => Math.max(a, b), 0);
}
function getMostProbableType(typesCount) {
  let highestCount = -1;
  let probableType = "string";
  Object.entries(typesCount).forEach(([type, count]) => {
    let countValue;
    if (type === "map") {
      countValue = getHighestRecordCount(count);
    } else if (type === "array") {
      countValue = getHighestTypesCount(count);
    } else {
      countValue = count;
    }
    if (countValue > highestCount) {
      highestCount = countValue;
      probableType = type;
    }
  });
  return probableType;
}
function buildPropertyFromCount(key2, totalDocsCount, mostProbableType, typesCount, valuesResult) {
  let title;
  if (key2) {
    title = formatString(key2.toLowerCase());
  }
  let result = void 0;
  if (mostProbableType === "map") {
    const highVariability = checkTypesCountHighVariability(typesCount);
    if (highVariability) {
      result = {
        dataType: "map",
        name: title,
        keyValue: true,
        properties: {}
      };
    }
    const properties = buildPropertiesFromCount(
      totalDocsCount,
      typesCount.map,
      valuesResult ? valuesResult.mapValues : void 0
    );
    result = {
      dataType: "map",
      name: title,
      properties
    };
  } else if (mostProbableType === "array") {
    const arrayTypesCount = typesCount.array;
    const arrayMostProbableType = getMostProbableType(arrayTypesCount);
    const of = buildPropertyFromCount(
      key2,
      totalDocsCount,
      arrayMostProbableType,
      arrayTypesCount,
      valuesResult
    );
    result = {
      dataType: "array",
      name: title,
      of
    };
  }
  if (!result) {
    const propertyProps = {
      name: key2,
      totalDocsCount,
      valuesResult
    };
    if (mostProbableType === "string") {
      result = buildStringProperty(propertyProps);
    } else if (mostProbableType === "reference") {
      result = buildReferenceProperty(propertyProps);
    } else {
      result = {
        dataType: mostProbableType
      };
    }
    if (title) {
      result.name = title;
    }
    const validation = buildValidation(propertyProps);
    if (validation) {
      result.validation = validation;
    }
  }
  return {
    ...result,
    editable: true
  };
}
function buildPropertiesFromCount(totalDocsCount, typesCountRecord, valuesCountRecord) {
  const res = {};
  Object.entries(typesCountRecord).forEach(([key2, typesCount]) => {
    const mostProbableType = getMostProbableType(typesCount);
    res[key2] = buildPropertyFromCount(
      key2,
      totalDocsCount,
      mostProbableType,
      typesCount,
      valuesCountRecord ? valuesCountRecord[key2] : void 0
    );
  });
  return res;
}
function countMaxDocumentsUnder(typesCount) {
  let count = 0;
  Object.entries(typesCount).forEach(([type, value]) => {
    if (typeof value === "object") {
      count = Math.max(count, countMaxDocumentsUnder(value));
    } else {
      count = Math.max(count, value);
    }
  });
  return count;
}
function getMostProbableTypeInArray(array, getType2) {
  let typesCount = {};
  array.forEach((value) => {
    increaseTypeCount(getType2(value), typesCount, value, getType2);
  });
  return getMostProbableType(typesCount);
}
function checkTypesCountHighVariability(typesCount) {
  const maxCount = countMaxDocumentsUnder(typesCount);
  let keysWithFewValues = 0;
  Object.entries(typesCount.map ?? {}).forEach(([key2, value]) => {
    const count = countMaxDocumentsUnder(value);
    if (count < maxCount / 3) {
      keysWithFewValues++;
    }
  });
  return keysWithFewValues / Object.entries(typesCount.map ?? {}).length > 0.5;
}
function formatString(input) {
  const normalized = input.replace(/[_\-]+/g, " ").replace(/([a-z])([A-Z])/g, "$1 $2").toLowerCase();
  const words = normalized.split(" ");
  const formatted = words.map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
  return formatted;
}
function inferTypeFromValue(value) {
  if (typeof value === "string") return "string";
  if (typeof value === "number") return "number";
  if (typeof value === "boolean") return "boolean";
  if (Array.isArray(value)) return "array";
  if (typeof value === "object") return "map";
  return "string";
}
var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
var unicode = {
  Space_Separator,
  ID_Start,
  ID_Continue
};
var util = {
  isSpaceSeparator(c2) {
    return typeof c2 === "string" && unicode.Space_Separator.test(c2);
  },
  isIdStartChar(c2) {
    return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_" || unicode.ID_Start.test(c2));
  },
  isIdContinueChar(c2) {
    return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "$" || c2 === "_" || c2 === "" || c2 === "" || unicode.ID_Continue.test(c2));
  },
  isDigit(c2) {
    return typeof c2 === "string" && /[0-9]/.test(c2);
  },
  isHexDigit(c2) {
    return typeof c2 === "string" && /[0-9A-Fa-f]/.test(c2);
  }
};
let source;
let parseState;
let stack;
let pos;
let line;
let column;
let token;
let key;
let root;
var parse = function parse2(text, reviver) {
  source = String(text);
  parseState = "start";
  stack = [];
  pos = 0;
  line = 1;
  column = 0;
  token = void 0;
  key = void 0;
  root = void 0;
  do {
    token = lex();
    parseStates[parseState]();
  } while (token.type !== "eof");
  if (typeof reviver === "function") {
    return internalize({ "": root }, "", reviver);
  }
  return root;
};
function internalize(holder, name, reviver) {
  const value = holder[name];
  if (value != null && typeof value === "object") {
    if (Array.isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        const key2 = String(i);
        const replacement = internalize(value, key2, reviver);
        if (replacement === void 0) {
          delete value[key2];
        } else {
          Object.defineProperty(value, key2, {
            value: replacement,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
    } else {
      for (const key2 in value) {
        const replacement = internalize(value, key2, reviver);
        if (replacement === void 0) {
          delete value[key2];
        } else {
          Object.defineProperty(value, key2, {
            value: replacement,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
    }
  }
  return reviver.call(holder, name, value);
}
let lexState;
let buffer;
let doubleQuote;
let sign;
let c;
function lex() {
  lexState = "default";
  buffer = "";
  doubleQuote = false;
  sign = 1;
  for (; ; ) {
    c = peek();
    const token2 = lexStates[lexState]();
    if (token2) {
      return token2;
    }
  }
}
function peek() {
  if (source[pos]) {
    return String.fromCodePoint(source.codePointAt(pos));
  }
}
function read() {
  const c2 = peek();
  if (c2 === "\n") {
    line++;
    column = 0;
  } else if (c2) {
    column += c2.length;
  } else {
    column++;
  }
  if (c2) {
    pos += c2.length;
  }
  return c2;
}
const lexStates = {
  default() {
    switch (c) {
      case "	":
      case "\v":
      case "\f":
      case " ":
      case "":
      case "\uFEFF":
      case "\n":
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        return;
      case "/":
        read();
        lexState = "comment";
        return;
      case void 0:
        read();
        return newToken("eof");
    }
    if (util.isSpaceSeparator(c)) {
      read();
      return;
    }
    return lexStates[parseState]();
  },
  comment() {
    switch (c) {
      case "*":
        read();
        lexState = "multiLineComment";
        return;
      case "/":
        read();
        lexState = "singleLineComment";
        return;
    }
    throw invalidChar(read());
  },
  multiLineComment() {
    switch (c) {
      case "*":
        read();
        lexState = "multiLineCommentAsterisk";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
  },
  multiLineCommentAsterisk() {
    switch (c) {
      case "*":
        read();
        return;
      case "/":
        read();
        lexState = "default";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
    lexState = "multiLineComment";
  },
  singleLineComment() {
    switch (c) {
      case "\n":
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        lexState = "default";
        return;
      case void 0:
        read();
        return newToken("eof");
    }
    read();
  },
  value() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
      case "n":
        read();
        literal("ull");
        return newToken("null", null);
      case "t":
        read();
        literal("rue");
        return newToken("boolean", true);
      case "f":
        read();
        literal("alse");
        return newToken("boolean", false);
      case "-":
      case "+":
        if (read() === "-") {
          sign = -1;
        }
        lexState = "sign";
        return;
      case ".":
        buffer = read();
        lexState = "decimalPointLeading";
        return;
      case "0":
        buffer = read();
        lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer = read();
        lexState = "decimalInteger";
        return;
      case "I":
        read();
        literal("nfinity");
        return newToken("numeric", Infinity);
      case "N":
        read();
        literal("aN");
        return newToken("numeric", NaN);
      case '"':
      case "'":
        doubleQuote = read() === '"';
        buffer = "";
        lexState = "string";
        return;
    }
    throw invalidChar(read());
  },
  identifierNameStartEscape() {
    if (c !== "u") {
      throw invalidChar(read());
    }
    read();
    const u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
        break;
      default:
        if (!util.isIdStartChar(u)) {
          throw invalidIdentifier();
        }
        break;
    }
    buffer += u;
    lexState = "identifierName";
  },
  identifierName() {
    switch (c) {
      case "$":
      case "_":
      case "":
      case "":
        buffer += read();
        return;
      case "\\":
        read();
        lexState = "identifierNameEscape";
        return;
    }
    if (util.isIdContinueChar(c)) {
      buffer += read();
      return;
    }
    return newToken("identifier", buffer);
  },
  identifierNameEscape() {
    if (c !== "u") {
      throw invalidChar(read());
    }
    read();
    const u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
      case "":
      case "":
        break;
      default:
        if (!util.isIdContinueChar(u)) {
          throw invalidIdentifier();
        }
        break;
    }
    buffer += u;
    lexState = "identifierName";
  },
  sign() {
    switch (c) {
      case ".":
        buffer = read();
        lexState = "decimalPointLeading";
        return;
      case "0":
        buffer = read();
        lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer = read();
        lexState = "decimalInteger";
        return;
      case "I":
        read();
        literal("nfinity");
        return newToken("numeric", sign * Infinity);
      case "N":
        read();
        literal("aN");
        return newToken("numeric", NaN);
    }
    throw invalidChar(read());
  },
  zero() {
    switch (c) {
      case ".":
        buffer += read();
        lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
      case "x":
      case "X":
        buffer += read();
        lexState = "hexadecimal";
        return;
    }
    return newToken("numeric", sign * 0);
  },
  decimalInteger() {
    switch (c) {
      case ".":
        buffer += read();
        lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalPointLeading() {
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalFraction";
      return;
    }
    throw invalidChar(read());
  },
  decimalPoint() {
    switch (c) {
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalFraction";
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalFraction() {
    switch (c) {
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalExponent() {
    switch (c) {
      case "+":
      case "-":
        buffer += read();
        lexState = "decimalExponentSign";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentSign() {
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentInteger() {
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  hexadecimal() {
    if (util.isHexDigit(c)) {
      buffer += read();
      lexState = "hexadecimalInteger";
      return;
    }
    throw invalidChar(read());
  },
  hexadecimalInteger() {
    if (util.isHexDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  string() {
    switch (c) {
      case "\\":
        read();
        buffer += escape();
        return;
      case '"':
        if (doubleQuote) {
          read();
          return newToken("string", buffer);
        }
        buffer += read();
        return;
      case "'":
        if (!doubleQuote) {
          read();
          return newToken("string", buffer);
        }
        buffer += read();
        return;
      case "\n":
      case "\r":
        throw invalidChar(read());
      case "\u2028":
      case "\u2029":
        separatorChar(c);
        break;
      case void 0:
        throw invalidChar(read());
    }
    buffer += read();
  },
  start() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
    }
    lexState = "value";
  },
  beforePropertyName() {
    switch (c) {
      case "$":
      case "_":
        buffer = read();
        lexState = "identifierName";
        return;
      case "\\":
        read();
        lexState = "identifierNameStartEscape";
        return;
      case "}":
        return newToken("punctuator", read());
      case '"':
      case "'":
        doubleQuote = read() === '"';
        lexState = "string";
        return;
    }
    if (util.isIdStartChar(c)) {
      buffer += read();
      lexState = "identifierName";
      return;
    }
    throw invalidChar(read());
  },
  afterPropertyName() {
    if (c === ":") {
      return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  beforePropertyValue() {
    lexState = "value";
  },
  afterPropertyValue() {
    switch (c) {
      case ",":
      case "}":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  beforeArrayValue() {
    if (c === "]") {
      return newToken("punctuator", read());
    }
    lexState = "value";
  },
  afterArrayValue() {
    switch (c) {
      case ",":
      case "]":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  end() {
    throw invalidChar(read());
  }
};
function newToken(type, value) {
  return {
    type,
    value,
    line,
    column
  };
}
function literal(s) {
  for (const c2 of s) {
    const p = peek();
    if (p !== c2) {
      throw invalidChar(read());
    }
    read();
  }
}
function escape() {
  const c2 = peek();
  switch (c2) {
    case "b":
      read();
      return "\b";
    case "f":
      read();
      return "\f";
    case "n":
      read();
      return "\n";
    case "r":
      read();
      return "\r";
    case "t":
      read();
      return "	";
    case "v":
      read();
      return "\v";
    case "0":
      read();
      if (util.isDigit(peek())) {
        throw invalidChar(read());
      }
      return "\0";
    case "x":
      read();
      return hexEscape();
    case "u":
      read();
      return unicodeEscape();
    case "\n":
    case "\u2028":
    case "\u2029":
      read();
      return "";
    case "\r":
      read();
      if (peek() === "\n") {
        read();
      }
      return "";
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      throw invalidChar(read());
    case void 0:
      throw invalidChar(read());
  }
  return read();
}
function hexEscape() {
  let buffer2 = "";
  let c2 = peek();
  if (!util.isHexDigit(c2)) {
    throw invalidChar(read());
  }
  buffer2 += read();
  c2 = peek();
  if (!util.isHexDigit(c2)) {
    throw invalidChar(read());
  }
  buffer2 += read();
  return String.fromCodePoint(parseInt(buffer2, 16));
}
function unicodeEscape() {
  let buffer2 = "";
  let count = 4;
  while (count-- > 0) {
    const c2 = peek();
    if (!util.isHexDigit(c2)) {
      throw invalidChar(read());
    }
    buffer2 += read();
  }
  return String.fromCodePoint(parseInt(buffer2, 16));
}
const parseStates = {
  start() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    push();
  },
  beforePropertyName() {
    switch (token.type) {
      case "identifier":
      case "string":
        key = token.value;
        parseState = "afterPropertyName";
        return;
      case "punctuator":
        pop();
        return;
      case "eof":
        throw invalidEOF();
    }
  },
  afterPropertyName() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    parseState = "beforePropertyValue";
  },
  beforePropertyValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    push();
  },
  beforeArrayValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    if (token.type === "punctuator" && token.value === "]") {
      pop();
      return;
    }
    push();
  },
  afterPropertyValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    switch (token.value) {
      case ",":
        parseState = "beforePropertyName";
        return;
      case "}":
        pop();
    }
  },
  afterArrayValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    switch (token.value) {
      case ",":
        parseState = "beforeArrayValue";
        return;
      case "]":
        pop();
    }
  },
  end() {
  }
};
function push() {
  let value;
  switch (token.type) {
    case "punctuator":
      switch (token.value) {
        case "{":
          value = {};
          break;
        case "[":
          value = [];
          break;
      }
      break;
    case "null":
    case "boolean":
    case "numeric":
    case "string":
      value = token.value;
      break;
  }
  if (root === void 0) {
    root = value;
  } else {
    const parent = stack[stack.length - 1];
    if (Array.isArray(parent)) {
      parent.push(value);
    } else {
      Object.defineProperty(parent, key, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  if (value !== null && typeof value === "object") {
    stack.push(value);
    if (Array.isArray(value)) {
      parseState = "beforeArrayValue";
    } else {
      parseState = "beforePropertyName";
    }
  } else {
    const current = stack[stack.length - 1];
    if (current == null) {
      parseState = "end";
    } else if (Array.isArray(current)) {
      parseState = "afterArrayValue";
    } else {
      parseState = "afterPropertyValue";
    }
  }
}
function pop() {
  stack.pop();
  const current = stack[stack.length - 1];
  if (current == null) {
    parseState = "end";
  } else if (Array.isArray(current)) {
    parseState = "afterArrayValue";
  } else {
    parseState = "afterPropertyValue";
  }
}
function invalidChar(c2) {
  if (c2 === void 0) {
    return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
  }
  return syntaxError(`JSON5: invalid character '${formatChar(c2)}' at ${line}:${column}`);
}
function invalidEOF() {
  return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
}
function invalidIdentifier() {
  column -= 5;
  return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
}
function separatorChar(c2) {
  console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
}
function formatChar(c2) {
  const replacements = {
    "'": "\\'",
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\v": "\\v",
    "\0": "\\0",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  if (replacements[c2]) {
    return replacements[c2];
  }
  if (c2 < " ") {
    const hexString = c2.charCodeAt(0).toString(16);
    return "\\x" + ("00" + hexString).substring(hexString.length);
  }
  return c2;
}
function syntaxError(message) {
  const err = new SyntaxError(message);
  err.lineNumber = line;
  err.columnNumber = column;
  return err;
}
var stringify = function stringify2(value, replacer, space) {
  const stack2 = [];
  let indent = "";
  let propertyList;
  let replacerFunc;
  let gap = "";
  let quote;
  if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
    space = replacer.space;
    quote = replacer.quote;
    replacer = replacer.replacer;
  }
  if (typeof replacer === "function") {
    replacerFunc = replacer;
  } else if (Array.isArray(replacer)) {
    propertyList = [];
    for (const v2 of replacer) {
      let item;
      if (typeof v2 === "string") {
        item = v2;
      } else if (typeof v2 === "number" || v2 instanceof String || v2 instanceof Number) {
        item = String(v2);
      }
      if (item !== void 0 && propertyList.indexOf(item) < 0) {
        propertyList.push(item);
      }
    }
  }
  if (space instanceof Number) {
    space = Number(space);
  } else if (space instanceof String) {
    space = String(space);
  }
  if (typeof space === "number") {
    if (space > 0) {
      space = Math.min(10, Math.floor(space));
      gap = "          ".substr(0, space);
    }
  } else if (typeof space === "string") {
    gap = space.substr(0, 10);
  }
  return serializeProperty("", { "": value });
  function serializeProperty(key2, holder) {
    let value2 = holder[key2];
    if (value2 != null) {
      if (typeof value2.toJSON5 === "function") {
        value2 = value2.toJSON5(key2);
      } else if (typeof value2.toJSON === "function") {
        value2 = value2.toJSON(key2);
      }
    }
    if (replacerFunc) {
      value2 = replacerFunc.call(holder, key2, value2);
    }
    if (value2 instanceof Number) {
      value2 = Number(value2);
    } else if (value2 instanceof String) {
      value2 = String(value2);
    } else if (value2 instanceof Boolean) {
      value2 = value2.valueOf();
    }
    switch (value2) {
      case null:
        return "null";
      case true:
        return "true";
      case false:
        return "false";
    }
    if (typeof value2 === "string") {
      return quoteString(value2);
    }
    if (typeof value2 === "number") {
      return String(value2);
    }
    if (typeof value2 === "object") {
      return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
    }
    return void 0;
  }
  function quoteString(value2) {
    const quotes = {
      "'": 0.1,
      '"': 0.2
    };
    const replacements = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    let product = "";
    for (let i = 0; i < value2.length; i++) {
      const c2 = value2[i];
      switch (c2) {
        case "'":
        case '"':
          quotes[c2]++;
          product += c2;
          continue;
        case "\0":
          if (util.isDigit(value2[i + 1])) {
            product += "\\x00";
            continue;
          }
      }
      if (replacements[c2]) {
        product += replacements[c2];
        continue;
      }
      if (c2 < " ") {
        let hexString = c2.charCodeAt(0).toString(16);
        product += "\\x" + ("00" + hexString).substring(hexString.length);
        continue;
      }
      product += c2;
    }
    const quoteChar = quote || Object.keys(quotes).reduce((a, b) => quotes[a] < quotes[b] ? a : b);
    product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
    return quoteChar + product + quoteChar;
  }
  function serializeObject(value2) {
    if (stack2.indexOf(value2) >= 0) {
      throw TypeError("Converting circular structure to JSON5");
    }
    stack2.push(value2);
    let stepback = indent;
    indent = indent + gap;
    let keys2 = propertyList || Object.keys(value2);
    let partial = [];
    for (const key2 of keys2) {
      const propertyString = serializeProperty(key2, value2);
      if (propertyString !== void 0) {
        let member = serializeKey(key2) + ":";
        if (gap !== "") {
          member += " ";
        }
        member += propertyString;
        partial.push(member);
      }
    }
    let final;
    if (partial.length === 0) {
      final = "{}";
    } else {
      let properties;
      if (gap === "") {
        properties = partial.join(",");
        final = "{" + properties + "}";
      } else {
        let separator = ",\n" + indent;
        properties = partial.join(separator);
        final = "{\n" + indent + properties + ",\n" + stepback + "}";
      }
    }
    stack2.pop();
    indent = stepback;
    return final;
  }
  function serializeKey(key2) {
    if (key2.length === 0) {
      return quoteString(key2);
    }
    const firstChar = String.fromCodePoint(key2.codePointAt(0));
    if (!util.isIdStartChar(firstChar)) {
      return quoteString(key2);
    }
    for (let i = firstChar.length; i < key2.length; i++) {
      if (!util.isIdContinueChar(String.fromCodePoint(key2.codePointAt(i)))) {
        return quoteString(key2);
      }
    }
    return key2;
  }
  function serializeArray(value2) {
    if (stack2.indexOf(value2) >= 0) {
      throw TypeError("Converting circular structure to JSON5");
    }
    stack2.push(value2);
    let stepback = indent;
    indent = indent + gap;
    let partial = [];
    for (let i = 0; i < value2.length; i++) {
      const propertyString = serializeProperty(String(i), value2);
      partial.push(propertyString !== void 0 ? propertyString : "null");
    }
    let final;
    if (partial.length === 0) {
      final = "[]";
    } else {
      if (gap === "") {
        let properties = partial.join(",");
        final = "[" + properties + "]";
      } else {
        let separator = ",\n" + indent;
        let properties = partial.join(separator);
        final = "[\n" + indent + properties + ",\n" + stepback + "]";
      }
    }
    stack2.pop();
    indent = stepback;
    return final;
  }
};
const JSON5 = {
  parse,
  stringify
};
var lib = JSON5;
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source2, exclude) => {
  var target = {};
  for (var prop in source2)
    if (__hasOwnProp.call(source2, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source2[prop];
  if (source2 != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source2)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source2, prop))
        target[prop] = source2[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var require_prism = __commonJS({
  "../../node_modules/.pnpm/prismjs@1.29.0_patch_hash=vrxx3pzkik6jpmgpayxfjunetu/node_modules/prismjs/prism.js"(exports, module) {
    var Prism2 = function() {
      var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _2 = {
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function encode(tokens) {
            if (tokens instanceof Token) {
              return new Token(tokens.type, encode(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(o) {
            return Object.prototype.toString.call(o).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function deepClone(o, visited) {
            visited = visited || {};
            var clone2;
            var id;
            switch (_2.util.type(o)) {
              case "Object":
                id = _2.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone2 = /** @type {Record<string, any>} */
                {};
                visited[id] = clone2;
                for (var key2 in o) {
                  if (o.hasOwnProperty(key2)) {
                    clone2[key2] = deepClone(o[key2], visited);
                  }
                }
                return (
                  /** @type {any} */
                  clone2
                );
              case "Array":
                id = _2.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone2 = [];
                visited[id] = clone2;
                o.forEach(function(v2, i) {
                  clone2[i] = deepClone(v2, visited);
                });
                return (
                  /** @type {any} */
                  clone2
                );
              default:
                return o;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(element) {
            while (element) {
              var m = lang.exec(element.className);
              if (m) {
                return m[1].toLowerCase();
              }
              element = element.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(element, language) {
            element.className = element.className.replace(RegExp(lang, "gi"), "");
            element.classList.add("language-" + language);
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(element, className, defaultActivation) {
            var no = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(id, redef) {
            var lang2 = _2.util.clone(_2.languages[id]);
            for (var key2 in redef) {
              lang2[key2] = redef[key2];
            }
            return lang2;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(inside, before, insert, root2) {
            root2 = root2 || /** @type {any} */
            _2.languages;
            var grammar = root2[inside];
            var ret = {};
            for (var token2 in grammar) {
              if (grammar.hasOwnProperty(token2)) {
                if (token2 == before) {
                  for (var newToken2 in insert) {
                    if (insert.hasOwnProperty(newToken2)) {
                      ret[newToken2] = insert[newToken2];
                    }
                  }
                }
                if (!insert.hasOwnProperty(token2)) {
                  ret[token2] = grammar[token2];
                }
              }
            }
            var old = root2[inside];
            root2[inside] = ret;
            _2.languages.DFS(_2.languages, function(key2, value) {
              if (value === old && key2 != inside) {
                this[key2] = ret;
              }
            });
            return ret;
          },
          // Traverse a language definition with Depth First Search
          DFS: function DFS(o, callback, type, visited) {
            visited = visited || {};
            var objId = _2.util.objId;
            for (var i in o) {
              if (o.hasOwnProperty(i)) {
                callback.call(o, i, o[i], type || i);
                var property = o[i];
                var propertyType = _2.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i, visited);
                }
              }
            }
          }
        },
        plugins: {},
        /**
         * Low-level function, only use if you know what youre doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(text, grammar, language) {
          var env = {
            code: text,
            grammar,
            language
          };
          _2.hooks.run("before-tokenize", env);
          if (!env.grammar) {
            throw new Error('The language "' + env.language + '" has no grammar.');
          }
          env.tokens = _2.tokenize(env.code, env.grammar);
          _2.hooks.run("after-tokenize", env);
          return Token.stringify(_2.util.encode(env.tokens), env.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token2 in rest) {
              grammar[token2] = rest[token2];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text);
          matchGrammar(text, tokenList, grammar, tokenList.head, 0);
          return toArray(tokenList);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(name, callback) {
            var hooks2 = _2.hooks.all;
            hooks2[name] = hooks2[name] || [];
            hooks2[name].push(callback);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(name, env) {
            var callbacks = _2.hooks.all[name];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i = 0, callback; callback = callbacks[i++]; ) {
              callback(env);
            }
          }
        },
        Token
      };
      function Token(type, content, alias, matchedStr) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify3(o, language) {
        if (typeof o == "string") {
          return o;
        }
        if (Array.isArray(o)) {
          var s = "";
          o.forEach(function(e) {
            s += stringify3(e, language);
          });
          return s;
        }
        var env = {
          type: o.type,
          content: stringify3(o.content, language),
          tag: "span",
          classes: ["token", o.type],
          attributes: {},
          language
        };
        var aliases = o.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env.classes, aliases);
          } else {
            env.classes.push(aliases);
          }
        }
        _2.hooks.run("wrap", env);
        var attributes = "";
        for (var name in env.attributes) {
          attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos2, text, lookbehind) {
        pattern.lastIndex = pos2;
        var match = pattern.exec(text);
        if (match && lookbehind && match[1]) {
          var lookbehindLength = match[1].length;
          match.index += lookbehindLength;
          match[0] = match[0].slice(lookbehindLength);
        }
        return match;
      }
      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token2 in grammar) {
          if (!grammar.hasOwnProperty(token2) || !grammar[token2]) {
            continue;
          }
          var patterns = grammar[token2];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j = 0; j < patterns.length; ++j) {
            if (rematch && rematch.cause == token2 + "," + j) {
              return;
            }
            var patternObj = patterns[j];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos2 = startPos; currentNode !== tokenList.tail; pos2 += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos2 >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match;
              if (greedy) {
                match = matchPattern(pattern, pos2, text, lookbehind);
                if (!match || match.index >= text.length) {
                  break;
                }
                var from = match.index;
                var to = match.index + match[0].length;
                var p = pos2;
                p += currentNode.value.length;
                while (from >= p) {
                  currentNode = currentNode.next;
                  p += currentNode.value.length;
                }
                p -= currentNode.value.length;
                pos2 = p;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k2 = currentNode; k2 !== tokenList.tail && (p < to || typeof k2.value === "string"); k2 = k2.next) {
                  removeCount++;
                  p += k2.value.length;
                }
                removeCount--;
                str = text.slice(pos2, p);
                match.index -= pos2;
              } else {
                match = matchPattern(pattern, 0, str, lookbehind);
                if (!match) {
                  continue;
                }
              }
              var from = match.index;
              var matchStr = match[0];
              var before = str.slice(0, from);
              var after = str.slice(from + matchStr.length);
              var reach = pos2 + str.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos2 += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token2, inside ? _2.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token2 + "," + j,
                  reach
                };
                matchGrammar(text, tokenList, grammar, currentNode.prev, pos2, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value) {
        var next = node.next;
        var newNode = { value, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node, count) {
        var next = node.next;
        for (var i = 0; i < count && next !== list.tail; i++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i;
      }
      function toArray(list) {
        var array = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array.push(node.value);
          node = node.next;
        }
        return array;
      }
      return _2;
    }();
    module.exports = Prism2;
    Prism2.default = Prism2;
  }
});
var Prism = __toESM(require_prism());
Prism.languages.markup = { comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: true }, prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: true }, doctype: { pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i, greedy: true, inside: { "internal-subset": { pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/, lookbehind: true, greedy: true, inside: null }, string: { pattern: /"[^"]*"|'[^']*'/, greedy: true }, punctuation: /^<!|>$|[[\]]/, "doctype-tag": /^DOCTYPE/i, name: /[^\s<>'"]+/ } }, cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: true }, tag: { pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/, greedy: true, inside: { tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, "special-attr": [], "attr-value": { pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, inside: { punctuation: [{ pattern: /^=/, alias: "attr-equals" }, { pattern: /^(\s*)["']|["']$/, lookbehind: true }] } }, punctuation: /\/?>/, "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } } } }, entity: [{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\da-f]{1,8};/i] }, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup, Prism.hooks.add("wrap", function(e) {
  "entity" === e.type && (e.attributes.title = e.content.replace(/&amp;/, "&"));
}), Object.defineProperty(Prism.languages.markup.tag, "addInlined", { value: function(e, n) {
  var t = {}, t = (t["language-" + n] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: true, inside: Prism.languages[n] }, t.cdata = /^<!\[CDATA\[|\]\]>$/i, { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: t } }), n = (t["language-" + n] = { pattern: /[\s\S]+/, inside: Prism.languages[n] }, {});
  n[e] = { pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
    return e;
  }), "i"), lookbehind: true, greedy: true, inside: t }, Prism.languages.insertBefore("markup", "cdata", n);
} }), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", { value: function(e, n) {
  Prism.languages.markup.tag.inside["special-attr"].push({ pattern: RegExp(/(^|["'\s])/.source + "(?:" + e + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"), lookbehind: true, inside: { "attr-name": /^[^\s=]+/, "attr-value": { pattern: /=[\s\S]+/, inside: { value: { pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/, lookbehind: true, alias: [n, "language-" + n], inside: Prism.languages[n] }, punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/] } } } });
} }), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml, function(e) {
  var n = { pattern: /\\[\\(){}[\]^$+*?|.]/, alias: "escape" }, t = /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/, a = "(?:[^\\\\-]|" + t.source + ")", a = RegExp(a + "-" + a), r = { pattern: /(<|')[^<>']+(?=[>']$)/, lookbehind: true, alias: "variable" };
  e.languages.regex = { "char-class": { pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/, lookbehind: true, inside: { "char-class-negation": { pattern: /(^\[)\^/, lookbehind: true, alias: "operator" }, "char-class-punctuation": { pattern: /^\[|\]$/, alias: "punctuation" }, range: { pattern: a, inside: { escape: t, "range-punctuation": { pattern: /-/, alias: "operator" } } }, "special-escape": n, "char-set": { pattern: /\\[wsd]|\\p\{[^{}]+\}/i, alias: "class-name" }, escape: t } }, "special-escape": n, "char-set": { pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i, alias: "class-name" }, backreference: [{ pattern: /\\(?![123][0-7]{2})[1-9]/, alias: "keyword" }, { pattern: /\\k<[^<>']+>/, alias: "keyword", inside: { "group-name": r } }], anchor: { pattern: /[$^]|\\[ABbGZz]/, alias: "function" }, escape: t, group: [{ pattern: /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/, alias: "punctuation", inside: { "group-name": r } }, { pattern: /\)/, alias: "punctuation" }], quantifier: { pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/, alias: "number" }, alternation: { pattern: /\|/, alias: "keyword" } };
}(Prism), Prism.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true, greedy: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/, boolean: /\b(?:false|true)\b/, function: /\b\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/, punctuation: /[{}[\];(),.:]/ }, Prism.languages.javascript = Prism.languages.extend("clike", { "class-name": [Prism.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/, lookbehind: true }], keyword: [{ pattern: /((?:^|\})\s*)catch\b/, lookbehind: true }, { pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, number: { pattern: RegExp(/(^|[^\w$])/.source + "(?:" + /NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source + ")" + /(?![\w$])/.source), lookbehind: true }, operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/ }), Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, Prism.languages.insertBefore("javascript", "keyword", { regex: { pattern: RegExp(/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source), lookbehind: true, greedy: true, inside: { "regex-source": { pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/, lookbehind: true, alias: "language-regex", inside: Prism.languages.regex }, "regex-delimiter": /^\/|\/$/, "regex-flags": /^[a-z]+$/ } }, "function-variable": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/, lookbehind: true, inside: Prism.languages.javascript }, { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i, lookbehind: true, inside: Prism.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/, lookbehind: true, inside: Prism.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/, lookbehind: true, inside: Prism.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ }), Prism.languages.insertBefore("javascript", "string", { hashbang: { pattern: /^#!.*/, greedy: true, alias: "comment" }, "template-string": { pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/, greedy: true, inside: { "template-punctuation": { pattern: /^`|`$/, alias: "string" }, interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/, lookbehind: true, inside: { "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "punctuation" }, rest: Prism.languages.javascript } }, string: /[\s\S]+/ } }, "string-property": { pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m, lookbehind: true, greedy: true, alias: "property" } }), Prism.languages.insertBefore("javascript", "operator", { "literal-property": { pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m, lookbehind: true, alias: "property" } }), Prism.languages.markup && (Prism.languages.markup.tag.addInlined("script", "javascript"), Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript")), Prism.languages.js = Prism.languages.javascript, Prism.languages.actionscript = Prism.languages.extend("javascript", { keyword: /\b(?:as|break|case|catch|class|const|default|delete|do|dynamic|each|else|extends|final|finally|for|function|get|if|implements|import|in|include|instanceof|interface|internal|is|namespace|native|new|null|override|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|use|var|void|while|with)\b/, operator: /\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/ }), Prism.languages.actionscript["class-name"].alias = "function", delete Prism.languages.actionscript.parameter, delete Prism.languages.actionscript["literal-property"], Prism.languages.markup && Prism.languages.insertBefore("actionscript", "string", { xml: { pattern: /(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/, lookbehind: true, inside: Prism.languages.markup } }), function(e) {
  var n = /#(?!\{).+/, t = { pattern: /#\{[^}]+\}/, alias: "variable" };
  e.languages.coffeescript = e.languages.extend("javascript", { comment: n, string: [{ pattern: /'(?:\\[\s\S]|[^\\'])*'/, greedy: true }, { pattern: /"(?:\\[\s\S]|[^\\"])*"/, greedy: true, inside: { interpolation: t } }], keyword: /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/, "class-member": { pattern: /@(?!\d)\w+/, alias: "variable" } }), e.languages.insertBefore("coffeescript", "comment", { "multiline-comment": { pattern: /###[\s\S]+?###/, alias: "comment" }, "block-regex": { pattern: /\/{3}[\s\S]*?\/{3}/, alias: "regex", inside: { comment: n, interpolation: t } } }), e.languages.insertBefore("coffeescript", "string", { "inline-javascript": { pattern: /`(?:\\[\s\S]|[^\\`])*`/, inside: { delimiter: { pattern: /^`|`$/, alias: "punctuation" }, script: { pattern: /[\s\S]+/, alias: "language-javascript", inside: e.languages.javascript } } }, "multiline-string": [{ pattern: /'''[\s\S]*?'''/, greedy: true, alias: "string" }, { pattern: /"""[\s\S]*?"""/, greedy: true, alias: "string", inside: { interpolation: t } }] }), e.languages.insertBefore("coffeescript", "keyword", { property: /(?!\d)\w+(?=\s*:(?!:))/ }), delete e.languages.coffeescript["template-string"], e.languages.coffee = e.languages.coffeescript;
}(Prism), function(l2) {
  var e = l2.languages.javadoclike = { parameter: { pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*@(?:arg|arguments|param)\s+)\w+/m, lookbehind: true }, keyword: { pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*|\{)@[a-z][a-zA-Z-]+\b/m, lookbehind: true }, punctuation: /[{}]/ };
  Object.defineProperty(e, "addSupport", { value: function(e2, o) {
    (e2 = "string" == typeof e2 ? [e2] : e2).forEach(function(e3) {
      var n = function(e4) {
        e4.inside || (e4.inside = {}), e4.inside.rest = o;
      }, t = "doc-comment";
      if (a = l2.languages[e3]) {
        var a, r = a[t];
        if ((r = r ? r : (a = l2.languages.insertBefore(e3, "comment", { "doc-comment": { pattern: /(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/, lookbehind: true, alias: "comment" } }))[t]) instanceof RegExp && (r = a[t] = { pattern: r }), Array.isArray(r))
          for (var s = 0, i = r.length; s < i; s++)
            r[s] instanceof RegExp && (r[s] = { pattern: r[s] }), n(r[s]);
        else
          n(r);
      }
    });
  } }), e.addSupport(["java", "javascript", "php"], e);
}(Prism), function(e) {
  var n = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/, n = (e.languages.css = { comment: /\/\*[\s\S]*?\*\//, atrule: { pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + n.source + ")*?" + /(?:;|(?=\s*\{))/.source), inside: { rule: /^@[\w-]+/, "selector-function-argument": { pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/, lookbehind: true, alias: "selector" }, keyword: { pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/, lookbehind: true } } }, url: { pattern: RegExp("\\burl\\((?:" + n.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"), greedy: true, inside: { function: /^url/i, punctuation: /^\(|\)$/, string: { pattern: RegExp("^" + n.source + "$"), alias: "url" } } }, selector: { pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + n.source + ")*(?=\\s*\\{)"), lookbehind: true }, string: { pattern: n, greedy: true }, property: { pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i, lookbehind: true }, important: /!important\b/i, function: { pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i, lookbehind: true }, punctuation: /[(){};:,]/ }, e.languages.css.atrule.inside.rest = e.languages.css, e.languages.markup);
  n && (n.tag.addInlined("style", "css"), n.tag.addAttribute("style", "css"));
}(Prism), function(e) {
  var n = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, n = (e.languages.css.selector = { pattern: e.languages.css.selector.pattern, lookbehind: true, inside: n = { "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/, "pseudo-class": /:[-\w]+/, class: /\.[-\w]+/, id: /#[-\w]+/, attribute: { pattern: RegExp(`\\[(?:[^[\\]"']|` + n.source + ")*\\]"), greedy: true, inside: { punctuation: /^\[|\]$/, "case-sensitivity": { pattern: /(\s)[si]$/i, lookbehind: true, alias: "keyword" }, namespace: { pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/, lookbehind: true, inside: { punctuation: /\|$/ } }, "attr-name": { pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/, lookbehind: true }, "attr-value": [n, { pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/, lookbehind: true }], operator: /[|~*^$]?=/ } }, "n-th": [{ pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/, lookbehind: true, inside: { number: /[\dn]+/, operator: /[+-]/ } }, { pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i, lookbehind: true }], combinator: />|\+|~|\|\|/, punctuation: /[(),]/ } }, e.languages.css.atrule.inside["selector-function-argument"].inside = n, e.languages.insertBefore("css", "property", { variable: { pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i, lookbehind: true } }), { pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/, lookbehind: true }), t = { pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/, lookbehind: true };
  e.languages.insertBefore("css", "function", { operator: { pattern: /(\s)[+\-*\/](?=\s)/, lookbehind: true }, hexcode: { pattern: /\B#[\da-f]{3,8}\b/i, alias: "color" }, color: [{ pattern: /(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|RebeccaPurple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i, lookbehind: true }, { pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i, inside: { unit: n, number: t, function: /[\w-]+(?=\()/, punctuation: /[(),]/ } }], entity: /\\[\da-f]{1,8}/i, unit: n, number: t });
}(Prism), function(e) {
  var n = /[*&][^\s[\]{},]+/, t = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/, a = "(?:" + t.source + "(?:[ 	]+" + n.source + ")?|" + n.source + "(?:[ 	]+" + t.source + ")?)", r = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
    return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
  }), s = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
  function i(e2, n2) {
    n2 = (n2 || "").replace(/m/g, "") + "m";
    var t2 = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
      return a;
    }).replace(/<<value>>/g, function() {
      return e2;
    });
    return RegExp(t2, n2);
  }
  e.languages.yaml = { scalar: { pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
    return a;
  })), lookbehind: true, alias: "string" }, comment: /#.*/, key: { pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
    return a;
  }).replace(/<<key>>/g, function() {
    return "(?:" + r + "|" + s + ")";
  })), lookbehind: true, greedy: true, alias: "atrule" }, directive: { pattern: /(^[ \t]*)%.+/m, lookbehind: true, alias: "important" }, datetime: { pattern: i(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source), lookbehind: true, alias: "number" }, boolean: { pattern: i(/false|true/.source, "i"), lookbehind: true, alias: "important" }, null: { pattern: i(/null|~/.source, "i"), lookbehind: true, alias: "important" }, string: { pattern: i(s), lookbehind: true, greedy: true }, number: { pattern: i(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"), lookbehind: true }, tag: t, important: n, punctuation: /---|[:[\]{}\-,|>?]|\.\.\./ }, e.languages.yml = e.languages.yaml;
}(Prism), function(o) {
  var n = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function e(e2) {
    return e2 = e2.replace(/<inner>/g, function() {
      return n;
    }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + e2 + ")");
  }
  var t = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, a = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return t;
  }), r = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source, l2 = (o.languages.markdown = o.languages.extend("markup", {}), o.languages.insertBefore("markdown", "prolog", { "front-matter-block": { pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/, lookbehind: true, greedy: true, inside: { punctuation: /^---|---$/, "front-matter": { pattern: /\S+(?:\s+\S+)*/, alias: ["yaml", "language-yaml"], inside: o.languages.yaml } } }, blockquote: { pattern: /^>(?:[\t ]*>)*/m, alias: "punctuation" }, table: { pattern: RegExp("^" + a + r + "(?:" + a + ")*", "m"), inside: { "table-data-rows": { pattern: RegExp("^(" + a + r + ")(?:" + a + ")*$"), lookbehind: true, inside: { "table-data": { pattern: RegExp(t), inside: o.languages.markdown }, punctuation: /\|/ } }, "table-line": { pattern: RegExp("^(" + a + ")" + r + "$"), lookbehind: true, inside: { punctuation: /\||:?-{3,}:?/ } }, "table-header-row": { pattern: RegExp("^" + a + "$"), inside: { "table-header": { pattern: RegExp(t), alias: "important", inside: o.languages.markdown }, punctuation: /\|/ } } } }, code: [{ pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/, lookbehind: true, alias: "keyword" }, { pattern: /^```[\s\S]*?^```$/m, greedy: true, inside: { "code-block": { pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m, lookbehind: true }, "code-language": { pattern: /^(```).+/, lookbehind: true }, punctuation: /```/ } }], title: [{ pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m, alias: "important", inside: { punctuation: /==+$|--+$/ } }, { pattern: /(^\s*)#.+/m, lookbehind: true, alias: "important", inside: { punctuation: /^#+|#+$/ } }], hr: { pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m, lookbehind: true, alias: "punctuation" }, list: { pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m, lookbehind: true, alias: "punctuation" }, "url-reference": { pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/, inside: { variable: { pattern: /^(!?\[)[^\]]+/, lookbehind: true }, string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/, punctuation: /^[\[\]!:]|[<>]/ }, alias: "url" }, bold: { pattern: e(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^..)[\s\S]+(?=..$)/, lookbehind: true, inside: {} }, punctuation: /\*\*|__/ } }, italic: { pattern: e(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^.)[\s\S]+(?=.$)/, lookbehind: true, inside: {} }, punctuation: /[*_]/ } }, strike: { pattern: e(/(~~?)(?:(?!~)<inner>)+\2/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^~~?)[\s\S]+(?=\1$)/, lookbehind: true, inside: {} }, punctuation: /~~?/ } }, "code-snippet": { pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/, lookbehind: true, greedy: true, alias: ["code", "keyword"] }, url: { pattern: e(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source), lookbehind: true, greedy: true, inside: { operator: /^!/, content: { pattern: /(^\[)[^\]]+(?=\])/, lookbehind: true, inside: {} }, variable: { pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/, lookbehind: true }, url: { pattern: /(^\]\()[^\s)]+/, lookbehind: true }, string: { pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/, lookbehind: true } } } }), ["url", "bold", "italic", "strike"].forEach(function(n2) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(e2) {
      n2 !== e2 && (o.languages.markdown[n2].inside.content.inside[e2] = o.languages.markdown[e2]);
    });
  }), o.hooks.add("after-tokenize", function(e2) {
    "markdown" !== e2.language && "md" !== e2.language || !function e3(n2) {
      if (n2 && "string" != typeof n2)
        for (var t2 = 0, a2 = n2.length; t2 < a2; t2++) {
          var r2, s = n2[t2];
          "code" !== s.type ? e3(s.content) : (r2 = s.content[1], s = s.content[3], r2 && s && "code-language" === r2.type && "code-block" === s.type && "string" == typeof r2.content && (r2 = r2.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp"), r2 = "language-" + (r2 = (/[a-z][\w-]*/i.exec(r2) || [""])[0].toLowerCase()), s.alias ? "string" == typeof s.alias ? s.alias = [s.alias, r2] : s.alias.push(r2) : s.alias = [r2]));
        }
    }(e2.tokens);
  }), o.hooks.add("wrap", function(e2) {
    if ("code-block" === e2.type) {
      for (var n2 = "", t2 = 0, a2 = e2.classes.length; t2 < a2; t2++) {
        var r2 = e2.classes[t2], r2 = /language-(.+)/.exec(r2);
        if (r2) {
          n2 = r2[1];
          break;
        }
      }
      var s, i = o.languages[n2];
      i ? e2.content = o.highlight(function(e3) {
        e3 = e3.replace(l2, "");
        return e3 = e3.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(e4, n3) {
          var t3;
          return "#" === (n3 = n3.toLowerCase())[0] ? (t3 = "x" === n3[1] ? parseInt(n3.slice(2), 16) : Number(n3.slice(1)), c2(t3)) : u[n3] || e4;
        });
      }(e2.content), i, n2) : n2 && "none" !== n2 && o.plugins.autoloader && (s = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(1e16 * Math.random()), e2.attributes.id = s, o.plugins.autoloader.loadLanguages(n2, function() {
        var e3 = document.getElementById(s);
        e3 && (e3.innerHTML = o.highlight(e3.textContent, o.languages[n2], n2));
      }));
    }
  }), RegExp(o.languages.markup.tag.pattern.source, "gi")), u = { amp: "&", lt: "<", gt: ">", quot: '"' }, c2 = String.fromCodePoint || String.fromCharCode;
  o.languages.md = o.languages.markdown;
}(Prism), Prism.languages.graphql = { comment: /#.*/, description: { pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i, greedy: true, alias: "string", inside: { "language-markdown": { pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/, lookbehind: true, inside: Prism.languages.markdown } } }, string: { pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/, greedy: true }, number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i, boolean: /\b(?:false|true)\b/, variable: /\$[a-z_]\w*/i, directive: { pattern: /@[a-z_]\w*/i, alias: "function" }, "attr-name": { pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i, greedy: true }, "atom-input": { pattern: /\b[A-Z]\w*Input\b/, alias: "class-name" }, scalar: /\b(?:Boolean|Float|ID|Int|String)\b/, constant: /\b[A-Z][A-Z_\d]*\b/, "class-name": { pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/, lookbehind: true }, fragment: { pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, "definition-mutation": { pattern: /(\bmutation\s+)[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, "definition-query": { pattern: /(\bquery\s+)[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, keyword: /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/, operator: /[!=|&]|\.{3}/, "property-query": /\w+(?=\s*\()/, object: /\w+(?=\s*\{)/, punctuation: /[!(){}\[\]:=,]/, property: /\w+/ }, Prism.hooks.add("after-tokenize", function(e) {
  if ("graphql" === e.language)
    for (var i = e.tokens.filter(function(e2) {
      return "string" != typeof e2 && "comment" !== e2.type && "scalar" !== e2.type;
    }), o = 0; o < i.length; ) {
      var n = i[o++];
      if ("keyword" === n.type && "mutation" === n.content) {
        var t = [];
        if (p(["definition-mutation", "punctuation"]) && "(" === c2(1).content) {
          o += 2;
          var a = d(/^\($/, /^\)$/);
          if (-1 === a)
            continue;
          for (; o < a; o++) {
            var r = c2(0);
            "variable" === r.type && (g(r, "variable-input"), t.push(r.content));
          }
          o = a + 1;
        }
        if (p(["punctuation", "property-query"]) && "{" === c2(0).content && (o++, g(c2(0), "property-mutation"), 0 < t.length)) {
          var s = d(/^\{$/, /^\}$/);
          if (-1 !== s)
            for (var l2 = o; l2 < s; l2++) {
              var u = i[l2];
              "variable" === u.type && 0 <= t.indexOf(u.content) && g(u, "variable-input");
            }
        }
      }
    }
  function c2(e2) {
    return i[o + e2];
  }
  function p(e2, n2) {
    n2 = n2 || 0;
    for (var t2 = 0; t2 < e2.length; t2++) {
      var a2 = c2(t2 + n2);
      if (!a2 || a2.type !== e2[t2])
        return;
    }
    return 1;
  }
  function d(e2, n2) {
    for (var t2 = 1, a2 = o; a2 < i.length; a2++) {
      var r2 = i[a2], s2 = r2.content;
      if ("punctuation" === r2.type && "string" == typeof s2) {
        if (e2.test(s2))
          t2++;
        else if (n2.test(s2) && 0 === --t2)
          return a2;
      }
    }
    return -1;
  }
  function g(e2, n2) {
    var t2 = e2.alias;
    t2 ? Array.isArray(t2) || (e2.alias = t2 = [t2]) : e2.alias = t2 = [], t2.push(n2);
  }
}), Prism.languages.sql = { comment: { pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/, lookbehind: true }, variable: [{ pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/, greedy: true }, /@[\w.$]+/], string: { pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/, greedy: true, lookbehind: true }, identifier: { pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/, greedy: true, lookbehind: true, inside: { punctuation: /^`|`$/ } }, function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i, keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i, boolean: /\b(?:FALSE|NULL|TRUE)\b/i, number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i, operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i, punctuation: /[;[\]()`,.]/ }, function(b) {
  var e = b.languages.javascript["template-string"], t = e.pattern.source, m = e.inside.interpolation, f = m.inside["interpolation-punctuation"], s = m.pattern.source;
  function n(e2, n2) {
    if (b.languages[e2])
      return { pattern: RegExp("((?:" + n2 + ")\\s*)" + t), lookbehind: true, greedy: true, inside: { "template-punctuation": { pattern: /^`|`$/, alias: "string" }, "embedded-code": { pattern: /[\s\S]+/, alias: e2 } } };
  }
  function h2(e2, n2, t2) {
    e2 = { code: e2, grammar: n2, language: t2 };
    return b.hooks.run("before-tokenize", e2), e2.tokens = b.tokenize(e2.code, e2.grammar), b.hooks.run("after-tokenize", e2), e2.tokens;
  }
  function l2(a2, e2, r) {
    var n2 = b.tokenize(a2, { interpolation: { pattern: RegExp(s), lookbehind: true } }), p = 0, d = {}, n2 = h2(n2.map(function(e3) {
      if ("string" == typeof e3)
        return e3;
      for (var n3, t2, e3 = e3.content; -1 !== a2.indexOf((t2 = p++, n3 = "___" + r.toUpperCase() + "_" + t2 + "___")); )
        ;
      return d[n3] = e3, n3;
    }).join(""), e2, r), g = Object.keys(d);
    return p = 0, function e3(n3) {
      for (var t2 = 0; t2 < n3.length; t2++) {
        if (p >= g.length)
          return;
        var a3, r2, s2, i, o, l22, u2, c2 = n3[t2];
        "string" == typeof c2 || "string" == typeof c2.content ? (a3 = g[p], -1 !== (u2 = (l22 = "string" == typeof c2 ? c2 : c2.content).indexOf(a3)) && (++p, r2 = l22.substring(0, u2), o = d[a3], s2 = void 0, (i = {})["interpolation-punctuation"] = f, 3 === (i = b.tokenize(o, i)).length && ((s2 = [1, 1]).push.apply(s2, h2(i[1], b.languages.javascript, "javascript")), i.splice.apply(i, s2)), s2 = new b.Token("interpolation", i, m.alias, o), i = l22.substring(u2 + a3.length), o = [], r2 && o.push(r2), o.push(s2), i && (e3(l22 = [i]), o.push.apply(o, l22)), "string" == typeof c2 ? (n3.splice.apply(n3, [t2, 1].concat(o)), t2 += o.length - 1) : c2.content = o)) : (u2 = c2.content, Array.isArray(u2) ? e3(u2) : e3([u2]));
      }
    }(n2), new b.Token(r, n2, "language-" + r, a2);
  }
  b.languages.javascript["template-string"] = [n("css", /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source), n("html", /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source), n("svg", /\bsvg/.source), n("markdown", /\b(?:markdown|md)/.source), n("graphql", /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source), n("sql", /\bsql/.source), e].filter(Boolean);
  var a = { javascript: true, js: true, typescript: true, ts: true, jsx: true, tsx: true };
  function u(e2) {
    return "string" == typeof e2 ? e2 : Array.isArray(e2) ? e2.map(u).join("") : u(e2.content);
  }
  b.hooks.add("after-tokenize", function(e2) {
    e2.language in a && !function e3(n2) {
      for (var t2 = 0, a2 = n2.length; t2 < a2; t2++) {
        var r, s2, i, o = n2[t2];
        "string" != typeof o && (r = o.content, Array.isArray(r) ? "template-string" === o.type ? (o = r[1], 3 === r.length && "string" != typeof o && "embedded-code" === o.type && (s2 = u(o), o = o.alias, o = Array.isArray(o) ? o[0] : o, i = b.languages[o]) && (r[1] = l2(s2, i, o))) : e3(r) : "string" != typeof r && e3([r]));
      }
    }(e2.tokens);
  });
}(Prism), function(e) {
  e.languages.typescript = e.languages.extend("javascript", { "class-name": { pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/, lookbehind: true, greedy: true, inside: null }, builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/ }), e.languages.typescript.keyword.push(/\b(?:abstract|declare|is|keyof|readonly|require)\b/, /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/, /\btype\b(?=\s*(?:[\{*]|$))/), delete e.languages.typescript.parameter, delete e.languages.typescript["literal-property"];
  var n = e.languages.extend("typescript", {});
  delete n["class-name"], e.languages.typescript["class-name"].inside = n, e.languages.insertBefore("typescript", "function", { decorator: { pattern: /@[$\w\xA0-\uFFFF]+/, inside: { at: { pattern: /^@/, alias: "operator" }, function: /^[\s\S]+/ } }, "generic-function": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/, greedy: true, inside: { function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/, generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: n } } } }), e.languages.ts = e.languages.typescript;
}(Prism), function(e) {
  var n = e.languages.javascript, t = /\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})+\}/.source, a = "(@(?:arg|argument|param|property)\\s+(?:" + t + "\\s+)?)";
  e.languages.jsdoc = e.languages.extend("javadoclike", { parameter: { pattern: RegExp(a + /(?:(?!\s)[$\w\xA0-\uFFFF.])+(?=\s|$)/.source), lookbehind: true, inside: { punctuation: /\./ } } }), e.languages.insertBefore("jsdoc", "keyword", { "optional-parameter": { pattern: RegExp(a + /\[(?:(?!\s)[$\w\xA0-\uFFFF.])+(?:=[^[\]]+)?\](?=\s|$)/.source), lookbehind: true, inside: { parameter: { pattern: /(^\[)[$\w\xA0-\uFFFF\.]+/, lookbehind: true, inside: { punctuation: /\./ } }, code: { pattern: /(=)[\s\S]*(?=\]$)/, lookbehind: true, inside: n, alias: "language-javascript" }, punctuation: /[=[\]]/ } }, "class-name": [{ pattern: RegExp(/(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\s+(?:<TYPE>\s+)?)[A-Z]\w*(?:\.[A-Z]\w*)*/.source.replace(/<TYPE>/g, function() {
    return t;
  })), lookbehind: true, inside: { punctuation: /\./ } }, { pattern: RegExp("(@[a-z]+\\s+)" + t), lookbehind: true, inside: { string: n.string, number: n.number, boolean: n.boolean, keyword: e.languages.typescript.keyword, operator: /=>|\.\.\.|[&|?:*]/, punctuation: /[.,;=<>{}()[\]]/ } }], example: { pattern: /(@example\s+(?!\s))(?:[^@\s]|\s+(?!\s))+?(?=\s*(?:\*\s*)?(?:@\w|\*\/))/, lookbehind: true, inside: { code: { pattern: /^([\t ]*(?:\*\s*)?)\S.*$/m, lookbehind: true, inside: n, alias: "language-javascript" } } } }), e.languages.javadoclike.addSupport("javascript", e.languages.jsdoc);
}(Prism), function(e) {
  e.languages.flow = e.languages.extend("javascript", {}), e.languages.insertBefore("flow", "keyword", { type: [{ pattern: /\b(?:[Bb]oolean|Function|[Nn]umber|[Ss]tring|[Ss]ymbol|any|mixed|null|void)\b/, alias: "class-name" }] }), e.languages.flow["function-variable"].pattern = /(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=\s*(?:function\b|(?:\([^()]*\)(?:\s*:\s*\w+)?|(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/i, delete e.languages.flow.parameter, e.languages.insertBefore("flow", "operator", { "flow-punctuation": { pattern: /\{\||\|\}/, alias: "punctuation" } }), Array.isArray(e.languages.flow.keyword) || (e.languages.flow.keyword = [e.languages.flow.keyword]), e.languages.flow.keyword.unshift({ pattern: /(^|[^$]\b)(?:Class|declare|opaque|type)\b(?!\$)/, lookbehind: true }, { pattern: /(^|[^$]\B)\$(?:Diff|Enum|Exact|Keys|ObjMap|PropertyType|Record|Shape|Subtype|Supertype|await)\b(?!\$)/, lookbehind: true });
}(Prism), Prism.languages.n4js = Prism.languages.extend("javascript", { keyword: /\b(?:Array|any|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|module|new|null|number|package|private|protected|public|return|set|static|string|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/ }), Prism.languages.insertBefore("n4js", "constant", { annotation: { pattern: /@+\w+/, alias: "operator" } }), Prism.languages.n4jsd = Prism.languages.n4js, function(e) {
  function n(e2, n2) {
    return RegExp(e2.replace(/<ID>/g, function() {
      return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
    }), n2);
  }
  e.languages.insertBefore("javascript", "function-variable", { "method-variable": { pattern: RegExp("(\\.\\s*)" + e.languages.javascript["function-variable"].pattern.source), lookbehind: true, alias: ["function-variable", "method", "function", "property-access"] } }), e.languages.insertBefore("javascript", "function", { method: { pattern: RegExp("(\\.\\s*)" + e.languages.javascript.function.source), lookbehind: true, alias: ["function", "property-access"] } }), e.languages.insertBefore("javascript", "constant", { "known-class-name": [{ pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/, alias: "class-name" }, { pattern: /\b(?:[A-Z]\w*)Error\b/, alias: "class-name" }] }), e.languages.insertBefore("javascript", "keyword", { imports: { pattern: n(/(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source), lookbehind: true, inside: e.languages.javascript }, exports: { pattern: n(/(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source), lookbehind: true, inside: e.languages.javascript } }), e.languages.javascript.keyword.unshift({ pattern: /\b(?:as|default|export|from|import)\b/, alias: "module" }, { pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/, alias: "control-flow" }, { pattern: /\bnull\b/, alias: ["null", "nil"] }, { pattern: /\bundefined\b/, alias: "nil" }), e.languages.insertBefore("javascript", "operator", { spread: { pattern: /\.{3}/, alias: "operator" }, arrow: { pattern: /=>/, alias: "operator" } }), e.languages.insertBefore("javascript", "punctuation", { "property-access": { pattern: n(/(\.\s*)#?<ID>/.source), lookbehind: true }, "maybe-class-name": { pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/, lookbehind: true }, dom: { pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/, alias: "variable" }, console: { pattern: /\bconsole(?=\s*\.)/, alias: "class-name" } });
  for (var t = ["function", "function-variable", "method", "method-variable", "property-access"], a = 0; a < t.length; a++) {
    var r = t[a], s = e.languages.javascript[r], r = (s = "RegExp" === e.util.type(s) ? e.languages.javascript[r] = { pattern: s } : s).inside || {};
    (s.inside = r)["maybe-class-name"] = /^[A-Z][\s\S]*/;
  }
}(Prism), function(s) {
  var e = s.util.clone(s.languages.javascript), t = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source, a = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source, r = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
  function n(e2, n2) {
    return e2 = e2.replace(/<S>/g, function() {
      return t;
    }).replace(/<BRACES>/g, function() {
      return a;
    }).replace(/<SPREAD>/g, function() {
      return r;
    }), RegExp(e2, n2);
  }
  r = n(r).source, s.languages.jsx = s.languages.extend("markup", e), s.languages.jsx.tag.pattern = n(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source), s.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/, s.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/, s.languages.jsx.tag.inside.tag.inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/, s.languages.jsx.tag.inside.comment = e.comment, s.languages.insertBefore("inside", "attr-name", { spread: { pattern: n(/<SPREAD>/.source), inside: s.languages.jsx } }, s.languages.jsx.tag), s.languages.insertBefore("inside", "special-attr", { script: { pattern: n(/=<BRACES>/.source), alias: "language-javascript", inside: { "script-punctuation": { pattern: /^=(?=\{)/, alias: "punctuation" }, rest: s.languages.jsx } } }, s.languages.jsx.tag);
  function i(e2) {
    for (var n2 = [], t2 = 0; t2 < e2.length; t2++) {
      var a2 = e2[t2], r2 = false;
      "string" != typeof a2 && ("tag" === a2.type && a2.content[0] && "tag" === a2.content[0].type ? "</" === a2.content[0].content[0].content ? 0 < n2.length && n2[n2.length - 1].tagName === o(a2.content[0].content[1]) && n2.pop() : "/>" !== a2.content[a2.content.length - 1].content && n2.push({ tagName: o(a2.content[0].content[1]), openedBraces: 0 }) : 0 < n2.length && "punctuation" === a2.type && "{" === a2.content ? n2[n2.length - 1].openedBraces++ : 0 < n2.length && 0 < n2[n2.length - 1].openedBraces && "punctuation" === a2.type && "}" === a2.content ? n2[n2.length - 1].openedBraces-- : r2 = true), (r2 || "string" == typeof a2) && 0 < n2.length && 0 === n2[n2.length - 1].openedBraces && (r2 = o(a2), t2 < e2.length - 1 && ("string" == typeof e2[t2 + 1] || "plain-text" === e2[t2 + 1].type) && (r2 += o(e2[t2 + 1]), e2.splice(t2 + 1, 1)), 0 < t2 && ("string" == typeof e2[t2 - 1] || "plain-text" === e2[t2 - 1].type) && (r2 = o(e2[t2 - 1]) + r2, e2.splice(t2 - 1, 1), t2--), e2[t2] = new s.Token("plain-text", r2, null, r2)), a2.content && "string" != typeof a2.content && i(a2.content);
    }
  }
  var o = function(e2) {
    return e2 ? "string" == typeof e2 ? e2 : "string" == typeof e2.content ? e2.content : e2.content.map(o).join("") : "";
  };
  s.hooks.add("after-tokenize", function(e2) {
    "jsx" !== e2.language && "tsx" !== e2.language || i(e2.tokens);
  });
}(Prism), function(e) {
  var n = e.util.clone(e.languages.typescript), n = (e.languages.tsx = e.languages.extend("jsx", n), delete e.languages.tsx.parameter, delete e.languages.tsx["literal-property"], e.languages.tsx.tag);
  n.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + n.pattern.source + ")", n.pattern.flags), n.lookbehind = true;
}(Prism), Prism.languages.swift = { comment: { pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/, lookbehind: true, greedy: true }, "string-literal": [{ pattern: RegExp(/(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source), lookbehind: true, greedy: true, inside: { interpolation: { pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: true, inside: null }, "interpolation-punctuation": { pattern: /^\)|\\\($/, alias: "punctuation" }, punctuation: /\\(?=[\r\n])/, string: /[\s\S]+/ } }, { pattern: RegExp(/(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"), lookbehind: true, greedy: true, inside: { interpolation: { pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: true, inside: null }, "interpolation-punctuation": { pattern: /^\)|\\#+\($/, alias: "punctuation" }, string: /[\s\S]+/ } }], directive: { pattern: RegExp(/#/.source + "(?:" + /(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+|" + /(?:else|endif)\b/.source + ")"), alias: "property", inside: { "directive-name": /^#\w+/, boolean: /\b(?:false|true)\b/, number: /\b\d+(?:\.\d+)*\b/, operator: /!|&&|\|\||[<>]=?/, punctuation: /[(),]/ } }, literal: { pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/, alias: "constant" }, "other-directive": { pattern: /#\w+\b/, alias: "property" }, attribute: { pattern: /@\w+/, alias: "atrule" }, "function-definition": { pattern: /(\bfunc\s+)\w+/, lookbehind: true, alias: "function" }, label: { pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/, lookbehind: true, alias: "important" }, keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/, boolean: /\b(?:false|true)\b/, nil: { pattern: /\bnil\b/, alias: "constant" }, "short-argument": /\$\d+\b/, omit: { pattern: /\b_\b/, alias: "keyword" }, number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i, "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/, function: /\b[a-z_]\w*(?=\s*\()/i, constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/, operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/, punctuation: /[{}[\]();,.:\\]/ }, Prism.languages.swift["string-literal"].forEach(function(e) {
  e.inside.interpolation.inside = Prism.languages.swift;
}), function(e) {
  e.languages.kotlin = e.languages.extend("clike", { keyword: { pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/, lookbehind: true }, function: [{ pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/, greedy: true }, { pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/, lookbehind: true, greedy: true }], number: /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/, operator: /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/ }), delete e.languages.kotlin["class-name"];
  var n = { "interpolation-punctuation": { pattern: /^\$\{?|\}$/, alias: "punctuation" }, expression: { pattern: /[\s\S]+/, inside: e.languages.kotlin } };
  e.languages.insertBefore("kotlin", "string", { "string-literal": [{ pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/, alias: "multiline", inside: { interpolation: { pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i, inside: n }, string: /[\s\S]+/ } }, { pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/, alias: "singleline", inside: { interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i, lookbehind: true, inside: n }, string: /[\s\S]+/ } }], char: { pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/, greedy: true } }), delete e.languages.kotlin.string, e.languages.insertBefore("kotlin", "keyword", { annotation: { pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/, alias: "builtin" } }), e.languages.insertBefore("kotlin", "function", { label: { pattern: /\b\w+@|@\w+\b/, alias: "symbol" } }), e.languages.kt = e.languages.kotlin, e.languages.kts = e.languages.kotlin;
}(Prism), Prism.languages.c = Prism.languages.extend("clike", { comment: { pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: true }, string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: true }, "class-name": { pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/, lookbehind: true }, keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/, function: /\b[a-z_]\w*(?=\s*\()/i, number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i, operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/ }), Prism.languages.insertBefore("c", "string", { char: { pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/, greedy: true } }), Prism.languages.insertBefore("c", "string", { macro: { pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im, lookbehind: true, greedy: true, alias: "property", inside: { string: [{ pattern: /^(#\s*include\s*)<[^>]+>/, lookbehind: true }, Prism.languages.c.string], char: Prism.languages.c.char, comment: Prism.languages.c.comment, "macro-name": [{ pattern: /(^#\s*define\s+)\w+\b(?!\()/i, lookbehind: true }, { pattern: /(^#\s*define\s+)\w+\b(?=\()/i, lookbehind: true, alias: "function" }], directive: { pattern: /^(#\s*)[a-z]+/, lookbehind: true, alias: "keyword" }, "directive-hash": /^#/, punctuation: /##|\\(?=[\r\n])/, expression: { pattern: /\S[\s\S]*/, inside: Prism.languages.c } } } }), Prism.languages.insertBefore("c", "function", { constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/ }), delete Prism.languages.c.boolean, Prism.languages.objectivec = Prism.languages.extend("c", { string: { pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: true }, keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/, operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/ }), delete Prism.languages.objectivec["class-name"], Prism.languages.objc = Prism.languages.objectivec, Prism.languages.reason = Prism.languages.extend("clike", { string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/, greedy: true }, "class-name": /\b[A-Z]\w*/, keyword: /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/, operator: /\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/ }), Prism.languages.insertBefore("reason", "class-name", { char: { pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/, greedy: true }, constructor: /\b[A-Z]\w*\b(?!\s*\.)/, label: { pattern: /\b[a-z]\w*(?=::)/, alias: "symbol" } }), delete Prism.languages.reason.function, function(e) {
  for (var n = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, t = 0; t < 2; t++)
    n = n.replace(/<self>/g, function() {
      return n;
    });
  n = n.replace(/<self>/g, function() {
    return /[^\s\S]/.source;
  }), e.languages.rust = { comment: [{ pattern: RegExp(/(^|[^\\])/.source + n), lookbehind: true, greedy: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/, greedy: true }, char: { pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/, greedy: true }, attribute: { pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/, greedy: true, alias: "attr-name", inside: { string: null } }, "closure-params": { pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/, lookbehind: true, greedy: true, inside: { "closure-punctuation": { pattern: /^\||\|$/, alias: "punctuation" }, rest: null } }, "lifetime-annotation": { pattern: /'\w+/, alias: "symbol" }, "fragment-specifier": { pattern: /(\$\w+:)[a-z]+/, lookbehind: true, alias: "punctuation" }, variable: /\$\w+/, "function-definition": { pattern: /(\bfn\s+)\w+/, lookbehind: true, alias: "function" }, "type-definition": { pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/, lookbehind: true, alias: "class-name" }, "module-declaration": [{ pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/, lookbehind: true, alias: "namespace" }, { pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/, lookbehind: true, alias: "namespace", inside: { punctuation: /::/ } }], keyword: [/\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/, /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/], function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/, macro: { pattern: /\b\w+!/, alias: "property" }, constant: /\b[A-Z_][A-Z_\d]+\b/, "class-name": /\b[A-Z]\w*\b/, namespace: { pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/, inside: { punctuation: /::/ } }, number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/, boolean: /\b(?:false|true)\b/, punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/, operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/ }, e.languages.rust["closure-params"].inside.rest = e.languages.rust, e.languages.rust.attribute.inside.string = e.languages.rust.string;
}(Prism), Prism.languages.go = Prism.languages.extend("clike", { string: { pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/, lookbehind: true, greedy: true }, keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/, boolean: /\b(?:_|false|iota|nil|true)\b/, number: [/\b0(?:b[01_]+|o[0-7_]+)i?\b/i, /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i, /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i], operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./, builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/ }), Prism.languages.insertBefore("go", "string", { char: { pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/, greedy: true } }), delete Prism.languages.go["class-name"], function(e) {
  var n = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, t = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return n.source;
  });
  e.languages.cpp = e.languages.extend("c", { "class-name": [{ pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
    return n.source;
  })), lookbehind: true }, /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/, /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i, /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/], keyword: n, number: { pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i, greedy: true }, operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/, boolean: /\b(?:false|true)\b/ }), e.languages.insertBefore("cpp", "string", { module: { pattern: RegExp(/(\b(?:import|module)\s+)/.source + "(?:" + /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
    return t;
  }) + ")"), lookbehind: true, greedy: true, inside: { string: /^[<"][\s\S]+/, operator: /:/, punctuation: /\./ } }, "raw-string": { pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/, alias: "string", greedy: true } }), e.languages.insertBefore("cpp", "keyword", { "generic-function": { pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i, inside: { function: /^\w+/, generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: e.languages.cpp } } } }), e.languages.insertBefore("cpp", "operator", { "double-colon": { pattern: /::/, alias: "punctuation" } }), e.languages.insertBefore("cpp", "class-name", { "base-clause": { pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/, lookbehind: true, greedy: true, inside: e.languages.extend("cpp", {}) } }), e.languages.insertBefore("inside", "double-colon", { "class-name": /\b[a-z_]\w*\b(?!\s*::)/i }, e.languages.cpp["base-clause"]);
}(Prism), Prism.languages.python = { comment: { pattern: /(^|[^\\])#.*/, lookbehind: true, greedy: true }, "string-interpolation": { pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i, greedy: true, inside: { interpolation: { pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/, lookbehind: true, inside: { "format-spec": { pattern: /(:)[^:(){}]+(?=\}$)/, lookbehind: true }, "conversion-option": { pattern: /![sra](?=[:}]$)/, alias: "punctuation" }, rest: null } }, string: /[\s\S]+/ } }, "triple-quoted-string": { pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i, greedy: true, alias: "string" }, string: { pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i, greedy: true }, function: { pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g, lookbehind: true }, "class-name": { pattern: /(\bclass\s+)\w+/i, lookbehind: true }, decorator: { pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m, lookbehind: true, alias: ["annotation", "punctuation"], inside: { punctuation: /\./ } }, keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/, builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/, boolean: /\b(?:False|None|True)\b/, number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i, operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/, punctuation: /[{}[\];(),.:]/ }, Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python, Prism.languages.py = Prism.languages.python, Prism.languages.json = { property: { pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/, lookbehind: true, greedy: true }, string: { pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/, lookbehind: true, greedy: true }, comment: { pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: true }, number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i, punctuation: /[{}[\],]/, operator: /:/, boolean: /\b(?:false|true)\b/, null: { pattern: /\bnull\b/, alias: "keyword" } }, Prism.languages.webmanifest = Prism.languages.json;
var themes_exports = {};
__export(themes_exports, {
  dracula: () => dracula_default,
  duotoneDark: () => duotoneDark_default,
  duotoneLight: () => duotoneLight_default,
  github: () => github_default,
  gruvboxMaterialDark: () => gruvboxMaterialDark_default,
  gruvboxMaterialLight: () => gruvboxMaterialLight_default,
  jettwaveDark: () => jettwaveDark_default,
  jettwaveLight: () => jettwaveLight_default,
  nightOwl: () => nightOwl_default,
  nightOwlLight: () => nightOwlLight_default,
  oceanicNext: () => oceanicNext_default,
  okaidia: () => okaidia_default,
  oneDark: () => oneDark_default,
  oneLight: () => oneLight_default,
  palenight: () => palenight_default,
  shadesOfPurple: () => shadesOfPurple_default,
  synthwave84: () => synthwave84_default,
  ultramin: () => ultramin_default,
  vsDark: () => vsDark_default,
  vsLight: () => vsLight_default
});
var theme = {
  plain: {
    color: "#F8F8F2",
    backgroundColor: "#282A36"
  },
  styles: [
    {
      types: ["prolog", "constant", "builtin"],
      style: {
        color: "rgb(189, 147, 249)"
      }
    },
    {
      types: ["inserted", "function"],
      style: {
        color: "rgb(80, 250, 123)"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgb(255, 85, 85)"
      }
    },
    {
      types: ["changed"],
      style: {
        color: "rgb(255, 184, 108)"
      }
    },
    {
      types: ["punctuation", "symbol"],
      style: {
        color: "rgb(248, 248, 242)"
      }
    },
    {
      types: ["string", "char", "tag", "selector"],
      style: {
        color: "rgb(255, 121, 198)"
      }
    },
    {
      types: ["keyword", "variable"],
      style: {
        color: "rgb(189, 147, 249)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(98, 114, 164)"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "rgb(241, 250, 140)"
      }
    }
  ]
};
var dracula_default = theme;
var theme2 = {
  plain: {
    backgroundColor: "#2a2734",
    color: "#9a86fd"
  },
  styles: [
    {
      types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
      style: {
        color: "#6c6783"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    },
    {
      types: ["tag", "operator", "number"],
      style: {
        color: "#e09142"
      }
    },
    {
      types: ["property", "function"],
      style: {
        color: "#9a86fd"
      }
    },
    {
      types: ["tag-id", "selector", "atrule-id"],
      style: {
        color: "#eeebff"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "#c4b9fe"
      }
    },
    {
      types: [
        "boolean",
        "string",
        "entity",
        "url",
        "attr-value",
        "keyword",
        "control",
        "directive",
        "unit",
        "statement",
        "regex",
        "atrule",
        "placeholder",
        "variable"
      ],
      style: {
        color: "#ffcc99"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "#c4b9fe"
      }
    }
  ]
};
var duotoneDark_default = theme2;
var theme3 = {
  plain: {
    backgroundColor: "#faf8f5",
    color: "#728fcb"
  },
  styles: [
    {
      types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
      style: {
        color: "#b6ad9a"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    },
    {
      types: ["tag", "operator", "number"],
      style: {
        color: "#063289"
      }
    },
    {
      types: ["property", "function"],
      style: {
        color: "#b29762"
      }
    },
    {
      types: ["tag-id", "selector", "atrule-id"],
      style: {
        color: "#2d2006"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "#896724"
      }
    },
    {
      types: [
        "boolean",
        "string",
        "entity",
        "url",
        "attr-value",
        "keyword",
        "control",
        "directive",
        "unit",
        "statement",
        "regex",
        "atrule"
      ],
      style: {
        color: "#728fcb"
      }
    },
    {
      types: ["placeholder", "variable"],
      style: {
        color: "#93abdc"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "#896724"
      }
    }
  ]
};
var duotoneLight_default = theme3;
var theme4 = {
  plain: {
    color: "#393A34",
    backgroundColor: "#f6f8fa"
  },
  styles: [
    {
      types: ["comment", "prolog", "doctype", "cdata"],
      style: {
        color: "#999988",
        fontStyle: "italic"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    },
    {
      types: ["string", "attr-value"],
      style: {
        color: "#e3116c"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "#393A34"
      }
    },
    {
      types: [
        "entity",
        "url",
        "symbol",
        "number",
        "boolean",
        "variable",
        "constant",
        "property",
        "regex",
        "inserted"
      ],
      style: {
        color: "#36acaa"
      }
    },
    {
      types: ["atrule", "keyword", "attr-name", "selector"],
      style: {
        color: "#00a4db"
      }
    },
    {
      types: ["function", "deleted", "tag"],
      style: {
        color: "#d73a49"
      }
    },
    {
      types: ["function-variable"],
      style: {
        color: "#6f42c1"
      }
    },
    {
      types: ["tag", "selector", "keyword"],
      style: {
        color: "#00009f"
      }
    }
  ]
};
var github_default = theme4;
var theme5 = {
  plain: {
    color: "#d6deeb",
    backgroundColor: "#011627"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(162, 191, 252)",
        fontStyle: "italic"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgba(239, 83, 80, 0.56)",
        fontStyle: "italic"
      }
    },
    {
      types: ["inserted", "attr-name"],
      style: {
        color: "rgb(173, 219, 103)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(99, 119, 119)",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "url"],
      style: {
        color: "rgb(173, 219, 103)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(214, 222, 235)"
      }
    },
    {
      types: ["number"],
      style: {
        color: "rgb(247, 140, 108)"
      }
    },
    {
      types: ["builtin", "char", "constant", "function"],
      style: {
        color: "rgb(130, 170, 255)"
      }
    },
    {
      // This was manually added after the auto-generation
      // so that punctuations are not italicised
      types: ["punctuation"],
      style: {
        color: "rgb(199, 146, 234)"
      }
    },
    {
      types: ["selector", "doctype"],
      style: {
        color: "rgb(199, 146, 234)",
        fontStyle: "italic"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(255, 203, 139)"
      }
    },
    {
      types: ["tag", "operator", "keyword"],
      style: {
        color: "rgb(127, 219, 202)"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "rgb(255, 88, 116)"
      }
    },
    {
      types: ["property"],
      style: {
        color: "rgb(128, 203, 196)"
      }
    },
    {
      types: ["namespace"],
      style: {
        color: "rgb(178, 204, 214)"
      }
    }
  ]
};
var nightOwl_default = theme5;
var theme6 = {
  plain: {
    color: "#403f53",
    backgroundColor: "#FBFBFB"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(162, 191, 252)",
        fontStyle: "italic"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgba(239, 83, 80, 0.56)",
        fontStyle: "italic"
      }
    },
    {
      types: ["inserted", "attr-name"],
      style: {
        color: "rgb(72, 118, 214)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(152, 159, 177)",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "builtin", "char", "constant", "url"],
      style: {
        color: "rgb(72, 118, 214)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(201, 103, 101)"
      }
    },
    {
      types: ["number"],
      style: {
        color: "rgb(170, 9, 130)"
      }
    },
    {
      // This was manually added after the auto-generation
      // so that punctuations are not italicised
      types: ["punctuation"],
      style: {
        color: "rgb(153, 76, 195)"
      }
    },
    {
      types: ["function", "selector", "doctype"],
      style: {
        color: "rgb(153, 76, 195)",
        fontStyle: "italic"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(17, 17, 17)"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "rgb(153, 76, 195)"
      }
    },
    {
      types: ["operator", "property", "keyword", "namespace"],
      style: {
        color: "rgb(12, 150, 155)"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "rgb(188, 84, 84)"
      }
    }
  ]
};
var nightOwlLight_default = theme6;
var colors = {
  char: "#D8DEE9",
  comment: "#999999",
  keyword: "#c5a5c5",
  primitive: "#5a9bcf",
  string: "#8dc891",
  variable: "#d7deea",
  boolean: "#ff8b50",
  punctuation: "#5FB3B3",
  tag: "#fc929e",
  function: "#79b6f2",
  className: "#FAC863",
  method: "#6699CC",
  operator: "#fc929e"
};
var theme7 = {
  plain: {
    backgroundColor: "#282c34",
    color: "#ffffff"
  },
  styles: [
    {
      types: ["attr-name"],
      style: {
        color: colors.keyword
      }
    },
    {
      types: ["attr-value"],
      style: {
        color: colors.string
      }
    },
    {
      types: [
        "comment",
        "block-comment",
        "prolog",
        "doctype",
        "cdata",
        "shebang"
      ],
      style: {
        color: colors.comment
      }
    },
    {
      types: [
        "property",
        "number",
        "function-name",
        "constant",
        "symbol",
        "deleted"
      ],
      style: {
        color: colors.primitive
      }
    },
    {
      types: ["boolean"],
      style: {
        color: colors.boolean
      }
    },
    {
      types: ["tag"],
      style: {
        color: colors.tag
      }
    },
    {
      types: ["string"],
      style: {
        color: colors.string
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: colors.string
      }
    },
    {
      types: ["selector", "char", "builtin", "inserted"],
      style: {
        color: colors.char
      }
    },
    {
      types: ["function"],
      style: {
        color: colors.function
      }
    },
    {
      types: ["operator", "entity", "url", "variable"],
      style: {
        color: colors.variable
      }
    },
    {
      types: ["keyword"],
      style: {
        color: colors.keyword
      }
    },
    {
      types: ["atrule", "class-name"],
      style: {
        color: colors.className
      }
    },
    {
      types: ["important"],
      style: {
        fontWeight: "400"
      }
    },
    {
      types: ["bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    }
  ]
};
var oceanicNext_default = theme7;
var theme8 = {
  plain: {
    color: "#f8f8f2",
    backgroundColor: "#272822"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(162, 191, 252)",
        fontStyle: "italic"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "#f92672",
        fontStyle: "italic"
      }
    },
    {
      types: ["inserted"],
      style: {
        color: "rgb(173, 219, 103)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "#8292a2",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "url"],
      style: {
        color: "#a6e22e"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "#f8f8f2"
      }
    },
    {
      types: ["number"],
      style: {
        color: "#ae81ff"
      }
    },
    {
      types: ["builtin", "char", "constant", "function", "class-name"],
      style: {
        color: "#e6db74"
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: "#f8f8f2"
      }
    },
    {
      types: ["selector", "doctype"],
      style: {
        color: "#a6e22e",
        fontStyle: "italic"
      }
    },
    {
      types: ["tag", "operator", "keyword"],
      style: {
        color: "#66d9ef"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "#ae81ff"
      }
    },
    {
      types: ["namespace"],
      style: {
        color: "rgb(178, 204, 214)",
        opacity: 0.7
      }
    },
    {
      types: ["tag", "property"],
      style: {
        color: "#f92672"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "#a6e22e !important"
      }
    },
    {
      types: ["doctype"],
      style: {
        color: "#8292a2"
      }
    },
    {
      types: ["rule"],
      style: {
        color: "#e6db74"
      }
    }
  ]
};
var okaidia_default = theme8;
var theme9 = {
  plain: {
    color: "#bfc7d5",
    backgroundColor: "#292d3e"
  },
  styles: [
    {
      types: ["comment"],
      style: {
        color: "rgb(105, 112, 152)",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "inserted"],
      style: {
        color: "rgb(195, 232, 141)"
      }
    },
    {
      types: ["number"],
      style: {
        color: "rgb(247, 140, 108)"
      }
    },
    {
      types: ["builtin", "char", "constant", "function"],
      style: {
        color: "rgb(130, 170, 255)"
      }
    },
    {
      types: ["punctuation", "selector"],
      style: {
        color: "rgb(199, 146, 234)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(191, 199, 213)"
      }
    },
    {
      types: ["class-name", "attr-name"],
      style: {
        color: "rgb(255, 203, 107)"
      }
    },
    {
      types: ["tag", "deleted"],
      style: {
        color: "rgb(255, 85, 114)"
      }
    },
    {
      types: ["operator"],
      style: {
        color: "rgb(137, 221, 255)"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "rgb(255, 88, 116)"
      }
    },
    {
      types: ["keyword"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["doctype"],
      style: {
        color: "rgb(199, 146, 234)",
        fontStyle: "italic"
      }
    },
    {
      types: ["namespace"],
      style: {
        color: "rgb(178, 204, 214)"
      }
    },
    {
      types: ["url"],
      style: {
        color: "rgb(221, 221, 221)"
      }
    }
  ]
};
var palenight_default = theme9;
var theme10 = {
  plain: {
    color: "#9EFEFF",
    backgroundColor: "#2D2A55"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(255, 238, 128)"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgba(239, 83, 80, 0.56)"
      }
    },
    {
      types: ["inserted"],
      style: {
        color: "rgb(173, 219, 103)"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(179, 98, 255)",
        fontStyle: "italic"
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: "rgb(255, 255, 255)"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "rgb(255, 98, 140)"
      }
    },
    {
      types: ["string", "url"],
      style: {
        color: "rgb(165, 255, 144)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(255, 238, 128)"
      }
    },
    {
      types: ["number", "boolean"],
      style: {
        color: "rgb(255, 98, 140)"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "rgb(255, 180, 84)"
      }
    },
    {
      types: [
        "keyword",
        "operator",
        "property",
        "namespace",
        "tag",
        "selector",
        "doctype"
      ],
      style: {
        color: "rgb(255, 157, 0)"
      }
    },
    {
      types: ["builtin", "char", "constant", "function", "class-name"],
      style: {
        color: "rgb(250, 208, 0)"
      }
    }
  ]
};
var shadesOfPurple_default = theme10;
var theme11 = {
  plain: {
    backgroundColor: "linear-gradient(to bottom, #2a2139 75%, #34294f)",
    backgroundImage: "#34294f",
    color: "#f92aad",
    textShadow: "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3"
  },
  styles: [
    {
      types: ["comment", "block-comment", "prolog", "doctype", "cdata"],
      style: {
        color: "#495495",
        fontStyle: "italic"
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: "#ccc"
      }
    },
    {
      types: [
        "tag",
        "attr-name",
        "namespace",
        "number",
        "unit",
        "hexcode",
        "deleted"
      ],
      style: {
        color: "#e2777a"
      }
    },
    {
      types: ["property", "selector"],
      style: {
        color: "#72f1b8",
        textShadow: "0 0 2px #100c0f, 0 0 10px #257c5575, 0 0 35px #21272475"
      }
    },
    {
      types: ["function-name"],
      style: {
        color: "#6196cc"
      }
    },
    {
      types: ["boolean", "selector-id", "function"],
      style: {
        color: "#fdfdfd",
        textShadow: "0 0 2px #001716, 0 0 3px #03edf975, 0 0 5px #03edf975, 0 0 8px #03edf975"
      }
    },
    {
      types: ["class-name", "maybe-class-name", "builtin"],
      style: {
        color: "#fff5f6",
        textShadow: "0 0 2px #000, 0 0 10px #fc1f2c75, 0 0 5px #fc1f2c75, 0 0 25px #fc1f2c75"
      }
    },
    {
      types: ["constant", "symbol"],
      style: {
        color: "#f92aad",
        textShadow: "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3"
      }
    },
    {
      types: ["important", "atrule", "keyword", "selector-class"],
      style: {
        color: "#f4eee4",
        textShadow: "0 0 2px #393a33, 0 0 8px #f39f0575, 0 0 2px #f39f0575"
      }
    },
    {
      types: ["string", "char", "attr-value", "regex", "variable"],
      style: {
        color: "#f87c32"
      }
    },
    {
      types: ["parameter"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["entity", "url"],
      style: {
        color: "#67cdcc"
      }
    },
    {
      types: ["operator"],
      style: {
        color: "ffffffee"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["entity"],
      style: {
        cursor: "help"
      }
    },
    {
      types: ["inserted"],
      style: {
        color: "green"
      }
    }
  ]
};
var synthwave84_default = theme11;
var theme12 = {
  plain: {
    color: "#282a2e",
    backgroundColor: "#ffffff"
  },
  styles: [
    {
      types: ["comment"],
      style: {
        color: "rgb(197, 200, 198)"
      }
    },
    {
      types: ["string", "number", "builtin", "variable"],
      style: {
        color: "rgb(150, 152, 150)"
      }
    },
    {
      types: ["class-name", "function", "tag", "attr-name"],
      style: {
        color: "rgb(40, 42, 46)"
      }
    }
  ]
};
var ultramin_default = theme12;
var theme13 = {
  plain: {
    color: "#9CDCFE",
    backgroundColor: "#1E1E1E"
  },
  styles: [
    {
      types: ["prolog"],
      style: {
        color: "rgb(0, 0, 128)"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(106, 153, 85)"
      }
    },
    {
      types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
      style: {
        color: "rgb(86, 156, 214)"
      }
    },
    {
      types: ["number", "inserted"],
      style: {
        color: "rgb(181, 206, 168)"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "rgb(100, 102, 149)"
      }
    },
    {
      types: ["attr-name", "variable"],
      style: {
        color: "rgb(156, 220, 254)"
      }
    },
    {
      types: ["deleted", "string", "attr-value", "template-punctuation"],
      style: {
        color: "rgb(206, 145, 120)"
      }
    },
    {
      types: ["selector"],
      style: {
        color: "rgb(215, 186, 125)"
      }
    },
    {
      // Fix tag color
      types: ["tag"],
      style: {
        color: "rgb(78, 201, 176)"
      }
    },
    {
      // Fix tag color for HTML
      types: ["tag"],
      languages: ["markup"],
      style: {
        color: "rgb(86, 156, 214)"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "rgb(212, 212, 212)"
      }
    },
    {
      // Fix punctuation color for HTML
      types: ["punctuation"],
      languages: ["markup"],
      style: {
        color: "#808080"
      }
    },
    {
      types: ["function"],
      style: {
        color: "rgb(220, 220, 170)"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(78, 201, 176)"
      }
    },
    {
      types: ["char"],
      style: {
        color: "rgb(209, 105, 105)"
      }
    }
  ]
};
var vsDark_default = theme13;
var theme14 = {
  plain: {
    color: "#000000",
    backgroundColor: "#ffffff"
  },
  styles: [
    {
      types: ["comment"],
      style: {
        color: "rgb(0, 128, 0)"
      }
    },
    {
      types: ["builtin"],
      style: {
        color: "rgb(0, 112, 193)"
      }
    },
    {
      types: ["number", "variable", "inserted"],
      style: {
        color: "rgb(9, 134, 88)"
      }
    },
    {
      types: ["operator"],
      style: {
        color: "rgb(0, 0, 0)"
      }
    },
    {
      types: ["constant", "char"],
      style: {
        color: "rgb(129, 31, 63)"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "rgb(128, 0, 0)"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "rgb(255, 0, 0)"
      }
    },
    {
      types: ["deleted", "string"],
      style: {
        color: "rgb(163, 21, 21)"
      }
    },
    {
      types: ["changed", "punctuation"],
      style: {
        color: "rgb(4, 81, 165)"
      }
    },
    {
      types: ["function", "keyword"],
      style: {
        color: "rgb(0, 0, 255)"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(38, 127, 153)"
      }
    }
  ]
};
var vsLight_default = theme14;
var theme15 = {
  plain: {
    color: "#f8fafc",
    backgroundColor: "#011627"
  },
  styles: [
    {
      types: ["prolog"],
      style: {
        color: "#000080"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "#6A9955"
      }
    },
    {
      types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
      style: {
        color: "#569CD6"
      }
    },
    {
      types: ["number", "inserted"],
      style: {
        color: "#B5CEA8"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "#f8fafc"
      }
    },
    {
      types: ["attr-name", "variable"],
      style: {
        color: "#9CDCFE"
      }
    },
    {
      types: ["deleted", "string", "attr-value", "template-punctuation"],
      style: {
        color: "#cbd5e1"
      }
    },
    {
      types: ["selector"],
      style: {
        color: "#D7BA7D"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["tag"],
      languages: ["markup"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "#D4D4D4"
      }
    },
    {
      types: ["punctuation"],
      languages: ["markup"],
      style: {
        color: "#808080"
      }
    },
    {
      types: ["function"],
      style: {
        color: "#7dd3fc"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["char"],
      style: {
        color: "#D16969"
      }
    }
  ]
};
var jettwaveDark_default = theme15;
var theme16 = {
  plain: {
    color: "#0f172a",
    backgroundColor: "#f1f5f9"
  },
  styles: [
    {
      types: ["prolog"],
      style: {
        color: "#000080"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "#6A9955"
      }
    },
    {
      types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
      style: {
        color: "#0c4a6e"
      }
    },
    {
      types: ["number", "inserted"],
      style: {
        color: "#B5CEA8"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "#0f172a"
      }
    },
    {
      types: ["attr-name", "variable"],
      style: {
        color: "#0c4a6e"
      }
    },
    {
      types: ["deleted", "string", "attr-value", "template-punctuation"],
      style: {
        color: "#64748b"
      }
    },
    {
      types: ["selector"],
      style: {
        color: "#D7BA7D"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["tag"],
      languages: ["markup"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "#475569"
      }
    },
    {
      types: ["punctuation"],
      languages: ["markup"],
      style: {
        color: "#808080"
      }
    },
    {
      types: ["function"],
      style: {
        color: "#0e7490"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["char"],
      style: {
        color: "#D16969"
      }
    }
  ]
};
var jettwaveLight_default = theme16;
var theme17 = {
  plain: {
    backgroundColor: "hsl(220, 13%, 18%)",
    color: "hsl(220, 14%, 71%)",
    textShadow: "0 1px rgba(0, 0, 0, 0.3)"
  },
  styles: [
    {
      types: ["comment", "prolog", "cdata"],
      style: {
        color: "hsl(220, 10%, 40%)"
      }
    },
    {
      types: ["doctype", "punctuation", "entity"],
      style: {
        color: "hsl(220, 14%, 71%)"
      }
    },
    {
      types: [
        "attr-name",
        "class-name",
        "maybe-class-name",
        "boolean",
        "constant",
        "number",
        "atrule"
      ],
      style: { color: "hsl(29, 54%, 61%)" }
    },
    {
      types: ["keyword"],
      style: { color: "hsl(286, 60%, 67%)" }
    },
    {
      types: ["property", "tag", "symbol", "deleted", "important"],
      style: {
        color: "hsl(355, 65%, 65%)"
      }
    },
    {
      types: [
        "selector",
        "string",
        "char",
        "builtin",
        "inserted",
        "regex",
        "attr-value"
      ],
      style: {
        color: "hsl(95, 38%, 62%)"
      }
    },
    {
      types: ["variable", "operator", "function"],
      style: {
        color: "hsl(207, 82%, 66%)"
      }
    },
    {
      types: ["url"],
      style: {
        color: "hsl(187, 47%, 55%)"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "hsl(220, 14%, 71%)"
      }
    }
  ]
};
var oneDark_default = theme17;
var theme18 = {
  plain: {
    backgroundColor: "hsl(230, 1%, 98%)",
    color: "hsl(230, 8%, 24%)"
  },
  styles: [
    {
      types: ["comment", "prolog", "cdata"],
      style: {
        color: "hsl(230, 4%, 64%)"
      }
    },
    {
      types: ["doctype", "punctuation", "entity"],
      style: {
        color: "hsl(230, 8%, 24%)"
      }
    },
    {
      types: [
        "attr-name",
        "class-name",
        "boolean",
        "constant",
        "number",
        "atrule"
      ],
      style: {
        color: "hsl(35, 99%, 36%)"
      }
    },
    {
      types: ["keyword"],
      style: {
        color: "hsl(301, 63%, 40%)"
      }
    },
    {
      types: ["property", "tag", "symbol", "deleted", "important"],
      style: {
        color: "hsl(5, 74%, 59%)"
      }
    },
    {
      types: [
        "selector",
        "string",
        "char",
        "builtin",
        "inserted",
        "regex",
        "attr-value",
        "punctuation"
      ],
      style: {
        color: "hsl(119, 34%, 47%)"
      }
    },
    {
      types: ["variable", "operator", "function"],
      style: {
        color: "hsl(221, 87%, 60%)"
      }
    },
    {
      types: ["url"],
      style: {
        color: "hsl(198, 99%, 37%)"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "hsl(230, 8%, 24%)"
      }
    }
  ]
};
var oneLight_default = theme18;
var theme19 = {
  plain: {
    color: "#ebdbb2",
    backgroundColor: "#292828"
  },
  styles: [
    {
      types: [
        "imports",
        "class-name",
        "maybe-class-name",
        "constant",
        "doctype",
        "builtin",
        "function"
      ],
      style: {
        color: "#d8a657"
      }
    },
    {
      types: ["property-access"],
      style: {
        color: "#7daea3"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#e78a4e"
      }
    },
    {
      types: ["attr-name", "char", "url", "regex"],
      style: {
        color: "#a9b665"
      }
    },
    {
      types: ["attr-value", "string"],
      style: {
        color: "#89b482"
      }
    },
    {
      types: ["comment", "prolog", "cdata", "operator", "inserted"],
      style: {
        color: "#a89984"
      }
    },
    {
      types: [
        "delimiter",
        "boolean",
        "keyword",
        "selector",
        "important",
        "atrule",
        "property",
        "variable",
        "deleted"
      ],
      style: {
        color: "#ea6962"
      }
    },
    {
      types: ["entity", "number", "symbol"],
      style: {
        color: "#d3869b"
      }
    }
  ]
};
var gruvboxMaterialDark_default = theme19;
var theme20 = {
  plain: {
    color: "#654735",
    backgroundColor: "#f9f5d7"
  },
  styles: [
    {
      types: [
        "delimiter",
        "boolean",
        "keyword",
        "selector",
        "important",
        "atrule",
        "property",
        "variable",
        "deleted"
      ],
      style: {
        color: "#af2528"
      }
    },
    {
      types: [
        "imports",
        "class-name",
        "maybe-class-name",
        "constant",
        "doctype",
        "builtin"
      ],
      style: {
        color: "#b4730e"
      }
    },
    {
      types: ["string", "attr-value"],
      style: {
        color: "#477a5b"
      }
    },
    {
      types: ["property-access"],
      style: {
        color: "#266b79"
      }
    },
    {
      types: ["function", "attr-name", "char", "url"],
      style: {
        color: "#72761e"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#b94c07"
      }
    },
    {
      types: ["comment", "prolog", "cdata", "operator", "inserted"],
      style: {
        color: "#a89984"
      }
    },
    {
      types: ["entity", "number", "symbol"],
      style: {
        color: "#924f79"
      }
    }
  ]
};
var gruvboxMaterialLight_default = theme20;
const { createElement } = await importShared("react");
const { useCallback: useCallback$5 } = await importShared("react");
var useGetLineProps = (themeDictionary) => useCallback$5(
  (_a) => {
    var _b = _a, { className, style, line: line2 } = _b, rest = __objRest(_b, ["className", "style", "line"]);
    const output = __spreadProps(__spreadValues({}, rest), {
      className: clsx("token-line", className)
    });
    if (typeof themeDictionary === "object" && "plain" in themeDictionary)
      output.style = themeDictionary.plain;
    if (typeof style === "object")
      output.style = __spreadValues(__spreadValues({}, output.style || {}), style);
    return output;
  },
  [themeDictionary]
);
const { useCallback: useCallback2 } = await importShared("react");
var useGetTokenProps = (themeDictionary) => {
  const styleForToken = useCallback2(
    ({ types, empty }) => {
      if (themeDictionary == null)
        return void 0;
      else if (types.length === 1 && types[0] === "plain") {
        return empty != null ? { display: "inline-block" } : void 0;
      } else if (types.length === 1 && empty != null) {
        return themeDictionary[types[0]];
      }
      return Object.assign(
        empty != null ? { display: "inline-block" } : {},
        ...types.map((type) => themeDictionary[type])
      );
    },
    [themeDictionary]
  );
  return useCallback2(
    (_a) => {
      var _b = _a, { token: token2, className, style } = _b, rest = __objRest(_b, ["token", "className", "style"]);
      const output = __spreadProps(__spreadValues({}, rest), {
        className: clsx("token", ...token2.types, className),
        children: token2.content,
        style: styleForToken(token2)
      });
      if (style != null) {
        output.style = __spreadValues(__spreadValues({}, output.style || {}), style);
      }
      return output;
    },
    [styleForToken]
  );
};
var newlineRe = /\r\n|\r|\n/;
var normalizeEmptyLines = (line2) => {
  if (line2.length === 0) {
    line2.push({
      types: ["plain"],
      content: "\n",
      empty: true
    });
  } else if (line2.length === 1 && line2[0].content === "") {
    line2[0].content = "\n";
    line2[0].empty = true;
  }
};
var appendTypes = (types, add) => {
  const typesSize = types.length;
  if (typesSize > 0 && types[typesSize - 1] === add) {
    return types;
  }
  return types.concat(add);
};
var normalizeTokens = (tokens) => {
  const typeArrStack = [[]];
  const tokenArrStack = [tokens];
  const tokenArrIndexStack = [0];
  const tokenArrSizeStack = [tokens.length];
  let i = 0;
  let stackIndex = 0;
  let currentLine = [];
  const acc = [currentLine];
  while (stackIndex > -1) {
    while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {
      let content;
      let types = typeArrStack[stackIndex];
      const tokenArr = tokenArrStack[stackIndex];
      const token2 = tokenArr[i];
      if (typeof token2 === "string") {
        types = stackIndex > 0 ? types : ["plain"];
        content = token2;
      } else {
        types = appendTypes(types, token2.type);
        if (token2.alias) {
          types = appendTypes(types, token2.alias);
        }
        content = token2.content;
      }
      if (typeof content !== "string") {
        stackIndex++;
        typeArrStack.push(types);
        tokenArrStack.push(content);
        tokenArrIndexStack.push(0);
        tokenArrSizeStack.push(content.length);
        continue;
      }
      const splitByNewlines = content.split(newlineRe);
      const newlineCount = splitByNewlines.length;
      currentLine.push({
        types,
        content: splitByNewlines[0]
      });
      for (let i2 = 1; i2 < newlineCount; i2++) {
        normalizeEmptyLines(currentLine);
        acc.push(currentLine = []);
        currentLine.push({
          types,
          content: splitByNewlines[i2]
        });
      }
    }
    stackIndex--;
    typeArrStack.pop();
    tokenArrStack.pop();
    tokenArrIndexStack.pop();
    tokenArrSizeStack.pop();
  }
  normalizeEmptyLines(currentLine);
  return acc;
};
var normalizeTokens_default = normalizeTokens;
const { useMemo: useMemo$5 } = await importShared("react");
var useTokenize = ({ prism, code, grammar, language }) => {
  return useMemo$5(() => {
    if (grammar == null)
      return normalizeTokens_default([code]);
    const prismConfig = {
      code,
      grammar,
      language,
      tokens: []
    };
    prism.hooks.run("before-tokenize", prismConfig);
    prismConfig.tokens = prism.tokenize(code, grammar);
    prism.hooks.run("after-tokenize", prismConfig);
    return normalizeTokens_default(prismConfig.tokens);
  }, [
    code,
    grammar,
    language,
    // prism is a stable import
    prism
  ]);
};
var themeToDict = (theme21, language) => {
  const { plain } = theme21;
  const themeDict = theme21.styles.reduce((acc, themeEntry) => {
    const { languages: languages2, style } = themeEntry;
    if (languages2 && !languages2.includes(language)) {
      return acc;
    }
    themeEntry.types.forEach((type) => {
      const accStyle = __spreadValues(__spreadValues({}, acc[type]), style);
      acc[type] = accStyle;
    });
    return acc;
  }, {});
  themeDict.root = plain;
  themeDict.plain = __spreadProps(__spreadValues({}, plain), { backgroundColor: void 0 });
  return themeDict;
};
var themeToDict_default = themeToDict;
var Highlight = ({
  children,
  language: _language,
  code,
  theme: theme21,
  prism
}) => {
  const language = _language.toLowerCase();
  const themeDictionary = themeToDict_default(theme21, language);
  const getLineProps = useGetLineProps(themeDictionary);
  const getTokenProps = useGetTokenProps(themeDictionary);
  const grammar = prism.languages[language];
  const tokens = useTokenize({ prism, language, code, grammar });
  return children({
    tokens,
    className: `prism-code language-${language}`,
    style: themeDictionary != null ? themeDictionary.root : {},
    getLineProps,
    getTokenProps
  });
};
var Highlight2 = (props) => createElement(Highlight, __spreadProps(__spreadValues({}, props), {
  prism: props.prism || Prism,
  theme: props.theme || vsDark_default,
  code: props.code,
  language: props.language
}));
/*! Bundled license information:

prismjs/prism.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)
*/
/*! xlsx.js (C) 2013-present SheetJS -- http://sheetjs.com */
var current_codepage = 1200;
var $cptable;
var VALID_ANSI = [874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1e4];
var CS2CP = {
  0: 1252,
  /* ANSI */
  1: 65001,
  /* DEFAULT */
  2: 65001,
  /* SYMBOL */
  77: 1e4,
  /* MAC */
  128: 932,
  /* SHIFTJIS */
  129: 949,
  /* HANGUL */
  130: 1361,
  /* JOHAB */
  134: 936,
  /* GB2312 */
  136: 950,
  /* CHINESEBIG5 */
  161: 1253,
  /* GREEK */
  162: 1254,
  /* TURKISH */
  163: 1258,
  /* VIETNAMESE */
  177: 1255,
  /* HEBREW */
  178: 1256,
  /* ARABIC */
  186: 1257,
  /* BALTIC */
  204: 1251,
  /* RUSSIAN */
  222: 874,
  /* THAI */
  238: 1250,
  /* EASTEUROPE */
  255: 1252,
  /* OEM */
  69: 6969
  /* MISC */
};
var set_ansi = function(cp) {
  if (VALID_ANSI.indexOf(cp) == -1) return;
  CS2CP[0] = cp;
};
function reset_ansi() {
  set_ansi(1252);
}
var set_cp = function(cp) {
  current_codepage = cp;
  set_ansi(cp);
};
function reset_cp() {
  set_cp(1200);
  reset_ansi();
}
function char_codes(data) {
  var o = [];
  for (var i = 0, len = data.length; i < len; ++i) o[i] = data.charCodeAt(i);
  return o;
}
function utf16leread(data) {
  var o = [];
  for (var i = 0; i < data.length >> 1; ++i) o[i] = String.fromCharCode(data.charCodeAt(2 * i) + (data.charCodeAt(2 * i + 1) << 8));
  return o.join("");
}
function utf16lereadu(data) {
  var o = [];
  for (var i = 0; i < data.length >> 1; ++i) o[i] = String.fromCharCode(data[2 * i] + (data[2 * i + 1] << 8));
  return o.join("");
}
function utf16beread(data) {
  var o = [];
  for (var i = 0; i < data.length >> 1; ++i) o[i] = String.fromCharCode(data.charCodeAt(2 * i + 1) + (data.charCodeAt(2 * i) << 8));
  return o.join("");
}
var debom = function(data) {
  var c1 = data.charCodeAt(0), c2 = data.charCodeAt(1);
  if (c1 == 255 && c2 == 254) return utf16leread(data.slice(2));
  if (c1 == 254 && c2 == 255) return utf16beread(data.slice(2));
  if (c1 == 65279) return data.slice(1);
  return data;
};
var _getchar = function _gc1(x) {
  return String.fromCharCode(x);
};
var _getansi = function _ga1(x) {
  return String.fromCharCode(x);
};
var DENSE = null;
var Base64_map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function Base64_encode(input) {
  var o = "";
  var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
  for (var i = 0; i < input.length; ) {
    c1 = input.charCodeAt(i++);
    e1 = c1 >> 2;
    c2 = input.charCodeAt(i++);
    e2 = (c1 & 3) << 4 | c2 >> 4;
    c3 = input.charCodeAt(i++);
    e3 = (c2 & 15) << 2 | c3 >> 6;
    e4 = c3 & 63;
    if (isNaN(c2)) {
      e3 = e4 = 64;
    } else if (isNaN(c3)) {
      e4 = 64;
    }
    o += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);
  }
  return o;
}
function Base64_decode(input) {
  var o = "";
  var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
  if (input.slice(0, 5) == "data:") {
    var i = input.slice(0, 1024).indexOf(";base64,");
    if (i > -1)
      input = input.slice(i + 8);
  }
  input = input.replace(/[^\w\+\/\=]/g, "");
  for (var i = 0; i < input.length; ) {
    e1 = Base64_map.indexOf(input.charAt(i++));
    e2 = Base64_map.indexOf(input.charAt(i++));
    c1 = e1 << 2 | e2 >> 4;
    o += String.fromCharCode(c1);
    e3 = Base64_map.indexOf(input.charAt(i++));
    c2 = (e2 & 15) << 4 | e3 >> 2;
    if (e3 !== 64) {
      o += String.fromCharCode(c2);
    }
    e4 = Base64_map.indexOf(input.charAt(i++));
    c3 = (e3 & 3) << 6 | e4;
    if (e4 !== 64) {
      o += String.fromCharCode(c3);
    }
  }
  return o;
}
var has_buf = /* @__PURE__ */ function() {
  return typeof Buffer !== "undefined" && typeof process !== "undefined" && typeof process.versions !== "undefined" && !!process.versions.node;
}();
var Buffer_from = /* @__PURE__ */ function() {
  if (typeof Buffer !== "undefined") {
    var nbfs = !Buffer.from;
    if (!nbfs) try {
      Buffer.from("foo", "utf8");
    } catch (e) {
      nbfs = true;
    }
    return nbfs ? function(buf, enc) {
      return enc ? new Buffer(buf, enc) : new Buffer(buf);
    } : Buffer.from.bind(Buffer);
  }
  return function() {
  };
}();
var buf_utf16le = /* @__PURE__ */ function() {
  if (typeof Buffer === "undefined") return false;
  var x = Buffer_from([65, 0]);
  if (!x) return false;
  var o = x.toString("utf16le");
  return o.length == 1;
}();
function new_raw_buf(len) {
  if (has_buf) return Buffer.alloc ? Buffer.alloc(len) : new Buffer(len);
  return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
}
function new_unsafe_buf(len) {
  if (has_buf) return Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : new Buffer(len);
  return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
}
var s2a = function s2a2(s) {
  if (has_buf) return Buffer_from(s, "binary");
  return s.split("").map(function(x) {
    return x.charCodeAt(0) & 255;
  });
};
function a2s(data) {
  if (Array.isArray(data)) return data.map(function(c2) {
    return String.fromCharCode(c2);
  }).join("");
  var o = [];
  for (var i = 0; i < data.length; ++i) o[i] = String.fromCharCode(data[i]);
  return o.join("");
}
function ab2a(data) {
  if (typeof ArrayBuffer == "undefined") throw new Error("Unsupported");
  if (data instanceof ArrayBuffer) return ab2a(new Uint8Array(data));
  var o = new Array(data.length);
  for (var i = 0; i < data.length; ++i) o[i] = data[i];
  return o;
}
var bconcat = has_buf ? function(bufs) {
  return Buffer.concat(bufs.map(function(buf) {
    return Buffer.isBuffer(buf) ? buf : Buffer_from(buf);
  }));
} : function(bufs) {
  if (typeof Uint8Array !== "undefined") {
    var i = 0, maxlen = 0;
    for (i = 0; i < bufs.length; ++i) maxlen += bufs[i].length;
    var o = new Uint8Array(maxlen);
    var len = 0;
    for (i = 0, maxlen = 0; i < bufs.length; maxlen += len, ++i) {
      len = bufs[i].length;
      if (bufs[i] instanceof Uint8Array) o.set(bufs[i], maxlen);
      else if (typeof bufs[i] == "string") o.set(new Uint8Array(s2a(bufs[i])), maxlen);
      else o.set(new Uint8Array(bufs[i]), maxlen);
    }
    return o;
  }
  return [].concat.apply([], bufs.map(function(buf) {
    return Array.isArray(buf) ? buf : [].slice.call(buf);
  }));
};
function utf8decode(content) {
  var out = [], widx = 0, L = content.length + 250;
  var o = new_raw_buf(content.length + 255);
  for (var ridx = 0; ridx < content.length; ++ridx) {
    var c2 = content.charCodeAt(ridx);
    if (c2 < 128) o[widx++] = c2;
    else if (c2 < 2048) {
      o[widx++] = 192 | c2 >> 6 & 31;
      o[widx++] = 128 | c2 & 63;
    } else if (c2 >= 55296 && c2 < 57344) {
      c2 = (c2 & 1023) + 64;
      var d = content.charCodeAt(++ridx) & 1023;
      o[widx++] = 240 | c2 >> 8 & 7;
      o[widx++] = 128 | c2 >> 2 & 63;
      o[widx++] = 128 | d >> 6 & 15 | (c2 & 3) << 4;
      o[widx++] = 128 | d & 63;
    } else {
      o[widx++] = 224 | c2 >> 12 & 15;
      o[widx++] = 128 | c2 >> 6 & 63;
      o[widx++] = 128 | c2 & 63;
    }
    if (widx > L) {
      out.push(o.slice(0, widx));
      widx = 0;
      o = new_raw_buf(65535);
      L = 65530;
    }
  }
  out.push(o.slice(0, widx));
  return bconcat(out);
}
var chr0 = /\u0000/g, chr1 = /[\u0001-\u0006]/g;
function _strrev(x) {
  var o = "", i = x.length - 1;
  while (i >= 0) o += x.charAt(i--);
  return o;
}
function pad0(v2, d) {
  var t = "" + v2;
  return t.length >= d ? t : fill("0", d - t.length) + t;
}
function pad_(v2, d) {
  var t = "" + v2;
  return t.length >= d ? t : fill(" ", d - t.length) + t;
}
function rpad_(v2, d) {
  var t = "" + v2;
  return t.length >= d ? t : t + fill(" ", d - t.length);
}
function pad0r1(v2, d) {
  var t = "" + Math.round(v2);
  return t.length >= d ? t : fill("0", d - t.length) + t;
}
function pad0r2(v2, d) {
  var t = "" + v2;
  return t.length >= d ? t : fill("0", d - t.length) + t;
}
var p2_32 = /* @__PURE__ */ Math.pow(2, 32);
function pad0r(v2, d) {
  if (v2 > p2_32 || v2 < -p2_32) return pad0r1(v2, d);
  var i = Math.round(v2);
  return pad0r2(i, d);
}
function SSF_isgeneral(s, i) {
  i = i || 0;
  return s.length >= 7 + i && (s.charCodeAt(i) | 32) === 103 && (s.charCodeAt(i + 1) | 32) === 101 && (s.charCodeAt(i + 2) | 32) === 110 && (s.charCodeAt(i + 3) | 32) === 101 && (s.charCodeAt(i + 4) | 32) === 114 && (s.charCodeAt(i + 5) | 32) === 97 && (s.charCodeAt(i + 6) | 32) === 108;
}
var days = [
  ["Sun", "Sunday"],
  ["Mon", "Monday"],
  ["Tue", "Tuesday"],
  ["Wed", "Wednesday"],
  ["Thu", "Thursday"],
  ["Fri", "Friday"],
  ["Sat", "Saturday"]
];
var months = [
  ["J", "Jan", "January"],
  ["F", "Feb", "February"],
  ["M", "Mar", "March"],
  ["A", "Apr", "April"],
  ["M", "May", "May"],
  ["J", "Jun", "June"],
  ["J", "Jul", "July"],
  ["A", "Aug", "August"],
  ["S", "Sep", "September"],
  ["O", "Oct", "October"],
  ["N", "Nov", "November"],
  ["D", "Dec", "December"]
];
function SSF_init_table(t) {
  if (!t) t = {};
  t[0] = "General";
  t[1] = "0";
  t[2] = "0.00";
  t[3] = "#,##0";
  t[4] = "#,##0.00";
  t[9] = "0%";
  t[10] = "0.00%";
  t[11] = "0.00E+00";
  t[12] = "# ?/?";
  t[13] = "# ??/??";
  t[14] = "m/d/yy";
  t[15] = "d-mmm-yy";
  t[16] = "d-mmm";
  t[17] = "mmm-yy";
  t[18] = "h:mm AM/PM";
  t[19] = "h:mm:ss AM/PM";
  t[20] = "h:mm";
  t[21] = "h:mm:ss";
  t[22] = "m/d/yy h:mm";
  t[37] = "#,##0 ;(#,##0)";
  t[38] = "#,##0 ;[Red](#,##0)";
  t[39] = "#,##0.00;(#,##0.00)";
  t[40] = "#,##0.00;[Red](#,##0.00)";
  t[45] = "mm:ss";
  t[46] = "[h]:mm:ss";
  t[47] = "mmss.0";
  t[48] = "##0.0E+0";
  t[49] = "@";
  t[56] = '"/ "hh""mm""ss" "';
  return t;
}
var table_fmt = {
  0: "General",
  1: "0",
  2: "0.00",
  3: "#,##0",
  4: "#,##0.00",
  9: "0%",
  10: "0.00%",
  11: "0.00E+00",
  12: "# ?/?",
  13: "# ??/??",
  14: "m/d/yy",
  15: "d-mmm-yy",
  16: "d-mmm",
  17: "mmm-yy",
  18: "h:mm AM/PM",
  19: "h:mm:ss AM/PM",
  20: "h:mm",
  21: "h:mm:ss",
  22: "m/d/yy h:mm",
  37: "#,##0 ;(#,##0)",
  38: "#,##0 ;[Red](#,##0)",
  39: "#,##0.00;(#,##0.00)",
  40: "#,##0.00;[Red](#,##0.00)",
  45: "mm:ss",
  46: "[h]:mm:ss",
  47: "mmss.0",
  48: "##0.0E+0",
  49: "@",
  56: '"/ "hh""mm""ss" "'
};
var SSF_default_map = {
  5: 37,
  6: 38,
  7: 39,
  8: 40,
  //  5 -> 37 ...  8 -> 40
  23: 0,
  24: 0,
  25: 0,
  26: 0,
  // 23 ->  0 ... 26 ->  0
  27: 14,
  28: 14,
  29: 14,
  30: 14,
  31: 14,
  // 27 -> 14 ... 31 -> 14
  50: 14,
  51: 14,
  52: 14,
  53: 14,
  54: 14,
  // 50 -> 14 ... 58 -> 14
  55: 14,
  56: 14,
  57: 14,
  58: 14,
  59: 1,
  60: 2,
  61: 3,
  62: 4,
  // 59 ->  1 ... 62 ->  4
  67: 9,
  68: 10,
  // 67 ->  9 ... 68 -> 10
  69: 12,
  70: 13,
  71: 14,
  // 69 -> 12 ... 71 -> 14
  72: 14,
  73: 15,
  74: 16,
  75: 17,
  // 72 -> 14 ... 75 -> 17
  76: 20,
  77: 21,
  78: 22,
  // 76 -> 20 ... 78 -> 22
  79: 45,
  80: 46,
  81: 47,
  // 79 -> 45 ... 81 -> 47
  82: 0
  // 82 ->  0 ... 65536 -> 0 (omitted)
};
var SSF_default_str = {
  //  5 -- Currency,   0 decimal, black negative
  5: '"$"#,##0_);\\("$"#,##0\\)',
  63: '"$"#,##0_);\\("$"#,##0\\)',
  //  6 -- Currency,   0 decimal, red   negative
  6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  //  7 -- Currency,   2 decimal, black negative
  7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  //  8 -- Currency,   2 decimal, red   negative
  8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  // 41 -- Accounting, 0 decimal, No Symbol
  41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',
  // 42 -- Accounting, 0 decimal, $  Symbol
  42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',
  // 43 -- Accounting, 2 decimal, No Symbol
  43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',
  // 44 -- Accounting, 2 decimal, $  Symbol
  44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'
};
function SSF_frac(x, D2, mixed) {
  var sgn = x < 0 ? -1 : 1;
  var B = x * sgn;
  var P_2 = 0, P_1 = 1, P = 0;
  var Q_2 = 1, Q_1 = 0, Q = 0;
  var A = Math.floor(B);
  while (Q_1 < D2) {
    A = Math.floor(B);
    P = A * P_1 + P_2;
    Q = A * Q_1 + Q_2;
    if (B - A < 5e-8) break;
    B = 1 / (B - A);
    P_2 = P_1;
    P_1 = P;
    Q_2 = Q_1;
    Q_1 = Q;
  }
  if (Q > D2) {
    if (Q_1 > D2) {
      Q = Q_2;
      P = P_2;
    } else {
      Q = Q_1;
      P = P_1;
    }
  }
  if (!mixed) return [0, sgn * P, Q];
  var q = Math.floor(sgn * P / Q);
  return [q, sgn * P - q * Q, Q];
}
function SSF_normalize_xl_unsafe(v2) {
  var s = v2.toPrecision(16);
  if (s.indexOf("e") > -1) {
    var m = s.slice(0, s.indexOf("e"));
    m = m.indexOf(".") > -1 ? m.slice(0, m.slice(0, 2) == "0." ? 17 : 16) : m.slice(0, 15) + fill("0", m.length - 15);
    return m + s.slice(s.indexOf("e"));
  }
  var n = s.indexOf(".") > -1 ? s.slice(0, s.slice(0, 2) == "0." ? 17 : 16) : s.slice(0, 15) + fill("0", s.length - 15);
  return Number(n);
}
function SSF_parse_date_code(v2, opts, b2) {
  if (v2 > 2958465 || v2 < 0) return null;
  v2 = SSF_normalize_xl_unsafe(v2);
  var date = v2 | 0, time = Math.floor(86400 * (v2 - date)), dow = 0;
  var dout = [];
  var out = { D: date, T: time, u: 86400 * (v2 - date) - time, y: 0, m: 0, d: 0, H: 0, M: 0, S: 0, q: 0 };
  if (Math.abs(out.u) < 1e-6) out.u = 0;
  if (opts && opts.date1904) date += 1462;
  if (out.u > 0.9999) {
    out.u = 0;
    if (++time == 86400) {
      out.T = time = 0;
      ++date;
      ++out.D;
    }
  }
  if (date === 60) {
    dout = b2 ? [1317, 10, 29] : [1900, 2, 29];
    dow = 3;
  } else if (date === 0) {
    dout = b2 ? [1317, 8, 29] : [1900, 1, 0];
    dow = 6;
  } else {
    if (date > 60) --date;
    var d = new Date(1900, 0, 1);
    d.setDate(d.getDate() + date - 1);
    dout = [d.getFullYear(), d.getMonth() + 1, d.getDate()];
    dow = d.getDay();
    if (date < 60) dow = (dow + 6) % 7;
    if (b2) dow = SSF_fix_hijri(d, dout);
  }
  out.y = dout[0];
  out.m = dout[1];
  out.d = dout[2];
  out.S = time % 60;
  time = Math.floor(time / 60);
  out.M = time % 60;
  time = Math.floor(time / 60);
  out.H = time;
  out.q = dow;
  return out;
}
function SSF_strip_decimal(o) {
  return o.indexOf(".") == -1 ? o : o.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1");
}
function SSF_normalize_exp(o) {
  if (o.indexOf("E") == -1) return o;
  return o.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/, "$1E").replace(/(E[+-])(\d)$/, "$10$2");
}
function SSF_small_exp(v2) {
  var w = v2 < 0 ? 12 : 11;
  var o = SSF_strip_decimal(v2.toFixed(12));
  if (o.length <= w) return o;
  o = v2.toPrecision(10);
  if (o.length <= w) return o;
  return v2.toExponential(5);
}
function SSF_large_exp(v2) {
  var o = SSF_strip_decimal(v2.toFixed(11));
  return o.length > (v2 < 0 ? 12 : 11) || o === "0" || o === "-0" ? v2.toPrecision(6) : o;
}
function SSF_general_num(v2) {
  var V = Math.floor(Math.log(Math.abs(v2)) * Math.LOG10E), o;
  if (V >= -4 && V <= -1) o = v2.toPrecision(10 + V);
  else if (Math.abs(V) <= 9) o = SSF_small_exp(v2);
  else if (V === 10) o = v2.toFixed(10).substr(0, 12);
  else o = SSF_large_exp(v2);
  return SSF_strip_decimal(SSF_normalize_exp(o.toUpperCase()));
}
function SSF_general(v2, opts) {
  switch (typeof v2) {
    case "string":
      return v2;
    case "boolean":
      return v2 ? "TRUE" : "FALSE";
    case "number":
      return (v2 | 0) === v2 ? v2.toString(10) : SSF_general_num(v2);
    case "undefined":
      return "";
    case "object":
      if (v2 == null) return "";
      if (v2 instanceof Date) return SSF_format(14, datenum(v2, opts && opts.date1904), opts);
  }
  throw new Error("unsupported value in General format: " + v2);
}
function SSF_fix_hijri(date, o) {
  o[0] -= 581;
  var dow = date.getDay();
  if (date < 60) dow = (dow + 6) % 7;
  return dow;
}
function SSF_write_date(type, fmt, val, ss0) {
  var o = "", ss = 0, tt = 0, y = val.y, out, outl = 0;
  switch (type) {
    case 98:
      y = val.y + 543;
    case 121:
      switch (fmt.length) {
        case 1:
        case 2:
          out = y % 100;
          outl = 2;
          break;
        default:
          out = y % 1e4;
          outl = 4;
          break;
      }
      break;
    case 109:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.m;
          outl = fmt.length;
          break;
        case 3:
          return months[val.m - 1][1];
        case 5:
          return months[val.m - 1][0];
        default:
          return months[val.m - 1][2];
      }
      break;
    case 100:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.d;
          outl = fmt.length;
          break;
        case 3:
          return days[val.q][0];
        default:
          return days[val.q][1];
      }
      break;
    case 104:
      switch (fmt.length) {
        case 1:
        case 2:
          out = 1 + (val.H + 11) % 12;
          outl = fmt.length;
          break;
        default:
          throw "bad hour format: " + fmt;
      }
      break;
    case 72:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.H;
          outl = fmt.length;
          break;
        default:
          throw "bad hour format: " + fmt;
      }
      break;
    case 77:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.M;
          outl = fmt.length;
          break;
        default:
          throw "bad minute format: " + fmt;
      }
      break;
    case 115:
      if (fmt != "s" && fmt != "ss" && fmt != ".0" && fmt != ".00" && fmt != ".000") throw "bad second format: " + fmt;
      if (val.u === 0 && (fmt == "s" || fmt == "ss")) return pad0(val.S, fmt.length);
      if (ss0 >= 2) tt = ss0 === 3 ? 1e3 : 100;
      else tt = ss0 === 1 ? 10 : 1;
      ss = Math.round(tt * (val.S + val.u));
      if (ss >= 60 * tt) ss = 0;
      if (fmt === "s") return ss === 0 ? "0" : "" + ss / tt;
      o = pad0(ss, 2 + ss0);
      if (fmt === "ss") return o.substr(0, 2);
      return "." + o.substr(2, fmt.length - 1);
    case 90:
      switch (fmt) {
        case "[h]":
        case "[hh]":
          out = val.D * 24 + val.H;
          break;
        case "[m]":
        case "[mm]":
          out = (val.D * 24 + val.H) * 60 + val.M;
          break;
        case "[s]":
        case "[ss]":
          out = ((val.D * 24 + val.H) * 60 + val.M) * 60 + (ss0 == 0 ? Math.round(val.S + val.u) : val.S);
          break;
        default:
          throw "bad abstime format: " + fmt;
      }
      outl = fmt.length === 3 ? 1 : 2;
      break;
    case 101:
      out = y;
      outl = 1;
      break;
  }
  var outstr = outl > 0 ? pad0(out, outl) : "";
  return outstr;
}
function commaify(s) {
  var w = 3;
  if (s.length <= w) return s;
  var j = s.length % w, o = s.substr(0, j);
  for (; j != s.length; j += w) o += (o.length > 0 ? "," : "") + s.substr(j, w);
  return o;
}
var pct1 = /%/g;
function write_num_pct(type, fmt, val) {
  var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
  return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
}
function write_num_cm(type, fmt, val) {
  var idx = fmt.length - 1;
  while (fmt.charCodeAt(idx - 1) === 44) --idx;
  return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
}
function write_num_exp(fmt, val) {
  var o;
  var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
  if (fmt.match(/^#+0.0E\+0$/)) {
    if (val == 0) return "0.0E+0";
    else if (val < 0) return "-" + write_num_exp(fmt, -val);
    var period = fmt.indexOf(".");
    if (period === -1) period = fmt.indexOf("E");
    var ee2 = Math.floor(Math.log(val) * Math.LOG10E) % period;
    if (ee2 < 0) ee2 += period;
    o = (val / Math.pow(10, ee2)).toPrecision(idx + 1 + (period + ee2) % period);
    if (o.indexOf("e") === -1) {
      var fakee = Math.floor(Math.log(val) * Math.LOG10E);
      if (o.indexOf(".") === -1) o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length + ee2);
      else o += "E+" + (fakee - ee2);
      while (o.substr(0, 2) === "0.") {
        o = o.charAt(0) + o.substr(2, period) + "." + o.substr(2 + period);
        o = o.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
      }
      o = o.replace(/\+-/, "-");
    }
    o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
      return $1 + $2 + $3.substr(0, (period + ee2) % period) + "." + $3.substr(ee2) + "E";
    });
  } else o = val.toExponential(idx);
  if (fmt.match(/E\+00$/) && o.match(/e[+-]\d$/)) o = o.substr(0, o.length - 1) + "0" + o.charAt(o.length - 1);
  if (fmt.match(/E\-/) && o.match(/e\+/)) o = o.replace(/e\+/, "e");
  return o.replace("e", "E");
}
var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;
function write_num_f1(r, aval, sign2) {
  var den = parseInt(r[4], 10), rr = Math.round(aval * den), base = Math.floor(rr / den);
  var myn = rr - base * den, myd = den;
  return sign2 + (base === 0 ? "" : "" + base) + " " + (myn === 0 ? fill(" ", r[1].length + 1 + r[4].length) : pad_(myn, r[1].length) + r[2] + "/" + r[3] + pad0(myd, r[4].length));
}
function write_num_f2(r, aval, sign2) {
  return sign2 + (aval === 0 ? "" : "" + aval) + fill(" ", r[1].length + 2 + r[4].length);
}
var dec1 = /^#*0*\.([0#]+)/;
var closeparen = /\)[^)]*[0#]/;
var phone = /\(###\) ###\\?-####/;
function hashq(str) {
  var o = "", cc;
  for (var i = 0; i != str.length; ++i) switch (cc = str.charCodeAt(i)) {
    case 35:
      break;
    case 63:
      o += " ";
      break;
    case 48:
      o += "0";
      break;
    default:
      o += String.fromCharCode(cc);
  }
  return o;
}
function rnd(val, d) {
  var dd = Math.pow(10, d);
  return "" + Math.round(val * dd) / dd;
}
function dec(val, d) {
  var _frac = val - Math.floor(val), dd = Math.pow(10, d);
  if (d < ("" + Math.round(_frac * dd)).length) return 0;
  return Math.round(_frac * dd);
}
function carry(val, d) {
  if (d < ("" + Math.round((val - Math.floor(val)) * Math.pow(10, d))).length) {
    return 1;
  }
  return 0;
}
function flr(val) {
  if (val < 2147483647 && val > -2147483648) return "" + (val >= 0 ? val | 0 : val - 1 | 0);
  return "" + Math.floor(val);
}
function write_num_flt(type, fmt, val) {
  if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
    var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    if (val >= 0) return write_num_flt("n", ffmt, val);
    return "(" + write_num_flt("n", ffmt, -val) + ")";
  }
  if (fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm(type, fmt, val);
  if (fmt.indexOf("%") !== -1) return write_num_pct(type, fmt, val);
  if (fmt.indexOf("E") !== -1) return write_num_exp(fmt, val);
  if (fmt.charCodeAt(0) === 36) return "$" + write_num_flt(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
  var o;
  var r, ri, ff, aval = Math.abs(val), sign2 = val < 0 ? "-" : "";
  if (fmt.match(/^00+$/)) return sign2 + pad0r(aval, fmt.length);
  if (fmt.match(/^[#?]+$/)) {
    o = pad0r(val, 0);
    if (o === "0") o = "";
    return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o;
  }
  if (r = fmt.match(frac1)) return write_num_f1(r, aval, sign2);
  if (fmt.match(/^#+0+$/)) return sign2 + pad0r(aval, fmt.length - fmt.indexOf("0"));
  if (r = fmt.match(dec1)) {
    o = rnd(val, r[1].length).replace(/^([^\.]+)$/, "$1." + hashq(r[1])).replace(/\.$/, "." + hashq(r[1])).replace(/\.(\d*)$/, function($$, $1) {
      return "." + $1 + fill("0", hashq(
        /*::(*/
        r[1]
      ).length - $1.length);
    });
    return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".");
  }
  fmt = fmt.replace(/^#+([0.])/, "$1");
  if (r = fmt.match(/^(0*)\.(#*)$/)) {
    return sign2 + rnd(aval, r[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".");
  }
  if (r = fmt.match(/^#{1,3},##0(\.?)$/)) return sign2 + commaify(pad0r(aval, 0));
  if (r = fmt.match(/^#,##0\.([#0]*0)$/)) {
    return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify("" + (Math.floor(val) + carry(val, r[1].length))) + "." + pad0(dec(val, r[1].length), r[1].length);
  }
  if (r = fmt.match(/^#,#*,#0/)) return write_num_flt(type, fmt.replace(/^#,#*,/, ""), val);
  if (r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
    o = _strrev(write_num_flt(type, fmt.replace(/[\\-]/g, ""), val));
    ri = 0;
    return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x2) {
      return ri < o.length ? o.charAt(ri++) : x2 === "0" ? "0" : "";
    }));
  }
  if (fmt.match(phone)) {
    o = write_num_flt(type, "##########", val);
    return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
  }
  var oa = "";
  if (r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri = Math.min(
      /*::String(*/
      r[4].length,
      7
    );
    ff = SSF_frac(aval, Math.pow(10, ri) - 1, false);
    o = "" + sign2;
    oa = write_num(
      "n",
      /*::String(*/
      r[1],
      ff[1]
    );
    if (oa.charAt(oa.length - 1) == " ") oa = oa.substr(0, oa.length - 1) + "0";
    o += oa + /*::String(*/
    r[2] + "/" + /*::String(*/
    r[3];
    oa = rpad_(ff[2], ri);
    if (oa.length < r[4].length) oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
    o += oa;
    return o;
  }
  if (r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri = Math.min(Math.max(r[1].length, r[4].length), 7);
    ff = SSF_frac(aval, Math.pow(10, ri) - 1, true);
    return sign2 + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r[2].length + r[3].length));
  }
  if (r = fmt.match(/^[#0?]+$/)) {
    o = pad0r(val, 0);
    if (fmt.length <= o.length) return o;
    return hashq(fmt.substr(0, fmt.length - o.length)) + o;
  }
  if (r = fmt.match(/^([#0?]+)\.([#0]+)$/)) {
    o = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
    ri = o.indexOf(".");
    var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;
    return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres));
  }
  if (r = fmt.match(/^00,000\.([#0]*0)$/)) {
    ri = dec(val, r[1].length);
    return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify(flr(val)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
      return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
    }) + "." + pad0(ri, r[1].length);
  }
  switch (fmt) {
    case "###,##0.00":
      return write_num_flt(type, "#,##0.00", val);
    case "###,###":
    case "##,###":
    case "#,###":
      var x = commaify(pad0r(aval, 0));
      return x !== "0" ? sign2 + x : "";
    case "###,###.00":
      return write_num_flt(type, "###,##0.00", val).replace(/^0\./, ".");
    case "#,###.00":
      return write_num_flt(type, "#,##0.00", val).replace(/^0\./, ".");
  }
  throw new Error("unsupported format |" + fmt + "|");
}
function write_num_cm2(type, fmt, val) {
  var idx = fmt.length - 1;
  while (fmt.charCodeAt(idx - 1) === 44) --idx;
  return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
}
function write_num_pct2(type, fmt, val) {
  var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
  return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
}
function write_num_exp2(fmt, val) {
  var o;
  var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
  if (fmt.match(/^#+0.0E\+0$/)) {
    if (val == 0) return "0.0E+0";
    else if (val < 0) return "-" + write_num_exp2(fmt, -val);
    var period = fmt.indexOf(".");
    if (period === -1) period = fmt.indexOf("E");
    var ee2 = Math.floor(Math.log(val) * Math.LOG10E) % period;
    if (ee2 < 0) ee2 += period;
    o = (val / Math.pow(10, ee2)).toPrecision(idx + 1 + (period + ee2) % period);
    if (!o.match(/[Ee]/)) {
      var fakee = Math.floor(Math.log(val) * Math.LOG10E);
      if (o.indexOf(".") === -1) o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length + ee2);
      else o += "E+" + (fakee - ee2);
      o = o.replace(/\+-/, "-");
    }
    o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
      return $1 + $2 + $3.substr(0, (period + ee2) % period) + "." + $3.substr(ee2) + "E";
    });
  } else o = val.toExponential(idx);
  if (fmt.match(/E\+00$/) && o.match(/e[+-]\d$/)) o = o.substr(0, o.length - 1) + "0" + o.charAt(o.length - 1);
  if (fmt.match(/E\-/) && o.match(/e\+/)) o = o.replace(/e\+/, "e");
  return o.replace("e", "E");
}
function write_num_int(type, fmt, val) {
  if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
    var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    if (val >= 0) return write_num_int("n", ffmt, val);
    return "(" + write_num_int("n", ffmt, -val) + ")";
  }
  if (fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm2(type, fmt, val);
  if (fmt.indexOf("%") !== -1) return write_num_pct2(type, fmt, val);
  if (fmt.indexOf("E") !== -1) return write_num_exp2(fmt, val);
  if (fmt.charCodeAt(0) === 36) return "$" + write_num_int(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
  var o;
  var r, ri, ff, aval = Math.abs(val), sign2 = val < 0 ? "-" : "";
  if (fmt.match(/^00+$/)) return sign2 + pad0(aval, fmt.length);
  if (fmt.match(/^[#?]+$/)) {
    o = "" + val;
    if (val === 0) o = "";
    return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o;
  }
  if (r = fmt.match(frac1)) return write_num_f2(r, aval, sign2);
  if (fmt.match(/^#+0+$/)) return sign2 + pad0(aval, fmt.length - fmt.indexOf("0"));
  if (r = fmt.match(dec1)) {
    o = ("" + val).replace(/^([^\.]+)$/, "$1." + hashq(r[1])).replace(/\.$/, "." + hashq(r[1]));
    o = o.replace(/\.(\d*)$/, function($$, $1) {
      return "." + $1 + fill("0", hashq(r[1]).length - $1.length);
    });
    return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".");
  }
  fmt = fmt.replace(/^#+([0.])/, "$1");
  if (r = fmt.match(/^(0*)\.(#*)$/)) {
    return sign2 + ("" + aval).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".");
  }
  if (r = fmt.match(/^#{1,3},##0(\.?)$/)) return sign2 + commaify("" + aval);
  if (r = fmt.match(/^#,##0\.([#0]*0)$/)) {
    return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val) + "." + fill("0", r[1].length);
  }
  if (r = fmt.match(/^#,#*,#0/)) return write_num_int(type, fmt.replace(/^#,#*,/, ""), val);
  if (r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
    o = _strrev(write_num_int(type, fmt.replace(/[\\-]/g, ""), val));
    ri = 0;
    return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x2) {
      return ri < o.length ? o.charAt(ri++) : x2 === "0" ? "0" : "";
    }));
  }
  if (fmt.match(phone)) {
    o = write_num_int(type, "##########", val);
    return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
  }
  var oa = "";
  if (r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri = Math.min(
      /*::String(*/
      r[4].length,
      7
    );
    ff = SSF_frac(aval, Math.pow(10, ri) - 1, false);
    o = "" + sign2;
    oa = write_num(
      "n",
      /*::String(*/
      r[1],
      ff[1]
    );
    if (oa.charAt(oa.length - 1) == " ") oa = oa.substr(0, oa.length - 1) + "0";
    o += oa + /*::String(*/
    r[2] + "/" + /*::String(*/
    r[3];
    oa = rpad_(ff[2], ri);
    if (oa.length < r[4].length) oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
    o += oa;
    return o;
  }
  if (r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri = Math.min(Math.max(r[1].length, r[4].length), 7);
    ff = SSF_frac(aval, Math.pow(10, ri) - 1, true);
    return sign2 + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r[2].length + r[3].length));
  }
  if (r = fmt.match(/^[#0?]+$/)) {
    o = "" + val;
    if (fmt.length <= o.length) return o;
    return hashq(fmt.substr(0, fmt.length - o.length)) + o;
  }
  if (r = fmt.match(/^([#0]+)\.([#0]+)$/)) {
    o = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
    ri = o.indexOf(".");
    var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;
    return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres));
  }
  if (r = fmt.match(/^00,000\.([#0]*0)$/)) {
    return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
      return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
    }) + "." + pad0(0, r[1].length);
  }
  switch (fmt) {
    case "###,###":
    case "##,###":
    case "#,###":
      var x = commaify("" + aval);
      return x !== "0" ? sign2 + x : "";
    default:
      if (fmt.match(/\.[0#?]*$/)) return write_num_int(type, fmt.slice(0, fmt.lastIndexOf(".")), val) + hashq(fmt.slice(fmt.lastIndexOf(".")));
  }
  throw new Error("unsupported format |" + fmt + "|");
}
function write_num(type, fmt, val) {
  return (val | 0) === val ? write_num_int(type, fmt, val) : write_num_flt(type, fmt, val);
}
function SSF_split_fmt(fmt) {
  var out = [];
  var in_str = false;
  for (var i = 0, j = 0; i < fmt.length; ++i) switch (
    /*cc=*/
    fmt.charCodeAt(i)
  ) {
    case 34:
      in_str = !in_str;
      break;
    case 95:
    case 42:
    case 92:
      ++i;
      break;
    case 59:
      out[out.length] = fmt.substr(j, i - j);
      j = i + 1;
  }
  out[out.length] = fmt.substr(j);
  if (in_str === true) throw new Error("Format |" + fmt + "| unterminated string ");
  return out;
}
var SSF_abstime = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;
function fmt_is_date(fmt) {
  var i = 0, c2 = "", o = "";
  while (i < fmt.length) {
    switch (c2 = fmt.charAt(i)) {
      case "G":
        if (SSF_isgeneral(fmt, i)) i += 6;
        i++;
        break;
      case '"':
        for (
          ;
          /*cc=*/
          fmt.charCodeAt(++i) !== 34 && i < fmt.length;
        ) {
        }
        ++i;
        break;
      case "\\":
        i += 2;
        break;
      case "_":
        i += 2;
        break;
      case "@":
        ++i;
        break;
      case "B":
      case "b":
        if (fmt.charAt(i + 1) === "1" || fmt.charAt(i + 1) === "2") return true;
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        return true;
      case "A":
      case "a":
      case "":
        if (fmt.substr(i, 3).toUpperCase() === "A/P") return true;
        if (fmt.substr(i, 5).toUpperCase() === "AM/PM") return true;
        if (fmt.substr(i, 5).toUpperCase() === "/") return true;
        ++i;
        break;
      case "[":
        o = c2;
        while (fmt.charAt(i++) !== "]" && i < fmt.length) o += fmt.charAt(i);
        if (o.match(SSF_abstime)) return true;
        break;
      case ".":
      case "0":
      case "#":
        while (i < fmt.length && ("0#?.,E+-%".indexOf(c2 = fmt.charAt(++i)) > -1 || c2 == "\\" && fmt.charAt(i + 1) == "-" && "0#".indexOf(fmt.charAt(i + 2)) > -1)) {
        }
        break;
      case "?":
        while (fmt.charAt(++i) === c2) {
        }
        break;
      case "*":
        ++i;
        if (fmt.charAt(i) == " " || fmt.charAt(i) == "*") ++i;
        break;
      case "(":
      case ")":
        ++i;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        while (i < fmt.length && "0123456789".indexOf(fmt.charAt(++i)) > -1) {
        }
        break;
      case " ":
        ++i;
        break;
      default:
        ++i;
        break;
    }
  }
  return false;
}
function eval_fmt(fmt, v2, opts, flen) {
  var out = [], o = "", i = 0, c2 = "", lst = "t", dt, j, cc;
  var hr = "H";
  while (i < fmt.length) {
    switch (c2 = fmt.charAt(i)) {
      case "G":
        if (!SSF_isgeneral(fmt, i)) throw new Error("unrecognized character " + c2 + " in " + fmt);
        out[out.length] = { t: "G", v: "General" };
        i += 7;
        break;
      case '"':
        for (o = ""; (cc = fmt.charCodeAt(++i)) !== 34 && i < fmt.length; ) o += String.fromCharCode(cc);
        out[out.length] = { t: "t", v: o };
        ++i;
        break;
      case "\\":
        var w = fmt.charAt(++i), t = w === "(" || w === ")" ? w : "t";
        out[out.length] = { t, v: w };
        ++i;
        break;
      case "_":
        out[out.length] = { t: "t", v: " " };
        i += 2;
        break;
      case "@":
        out[out.length] = { t: "T", v: v2 };
        ++i;
        break;
      case "B":
      case "b":
        if (fmt.charAt(i + 1) === "1" || fmt.charAt(i + 1) === "2") {
          if (dt == null) {
            dt = SSF_parse_date_code(v2, opts, fmt.charAt(i + 1) === "2");
            if (dt == null) return "";
          }
          out[out.length] = { t: "X", v: fmt.substr(i, 2) };
          lst = c2;
          i += 2;
          break;
        }
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
        c2 = c2.toLowerCase();
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        if (v2 < 0) return "";
        if (dt == null) {
          dt = SSF_parse_date_code(v2, opts);
          if (dt == null) return "";
        }
        o = c2;
        while (++i < fmt.length && fmt.charAt(i).toLowerCase() === c2) o += c2;
        if (c2 === "m" && lst.toLowerCase() === "h") c2 = "M";
        if (c2 === "h") c2 = hr;
        out[out.length] = { t: c2, v: o };
        lst = c2;
        break;
      case "A":
      case "a":
      case "":
        var q = { t: c2, v: c2 };
        if (dt == null) dt = SSF_parse_date_code(v2, opts);
        if (fmt.substr(i, 3).toUpperCase() === "A/P") {
          if (dt != null) q.v = dt.H >= 12 ? fmt.charAt(i + 2) : c2;
          q.t = "T";
          hr = "h";
          i += 3;
        } else if (fmt.substr(i, 5).toUpperCase() === "AM/PM") {
          if (dt != null) q.v = dt.H >= 12 ? "PM" : "AM";
          q.t = "T";
          i += 5;
          hr = "h";
        } else if (fmt.substr(i, 5).toUpperCase() === "/") {
          if (dt != null) q.v = dt.H >= 12 ? "" : "";
          q.t = "T";
          i += 5;
          hr = "h";
        } else {
          q.t = "t";
          ++i;
        }
        if (dt == null && q.t === "T") return "";
        out[out.length] = q;
        lst = c2;
        break;
      case "[":
        o = c2;
        while (fmt.charAt(i++) !== "]" && i < fmt.length) o += fmt.charAt(i);
        if (o.slice(-1) !== "]") throw 'unterminated "[" block: |' + o + "|";
        if (o.match(SSF_abstime)) {
          if (dt == null) {
            dt = SSF_parse_date_code(v2, opts);
            if (dt == null) return "";
          }
          out[out.length] = { t: "Z", v: o.toLowerCase() };
          lst = o.charAt(1);
        } else if (o.indexOf("$") > -1) {
          o = (o.match(/\$([^-\[\]]*)/) || [])[1] || "$";
          if (!fmt_is_date(fmt)) out[out.length] = { t: "t", v: o };
        }
        break;
      case ".":
        if (dt != null) {
          o = c2;
          while (++i < fmt.length && (c2 = fmt.charAt(i)) === "0") o += c2;
          out[out.length] = { t: "s", v: o };
          break;
        }
      case "0":
      case "#":
        o = c2;
        while (++i < fmt.length && "0#?.,E+-%".indexOf(c2 = fmt.charAt(i)) > -1) o += c2;
        out[out.length] = { t: "n", v: o };
        break;
      case "?":
        o = c2;
        while (fmt.charAt(++i) === c2) o += c2;
        out[out.length] = { t: c2, v: o };
        lst = c2;
        break;
      case "*":
        ++i;
        if (fmt.charAt(i) == " " || fmt.charAt(i) == "*") ++i;
        break;
      case "(":
      case ")":
        out[out.length] = { t: flen === 1 ? "t" : c2, v: c2 };
        ++i;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        o = c2;
        while (i < fmt.length && "0123456789".indexOf(fmt.charAt(++i)) > -1) o += fmt.charAt(i);
        out[out.length] = { t: "D", v: o };
        break;
      case " ":
        out[out.length] = { t: c2, v: c2 };
        ++i;
        break;
      case "$":
        out[out.length] = { t: "t", v: "$" };
        ++i;
        break;
      default:
        if (",$-+/():!^&'~{}<>=acfijklopqrtuvwxzP".indexOf(c2) === -1) throw new Error("unrecognized character " + c2 + " in " + fmt);
        out[out.length] = { t: "t", v: c2 };
        ++i;
        break;
    }
  }
  var bt = 0, ss0 = 0, ssm;
  for (i = out.length - 1, lst = "t"; i >= 0; --i) {
    switch (out[i].t) {
      case "h":
      case "H":
        out[i].t = hr;
        lst = "h";
        if (bt < 1) bt = 1;
        break;
      case "s":
        if (ssm = out[i].v.match(/\.0+$/)) {
          ss0 = Math.max(ss0, ssm[0].length - 1);
          bt = 4;
        }
        if (bt < 3) bt = 3;
      case "d":
      case "y":
      case "e":
        lst = out[i].t;
        break;
      case "M":
        lst = out[i].t;
        if (bt < 2) bt = 2;
        break;
      case "m":
        if (lst === "s") {
          out[i].t = "M";
          if (bt < 2) bt = 2;
        }
        break;
      case "X":
        break;
      case "Z":
        if (bt < 1 && out[i].v.match(/[Hh]/)) bt = 1;
        if (bt < 2 && out[i].v.match(/[Mm]/)) bt = 2;
        if (bt < 3 && out[i].v.match(/[Ss]/)) bt = 3;
    }
  }
  var _dt;
  switch (bt) {
    case 0:
      break;
    case 1:
    case 2:
    case 3:
      if (dt.u >= 0.5) {
        dt.u = 0;
        ++dt.S;
      }
      if (dt.S >= 60) {
        dt.S = 0;
        ++dt.M;
      }
      if (dt.M >= 60) {
        dt.M = 0;
        ++dt.H;
      }
      if (dt.H >= 24) {
        dt.H = 0;
        ++dt.D;
        _dt = SSF_parse_date_code(dt.D);
        _dt.u = dt.u;
        _dt.S = dt.S;
        _dt.M = dt.M;
        _dt.H = dt.H;
        dt = _dt;
      }
      break;
    case 4:
      switch (ss0) {
        case 1:
          dt.u = Math.round(dt.u * 10) / 10;
          break;
        case 2:
          dt.u = Math.round(dt.u * 100) / 100;
          break;
        case 3:
          dt.u = Math.round(dt.u * 1e3) / 1e3;
          break;
      }
      if (dt.u >= 1) {
        dt.u = 0;
        ++dt.S;
      }
      if (dt.S >= 60) {
        dt.S = 0;
        ++dt.M;
      }
      if (dt.M >= 60) {
        dt.M = 0;
        ++dt.H;
      }
      if (dt.H >= 24) {
        dt.H = 0;
        ++dt.D;
        _dt = SSF_parse_date_code(dt.D);
        _dt.u = dt.u;
        _dt.S = dt.S;
        _dt.M = dt.M;
        _dt.H = dt.H;
        dt = _dt;
      }
      break;
  }
  var nstr = "", jj;
  for (i = 0; i < out.length; ++i) {
    switch (out[i].t) {
      case "t":
      case "T":
      case " ":
      case "D":
        break;
      case "X":
        out[i].v = "";
        out[i].t = ";";
        break;
      case "d":
      case "m":
      case "y":
      case "h":
      case "H":
      case "M":
      case "s":
      case "e":
      case "b":
      case "Z":
        out[i].v = SSF_write_date(out[i].t.charCodeAt(0), out[i].v, dt, ss0);
        out[i].t = "t";
        break;
      case "n":
      case "?":
        jj = i + 1;
        while (out[jj] != null && ((c2 = out[jj].t) === "?" || c2 === "D" || (c2 === " " || c2 === "t") && out[jj + 1] != null && (out[jj + 1].t === "?" || out[jj + 1].t === "t" && out[jj + 1].v === "/") || out[i].t === "(" && (c2 === " " || c2 === "n" || c2 === ")") || c2 === "t" && (out[jj].v === "/" || out[jj].v === " " && out[jj + 1] != null && out[jj + 1].t == "?"))) {
          out[i].v += out[jj].v;
          out[jj] = { v: "", t: ";" };
          ++jj;
        }
        nstr += out[i].v;
        i = jj - 1;
        break;
      case "G":
        out[i].t = "t";
        out[i].v = SSF_general(v2, opts);
        break;
    }
  }
  var vv = "", myv, ostr;
  if (nstr.length > 0) {
    if (nstr.charCodeAt(0) == 40) {
      myv = v2 < 0 && nstr.charCodeAt(0) === 45 ? -v2 : v2;
      ostr = write_num("n", nstr, myv);
    } else {
      myv = v2 < 0 && flen > 1 ? -v2 : v2;
      ostr = write_num("n", nstr, myv);
      if (myv < 0 && out[0] && out[0].t == "t") {
        ostr = ostr.substr(1);
        out[0].v = "-" + out[0].v;
      }
    }
    jj = ostr.length - 1;
    var decpt = out.length;
    for (i = 0; i < out.length; ++i) if (out[i] != null && out[i].t != "t" && out[i].v.indexOf(".") > -1) {
      decpt = i;
      break;
    }
    var lasti = out.length;
    if (decpt === out.length && ostr.indexOf("E") === -1) {
      for (i = out.length - 1; i >= 0; --i) {
        if (out[i] == null || "n?".indexOf(out[i].t) === -1) continue;
        if (jj >= out[i].v.length - 1) {
          jj -= out[i].v.length;
          out[i].v = ostr.substr(jj + 1, out[i].v.length);
        } else if (jj < 0) out[i].v = "";
        else {
          out[i].v = ostr.substr(0, jj + 1);
          jj = -1;
        }
        out[i].t = "t";
        lasti = i;
      }
      if (jj >= 0 && lasti < out.length) out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
    } else if (decpt !== out.length && ostr.indexOf("E") === -1) {
      jj = ostr.indexOf(".") - 1;
      for (i = decpt; i >= 0; --i) {
        if (out[i] == null || "n?".indexOf(out[i].t) === -1) continue;
        j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") - 1 : out[i].v.length - 1;
        vv = out[i].v.substr(j + 1);
        for (; j >= 0; --j) {
          if (jj >= 0 && (out[i].v.charAt(j) === "0" || out[i].v.charAt(j) === "#")) vv = ostr.charAt(jj--) + vv;
        }
        out[i].v = vv;
        out[i].t = "t";
        lasti = i;
      }
      if (jj >= 0 && lasti < out.length) out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
      jj = ostr.indexOf(".") + 1;
      for (i = decpt; i < out.length; ++i) {
        if (out[i] == null || "n?(".indexOf(out[i].t) === -1 && i !== decpt) continue;
        j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") + 1 : 0;
        vv = out[i].v.substr(0, j);
        for (; j < out[i].v.length; ++j) {
          if (jj < ostr.length) vv += ostr.charAt(jj++);
        }
        out[i].v = vv;
        out[i].t = "t";
        lasti = i;
      }
    }
  }
  for (i = 0; i < out.length; ++i) if (out[i] != null && "n?".indexOf(out[i].t) > -1) {
    myv = flen > 1 && v2 < 0 && i > 0 && out[i - 1].v === "-" ? -v2 : v2;
    out[i].v = write_num(out[i].t, out[i].v, myv);
    out[i].t = "t";
  }
  var retval = "";
  for (i = 0; i !== out.length; ++i) if (out[i] != null) retval += out[i].v;
  return retval;
}
var cfregex2 = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
function chkcond(v2, rr) {
  if (rr == null) return false;
  var thresh = parseFloat(rr[2]);
  switch (rr[1]) {
    case "=":
      if (v2 == thresh) return true;
      break;
    case ">":
      if (v2 > thresh) return true;
      break;
    case "<":
      if (v2 < thresh) return true;
      break;
    case "<>":
      if (v2 != thresh) return true;
      break;
    case ">=":
      if (v2 >= thresh) return true;
      break;
    case "<=":
      if (v2 <= thresh) return true;
      break;
  }
  return false;
}
function choose_fmt(f, v2) {
  var fmt = SSF_split_fmt(f);
  var l2 = fmt.length, lat = fmt[l2 - 1].indexOf("@");
  if (l2 < 4 && lat > -1) --l2;
  if (fmt.length > 4) throw new Error("cannot find right format for |" + fmt.join("|") + "|");
  if (typeof v2 !== "number") return [4, fmt.length === 4 || lat > -1 ? fmt[fmt.length - 1] : "@"];
  switch (fmt.length) {
    case 1:
      fmt = lat > -1 ? ["General", "General", "General", fmt[0]] : [fmt[0], fmt[0], fmt[0], "@"];
      break;
    case 2:
      fmt = lat > -1 ? [fmt[0], fmt[0], fmt[0], fmt[1]] : [fmt[0], fmt[1], fmt[0], "@"];
      break;
    case 3:
      fmt = lat > -1 ? [fmt[0], fmt[1], fmt[0], fmt[2]] : [fmt[0], fmt[1], fmt[2], "@"];
      break;
  }
  var ff = v2 > 0 ? fmt[0] : v2 < 0 ? fmt[1] : fmt[2];
  if (fmt[0].indexOf("[") === -1 && fmt[1].indexOf("[") === -1) return [l2, ff];
  if (fmt[0].match(/\[[=<>]/) != null || fmt[1].match(/\[[=<>]/) != null) {
    var m1 = fmt[0].match(cfregex2);
    var m2 = fmt[1].match(cfregex2);
    return chkcond(v2, m1) ? [l2, fmt[0]] : chkcond(v2, m2) ? [l2, fmt[1]] : [l2, fmt[m1 != null && m2 != null ? 2 : 1]];
  }
  return [l2, ff];
}
function SSF_format(fmt, v2, o) {
  if (o == null) o = {};
  var sfmt = "";
  switch (typeof fmt) {
    case "string":
      if (fmt == "m/d/yy" && o.dateNF) sfmt = o.dateNF;
      else sfmt = fmt;
      break;
    case "number":
      if (fmt == 14 && o.dateNF) sfmt = o.dateNF;
      else sfmt = (o.table != null ? o.table : table_fmt)[fmt];
      if (sfmt == null) sfmt = o.table && o.table[SSF_default_map[fmt]] || table_fmt[SSF_default_map[fmt]];
      if (sfmt == null) sfmt = SSF_default_str[fmt] || "General";
      break;
  }
  if (SSF_isgeneral(sfmt, 0)) return SSF_general(v2, o);
  if (v2 instanceof Date) v2 = datenum(v2, o.date1904);
  var f = choose_fmt(sfmt, v2);
  if (SSF_isgeneral(f[1])) return SSF_general(v2, o);
  if (v2 === true) v2 = "TRUE";
  else if (v2 === false) v2 = "FALSE";
  else if (v2 === "" || v2 == null) return "";
  return eval_fmt(f[1], v2, o, f[0]);
}
function SSF_load(fmt, idx) {
  if (typeof idx != "number") {
    idx = +idx || -1;
    for (var i = 0; i < 392; ++i) {
      if (table_fmt[i] == void 0) {
        if (idx < 0) idx = i;
        continue;
      }
      if (table_fmt[i] == fmt) {
        idx = i;
        break;
      }
    }
    if (idx < 0) idx = 391;
  }
  table_fmt[idx] = fmt;
  return idx;
}
function make_ssf() {
  table_fmt = SSF_init_table();
}
var SSFImplicit = {
  "5": '"$"#,##0_);\\("$"#,##0\\)',
  "6": '"$"#,##0_);[Red]\\("$"#,##0\\)',
  "7": '"$"#,##0.00_);\\("$"#,##0.00\\)',
  "8": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  "23": "General",
  "24": "General",
  "25": "General",
  "26": "General",
  "27": "m/d/yy",
  "28": "m/d/yy",
  "29": "m/d/yy",
  "30": "m/d/yy",
  "31": "m/d/yy",
  "32": "h:mm:ss",
  "33": "h:mm:ss",
  "34": "h:mm:ss",
  "35": "h:mm:ss",
  "36": "m/d/yy",
  "41": '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)',
  "42": '_("$"* #,##0_);_("$"* (#,##0);_("$"* "-"_);_(@_)',
  "43": '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)',
  "44": '_("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)',
  "50": "m/d/yy",
  "51": "m/d/yy",
  "52": "m/d/yy",
  "53": "m/d/yy",
  "54": "m/d/yy",
  "55": "m/d/yy",
  "56": "m/d/yy",
  "57": "m/d/yy",
  "58": "m/d/yy",
  "59": "0",
  "60": "0.00",
  "61": "#,##0",
  "62": "#,##0.00",
  "63": '"$"#,##0_);\\("$"#,##0\\)',
  "64": '"$"#,##0_);[Red]\\("$"#,##0\\)',
  "65": '"$"#,##0.00_);\\("$"#,##0.00\\)',
  "66": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  "67": "0%",
  "68": "0.00%",
  "69": "# ?/?",
  "70": "# ??/??",
  "71": "m/d/yy",
  "72": "m/d/yy",
  "73": "d-mmm-yy",
  "74": "d-mmm",
  "75": "mmm-yy",
  "76": "h:mm",
  "77": "h:mm:ss",
  "78": "m/d/yy h:mm",
  "79": "mm:ss",
  "80": "[h]:mm:ss",
  "81": "mmss.0"
};
var dateNFregex = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;
function dateNF_regex(dateNF) {
  var fmt = typeof dateNF == "number" ? table_fmt[dateNF] : dateNF;
  fmt = fmt.replace(dateNFregex, "(\\d+)");
  dateNFregex.lastIndex = 0;
  return new RegExp("^" + fmt + "$");
}
function dateNF_fix(str, dateNF, match) {
  var Y2 = -1, m = -1, d = -1, H2 = -1, M = -1, S2 = -1;
  (dateNF.match(dateNFregex) || []).forEach(function(n, i) {
    var v2 = parseInt(match[i + 1], 10);
    switch (n.toLowerCase().charAt(0)) {
      case "y":
        Y2 = v2;
        break;
      case "d":
        d = v2;
        break;
      case "h":
        H2 = v2;
        break;
      case "s":
        S2 = v2;
        break;
      case "m":
        if (H2 >= 0) M = v2;
        else m = v2;
        break;
    }
  });
  dateNFregex.lastIndex = 0;
  if (S2 >= 0 && M == -1 && m >= 0) {
    M = m;
    m = -1;
  }
  var datestr = ("" + (Y2 >= 0 ? Y2 : (/* @__PURE__ */ new Date()).getFullYear())).slice(-4) + "-" + ("00" + (m >= 1 ? m : 1)).slice(-2) + "-" + ("00" + (d >= 1 ? d : 1)).slice(-2);
  if (datestr.length == 7) datestr = "0" + datestr;
  if (datestr.length == 8) datestr = "20" + datestr;
  var timestr = ("00" + (H2 >= 0 ? H2 : 0)).slice(-2) + ":" + ("00" + (M >= 0 ? M : 0)).slice(-2) + ":" + ("00" + (S2 >= 0 ? S2 : 0)).slice(-2);
  if (H2 == -1 && M == -1 && S2 == -1) return datestr;
  if (Y2 == -1 && m == -1 && d == -1) return timestr;
  return datestr + "T" + timestr;
}
var bad_formats = {
  "d.m": "d\\.m"
  // Issue #2571 Google Sheets writes invalid format 'd.m', correct format is 'd"."m' or 'd\\.m'
};
function SSF__load(fmt, idx) {
  return SSF_load(bad_formats[fmt] || fmt, idx);
}
var CRC32 = /* @__PURE__ */ function() {
  var CRC322 = {};
  CRC322.version = "1.2.0";
  function signed_crc_table() {
    var c2 = 0, table = new Array(256);
    for (var n = 0; n != 256; ++n) {
      c2 = n;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      table[n] = c2;
    }
    return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
  }
  var T0 = signed_crc_table();
  function slice_by_16_tables(T) {
    var c2 = 0, v2 = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
    for (n = 0; n != 256; ++n) table[n] = T[n];
    for (n = 0; n != 256; ++n) {
      v2 = T[n];
      for (c2 = 256 + n; c2 < 4096; c2 += 256) v2 = table[c2] = v2 >>> 8 ^ T[v2 & 255];
    }
    var out = [];
    for (n = 1; n != 16; ++n) out[n - 1] = typeof Int32Array !== "undefined" && typeof table.subarray == "function" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
    return out;
  }
  var TT = slice_by_16_tables(T0);
  var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
  var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
  var Tb = TT[10], Tc = TT[11], Td = TT[12], Te2 = TT[13], Tf = TT[14];
  function crc32_bstr(bstr, seed) {
    var C2 = seed ^ -1;
    for (var i = 0, L = bstr.length; i < L; ) C2 = C2 >>> 8 ^ T0[(C2 ^ bstr.charCodeAt(i++)) & 255];
    return ~C2;
  }
  function crc32_buf(B, seed) {
    var C2 = seed ^ -1, L = B.length - 15, i = 0;
    for (; i < L; ) C2 = Tf[B[i++] ^ C2 & 255] ^ Te2[B[i++] ^ C2 >> 8 & 255] ^ Td[B[i++] ^ C2 >> 16 & 255] ^ Tc[B[i++] ^ C2 >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
    L += 15;
    while (i < L) C2 = C2 >>> 8 ^ T0[(C2 ^ B[i++]) & 255];
    return ~C2;
  }
  function crc32_str(str, seed) {
    var C2 = seed ^ -1;
    for (var i = 0, L = str.length, c2 = 0, d = 0; i < L; ) {
      c2 = str.charCodeAt(i++);
      if (c2 < 128) {
        C2 = C2 >>> 8 ^ T0[(C2 ^ c2) & 255];
      } else if (c2 < 2048) {
        C2 = C2 >>> 8 ^ T0[(C2 ^ (192 | c2 >> 6 & 31)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | c2 & 63)) & 255];
      } else if (c2 >= 55296 && c2 < 57344) {
        c2 = (c2 & 1023) + 64;
        d = str.charCodeAt(i++) & 1023;
        C2 = C2 >>> 8 ^ T0[(C2 ^ (240 | c2 >> 8 & 7)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | c2 >> 2 & 63)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | d >> 6 & 15 | (c2 & 3) << 4)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | d & 63)) & 255];
      } else {
        C2 = C2 >>> 8 ^ T0[(C2 ^ (224 | c2 >> 12 & 15)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | c2 >> 6 & 63)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | c2 & 63)) & 255];
      }
    }
    return ~C2;
  }
  CRC322.table = T0;
  CRC322.bstr = crc32_bstr;
  CRC322.buf = crc32_buf;
  CRC322.str = crc32_str;
  return CRC322;
}();
var CFB = /* @__PURE__ */ function _CFB() {
  var exports = (
    /*::(*/
    {}
  );
  exports.version = "1.2.2";
  function namecmp(l2, r) {
    var L = l2.split("/"), R = r.split("/");
    for (var i2 = 0, c2 = 0, Z2 = Math.min(L.length, R.length); i2 < Z2; ++i2) {
      if (c2 = L[i2].length - R[i2].length) return c2;
      if (L[i2] != R[i2]) return L[i2] < R[i2] ? -1 : 1;
    }
    return L.length - R.length;
  }
  function dirname(p) {
    if (p.charAt(p.length - 1) == "/") return p.slice(0, -1).indexOf("/") === -1 ? p : dirname(p.slice(0, -1));
    var c2 = p.lastIndexOf("/");
    return c2 === -1 ? p : p.slice(0, c2 + 1);
  }
  function filename(p) {
    if (p.charAt(p.length - 1) == "/") return filename(p.slice(0, -1));
    var c2 = p.lastIndexOf("/");
    return c2 === -1 ? p : p.slice(c2 + 1);
  }
  function write_dos_date(buf, date) {
    if (typeof date === "string") date = new Date(date);
    var hms = date.getHours();
    hms = hms << 6 | date.getMinutes();
    hms = hms << 5 | date.getSeconds() >>> 1;
    buf.write_shift(2, hms);
    var ymd = date.getFullYear() - 1980;
    ymd = ymd << 4 | date.getMonth() + 1;
    ymd = ymd << 5 | date.getDate();
    buf.write_shift(2, ymd);
  }
  function parse_dos_date(buf) {
    var hms = buf.read_shift(2) & 65535;
    var ymd = buf.read_shift(2) & 65535;
    var val = /* @__PURE__ */ new Date();
    var d = ymd & 31;
    ymd >>>= 5;
    var m = ymd & 15;
    ymd >>>= 4;
    val.setMilliseconds(0);
    val.setFullYear(ymd + 1980);
    val.setMonth(m - 1);
    val.setDate(d);
    var S2 = hms & 31;
    hms >>>= 5;
    var M = hms & 63;
    hms >>>= 6;
    val.setHours(hms);
    val.setMinutes(M);
    val.setSeconds(S2 << 1);
    return val;
  }
  function parse_extra_field(blob) {
    prep_blob(blob, 0);
    var o = (
      /*::(*/
      {}
    );
    var flags = 0;
    while (blob.l <= blob.length - 4) {
      var type = blob.read_shift(2);
      var sz = blob.read_shift(2), tgt = blob.l + sz;
      var p = {};
      switch (type) {
        case 21589:
          {
            flags = blob.read_shift(1);
            if (flags & 1) p.mtime = blob.read_shift(4);
            if (sz > 5) {
              if (flags & 2) p.atime = blob.read_shift(4);
              if (flags & 4) p.ctime = blob.read_shift(4);
            }
            if (p.mtime) p.mt = new Date(p.mtime * 1e3);
          }
          break;
        case 1:
          {
            var sz1 = blob.read_shift(4), sz2 = blob.read_shift(4);
            p.usz = sz2 * Math.pow(2, 32) + sz1;
            sz1 = blob.read_shift(4);
            sz2 = blob.read_shift(4);
            p.csz = sz2 * Math.pow(2, 32) + sz1;
          }
          break;
      }
      blob.l = tgt;
      o[type] = p;
    }
    return o;
  }
  var fs;
  function get_fs() {
    return fs || (fs = _fs);
  }
  function parse3(file, options) {
    if (file[0] == 80 && file[1] == 75) return parse_zip2(file, options);
    if ((file[0] | 32) == 109 && (file[1] | 32) == 105) return parse_mad(file, options);
    if (file.length < 512) throw new Error("CFB file size " + file.length + " < 512");
    var mver = 3;
    var ssz = 512;
    var nmfs = 0;
    var difat_sec_cnt = 0;
    var dir_start = 0;
    var minifat_start = 0;
    var difat_start = 0;
    var fat_addrs = [];
    var blob = (
      /*::(*/
      file.slice(0, 512)
    );
    prep_blob(blob, 0);
    var mv = check_get_mver(blob);
    mver = mv[0];
    switch (mver) {
      case 3:
        ssz = 512;
        break;
      case 4:
        ssz = 4096;
        break;
      case 0:
        if (mv[1] == 0) return parse_zip2(file, options);
      default:
        throw new Error("Major Version: Expected 3 or 4 saw " + mver);
    }
    if (ssz !== 512) {
      blob = /*::(*/
      file.slice(0, ssz);
      prep_blob(
        blob,
        28
        /* blob.l */
      );
    }
    var header = file.slice(0, ssz);
    check_shifts(blob, mver);
    var dir_cnt = blob.read_shift(4, "i");
    if (mver === 3 && dir_cnt !== 0) throw new Error("# Directory Sectors: Expected 0 saw " + dir_cnt);
    blob.l += 4;
    dir_start = blob.read_shift(4, "i");
    blob.l += 4;
    blob.chk("00100000", "Mini Stream Cutoff Size: ");
    minifat_start = blob.read_shift(4, "i");
    nmfs = blob.read_shift(4, "i");
    difat_start = blob.read_shift(4, "i");
    difat_sec_cnt = blob.read_shift(4, "i");
    for (var q2 = -1, j = 0; j < 109; ++j) {
      q2 = blob.read_shift(4, "i");
      if (q2 < 0) break;
      fat_addrs[j] = q2;
    }
    var sectors = sectorify(file, ssz);
    sleuth_fat(difat_start, difat_sec_cnt, sectors, ssz, fat_addrs);
    var sector_list = make_sector_list(sectors, dir_start, fat_addrs, ssz);
    if (dir_start < sector_list.length) sector_list[dir_start].name = "!Directory";
    if (nmfs > 0 && minifat_start !== ENDOFCHAIN) sector_list[minifat_start].name = "!MiniFAT";
    sector_list[fat_addrs[0]].name = "!FAT";
    sector_list.fat_addrs = fat_addrs;
    sector_list.ssz = ssz;
    var files = {}, Paths = [], FileIndex = [], FullPaths = [];
    read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, minifat_start);
    build_full_paths(FileIndex, FullPaths, Paths);
    Paths.shift();
    var o = {
      FileIndex,
      FullPaths
    };
    if (options && options.raw) o.raw = { header, sectors };
    return o;
  }
  function check_get_mver(blob) {
    if (blob[blob.l] == 80 && blob[blob.l + 1] == 75) return [0, 0];
    blob.chk(HEADER_SIGNATURE, "Header Signature: ");
    blob.l += 16;
    var mver = blob.read_shift(2, "u");
    return [blob.read_shift(2, "u"), mver];
  }
  function check_shifts(blob, mver) {
    var shift = 9;
    blob.l += 2;
    switch (shift = blob.read_shift(2)) {
      case 9:
        if (mver != 3) throw new Error("Sector Shift: Expected 9 saw " + shift);
        break;
      case 12:
        if (mver != 4) throw new Error("Sector Shift: Expected 12 saw " + shift);
        break;
      default:
        throw new Error("Sector Shift: Expected 9 or 12 saw " + shift);
    }
    blob.chk("0600", "Mini Sector Shift: ");
    blob.chk("000000000000", "Reserved: ");
  }
  function sectorify(file, ssz) {
    var nsectors = Math.ceil(file.length / ssz) - 1;
    var sectors = [];
    for (var i2 = 1; i2 < nsectors; ++i2) sectors[i2 - 1] = file.slice(i2 * ssz, (i2 + 1) * ssz);
    sectors[nsectors - 1] = file.slice(nsectors * ssz);
    return sectors;
  }
  function build_full_paths(FI, FP, Paths) {
    var i2 = 0, L = 0, R = 0, C2 = 0, j = 0, pl = Paths.length;
    var dad = [], q2 = [];
    for (; i2 < pl; ++i2) {
      dad[i2] = q2[i2] = i2;
      FP[i2] = Paths[i2];
    }
    for (; j < q2.length; ++j) {
      i2 = q2[j];
      L = FI[i2].L;
      R = FI[i2].R;
      C2 = FI[i2].C;
      if (dad[i2] === i2) {
        if (L !== -1 && dad[L] !== L) dad[i2] = dad[L];
        if (R !== -1 && dad[R] !== R) dad[i2] = dad[R];
      }
      if (C2 !== -1) dad[C2] = i2;
      if (L !== -1 && i2 != dad[i2]) {
        dad[L] = dad[i2];
        if (q2.lastIndexOf(L) < j) q2.push(L);
      }
      if (R !== -1 && i2 != dad[i2]) {
        dad[R] = dad[i2];
        if (q2.lastIndexOf(R) < j) q2.push(R);
      }
    }
    for (i2 = 1; i2 < pl; ++i2) if (dad[i2] === i2) {
      if (R !== -1 && dad[R] !== R) dad[i2] = dad[R];
      else if (L !== -1 && dad[L] !== L) dad[i2] = dad[L];
    }
    for (i2 = 1; i2 < pl; ++i2) {
      if (FI[i2].type === 0) continue;
      j = i2;
      if (j != dad[j]) do {
        j = dad[j];
        FP[i2] = FP[j] + "/" + FP[i2];
      } while (j !== 0 && -1 !== dad[j] && j != dad[j]);
      dad[i2] = -1;
    }
    FP[0] += "/";
    for (i2 = 1; i2 < pl; ++i2) {
      if (FI[i2].type !== 2) FP[i2] += "/";
    }
  }
  function get_mfat_entry(entry, payload, mini) {
    var start = entry.start, size = entry.size;
    var o = [];
    var idx = start;
    while (mini && size > 0 && idx >= 0) {
      o.push(payload.slice(idx * MSSZ, idx * MSSZ + MSSZ));
      size -= MSSZ;
      idx = __readInt32LE(mini, idx * 4);
    }
    if (o.length === 0) return new_buf(0);
    return bconcat(o).slice(0, entry.size);
  }
  function sleuth_fat(idx, cnt, sectors, ssz, fat_addrs) {
    var q2 = ENDOFCHAIN;
    if (idx === ENDOFCHAIN) {
      if (cnt !== 0) throw new Error("DIFAT chain shorter than expected");
    } else if (idx !== -1) {
      var sector = sectors[idx], m = (ssz >>> 2) - 1;
      if (!sector) return;
      for (var i2 = 0; i2 < m; ++i2) {
        if ((q2 = __readInt32LE(sector, i2 * 4)) === ENDOFCHAIN) break;
        fat_addrs.push(q2);
      }
      if (cnt >= 1) sleuth_fat(__readInt32LE(sector, ssz - 4), cnt - 1, sectors, ssz, fat_addrs);
    }
  }
  function get_sector_list(sectors, start, fat_addrs, ssz, chkd) {
    var buf = [], buf_chain = [];
    if (!chkd) chkd = [];
    var modulus = ssz - 1, j = 0, jj = 0;
    for (j = start; j >= 0; ) {
      chkd[j] = true;
      buf[buf.length] = j;
      buf_chain.push(sectors[j]);
      var addr = fat_addrs[Math.floor(j * 4 / ssz)];
      jj = j * 4 & modulus;
      if (ssz < 4 + jj) throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
      if (!sectors[addr]) break;
      j = __readInt32LE(sectors[addr], jj);
    }
    return { nodes: buf, data: __toBuffer([buf_chain]) };
  }
  function make_sector_list(sectors, dir_start, fat_addrs, ssz) {
    var sl = sectors.length, sector_list = [];
    var chkd = [], buf = [], buf_chain = [];
    var modulus = ssz - 1, i2 = 0, j = 0, k2 = 0, jj = 0;
    for (i2 = 0; i2 < sl; ++i2) {
      buf = [];
      k2 = i2 + dir_start;
      if (k2 >= sl) k2 -= sl;
      if (chkd[k2]) continue;
      buf_chain = [];
      var seen2 = [];
      for (j = k2; j >= 0; ) {
        seen2[j] = true;
        chkd[j] = true;
        buf[buf.length] = j;
        buf_chain.push(sectors[j]);
        var addr = fat_addrs[Math.floor(j * 4 / ssz)];
        jj = j * 4 & modulus;
        if (ssz < 4 + jj) throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
        if (!sectors[addr]) break;
        j = __readInt32LE(sectors[addr], jj);
        if (seen2[j]) break;
      }
      sector_list[k2] = { nodes: buf, data: __toBuffer([buf_chain]) };
    }
    return sector_list;
  }
  function read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, mini) {
    var minifat_store = 0, pl = Paths.length ? 2 : 0;
    var sector = sector_list[dir_start].data;
    var i2 = 0, namelen = 0, name;
    for (; i2 < sector.length; i2 += 128) {
      var blob = (
        /*::(*/
        sector.slice(i2, i2 + 128)
      );
      prep_blob(blob, 64);
      namelen = blob.read_shift(2);
      name = __utf16le(blob, 0, namelen - pl);
      Paths.push(name);
      var o = {
        name,
        type: blob.read_shift(1),
        color: blob.read_shift(1),
        L: blob.read_shift(4, "i"),
        R: blob.read_shift(4, "i"),
        C: blob.read_shift(4, "i"),
        clsid: blob.read_shift(16),
        state: blob.read_shift(4, "i"),
        start: 0,
        size: 0
      };
      var ctime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
      if (ctime !== 0) o.ct = read_date(blob, blob.l - 8);
      var mtime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
      if (mtime !== 0) o.mt = read_date(blob, blob.l - 8);
      o.start = blob.read_shift(4, "i");
      o.size = blob.read_shift(4, "i");
      if (o.size < 0 && o.start < 0) {
        o.size = o.type = 0;
        o.start = ENDOFCHAIN;
        o.name = "";
      }
      if (o.type === 5) {
        minifat_store = o.start;
        if (nmfs > 0 && minifat_store !== ENDOFCHAIN) sector_list[minifat_store].name = "!StreamData";
      } else if (o.size >= 4096) {
        o.storage = "fat";
        if (sector_list[o.start] === void 0) sector_list[o.start] = get_sector_list(sectors, o.start, sector_list.fat_addrs, sector_list.ssz);
        sector_list[o.start].name = o.name;
        o.content = sector_list[o.start].data.slice(0, o.size);
      } else {
        o.storage = "minifat";
        if (o.size < 0) o.size = 0;
        else if (minifat_store !== ENDOFCHAIN && o.start !== ENDOFCHAIN && sector_list[minifat_store]) {
          o.content = get_mfat_entry(o, sector_list[minifat_store].data, (sector_list[mini] || {}).data);
        }
      }
      if (o.content) prep_blob(o.content, 0);
      files[name] = o;
      FileIndex.push(o);
    }
  }
  function read_date(blob, offset) {
    return new Date((__readUInt32LE(blob, offset + 4) / 1e7 * Math.pow(2, 32) + __readUInt32LE(blob, offset) / 1e7 - 11644473600) * 1e3);
  }
  function read_file(filename2, options) {
    get_fs();
    return parse3(fs.readFileSync(filename2), options);
  }
  function read2(blob, options) {
    var type = options && options.type;
    if (!type) {
      if (has_buf && Buffer.isBuffer(blob)) type = "buffer";
    }
    switch (type || "base64") {
      case "file":
        return read_file(blob, options);
      case "base64":
        return parse3(s2a(Base64_decode(blob)), options);
      case "binary":
        return parse3(s2a(blob), options);
    }
    return parse3(
      /*::typeof blob == 'string' ? new Buffer(blob, 'utf-8') : */
      blob,
      options
    );
  }
  function init_cfb(cfb, opts) {
    var o = opts || {}, root2 = o.root || "Root Entry";
    if (!cfb.FullPaths) cfb.FullPaths = [];
    if (!cfb.FileIndex) cfb.FileIndex = [];
    if (cfb.FullPaths.length !== cfb.FileIndex.length) throw new Error("inconsistent CFB structure");
    if (cfb.FullPaths.length === 0) {
      cfb.FullPaths[0] = root2 + "/";
      cfb.FileIndex[0] = { name: root2, type: 5 };
    }
    if (o.CLSID) cfb.FileIndex[0].clsid = o.CLSID;
    seed_cfb(cfb);
  }
  function seed_cfb(cfb) {
    var nm = "Sh33tJ5";
    if (CFB.find(cfb, "/" + nm)) return;
    var p = new_buf(4);
    p[0] = 55;
    p[1] = p[3] = 50;
    p[2] = 54;
    cfb.FileIndex.push({ name: nm, type: 2, content: p, size: 4, L: 69, R: 69, C: 69 });
    cfb.FullPaths.push(cfb.FullPaths[0] + nm);
    rebuild_cfb(cfb);
  }
  function rebuild_cfb(cfb, f) {
    init_cfb(cfb);
    var gc = false, s = false;
    for (var i2 = cfb.FullPaths.length - 1; i2 >= 0; --i2) {
      var _file = cfb.FileIndex[i2];
      switch (_file.type) {
        case 0:
          if (s) gc = true;
          else {
            cfb.FileIndex.pop();
            cfb.FullPaths.pop();
          }
          break;
        case 1:
        case 2:
        case 5:
          s = true;
          if (isNaN(_file.R * _file.L * _file.C)) gc = true;
          if (_file.R > -1 && _file.L > -1 && _file.R == _file.L) gc = true;
          break;
        default:
          gc = true;
          break;
      }
    }
    if (!gc && !f) return;
    var now = new Date(1987, 1, 19), j = 0;
    var fullPaths = Object.create ? /* @__PURE__ */ Object.create(null) : {};
    var data = [];
    for (i2 = 0; i2 < cfb.FullPaths.length; ++i2) {
      fullPaths[cfb.FullPaths[i2]] = true;
      if (cfb.FileIndex[i2].type === 0) continue;
      data.push([cfb.FullPaths[i2], cfb.FileIndex[i2]]);
    }
    for (i2 = 0; i2 < data.length; ++i2) {
      var dad = dirname(data[i2][0]);
      s = fullPaths[dad];
      while (!s) {
        while (dirname(dad) && !fullPaths[dirname(dad)]) dad = dirname(dad);
        data.push([dad, {
          name: filename(dad).replace("/", ""),
          type: 1,
          clsid: HEADER_CLSID,
          ct: now,
          mt: now,
          content: null
        }]);
        fullPaths[dad] = true;
        dad = dirname(data[i2][0]);
        s = fullPaths[dad];
      }
    }
    data.sort(function(x, y) {
      return namecmp(x[0], y[0]);
    });
    cfb.FullPaths = [];
    cfb.FileIndex = [];
    for (i2 = 0; i2 < data.length; ++i2) {
      cfb.FullPaths[i2] = data[i2][0];
      cfb.FileIndex[i2] = data[i2][1];
    }
    for (i2 = 0; i2 < data.length; ++i2) {
      var elt = cfb.FileIndex[i2];
      var nm = cfb.FullPaths[i2];
      elt.name = filename(nm).replace("/", "");
      elt.L = elt.R = elt.C = -(elt.color = 1);
      elt.size = elt.content ? elt.content.length : 0;
      elt.start = 0;
      elt.clsid = elt.clsid || HEADER_CLSID;
      if (i2 === 0) {
        elt.C = data.length > 1 ? 1 : -1;
        elt.size = 0;
        elt.type = 5;
      } else if (nm.slice(-1) == "/") {
        for (j = i2 + 1; j < data.length; ++j) if (dirname(cfb.FullPaths[j]) == nm) break;
        elt.C = j >= data.length ? -1 : j;
        for (j = i2 + 1; j < data.length; ++j) if (dirname(cfb.FullPaths[j]) == dirname(nm)) break;
        elt.R = j >= data.length ? -1 : j;
        elt.type = 1;
      } else {
        if (dirname(cfb.FullPaths[i2 + 1] || "") == dirname(nm)) elt.R = i2 + 1;
        elt.type = 2;
      }
    }
  }
  function _write(cfb, options) {
    var _opts = options || {};
    if (_opts.fileType == "mad") return write_mad(cfb, _opts);
    rebuild_cfb(cfb);
    switch (_opts.fileType) {
      case "zip":
        return write_zip(cfb, _opts);
    }
    var L = function(cfb2) {
      var mini_size = 0, fat_size = 0;
      for (var i3 = 0; i3 < cfb2.FileIndex.length; ++i3) {
        var file2 = cfb2.FileIndex[i3];
        if (!file2.content) continue;
        var flen2 = file2.content.length;
        if (flen2 > 0) {
          if (flen2 < 4096) mini_size += flen2 + 63 >> 6;
          else fat_size += flen2 + 511 >> 9;
        }
      }
      var dir_cnt = cfb2.FullPaths.length + 3 >> 2;
      var mini_cnt = mini_size + 7 >> 3;
      var mfat_cnt = mini_size + 127 >> 7;
      var fat_base = mini_cnt + fat_size + dir_cnt + mfat_cnt;
      var fat_cnt = fat_base + 127 >> 7;
      var difat_cnt = fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
      while (fat_base + fat_cnt + difat_cnt + 127 >> 7 > fat_cnt) difat_cnt = ++fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
      var L2 = [1, difat_cnt, fat_cnt, mfat_cnt, dir_cnt, fat_size, mini_size, 0];
      cfb2.FileIndex[0].size = mini_size << 6;
      L2[7] = (cfb2.FileIndex[0].start = L2[0] + L2[1] + L2[2] + L2[3] + L2[4] + L2[5]) + (L2[6] + 7 >> 3);
      return L2;
    }(cfb);
    var o = new_buf(L[7] << 9);
    var i2 = 0, T = 0;
    {
      for (i2 = 0; i2 < 8; ++i2) o.write_shift(1, HEADER_SIG[i2]);
      for (i2 = 0; i2 < 8; ++i2) o.write_shift(2, 0);
      o.write_shift(2, 62);
      o.write_shift(2, 3);
      o.write_shift(2, 65534);
      o.write_shift(2, 9);
      o.write_shift(2, 6);
      for (i2 = 0; i2 < 3; ++i2) o.write_shift(2, 0);
      o.write_shift(4, 0);
      o.write_shift(4, L[2]);
      o.write_shift(4, L[0] + L[1] + L[2] + L[3] - 1);
      o.write_shift(4, 0);
      o.write_shift(4, 1 << 12);
      o.write_shift(4, L[3] ? L[0] + L[1] + L[2] - 1 : ENDOFCHAIN);
      o.write_shift(4, L[3]);
      o.write_shift(-4, L[1] ? L[0] - 1 : ENDOFCHAIN);
      o.write_shift(4, L[1]);
      for (i2 = 0; i2 < 109; ++i2) o.write_shift(-4, i2 < L[2] ? L[1] + i2 : -1);
    }
    if (L[1]) {
      for (T = 0; T < L[1]; ++T) {
        for (; i2 < 236 + T * 127; ++i2) o.write_shift(-4, i2 < L[2] ? L[1] + i2 : -1);
        o.write_shift(-4, T === L[1] - 1 ? ENDOFCHAIN : T + 1);
      }
    }
    var chainit = function(w) {
      for (T += w; i2 < T - 1; ++i2) o.write_shift(-4, i2 + 1);
      if (w) {
        ++i2;
        o.write_shift(-4, ENDOFCHAIN);
      }
    };
    T = i2 = 0;
    for (T += L[1]; i2 < T; ++i2) o.write_shift(-4, consts.DIFSECT);
    for (T += L[2]; i2 < T; ++i2) o.write_shift(-4, consts.FATSECT);
    chainit(L[3]);
    chainit(L[4]);
    var j = 0, flen = 0;
    var file = cfb.FileIndex[0];
    for (; j < cfb.FileIndex.length; ++j) {
      file = cfb.FileIndex[j];
      if (!file.content) continue;
      flen = file.content.length;
      if (flen < 4096) continue;
      file.start = T;
      chainit(flen + 511 >> 9);
    }
    chainit(L[6] + 7 >> 3);
    while (o.l & 511) o.write_shift(-4, consts.ENDOFCHAIN);
    T = i2 = 0;
    for (j = 0; j < cfb.FileIndex.length; ++j) {
      file = cfb.FileIndex[j];
      if (!file.content) continue;
      flen = file.content.length;
      if (!flen || flen >= 4096) continue;
      file.start = T;
      chainit(flen + 63 >> 6);
    }
    while (o.l & 511) o.write_shift(-4, consts.ENDOFCHAIN);
    for (i2 = 0; i2 < L[4] << 2; ++i2) {
      var nm = cfb.FullPaths[i2];
      if (!nm || nm.length === 0) {
        for (j = 0; j < 17; ++j) o.write_shift(4, 0);
        for (j = 0; j < 3; ++j) o.write_shift(4, -1);
        for (j = 0; j < 12; ++j) o.write_shift(4, 0);
        continue;
      }
      file = cfb.FileIndex[i2];
      if (i2 === 0) file.start = file.size ? file.start - 1 : ENDOFCHAIN;
      var _nm = i2 === 0 && _opts.root || file.name;
      if (_nm.length > 31) {
        console.error("Name " + _nm + " will be truncated to " + _nm.slice(0, 31));
        _nm = _nm.slice(0, 31);
      }
      flen = 2 * (_nm.length + 1);
      o.write_shift(64, _nm, "utf16le");
      o.write_shift(2, flen);
      o.write_shift(1, file.type);
      o.write_shift(1, file.color);
      o.write_shift(-4, file.L);
      o.write_shift(-4, file.R);
      o.write_shift(-4, file.C);
      if (!file.clsid) for (j = 0; j < 4; ++j) o.write_shift(4, 0);
      else o.write_shift(16, file.clsid, "hex");
      o.write_shift(4, file.state || 0);
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      o.write_shift(4, file.start);
      o.write_shift(4, file.size);
      o.write_shift(4, 0);
    }
    for (i2 = 1; i2 < cfb.FileIndex.length; ++i2) {
      file = cfb.FileIndex[i2];
      if (file.size >= 4096) {
        o.l = file.start + 1 << 9;
        if (has_buf && Buffer.isBuffer(file.content)) {
          file.content.copy(o, o.l, 0, file.size);
          o.l += file.size + 511 & -512;
        } else {
          for (j = 0; j < file.size; ++j) o.write_shift(1, file.content[j]);
          for (; j & 511; ++j) o.write_shift(1, 0);
        }
      }
    }
    for (i2 = 1; i2 < cfb.FileIndex.length; ++i2) {
      file = cfb.FileIndex[i2];
      if (file.size > 0 && file.size < 4096) {
        if (has_buf && Buffer.isBuffer(file.content)) {
          file.content.copy(o, o.l, 0, file.size);
          o.l += file.size + 63 & -64;
        } else {
          for (j = 0; j < file.size; ++j) o.write_shift(1, file.content[j]);
          for (; j & 63; ++j) o.write_shift(1, 0);
        }
      }
    }
    if (has_buf) {
      o.l = o.length;
    } else {
      while (o.l < o.length) o.write_shift(1, 0);
    }
    return o;
  }
  function find(cfb, path) {
    var UCFullPaths = cfb.FullPaths.map(function(x) {
      return x.toUpperCase();
    });
    var UCPaths = UCFullPaths.map(function(x) {
      var y = x.split("/");
      return y[y.length - (x.slice(-1) == "/" ? 2 : 1)];
    });
    var k2 = false;
    if (path.charCodeAt(0) === 47) {
      k2 = true;
      path = UCFullPaths[0].slice(0, -1) + path;
    } else k2 = path.indexOf("/") !== -1;
    var UCPath = path.toUpperCase();
    var w = k2 === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);
    if (w !== -1) return cfb.FileIndex[w];
    var m = !UCPath.match(chr1);
    UCPath = UCPath.replace(chr0, "");
    if (m) UCPath = UCPath.replace(chr1, "!");
    for (w = 0; w < UCFullPaths.length; ++w) {
      if ((m ? UCFullPaths[w].replace(chr1, "!") : UCFullPaths[w]).replace(chr0, "") == UCPath) return cfb.FileIndex[w];
      if ((m ? UCPaths[w].replace(chr1, "!") : UCPaths[w]).replace(chr0, "") == UCPath) return cfb.FileIndex[w];
    }
    return null;
  }
  var MSSZ = 64;
  var ENDOFCHAIN = -2;
  var HEADER_SIGNATURE = "d0cf11e0a1b11ae1";
  var HEADER_SIG = [208, 207, 17, 224, 161, 177, 26, 225];
  var HEADER_CLSID = "00000000000000000000000000000000";
  var consts = {
    /* 2.1 Compund File Sector Numbers and Types */
    MAXREGSECT: -6,
    DIFSECT: -4,
    FATSECT: -3,
    ENDOFCHAIN,
    FREESECT: -1,
    /* 2.2 Compound File Header */
    HEADER_SIGNATURE,
    HEADER_MINOR_VERSION: "3e00",
    MAXREGSID: -6,
    NOSTREAM: -1,
    HEADER_CLSID,
    /* 2.6.1 Compound File Directory Entry */
    EntryTypes: ["unknown", "storage", "stream", "lockbytes", "property", "root"]
  };
  function write_file(cfb, filename2, options) {
    get_fs();
    var o = _write(cfb, options);
    fs.writeFileSync(filename2, o);
  }
  function a2s2(o) {
    var out = new Array(o.length);
    for (var i2 = 0; i2 < o.length; ++i2) out[i2] = String.fromCharCode(o[i2]);
    return out.join("");
  }
  function write(cfb, options) {
    var o = _write(cfb, options);
    switch (options && options.type || "buffer") {
      case "file":
        get_fs();
        fs.writeFileSync(options.filename, o);
        return o;
      case "binary":
        return typeof o == "string" ? o : a2s2(o);
      case "base64":
        return Base64_encode(typeof o == "string" ? o : a2s2(o));
      case "buffer":
        if (has_buf) return Buffer.isBuffer(o) ? o : Buffer_from(o);
      case "array":
        return typeof o == "string" ? s2a(o) : o;
    }
    return o;
  }
  var _zlib;
  function use_zlib(zlib) {
    try {
      var InflateRaw = zlib.InflateRaw;
      var InflRaw = new InflateRaw();
      InflRaw._processChunk(new Uint8Array([3, 0]), InflRaw._finishFlushFlag);
      if (InflRaw.bytesRead) _zlib = zlib;
      else throw new Error("zlib does not expose bytesRead");
    } catch (e) {
      console.error("cannot use native zlib: " + (e.message || e));
    }
  }
  function _inflateRawSync(payload, usz) {
    if (!_zlib) return _inflate(payload, usz);
    var InflateRaw = _zlib.InflateRaw;
    var InflRaw = new InflateRaw();
    var out = InflRaw._processChunk(payload.slice(payload.l), InflRaw._finishFlushFlag);
    payload.l += InflRaw.bytesRead;
    return out;
  }
  function _deflateRawSync(payload) {
    return _zlib ? _zlib.deflateRawSync(payload) : _deflate(payload);
  }
  var CLEN_ORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var LEN_LN = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258];
  var DST_LN = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
  function bit_swap_8(n) {
    var t = (n << 1 | n << 11) & 139536 | (n << 5 | n << 15) & 558144;
    return (t >> 16 | t >> 8 | t) & 255;
  }
  var use_typed_arrays = typeof Uint8Array !== "undefined";
  var bitswap8 = use_typed_arrays ? new Uint8Array(1 << 8) : [];
  for (var q = 0; q < 1 << 8; ++q) bitswap8[q] = bit_swap_8(q);
  function bit_swap_n(n, b) {
    var rev = bitswap8[n & 255];
    if (b <= 8) return rev >>> 8 - b;
    rev = rev << 8 | bitswap8[n >> 8 & 255];
    if (b <= 16) return rev >>> 16 - b;
    rev = rev << 8 | bitswap8[n >> 16 & 255];
    return rev >>> 24 - b;
  }
  function read_bits_2(buf, bl) {
    var w = bl & 7, h2 = bl >>> 3;
    return (buf[h2] | (w <= 6 ? 0 : buf[h2 + 1] << 8)) >>> w & 3;
  }
  function read_bits_3(buf, bl) {
    var w = bl & 7, h2 = bl >>> 3;
    return (buf[h2] | (w <= 5 ? 0 : buf[h2 + 1] << 8)) >>> w & 7;
  }
  function read_bits_4(buf, bl) {
    var w = bl & 7, h2 = bl >>> 3;
    return (buf[h2] | (w <= 4 ? 0 : buf[h2 + 1] << 8)) >>> w & 15;
  }
  function read_bits_5(buf, bl) {
    var w = bl & 7, h2 = bl >>> 3;
    return (buf[h2] | (w <= 3 ? 0 : buf[h2 + 1] << 8)) >>> w & 31;
  }
  function read_bits_7(buf, bl) {
    var w = bl & 7, h2 = bl >>> 3;
    return (buf[h2] | (w <= 1 ? 0 : buf[h2 + 1] << 8)) >>> w & 127;
  }
  function read_bits_n(buf, bl, n) {
    var w = bl & 7, h2 = bl >>> 3, f = (1 << n) - 1;
    var v2 = buf[h2] >>> w;
    if (n < 8 - w) return v2 & f;
    v2 |= buf[h2 + 1] << 8 - w;
    if (n < 16 - w) return v2 & f;
    v2 |= buf[h2 + 2] << 16 - w;
    if (n < 24 - w) return v2 & f;
    v2 |= buf[h2 + 3] << 24 - w;
    return v2 & f;
  }
  function write_bits_3(buf, bl, v2) {
    var w = bl & 7, h2 = bl >>> 3;
    if (w <= 5) buf[h2] |= (v2 & 7) << w;
    else {
      buf[h2] |= v2 << w & 255;
      buf[h2 + 1] = (v2 & 7) >> 8 - w;
    }
    return bl + 3;
  }
  function write_bits_1(buf, bl, v2) {
    var w = bl & 7, h2 = bl >>> 3;
    v2 = (v2 & 1) << w;
    buf[h2] |= v2;
    return bl + 1;
  }
  function write_bits_8(buf, bl, v2) {
    var w = bl & 7, h2 = bl >>> 3;
    v2 <<= w;
    buf[h2] |= v2 & 255;
    v2 >>>= 8;
    buf[h2 + 1] = v2;
    return bl + 8;
  }
  function write_bits_16(buf, bl, v2) {
    var w = bl & 7, h2 = bl >>> 3;
    v2 <<= w;
    buf[h2] |= v2 & 255;
    v2 >>>= 8;
    buf[h2 + 1] = v2 & 255;
    buf[h2 + 2] = v2 >>> 8;
    return bl + 16;
  }
  function realloc(b, sz) {
    var L = b.length, M = 2 * L > sz ? 2 * L : sz + 5, i2 = 0;
    if (L >= sz) return b;
    if (has_buf) {
      var o = new_unsafe_buf(M);
      if (b.copy) b.copy(o);
      else for (; i2 < b.length; ++i2) o[i2] = b[i2];
      return o;
    } else if (use_typed_arrays) {
      var a = new Uint8Array(M);
      if (a.set) a.set(b);
      else for (; i2 < L; ++i2) a[i2] = b[i2];
      return a;
    }
    b.length = M;
    return b;
  }
  function zero_fill_array(n) {
    var o = new Array(n);
    for (var i2 = 0; i2 < n; ++i2) o[i2] = 0;
    return o;
  }
  function build_tree(clens, cmap, MAX) {
    var maxlen = 1, w = 0, i2 = 0, j = 0, ccode = 0, L = clens.length;
    var bl_count = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
    for (i2 = 0; i2 < 32; ++i2) bl_count[i2] = 0;
    for (i2 = L; i2 < MAX; ++i2) clens[i2] = 0;
    L = clens.length;
    var ctree = use_typed_arrays ? new Uint16Array(L) : zero_fill_array(L);
    for (i2 = 0; i2 < L; ++i2) {
      bl_count[w = clens[i2]]++;
      if (maxlen < w) maxlen = w;
      ctree[i2] = 0;
    }
    bl_count[0] = 0;
    for (i2 = 1; i2 <= maxlen; ++i2) bl_count[i2 + 16] = ccode = ccode + bl_count[i2 - 1] << 1;
    for (i2 = 0; i2 < L; ++i2) {
      ccode = clens[i2];
      if (ccode != 0) ctree[i2] = bl_count[ccode + 16]++;
    }
    var cleni = 0;
    for (i2 = 0; i2 < L; ++i2) {
      cleni = clens[i2];
      if (cleni != 0) {
        ccode = bit_swap_n(ctree[i2], maxlen) >> maxlen - cleni;
        for (j = (1 << maxlen + 4 - cleni) - 1; j >= 0; --j)
          cmap[ccode | j << cleni] = cleni & 15 | i2 << 4;
      }
    }
    return maxlen;
  }
  var fix_lmap = use_typed_arrays ? new Uint16Array(512) : zero_fill_array(512);
  var fix_dmap = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
  if (!use_typed_arrays) {
    for (var i = 0; i < 512; ++i) fix_lmap[i] = 0;
    for (i = 0; i < 32; ++i) fix_dmap[i] = 0;
  }
  (function() {
    var dlens = [];
    var i2 = 0;
    for (; i2 < 32; i2++) dlens.push(5);
    build_tree(dlens, fix_dmap, 32);
    var clens = [];
    i2 = 0;
    for (; i2 <= 143; i2++) clens.push(8);
    for (; i2 <= 255; i2++) clens.push(9);
    for (; i2 <= 279; i2++) clens.push(7);
    for (; i2 <= 287; i2++) clens.push(8);
    build_tree(clens, fix_lmap, 288);
  })();
  var _deflateRaw = /* @__PURE__ */ function _deflateRawIIFE() {
    var DST_LN_RE = use_typed_arrays ? new Uint8Array(32768) : [];
    var j = 0, k2 = 0;
    for (; j < DST_LN.length - 1; ++j) {
      for (; k2 < DST_LN[j + 1]; ++k2) DST_LN_RE[k2] = j;
    }
    for (; k2 < 32768; ++k2) DST_LN_RE[k2] = 29;
    var LEN_LN_RE = use_typed_arrays ? new Uint8Array(259) : [];
    for (j = 0, k2 = 0; j < LEN_LN.length - 1; ++j) {
      for (; k2 < LEN_LN[j + 1]; ++k2) LEN_LN_RE[k2] = j;
    }
    function write_stored(data, out) {
      var boff = 0;
      while (boff < data.length) {
        var L = Math.min(65535, data.length - boff);
        var h2 = boff + L == data.length;
        out.write_shift(1, +h2);
        out.write_shift(2, L);
        out.write_shift(2, ~L & 65535);
        while (L-- > 0) out[out.l++] = data[boff++];
      }
      return out.l;
    }
    function write_huff_fixed(data, out) {
      var bl = 0;
      var boff = 0;
      var addrs = use_typed_arrays ? new Uint16Array(32768) : [];
      while (boff < data.length) {
        var L = (
          /* data.length - boff; */
          Math.min(65535, data.length - boff)
        );
        if (L < 10) {
          bl = write_bits_3(out, bl, +!!(boff + L == data.length));
          if (bl & 7) bl += 8 - (bl & 7);
          out.l = bl / 8 | 0;
          out.write_shift(2, L);
          out.write_shift(2, ~L & 65535);
          while (L-- > 0) out[out.l++] = data[boff++];
          bl = out.l * 8;
          continue;
        }
        bl = write_bits_3(out, bl, +!!(boff + L == data.length) + 2);
        var hash = 0;
        while (L-- > 0) {
          var d = data[boff];
          hash = (hash << 5 ^ d) & 32767;
          var match = -1, mlen = 0;
          if (match = addrs[hash]) {
            match |= boff & ~32767;
            if (match > boff) match -= 32768;
            if (match < boff) while (data[match + mlen] == data[boff + mlen] && mlen < 250) ++mlen;
          }
          if (mlen > 2) {
            d = LEN_LN_RE[mlen];
            if (d <= 22) bl = write_bits_8(out, bl, bitswap8[d + 1] >> 1) - 1;
            else {
              write_bits_8(out, bl, 3);
              bl += 5;
              write_bits_8(out, bl, bitswap8[d - 23] >> 5);
              bl += 3;
            }
            var len_eb = d < 8 ? 0 : d - 4 >> 2;
            if (len_eb > 0) {
              write_bits_16(out, bl, mlen - LEN_LN[d]);
              bl += len_eb;
            }
            d = DST_LN_RE[boff - match];
            bl = write_bits_8(out, bl, bitswap8[d] >> 3);
            bl -= 3;
            var dst_eb = d < 4 ? 0 : d - 2 >> 1;
            if (dst_eb > 0) {
              write_bits_16(out, bl, boff - match - DST_LN[d]);
              bl += dst_eb;
            }
            for (var q2 = 0; q2 < mlen; ++q2) {
              addrs[hash] = boff & 32767;
              hash = (hash << 5 ^ data[boff]) & 32767;
              ++boff;
            }
            L -= mlen - 1;
          } else {
            if (d <= 143) d = d + 48;
            else bl = write_bits_1(out, bl, 1);
            bl = write_bits_8(out, bl, bitswap8[d]);
            addrs[hash] = boff & 32767;
            ++boff;
          }
        }
        bl = write_bits_8(out, bl, 0) - 1;
      }
      out.l = (bl + 7) / 8 | 0;
      return out.l;
    }
    return function _deflateRaw2(data, out) {
      if (data.length < 8) return write_stored(data, out);
      return write_huff_fixed(data, out);
    };
  }();
  function _deflate(data) {
    var buf = new_buf(50 + Math.floor(data.length * 1.1));
    var off = _deflateRaw(data, buf);
    return buf.slice(0, off);
  }
  var dyn_lmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
  var dyn_dmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
  var dyn_cmap = use_typed_arrays ? new Uint16Array(128) : zero_fill_array(128);
  var dyn_len_1 = 1, dyn_len_2 = 1;
  function dyn(data, boff) {
    var _HLIT = read_bits_5(data, boff) + 257;
    boff += 5;
    var _HDIST = read_bits_5(data, boff) + 1;
    boff += 5;
    var _HCLEN = read_bits_4(data, boff) + 4;
    boff += 4;
    var w = 0;
    var clens = use_typed_arrays ? new Uint8Array(19) : zero_fill_array(19);
    var ctree = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    var maxlen = 1;
    var bl_count = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
    var next_code = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
    var L = clens.length;
    for (var i2 = 0; i2 < _HCLEN; ++i2) {
      clens[CLEN_ORDER[i2]] = w = read_bits_3(data, boff);
      if (maxlen < w) maxlen = w;
      bl_count[w]++;
      boff += 3;
    }
    var ccode = 0;
    bl_count[0] = 0;
    for (i2 = 1; i2 <= maxlen; ++i2) next_code[i2] = ccode = ccode + bl_count[i2 - 1] << 1;
    for (i2 = 0; i2 < L; ++i2) if ((ccode = clens[i2]) != 0) ctree[i2] = next_code[ccode]++;
    var cleni = 0;
    for (i2 = 0; i2 < L; ++i2) {
      cleni = clens[i2];
      if (cleni != 0) {
        ccode = bitswap8[ctree[i2]] >> 8 - cleni;
        for (var j = (1 << 7 - cleni) - 1; j >= 0; --j) dyn_cmap[ccode | j << cleni] = cleni & 7 | i2 << 3;
      }
    }
    var hcodes = [];
    maxlen = 1;
    for (; hcodes.length < _HLIT + _HDIST; ) {
      ccode = dyn_cmap[read_bits_7(data, boff)];
      boff += ccode & 7;
      switch (ccode >>>= 3) {
        case 16:
          w = 3 + read_bits_2(data, boff);
          boff += 2;
          ccode = hcodes[hcodes.length - 1];
          while (w-- > 0) hcodes.push(ccode);
          break;
        case 17:
          w = 3 + read_bits_3(data, boff);
          boff += 3;
          while (w-- > 0) hcodes.push(0);
          break;
        case 18:
          w = 11 + read_bits_7(data, boff);
          boff += 7;
          while (w-- > 0) hcodes.push(0);
          break;
        default:
          hcodes.push(ccode);
          if (maxlen < ccode) maxlen = ccode;
          break;
      }
    }
    var h1 = hcodes.slice(0, _HLIT), h2 = hcodes.slice(_HLIT);
    for (i2 = _HLIT; i2 < 286; ++i2) h1[i2] = 0;
    for (i2 = _HDIST; i2 < 30; ++i2) h2[i2] = 0;
    dyn_len_1 = build_tree(h1, dyn_lmap, 286);
    dyn_len_2 = build_tree(h2, dyn_dmap, 30);
    return boff;
  }
  function inflate(data, usz) {
    if (data[0] == 3 && !(data[1] & 3)) {
      return [new_raw_buf(usz), 2];
    }
    var boff = 0;
    var header = 0;
    var outbuf = new_unsafe_buf(usz ? usz : 1 << 18);
    var woff = 0;
    var OL = outbuf.length >>> 0;
    var max_len_1 = 0, max_len_2 = 0;
    while ((header & 1) == 0) {
      header = read_bits_3(data, boff);
      boff += 3;
      if (header >>> 1 == 0) {
        if (boff & 7) boff += 8 - (boff & 7);
        var sz = data[boff >>> 3] | data[(boff >>> 3) + 1] << 8;
        boff += 32;
        if (sz > 0) {
          if (!usz && OL < woff + sz) {
            outbuf = realloc(outbuf, woff + sz);
            OL = outbuf.length;
          }
          while (sz-- > 0) {
            outbuf[woff++] = data[boff >>> 3];
            boff += 8;
          }
        }
        continue;
      } else if (header >> 1 == 1) {
        max_len_1 = 9;
        max_len_2 = 5;
      } else {
        boff = dyn(data, boff);
        max_len_1 = dyn_len_1;
        max_len_2 = dyn_len_2;
      }
      for (; ; ) {
        if (!usz && OL < woff + 32767) {
          outbuf = realloc(outbuf, woff + 32767);
          OL = outbuf.length;
        }
        var bits = read_bits_n(data, boff, max_len_1);
        var code = header >>> 1 == 1 ? fix_lmap[bits] : dyn_lmap[bits];
        boff += code & 15;
        code >>>= 4;
        if ((code >>> 8 & 255) === 0) outbuf[woff++] = code;
        else if (code == 256) break;
        else {
          code -= 257;
          var len_eb = code < 8 ? 0 : code - 4 >> 2;
          if (len_eb > 5) len_eb = 0;
          var tgt = woff + LEN_LN[code];
          if (len_eb > 0) {
            tgt += read_bits_n(data, boff, len_eb);
            boff += len_eb;
          }
          bits = read_bits_n(data, boff, max_len_2);
          code = header >>> 1 == 1 ? fix_dmap[bits] : dyn_dmap[bits];
          boff += code & 15;
          code >>>= 4;
          var dst_eb = code < 4 ? 0 : code - 2 >> 1;
          var dst = DST_LN[code];
          if (dst_eb > 0) {
            dst += read_bits_n(data, boff, dst_eb);
            boff += dst_eb;
          }
          if (!usz && OL < tgt) {
            outbuf = realloc(outbuf, tgt + 100);
            OL = outbuf.length;
          }
          while (woff < tgt) {
            outbuf[woff] = outbuf[woff - dst];
            ++woff;
          }
        }
      }
    }
    if (usz) return [outbuf, boff + 7 >>> 3];
    return [outbuf.slice(0, woff), boff + 7 >>> 3];
  }
  function _inflate(payload, usz) {
    var data = payload.slice(payload.l || 0);
    var out = inflate(data, usz);
    payload.l += out[1];
    return out[0];
  }
  function warn_or_throw(wrn, msg) {
    if (wrn) {
      if (typeof console !== "undefined") console.error(msg);
    } else throw new Error(msg);
  }
  function parse_zip2(file, options) {
    var blob = (
      /*::(*/
      file
    );
    prep_blob(blob, 0);
    var FileIndex = [], FullPaths = [];
    var o = {
      FileIndex,
      FullPaths
    };
    init_cfb(o, { root: options.root });
    var i2 = blob.length - 4;
    while ((blob[i2] != 80 || blob[i2 + 1] != 75 || blob[i2 + 2] != 5 || blob[i2 + 3] != 6) && i2 >= 0) --i2;
    blob.l = i2 + 4;
    blob.l += 4;
    var fcnt = blob.read_shift(2);
    blob.l += 6;
    var start_cd = blob.read_shift(4);
    blob.l = start_cd;
    for (i2 = 0; i2 < fcnt; ++i2) {
      blob.l += 20;
      var csz = blob.read_shift(4);
      var usz = blob.read_shift(4);
      var namelen = blob.read_shift(2);
      var efsz = blob.read_shift(2);
      var fcsz = blob.read_shift(2);
      blob.l += 8;
      var offset = blob.read_shift(4);
      var EF = parse_extra_field(
        /*::(*/
        blob.slice(blob.l + namelen, blob.l + namelen + efsz)
        /*:: :any)*/
      );
      blob.l += namelen + efsz + fcsz;
      var L = blob.l;
      blob.l = offset + 4;
      if (EF && EF[1]) {
        if ((EF[1] || {}).usz) usz = EF[1].usz;
        if ((EF[1] || {}).csz) csz = EF[1].csz;
      }
      parse_local_file(blob, csz, usz, o, EF);
      blob.l = L;
    }
    return o;
  }
  function parse_local_file(blob, csz, usz, o, EF) {
    blob.l += 2;
    var flags = blob.read_shift(2);
    var meth = blob.read_shift(2);
    var date = parse_dos_date(blob);
    if (flags & 8257) throw new Error("Unsupported ZIP encryption");
    var crc32 = blob.read_shift(4);
    var _csz = blob.read_shift(4);
    var _usz = blob.read_shift(4);
    var namelen = blob.read_shift(2);
    var efsz = blob.read_shift(2);
    var name = "";
    for (var i2 = 0; i2 < namelen; ++i2) name += String.fromCharCode(blob[blob.l++]);
    if (efsz) {
      var ef = parse_extra_field(
        /*::(*/
        blob.slice(blob.l, blob.l + efsz)
        /*:: :any)*/
      );
      if ((ef[21589] || {}).mt) date = ef[21589].mt;
      if ((ef[1] || {}).usz) _usz = ef[1].usz;
      if ((ef[1] || {}).csz) _csz = ef[1].csz;
      if (EF) {
        if ((EF[21589] || {}).mt) date = EF[21589].mt;
        if ((EF[1] || {}).usz) _usz = ef[1].usz;
        if ((EF[1] || {}).csz) _csz = ef[1].csz;
      }
    }
    blob.l += efsz;
    var data = blob.slice(blob.l, blob.l + _csz);
    switch (meth) {
      case 8:
        data = _inflateRawSync(blob, _usz);
        break;
      case 0:
        break;
      default:
        throw new Error("Unsupported ZIP Compression method " + meth);
    }
    var wrn = false;
    if (flags & 8) {
      crc32 = blob.read_shift(4);
      if (crc32 == 134695760) {
        crc32 = blob.read_shift(4);
        wrn = true;
      }
      _csz = blob.read_shift(4);
      _usz = blob.read_shift(4);
    }
    if (_csz != csz) warn_or_throw(wrn, "Bad compressed size: " + csz + " != " + _csz);
    if (_usz != usz) warn_or_throw(wrn, "Bad uncompressed size: " + usz + " != " + _usz);
    cfb_add(o, name, data, { unsafe: true, mt: date });
  }
  function write_zip(cfb, options) {
    var _opts = options;
    var out = [], cdirs = [];
    var o = new_buf(1);
    var method = _opts.compression ? 8 : 0, flags = 0;
    var i2 = 0, j = 0;
    var start_cd = 0, fcnt = 0;
    var root2 = cfb.FullPaths[0], fp = root2, fi = cfb.FileIndex[0];
    var crcs = [];
    var sz_cd = 0;
    for (i2 = 1; i2 < cfb.FullPaths.length; ++i2) {
      fp = cfb.FullPaths[i2].slice(root2.length);
      fi = cfb.FileIndex[i2];
      if (!fi.size || !fi.content || fp == "Sh33tJ5") continue;
      var start = start_cd;
      var namebuf = new_buf(fp.length);
      for (j = 0; j < fp.length; ++j) namebuf.write_shift(1, fp.charCodeAt(j) & 127);
      namebuf = namebuf.slice(0, namebuf.l);
      crcs[fcnt] = typeof fi.content == "string" ? CRC32.bstr(fi.content, 0) : CRC32.buf(
        /*::((*/
        fi.content,
        0
      );
      var outbuf = typeof fi.content == "string" ? s2a(fi.content) : fi.content;
      if (method == 8) outbuf = _deflateRawSync(outbuf);
      o = new_buf(30);
      o.write_shift(4, 67324752);
      o.write_shift(2, 20);
      o.write_shift(2, flags);
      o.write_shift(2, method);
      if (fi.mt) write_dos_date(o, fi.mt);
      else o.write_shift(4, 0);
      o.write_shift(-4, crcs[fcnt]);
      o.write_shift(4, outbuf.length);
      o.write_shift(
        4,
        /*::(*/
        fi.content.length
      );
      o.write_shift(2, namebuf.length);
      o.write_shift(2, 0);
      start_cd += o.length;
      out.push(o);
      start_cd += namebuf.length;
      out.push(namebuf);
      start_cd += outbuf.length;
      out.push(outbuf);
      o = new_buf(46);
      o.write_shift(4, 33639248);
      o.write_shift(2, 0);
      o.write_shift(2, 20);
      o.write_shift(2, flags);
      o.write_shift(2, method);
      o.write_shift(4, 0);
      o.write_shift(-4, crcs[fcnt]);
      o.write_shift(4, outbuf.length);
      o.write_shift(
        4,
        /*::(*/
        fi.content.length
      );
      o.write_shift(2, namebuf.length);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      o.write_shift(4, 0);
      o.write_shift(4, start);
      sz_cd += o.l;
      cdirs.push(o);
      sz_cd += namebuf.length;
      cdirs.push(namebuf);
      ++fcnt;
    }
    o = new_buf(22);
    o.write_shift(4, 101010256);
    o.write_shift(2, 0);
    o.write_shift(2, 0);
    o.write_shift(2, fcnt);
    o.write_shift(2, fcnt);
    o.write_shift(4, sz_cd);
    o.write_shift(4, start_cd);
    o.write_shift(2, 0);
    return bconcat([bconcat(out), bconcat(cdirs), o]);
  }
  var ContentTypeMap = {
    "htm": "text/html",
    "xml": "text/xml",
    "gif": "image/gif",
    "jpg": "image/jpeg",
    "png": "image/png",
    "mso": "application/x-mso",
    "thmx": "application/vnd.ms-officetheme",
    "sh33tj5": "application/octet-stream"
  };
  function get_content_type(fi, fp) {
    if (fi.ctype) return fi.ctype;
    var ext = fi.name || "", m = ext.match(/\.([^\.]+)$/);
    if (m && ContentTypeMap[m[1]]) return ContentTypeMap[m[1]];
    if (fp) {
      m = (ext = fp).match(/[\.\\]([^\.\\])+$/);
      if (m && ContentTypeMap[m[1]]) return ContentTypeMap[m[1]];
    }
    return "application/octet-stream";
  }
  function write_base64_76(bstr) {
    var data = Base64_encode(bstr);
    var o = [];
    for (var i2 = 0; i2 < data.length; i2 += 76) o.push(data.slice(i2, i2 + 76));
    return o.join("\r\n") + "\r\n";
  }
  function write_quoted_printable(text) {
    var encoded = text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(c2) {
      var w = c2.charCodeAt(0).toString(16).toUpperCase();
      return "=" + (w.length == 1 ? "0" + w : w);
    });
    encoded = encoded.replace(/ $/mg, "=20").replace(/\t$/mg, "=09");
    if (encoded.charAt(0) == "\n") encoded = "=0D" + encoded.slice(1);
    encoded = encoded.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, "\n=0A").replace(/([^\r\n])\n/mg, "$1=0A");
    var o = [], split = encoded.split("\r\n");
    for (var si = 0; si < split.length; ++si) {
      var str = split[si];
      if (str.length == 0) {
        o.push("");
        continue;
      }
      for (var i2 = 0; i2 < str.length; ) {
        var end = 76;
        var tmp = str.slice(i2, i2 + end);
        if (tmp.charAt(end - 1) == "=") end--;
        else if (tmp.charAt(end - 2) == "=") end -= 2;
        else if (tmp.charAt(end - 3) == "=") end -= 3;
        tmp = str.slice(i2, i2 + end);
        i2 += end;
        if (i2 < str.length) tmp += "=";
        o.push(tmp);
      }
    }
    return o.join("\r\n");
  }
  function parse_quoted_printable(data) {
    var o = [];
    for (var di = 0; di < data.length; ++di) {
      var line2 = data[di];
      while (di <= data.length && line2.charAt(line2.length - 1) == "=") line2 = line2.slice(0, line2.length - 1) + data[++di];
      o.push(line2);
    }
    for (var oi = 0; oi < o.length; ++oi) o[oi] = o[oi].replace(/[=][0-9A-Fa-f]{2}/g, function($$) {
      return String.fromCharCode(parseInt($$.slice(1), 16));
    });
    return s2a(o.join("\r\n"));
  }
  function parse_mime(cfb, data, root2) {
    var fname = "", cte = "", ctype = "", fdata;
    var di = 0;
    for (; di < 10; ++di) {
      var line2 = data[di];
      if (!line2 || line2.match(/^\s*$/)) break;
      var m = line2.match(/^([^:]*?):\s*([^\s].*)$/);
      if (m) switch (m[1].toLowerCase()) {
        case "content-location":
          fname = m[2].trim();
          break;
        case "content-type":
          ctype = m[2].trim();
          break;
        case "content-transfer-encoding":
          cte = m[2].trim();
          break;
      }
    }
    ++di;
    switch (cte.toLowerCase()) {
      case "base64":
        fdata = s2a(Base64_decode(data.slice(di).join("")));
        break;
      case "quoted-printable":
        fdata = parse_quoted_printable(data.slice(di));
        break;
      default:
        throw new Error("Unsupported Content-Transfer-Encoding " + cte);
    }
    var file = cfb_add(cfb, fname.slice(root2.length), fdata, { unsafe: true });
    if (ctype) file.ctype = ctype;
  }
  function parse_mad(file, options) {
    if (a2s2(file.slice(0, 13)).toLowerCase() != "mime-version:") throw new Error("Unsupported MAD header");
    var root2 = options && options.root || "";
    var data = (has_buf && Buffer.isBuffer(file) ? file.toString("binary") : a2s2(file)).split("\r\n");
    var di = 0, row = "";
    for (di = 0; di < data.length; ++di) {
      row = data[di];
      if (!/^Content-Location:/i.test(row)) continue;
      row = row.slice(row.indexOf("file"));
      if (!root2) root2 = row.slice(0, row.lastIndexOf("/") + 1);
      if (row.slice(0, root2.length) == root2) continue;
      while (root2.length > 0) {
        root2 = root2.slice(0, root2.length - 1);
        root2 = root2.slice(0, root2.lastIndexOf("/") + 1);
        if (row.slice(0, root2.length) == root2) break;
      }
    }
    var mboundary = (data[1] || "").match(/boundary="(.*?)"/);
    if (!mboundary) throw new Error("MAD cannot find boundary");
    var boundary = "--" + (mboundary[1] || "");
    var FileIndex = [], FullPaths = [];
    var o = {
      FileIndex,
      FullPaths
    };
    init_cfb(o);
    var start_di, fcnt = 0;
    for (di = 0; di < data.length; ++di) {
      var line2 = data[di];
      if (line2 !== boundary && line2 !== boundary + "--") continue;
      if (fcnt++) parse_mime(o, data.slice(start_di, di), root2);
      start_di = di;
    }
    return o;
  }
  function write_mad(cfb, options) {
    var opts = options;
    var boundary = opts.boundary || "SheetJS";
    boundary = "------=" + boundary;
    var out = [
      "MIME-Version: 1.0",
      'Content-Type: multipart/related; boundary="' + boundary.slice(2) + '"',
      "",
      "",
      ""
    ];
    var root2 = cfb.FullPaths[0], fp = root2, fi = cfb.FileIndex[0];
    for (var i2 = 1; i2 < cfb.FullPaths.length; ++i2) {
      fp = cfb.FullPaths[i2].slice(root2.length);
      fi = cfb.FileIndex[i2];
      if (!fi.size || !fi.content || fp == "Sh33tJ5") continue;
      fp = fp.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(c2) {
        return "_x" + c2.charCodeAt(0).toString(16) + "_";
      }).replace(/[\u0080-\uFFFF]/g, function(u) {
        return "_u" + u.charCodeAt(0).toString(16) + "_";
      });
      var ca = fi.content;
      var cstr = has_buf && Buffer.isBuffer(ca) ? ca.toString("binary") : a2s2(ca);
      var dispcnt = 0, L = Math.min(1024, cstr.length), cc = 0;
      for (var csl = 0; csl <= L; ++csl) if ((cc = cstr.charCodeAt(csl)) >= 32 && cc < 128) ++dispcnt;
      var qp = dispcnt >= L * 4 / 5;
      out.push(boundary);
      out.push("Content-Location: " + (opts.root || "file:///C:/SheetJS/") + fp);
      out.push("Content-Transfer-Encoding: " + (qp ? "quoted-printable" : "base64"));
      out.push("Content-Type: " + get_content_type(fi, fp));
      out.push("");
      out.push(qp ? write_quoted_printable(cstr) : write_base64_76(cstr));
    }
    out.push(boundary + "--\r\n");
    return out.join("\r\n");
  }
  function cfb_new(opts) {
    var o = {};
    init_cfb(o, opts);
    return o;
  }
  function cfb_add(cfb, name, content, opts) {
    var unsafe = opts && opts.unsafe;
    if (!unsafe) init_cfb(cfb);
    var file = !unsafe && CFB.find(cfb, name);
    if (!file) {
      var fpath = cfb.FullPaths[0];
      if (name.slice(0, fpath.length) == fpath) fpath = name;
      else {
        if (fpath.slice(-1) != "/") fpath += "/";
        fpath = (fpath + name).replace("//", "/");
      }
      file = { name: filename(name), type: 2 };
      cfb.FileIndex.push(file);
      cfb.FullPaths.push(fpath);
      if (!unsafe) CFB.utils.cfb_gc(cfb);
    }
    file.content = content;
    file.size = content ? content.length : 0;
    if (opts) {
      if (opts.CLSID) file.clsid = opts.CLSID;
      if (opts.mt) file.mt = opts.mt;
      if (opts.ct) file.ct = opts.ct;
    }
    return file;
  }
  function cfb_del(cfb, name) {
    init_cfb(cfb);
    var file = CFB.find(cfb, name);
    if (file) {
      for (var j = 0; j < cfb.FileIndex.length; ++j) if (cfb.FileIndex[j] == file) {
        cfb.FileIndex.splice(j, 1);
        cfb.FullPaths.splice(j, 1);
        return true;
      }
    }
    return false;
  }
  function cfb_mov(cfb, old_name, new_name) {
    init_cfb(cfb);
    var file = CFB.find(cfb, old_name);
    if (file) {
      for (var j = 0; j < cfb.FileIndex.length; ++j) if (cfb.FileIndex[j] == file) {
        cfb.FileIndex[j].name = filename(new_name);
        cfb.FullPaths[j] = new_name;
        return true;
      }
    }
    return false;
  }
  function cfb_gc(cfb) {
    rebuild_cfb(cfb, true);
  }
  exports.find = find;
  exports.read = read2;
  exports.parse = parse3;
  exports.write = write;
  exports.writeFile = write_file;
  exports.utils = {
    cfb_new,
    cfb_add,
    cfb_del,
    cfb_mov,
    cfb_gc,
    ReadShift,
    CheckField,
    prep_blob,
    bconcat,
    use_zlib,
    _deflateRaw: _deflate,
    _inflateRaw: _inflate,
    consts
  };
  return exports;
}();
var _fs;
function read_binary(path) {
  if (typeof Deno !== "undefined") return Deno.readFileSync(path);
  if (typeof $ !== "undefined" && typeof File !== "undefined" && typeof Folder !== "undefined") try {
    var infile = File(path);
    infile.open("r");
    infile.encoding = "binary";
    var data = infile.read();
    infile.close();
    return data;
  } catch (e) {
    if (!e.message || e.message.indexOf("onstruct") == -1) throw e;
  }
  throw new Error("Cannot access file " + path);
}
function keys(o) {
  var ks = Object.keys(o), o2 = [];
  for (var i = 0; i < ks.length; ++i) if (Object.prototype.hasOwnProperty.call(o, ks[i])) o2.push(ks[i]);
  return o2;
}
function evert(obj) {
  var o = [], K2 = keys(obj);
  for (var i = 0; i !== K2.length; ++i) o[obj[K2[i]]] = K2[i];
  return o;
}
var dnthresh = /* @__PURE__ */ Date.UTC(1899, 11, 30, 0, 0, 0);
var dnthresh1 = /* @__PURE__ */ Date.UTC(1899, 11, 31, 0, 0, 0);
var dnthresh2 = /* @__PURE__ */ Date.UTC(1904, 0, 1, 0, 0, 0);
function datenum(v2, date1904) {
  var epoch = /* @__PURE__ */ v2.getTime();
  var res = (epoch - dnthresh) / (24 * 60 * 60 * 1e3);
  if (date1904) {
    res -= 1462;
    return res < -1402 ? res - 1 : res;
  }
  return res < 60 ? res - 1 : res;
}
function numdate(v2) {
  if (v2 >= 60 && v2 < 61) return v2;
  var out = /* @__PURE__ */ new Date();
  out.setTime((v2 > 60 ? v2 : v2 + 1) * 24 * 60 * 60 * 1e3 + dnthresh);
  return out;
}
function parse_isodur(s) {
  var sec = 0, mt = 0, time = false;
  var m = s.match(/P([0-9\.]+Y)?([0-9\.]+M)?([0-9\.]+D)?T([0-9\.]+H)?([0-9\.]+M)?([0-9\.]+S)?/);
  if (!m) throw new Error("|" + s + "| is not an ISO8601 Duration");
  for (var i = 1; i != m.length; ++i) {
    if (!m[i]) continue;
    mt = 1;
    if (i > 3) time = true;
    switch (m[i].slice(m[i].length - 1)) {
      case "Y":
        throw new Error("Unsupported ISO Duration Field: " + m[i].slice(m[i].length - 1));
      case "D":
        mt *= 24;
      case "H":
        mt *= 60;
      case "M":
        if (!time) throw new Error("Unsupported ISO Duration Field: M");
        else mt *= 60;
    }
    sec += mt * parseInt(m[i], 10);
  }
  return sec;
}
var pdre1 = /^(\d+):(\d+)(:\d+)?(\.\d+)?$/;
var pdre2 = /^(\d+)-(\d+)-(\d+)$/;
var pdre3 = /^(\d+)-(\d+)-(\d+)[T ](\d+):(\d+)(:\d+)?(\.\d+)?$/;
function parseDate(str, date1904) {
  if (str instanceof Date) return str;
  var m = str.match(pdre1);
  if (m) return new Date((date1904 ? dnthresh2 : dnthresh1) + ((parseInt(m[1], 10) * 60 + parseInt(m[2], 10)) * 60 + (m[3] ? parseInt(m[3].slice(1), 10) : 0)) * 1e3 + (m[4] ? parseInt((m[4] + "000").slice(1, 4), 10) : 0));
  m = str.match(pdre2);
  if (m) return new Date(Date.UTC(+m[1], +m[2] - 1, +m[3], 0, 0, 0, 0));
  m = str.match(pdre3);
  if (m) return new Date(Date.UTC(+m[1], +m[2] - 1, +m[3], +m[4], +m[5], m[6] && parseInt(m[6].slice(1), 10) || 0, m[7] && parseInt((m[7] + "0000").slice(1, 4), 10) || 0));
  var d = new Date(str);
  return d;
}
function cc2str(arr, debomit) {
  if (has_buf && Buffer.isBuffer(arr)) {
    if (debomit && buf_utf16le) {
      if (arr[0] == 255 && arr[1] == 254) return utf8write(arr.slice(2).toString("utf16le"));
      if (arr[1] == 254 && arr[2] == 255) return utf8write(utf16beread(arr.slice(2).toString("binary")));
    }
    return arr.toString("binary");
  }
  if (typeof TextDecoder !== "undefined") try {
    if (debomit) {
      if (arr[0] == 255 && arr[1] == 254) return utf8write(new TextDecoder("utf-16le").decode(arr.slice(2)));
      if (arr[0] == 254 && arr[1] == 255) return utf8write(new TextDecoder("utf-16be").decode(arr.slice(2)));
    }
    var rev = {
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": ""
    };
    if (Array.isArray(arr)) arr = new Uint8Array(arr);
    return new TextDecoder("latin1").decode(arr).replace(/[]/g, function(c2) {
      return rev[c2] || c2;
    });
  } catch (e) {
  }
  var o = [], i = 0;
  try {
    for (i = 0; i < arr.length - 65536; i += 65536) o.push(String.fromCharCode.apply(0, arr.slice(i, i + 65536)));
    o.push(String.fromCharCode.apply(0, arr.slice(i)));
  } catch (e) {
    try {
      for (; i < arr.length - 16384; i += 16384) o.push(String.fromCharCode.apply(0, arr.slice(i, i + 16384)));
      o.push(String.fromCharCode.apply(0, arr.slice(i)));
    } catch (e2) {
      for (; i != arr.length; ++i) o.push(String.fromCharCode(arr[i]));
    }
  }
  return o.join("");
}
function dup(o) {
  if (typeof JSON != "undefined" && !Array.isArray(o)) return JSON.parse(JSON.stringify(o));
  if (typeof o != "object" || o == null) return o;
  if (o instanceof Date) return new Date(o.getTime());
  var out = {};
  for (var k2 in o) if (Object.prototype.hasOwnProperty.call(o, k2)) out[k2] = dup(o[k2]);
  return out;
}
function fill(c2, l2) {
  var o = "";
  while (o.length < l2) o += c2;
  return o;
}
function fuzzynum(s) {
  var v2 = Number(s);
  if (!isNaN(v2)) return isFinite(v2) ? v2 : NaN;
  if (!/\d/.test(s)) return v2;
  var wt = 1;
  var ss = s.replace(/([\d]),([\d])/g, "$1$2").replace(/[$]/g, "").replace(/[%]/g, function() {
    wt *= 100;
    return "";
  });
  if (!isNaN(v2 = Number(ss))) return v2 / wt;
  ss = ss.replace(/[(]([^()]*)[)]/, function($$, $1) {
    wt = -wt;
    return $1;
  });
  if (!isNaN(v2 = Number(ss))) return v2 / wt;
  return v2;
}
var FDRE1 = /^(0?\d|1[0-2])(?:|:([0-5]?\d)(?:|(\.\d+)(?:|:([0-5]?\d))|:([0-5]?\d)(|\.\d+)))\s+([ap])m?$/;
var FDRE2 = /^([01]?\d|2[0-3])(?:|:([0-5]?\d)(?:|(\.\d+)(?:|:([0-5]?\d))|:([0-5]?\d)(|\.\d+)))$/;
var FDISO = /^(\d+)-(\d+)-(\d+)[T ](\d+):(\d+)(:\d+)(\.\d+)?[Z]?$/;
var utc_append_works = (/* @__PURE__ */ new Date("6/9/69 00:00 UTC")).valueOf() == -177984e5;
function fuzzytime1(M) {
  if (!M[2]) return new Date(Date.UTC(1899, 11, 31, +M[1] % 12 + (M[7] == "p" ? 12 : 0), 0, 0, 0));
  if (M[3]) {
    if (M[4]) return new Date(Date.UTC(1899, 11, 31, +M[1] % 12 + (M[7] == "p" ? 12 : 0), +M[2], +M[4], parseFloat(M[3]) * 1e3));
    else return new Date(Date.UTC(1899, 11, 31, M[7] == "p" ? 12 : 0, +M[1], +M[2], parseFloat(M[3]) * 1e3));
  } else if (M[5]) return new Date(Date.UTC(1899, 11, 31, +M[1] % 12 + (M[7] == "p" ? 12 : 0), +M[2], +M[5], M[6] ? parseFloat(M[6]) * 1e3 : 0));
  else return new Date(Date.UTC(1899, 11, 31, +M[1] % 12 + (M[7] == "p" ? 12 : 0), +M[2], 0, 0));
}
function fuzzytime2(M) {
  if (!M[2]) return new Date(Date.UTC(1899, 11, 31, +M[1], 0, 0, 0));
  if (M[3]) {
    if (M[4]) return new Date(Date.UTC(1899, 11, 31, +M[1], +M[2], +M[4], parseFloat(M[3]) * 1e3));
    else return new Date(Date.UTC(1899, 11, 31, 0, +M[1], +M[2], parseFloat(M[3]) * 1e3));
  } else if (M[5]) return new Date(Date.UTC(1899, 11, 31, +M[1], +M[2], +M[5], M[6] ? parseFloat(M[6]) * 1e3 : 0));
  else return new Date(Date.UTC(1899, 11, 31, +M[1], +M[2], 0, 0));
}
var lower_months = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
function fuzzydate(s) {
  if (FDISO.test(s)) return s.indexOf("Z") == -1 ? local_to_utc(new Date(s)) : new Date(s);
  var lower = s.toLowerCase();
  var lnos = lower.replace(/\s+/g, " ").trim();
  var M = lnos.match(FDRE1);
  if (M) return fuzzytime1(M);
  M = lnos.match(FDRE2);
  if (M) return fuzzytime2(M);
  M = lnos.match(pdre3);
  if (M) return new Date(Date.UTC(+M[1], +M[2] - 1, +M[3], +M[4], +M[5], M[6] && parseInt(M[6].slice(1), 10) || 0, M[7] && parseInt((M[7] + "0000").slice(1, 4), 10) || 0));
  var o = new Date(utc_append_works && s.indexOf("UTC") == -1 ? s + " UTC" : s), n = /* @__PURE__ */ new Date(NaN);
  var y = o.getYear();
  o.getMonth();
  var d = o.getDate();
  if (isNaN(d)) return n;
  if (lower.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {
    lower = lower.replace(/[^a-z]/g, "").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/, "");
    if (lower.length > 3 && lower_months.indexOf(lower) == -1) return n;
  } else if (lower.replace(/[ap]m?/, "").match(/[a-z]/)) return n;
  if (y < 0 || y > 8099 || s.match(/[^-0-9:,\/\\\ ]/)) return n;
  return o;
}
var split_regex = /* @__PURE__ */ function() {
  var safe_split_regex = "abacaba".split(/(:?b)/i).length == 5;
  return function split_regex2(str, re2, def) {
    if (safe_split_regex || typeof re2 == "string") return str.split(re2);
    var p = str.split(re2), o = [p[0]];
    for (var i = 1; i < p.length; ++i) {
      o.push(def);
      o.push(p[i]);
    }
    return o;
  };
}();
function utc_to_local(utc) {
  return new Date(utc.getUTCFullYear(), utc.getUTCMonth(), utc.getUTCDate(), utc.getUTCHours(), utc.getUTCMinutes(), utc.getUTCSeconds(), utc.getUTCMilliseconds());
}
function local_to_utc(local) {
  return new Date(Date.UTC(local.getFullYear(), local.getMonth(), local.getDate(), local.getHours(), local.getMinutes(), local.getSeconds(), local.getMilliseconds()));
}
function remove_doctype(str) {
  var preamble = str.slice(0, 1024);
  var si = preamble.indexOf("<!DOCTYPE");
  if (si == -1) return str;
  var m = str.match(/<[\w]/);
  if (!m) return str;
  return str.slice(0, si) + str.slice(m.index);
}
function str_match_ng(str, s, e) {
  var out = [];
  var si = str.indexOf(s);
  while (si > -1) {
    var ei = str.indexOf(e, si + s.length);
    if (ei == -1) break;
    out.push(str.slice(si, ei + e.length));
    si = str.indexOf(s, ei + e.length);
  }
  return out.length > 0 ? out : null;
}
function str_remove_ng(str, s, e) {
  var out = [], last = 0;
  var si = str.indexOf(s);
  if (si == -1) return str;
  while (si > -1) {
    out.push(str.slice(last, si));
    var ei = str.indexOf(e, si + s.length);
    if (ei == -1) break;
    if ((si = str.indexOf(s, last = ei + e.length)) == -1) out.push(str.slice(last));
  }
  return out.join("");
}
var xml_boundary = { " ": 1, "	": 1, "\r": 1, "\n": 1, ">": 1 };
function str_match_xml(str, tag) {
  var si = str.indexOf("<" + tag), w = tag.length + 1, L = str.length;
  while (si >= 0 && si <= L - w && !xml_boundary[str.charAt(si + w)]) si = str.indexOf("<" + tag, si + 1);
  if (si === -1) return null;
  var sf = str.indexOf(">", si + tag.length);
  if (sf === -1) return null;
  var et = "</" + tag + ">";
  var ei = str.indexOf(et, sf);
  if (ei == -1) return null;
  return [str.slice(si, ei + et.length), str.slice(sf + 1, ei)];
}
var str_match_xml_ns = /* @__PURE__ */ function() {
  var str_match_xml_ns_cache = {};
  return function str_match_xml_ns2(str, tag) {
    var res = str_match_xml_ns_cache[tag];
    if (!res) str_match_xml_ns_cache[tag] = res = [
      new RegExp("<(?:\\w+:)?" + tag + "\\b[^<>]*>", "g"),
      new RegExp("</(?:\\w+:)?" + tag + ">", "g")
    ];
    res[0].lastIndex = res[1].lastIndex = 0;
    var m = res[0].exec(str);
    if (!m) return null;
    var si = m.index;
    var sf = res[0].lastIndex;
    res[1].lastIndex = res[0].lastIndex;
    m = res[1].exec(str);
    if (!m) return null;
    var ei = m.index;
    var ef = res[1].lastIndex;
    return [str.slice(si, ef), str.slice(sf, ei)];
  };
}();
var str_match_xml_ns_g = /* @__PURE__ */ function() {
  var str_match_xml_ns_cache = {};
  return function str_match_xml_ns2(str, tag) {
    var out = [];
    var res = str_match_xml_ns_cache[tag];
    if (!res) str_match_xml_ns_cache[tag] = res = [
      new RegExp("<(?:\\w+:)?" + tag + "\\b[^<>]*>", "g"),
      new RegExp("</(?:\\w+:)?" + tag + ">", "g")
    ];
    res[0].lastIndex = res[1].lastIndex = 0;
    var m;
    while (m = res[0].exec(str)) {
      var si = m.index;
      res[1].lastIndex = res[0].lastIndex;
      m = res[1].exec(str);
      if (!m) return null;
      var ef = res[1].lastIndex;
      out.push(str.slice(si, ef));
      res[0].lastIndex = res[1].lastIndex;
    }
    return out.length == 0 ? null : out;
  };
}();
var str_remove_xml_ns_g = /* @__PURE__ */ function() {
  var str_remove_xml_ns_cache = {};
  return function str_remove_xml_ns_g2(str, tag) {
    var out = [];
    var res = str_remove_xml_ns_cache[tag];
    if (!res) str_remove_xml_ns_cache[tag] = res = [
      new RegExp("<(?:\\w+:)?" + tag + "\\b[^<>]*>", "g"),
      new RegExp("</(?:\\w+:)?" + tag + ">", "g")
    ];
    res[0].lastIndex = res[1].lastIndex = 0;
    var m;
    var si = 0, ef = 0;
    while (m = res[0].exec(str)) {
      si = m.index;
      out.push(str.slice(ef, si));
      ef = si;
      res[1].lastIndex = res[0].lastIndex;
      m = res[1].exec(str);
      if (!m) return null;
      ef = res[1].lastIndex;
      res[0].lastIndex = res[1].lastIndex;
    }
    out.push(str.slice(ef));
    return out.length == 0 ? "" : out.join("");
  };
}();
var str_match_xml_ig = /* @__PURE__ */ function() {
  var str_match_xml_ns_cache = {};
  return function str_match_xml_ns2(str, tag) {
    var out = [];
    var res = str_match_xml_ns_cache[tag];
    if (!res) str_match_xml_ns_cache[tag] = res = [
      new RegExp("<" + tag + "\\b[^<>]*>", "ig"),
      new RegExp("</" + tag + ">", "ig")
    ];
    res[0].lastIndex = res[1].lastIndex = 0;
    var m;
    while (m = res[0].exec(str)) {
      var si = m.index;
      res[1].lastIndex = res[0].lastIndex;
      m = res[1].exec(str);
      if (!m) return null;
      var ef = res[1].lastIndex;
      out.push(str.slice(si, ef));
      res[0].lastIndex = res[1].lastIndex;
    }
    return out.length == 0 ? null : out;
  };
}();
function getdatastr(data) {
  if (!data) return null;
  if (data.content && data.type) return cc2str(data.content, true);
  if (data.data) return debom(data.data);
  if (data.asNodeBuffer && has_buf) return debom(data.asNodeBuffer().toString("binary"));
  if (data.asBinary) return debom(data.asBinary());
  if (data._data && data._data.getContent) return debom(cc2str(Array.prototype.slice.call(data._data.getContent(), 0)));
  return null;
}
function getdatabin(data) {
  if (!data) return null;
  if (data.data) return char_codes(data.data);
  if (data.asNodeBuffer && has_buf) return data.asNodeBuffer();
  if (data._data && data._data.getContent) {
    var o = data._data.getContent();
    if (typeof o == "string") return char_codes(o);
    return Array.prototype.slice.call(o);
  }
  if (data.content && data.type) return data.content;
  return null;
}
function getdata(data) {
  return data && data.name.slice(-4) === ".bin" ? getdatabin(data) : getdatastr(data);
}
function safegetzipfile(zip, file) {
  var k2 = zip.FullPaths || keys(zip.files);
  var f = file.toLowerCase().replace(/[\/]/g, "\\"), g = f.replace(/\\/g, "/");
  for (var i = 0; i < k2.length; ++i) {
    var n = k2[i].replace(/^Root Entry[\/]/, "").toLowerCase();
    if (f == n || g == n) return zip.files ? zip.files[k2[i]] : zip.FileIndex[i];
  }
  return null;
}
function getzipfile(zip, file) {
  var o = safegetzipfile(zip, file);
  if (o == null) throw new Error("Cannot find file " + file + " in zip");
  return o;
}
function getzipdata(zip, file, safe) {
  if (!safe) return getdata(getzipfile(zip, file));
  if (!file) return null;
  try {
    return getzipdata(zip, file);
  } catch (e) {
    return null;
  }
}
function getzipstr(zip, file, safe) {
  if (!safe) return getdatastr(getzipfile(zip, file));
  if (!file) return null;
  try {
    return getzipstr(zip, file);
  } catch (e) {
    return null;
  }
}
function getzipbin(zip, file, safe) {
  return getdatabin(getzipfile(zip, file));
}
function zipentries(zip) {
  var k2 = zip.FullPaths || keys(zip.files), o = [];
  for (var i = 0; i < k2.length; ++i) if (k2[i].slice(-1) != "/") o.push(k2[i].replace(/^Root Entry[\/]/, ""));
  return o.sort();
}
function zip_add_file(zip, path, content) {
  if (zip.FullPaths) {
    if (typeof content == "string") {
      var res;
      if (has_buf) res = Buffer_from(content);
      else res = utf8decode(content);
      return CFB.utils.cfb_add(zip, path, res);
    }
    CFB.utils.cfb_add(zip, path, content);
  } else zip.file(path, content);
}
function zip_read(d, o) {
  switch (o.type) {
    case "base64":
      return CFB.read(d, { type: "base64" });
    case "binary":
      return CFB.read(d, { type: "binary" });
    case "buffer":
    case "array":
      return CFB.read(d, { type: "buffer" });
  }
  throw new Error("Unrecognized type " + o.type);
}
function resolve_path(path, base) {
  if (path.charAt(0) == "/") return path.slice(1);
  var result = base.split("/");
  if (base.slice(-1) != "/") result.pop();
  var target = path.split("/");
  while (target.length !== 0) {
    var step = target.shift();
    if (step === "..") result.pop();
    else if (step !== ".") result.push(step);
  }
  return result.join("/");
}
var XML_HEADER = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n';
var attregexg = /\s([^"\s?>\/]+)\s*=\s*((?:")([^"]*)(?:")|(?:')([^']*)(?:')|([^'">\s]+))/g;
var tagregex1 = /<[\/\?]?[a-zA-Z0-9:_-]+(?:\s+[^"\s?<>\/]+\s*=\s*(?:"[^"]*"|'[^']*'|[^'"<>\s=]+))*\s*[\/\?]?>/mg, tagregex2 = /<[^<>]*>/g;
var tagregex = /* @__PURE__ */ XML_HEADER.match(tagregex1) ? tagregex1 : tagregex2;
var nsregex = /<\w*:/, nsregex2 = /<(\/?)\w+:/;
function parsexmltag(tag, skip_root, skip_LC) {
  var z = {};
  var eq = 0, c2 = 0;
  for (; eq !== tag.length; ++eq) if ((c2 = tag.charCodeAt(eq)) === 32 || c2 === 10 || c2 === 13) break;
  if (!skip_root) z[0] = tag.slice(0, eq);
  if (eq === tag.length) return z;
  var m = tag.match(attregexg), j = 0, v2 = "", i = 0, q = "", cc = "", quot = 1;
  if (m) for (i = 0; i != m.length; ++i) {
    cc = m[i].slice(1);
    for (c2 = 0; c2 != cc.length; ++c2) if (cc.charCodeAt(c2) === 61) break;
    q = cc.slice(0, c2).trim();
    while (cc.charCodeAt(c2 + 1) == 32) ++c2;
    quot = (eq = cc.charCodeAt(c2 + 1)) == 34 || eq == 39 ? 1 : 0;
    v2 = cc.slice(c2 + 1 + quot, cc.length - quot);
    for (j = 0; j != q.length; ++j) if (q.charCodeAt(j) === 58) break;
    if (j === q.length) {
      if (q.indexOf("_") > 0) q = q.slice(0, q.indexOf("_"));
      z[q] = v2;
      z[q.toLowerCase()] = v2;
    } else {
      var k2 = (j === 5 && q.slice(0, 5) === "xmlns" ? "xmlns" : "") + q.slice(j + 1);
      if (z[k2] && q.slice(j - 3, j) == "ext") continue;
      z[k2] = v2;
      z[k2.toLowerCase()] = v2;
    }
  }
  return z;
}
function strip_ns(x) {
  return x.replace(nsregex2, "<$1");
}
var encodings = {
  "&quot;": '"',
  "&apos;": "'",
  "&gt;": ">",
  "&lt;": "<",
  "&amp;": "&"
};
var rencoding = /* @__PURE__ */ evert(encodings);
var unescapexml = /* @__PURE__ */ function() {
  var encregex = /&(?:quot|apos|gt|lt|amp|#x?([\da-fA-F]+));/ig, coderegex = /_x([\da-fA-F]{4})_/ig;
  function raw_unescapexml(text) {
    var s = text + "", i = s.indexOf("<![CDATA[");
    if (i == -1) return s.replace(encregex, function($$, $1) {
      return encodings[$$] || String.fromCharCode(parseInt($1, $$.indexOf("x") > -1 ? 16 : 10)) || $$;
    }).replace(coderegex, function(m, c2) {
      return String.fromCharCode(parseInt(c2, 16));
    });
    var j = s.indexOf("]]>");
    return raw_unescapexml(s.slice(0, i)) + s.slice(i + 9, j) + raw_unescapexml(s.slice(j + 3));
  }
  return function unescapexml2(text, xlsx) {
    var out = raw_unescapexml(text);
    return xlsx ? out.replace(/\r\n/g, "\n") : out;
  };
}();
var decregex = /[&<>'"]/g;
var htmlcharegex = /[\u0000-\u001f]/g;
function escapehtml(text) {
  var s = text + "";
  return s.replace(decregex, function(y) {
    return rencoding[y];
  }).replace(/\n/g, "<br/>").replace(htmlcharegex, function(s2) {
    return "&#x" + ("000" + s2.charCodeAt(0).toString(16)).slice(-4) + ";";
  });
}
var xlml_fixstr = /* @__PURE__ */ function() {
  var entregex = /&#(\d+);/g;
  function entrepl($$, $1) {
    return String.fromCharCode(parseInt($1, 10));
  }
  return function xlml_fixstr2(str) {
    return str.replace(entregex, entrepl);
  };
}();
function parsexmlbool(value) {
  switch (value) {
    case 1:
    case true:
    case "1":
    case "true":
      return true;
    case 0:
    case false:
    case "0":
    case "false":
      return false;
  }
  return false;
}
function utf8reada(orig) {
  var out = "", i = 0, c2 = 0, d = 0, e = 0, f = 0, w = 0;
  while (i < orig.length) {
    c2 = orig.charCodeAt(i++);
    if (c2 < 128) {
      out += String.fromCharCode(c2);
      continue;
    }
    d = orig.charCodeAt(i++);
    if (c2 > 191 && c2 < 224) {
      f = (c2 & 31) << 6;
      f |= d & 63;
      out += String.fromCharCode(f);
      continue;
    }
    e = orig.charCodeAt(i++);
    if (c2 < 240) {
      out += String.fromCharCode((c2 & 15) << 12 | (d & 63) << 6 | e & 63);
      continue;
    }
    f = orig.charCodeAt(i++);
    w = ((c2 & 7) << 18 | (d & 63) << 12 | (e & 63) << 6 | f & 63) - 65536;
    out += String.fromCharCode(55296 + (w >>> 10 & 1023));
    out += String.fromCharCode(56320 + (w & 1023));
  }
  return out;
}
function utf8readb(data) {
  var out = new_raw_buf(2 * data.length), w, i, j = 1, k2 = 0, ww = 0, c2;
  for (i = 0; i < data.length; i += j) {
    j = 1;
    if ((c2 = data.charCodeAt(i)) < 128) w = c2;
    else if (c2 < 224) {
      w = (c2 & 31) * 64 + (data.charCodeAt(i + 1) & 63);
      j = 2;
    } else if (c2 < 240) {
      w = (c2 & 15) * 4096 + (data.charCodeAt(i + 1) & 63) * 64 + (data.charCodeAt(i + 2) & 63);
      j = 3;
    } else {
      j = 4;
      w = (c2 & 7) * 262144 + (data.charCodeAt(i + 1) & 63) * 4096 + (data.charCodeAt(i + 2) & 63) * 64 + (data.charCodeAt(i + 3) & 63);
      w -= 65536;
      ww = 55296 + (w >>> 10 & 1023);
      w = 56320 + (w & 1023);
    }
    if (ww !== 0) {
      out[k2++] = ww & 255;
      out[k2++] = ww >>> 8;
      ww = 0;
    }
    out[k2++] = w % 256;
    out[k2++] = w >>> 8;
  }
  return out.slice(0, k2).toString("ucs2");
}
function utf8readc(data) {
  return Buffer_from(data, "binary").toString("utf8");
}
var utf8corpus = "foo bar baz";
var utf8read = has_buf && (/* @__PURE__ */ utf8readc(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readc || /* @__PURE__ */ utf8readb(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readb) || utf8reada;
var utf8write = has_buf ? function(data) {
  return Buffer_from(data, "utf8").toString("binary");
} : function(orig) {
  var out = [], i = 0, c2 = 0, d = 0;
  while (i < orig.length) {
    c2 = orig.charCodeAt(i++);
    switch (true) {
      case c2 < 128:
        out.push(String.fromCharCode(c2));
        break;
      case c2 < 2048:
        out.push(String.fromCharCode(192 + (c2 >> 6)));
        out.push(String.fromCharCode(128 + (c2 & 63)));
        break;
      case (c2 >= 55296 && c2 < 57344):
        c2 -= 55296;
        d = orig.charCodeAt(i++) - 56320 + (c2 << 10);
        out.push(String.fromCharCode(240 + (d >> 18 & 7)));
        out.push(String.fromCharCode(144 + (d >> 12 & 63)));
        out.push(String.fromCharCode(128 + (d >> 6 & 63)));
        out.push(String.fromCharCode(128 + (d & 63)));
        break;
      default:
        out.push(String.fromCharCode(224 + (c2 >> 12)));
        out.push(String.fromCharCode(128 + (c2 >> 6 & 63)));
        out.push(String.fromCharCode(128 + (c2 & 63)));
    }
  }
  return out.join("");
};
var htmldecode = /* @__PURE__ */ function() {
  var entities = [
    ["nbsp", " "],
    ["middot", ""],
    ["quot", '"'],
    ["apos", "'"],
    ["gt", ">"],
    ["lt", "<"],
    ["amp", "&"]
  ].map(function(x) {
    return [new RegExp("&" + x[0] + ";", "ig"), x[1]];
  });
  return function htmldecode2(str) {
    var o = str.replace(/^[\t\n\r ]+/, "").replace(/(^|[^\t\n\r ])[\t\n\r ]+$/, "$1").replace(/>\s+/g, ">").replace(/\b\s+</g, "<").replace(/[\t\n\r ]+/g, " ").replace(/<\s*[bB][rR]\s*\/?>/g, "\n").replace(/<[^<>]*>/g, "");
    for (var i = 0; i < entities.length; ++i) o = o.replace(entities[i][0], entities[i][1]);
    return o;
  };
}();
var vtvregex = /<\/?(?:vt:)?variant>/g, vtmregex = /<(?:vt:)([^<"'>]*)>([\s\S]*)</;
function parseVector(data, opts) {
  var h2 = parsexmltag(data);
  var matches = str_match_xml_ns_g(data, h2.baseType) || [];
  var res = [];
  if (matches.length != h2.size) {
    if (opts.WTF) throw new Error("unexpected vector length " + matches.length + " != " + h2.size);
    return res;
  }
  matches.forEach(function(x) {
    var v2 = x.replace(vtvregex, "").match(vtmregex);
    if (v2) res.push({ v: utf8read(v2[2]), t: v2[1] });
  });
  return res;
}
var wtregex = /(^\s|\s$|\n)/;
function wxt_helper(h2) {
  return keys(h2).map(function(k2) {
    return " " + k2 + '="' + h2[k2] + '"';
  }).join("");
}
function writextag(f, g, h2) {
  return "<" + f + (h2 != null ? wxt_helper(h2) : "") + (g != null ? (g.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + g + "</" + f : "/") + ">";
}
function xlml_normalize(d) {
  if (has_buf && /*::typeof Buffer !== "undefined" && d != null && d instanceof Buffer &&*/
  Buffer.isBuffer(d)) return d.toString("utf8");
  if (typeof d === "string") return d;
  if (typeof Uint8Array !== "undefined" && d instanceof Uint8Array) return utf8read(a2s(ab2a(d)));
  throw new Error("Bad input format: expected Buffer or string");
}
var xlmlregex = /<([\/]?)([^\s?><!\/:"]*:|)([^\s?<>:\/"]+)(?:\s+[^<>=?"'\s]+="[^"]*?")*\s*[\/]?>/mg;
var XMLNS = {
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
  CT: "http://schemas.openxmlformats.org/package/2006/content-types",
  RELS: "http://schemas.openxmlformats.org/package/2006/relationships",
  TCMNT: "http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments",
  "dc": "http://purl.org/dc/elements/1.1/",
  "dcterms": "http://purl.org/dc/terms/",
  "dcmitype": "http://purl.org/dc/dcmitype/",
  "mx": "http://schemas.microsoft.com/office/mac/excel/2008/main",
  "r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
  "sjs": "http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties",
  "vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",
  "xsi": "http://www.w3.org/2001/XMLSchema-instance",
  "xsd": "http://www.w3.org/2001/XMLSchema"
};
var XMLNS_main = [
  "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
  "http://purl.oclc.org/ooxml/spreadsheetml/main",
  "http://schemas.microsoft.com/office/excel/2006/main",
  "http://schemas.microsoft.com/office/excel/2006/2"
];
function read_double_le(b, idx) {
  var s = 1 - 2 * (b[idx + 7] >>> 7);
  var e = ((b[idx + 7] & 127) << 4) + (b[idx + 6] >>> 4 & 15);
  var m = b[idx + 6] & 15;
  for (var i = 5; i >= 0; --i) m = m * 256 + b[idx + i];
  if (e == 2047) return m == 0 ? s * Infinity : NaN;
  if (e == 0) e = -1022;
  else {
    e -= 1023;
    m += Math.pow(2, 52);
  }
  return s * Math.pow(2, e - 52) * m;
}
function write_double_le(b, v2, idx) {
  var bs = (v2 < 0 || 1 / v2 == -Infinity ? 1 : 0) << 7, e = 0, m = 0;
  var av = bs ? -v2 : v2;
  if (!isFinite(av)) {
    e = 2047;
    m = isNaN(v2) ? 26985 : 0;
  } else if (av == 0) e = m = 0;
  else {
    e = Math.floor(Math.log(av) / Math.LN2);
    m = av * Math.pow(2, 52 - e);
    if (e <= -1023 && (!isFinite(m) || m < Math.pow(2, 52))) {
      e = -1022;
    } else {
      m -= Math.pow(2, 52);
      e += 1023;
    }
  }
  for (var i = 0; i <= 5; ++i, m /= 256) b[idx + i] = m & 255;
  b[idx + 6] = (e & 15) << 4 | m & 15;
  b[idx + 7] = e >> 4 | bs;
}
var ___toBuffer = function(bufs) {
  var x = [], w = 10240;
  for (var i = 0; i < bufs[0].length; ++i) if (bufs[0][i]) for (var j = 0, L = bufs[0][i].length; j < L; j += w) x.push.apply(x, bufs[0][i].slice(j, j + w));
  return x;
};
var __toBuffer = has_buf ? function(bufs) {
  return bufs[0].length > 0 && Buffer.isBuffer(bufs[0][0]) ? Buffer.concat(bufs[0].map(function(x) {
    return Buffer.isBuffer(x) ? x : Buffer_from(x);
  })) : ___toBuffer(bufs);
} : ___toBuffer;
var ___utf16le = function(b, s, e) {
  var ss = [];
  for (var i = s; i < e; i += 2) ss.push(String.fromCharCode(__readUInt16LE(b, i)));
  return ss.join("").replace(chr0, "");
};
var __utf16le = has_buf ? function(b, s, e) {
  if (!Buffer.isBuffer(b) || !buf_utf16le) return ___utf16le(b, s, e);
  return b.toString("utf16le", s, e).replace(chr0, "");
} : ___utf16le;
var ___hexlify = function(b, s, l2) {
  var ss = [];
  for (var i = s; i < s + l2; ++i) ss.push(("0" + b[i].toString(16)).slice(-2));
  return ss.join("");
};
var __hexlify = has_buf ? function(b, s, l2) {
  return Buffer.isBuffer(b) ? b.toString("hex", s, s + l2) : ___hexlify(b, s, l2);
} : ___hexlify;
var ___utf8 = function(b, s, e) {
  var ss = [];
  for (var i = s; i < e; i++) ss.push(String.fromCharCode(__readUInt8(b, i)));
  return ss.join("");
};
var __utf8 = has_buf ? function utf8_b(b, s, e) {
  return Buffer.isBuffer(b) ? b.toString("utf8", s, e) : ___utf8(b, s, e);
} : ___utf8;
var ___lpstr = function(b, i) {
  var len = __readUInt32LE(b, i);
  return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
};
var __lpstr = ___lpstr;
var ___cpstr = function(b, i) {
  var len = __readUInt32LE(b, i);
  return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
};
var __cpstr = ___cpstr;
var ___lpwstr = function(b, i) {
  var len = 2 * __readUInt32LE(b, i);
  return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
};
var __lpwstr = ___lpwstr;
var ___lpp4 = function lpp4_(b, i) {
  var len = __readUInt32LE(b, i);
  return len > 0 ? __utf16le(b, i + 4, i + 4 + len) : "";
};
var __lpp4 = ___lpp4;
var ___8lpp4 = function(b, i) {
  var len = __readUInt32LE(b, i);
  return len > 0 ? __utf8(b, i + 4, i + 4 + len) : "";
};
var __8lpp4 = ___8lpp4;
var ___double = function(b, idx) {
  return read_double_le(b, idx);
};
var __double = ___double;
var is_buf = function is_buf_a(a) {
  return Array.isArray(a) || typeof Uint8Array !== "undefined" && a instanceof Uint8Array;
};
if (has_buf) {
  __lpstr = function lpstr_b(b, i) {
    if (!Buffer.isBuffer(b)) return ___lpstr(b, i);
    var len = b.readUInt32LE(i);
    return len > 0 ? b.toString("utf8", i + 4, i + 4 + len - 1) : "";
  };
  __cpstr = function cpstr_b(b, i) {
    if (!Buffer.isBuffer(b)) return ___cpstr(b, i);
    var len = b.readUInt32LE(i);
    return len > 0 ? b.toString("utf8", i + 4, i + 4 + len - 1) : "";
  };
  __lpwstr = function lpwstr_b(b, i) {
    if (!Buffer.isBuffer(b) || !buf_utf16le) return ___lpwstr(b, i);
    var len = 2 * b.readUInt32LE(i);
    return b.toString("utf16le", i + 4, i + 4 + len - 1);
  };
  __lpp4 = function lpp4_b(b, i) {
    if (!Buffer.isBuffer(b) || !buf_utf16le) return ___lpp4(b, i);
    var len = b.readUInt32LE(i);
    return b.toString("utf16le", i + 4, i + 4 + len);
  };
  __8lpp4 = function lpp4_8b(b, i) {
    if (!Buffer.isBuffer(b)) return ___8lpp4(b, i);
    var len = b.readUInt32LE(i);
    return b.toString("utf8", i + 4, i + 4 + len);
  };
  __double = function double_(b, i) {
    if (Buffer.isBuffer(b)) return b.readDoubleLE(i);
    return ___double(b, i);
  };
  is_buf = function is_buf_b(a) {
    return Buffer.isBuffer(a) || Array.isArray(a) || typeof Uint8Array !== "undefined" && a instanceof Uint8Array;
  };
}
var __readUInt8 = function(b, idx) {
  return b[idx];
};
var __readUInt16LE = function(b, idx) {
  return b[idx + 1] * (1 << 8) + b[idx];
};
var __readInt16LE = function(b, idx) {
  var u = b[idx + 1] * (1 << 8) + b[idx];
  return u < 32768 ? u : (65535 - u + 1) * -1;
};
var __readUInt32LE = function(b, idx) {
  return b[idx + 3] * (1 << 24) + (b[idx + 2] << 16) + (b[idx + 1] << 8) + b[idx];
};
var __readInt32LE = function(b, idx) {
  return b[idx + 3] << 24 | b[idx + 2] << 16 | b[idx + 1] << 8 | b[idx];
};
var __readInt32BE = function(b, idx) {
  return b[idx] << 24 | b[idx + 1] << 16 | b[idx + 2] << 8 | b[idx + 3];
};
function ReadShift(size, t) {
  var o = "", oI, oR, oo = [], w, vv, i, loc;
  switch (t) {
    case "dbcs":
      loc = this.l;
      if (has_buf && Buffer.isBuffer(this) && buf_utf16le) o = this.slice(this.l, this.l + 2 * size).toString("utf16le");
      else for (i = 0; i < size; ++i) {
        o += String.fromCharCode(__readUInt16LE(this, loc));
        loc += 2;
      }
      size *= 2;
      break;
    case "utf8":
      o = __utf8(this, this.l, this.l + size);
      break;
    case "utf16le":
      size *= 2;
      o = __utf16le(this, this.l, this.l + size);
      break;
    case "wstr":
      return ReadShift.call(this, size, "dbcs");
    case "lpstr-ansi":
      o = __lpstr(this, this.l);
      size = 4 + __readUInt32LE(this, this.l);
      break;
    case "lpstr-cp":
      o = __cpstr(this, this.l);
      size = 4 + __readUInt32LE(this, this.l);
      break;
    case "lpwstr":
      o = __lpwstr(this, this.l);
      size = 4 + 2 * __readUInt32LE(this, this.l);
      break;
    case "lpp4":
      size = 4 + __readUInt32LE(this, this.l);
      o = __lpp4(this, this.l);
      if (size & 2) size += 2;
      break;
    case "8lpp4":
      size = 4 + __readUInt32LE(this, this.l);
      o = __8lpp4(this, this.l);
      if (size & 3) size += 4 - (size & 3);
      break;
    case "cstr":
      size = 0;
      o = "";
      while ((w = __readUInt8(this, this.l + size++)) !== 0) oo.push(_getchar(w));
      o = oo.join("");
      break;
    case "_wstr":
      size = 0;
      o = "";
      while ((w = __readUInt16LE(this, this.l + size)) !== 0) {
        oo.push(_getchar(w));
        size += 2;
      }
      size += 2;
      o = oo.join("");
      break;
    case "dbcs-cont":
      o = "";
      loc = this.l;
      for (i = 0; i < size; ++i) {
        if (this.lens && this.lens.indexOf(loc) !== -1) {
          w = __readUInt8(this, loc);
          this.l = loc + 1;
          vv = ReadShift.call(this, size - i, w ? "dbcs-cont" : "sbcs-cont");
          return oo.join("") + vv;
        }
        oo.push(_getchar(__readUInt16LE(this, loc)));
        loc += 2;
      }
      o = oo.join("");
      size *= 2;
      break;
    case "cpstr":
    case "sbcs-cont":
      o = "";
      loc = this.l;
      for (i = 0; i != size; ++i) {
        if (this.lens && this.lens.indexOf(loc) !== -1) {
          w = __readUInt8(this, loc);
          this.l = loc + 1;
          vv = ReadShift.call(this, size - i, w ? "dbcs-cont" : "sbcs-cont");
          return oo.join("") + vv;
        }
        oo.push(_getchar(__readUInt8(this, loc)));
        loc += 1;
      }
      o = oo.join("");
      break;
    default:
      switch (size) {
        case 1:
          oI = __readUInt8(this, this.l);
          this.l++;
          return oI;
        case 2:
          oI = (t === "i" ? __readInt16LE : __readUInt16LE)(this, this.l);
          this.l += 2;
          return oI;
        case 4:
        case -4:
          if (t === "i" || (this[this.l + 3] & 128) === 0) {
            oI = (size > 0 ? __readInt32LE : __readInt32BE)(this, this.l);
            this.l += 4;
            return oI;
          } else {
            oR = __readUInt32LE(this, this.l);
            this.l += 4;
          }
          return oR;
        case 8:
        case -8:
          if (t === "f") {
            if (size == 8) oR = __double(this, this.l);
            else oR = __double([this[this.l + 7], this[this.l + 6], this[this.l + 5], this[this.l + 4], this[this.l + 3], this[this.l + 2], this[this.l + 1], this[this.l + 0]], 0);
            this.l += 8;
            return oR;
          } else size = 8;
        case 16:
          o = __hexlify(this, this.l, size);
          break;
      }
  }
  this.l += size;
  return o;
}
var __writeUInt32LE = function(b, val, idx) {
  b[idx] = val & 255;
  b[idx + 1] = val >>> 8 & 255;
  b[idx + 2] = val >>> 16 & 255;
  b[idx + 3] = val >>> 24 & 255;
};
var __writeInt32LE = function(b, val, idx) {
  b[idx] = val & 255;
  b[idx + 1] = val >> 8 & 255;
  b[idx + 2] = val >> 16 & 255;
  b[idx + 3] = val >> 24 & 255;
};
var __writeUInt16LE = function(b, val, idx) {
  b[idx] = val & 255;
  b[idx + 1] = val >>> 8 & 255;
};
function WriteShift(t, val, f) {
  var size = 0, i = 0;
  if (f === "dbcs") {
    for (i = 0; i != val.length; ++i) __writeUInt16LE(this, val.charCodeAt(i), this.l + 2 * i);
    size = 2 * val.length;
  } else if (f === "sbcs" || f == "cpstr") {
    {
      val = val.replace(/[^\x00-\x7F]/g, "_");
      for (i = 0; i != val.length; ++i) this[this.l + i] = val.charCodeAt(i) & 255;
      size = val.length;
    }
  } else if (f === "hex") {
    for (; i < t; ++i) {
      this[this.l++] = parseInt(val.slice(2 * i, 2 * i + 2), 16) || 0;
    }
    return this;
  } else if (f === "utf16le") {
    var end = Math.min(this.l + t, this.length);
    for (i = 0; i < Math.min(val.length, t); ++i) {
      var cc = val.charCodeAt(i);
      this[this.l++] = cc & 255;
      this[this.l++] = cc >> 8;
    }
    while (this.l < end) this[this.l++] = 0;
    return this;
  } else switch (t) {
    case 1:
      size = 1;
      this[this.l] = val & 255;
      break;
    case 2:
      size = 2;
      this[this.l] = val & 255;
      val >>>= 8;
      this[this.l + 1] = val & 255;
      break;
    case 3:
      size = 3;
      this[this.l] = val & 255;
      val >>>= 8;
      this[this.l + 1] = val & 255;
      val >>>= 8;
      this[this.l + 2] = val & 255;
      break;
    case 4:
      size = 4;
      __writeUInt32LE(this, val, this.l);
      break;
    case 8:
      size = 8;
      if (f === "f") {
        write_double_le(this, val, this.l);
        break;
      }
    case 16:
      break;
    case -4:
      size = 4;
      __writeInt32LE(this, val, this.l);
      break;
  }
  this.l += size;
  return this;
}
function CheckField(hexstr, fld) {
  var m = __hexlify(this, this.l, hexstr.length >> 1);
  if (m !== hexstr) throw new Error(fld + "Expected " + hexstr + " saw " + m);
  this.l += hexstr.length >> 1;
}
function prep_blob(blob, pos2) {
  blob.l = pos2;
  blob.read_shift = /*::(*/
  ReadShift;
  blob.chk = CheckField;
  blob.write_shift = WriteShift;
}
function parsenoop(blob, length) {
  blob.l += length;
}
function new_buf(sz) {
  var o = new_raw_buf(sz);
  prep_blob(o, 0);
  return o;
}
function recordhopper(data, cb, opts) {
  if (!data) return;
  var tmpbyte, cntbyte, length;
  prep_blob(data, data.l || 0);
  var L = data.length, RT = 0, tgt = 0;
  while (data.l < L) {
    RT = data.read_shift(1);
    if (RT & 128) RT = (RT & 127) + ((data.read_shift(1) & 127) << 7);
    var R = XLSBRecordEnum[RT] || XLSBRecordEnum[65535];
    tmpbyte = data.read_shift(1);
    length = tmpbyte & 127;
    for (cntbyte = 1; cntbyte < 4 && tmpbyte & 128; ++cntbyte) length += ((tmpbyte = data.read_shift(1)) & 127) << 7 * cntbyte;
    tgt = data.l + length;
    var d = R.f && R.f(data, length, opts);
    data.l = tgt;
    if (cb(d, R, RT)) return;
  }
}
function buf_array() {
  var bufs = [], blksz = has_buf ? 256 : 2048;
  var newblk = function ba_newblk(sz) {
    var o = new_buf(sz);
    prep_blob(o, 0);
    return o;
  };
  var curbuf = newblk(blksz);
  var endbuf = function ba_endbuf() {
    if (!curbuf) return;
    if (curbuf.l) {
      if (curbuf.length > curbuf.l) {
        curbuf = curbuf.slice(0, curbuf.l);
        curbuf.l = curbuf.length;
      }
      if (curbuf.length > 0) bufs.push(curbuf);
    }
    curbuf = null;
  };
  var next = function ba_next(sz) {
    if (curbuf && sz < curbuf.length - curbuf.l) return curbuf;
    endbuf();
    return curbuf = newblk(Math.max(sz + 1, blksz));
  };
  var end = function ba_end() {
    endbuf();
    return bconcat(bufs);
  };
  var push2 = function ba_push(buf) {
    endbuf();
    curbuf = buf;
    if (curbuf.l == null) curbuf.l = curbuf.length;
    next(blksz);
  };
  return { next, push: push2, end, _bufs: bufs };
}
function shift_cell_xls(cell, tgt, opts) {
  var out = dup(cell);
  if (tgt.s) {
    if (out.cRel) out.c += tgt.s.c;
    if (out.rRel) out.r += tgt.s.r;
  } else {
    if (out.cRel) out.c += tgt.c;
    if (out.rRel) out.r += tgt.r;
  }
  if (!opts || opts.biff < 12) {
    while (out.c >= 256) out.c -= 256;
    while (out.r >= 65536) out.r -= 65536;
  }
  return out;
}
function shift_range_xls(cell, range, opts) {
  var out = dup(cell);
  out.s = shift_cell_xls(out.s, range.s, opts);
  out.e = shift_cell_xls(out.e, range.s, opts);
  return out;
}
function encode_cell_xls(c2, biff) {
  if (c2.cRel && c2.c < 0) {
    c2 = dup(c2);
    while (c2.c < 0) c2.c += biff > 8 ? 16384 : 256;
  }
  if (c2.rRel && c2.r < 0) {
    c2 = dup(c2);
    while (c2.r < 0) c2.r += biff > 8 ? 1048576 : biff > 5 ? 65536 : 16384;
  }
  var s = encode_cell(c2);
  if (!c2.cRel && c2.cRel != null) s = fix_col(s);
  if (!c2.rRel && c2.rRel != null) s = fix_row(s);
  return s;
}
function encode_range_xls(r, opts) {
  if (r.s.r == 0 && !r.s.rRel) {
    if (r.e.r == (opts.biff >= 12 ? 1048575 : opts.biff >= 8 ? 65536 : 16384) && !r.e.rRel) {
      return (r.s.cRel ? "" : "$") + encode_col(r.s.c) + ":" + (r.e.cRel ? "" : "$") + encode_col(r.e.c);
    }
  }
  if (r.s.c == 0 && !r.s.cRel) {
    if (r.e.c == (opts.biff >= 12 ? 16383 : 255) && !r.e.cRel) {
      return (r.s.rRel ? "" : "$") + encode_row(r.s.r) + ":" + (r.e.rRel ? "" : "$") + encode_row(r.e.r);
    }
  }
  return encode_cell_xls(r.s, opts.biff) + ":" + encode_cell_xls(r.e, opts.biff);
}
function decode_row(rowstr) {
  return parseInt(unfix_row(rowstr), 10) - 1;
}
function encode_row(row) {
  return "" + (row + 1);
}
function fix_row(cstr) {
  return cstr.replace(/([A-Z]|^)(\d+)$/, "$1$$$2");
}
function unfix_row(cstr) {
  return cstr.replace(/\$(\d+)$/, "$1");
}
function decode_col(colstr) {
  var c2 = unfix_col(colstr), d = 0, i = 0;
  for (; i !== c2.length; ++i) d = 26 * d + c2.charCodeAt(i) - 64;
  return d - 1;
}
function encode_col(col) {
  if (col < 0) throw new Error("invalid column " + col);
  var s = "";
  for (++col; col; col = Math.floor((col - 1) / 26)) s = String.fromCharCode((col - 1) % 26 + 65) + s;
  return s;
}
function fix_col(cstr) {
  return cstr.replace(/^([A-Z])/, "$$$1");
}
function unfix_col(cstr) {
  return cstr.replace(/^\$([A-Z])/, "$1");
}
function split_cell(cstr) {
  return cstr.replace(/(\$?[A-Z]*)(\$?\d*)/, "$1,$2").split(",");
}
function decode_cell(cstr) {
  var R = 0, C2 = 0;
  for (var i = 0; i < cstr.length; ++i) {
    var cc = cstr.charCodeAt(i);
    if (cc >= 48 && cc <= 57) R = 10 * R + (cc - 48);
    else if (cc >= 65 && cc <= 90) C2 = 26 * C2 + (cc - 64);
  }
  return { c: C2 - 1, r: R - 1 };
}
function encode_cell(cell) {
  var col = cell.c + 1;
  var s = "";
  for (; col; col = (col - 1) / 26 | 0) s = String.fromCharCode((col - 1) % 26 + 65) + s;
  return s + (cell.r + 1);
}
function decode_range(range) {
  var idx = range.indexOf(":");
  if (idx == -1) return { s: decode_cell(range), e: decode_cell(range) };
  return { s: decode_cell(range.slice(0, idx)), e: decode_cell(range.slice(idx + 1)) };
}
function encode_range(cs, ce) {
  if (typeof ce === "undefined" || typeof ce === "number") {
    return encode_range(cs.s, cs.e);
  }
  if (typeof cs !== "string") cs = encode_cell(cs);
  if (typeof ce !== "string") ce = encode_cell(ce);
  return cs == ce ? cs : cs + ":" + ce;
}
function formula_quote_sheet_name(sname, opts) {
  if (!sname && !(opts && opts.biff <= 5 && opts.biff >= 2)) throw new Error("empty sheet name");
  if (/[^\w\u4E00-\u9FFF\u3040-\u30FF]/.test(sname)) return "'" + sname.replace(/'/g, "''") + "'";
  return sname;
}
function safe_decode_range(range) {
  var o = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
  var idx = 0, i = 0, cc = 0;
  var len = range.length;
  for (idx = 0; i < len; ++i) {
    if ((cc = range.charCodeAt(i) - 64) < 1 || cc > 26) break;
    idx = 26 * idx + cc;
  }
  o.s.c = --idx;
  for (idx = 0; i < len; ++i) {
    if ((cc = range.charCodeAt(i) - 48) < 0 || cc > 9) break;
    idx = 10 * idx + cc;
  }
  o.s.r = --idx;
  if (i === len || cc != 10) {
    o.e.c = o.s.c;
    o.e.r = o.s.r;
    return o;
  }
  ++i;
  for (idx = 0; i != len; ++i) {
    if ((cc = range.charCodeAt(i) - 64) < 1 || cc > 26) break;
    idx = 26 * idx + cc;
  }
  o.e.c = --idx;
  for (idx = 0; i != len; ++i) {
    if ((cc = range.charCodeAt(i) - 48) < 0 || cc > 9) break;
    idx = 10 * idx + cc;
  }
  o.e.r = --idx;
  return o;
}
function safe_format_cell(cell, v2) {
  var q = cell.t == "d" && v2 instanceof Date;
  if (cell.z != null) try {
    return cell.w = SSF_format(cell.z, q ? datenum(v2) : v2);
  } catch (e) {
  }
  try {
    return cell.w = SSF_format((cell.XF || {}).numFmtId || (q ? 14 : 0), q ? datenum(v2) : v2);
  } catch (e) {
    return "" + v2;
  }
}
function format_cell(cell, v2, o) {
  if (cell == null || cell.t == null || cell.t == "z") return "";
  if (cell.w !== void 0) return cell.w;
  if (cell.t == "d" && !cell.z && o && o.dateNF) cell.z = o.dateNF;
  if (cell.t == "e") return BErr[cell.v] || cell.v;
  if (v2 == void 0) return safe_format_cell(cell, cell.v);
  return safe_format_cell(cell, v2);
}
function sheet_to_workbook(sheet, opts) {
  var n = opts && opts.sheet ? opts.sheet : "Sheet1";
  var sheets = {};
  sheets[n] = sheet;
  return { SheetNames: [n], Sheets: sheets };
}
function sheet_new(opts) {
  var out = {};
  var o = opts || {};
  if (o.dense) out["!data"] = [];
  return out;
}
function sheet_add_aoa(_ws, data, opts) {
  var o = opts || {};
  var dense = _ws ? _ws["!data"] != null : o.dense;
  var ws = _ws || {};
  if (dense && !ws["!data"]) ws["!data"] = [];
  var _R = 0, _C = 0;
  if (o.origin != null) {
    if (typeof o.origin == "number") _R = o.origin;
    else {
      var _origin = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;
      _R = _origin.r;
      _C = _origin.c;
    }
  }
  var range = { s: { c: 1e7, r: 1e7 }, e: { c: 0, r: 0 } };
  if (ws["!ref"]) {
    var _range = safe_decode_range(ws["!ref"]);
    range.s.c = _range.s.c;
    range.s.r = _range.s.r;
    range.e.c = Math.max(range.e.c, _range.e.c);
    range.e.r = Math.max(range.e.r, _range.e.r);
    if (_R == -1) range.e.r = _R = ws["!ref"] ? _range.e.r + 1 : 0;
  } else {
    range.s.c = range.e.c = range.s.r = range.e.r = 0;
  }
  var row = [], seen2 = false;
  for (var R = 0; R != data.length; ++R) {
    if (!data[R]) continue;
    if (!Array.isArray(data[R])) throw new Error("aoa_to_sheet expects an array of arrays");
    var __R = _R + R, __Rstr = "" + (__R + 1);
    if (dense) {
      if (!ws["!data"][__R]) ws["!data"][__R] = [];
      row = ws["!data"][__R];
    }
    for (var C2 = 0; C2 != data[R].length; ++C2) {
      if (typeof data[R][C2] === "undefined") continue;
      var cell = { v: data[R][C2] };
      var __C = _C + C2;
      if (range.s.r > __R) range.s.r = __R;
      if (range.s.c > __C) range.s.c = __C;
      if (range.e.r < __R) range.e.r = __R;
      if (range.e.c < __C) range.e.c = __C;
      seen2 = true;
      if (data[R][C2] && typeof data[R][C2] === "object" && !Array.isArray(data[R][C2]) && !(data[R][C2] instanceof Date)) cell = data[R][C2];
      else {
        if (Array.isArray(cell.v)) {
          cell.f = data[R][C2][1];
          cell.v = cell.v[0];
        }
        if (cell.v === null) {
          if (cell.f) cell.t = "n";
          else if (o.nullError) {
            cell.t = "e";
            cell.v = 0;
          } else if (!o.sheetStubs) continue;
          else cell.t = "z";
        } else if (typeof cell.v === "number") cell.t = "n";
        else if (typeof cell.v === "boolean") cell.t = "b";
        else if (cell.v instanceof Date) {
          cell.z = o.dateNF || table_fmt[14];
          if (!o.UTC) cell.v = local_to_utc(cell.v);
          if (o.cellDates) {
            cell.t = "d";
            cell.w = SSF_format(cell.z, datenum(cell.v, o.date1904));
          } else {
            cell.t = "n";
            cell.v = datenum(cell.v, o.date1904);
            cell.w = SSF_format(cell.z, cell.v);
          }
        } else cell.t = "s";
      }
      if (dense) {
        if (row[__C] && row[__C].z) cell.z = row[__C].z;
        row[__C] = cell;
      } else {
        var cell_ref = encode_col(__C) + __Rstr;
        if (ws[cell_ref] && ws[cell_ref].z) cell.z = ws[cell_ref].z;
        ws[cell_ref] = cell;
      }
    }
  }
  if (seen2 && range.s.c < 104e5) ws["!ref"] = encode_range(range);
  return ws;
}
function aoa_to_sheet(data, opts) {
  return sheet_add_aoa(null, data, opts);
}
function parse_Int32LE(data) {
  return data.read_shift(4, "i");
}
function parse_XLWideString(data) {
  var cchCharacters = data.read_shift(4);
  return cchCharacters === 0 ? "" : data.read_shift(cchCharacters, "dbcs");
}
function parse_StrRun(data) {
  return { ich: data.read_shift(2), ifnt: data.read_shift(2) };
}
function parse_RichStr(data, length) {
  var start = data.l;
  var flags = data.read_shift(1);
  var str = parse_XLWideString(data);
  var rgsStrRun = [];
  var z = { t: str, h: str };
  if ((flags & 1) !== 0) {
    var dwSizeStrRun = data.read_shift(4);
    for (var i = 0; i != dwSizeStrRun; ++i) rgsStrRun.push(parse_StrRun(data));
    z.r = rgsStrRun;
  } else z.r = [{ ich: 0, ifnt: 0 }];
  data.l = start + length;
  return z;
}
var parse_BrtCommentText = parse_RichStr;
function parse_XLSBCell(data) {
  var col = data.read_shift(4);
  var iStyleRef = data.read_shift(2);
  iStyleRef += data.read_shift(1) << 16;
  data.l++;
  return { c: col, iStyleRef };
}
function parse_XLSBShortCell(data) {
  var iStyleRef = data.read_shift(2);
  iStyleRef += data.read_shift(1) << 16;
  data.l++;
  return { c: -1, iStyleRef };
}
var parse_XLSBCodeName = parse_XLWideString;
function parse_XLNullableWideString(data) {
  var cchCharacters = data.read_shift(4);
  return cchCharacters === 0 || cchCharacters === 4294967295 ? "" : data.read_shift(cchCharacters, "dbcs");
}
var parse_XLNameWideString = parse_XLWideString;
var parse_RelID = parse_XLNullableWideString;
function parse_RkNumber(data) {
  var b = data.slice(data.l, data.l + 4);
  var fX100 = b[0] & 1, fInt = b[0] & 2;
  data.l += 4;
  var RK = fInt === 0 ? __double([0, 0, 0, 0, b[0] & 252, b[1], b[2], b[3]], 0) : __readInt32LE(b, 0) >> 2;
  return fX100 ? RK / 100 : RK;
}
function parse_RfX(data) {
  var cell = { s: {}, e: {} };
  cell.s.r = data.read_shift(4);
  cell.e.r = data.read_shift(4);
  cell.s.c = data.read_shift(4);
  cell.e.c = data.read_shift(4);
  return cell;
}
var parse_UncheckedRfX = parse_RfX;
function parse_Xnum(data) {
  if (data.length - data.l < 8) throw "XLS Xnum Buffer underflow";
  return data.read_shift(8, "f");
}
function parse_BrtColor(data) {
  var out = {};
  var d = data.read_shift(1);
  var xColorType = d >>> 1;
  var index2 = data.read_shift(1);
  var nTS = data.read_shift(2, "i");
  var bR = data.read_shift(1);
  var bG = data.read_shift(1);
  var bB = data.read_shift(1);
  data.l++;
  switch (xColorType) {
    case 0:
      out.auto = 1;
      break;
    case 1:
      out.index = index2;
      var icv = XLSIcv[index2];
      if (icv) out.rgb = rgb2Hex(icv);
      break;
    case 2:
      out.rgb = rgb2Hex([bR, bG, bB]);
      break;
    case 3:
      out.theme = index2;
      break;
  }
  if (nTS != 0) out.tint = nTS > 0 ? nTS / 32767 : nTS / 32768;
  return out;
}
function parse_FontFlags(data) {
  var d = data.read_shift(1);
  data.l++;
  var out = {
    fBold: d & 1,
    fItalic: d & 2,
    fUnderline: d & 4,
    fStrikeout: d & 8,
    fOutline: d & 16,
    fShadow: d & 32,
    fCondense: d & 64,
    fExtend: d & 128
  };
  return out;
}
function parse_ClipboardFormatOrString(o, w) {
  var ClipFmt = { 2: "BITMAP", 3: "METAFILEPICT", 8: "DIB", 14: "ENHMETAFILE" };
  var m = o.read_shift(4);
  switch (m) {
    case 0:
      return "";
    case 4294967295:
    case 4294967294:
      return ClipFmt[o.read_shift(4)] || "";
  }
  if (m > 400) throw new Error("Unsupported Clipboard: " + m.toString(16));
  o.l -= 4;
  return o.read_shift(0, w == 1 ? "lpstr" : "lpwstr");
}
function parse_ClipboardFormatOrAnsiString(o) {
  return parse_ClipboardFormatOrString(o, 1);
}
function parse_ClipboardFormatOrUnicodeString(o) {
  return parse_ClipboardFormatOrString(o, 2);
}
var VT_I2 = 2;
var VT_I4 = 3;
var VT_BOOL = 11;
var VT_VARIANT = 12;
var VT_UI4 = 19;
var VT_FILETIME = 64;
var VT_BLOB = 65;
var VT_CF = 71;
var VT_VECTOR_VARIANT = 4108;
var VT_VECTOR_LPSTR = 4126;
var VT_STRING = 80;
var VT_USTR = 81;
var VT_CUSTOM = [VT_STRING, VT_USTR];
var DocSummaryPIDDSI = {
  1: { n: "CodePage", t: VT_I2 },
  2: { n: "Category", t: VT_STRING },
  3: { n: "PresentationFormat", t: VT_STRING },
  4: { n: "ByteCount", t: VT_I4 },
  5: { n: "LineCount", t: VT_I4 },
  6: { n: "ParagraphCount", t: VT_I4 },
  7: { n: "SlideCount", t: VT_I4 },
  8: { n: "NoteCount", t: VT_I4 },
  9: { n: "HiddenCount", t: VT_I4 },
  10: { n: "MultimediaClipCount", t: VT_I4 },
  11: { n: "ScaleCrop", t: VT_BOOL },
  12: {
    n: "HeadingPairs",
    t: VT_VECTOR_VARIANT
    /* VT_VECTOR | VT_VARIANT */
  },
  13: {
    n: "TitlesOfParts",
    t: VT_VECTOR_LPSTR
    /* VT_VECTOR | VT_LPSTR */
  },
  14: { n: "Manager", t: VT_STRING },
  15: { n: "Company", t: VT_STRING },
  16: { n: "LinksUpToDate", t: VT_BOOL },
  17: { n: "CharacterCount", t: VT_I4 },
  19: { n: "SharedDoc", t: VT_BOOL },
  22: { n: "HyperlinksChanged", t: VT_BOOL },
  23: { n: "AppVersion", t: VT_I4, p: "version" },
  24: { n: "DigSig", t: VT_BLOB },
  26: { n: "ContentType", t: VT_STRING },
  27: { n: "ContentStatus", t: VT_STRING },
  28: { n: "Language", t: VT_STRING },
  29: { n: "Version", t: VT_STRING },
  255: {},
  /* [MS-OLEPS] 2.18 */
  2147483648: { n: "Locale", t: VT_UI4 },
  2147483651: { n: "Behavior", t: VT_UI4 },
  1919054434: {}
};
var SummaryPIDSI = {
  1: { n: "CodePage", t: VT_I2 },
  2: { n: "Title", t: VT_STRING },
  3: { n: "Subject", t: VT_STRING },
  4: { n: "Author", t: VT_STRING },
  5: { n: "Keywords", t: VT_STRING },
  6: { n: "Comments", t: VT_STRING },
  7: { n: "Template", t: VT_STRING },
  8: { n: "LastAuthor", t: VT_STRING },
  9: { n: "RevNumber", t: VT_STRING },
  10: { n: "EditTime", t: VT_FILETIME },
  11: { n: "LastPrinted", t: VT_FILETIME },
  12: { n: "CreatedDate", t: VT_FILETIME },
  13: { n: "ModifiedDate", t: VT_FILETIME },
  14: { n: "PageCount", t: VT_I4 },
  15: { n: "WordCount", t: VT_I4 },
  16: { n: "CharCount", t: VT_I4 },
  17: { n: "Thumbnail", t: VT_CF },
  18: { n: "Application", t: VT_STRING },
  19: { n: "DocSecurity", t: VT_I4 },
  255: {},
  /* [MS-OLEPS] 2.18 */
  2147483648: { n: "Locale", t: VT_UI4 },
  2147483651: { n: "Behavior", t: VT_UI4 },
  1919054434: {}
};
var CountryEnum = {
  1: "US",
  // United States
  2: "CA",
  // Canada
  3: "",
  // Latin America (except Brazil)
  7: "RU",
  // Russia
  20: "EG",
  // Egypt
  30: "GR",
  // Greece
  31: "NL",
  // Netherlands
  32: "BE",
  // Belgium
  33: "FR",
  // France
  34: "ES",
  // Spain
  36: "HU",
  // Hungary
  39: "IT",
  // Italy
  41: "CH",
  // Switzerland
  43: "AT",
  // Austria
  44: "GB",
  // United Kingdom
  45: "DK",
  // Denmark
  46: "SE",
  // Sweden
  47: "NO",
  // Norway
  48: "PL",
  // Poland
  49: "DE",
  // Germany
  52: "MX",
  // Mexico
  55: "BR",
  // Brazil
  61: "AU",
  // Australia
  64: "NZ",
  // New Zealand
  66: "TH",
  // Thailand
  81: "JP",
  // Japan
  82: "KR",
  // Korea
  84: "VN",
  // Viet Nam
  86: "CN",
  // China
  90: "TR",
  // Turkey
  105: "JS",
  // Ramastan
  213: "DZ",
  // Algeria
  216: "MA",
  // Morocco
  218: "LY",
  // Libya
  351: "PT",
  // Portugal
  354: "IS",
  // Iceland
  358: "FI",
  // Finland
  420: "CZ",
  // Czech Republic
  886: "TW",
  // Taiwan
  961: "LB",
  // Lebanon
  962: "JO",
  // Jordan
  963: "SY",
  // Syria
  964: "IQ",
  // Iraq
  965: "KW",
  // Kuwait
  966: "SA",
  // Saudi Arabia
  971: "AE",
  // United Arab Emirates
  972: "IL",
  // Israel
  974: "QA",
  // Qatar
  981: "IR",
  // Iran
  65535: "US"
  // United States
};
var XLSFillPattern = [
  null,
  "solid",
  "mediumGray",
  "darkGray",
  "lightGray",
  "darkHorizontal",
  "darkVertical",
  "darkDown",
  "darkUp",
  "darkGrid",
  "darkTrellis",
  "lightHorizontal",
  "lightVertical",
  "lightDown",
  "lightUp",
  "lightGrid",
  "lightTrellis",
  "gray125",
  "gray0625"
];
function rgbify(arr) {
  return arr.map(function(x) {
    return [x >> 16 & 255, x >> 8 & 255, x & 255];
  });
}
var _XLSIcv = /* @__PURE__ */ rgbify([
  /* Color Constants */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  /* Overridable Defaults */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  8388608,
  32768,
  128,
  8421376,
  8388736,
  32896,
  12632256,
  8421504,
  10066431,
  10040166,
  16777164,
  13434879,
  6684774,
  16744576,
  26316,
  13421823,
  128,
  16711935,
  16776960,
  65535,
  8388736,
  8388608,
  32896,
  255,
  52479,
  13434879,
  13434828,
  16777113,
  10079487,
  16751052,
  13408767,
  16764057,
  3368703,
  3394764,
  10079232,
  16763904,
  16750848,
  16737792,
  6710937,
  9868950,
  13158,
  3381606,
  13056,
  3355392,
  10040064,
  10040166,
  3355545,
  3355443,
  /* Other entries to appease BIFF8/12 */
  0,
  /* 0x40 icvForeground ?? */
  16777215,
  /* 0x41 icvBackground ?? */
  0,
  /* 0x42 icvFrame ?? */
  0,
  /* 0x43 icv3D ?? */
  0,
  /* 0x44 icv3DText ?? */
  0,
  /* 0x45 icv3DHilite ?? */
  0,
  /* 0x46 icv3DShadow ?? */
  0,
  /* 0x47 icvHilite ?? */
  0,
  /* 0x48 icvCtlText ?? */
  0,
  /* 0x49 icvCtlScrl ?? */
  0,
  /* 0x4A icvCtlInv ?? */
  0,
  /* 0x4B icvCtlBody ?? */
  0,
  /* 0x4C icvCtlFrame ?? */
  0,
  /* 0x4D icvCtlFore ?? */
  0,
  /* 0x4E icvCtlBack ?? */
  0,
  /* 0x4F icvCtlNeutral */
  0,
  /* 0x50 icvInfoBk ?? */
  0
  /* 0x51 icvInfoText ?? */
]);
var XLSIcv = /* @__PURE__ */ dup(_XLSIcv);
var BErr = {
  0: "#NULL!",
  7: "#DIV/0!",
  15: "#VALUE!",
  23: "#REF!",
  29: "#NAME?",
  36: "#NUM!",
  42: "#N/A",
  43: "#GETTING_DATA",
  255: "#WTF?"
};
var RBErr = {
  "#NULL!": 0,
  "#DIV/0!": 7,
  "#VALUE!": 15,
  "#REF!": 23,
  "#NAME?": 29,
  "#NUM!": 36,
  "#N/A": 42,
  "#GETTING_DATA": 43,
  "#WTF?": 255
};
var XLSLblBuiltIn = [
  "_xlnm.Consolidate_Area",
  "_xlnm.Auto_Open",
  "_xlnm.Auto_Close",
  "_xlnm.Extract",
  "_xlnm.Database",
  "_xlnm.Criteria",
  "_xlnm.Print_Area",
  "_xlnm.Print_Titles",
  "_xlnm.Recorder",
  "_xlnm.Data_Form",
  "_xlnm.Auto_Activate",
  "_xlnm.Auto_Deactivate",
  "_xlnm.Sheet_Title",
  "_xlnm._FilterDatabase"
];
var ct2type = {
  /* Workbook */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",
  "application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",
  /* Worksheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",
  "application/vnd.ms-excel.worksheet": "sheets",
  "application/vnd.ms-excel.binIndexWs": "TODO",
  /* Binary Index */
  /* Chartsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",
  "application/vnd.ms-excel.chartsheet": "charts",
  /* Macrosheet */
  "application/vnd.ms-excel.macrosheet+xml": "macros",
  "application/vnd.ms-excel.macrosheet": "macros",
  "application/vnd.ms-excel.intlmacrosheet": "TODO",
  "application/vnd.ms-excel.binIndexMs": "TODO",
  /* Binary Index */
  /* Dialogsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",
  "application/vnd.ms-excel.dialogsheet": "dialogs",
  /* Shared Strings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",
  "application/vnd.ms-excel.sharedStrings": "strs",
  /* Styles */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",
  "application/vnd.ms-excel.styles": "styles",
  /* File Properties */
  "application/vnd.openxmlformats-package.core-properties+xml": "coreprops",
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",
  /* Custom Data Properties */
  "application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",
  /* Comments */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",
  "application/vnd.ms-excel.comments": "comments",
  "application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",
  "application/vnd.ms-excel.person+xml": "people",
  /* Metadata (Stock/Geography and Dynamic Array) */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",
  "application/vnd.ms-excel.sheetMetadata": "metadata",
  /* PivotTable */
  "application/vnd.ms-excel.pivotTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",
  /* Chart Objects */
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",
  /* Chart Colors */
  "application/vnd.ms-office.chartcolorstyle+xml": "TODO",
  /* Chart Style */
  "application/vnd.ms-office.chartstyle+xml": "TODO",
  /* Chart Advanced */
  "application/vnd.ms-office.chartex+xml": "TODO",
  /* Calculation Chain */
  "application/vnd.ms-excel.calcChain": "calcchains",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",
  /* Printer Settings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",
  /* ActiveX */
  "application/vnd.ms-office.activeX": "TODO",
  "application/vnd.ms-office.activeX+xml": "TODO",
  /* Custom Toolbars */
  "application/vnd.ms-excel.attachedToolbars": "TODO",
  /* External Data Connections */
  "application/vnd.ms-excel.connections": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",
  /* External Links */
  "application/vnd.ms-excel.externalLink": "links",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",
  /* PivotCache */
  "application/vnd.ms-excel.pivotCacheDefinition": "TODO",
  "application/vnd.ms-excel.pivotCacheRecords": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",
  /* Query Table */
  "application/vnd.ms-excel.queryTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",
  /* Shared Workbook */
  "application/vnd.ms-excel.userNames": "TODO",
  "application/vnd.ms-excel.revisionHeaders": "TODO",
  "application/vnd.ms-excel.revisionLog": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",
  /* Single Cell Table */
  "application/vnd.ms-excel.tableSingleCells": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",
  /* Slicer */
  "application/vnd.ms-excel.slicer": "TODO",
  "application/vnd.ms-excel.slicerCache": "TODO",
  "application/vnd.ms-excel.slicer+xml": "TODO",
  "application/vnd.ms-excel.slicerCache+xml": "TODO",
  /* Sort Map */
  "application/vnd.ms-excel.wsSortMap": "TODO",
  /* Table */
  "application/vnd.ms-excel.table": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",
  /* Themes */
  "application/vnd.openxmlformats-officedocument.theme+xml": "themes",
  /* Theme Override */
  "application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",
  /* Timeline */
  "application/vnd.ms-excel.Timeline+xml": "TODO",
  /* verify */
  "application/vnd.ms-excel.TimelineCache+xml": "TODO",
  /* verify */
  /* VBA */
  "application/vnd.ms-office.vbaProject": "vba",
  "application/vnd.ms-office.vbaProjectSignature": "TODO",
  /* Volatile Dependencies */
  "application/vnd.ms-office.volatileDependencies": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",
  /* Control Properties */
  "application/vnd.ms-excel.controlproperties+xml": "TODO",
  /* Data Model */
  "application/vnd.openxmlformats-officedocument.model+data": "TODO",
  /* Survey */
  "application/vnd.ms-excel.Survey+xml": "TODO",
  /* Drawing */
  "application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",
  /* VML */
  "application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",
  "application/vnd.openxmlformats-package.relationships+xml": "rels",
  "application/vnd.openxmlformats-officedocument.oleObject": "TODO",
  /* Image */
  "image/png": "TODO",
  "sheet": "js"
};
function new_ct() {
  return {
    workbooks: [],
    sheets: [],
    charts: [],
    dialogs: [],
    macros: [],
    rels: [],
    strs: [],
    comments: [],
    threadedcomments: [],
    links: [],
    coreprops: [],
    extprops: [],
    custprops: [],
    themes: [],
    styles: [],
    calcchains: [],
    vba: [],
    drawings: [],
    metadata: [],
    people: [],
    TODO: [],
    xmlns: ""
  };
}
function parse_ct(data) {
  var ct = new_ct();
  if (!data || !data.match) return ct;
  var ctext = {};
  (data.match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    switch (y[0].replace(nsregex, "<")) {
      case "<?xml":
        break;
      case "<Types":
        ct.xmlns = y["xmlns" + (y[0].match(/<(\w+):/) || ["", ""])[1]];
        break;
      case "<Default":
        ctext[y.Extension.toLowerCase()] = y.ContentType;
        break;
      case "<Override":
        if (ct[ct2type[y.ContentType]] !== void 0) ct[ct2type[y.ContentType]].push(y.PartName);
        break;
    }
  });
  if (ct.xmlns !== XMLNS.CT) throw new Error("Unknown Namespace: " + ct.xmlns);
  ct.calcchain = ct.calcchains.length > 0 ? ct.calcchains[0] : "";
  ct.sst = ct.strs.length > 0 ? ct.strs[0] : "";
  ct.style = ct.styles.length > 0 ? ct.styles[0] : "";
  ct.defaults = ctext;
  delete ct.calcchains;
  return ct;
}
var RELS = {
  WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  SHEET: "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
  VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
  XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",
  XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",
  XLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",
  CXML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",
  CXMLP: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps",
  CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
  SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
  STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
  THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
  CHART: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",
  CHARTEX: "http://schemas.microsoft.com/office/2014/relationships/chartEx",
  CS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet",
  WS: [
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
    "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"
  ],
  DS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet",
  MS: "http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet",
  IMG: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
  DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
  XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",
  TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",
  PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",
  CONN: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/connections",
  VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
};
function get_rels_path(file) {
  var n = file.lastIndexOf("/");
  return file.slice(0, n + 1) + "_rels/" + file.slice(n + 1) + ".rels";
}
function parse_rels(data, currentFilePath) {
  var rels = { "!id": {} };
  if (!data) return rels;
  if (currentFilePath.charAt(0) !== "/") {
    currentFilePath = "/" + currentFilePath;
  }
  var hash = {};
  (data.match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    if (y[0] === "<Relationship") {
      var rel = {};
      rel.Type = y.Type;
      rel.Target = unescapexml(y.Target);
      rel.Id = y.Id;
      if (y.TargetMode) rel.TargetMode = y.TargetMode;
      var canonictarget = y.TargetMode === "External" ? y.Target : resolve_path(y.Target, currentFilePath);
      rels[canonictarget] = rel;
      hash[y.Id] = rel;
    }
  });
  rels["!id"] = hash;
  return rels;
}
var CT_ODS = "application/vnd.oasis.opendocument.spreadsheet";
function parse_manifest(d, opts) {
  var str = xlml_normalize(d);
  var Rn;
  var FEtag;
  while (Rn = xlmlregex.exec(str))
    switch (Rn[3]) {
      case "manifest":
        break;
      case "file-entry":
        FEtag = parsexmltag(Rn[0], false);
        if (FEtag.path == "/" && FEtag.type !== CT_ODS)
          throw new Error("This OpenDocument is not a spreadsheet");
        break;
      case "encryption-data":
      case "algorithm":
      case "start-key-generation":
      case "key-derivation":
        throw new Error("Unsupported ODS Encryption");
      default:
        if (opts && opts.WTF)
          throw Rn;
    }
}
var CORE_PROPS = [
  ["cp:category", "Category"],
  ["cp:contentStatus", "ContentStatus"],
  ["cp:keywords", "Keywords"],
  ["cp:lastModifiedBy", "LastAuthor"],
  ["cp:lastPrinted", "LastPrinted"],
  ["cp:revision", "RevNumber"],
  ["cp:version", "Version"],
  ["dc:creator", "Author"],
  ["dc:description", "Comments"],
  ["dc:identifier", "Identifier"],
  ["dc:language", "Language"],
  ["dc:subject", "Subject"],
  ["dc:title", "Title"],
  ["dcterms:created", "CreatedDate", "date"],
  ["dcterms:modified", "ModifiedDate", "date"]
];
function parse_core_props(data) {
  var p = {};
  data = utf8read(data);
  for (var i = 0; i < CORE_PROPS.length; ++i) {
    var f = CORE_PROPS[i], cur = str_match_xml(data, f[0]);
    if (cur != null && cur.length > 0) p[f[1]] = unescapexml(cur[1]);
    if (f[2] === "date" && p[f[1]]) p[f[1]] = parseDate(p[f[1]]);
  }
  return p;
}
var EXT_PROPS = [
  ["Application", "Application", "string"],
  ["AppVersion", "AppVersion", "string"],
  ["Company", "Company", "string"],
  ["DocSecurity", "DocSecurity", "string"],
  ["Manager", "Manager", "string"],
  ["HyperlinksChanged", "HyperlinksChanged", "bool"],
  ["SharedDoc", "SharedDoc", "bool"],
  ["LinksUpToDate", "LinksUpToDate", "bool"],
  ["ScaleCrop", "ScaleCrop", "bool"],
  ["HeadingPairs", "HeadingPairs", "raw"],
  ["TitlesOfParts", "TitlesOfParts", "raw"]
];
function load_props_pairs(HP, TOP, props, opts) {
  var v2 = [];
  if (typeof HP == "string") v2 = parseVector(HP, opts);
  else for (var j = 0; j < HP.length; ++j) v2 = v2.concat(HP[j].map(function(hp) {
    return { v: hp };
  }));
  var parts = typeof TOP == "string" ? parseVector(TOP, opts).map(function(x) {
    return x.v;
  }) : TOP;
  var idx = 0, len = 0;
  if (parts.length > 0) for (var i = 0; i !== v2.length; i += 2) {
    len = +v2[i + 1].v;
    switch (v2[i].v) {
      case "Worksheets":
      case "":
      case "":
      case " ":
      case "":
      case " ":
      case "Arbeitsbltter":
      case "alma Sayfalar":
      case "Feuilles de calcul":
      case "Fogli di lavoro":
      case "Folhas de clculo":
      case "Planilhas":
      case "Regneark":
      case "Hojas de clculo":
      case "Werkbladen":
        props.Worksheets = len;
        props.SheetNames = parts.slice(idx, idx + len);
        break;
      case "Named Ranges":
      case "Rangos con nombre":
      case "":
      case "Benannte Bereiche":
      case "Navngivne omrder":
        props.NamedRanges = len;
        props.DefinedNames = parts.slice(idx, idx + len);
        break;
      case "Charts":
      case "Diagramme":
        props.Chartsheets = len;
        props.ChartNames = parts.slice(idx, idx + len);
        break;
    }
    idx += len;
  }
}
function parse_ext_props(data, p, opts) {
  var q = {};
  if (!p) p = {};
  data = utf8read(data);
  EXT_PROPS.forEach(function(f) {
    var xml = (str_match_xml_ns(data, f[0]) || [])[1];
    switch (f[2]) {
      case "string":
        if (xml) p[f[1]] = unescapexml(xml);
        break;
      case "bool":
        p[f[1]] = xml === "true";
        break;
      case "raw":
        var cur = str_match_xml(data, f[0]);
        if (cur && cur.length > 0) q[f[1]] = cur[1];
        break;
    }
  });
  if (q.HeadingPairs && q.TitlesOfParts) load_props_pairs(q.HeadingPairs, q.TitlesOfParts, p, opts);
  return p;
}
var custregex = /<[^<>]+>[^<]*/g;
function parse_cust_props(data, opts) {
  var p = {}, name = "";
  var m = data.match(custregex);
  if (m) for (var i = 0; i != m.length; ++i) {
    var x = m[i], y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<?xml":
        break;
      case "<Properties":
        break;
      case "<property":
        name = unescapexml(y.name);
        break;
      case "</property>":
        name = null;
        break;
      default:
        if (x.indexOf("<vt:") === 0) {
          var toks = x.split(">");
          var type = toks[0].slice(4), text = toks[1];
          switch (type) {
            case "lpstr":
            case "bstr":
            case "lpwstr":
              p[name] = unescapexml(text);
              break;
            case "bool":
              p[name] = parsexmlbool(text);
              break;
            case "i1":
            case "i2":
            case "i4":
            case "i8":
            case "int":
            case "uint":
              p[name] = parseInt(text, 10);
              break;
            case "r4":
            case "r8":
            case "decimal":
              p[name] = parseFloat(text);
              break;
            case "filetime":
            case "date":
              p[name] = parseDate(text);
              break;
            case "cy":
            case "error":
              p[name] = unescapexml(text);
              break;
            default:
              if (type.slice(-1) == "/") break;
              if (opts.WTF && typeof console !== "undefined") console.warn("Unexpected", x, type, toks);
          }
        } else if (x.slice(0, 2) === "</") ;
        else if (opts.WTF) throw new Error(x);
    }
  }
  return p;
}
var XLMLDocPropsMap = {
  Title: "Title",
  Subject: "Subject",
  Author: "Author",
  Keywords: "Keywords",
  Comments: "Description",
  LastAuthor: "LastAuthor",
  RevNumber: "Revision",
  Application: "AppName",
  /* TotalTime: 'TotalTime', */
  LastPrinted: "LastPrinted",
  CreatedDate: "Created",
  ModifiedDate: "LastSaved",
  /* Pages */
  /* Words */
  /* Characters */
  Category: "Category",
  /* PresentationFormat */
  Manager: "Manager",
  Company: "Company",
  /* Guid */
  /* HyperlinkBase */
  /* Bytes */
  /* Lines */
  /* Paragraphs */
  /* CharactersWithSpaces */
  AppVersion: "Version",
  ContentStatus: "ContentStatus",
  /* NOTE: missing from schema */
  Identifier: "Identifier",
  /* NOTE: missing from schema */
  Language: "Language"
  /* NOTE: missing from schema */
};
var evert_XLMLDPM;
function xlml_set_prop(Props, tag, val) {
  if (!evert_XLMLDPM) evert_XLMLDPM = evert(XLMLDocPropsMap);
  tag = evert_XLMLDPM[tag] || tag;
  Props[tag] = val;
}
function parse_FILETIME(blob) {
  var dwLowDateTime = blob.read_shift(4), dwHighDateTime = blob.read_shift(4);
  return new Date((dwHighDateTime / 1e7 * Math.pow(2, 32) + dwLowDateTime / 1e7 - 11644473600) * 1e3).toISOString().replace(/\.000/, "");
}
function parse_lpstr(blob, type, pad) {
  var start = blob.l;
  var str = blob.read_shift(0, "lpstr-cp");
  if (pad) while (blob.l - start & 3) ++blob.l;
  return str;
}
function parse_lpwstr(blob, type, pad) {
  var str = blob.read_shift(0, "lpwstr");
  return str;
}
function parse_VtStringBase(blob, stringType, pad) {
  if (stringType === 31) return parse_lpwstr(blob);
  return parse_lpstr(blob, stringType, pad);
}
function parse_VtString(blob, t, pad) {
  return parse_VtStringBase(blob, t, pad === false ? 0 : 4);
}
function parse_VtUnalignedString(blob, t) {
  if (!t) throw new Error("VtUnalignedString must have positive length");
  return parse_VtStringBase(blob, t, 0);
}
function parse_VtVecLpwstrValue(blob) {
  var length = blob.read_shift(4);
  var ret = [];
  for (var i = 0; i != length; ++i) {
    var start = blob.l;
    ret[i] = blob.read_shift(0, "lpwstr").replace(chr0, "");
    if (blob.l - start & 2) blob.l += 2;
  }
  return ret;
}
function parse_VtVecUnalignedLpstrValue(blob) {
  var length = blob.read_shift(4);
  var ret = [];
  for (var i = 0; i != length; ++i) ret[i] = blob.read_shift(0, "lpstr-cp").replace(chr0, "");
  return ret;
}
function parse_VtHeadingPair(blob) {
  var start = blob.l;
  var headingString = parse_TypedPropertyValue(blob, VT_USTR);
  if (blob[blob.l] == 0 && blob[blob.l + 1] == 0 && blob.l - start & 2) blob.l += 2;
  var headerParts = parse_TypedPropertyValue(blob, VT_I4);
  return [headingString, headerParts];
}
function parse_VtVecHeadingPairValue(blob) {
  var cElements = blob.read_shift(4);
  var out = [];
  for (var i = 0; i < cElements / 2; ++i) out.push(parse_VtHeadingPair(blob));
  return out;
}
function parse_dictionary(blob, CodePage) {
  var cnt = blob.read_shift(4);
  var dict = {};
  for (var j = 0; j != cnt; ++j) {
    var pid = blob.read_shift(4);
    var len = blob.read_shift(4);
    dict[pid] = blob.read_shift(len, CodePage === 1200 ? "utf16le" : "utf8").replace(chr0, "").replace(chr1, "!");
    if (CodePage === 1200 && len % 2) blob.l += 2;
  }
  if (blob.l & 3) blob.l = blob.l >> 2 + 1 << 2;
  return dict;
}
function parse_BLOB(blob) {
  var size = blob.read_shift(4);
  var bytes = blob.slice(blob.l, blob.l + size);
  blob.l += size;
  if ((size & 3) > 0) blob.l += 4 - (size & 3) & 3;
  return bytes;
}
function parse_ClipboardData(blob) {
  var o = {};
  o.Size = blob.read_shift(4);
  blob.l += o.Size + 3 - (o.Size - 1) % 4;
  return o;
}
function parse_TypedPropertyValue(blob, type, _opts) {
  var t = blob.read_shift(2), ret, opts = _opts || {};
  blob.l += 2;
  if (type !== VT_VARIANT) {
    if (t !== type && VT_CUSTOM.indexOf(type) === -1 && !((type & 65534) == 4126 && (t & 65534) == 4126)) throw new Error("Expected type " + type + " saw " + t);
  }
  switch (type === VT_VARIANT ? t : type) {
    case 2:
      ret = blob.read_shift(2, "i");
      if (!opts.raw) blob.l += 2;
      return ret;
    case 3:
      ret = blob.read_shift(4, "i");
      return ret;
    case 11:
      return blob.read_shift(4) !== 0;
    case 19:
      ret = blob.read_shift(4);
      return ret;
    case 30:
      return parse_lpstr(blob, t, 4).replace(chr0, "");
    case 31:
      return parse_lpwstr(blob);
    case 64:
      return parse_FILETIME(blob);
    case 65:
      return parse_BLOB(blob);
    case 71:
      return parse_ClipboardData(blob);
    case 80:
      return parse_VtString(blob, t, !opts.raw).replace(chr0, "");
    case 81:
      return parse_VtUnalignedString(
        blob,
        t
        /*, 4*/
      ).replace(chr0, "");
    case 4108:
      return parse_VtVecHeadingPairValue(blob);
    case 4126:
    case 4127:
      return t == 4127 ? parse_VtVecLpwstrValue(blob) : parse_VtVecUnalignedLpstrValue(blob);
    default:
      throw new Error("TypedPropertyValue unrecognized type " + type + " " + t);
  }
}
function parse_PropertySet(blob, PIDSI) {
  var start_addr = blob.l;
  var size = blob.read_shift(4);
  var NumProps = blob.read_shift(4);
  var Props = [], i = 0;
  var CodePage = 0;
  var Dictionary = -1, DictObj = {};
  for (i = 0; i != NumProps; ++i) {
    var PropID = blob.read_shift(4);
    var Offset = blob.read_shift(4);
    Props[i] = [PropID, Offset + start_addr];
  }
  Props.sort(function(x, y) {
    return x[1] - y[1];
  });
  var PropH = {};
  for (i = 0; i != NumProps; ++i) {
    if (blob.l !== Props[i][1]) {
      var fail = true;
      if (i > 0 && PIDSI) switch (PIDSI[Props[i - 1][0]].t) {
        case 2:
          if (blob.l + 2 === Props[i][1]) {
            blob.l += 2;
            fail = false;
          }
          break;
        case 80:
          if (blob.l <= Props[i][1]) {
            blob.l = Props[i][1];
            fail = false;
          }
          break;
        case 4108:
          if (blob.l <= Props[i][1]) {
            blob.l = Props[i][1];
            fail = false;
          }
          break;
      }
      if ((!PIDSI || i == 0) && blob.l <= Props[i][1]) {
        fail = false;
        blob.l = Props[i][1];
      }
      if (fail) throw new Error("Read Error: Expected address " + Props[i][1] + " at " + blob.l + " :" + i);
    }
    if (PIDSI) {
      if (Props[i][0] == 0 && Props.length > i + 1 && Props[i][1] == Props[i + 1][1]) continue;
      var piddsi = PIDSI[Props[i][0]];
      PropH[piddsi.n] = parse_TypedPropertyValue(blob, piddsi.t, { raw: true });
      if (piddsi.p === "version") PropH[piddsi.n] = String(PropH[piddsi.n] >> 16) + "." + ("0000" + String(PropH[piddsi.n] & 65535)).slice(-4);
      if (piddsi.n == "CodePage") switch (PropH[piddsi.n]) {
        case 0:
          PropH[piddsi.n] = 1252;
        case 874:
        case 932:
        case 936:
        case 949:
        case 950:
        case 1250:
        case 1251:
        case 1253:
        case 1254:
        case 1255:
        case 1256:
        case 1257:
        case 1258:
        case 1e4:
        case 1200:
        case 1201:
        case 1252:
        case 65e3:
        case -536:
        case 65001:
        case -535:
          set_cp(CodePage = PropH[piddsi.n] >>> 0 & 65535);
          break;
        default:
          throw new Error("Unsupported CodePage: " + PropH[piddsi.n]);
      }
    } else {
      if (Props[i][0] === 1) {
        CodePage = PropH.CodePage = parse_TypedPropertyValue(blob, VT_I2);
        set_cp(CodePage);
        if (Dictionary !== -1) {
          var oldpos = blob.l;
          blob.l = Props[Dictionary][1];
          DictObj = parse_dictionary(blob, CodePage);
          blob.l = oldpos;
        }
      } else if (Props[i][0] === 0) {
        if (CodePage === 0) {
          Dictionary = i;
          blob.l = Props[i + 1][1];
          continue;
        }
        DictObj = parse_dictionary(blob, CodePage);
      } else {
        var name = DictObj[Props[i][0]];
        var val;
        switch (blob[blob.l]) {
          case 65:
            blob.l += 4;
            val = parse_BLOB(blob);
            break;
          case 30:
            blob.l += 4;
            val = parse_VtString(blob, blob[blob.l - 4]).replace(/(^|[^\u0000])\u0000+$/, "$1");
            break;
          case 31:
            blob.l += 4;
            val = parse_VtString(blob, blob[blob.l - 4]).replace(/(^|[^\u0000])\u0000+$/, "$1");
            break;
          case 3:
            blob.l += 4;
            val = blob.read_shift(4, "i");
            break;
          case 19:
            blob.l += 4;
            val = blob.read_shift(4);
            break;
          case 5:
            blob.l += 4;
            val = blob.read_shift(8, "f");
            break;
          case 11:
            blob.l += 4;
            val = parsebool(blob, 4);
            break;
          case 64:
            blob.l += 4;
            val = parseDate(parse_FILETIME(blob));
            break;
          default:
            throw new Error("unparsed value: " + blob[blob.l]);
        }
        PropH[name] = val;
      }
    }
  }
  blob.l = start_addr + size;
  return PropH;
}
function parse_PropertySetStream(file, PIDSI, clsid) {
  var blob = file.content;
  if (!blob) return {};
  prep_blob(blob, 0);
  var NumSets, FMTID0, FMTID1, Offset0, Offset1 = 0;
  blob.chk("feff", "Byte Order: ");
  blob.read_shift(2);
  var SystemIdentifier = blob.read_shift(4);
  var CLSID = blob.read_shift(16);
  if (CLSID !== CFB.utils.consts.HEADER_CLSID && CLSID !== clsid) throw new Error("Bad PropertySet CLSID " + CLSID);
  NumSets = blob.read_shift(4);
  if (NumSets !== 1 && NumSets !== 2) throw new Error("Unrecognized #Sets: " + NumSets);
  FMTID0 = blob.read_shift(16);
  Offset0 = blob.read_shift(4);
  if (NumSets === 1 && Offset0 !== blob.l) throw new Error("Length mismatch: " + Offset0 + " !== " + blob.l);
  else if (NumSets === 2) {
    FMTID1 = blob.read_shift(16);
    Offset1 = blob.read_shift(4);
  }
  var PSet0 = parse_PropertySet(blob, PIDSI);
  var rval = { SystemIdentifier };
  for (var y in PSet0) rval[y] = PSet0[y];
  rval.FMTID = FMTID0;
  if (NumSets === 1) return rval;
  if (Offset1 - blob.l == 2) blob.l += 2;
  if (blob.l !== Offset1) throw new Error("Length mismatch 2: " + blob.l + " !== " + Offset1);
  var PSet1;
  try {
    PSet1 = parse_PropertySet(blob, null);
  } catch (e) {
  }
  for (y in PSet1) rval[y] = PSet1[y];
  rval.FMTID = [FMTID0, FMTID1];
  return rval;
}
function parsenoop2(blob, length) {
  blob.read_shift(length);
  return null;
}
function parslurp(blob, length, cb) {
  var arr = [], target = blob.l + length;
  while (blob.l < target) arr.push(cb(blob, target - blob.l));
  if (target !== blob.l) throw new Error("Slurp error");
  return arr;
}
function parsebool(blob, length) {
  return blob.read_shift(length) === 1;
}
function parseuint16(blob) {
  return blob.read_shift(2, "u");
}
function parseuint16a(blob, length) {
  return parslurp(blob, length, parseuint16);
}
function parse_Bes(blob) {
  var v2 = blob.read_shift(1), t = blob.read_shift(1);
  return t === 1 ? v2 : v2 === 1;
}
function parse_ShortXLUnicodeString(blob, length, opts) {
  var cch = blob.read_shift(opts && opts.biff >= 12 ? 2 : 1);
  var encoding = "sbcs-cont";
  var cp = current_codepage;
  if (opts && opts.biff >= 8) current_codepage = 1200;
  if (!opts || opts.biff == 8) {
    var fHighByte = blob.read_shift(1);
    if (fHighByte) {
      encoding = "dbcs-cont";
    }
  } else if (opts.biff == 12) {
    encoding = "wstr";
  }
  if (opts.biff >= 2 && opts.biff <= 5) encoding = "cpstr";
  var o = cch ? blob.read_shift(cch, encoding) : "";
  current_codepage = cp;
  return o;
}
function parse_XLUnicodeRichExtendedString(blob) {
  var cp = current_codepage;
  current_codepage = 1200;
  var cch = blob.read_shift(2), flags = blob.read_shift(1);
  var fExtSt = flags & 4, fRichSt = flags & 8;
  var width = 1 + (flags & 1);
  var cRun = 0, cbExtRst;
  var z = {};
  if (fRichSt) cRun = blob.read_shift(2);
  if (fExtSt) cbExtRst = blob.read_shift(4);
  var encoding = width == 2 ? "dbcs-cont" : "sbcs-cont";
  var msg = cch === 0 ? "" : blob.read_shift(cch, encoding);
  if (fRichSt) blob.l += 4 * cRun;
  if (fExtSt) blob.l += cbExtRst;
  z.t = msg;
  if (!fRichSt) {
    z.raw = "<t>" + z.t + "</t>";
    z.r = z.t;
  }
  current_codepage = cp;
  return z;
}
function parse_XLUnicodeStringNoCch(blob, cch, opts) {
  var retval;
  if (opts) {
    if (opts.biff >= 2 && opts.biff <= 5) return blob.read_shift(cch, "cpstr");
    if (opts.biff >= 12) return blob.read_shift(cch, "dbcs-cont");
  }
  var fHighByte = blob.read_shift(1);
  if (fHighByte === 0) {
    retval = blob.read_shift(cch, "sbcs-cont");
  } else {
    retval = blob.read_shift(cch, "dbcs-cont");
  }
  return retval;
}
function parse_XLUnicodeString(blob, length, opts) {
  var cch = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  if (cch === 0) {
    blob.l++;
    return "";
  }
  return parse_XLUnicodeStringNoCch(blob, cch, opts);
}
function parse_XLUnicodeString2(blob, length, opts) {
  if (opts.biff > 5) return parse_XLUnicodeString(blob, length, opts);
  var cch = blob.read_shift(1);
  if (cch === 0) {
    blob.l++;
    return "";
  }
  return blob.read_shift(cch, opts.biff <= 4 || !blob.lens ? "cpstr" : "sbcs-cont");
}
function parse_ControlInfo(blob) {
  var flags = blob.read_shift(1);
  blob.l++;
  var accel = blob.read_shift(2);
  blob.l += 2;
  return [flags, accel];
}
function parse_URLMoniker(blob) {
  var len = blob.read_shift(4), start = blob.l;
  var extra = false;
  if (len > 24) {
    blob.l += len - 24;
    if (blob.read_shift(16) === "795881f43b1d7f48af2c825dc4852763") extra = true;
    blob.l = start;
  }
  var url = blob.read_shift((extra ? len - 24 : len) >> 1, "utf16le").replace(chr0, "");
  if (extra) blob.l += 24;
  return url;
}
function parse_FileMoniker(blob) {
  var cAnti = blob.read_shift(2);
  var preamble = "";
  while (cAnti-- > 0) preamble += "../";
  var ansiPath = blob.read_shift(0, "lpstr-ansi");
  blob.l += 2;
  if (blob.read_shift(2) != 57005) throw new Error("Bad FileMoniker");
  var sz = blob.read_shift(4);
  if (sz === 0) return preamble + ansiPath.replace(/\\/g, "/");
  var bytes = blob.read_shift(4);
  if (blob.read_shift(2) != 3) throw new Error("Bad FileMoniker");
  var unicodePath = blob.read_shift(bytes >> 1, "utf16le").replace(chr0, "");
  return preamble + unicodePath;
}
function parse_HyperlinkMoniker(blob, length) {
  var clsid = blob.read_shift(16);
  switch (clsid) {
    case "e0c9ea79f9bace118c8200aa004ba90b":
      return parse_URLMoniker(blob);
    case "0303000000000000c000000000000046":
      return parse_FileMoniker(blob);
    default:
      throw new Error("Unsupported Moniker " + clsid);
  }
}
function parse_HyperlinkString(blob) {
  var len = blob.read_shift(4);
  var o = len > 0 ? blob.read_shift(len, "utf16le").replace(chr0, "") : "";
  return o;
}
function parse_Hyperlink(blob, length) {
  var end = blob.l + length;
  var sVer = blob.read_shift(4);
  if (sVer !== 2) throw new Error("Unrecognized streamVersion: " + sVer);
  var flags = blob.read_shift(2);
  blob.l += 2;
  var displayName, targetFrameName, moniker, oleMoniker, Loc = "", guid, fileTime;
  if (flags & 16) displayName = parse_HyperlinkString(blob, end - blob.l);
  if (flags & 128) targetFrameName = parse_HyperlinkString(blob, end - blob.l);
  if ((flags & 257) === 257) moniker = parse_HyperlinkString(blob, end - blob.l);
  if ((flags & 257) === 1) oleMoniker = parse_HyperlinkMoniker(blob, end - blob.l);
  if (flags & 8) Loc = parse_HyperlinkString(blob, end - blob.l);
  if (flags & 32) guid = blob.read_shift(16);
  if (flags & 64) fileTime = parse_FILETIME(
    blob
    /*, 8*/
  );
  blob.l = end;
  var target = targetFrameName || moniker || oleMoniker || "";
  if (target && Loc) target += "#" + Loc;
  if (!target) target = "#" + Loc;
  if (flags & 2 && target.charAt(0) == "/" && target.charAt(1) != "/") target = "file://" + target;
  var out = { Target: target };
  if (guid) out.guid = guid;
  if (fileTime) out.time = fileTime;
  if (displayName) out.Tooltip = displayName;
  return out;
}
function parse_LongRGBA(blob) {
  var r = blob.read_shift(1), g = blob.read_shift(1), b = blob.read_shift(1), a = blob.read_shift(1);
  return [r, g, b, a];
}
function parse_LongRGB(blob, length) {
  var x = parse_LongRGBA(blob);
  x[3] = 0;
  return x;
}
function parse_XLSCell(blob, length, opts) {
  var rw = blob.read_shift(2);
  var col = blob.read_shift(2);
  var ret = { r: rw, c: col, ixfe: 0 };
  if (opts && opts.biff == 2 || length == 7) {
    var flags = blob.read_shift(1);
    ret.ixfe = flags & 63;
    blob.l += 2;
  } else ret.ixfe = blob.read_shift(2);
  return ret;
}
function parse_frtHeader(blob) {
  var rt = blob.read_shift(2);
  var flags = blob.read_shift(2);
  blob.l += 8;
  return { type: rt, flags };
}
function parse_OptXLUnicodeString(blob, length, opts) {
  return length === 0 ? "" : parse_XLUnicodeString2(blob, length, opts);
}
function parse_XTI(blob, length, opts) {
  var w = opts.biff > 8 ? 4 : 2;
  var iSupBook = blob.read_shift(w), itabFirst = blob.read_shift(w, "i"), itabLast = blob.read_shift(w, "i");
  return [iSupBook, itabFirst, itabLast];
}
function parse_RkRec(blob) {
  var ixfe = blob.read_shift(2);
  var RK = parse_RkNumber(blob);
  return [ixfe, RK];
}
function parse_AddinUdf(blob, length, opts) {
  blob.l += 4;
  length -= 4;
  var l2 = blob.l + length;
  var udfName = parse_ShortXLUnicodeString(blob, length, opts);
  var cb = blob.read_shift(2);
  l2 -= blob.l;
  if (cb !== l2) throw new Error("Malformed AddinUdf: padding = " + l2 + " != " + cb);
  blob.l += cb;
  return udfName;
}
function parse_Ref8U(blob) {
  var rwFirst = blob.read_shift(2);
  var rwLast = blob.read_shift(2);
  var colFirst = blob.read_shift(2);
  var colLast = blob.read_shift(2);
  return { s: { c: colFirst, r: rwFirst }, e: { c: colLast, r: rwLast } };
}
function parse_RefU(blob) {
  var rwFirst = blob.read_shift(2);
  var rwLast = blob.read_shift(2);
  var colFirst = blob.read_shift(1);
  var colLast = blob.read_shift(1);
  return { s: { c: colFirst, r: rwFirst }, e: { c: colLast, r: rwLast } };
}
var parse_Ref = parse_RefU;
function parse_FtCmo(blob) {
  blob.l += 4;
  var ot = blob.read_shift(2);
  var id = blob.read_shift(2);
  var flags = blob.read_shift(2);
  blob.l += 12;
  return [id, ot, flags];
}
function parse_FtNts(blob) {
  var out = {};
  blob.l += 4;
  blob.l += 16;
  out.fSharedNote = blob.read_shift(2);
  blob.l += 4;
  return out;
}
function parse_FtCf(blob) {
  var out = {};
  blob.l += 4;
  blob.cf = blob.read_shift(2);
  return out;
}
function parse_FtSkip(blob) {
  blob.l += 2;
  blob.l += blob.read_shift(2);
}
var FtTab = {
  0: parse_FtSkip,
  /* FtEnd */
  4: parse_FtSkip,
  /* FtMacro */
  5: parse_FtSkip,
  /* FtButton */
  6: parse_FtSkip,
  /* FtGmo */
  7: parse_FtCf,
  /* FtCf */
  8: parse_FtSkip,
  /* FtPioGrbit */
  9: parse_FtSkip,
  /* FtPictFmla */
  10: parse_FtSkip,
  /* FtCbls */
  11: parse_FtSkip,
  /* FtRbo */
  12: parse_FtSkip,
  /* FtSbs */
  13: parse_FtNts,
  /* FtNts */
  14: parse_FtSkip,
  /* FtSbsFmla */
  15: parse_FtSkip,
  /* FtGboData */
  16: parse_FtSkip,
  /* FtEdoData */
  17: parse_FtSkip,
  /* FtRboData */
  18: parse_FtSkip,
  /* FtCblsData */
  19: parse_FtSkip,
  /* FtLbsData */
  20: parse_FtSkip,
  /* FtCblsFmla */
  21: parse_FtCmo
};
function parse_FtArray(blob, length) {
  var tgt = blob.l + length;
  var fts = [];
  while (blob.l < tgt) {
    var ft = blob.read_shift(2);
    blob.l -= 2;
    try {
      fts[ft] = FtTab[ft](blob, tgt - blob.l);
    } catch (e) {
      blob.l = tgt;
      return fts;
    }
  }
  if (blob.l != tgt) blob.l = tgt;
  return fts;
}
function parse_BOF(blob, length) {
  var o = { BIFFVer: 0, dt: 0 };
  o.BIFFVer = blob.read_shift(2);
  length -= 2;
  if (length >= 2) {
    o.dt = blob.read_shift(2);
    blob.l -= 2;
  }
  switch (o.BIFFVer) {
    case 1536:
    case 1280:
    case 1024:
    case 768:
    case 512:
    case 2:
    case 7:
      break;
    default:
      if (length > 6) throw new Error("Unexpected BIFF Ver " + o.BIFFVer);
  }
  blob.read_shift(length);
  return o;
}
function parse_InterfaceHdr(blob, length) {
  if (length === 0) return 1200;
  if (blob.read_shift(2) !== 1200) ;
  return 1200;
}
function parse_WriteAccess(blob, length, opts) {
  if (opts.enc) {
    blob.l += length;
    return "";
  }
  var l2 = blob.l;
  var UserName = parse_XLUnicodeString2(blob, 0, opts);
  blob.read_shift(length + l2 - blob.l);
  return UserName;
}
function parse_WsBool(blob, length, opts) {
  var flags = opts && opts.biff == 8 || length == 2 ? blob.read_shift(2) : (blob.l += length, 0);
  return { fDialog: flags & 16, fBelow: flags & 64, fRight: flags & 128 };
}
function parse_BoundSheet8(blob, length, opts) {
  var name = "";
  if (opts.biff == 4) {
    name = parse_ShortXLUnicodeString(blob, 0, opts);
    if (name.length === 0) name = "Sheet1";
    return { name };
  }
  var pos2 = blob.read_shift(4);
  var hidden = blob.read_shift(1) & 3;
  var dt = blob.read_shift(1);
  switch (dt) {
    case 0:
      dt = "Worksheet";
      break;
    case 1:
      dt = "Macrosheet";
      break;
    case 2:
      dt = "Chartsheet";
      break;
    case 6:
      dt = "VBAModule";
      break;
  }
  name = parse_ShortXLUnicodeString(blob, 0, opts);
  if (name.length === 0) name = "Sheet1";
  return { pos: pos2, hs: hidden, dt, name };
}
function parse_SST(blob, length) {
  var end = blob.l + length;
  var cnt = blob.read_shift(4);
  var ucnt = blob.read_shift(4);
  var strs2 = [];
  for (var i = 0; i != ucnt && blob.l < end; ++i) {
    strs2.push(parse_XLUnicodeRichExtendedString(blob));
  }
  strs2.Count = cnt;
  strs2.Unique = ucnt;
  return strs2;
}
function parse_ExtSST(blob, length) {
  var extsst = {};
  extsst.dsst = blob.read_shift(2);
  blob.l += length - 2;
  return extsst;
}
function parse_Row(blob) {
  var z = {};
  z.r = blob.read_shift(2);
  z.c = blob.read_shift(2);
  z.cnt = blob.read_shift(2) - z.c;
  var miyRw = blob.read_shift(2);
  blob.l += 4;
  var flags = blob.read_shift(1);
  blob.l += 3;
  if (flags & 7) z.level = flags & 7;
  if (flags & 32) z.hidden = true;
  if (flags & 64) z.hpt = miyRw / 20;
  return z;
}
function parse_ForceFullCalculation(blob) {
  var header = parse_frtHeader(blob);
  if (header.type != 2211) throw new Error("Invalid Future Record " + header.type);
  var fullcalc = blob.read_shift(4);
  return fullcalc !== 0;
}
function parse_RecalcId(blob) {
  blob.read_shift(2);
  return blob.read_shift(4);
}
function parse_DefaultRowHeight(blob, length, opts) {
  var f = 0;
  if (!(opts && opts.biff == 2)) {
    f = blob.read_shift(2);
  }
  var miyRw = blob.read_shift(2);
  if (opts && opts.biff == 2) {
    f = 1 - (miyRw >> 15);
    miyRw &= 32767;
  }
  var fl = { Unsynced: f & 1, DyZero: (f & 2) >> 1, ExAsc: (f & 4) >> 2, ExDsc: (f & 8) >> 3 };
  return [fl, miyRw];
}
function parse_Window1(blob) {
  var xWn = blob.read_shift(2), yWn = blob.read_shift(2), dxWn = blob.read_shift(2), dyWn = blob.read_shift(2);
  var flags = blob.read_shift(2), iTabCur = blob.read_shift(2), iTabFirst = blob.read_shift(2);
  var ctabSel = blob.read_shift(2), wTabRatio = blob.read_shift(2);
  return {
    Pos: [xWn, yWn],
    Dim: [dxWn, dyWn],
    Flags: flags,
    CurTab: iTabCur,
    FirstTab: iTabFirst,
    Selected: ctabSel,
    TabRatio: wTabRatio
  };
}
function parse_Window2(blob, length, opts) {
  if (opts && opts.biff >= 2 && opts.biff < 5) return {};
  var f = blob.read_shift(2);
  return { RTL: f & 64 };
}
function parse_Pane() {
}
function parse_Font(blob, length, opts) {
  var o = {
    dyHeight: blob.read_shift(2),
    fl: blob.read_shift(2)
  };
  switch (opts && opts.biff || 8) {
    case 2:
      break;
    case 3:
    case 4:
      blob.l += 2;
      break;
    default:
      blob.l += 10;
      break;
  }
  o.name = parse_ShortXLUnicodeString(blob, 0, opts);
  return o;
}
function parse_LabelSst(blob, length, opts) {
  var cell = parse_XLSCell(blob, length, opts);
  cell.isst = blob.read_shift(4);
  return cell;
}
function parse_Label(blob, length, opts) {
  if (opts.biffguess && opts.biff == 2) opts.biff = 5;
  var target = blob.l + length;
  var cell = parse_XLSCell(blob, length, opts);
  var str = parse_XLUnicodeString(blob, target - blob.l, opts);
  cell.val = str;
  return cell;
}
function parse_Format(blob, length, opts) {
  var numFmtId = blob.read_shift(2);
  var fmtstr = parse_XLUnicodeString2(blob, 0, opts);
  return [numFmtId, fmtstr];
}
var parse_BIFF2Format = parse_XLUnicodeString2;
function parse_Dimensions(blob, length, opts) {
  var end = blob.l + length;
  var w = opts.biff == 8 || !opts.biff ? 4 : 2;
  var r = blob.read_shift(w), R = blob.read_shift(w);
  var c2 = blob.read_shift(2), C2 = blob.read_shift(2);
  blob.l = end;
  return { s: { r, c: c2 }, e: { r: R, c: C2 } };
}
function parse_RK(blob) {
  var rw = blob.read_shift(2), col = blob.read_shift(2);
  var rkrec = parse_RkRec(blob);
  return { r: rw, c: col, ixfe: rkrec[0], rknum: rkrec[1] };
}
function parse_MulRk(blob, length) {
  var target = blob.l + length - 2;
  var rw = blob.read_shift(2), col = blob.read_shift(2);
  var rkrecs = [];
  while (blob.l < target) rkrecs.push(parse_RkRec(blob));
  if (blob.l !== target) throw new Error("MulRK read error");
  var lastcol = blob.read_shift(2);
  if (rkrecs.length != lastcol - col + 1) throw new Error("MulRK length mismatch");
  return { r: rw, c: col, C: lastcol, rkrec: rkrecs };
}
function parse_MulBlank(blob, length) {
  var target = blob.l + length - 2;
  var rw = blob.read_shift(2), col = blob.read_shift(2);
  var ixfes = [];
  while (blob.l < target) ixfes.push(blob.read_shift(2));
  if (blob.l !== target) throw new Error("MulBlank read error");
  var lastcol = blob.read_shift(2);
  if (ixfes.length != lastcol - col + 1) throw new Error("MulBlank length mismatch");
  return { r: rw, c: col, C: lastcol, ixfe: ixfes };
}
function parse_CellStyleXF(blob, length, style, opts) {
  var o = {};
  var a = blob.read_shift(4), b = blob.read_shift(4);
  var c2 = blob.read_shift(4), d = blob.read_shift(2);
  o.patternType = XLSFillPattern[c2 >> 26];
  if (!opts.cellStyles) return o;
  o.alc = a & 7;
  o.fWrap = a >> 3 & 1;
  o.alcV = a >> 4 & 7;
  o.fJustLast = a >> 7 & 1;
  o.trot = a >> 8 & 255;
  o.cIndent = a >> 16 & 15;
  o.fShrinkToFit = a >> 20 & 1;
  o.iReadOrder = a >> 22 & 2;
  o.fAtrNum = a >> 26 & 1;
  o.fAtrFnt = a >> 27 & 1;
  o.fAtrAlc = a >> 28 & 1;
  o.fAtrBdr = a >> 29 & 1;
  o.fAtrPat = a >> 30 & 1;
  o.fAtrProt = a >> 31 & 1;
  o.dgLeft = b & 15;
  o.dgRight = b >> 4 & 15;
  o.dgTop = b >> 8 & 15;
  o.dgBottom = b >> 12 & 15;
  o.icvLeft = b >> 16 & 127;
  o.icvRight = b >> 23 & 127;
  o.grbitDiag = b >> 30 & 3;
  o.icvTop = c2 & 127;
  o.icvBottom = c2 >> 7 & 127;
  o.icvDiag = c2 >> 14 & 127;
  o.dgDiag = c2 >> 21 & 15;
  o.icvFore = d & 127;
  o.icvBack = d >> 7 & 127;
  o.fsxButton = d >> 14 & 1;
  return o;
}
function parse_XF(blob, length, opts) {
  var o = {};
  o.ifnt = blob.read_shift(2);
  o.numFmtId = blob.read_shift(2);
  o.flags = blob.read_shift(2);
  o.fStyle = o.flags >> 2 & 1;
  length -= 6;
  o.data = parse_CellStyleXF(blob, length, o.fStyle, opts);
  return o;
}
function parse_BIFF2XF(blob) {
  var o = {};
  o.ifnt = blob.read_shift(1);
  blob.l++;
  o.flags = blob.read_shift(1);
  o.numFmtId = o.flags & 63;
  o.flags >>= 6;
  o.fStyle = 0;
  o.data = {};
  return o;
}
function parse_BIFF3XF(blob) {
  var o = {};
  o.ifnt = blob.read_shift(1);
  o.numFmtId = blob.read_shift(1);
  o.flags = blob.read_shift(2);
  o.fStyle = o.flags >> 2 & 1;
  o.data = {};
  return o;
}
function parse_BIFF4XF(blob) {
  var o = {};
  o.ifnt = blob.read_shift(1);
  o.numFmtId = blob.read_shift(1);
  o.flags = blob.read_shift(2);
  o.fStyle = o.flags >> 2 & 1;
  o.data = {};
  return o;
}
function parse_Guts(blob) {
  blob.l += 4;
  var out = [blob.read_shift(2), blob.read_shift(2)];
  if (out[0] !== 0) out[0]--;
  if (out[1] !== 0) out[1]--;
  if (out[0] > 7 || out[1] > 7) throw new Error("Bad Gutters: " + out.join("|"));
  return out;
}
function parse_BoolErr(blob, length, opts) {
  var cell = parse_XLSCell(blob, 6, opts);
  var val = parse_Bes(blob);
  cell.val = val;
  cell.t = val === true || val === false ? "b" : "e";
  return cell;
}
function parse_Number(blob, length, opts) {
  if (opts.biffguess && opts.biff == 2) opts.biff = 5;
  var cell = parse_XLSCell(blob, 6, opts);
  var xnum = parse_Xnum(blob);
  cell.val = xnum;
  return cell;
}
var parse_XLHeaderFooter = parse_OptXLUnicodeString;
function parse_SupBook(blob, length, opts) {
  var end = blob.l + length;
  var ctab = blob.read_shift(2);
  var cch = blob.read_shift(2);
  opts.sbcch = cch;
  if (cch == 1025 || cch == 14849) return [cch, ctab];
  if (cch < 1 || cch > 255) throw new Error("Unexpected SupBook type: " + cch);
  var virtPath = parse_XLUnicodeStringNoCch(blob, cch);
  var rgst = [];
  while (end > blob.l) rgst.push(parse_XLUnicodeString(blob));
  return [cch, ctab, virtPath, rgst];
}
function parse_ExternName(blob, length, opts) {
  var flags = blob.read_shift(2);
  var body;
  var o = {
    fBuiltIn: flags & 1,
    fWantAdvise: flags >>> 1 & 1,
    fWantPict: flags >>> 2 & 1,
    fOle: flags >>> 3 & 1,
    fOleLink: flags >>> 4 & 1,
    cf: flags >>> 5 & 1023,
    fIcon: flags >>> 15 & 1
  };
  if (opts.sbcch === 14849) body = parse_AddinUdf(blob, length - 2, opts);
  o.body = body || blob.read_shift(length - 2);
  if (typeof body === "string") o.Name = body;
  return o;
}
function parse_Lbl(blob, length, opts) {
  var target = blob.l + length;
  var flags = blob.read_shift(2);
  var chKey = blob.read_shift(1);
  var cch = blob.read_shift(1);
  var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  var itab = 0;
  if (!opts || opts.biff >= 5) {
    if (opts.biff != 5) blob.l += 2;
    itab = blob.read_shift(2);
    if (opts.biff == 5) blob.l += 2;
    blob.l += 4;
  }
  var name = parse_XLUnicodeStringNoCch(blob, cch, opts);
  if (flags & 32) name = XLSLblBuiltIn[name.charCodeAt(0)];
  var npflen = target - blob.l;
  if (opts && opts.biff == 2) --npflen;
  var rgce = target == blob.l || cce === 0 || !(npflen > 0) ? [] : parse_NameParsedFormula(blob, npflen, opts, cce);
  return {
    chKey,
    Name: name,
    itab,
    rgce
  };
}
function parse_ExternSheet(blob, length, opts) {
  if (opts.biff < 8) return parse_BIFF5ExternSheet(blob, length, opts);
  if (!(opts.biff > 8) && length == blob[blob.l] + (blob[blob.l + 1] == 3 ? 1 : 0) + 1) return parse_BIFF5ExternSheet(blob, length, opts);
  var o = [], target = blob.l + length, len = blob.read_shift(opts.biff > 8 ? 4 : 2);
  while (len-- !== 0) o.push(parse_XTI(blob, opts.biff > 8 ? 12 : 6, opts));
  if (blob.l != target) throw new Error("Bad ExternSheet: " + blob.l + " != " + target);
  return o;
}
function parse_BIFF5ExternSheet(blob, length, opts) {
  if (blob[blob.l + 1] == 3) blob[blob.l]++;
  var o = parse_ShortXLUnicodeString(blob, length, opts);
  return o.charCodeAt(0) == 3 ? o.slice(1) : o;
}
function parse_NameCmt(blob, length, opts) {
  if (opts.biff < 8) {
    blob.l += length;
    return;
  }
  var cchName = blob.read_shift(2);
  var cchComment = blob.read_shift(2);
  var name = parse_XLUnicodeStringNoCch(blob, cchName, opts);
  var comment = parse_XLUnicodeStringNoCch(blob, cchComment, opts);
  return [name, comment];
}
function parse_ShrFmla(blob, length, opts) {
  var ref2 = parse_RefU(blob);
  blob.l++;
  var cUse = blob.read_shift(1);
  length -= 8;
  return [parse_SharedParsedFormula(blob, length, opts), cUse, ref2];
}
function parse_Array(blob, length, opts) {
  var ref2 = parse_Ref(blob);
  switch (opts.biff) {
    case 2:
      blob.l++;
      length -= 7;
      break;
    case 3:
    case 4:
      blob.l += 2;
      length -= 8;
      break;
    default:
      blob.l += 6;
      length -= 12;
  }
  return [ref2, parse_ArrayParsedFormula(blob, length, opts)];
}
function parse_MTRSettings(blob) {
  var fMTREnabled = blob.read_shift(4) !== 0;
  var fUserSetThreadCount = blob.read_shift(4) !== 0;
  var cUserThreadCount = blob.read_shift(4);
  return [fMTREnabled, fUserSetThreadCount, cUserThreadCount];
}
function parse_NoteSh(blob, length, opts) {
  var row = blob.read_shift(2), col = blob.read_shift(2);
  var flags = blob.read_shift(2), idObj = blob.read_shift(2);
  var stAuthor = parse_XLUnicodeString2(blob, 0, opts);
  return [{ r: row, c: col }, stAuthor, idObj, flags];
}
function parse_Note(blob, length, opts) {
  if (opts && opts.biff < 8) {
    var row = blob.read_shift(2), col = blob.read_shift(2);
    if (row == 65535 || row == -1) return;
    var cch = blob.read_shift(2);
    var cmnt = blob.read_shift(Math.min(cch, 2048), "cpstr");
    return [{ r: row, c: col }, cmnt];
  }
  return parse_NoteSh(blob, length, opts);
}
function parse_MergeCells(blob, length) {
  var merges = [];
  var cmcs = blob.read_shift(2);
  while (cmcs--) merges.push(parse_Ref8U(blob));
  return merges;
}
function parse_Obj(blob, length, opts) {
  if (opts && opts.biff < 8) return parse_BIFF5Obj(blob, length, opts);
  var cmo = parse_FtCmo(blob);
  var fts = parse_FtArray(blob, length - 22, cmo[1]);
  return { cmo, ft: fts };
}
var parse_BIFF5OT = {
  8: function(blob, length) {
    var tgt = blob.l + length;
    blob.l += 10;
    var cf = blob.read_shift(2);
    blob.l += 4;
    blob.l += 2;
    blob.l += 2;
    blob.l += 2;
    blob.l += 4;
    var cchName = blob.read_shift(1);
    blob.l += cchName;
    blob.l = tgt;
    return { fmt: cf };
  }
};
function parse_BIFF5Obj(blob, length, opts) {
  blob.l += 4;
  var ot = blob.read_shift(2);
  var id = blob.read_shift(2);
  var grbit = blob.read_shift(2);
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 6;
  length -= 36;
  var fts = [];
  fts.push((parse_BIFF5OT[ot] || parsenoop)(blob, length, opts));
  return { cmo: [id, ot, grbit], ft: fts };
}
function parse_TxO(blob, length, opts) {
  var s = blob.l;
  var texts = "";
  try {
    blob.l += 4;
    var ot = (opts.lastobj || { cmo: [0, 0] }).cmo[1];
    var controlInfo;
    if ([0, 5, 7, 11, 12, 14].indexOf(ot) == -1) blob.l += 6;
    else controlInfo = parse_ControlInfo(blob, 6, opts);
    var cchText = blob.read_shift(2);
    blob.read_shift(2);
    parseuint16(blob, 2);
    var len = blob.read_shift(2);
    blob.l += len;
    for (var i = 1; i < blob.lens.length - 1; ++i) {
      if (blob.l - s != blob.lens[i]) throw new Error("TxO: bad continue record");
      var hdr = blob[blob.l];
      var t = parse_XLUnicodeStringNoCch(blob, blob.lens[i + 1] - blob.lens[i] - 1);
      texts += t;
      if (texts.length >= (hdr ? cchText : 2 * cchText)) break;
    }
    if (texts.length !== cchText && texts.length !== cchText * 2) {
      throw new Error("cchText: " + cchText + " != " + texts.length);
    }
    blob.l = s + length;
    return { t: texts };
  } catch (e) {
    blob.l = s + length;
    return { t: texts };
  }
}
function parse_HLink(blob, length) {
  var ref2 = parse_Ref8U(blob);
  blob.l += 16;
  var hlink = parse_Hyperlink(blob, length - 24);
  return [ref2, hlink];
}
function parse_HLinkTooltip(blob, length) {
  blob.read_shift(2);
  var ref2 = parse_Ref8U(blob);
  var wzTooltip = blob.read_shift((length - 10) / 2, "dbcs-cont");
  wzTooltip = wzTooltip.replace(chr0, "");
  return [ref2, wzTooltip];
}
function parse_Country(blob) {
  var o = [0, 0], d;
  d = blob.read_shift(2);
  o[0] = CountryEnum[d] || d;
  d = blob.read_shift(2);
  o[1] = CountryEnum[d] || d;
  return o;
}
function parse_ClrtClient(blob) {
  var ccv = blob.read_shift(2);
  var o = [];
  while (ccv-- > 0) o.push(parse_LongRGB(blob));
  return o;
}
function parse_Palette(blob) {
  var ccv = blob.read_shift(2);
  var o = [];
  while (ccv-- > 0) o.push(parse_LongRGB(blob));
  return o;
}
function parse_XFCRC(blob) {
  blob.l += 2;
  var o = { cxfs: 0, crc: 0 };
  o.cxfs = blob.read_shift(2);
  o.crc = blob.read_shift(4);
  return o;
}
function parse_ColInfo(blob, length, opts) {
  if (!opts.cellStyles) return parsenoop(blob, length);
  var w = opts && opts.biff >= 12 ? 4 : 2;
  var colFirst = blob.read_shift(w);
  var colLast = blob.read_shift(w);
  var coldx = blob.read_shift(w);
  var ixfe = blob.read_shift(w);
  var flags = blob.read_shift(2);
  if (w == 2) blob.l += 2;
  var o = { s: colFirst, e: colLast, w: coldx, ixfe, flags };
  if (opts.biff >= 5 || !opts.biff) o.level = flags >> 8 & 7;
  return o;
}
function parse_Setup(blob, length) {
  var o = {};
  if (length < 32) return o;
  blob.l += 16;
  o.header = parse_Xnum(blob);
  o.footer = parse_Xnum(blob);
  blob.l += 2;
  return o;
}
function parse_ShtProps(blob, length, opts) {
  var def = { area: false };
  if (opts.biff != 5) {
    blob.l += length;
    return def;
  }
  var d = blob.read_shift(1);
  blob.l += 3;
  if (d & 16) def.area = true;
  return def;
}
var parse_Blank = parse_XLSCell;
var parse_Scl = parseuint16a;
var parse_String = parse_XLUnicodeString;
function parse_ImData(blob) {
  var cf = blob.read_shift(2);
  var env = blob.read_shift(2);
  var lcb = blob.read_shift(4);
  var o = { fmt: cf, env, len: lcb, data: blob.slice(blob.l, blob.l + lcb) };
  blob.l += lcb;
  return o;
}
function parse_BIFF2STR(blob, length, opts) {
  if (opts.biffguess && opts.biff == 5) opts.biff = 2;
  var cell = parse_XLSCell(blob, 7, opts);
  var str = parse_XLUnicodeString2(blob, length - 7, opts);
  cell.t = "str";
  cell.val = str;
  return cell;
}
function parse_BIFF2NUM(blob, length, opts) {
  var cell = parse_XLSCell(blob, 7, opts);
  var num = parse_Xnum(blob);
  cell.t = "n";
  cell.val = num;
  return cell;
}
function parse_BIFF2INT(blob, length, opts) {
  var cell = parse_XLSCell(blob, 7, opts);
  var num = blob.read_shift(2);
  cell.t = "n";
  cell.val = num;
  return cell;
}
function parse_BIFF2STRING(blob) {
  var cch = blob.read_shift(1);
  if (cch === 0) {
    blob.l++;
    return "";
  }
  return blob.read_shift(cch, "sbcs-cont");
}
function parse_BIFF2BOOLERR(blob, length, opts) {
  var bestart = blob.l + 7;
  var cell = parse_XLSCell(blob, 6, opts);
  blob.l = bestart;
  var val = parse_Bes(blob);
  cell.val = val;
  cell.t = val === true || val === false ? "b" : "e";
  return cell;
}
function parse_BIFF2FONTXTRA(blob, length) {
  blob.l += 6;
  blob.l += 2;
  blob.l += 1;
  blob.l += 3;
  blob.l += 1;
  blob.l += length - 13;
}
function parse_RString(blob, length, opts) {
  var end = blob.l + length;
  var cell = parse_XLSCell(blob, 6, opts);
  var cch = blob.read_shift(2);
  var str = parse_XLUnicodeStringNoCch(blob, cch, opts);
  blob.l = end;
  cell.t = "str";
  cell.val = str;
  return cell;
}
function parse_BIFF4SheetInfo(blob) {
  var flags = blob.read_shift(4);
  var cch = blob.read_shift(1), name = blob.read_shift(cch, "sbcs");
  if (name.length === 0) name = "Sheet1";
  return { flags, name };
}
var DBF_SUPPORTED_VERSIONS = [2, 3, 48, 49, 131, 139, 140, 245];
var DBF = /* @__PURE__ */ function() {
  var dbf_codepage_map = {
    /* Code Pages Supported by Visual FoxPro */
    1: 437,
    2: 850,
    3: 1252,
    4: 1e4,
    100: 852,
    101: 866,
    102: 865,
    103: 861,
    104: 895,
    105: 620,
    106: 737,
    107: 857,
    120: 950,
    121: 949,
    122: 936,
    123: 932,
    124: 874,
    125: 1255,
    126: 1256,
    150: 10007,
    151: 10029,
    152: 10006,
    200: 1250,
    201: 1251,
    202: 1254,
    203: 1253,
    /* shapefile DBF extension */
    0: 20127,
    8: 865,
    9: 437,
    10: 850,
    11: 437,
    13: 437,
    14: 850,
    15: 437,
    16: 850,
    17: 437,
    18: 850,
    19: 932,
    20: 850,
    21: 437,
    22: 850,
    23: 865,
    24: 437,
    25: 437,
    26: 850,
    27: 437,
    28: 863,
    29: 850,
    31: 852,
    34: 852,
    35: 852,
    36: 860,
    37: 850,
    38: 866,
    55: 850,
    64: 852,
    77: 936,
    78: 949,
    79: 950,
    80: 874,
    87: 1252,
    88: 1252,
    89: 1252,
    108: 863,
    134: 737,
    135: 852,
    136: 857,
    204: 1257,
    255: 16969
  };
  var dbf_reverse_map = evert({
    1: 437,
    2: 850,
    3: 1252,
    4: 1e4,
    100: 852,
    101: 866,
    102: 865,
    103: 861,
    104: 895,
    105: 620,
    106: 737,
    107: 857,
    120: 950,
    121: 949,
    122: 936,
    123: 932,
    124: 874,
    125: 1255,
    126: 1256,
    150: 10007,
    151: 10029,
    152: 10006,
    200: 1250,
    201: 1251,
    202: 1254,
    203: 1253,
    0: 20127
  });
  function dbf_to_aoa(buf, opts) {
    var out = [];
    var d = new_raw_buf(1);
    switch (opts.type) {
      case "base64":
        d = s2a(Base64_decode(buf));
        break;
      case "binary":
        d = s2a(buf);
        break;
      case "buffer":
      case "array":
        d = buf;
        break;
    }
    prep_blob(d, 0);
    var ft = d.read_shift(1);
    var memo = !!(ft & 136);
    var vfp = false, l7 = false;
    switch (ft) {
      case 2:
        break;
      case 3:
        break;
      case 48:
        vfp = true;
        memo = true;
        break;
      case 49:
        vfp = true;
        memo = true;
        break;
      case 131:
        break;
      case 139:
        break;
      case 140:
        l7 = true;
        break;
      case 245:
        break;
      default:
        throw new Error("DBF Unsupported Version: " + ft.toString(16));
    }
    var nrow = 0, fpos = 521;
    if (ft == 2) nrow = d.read_shift(2);
    d.l += 3;
    if (ft != 2) nrow = d.read_shift(4);
    if (nrow > 1048576) nrow = 1e6;
    if (ft != 2) fpos = d.read_shift(2);
    var rlen = d.read_shift(2);
    opts.codepage || 1252;
    if (ft != 2) {
      d.l += 16;
      d.read_shift(1);
      if (d[d.l] !== 0) dbf_codepage_map[d[d.l]];
      d.l += 1;
      d.l += 2;
    }
    if (l7) d.l += 36;
    var fields = [], field = {};
    var hend = Math.min(d.length, ft == 2 ? 521 : fpos - 10 - (vfp ? 264 : 0));
    var ww = l7 ? 32 : 11;
    while (d.l < hend && d[d.l] != 13) {
      field = {};
      field.name = a2s(d.slice(d.l, d.l + ww)).replace(/[\u0000\r\n][\S\s]*$/g, "");
      d.l += ww;
      field.type = String.fromCharCode(d.read_shift(1));
      if (ft != 2 && !l7) field.offset = d.read_shift(4);
      field.len = d.read_shift(1);
      if (ft == 2) field.offset = d.read_shift(2);
      field.dec = d.read_shift(1);
      if (field.name.length) fields.push(field);
      if (ft != 2) d.l += l7 ? 13 : 14;
      switch (field.type) {
        case "B":
          if ((!vfp || field.len != 8) && opts.WTF) console.log("Skipping " + field.name + ":" + field.type);
          break;
        case "G":
        case "P":
          if (opts.WTF) console.log("Skipping " + field.name + ":" + field.type);
          break;
        case "+":
        case "0":
        case "@":
        case "C":
        case "D":
        case "F":
        case "I":
        case "L":
        case "M":
        case "N":
        case "O":
        case "T":
        case "Y":
          break;
        default:
          throw new Error("Unknown Field Type: " + field.type);
      }
    }
    if (d[d.l] !== 13) d.l = fpos - 1;
    if (d.read_shift(1) !== 13) throw new Error("DBF Terminator not found " + d.l + " " + d[d.l]);
    d.l = fpos;
    var R = 0, C2 = 0;
    out[0] = [];
    for (C2 = 0; C2 != fields.length; ++C2) out[0][C2] = fields[C2].name;
    while (nrow-- > 0) {
      if (d[d.l] === 42) {
        d.l += rlen;
        continue;
      }
      ++d.l;
      out[++R] = [];
      C2 = 0;
      for (C2 = 0; C2 != fields.length; ++C2) {
        var dd = d.slice(d.l, d.l + fields[C2].len);
        d.l += fields[C2].len;
        prep_blob(dd, 0);
        var s = a2s(dd);
        switch (fields[C2].type) {
          case "C":
            if (s.trim().length) out[R][C2] = s.replace(/([^\s])\s+$/, "$1");
            break;
          case "D":
            if (s.length === 8) {
              out[R][C2] = new Date(Date.UTC(+s.slice(0, 4), +s.slice(4, 6) - 1, +s.slice(6, 8), 0, 0, 0, 0));
              if (!opts.UTC) {
                out[R][C2] = utc_to_local(out[R][C2]);
              }
            } else out[R][C2] = s;
            break;
          case "F":
            out[R][C2] = parseFloat(s.trim());
            break;
          case "+":
          case "I":
            out[R][C2] = l7 ? dd.read_shift(-4, "i") ^ 2147483648 : dd.read_shift(4, "i");
            break;
          case "L":
            switch (s.trim().toUpperCase()) {
              case "Y":
              case "T":
                out[R][C2] = true;
                break;
              case "N":
              case "F":
                out[R][C2] = false;
                break;
              case "":
              case "\0":
              case "?":
                break;
              default:
                throw new Error("DBF Unrecognized L:|" + s + "|");
            }
            break;
          case "M":
            if (!memo) throw new Error("DBF Unexpected MEMO for type " + ft.toString(16));
            out[R][C2] = "##MEMO##" + (l7 ? parseInt(s.trim(), 10) : dd.read_shift(4));
            break;
          case "N":
            s = s.replace(/\u0000/g, "").trim();
            if (s && s != ".") out[R][C2] = +s || 0;
            break;
          case "@":
            out[R][C2] = new Date(dd.read_shift(-8, "f") - 621356832e5);
            break;
          case "T":
            {
              var hi = dd.read_shift(4), lo = dd.read_shift(4);
              if (hi == 0 && lo == 0) break;
              out[R][C2] = new Date((hi - 2440588) * 864e5 + lo);
              if (!opts.UTC) out[R][C2] = utc_to_local(out[R][C2]);
            }
            break;
          case "Y":
            out[R][C2] = dd.read_shift(4, "i") / 1e4 + dd.read_shift(4, "i") / 1e4 * Math.pow(2, 32);
            break;
          case "O":
            out[R][C2] = -dd.read_shift(-8, "f");
            break;
          case "B":
            if (vfp && fields[C2].len == 8) {
              out[R][C2] = dd.read_shift(8, "f");
              break;
            }
          case "G":
          case "P":
            dd.l += fields[C2].len;
            break;
          case "0":
            if (fields[C2].name === "_NullFlags") break;
          default:
            throw new Error("DBF Unsupported data type " + fields[C2].type);
        }
      }
    }
    if (ft != 2) {
      if (d.l < d.length && d[d.l++] != 26) throw new Error("DBF EOF Marker missing " + (d.l - 1) + " of " + d.length + " " + d[d.l - 1].toString(16));
    }
    if (opts.sheetRows) out = out.slice(0, opts.sheetRows);
    opts.DBF = fields;
    return out;
  }
  function dbf_to_sheet(buf, opts) {
    var o = opts || {};
    if (!o.dateNF) o.dateNF = "yyyymmdd";
    var ws = aoa_to_sheet(dbf_to_aoa(buf, o), o);
    ws["!cols"] = o.DBF.map(function(field) {
      return {
        wch: field.len,
        DBF: field
      };
    });
    delete o.DBF;
    return ws;
  }
  function dbf_to_workbook(buf, opts) {
    try {
      var o = sheet_to_workbook(dbf_to_sheet(buf, opts), opts);
      o.bookType = "dbf";
      return o;
    } catch (e) {
      if (opts && opts.WTF) throw e;
    }
    return { SheetNames: [], Sheets: {} };
  }
  var _RLEN = { "B": 8, "C": 250, "L": 1, "D": 8, "?": 0, "": 0 };
  function sheet_to_dbf(ws, opts) {
    if (!ws["!ref"]) throw new Error("Cannot export empty sheet to DBF");
    var o = opts || {};
    var old_cp = current_codepage;
    if (+o.codepage >= 0) set_cp(+o.codepage);
    if (o.type == "string") throw new Error("Cannot write DBF to JS string");
    var ba = buf_array();
    var aoa = sheet_to_json(ws, { header: 1, raw: true, cellDates: true });
    var headers = aoa[0], data = aoa.slice(1), cols = ws["!cols"] || [];
    var i = 0, j = 0, hcnt = 0, rlen = 1;
    for (i = 0; i < headers.length; ++i) {
      if (((cols[i] || {}).DBF || {}).name) {
        headers[i] = cols[i].DBF.name;
        ++hcnt;
        continue;
      }
      if (headers[i] == null) continue;
      ++hcnt;
      if (typeof headers[i] === "number") headers[i] = headers[i].toString(10);
      if (typeof headers[i] !== "string") throw new Error("DBF Invalid column name " + headers[i] + " |" + typeof headers[i] + "|");
      if (headers.indexOf(headers[i]) !== i) {
        for (j = 0; j < 1024; ++j)
          if (headers.indexOf(headers[i] + "_" + j) == -1) {
            headers[i] += "_" + j;
            break;
          }
      }
    }
    var range = safe_decode_range(ws["!ref"]);
    var coltypes = [];
    var colwidths = [];
    var coldecimals = [];
    for (i = 0; i <= range.e.c - range.s.c; ++i) {
      var guess = "", _guess = "", maxlen = 0;
      var col = [];
      for (j = 0; j < data.length; ++j) {
        if (data[j][i] != null) col.push(data[j][i]);
      }
      if (col.length == 0 || headers[i] == null) {
        coltypes[i] = "?";
        continue;
      }
      for (j = 0; j < col.length; ++j) {
        switch (typeof col[j]) {
          case "number":
            _guess = "B";
            break;
          case "string":
            _guess = "C";
            break;
          case "boolean":
            _guess = "L";
            break;
          case "object":
            _guess = col[j] instanceof Date ? "D" : "C";
            break;
          default:
            _guess = "C";
        }
        maxlen = Math.max(maxlen, String(col[j]).length);
        guess = guess && guess != _guess ? "C" : _guess;
      }
      if (maxlen > 250) maxlen = 250;
      _guess = ((cols[i] || {}).DBF || {}).type;
      if (_guess == "C") {
        if (cols[i].DBF.len > maxlen) maxlen = cols[i].DBF.len;
      }
      if (guess == "B" && _guess == "N") {
        guess = "N";
        coldecimals[i] = cols[i].DBF.dec;
        maxlen = cols[i].DBF.len;
      }
      colwidths[i] = guess == "C" || _guess == "N" ? maxlen : _RLEN[guess] || 0;
      rlen += colwidths[i];
      coltypes[i] = guess;
    }
    var h2 = ba.next(32);
    h2.write_shift(4, 318902576);
    h2.write_shift(4, data.length);
    h2.write_shift(2, 296 + 32 * hcnt);
    h2.write_shift(2, rlen);
    for (i = 0; i < 4; ++i) h2.write_shift(4, 0);
    var cp = +dbf_reverse_map[
      /*::String(*/
      current_codepage
      /*::)*/
    ] || 3;
    h2.write_shift(4, 0 | cp << 8);
    if (dbf_codepage_map[cp] != +o.codepage) {
      if (o.codepage) console.error("DBF Unsupported codepage " + current_codepage + ", using 1252");
      current_codepage = 1252;
    }
    for (i = 0, j = 0; i < headers.length; ++i) {
      if (headers[i] == null) continue;
      var hf = ba.next(32);
      var _f = (headers[i].slice(-10) + "\0\0\0\0\0\0\0\0\0\0\0").slice(0, 11);
      hf.write_shift(1, _f, "sbcs");
      hf.write_shift(1, coltypes[i] == "?" ? "C" : coltypes[i], "sbcs");
      hf.write_shift(4, j);
      hf.write_shift(1, colwidths[i] || _RLEN[coltypes[i]] || 0);
      hf.write_shift(1, coldecimals[i] || 0);
      hf.write_shift(1, 2);
      hf.write_shift(4, 0);
      hf.write_shift(1, 0);
      hf.write_shift(4, 0);
      hf.write_shift(4, 0);
      j += colwidths[i] || _RLEN[coltypes[i]] || 0;
    }
    var hb = ba.next(264);
    hb.write_shift(4, 13);
    for (i = 0; i < 65; ++i) hb.write_shift(4, 0);
    for (i = 0; i < data.length; ++i) {
      var rout = ba.next(rlen);
      rout.write_shift(1, 0);
      for (j = 0; j < headers.length; ++j) {
        if (headers[j] == null) continue;
        switch (coltypes[j]) {
          case "L":
            rout.write_shift(1, data[i][j] == null ? 63 : data[i][j] ? 84 : 70);
            break;
          case "B":
            rout.write_shift(8, data[i][j] || 0, "f");
            break;
          case "N":
            var _n = "0";
            if (typeof data[i][j] == "number") _n = data[i][j].toFixed(coldecimals[j] || 0);
            if (_n.length > colwidths[j]) _n = _n.slice(0, colwidths[j]);
            for (hcnt = 0; hcnt < colwidths[j] - _n.length; ++hcnt) rout.write_shift(1, 32);
            rout.write_shift(1, _n, "sbcs");
            break;
          case "D":
            if (!data[i][j]) rout.write_shift(8, "00000000", "sbcs");
            else {
              rout.write_shift(4, ("0000" + data[i][j].getFullYear()).slice(-4), "sbcs");
              rout.write_shift(2, ("00" + (data[i][j].getMonth() + 1)).slice(-2), "sbcs");
              rout.write_shift(2, ("00" + data[i][j].getDate()).slice(-2), "sbcs");
            }
            break;
          case "C":
            var _l = rout.l;
            var _s = String(data[i][j] != null ? data[i][j] : "").slice(0, colwidths[j]);
            rout.write_shift(1, _s, "cpstr");
            _l += colwidths[j] - rout.l;
            for (hcnt = 0; hcnt < _l; ++hcnt) rout.write_shift(1, 32);
            break;
        }
      }
    }
    current_codepage = old_cp;
    ba.next(1).write_shift(1, 26);
    return ba.end();
  }
  return {
    to_workbook: dbf_to_workbook,
    to_sheet: dbf_to_sheet,
    from_sheet: sheet_to_dbf
  };
}();
var SYLK = /* @__PURE__ */ function() {
  var sylk_escapes = {
    AA: "",
    BA: "",
    CA: "",
    DA: 195,
    HA: "",
    JA: 197,
    AE: "",
    BE: "",
    CE: "",
    HE: "",
    AI: "",
    BI: "",
    CI: "",
    HI: "",
    AO: "",
    BO: "",
    CO: "",
    DO: 213,
    HO: "",
    AU: "",
    BU: "",
    CU: "",
    HU: "",
    Aa: "",
    Ba: "",
    Ca: "",
    Da: 227,
    Ha: "",
    Ja: 229,
    Ae: "",
    Be: "",
    Ce: "",
    He: "",
    Ai: "",
    Bi: "",
    Ci: "",
    Hi: "",
    Ao: "",
    Bo: "",
    Co: "",
    Do: 245,
    Ho: "",
    Au: "",
    Bu: "",
    Cu: "",
    Hu: "",
    KC: "",
    Kc: "",
    q: "",
    z: "",
    a: "",
    j: "",
    DN: 209,
    Dn: 241,
    Hy: 255,
    S: 169,
    c: 170,
    R: 174,
    "B ": 180,
    0: 176,
    1: 177,
    2: 178,
    3: 179,
    5: 181,
    6: 182,
    7: 183,
    Q: 185,
    k: 186,
    b: 208,
    i: 216,
    l: 222,
    s: 240,
    y: 248,
    "!": 161,
    '"': 162,
    "#": 163,
    "(": 164,
    "%": 165,
    "'": 167,
    "H ": 168,
    "+": 171,
    ";": 187,
    "<": 188,
    "=": 189,
    ">": 190,
    "?": 191,
    "{": 223
  };
  var sylk_char_regex = new RegExp("\x1BN(" + keys(sylk_escapes).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1").replace("{", "\\{") + "|\\|)", "gm");
  try {
    sylk_char_regex = new RegExp("\x1BN(" + keys(sylk_escapes).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1") + "|\\|)", "gm");
  } catch (e) {
  }
  var sylk_char_fn = function(_2, $1) {
    var o = sylk_escapes[$1];
    return typeof o == "number" ? _getansi(o) : o;
  };
  var decode_sylk_char = function($$, $1, $2) {
    var newcc = $1.charCodeAt(0) - 32 << 4 | $2.charCodeAt(0) - 48;
    return newcc == 59 ? $$ : _getansi(newcc);
  };
  sylk_escapes["|"] = 254;
  var encode_sylk_str = function($$) {
    return $$.replace(/\n/g, "\x1B :").replace(/\r/g, "\x1B =");
  };
  function sylk_to_aoa(d, opts) {
    switch (opts.type) {
      case "base64":
        return sylk_to_aoa_str(Base64_decode(d), opts);
      case "binary":
        return sylk_to_aoa_str(d, opts);
      case "buffer":
        return sylk_to_aoa_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
      case "array":
        return sylk_to_aoa_str(cc2str(d), opts);
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  function sylk_to_aoa_str(str, opts) {
    var records = str.split(/[\n\r]+/), R = -1, C2 = -1, ri = 0, rj = 0, arr = [];
    var formats = [];
    var next_cell_format = null;
    var sht = {}, rowinfo = [], colinfo = [], cw = [];
    var Mval = 0, j;
    var wb = { Workbook: { WBProps: {}, Names: [] } };
    if (+opts.codepage >= 0) set_cp(+opts.codepage);
    for (; ri !== records.length; ++ri) {
      Mval = 0;
      var rstr = records[ri].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g, decode_sylk_char).replace(sylk_char_regex, sylk_char_fn);
      var record = rstr.replace(/;;/g, "\0").split(";").map(function(x) {
        return x.replace(/\u0000/g, ";");
      });
      var RT = record[0], val;
      if (rstr.length > 0) switch (RT) {
        case "ID":
          break;
        case "E":
          break;
        case "B":
          break;
        case "O":
          for (rj = 1; rj < record.length; ++rj) switch (record[rj].charAt(0)) {
            case "V":
              {
                var d1904 = parseInt(record[rj].slice(1), 10);
                if (d1904 >= 1 && d1904 <= 4) wb.Workbook.WBProps.date1904 = true;
              }
              break;
          }
          break;
        case "W":
          break;
        case "P":
          switch (record[1].charAt(0)) {
            case "P":
              formats.push(rstr.slice(3).replace(/;;/g, ";"));
              break;
          }
          break;
        case "NN":
          {
            var nn = { Sheet: 0 };
            for (rj = 1; rj < record.length; ++rj) switch (record[rj].charAt(0)) {
              case "N":
                nn.Name = record[rj].slice(1);
                break;
              case "E":
                nn.Ref = (opts && opts.sheet || "Sheet1") + "!" + rc_to_a1(record[rj].slice(1));
                break;
            }
            wb.Workbook.Names.push(nn);
          }
          break;
        case "C":
          var C_seen_K = false, C_seen_X = false, C_seen_S = false, C_seen_E = false, _R = -1, _C = -1, formula = "", cell_t = "z";
          var cmnt = "";
          for (rj = 1; rj < record.length; ++rj) switch (record[rj].charAt(0)) {
            case "A":
              cmnt = record[rj].slice(1);
              break;
            case "X":
              C2 = parseInt(record[rj].slice(1), 10) - 1;
              C_seen_X = true;
              break;
            case "Y":
              R = parseInt(record[rj].slice(1), 10) - 1;
              if (!C_seen_X) C2 = 0;
              for (j = arr.length; j <= R; ++j) arr[j] = [];
              break;
            case "K":
              val = record[rj].slice(1);
              if (val.charAt(0) === '"') {
                val = val.slice(1, val.length - 1);
                cell_t = "s";
              } else if (val === "TRUE" || val === "FALSE") {
                val = val === "TRUE";
                cell_t = "b";
              } else if (val.charAt(0) == "#" && RBErr[val] != null) {
                cell_t = "e";
                val = RBErr[val];
              } else if (!isNaN(fuzzynum(val))) {
                val = fuzzynum(val);
                cell_t = "n";
                if (next_cell_format !== null && fmt_is_date(next_cell_format) && opts.cellDates) {
                  val = numdate(wb.Workbook.WBProps.date1904 ? val + 1462 : val);
                  cell_t = typeof val == "number" ? "n" : "d";
                }
              }
              C_seen_K = true;
              break;
            case "E":
              C_seen_E = true;
              formula = rc_to_a1(record[rj].slice(1), { r: R, c: C2 });
              break;
            case "S":
              C_seen_S = true;
              break;
            case "G":
              break;
            case "R":
              _R = parseInt(record[rj].slice(1), 10) - 1;
              break;
            case "C":
              _C = parseInt(record[rj].slice(1), 10) - 1;
              break;
            default:
              if (opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
          }
          if (C_seen_K) {
            if (!arr[R][C2]) arr[R][C2] = { t: cell_t, v: val };
            else {
              arr[R][C2].t = cell_t;
              arr[R][C2].v = val;
            }
            if (next_cell_format) arr[R][C2].z = next_cell_format;
            if (opts.cellText !== false && next_cell_format) arr[R][C2].w = SSF_format(arr[R][C2].z, arr[R][C2].v, { date1904: wb.Workbook.WBProps.date1904 });
            next_cell_format = null;
          }
          if (C_seen_S) {
            if (C_seen_E) throw new Error("SYLK shared formula cannot have own formula");
            var shrbase = _R > -1 && arr[_R][_C];
            if (!shrbase || !shrbase[1]) throw new Error("SYLK shared formula cannot find base");
            formula = shift_formula_str(shrbase[1], { r: R - _R, c: C2 - _C });
          }
          if (formula) {
            if (!arr[R][C2]) arr[R][C2] = { t: "n", f: formula };
            else arr[R][C2].f = formula;
          }
          if (cmnt) {
            if (!arr[R][C2]) arr[R][C2] = { t: "z" };
            arr[R][C2].c = [{ a: "SheetJSYLK", t: cmnt }];
          }
          break;
        case "F":
          var F_seen = 0;
          for (rj = 1; rj < record.length; ++rj) switch (record[rj].charAt(0)) {
            case "X":
              C2 = parseInt(record[rj].slice(1), 10) - 1;
              ++F_seen;
              break;
            case "Y":
              R = parseInt(record[rj].slice(1), 10) - 1;
              for (j = arr.length; j <= R; ++j) arr[j] = [];
              break;
            case "M":
              Mval = parseInt(record[rj].slice(1), 10) / 20;
              break;
            case "F":
              break;
            case "G":
              break;
            case "P":
              next_cell_format = formats[parseInt(record[rj].slice(1), 10)];
              break;
            case "S":
              break;
            case "D":
              break;
            case "N":
              break;
            case "W":
              cw = record[rj].slice(1).split(" ");
              for (j = parseInt(cw[0], 10); j <= parseInt(cw[1], 10); ++j) {
                Mval = parseInt(cw[2], 10);
                colinfo[j - 1] = Mval === 0 ? { hidden: true } : { wch: Mval };
              }
              break;
            case "C":
              C2 = parseInt(record[rj].slice(1), 10) - 1;
              if (!colinfo[C2]) colinfo[C2] = {};
              break;
            case "R":
              R = parseInt(record[rj].slice(1), 10) - 1;
              if (!rowinfo[R]) rowinfo[R] = {};
              if (Mval > 0) {
                rowinfo[R].hpt = Mval;
                rowinfo[R].hpx = pt2px(Mval);
              } else if (Mval === 0) rowinfo[R].hidden = true;
              break;
            default:
              if (opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
          }
          if (F_seen < 1) next_cell_format = null;
          break;
        default:
          if (opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
      }
    }
    if (rowinfo.length > 0) sht["!rows"] = rowinfo;
    if (colinfo.length > 0) sht["!cols"] = colinfo;
    colinfo.forEach(function(col) {
      process_col(col);
    });
    if (opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
    return [arr, sht, wb];
  }
  function sylk_to_workbook(d, opts) {
    var aoasht = sylk_to_aoa(d, opts);
    var aoa = aoasht[0], ws = aoasht[1], wb = aoasht[2];
    var _opts = dup(opts);
    _opts.date1904 = (((wb || {}).Workbook || {}).WBProps || {}).date1904;
    var o = aoa_to_sheet(aoa, _opts);
    keys(ws).forEach(function(k2) {
      o[k2] = ws[k2];
    });
    var outwb = sheet_to_workbook(o, opts);
    keys(wb).forEach(function(k2) {
      outwb[k2] = wb[k2];
    });
    outwb.bookType = "sylk";
    return outwb;
  }
  function write_ws_cell_sylk(cell, ws, R, C2, opts, date1904) {
    var o = "C;Y" + (R + 1) + ";X" + (C2 + 1) + ";K";
    switch (cell.t) {
      case "n":
        o += cell.v || 0;
        if (cell.f && !cell.F) o += ";E" + a1_to_rc(cell.f, { r: R, c: C2 });
        break;
      case "b":
        o += cell.v ? "TRUE" : "FALSE";
        break;
      case "e":
        o += cell.w || BErr[cell.v] || cell.v;
        break;
      case "d":
        o += datenum(parseDate(cell.v, date1904), date1904);
        break;
      case "s":
        o += '"' + (cell.v == null ? "" : String(cell.v)).replace(/"/g, "").replace(/;/g, ";;") + '"';
        break;
    }
    return o;
  }
  function write_ws_cmnt_sylk(cmnt, R, C2) {
    var o = "C;Y" + (R + 1) + ";X" + (C2 + 1) + ";A";
    o += encode_sylk_str(cmnt.map(function(c2) {
      return c2.t;
    }).join(""));
    return o;
  }
  function write_ws_cols_sylk(out, cols) {
    cols.forEach(function(col, i) {
      var rec = "F;W" + (i + 1) + " " + (i + 1) + " ";
      if (col.hidden) rec += "0";
      else {
        if (typeof col.width == "number" && !col.wpx) col.wpx = width2px(col.width);
        if (typeof col.wpx == "number" && !col.wch) col.wch = px2char(col.wpx);
        if (typeof col.wch == "number") rec += Math.round(col.wch);
      }
      if (rec.charAt(rec.length - 1) != " ") out.push(rec);
    });
  }
  function write_ws_rows_sylk(out, rows) {
    rows.forEach(function(row, i) {
      var rec = "F;";
      if (row.hidden) rec += "M0;";
      else if (row.hpt) rec += "M" + 20 * row.hpt + ";";
      else if (row.hpx) rec += "M" + 20 * px2pt(row.hpx) + ";";
      if (rec.length > 2) out.push(rec + "R" + (i + 1));
    });
  }
  function sheet_to_sylk(ws, opts, wb) {
    if (!opts) opts = {};
    opts._formats = ["General"];
    var preamble = ["ID;PSheetJS;N;E"], o = [];
    var r = safe_decode_range(ws["!ref"] || "A1"), cell;
    var dense = ws["!data"] != null;
    var RS = "\r\n";
    var d1904 = (((wb || {}).Workbook || {}).WBProps || {}).date1904;
    var _lastfmt = "General";
    preamble.push("P;PGeneral");
    var R = r.s.r, C2 = r.s.c, p = [];
    if (ws["!ref"]) for (R = r.s.r; R <= r.e.r; ++R) {
      if (dense && !ws["!data"][R]) continue;
      p = [];
      for (C2 = r.s.c; C2 <= r.e.c; ++C2) {
        cell = dense ? ws["!data"][R][C2] : ws[encode_col(C2) + encode_row(R)];
        if (!cell || !cell.c) continue;
        p.push(write_ws_cmnt_sylk(cell.c, R, C2));
      }
      if (p.length) o.push(p.join(RS));
    }
    if (ws["!ref"]) for (R = r.s.r; R <= r.e.r; ++R) {
      if (dense && !ws["!data"][R]) continue;
      p = [];
      for (C2 = r.s.c; C2 <= r.e.c; ++C2) {
        cell = dense ? ws["!data"][R][C2] : ws[encode_col(C2) + encode_row(R)];
        if (!cell || cell.v == null && (!cell.f || cell.F)) continue;
        if ((cell.z || (cell.t == "d" ? table_fmt[14] : "General")) != _lastfmt) {
          var ifmt = opts._formats.indexOf(cell.z);
          if (ifmt == -1) {
            opts._formats.push(cell.z);
            ifmt = opts._formats.length - 1;
            preamble.push("P;P" + cell.z.replace(/;/g, ";;"));
          }
          p.push("F;P" + ifmt + ";Y" + (R + 1) + ";X" + (C2 + 1));
        }
        p.push(write_ws_cell_sylk(cell, ws, R, C2, opts, d1904));
      }
      o.push(p.join(RS));
    }
    preamble.push("F;P0;DG0G8;M255");
    if (ws["!cols"]) write_ws_cols_sylk(preamble, ws["!cols"]);
    if (ws["!rows"]) write_ws_rows_sylk(preamble, ws["!rows"]);
    if (ws["!ref"]) preamble.push("B;Y" + (r.e.r - r.s.r + 1) + ";X" + (r.e.c - r.s.c + 1) + ";D" + [r.s.c, r.s.r, r.e.c, r.e.r].join(" "));
    preamble.push("O;L;D;B" + (d1904 ? ";V4" : "") + ";K47;G100 0.001");
    delete opts._formats;
    return preamble.join(RS) + RS + o.join(RS) + RS + "E" + RS;
  }
  return {
    to_workbook: sylk_to_workbook,
    from_sheet: sheet_to_sylk
  };
}();
var DIF = /* @__PURE__ */ function() {
  function dif_to_aoa(d, opts) {
    switch (opts.type) {
      case "base64":
        return dif_to_aoa_str(Base64_decode(d), opts);
      case "binary":
        return dif_to_aoa_str(d, opts);
      case "buffer":
        return dif_to_aoa_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
      case "array":
        return dif_to_aoa_str(cc2str(d), opts);
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  function dif_to_aoa_str(str, opts) {
    var records = str.split("\n"), R = -1, C2 = -1, ri = 0, arr = [];
    for (; ri !== records.length; ++ri) {
      if (records[ri].trim() === "BOT") {
        arr[++R] = [];
        C2 = 0;
        continue;
      }
      if (R < 0) continue;
      var metadata = records[ri].trim().split(",");
      var type = metadata[0], value = metadata[1];
      ++ri;
      var data = records[ri] || "";
      while ((data.match(/["]/g) || []).length & 1 && ri < records.length - 1) data += "\n" + records[++ri];
      data = data.trim();
      switch (+type) {
        case -1:
          if (data === "BOT") {
            arr[++R] = [];
            C2 = 0;
            continue;
          } else if (data !== "EOD") throw new Error("Unrecognized DIF special command " + data);
          break;
        case 0:
          if (data === "TRUE") arr[R][C2] = true;
          else if (data === "FALSE") arr[R][C2] = false;
          else if (!isNaN(fuzzynum(value))) arr[R][C2] = fuzzynum(value);
          else if (!isNaN(fuzzydate(value).getDate())) {
            arr[R][C2] = parseDate(value);
            if (!(opts && opts.UTC)) {
              arr[R][C2] = utc_to_local(arr[R][C2]);
            }
          } else arr[R][C2] = value;
          ++C2;
          break;
        case 1:
          data = data.slice(1, data.length - 1);
          data = data.replace(/""/g, '"');
          if (data && data.match(/^=".*"$/)) data = data.slice(2, -1);
          arr[R][C2++] = data !== "" ? data : null;
          break;
      }
      if (data === "EOD") break;
    }
    if (opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
    return arr;
  }
  function dif_to_sheet(str, opts) {
    return aoa_to_sheet(dif_to_aoa(str, opts), opts);
  }
  function dif_to_workbook(str, opts) {
    var o = sheet_to_workbook(dif_to_sheet(str, opts), opts);
    o.bookType = "dif";
    return o;
  }
  function make_value(v2, s) {
    return "0," + String(v2) + "\r\n" + s;
  }
  function make_value_str(s) {
    return '1,0\r\n"' + s.replace(/"/g, '""') + '"';
  }
  function sheet_to_dif(ws) {
    if (!ws["!ref"]) throw new Error("Cannot export empty sheet to DIF");
    var r = safe_decode_range(ws["!ref"]);
    var dense = ws["!data"] != null;
    var o = [
      'TABLE\r\n0,1\r\n"sheetjs"\r\n',
      "VECTORS\r\n0," + (r.e.r - r.s.r + 1) + '\r\n""\r\n',
      "TUPLES\r\n0," + (r.e.c - r.s.c + 1) + '\r\n""\r\n',
      'DATA\r\n0,0\r\n""\r\n'
    ];
    for (var R = r.s.r; R <= r.e.r; ++R) {
      var row = dense ? ws["!data"][R] : [];
      var p = "-1,0\r\nBOT\r\n";
      for (var C2 = r.s.c; C2 <= r.e.c; ++C2) {
        var cell = dense ? row && row[C2] : ws[encode_cell({ r: R, c: C2 })];
        if (cell == null) {
          p += '1,0\r\n""\r\n';
          continue;
        }
        switch (cell.t) {
          case "n":
            {
              if (cell.w != null) p += "0," + cell.w + "\r\nV";
              else if (cell.v != null) p += make_value(cell.v, "V");
              else if (cell.f != null && !cell.F) p += make_value_str("=" + cell.f);
              else p += '1,0\r\n""';
            }
            break;
          case "b":
            p += cell.v ? make_value(1, "TRUE") : make_value(0, "FALSE");
            break;
          case "s":
            p += make_value_str(isNaN(+cell.v) ? cell.v : '="' + cell.v + '"');
            break;
          case "d":
            if (!cell.w) cell.w = SSF_format(cell.z || table_fmt[14], datenum(parseDate(cell.v)));
            p += make_value(cell.w, "V");
            break;
          default:
            p += '1,0\r\n""';
        }
        p += "\r\n";
      }
      o.push(p);
    }
    return o.join("") + "-1,0\r\nEOD";
  }
  return {
    to_workbook: dif_to_workbook,
    to_sheet: dif_to_sheet,
    from_sheet: sheet_to_dif
  };
}();
var ETH = /* @__PURE__ */ function() {
  function decode(s) {
    return s.replace(/\\b/g, "\\").replace(/\\c/g, ":").replace(/\\n/g, "\n");
  }
  function encode(s) {
    return s.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g, "\\n");
  }
  function eth_to_aoa(str, opts) {
    var records = str.split("\n"), R = -1, C2 = -1, ri = 0, arr = [];
    for (; ri !== records.length; ++ri) {
      var record = records[ri].trim().split(":");
      if (record[0] !== "cell") continue;
      var addr = decode_cell(record[1]);
      if (arr.length <= addr.r) {
        for (R = arr.length; R <= addr.r; ++R) if (!arr[R]) arr[R] = [];
      }
      R = addr.r;
      C2 = addr.c;
      switch (record[2]) {
        case "t":
          arr[R][C2] = decode(record[3]);
          break;
        case "v":
          arr[R][C2] = +record[3];
          break;
        case "vtf":
          var _f = record[record.length - 1];
        case "vtc":
          switch (record[3]) {
            case "nl":
              arr[R][C2] = +record[4] ? true : false;
              break;
            default:
              arr[R][C2] = +record[4];
              break;
          }
          if (record[2] == "vtf") arr[R][C2] = [arr[R][C2], _f];
      }
    }
    if (opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
    return arr;
  }
  function eth_to_sheet(d, opts) {
    return aoa_to_sheet(eth_to_aoa(d, opts), opts);
  }
  function eth_to_workbook(d, opts) {
    return sheet_to_workbook(eth_to_sheet(d, opts), opts);
  }
  var header = [
    "socialcalc:version:1.5",
    "MIME-Version: 1.0",
    "Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"
  ].join("\n");
  var sep = [
    "--SocialCalcSpreadsheetControlSave",
    "Content-type: text/plain; charset=UTF-8"
  ].join("\n") + "\n";
  var meta = [
    "# SocialCalc Spreadsheet Control Save",
    "part:sheet"
  ].join("\n");
  var end = "--SocialCalcSpreadsheetControlSave--";
  function sheet_to_eth_data(ws) {
    if (!ws || !ws["!ref"]) return "";
    var o = [], oo = [], cell, coord = "";
    var r = decode_range(ws["!ref"]);
    var dense = ws["!data"] != null;
    for (var R = r.s.r; R <= r.e.r; ++R) {
      for (var C2 = r.s.c; C2 <= r.e.c; ++C2) {
        coord = encode_cell({ r: R, c: C2 });
        cell = dense ? (ws["!data"][R] || [])[C2] : ws[coord];
        if (!cell || cell.v == null || cell.t === "z") continue;
        oo = ["cell", coord, "t"];
        switch (cell.t) {
          case "s":
          case "str":
            oo.push(encode(cell.v));
            break;
          case "n":
            if (!cell.f) {
              oo[2] = "v";
              oo[3] = cell.v;
            } else {
              oo[2] = "vtf";
              oo[3] = "n";
              oo[4] = cell.v;
              oo[5] = encode(cell.f);
            }
            break;
          case "b":
            oo[2] = "vt" + (cell.f ? "f" : "c");
            oo[3] = "nl";
            oo[4] = cell.v ? "1" : "0";
            oo[5] = encode(cell.f || (cell.v ? "TRUE" : "FALSE"));
            break;
          case "d":
            var t = datenum(parseDate(cell.v));
            oo[2] = "vtc";
            oo[3] = "nd";
            oo[4] = "" + t;
            oo[5] = cell.w || SSF_format(cell.z || table_fmt[14], t);
            break;
          case "e":
            continue;
        }
        o.push(oo.join(":"));
      }
    }
    o.push("sheet:c:" + (r.e.c - r.s.c + 1) + ":r:" + (r.e.r - r.s.r + 1) + ":tvf:1");
    o.push("valueformat:1:text-wiki");
    return o.join("\n");
  }
  function sheet_to_eth(ws) {
    return [header, sep, meta, sep, sheet_to_eth_data(ws), end].join("\n");
  }
  return {
    to_workbook: eth_to_workbook,
    to_sheet: eth_to_sheet,
    from_sheet: sheet_to_eth
  };
}();
var PRN = /* @__PURE__ */ function() {
  function set_text_arr(data, arr, R, C2, o) {
    if (o.raw) arr[R][C2] = data;
    else if (data === "") ;
    else if (data === "TRUE") arr[R][C2] = true;
    else if (data === "FALSE") arr[R][C2] = false;
    else if (!isNaN(fuzzynum(data))) arr[R][C2] = fuzzynum(data);
    else if (!isNaN(fuzzydate(data).getDate())) arr[R][C2] = parseDate(data);
    else arr[R][C2] = data;
  }
  function prn_to_aoa_str(f, opts) {
    var o = opts || {};
    var arr = [];
    if (!f || f.length === 0) return arr;
    var lines = f.split(/[\r\n]/);
    var L = lines.length - 1;
    while (L >= 0 && lines[L].length === 0) --L;
    var start = 10, idx = 0;
    var R = 0;
    for (; R <= L; ++R) {
      idx = lines[R].indexOf(" ");
      if (idx == -1) idx = lines[R].length;
      else idx++;
      start = Math.max(start, idx);
    }
    for (R = 0; R <= L; ++R) {
      arr[R] = [];
      var C2 = 0;
      set_text_arr(lines[R].slice(0, start).trim(), arr, R, C2, o);
      for (C2 = 1; C2 <= (lines[R].length - start) / 10 + 1; ++C2)
        set_text_arr(lines[R].slice(start + (C2 - 1) * 10, start + C2 * 10).trim(), arr, R, C2, o);
    }
    if (o.sheetRows) arr = arr.slice(0, o.sheetRows);
    return arr;
  }
  var guess_seps = {
    44: ",",
    9: "	",
    59: ";",
    124: "|"
  };
  var guess_sep_weights = {
    44: 3,
    9: 2,
    59: 1,
    124: 0
  };
  function guess_sep(str) {
    var cnt = {}, instr = false, end = 0, cc = 0;
    for (; end < str.length; ++end) {
      if ((cc = str.charCodeAt(end)) == 34) instr = !instr;
      else if (!instr && cc in guess_seps) cnt[cc] = (cnt[cc] || 0) + 1;
    }
    cc = [];
    for (end in cnt) if (Object.prototype.hasOwnProperty.call(cnt, end)) {
      cc.push([cnt[end], end]);
    }
    if (!cc.length) {
      cnt = guess_sep_weights;
      for (end in cnt) if (Object.prototype.hasOwnProperty.call(cnt, end)) {
        cc.push([cnt[end], end]);
      }
    }
    cc.sort(function(a, b) {
      return a[0] - b[0] || guess_sep_weights[a[1]] - guess_sep_weights[b[1]];
    });
    return guess_seps[cc.pop()[1]] || 44;
  }
  function dsv_to_sheet_str(str, opts) {
    var o = opts || {};
    var sep = "";
    var ws = {};
    if (o.dense) ws["!data"] = [];
    var range = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    if (str.slice(0, 4) == "sep=") {
      if (str.charCodeAt(5) == 13 && str.charCodeAt(6) == 10) {
        sep = str.charAt(4);
        str = str.slice(7);
      } else if (str.charCodeAt(5) == 13 || str.charCodeAt(5) == 10) {
        sep = str.charAt(4);
        str = str.slice(6);
      } else sep = guess_sep(str.slice(0, 1024));
    } else if (o.FS) sep = o.FS;
    else sep = guess_sep(str.slice(0, 1024));
    var R = 0, C2 = 0, v2 = 0;
    var start = 0, end = 0, sepcc = sep.charCodeAt(0), instr = false, cc = 0, startcc = str.charCodeAt(0);
    var _re = o.dateNF != null ? dateNF_regex(o.dateNF) : null;
    function finish_cell() {
      var s = str.slice(start, end);
      if (s.slice(-1) == "\r") s = s.slice(0, -1);
      var cell = {};
      if (s.charAt(0) == '"' && s.charAt(s.length - 1) == '"') s = s.slice(1, -1).replace(/""/g, '"');
      if (o.cellText !== false) cell.w = s;
      if (s.length === 0) cell.t = "z";
      else if (o.raw) {
        cell.t = "s";
        cell.v = s;
      } else if (s.trim().length === 0) {
        cell.t = "s";
        cell.v = s;
      } else if (s.charCodeAt(0) == 61) {
        if (s.charCodeAt(1) == 34 && s.charCodeAt(s.length - 1) == 34) {
          cell.t = "s";
          cell.v = s.slice(2, -1).replace(/""/g, '"');
        } else if (fuzzyfmla(s)) {
          cell.t = "s";
          cell.f = s.slice(1);
          cell.v = s;
        } else {
          cell.t = "s";
          cell.v = s;
        }
      } else if (s == "TRUE") {
        cell.t = "b";
        cell.v = true;
      } else if (s == "FALSE") {
        cell.t = "b";
        cell.v = false;
      } else if (!isNaN(v2 = fuzzynum(s))) {
        cell.t = "n";
        cell.v = v2;
      } else if (!isNaN((v2 = fuzzydate(s)).getDate()) || _re && s.match(_re)) {
        cell.z = o.dateNF || table_fmt[14];
        if (_re && s.match(_re)) {
          var news = dateNF_fix(s, o.dateNF, s.match(_re) || []);
          v2 = parseDate(news);
          if (o.UTC === false) v2 = utc_to_local(v2);
        } else if (o.UTC === false) v2 = utc_to_local(v2);
        else if (o.cellText !== false && o.dateNF) cell.w = SSF_format(cell.z, v2);
        if (o.cellDates) {
          cell.t = "d";
          cell.v = v2;
        } else {
          cell.t = "n";
          cell.v = datenum(v2);
        }
        if (!o.cellNF) delete cell.z;
      } else {
        cell.t = "s";
        cell.v = s;
      }
      if (cell.t == "z") ;
      else if (o.dense) {
        if (!ws["!data"][R]) ws["!data"][R] = [];
        ws["!data"][R][C2] = cell;
      } else ws[encode_cell({ c: C2, r: R })] = cell;
      start = end + 1;
      startcc = str.charCodeAt(start);
      if (range.e.c < C2) range.e.c = C2;
      if (range.e.r < R) range.e.r = R;
      if (cc == sepcc) ++C2;
      else {
        C2 = 0;
        ++R;
        if (o.sheetRows && o.sheetRows <= R) return true;
      }
    }
    outer: for (; end < str.length; ++end) switch (cc = str.charCodeAt(end)) {
      case 34:
        if (startcc === 34) instr = !instr;
        break;
      case 13:
        if (instr) break;
        if (str.charCodeAt(end + 1) == 10) ++end;
      case sepcc:
      case 10:
        if (!instr && finish_cell()) break outer;
        break;
    }
    if (end - start > 0) finish_cell();
    ws["!ref"] = encode_range(range);
    return ws;
  }
  function prn_to_sheet_str(str, opts) {
    if (!(opts && opts.PRN)) return dsv_to_sheet_str(str, opts);
    if (opts.FS) return dsv_to_sheet_str(str, opts);
    if (str.slice(0, 4) == "sep=") return dsv_to_sheet_str(str, opts);
    if (str.indexOf("	") >= 0 || str.indexOf(",") >= 0 || str.indexOf(";") >= 0) return dsv_to_sheet_str(str, opts);
    return aoa_to_sheet(prn_to_aoa_str(str, opts), opts);
  }
  function prn_to_sheet(d, opts) {
    var str = "", bytes = opts.type == "string" ? [0, 0, 0, 0] : firstbyte(d, opts);
    switch (opts.type) {
      case "base64":
        str = Base64_decode(d);
        break;
      case "binary":
        str = d;
        break;
      case "buffer":
        if (opts.codepage == 65001) str = d.toString("utf8");
        else if (opts.codepage && typeof $cptable !== "undefined") ;
        else str = has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d);
        break;
      case "array":
        str = cc2str(d);
        break;
      case "string":
        str = d;
        break;
      default:
        throw new Error("Unrecognized type " + opts.type);
    }
    if (bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191) str = utf8read(str.slice(3));
    else if (opts.type != "string" && opts.type != "buffer" && opts.codepage == 65001) str = utf8read(str);
    else if (opts.type == "binary" && typeof $cptable !== "undefined") ;
    if (str.slice(0, 19) == "socialcalc:version:") return ETH.to_sheet(opts.type == "string" ? str : utf8read(str), opts);
    return prn_to_sheet_str(str, opts);
  }
  function prn_to_workbook(d, opts) {
    return sheet_to_workbook(prn_to_sheet(d, opts), opts);
  }
  function sheet_to_prn(ws) {
    var o = [];
    if (!ws["!ref"]) return "";
    var r = safe_decode_range(ws["!ref"]), cell;
    var dense = ws["!data"] != null;
    for (var R = r.s.r; R <= r.e.r; ++R) {
      var oo = [];
      for (var C2 = r.s.c; C2 <= r.e.c; ++C2) {
        var coord = encode_cell({ r: R, c: C2 });
        cell = dense ? (ws["!data"][R] || [])[C2] : ws[coord];
        if (!cell || cell.v == null) {
          oo.push("          ");
          continue;
        }
        var w = (cell.w || (format_cell(cell), cell.w) || "").slice(0, 10);
        while (w.length < 10) w += " ";
        oo.push(w + (C2 === 0 ? " " : ""));
      }
      o.push(oo.join(""));
    }
    return o.join("\n");
  }
  return {
    to_workbook: prn_to_workbook,
    to_sheet: prn_to_sheet,
    from_sheet: sheet_to_prn
  };
}();
function read_wb_ID(d, opts) {
  var o = opts || {}, OLD_WTF = !!o.WTF;
  o.WTF = true;
  try {
    var out = SYLK.to_workbook(d, o);
    o.WTF = OLD_WTF;
    return out;
  } catch (e) {
    o.WTF = OLD_WTF;
    if (e.message.indexOf("SYLK bad record ID") == -1 && OLD_WTF) throw e;
    return PRN.to_workbook(d, opts);
  }
}
var WK_ = /* @__PURE__ */ function() {
  function lotushopper(data, cb, opts) {
    if (!data) return;
    prep_blob(data, data.l || 0);
    var Enum = opts.Enum || WK1Enum;
    while (data.l < data.length) {
      var RT = data.read_shift(2);
      var R = Enum[RT] || Enum[65535];
      var length = data.read_shift(2);
      var tgt = data.l + length;
      var d = R.f && R.f(data, length, opts);
      data.l = tgt;
      if (cb(d, R, RT)) return;
    }
  }
  function lotus_to_workbook(d, opts) {
    switch (opts.type) {
      case "base64":
        return lotus_to_workbook_buf(s2a(Base64_decode(d)), opts);
      case "binary":
        return lotus_to_workbook_buf(s2a(d), opts);
      case "buffer":
      case "array":
        return lotus_to_workbook_buf(d, opts);
    }
    throw "Unsupported type " + opts.type;
  }
  var LOTUS_DATE_FMTS = [
    "mmmm",
    "dd-mmm-yyyy",
    "dd-mmm",
    "mmm-yyyy",
    "@",
    // "text"?
    "mm/dd",
    "hh:mm:ss AM/PM",
    // 7
    "hh:mm AM/PM",
    "mm/dd/yyyy",
    "mm/dd",
    "hh:mm:ss",
    "hh:mm"
    // 12
  ];
  function lotus_to_workbook_buf(d, opts) {
    if (!d) return d;
    var o = opts || {};
    var s = {}, n = "Sheet1", next_n = "", sidx = 0;
    var sheets = {}, snames = [], realnames = [], sdata = [];
    if (o.dense) sdata = s["!data"] = [];
    var refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
    var sheetRows = o.sheetRows || 0;
    var lastcell = {};
    if (d[4] == 81 && d[5] == 80 && d[6] == 87) return qpw_to_workbook_buf(d, opts);
    if (d[2] == 0) {
      if (d[3] == 8 || d[3] == 9) {
        if (d.length >= 16 && d[14] == 5 && d[15] === 108) throw new Error("Unsupported Works 3 for Mac file");
      }
    }
    if (d[2] == 2) {
      o.Enum = WK1Enum;
      lotushopper(d, function(val, R, RT) {
        switch (RT) {
          case 0:
            o.vers = val;
            if (val >= 4096) o.qpro = true;
            break;
          case 255:
            o.vers = val;
            o.works = true;
            break;
          case 6:
            refguess = val;
            break;
          case 204:
            if (val) next_n = val;
            break;
          case 222:
            next_n = val;
            break;
          case 15:
          case 51:
            if ((!o.qpro && !o.works || RT == 51) && val[1].v.charCodeAt(0) < 48) val[1].v = val[1].v.slice(1);
            if (o.works || o.works2) val[1].v = val[1].v.replace(/\r\n/g, "\n");
          case 13:
          case 14:
          case 16:
            if ((val[2] & 112) == 112 && (val[2] & 15) > 1 && (val[2] & 15) < 15) {
              val[1].z = o.dateNF || LOTUS_DATE_FMTS[(val[2] & 15) - 1] || table_fmt[14];
              if (o.cellDates) {
                val[1].v = numdate(val[1].v);
                val[1].t = typeof val[1].v == "number" ? "n" : "d";
              }
            }
            if (o.qpro) {
              if (val[3] > sidx) {
                s["!ref"] = encode_range(refguess);
                sheets[n] = s;
                snames.push(n);
                s = {};
                if (o.dense) sdata = s["!data"] = [];
                refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
                sidx = val[3];
                n = next_n || "Sheet" + (sidx + 1);
                next_n = "";
              }
            }
            var tmpcell = o.dense ? (sdata[val[0].r] || [])[val[0].c] : s[encode_cell(val[0])];
            if (tmpcell) {
              tmpcell.t = val[1].t;
              tmpcell.v = val[1].v;
              if (val[1].z != null) tmpcell.z = val[1].z;
              if (val[1].f != null) tmpcell.f = val[1].f;
              lastcell = tmpcell;
              break;
            }
            if (o.dense) {
              if (!sdata[val[0].r]) sdata[val[0].r] = [];
              sdata[val[0].r][val[0].c] = val[1];
            } else s[encode_cell(val[0])] = val[1];
            lastcell = val[1];
            break;
          case 21509:
            o.works2 = true;
            break;
          case 21506:
            {
              if (val == 5281) {
                lastcell.z = "hh:mm:ss";
                if (o.cellDates && lastcell.t == "n") {
                  lastcell.v = numdate(lastcell.v);
                  lastcell.t = typeof lastcell.v == "number" ? "n" : "d";
                }
              }
            }
            break;
        }
      }, o);
    } else if (d[2] == 26 || d[2] == 14) {
      o.Enum = WK3Enum;
      if (d[2] == 14) {
        o.qpro = true;
        d.l = 0;
      }
      lotushopper(d, function(val, R, RT) {
        switch (RT) {
          case 204:
            n = val;
            break;
          case 22:
            if (val[1].v.charCodeAt(0) < 48) val[1].v = val[1].v.slice(1);
            val[1].v = val[1].v.replace(/\x0F./g, function($$) {
              return String.fromCharCode($$.charCodeAt(1) - 32);
            }).replace(/\r\n/g, "\n");
          case 23:
          case 24:
          case 25:
          case 37:
          case 39:
          case 40:
            if (val[3] > sidx) {
              s["!ref"] = encode_range(refguess);
              sheets[n] = s;
              snames.push(n);
              s = {};
              if (o.dense) sdata = s["!data"] = [];
              refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
              sidx = val[3];
              n = "Sheet" + (sidx + 1);
            }
            if (sheetRows > 0 && val[0].r >= sheetRows) break;
            if (o.dense) {
              if (!sdata[val[0].r]) sdata[val[0].r] = [];
              sdata[val[0].r][val[0].c] = val[1];
            } else s[encode_cell(val[0])] = val[1];
            if (refguess.e.c < val[0].c) refguess.e.c = val[0].c;
            if (refguess.e.r < val[0].r) refguess.e.r = val[0].r;
            break;
          case 27:
            if (val[14e3]) realnames[val[14e3][0]] = val[14e3][1];
            break;
          case 1537:
            realnames[val[0]] = val[1];
            if (val[0] == sidx) n = val[1];
            break;
        }
      }, o);
    } else throw new Error("Unrecognized LOTUS BOF " + d[2]);
    s["!ref"] = encode_range(refguess);
    sheets[next_n || n] = s;
    snames.push(next_n || n);
    if (!realnames.length) return { SheetNames: snames, Sheets: sheets };
    var osheets = {}, rnames = [];
    for (var i = 0; i < realnames.length; ++i) if (sheets[snames[i]]) {
      rnames.push(realnames[i] || snames[i]);
      osheets[realnames[i]] = sheets[realnames[i]] || sheets[snames[i]];
    } else {
      rnames.push(realnames[i]);
      osheets[realnames[i]] = { "!ref": "A1" };
    }
    return { SheetNames: rnames, Sheets: osheets };
  }
  function sheet_to_wk1(ws, opts) {
    var o = opts || {};
    if (+o.codepage >= 0) set_cp(+o.codepage);
    if (o.type == "string") throw new Error("Cannot write WK1 to JS string");
    var ba = buf_array();
    if (!ws["!ref"]) throw new Error("Cannot export empty sheet to WK1");
    var range = safe_decode_range(ws["!ref"]);
    var dense = ws["!data"] != null;
    var cols = [];
    write_biff_rec(ba, 0, write_BOF_WK1(1030));
    write_biff_rec(ba, 6, write_RANGE(range));
    var max_R = Math.min(range.e.r, 8191);
    for (var C2 = range.s.c; C2 <= range.e.c; ++C2) cols[C2] = encode_col(C2);
    for (var R = range.s.r; R <= max_R; ++R) {
      var rr = encode_row(R);
      for (C2 = range.s.c; C2 <= range.e.c; ++C2) {
        var cell = dense ? (ws["!data"][R] || [])[C2] : ws[cols[C2] + rr];
        if (!cell || cell.t == "z") continue;
        switch (cell.t) {
          case "n":
            if ((cell.v | 0) == cell.v && cell.v >= -32768 && cell.v <= 32767) write_biff_rec(ba, 13, write_INTEGER(R, C2, cell));
            else write_biff_rec(ba, 14, write_NUMBER(R, C2, cell));
            break;
          case "d":
            var dc = datenum(cell.v);
            if ((dc | 0) == dc && dc >= -32768 && dc <= 32767) write_biff_rec(ba, 13, write_INTEGER(R, C2, { t: "n", v: dc, z: cell.z || table_fmt[14] }));
            else write_biff_rec(ba, 14, write_NUMBER(R, C2, { t: "n", v: dc, z: cell.z || table_fmt[14] }));
            break;
          default:
            var str = format_cell(cell);
            write_biff_rec(ba, 15, write_LABEL(R, C2, str.slice(0, 239)));
        }
      }
    }
    write_biff_rec(ba, 1);
    return ba.end();
  }
  function book_to_wk3(wb, opts) {
    var o = opts || {};
    if (+o.codepage >= 0) set_cp(+o.codepage);
    if (o.type == "string") throw new Error("Cannot write WK3 to JS string");
    var ba = buf_array();
    write_biff_rec(ba, 0, write_BOF_WK3(wb));
    for (var i = 0, cnt = 0; i < wb.SheetNames.length; ++i) if ((wb.Sheets[wb.SheetNames[i]] || {})["!ref"]) write_biff_rec(ba, 27, write_XFORMAT_SHEETNAME(wb.SheetNames[i], cnt++));
    var wsidx = 0;
    for (i = 0; i < wb.SheetNames.length; ++i) {
      var ws = wb.Sheets[wb.SheetNames[i]];
      if (!ws || !ws["!ref"]) continue;
      var range = safe_decode_range(ws["!ref"]);
      var dense = ws["!data"] != null;
      var cols = [];
      var max_R = Math.min(range.e.r, 8191);
      for (var R = range.s.r; R <= max_R; ++R) {
        var rr = encode_row(R);
        for (var C2 = range.s.c; C2 <= range.e.c; ++C2) {
          if (R === range.s.r) cols[C2] = encode_col(C2);
          var ref2 = cols[C2] + rr;
          var cell = dense ? (ws["!data"][R] || [])[C2] : ws[ref2];
          if (!cell || cell.t == "z") continue;
          if (cell.t == "n") {
            write_biff_rec(ba, 23, write_NUMBER_17(R, C2, wsidx, cell.v));
          } else {
            var str = format_cell(cell);
            write_biff_rec(ba, 22, write_LABEL_16(R, C2, wsidx, str.slice(0, 239)));
          }
        }
      }
      ++wsidx;
    }
    write_biff_rec(ba, 1);
    return ba.end();
  }
  function write_BOF_WK1(v2) {
    var out = new_buf(2);
    out.write_shift(2, v2);
    return out;
  }
  function write_BOF_WK3(wb) {
    var out = new_buf(26);
    out.write_shift(2, 4096);
    out.write_shift(2, 4);
    out.write_shift(4, 0);
    var rows = 0, cols = 0, wscnt = 0;
    for (var i = 0; i < wb.SheetNames.length; ++i) {
      var name = wb.SheetNames[i];
      var ws = wb.Sheets[name];
      if (!ws || !ws["!ref"]) continue;
      ++wscnt;
      var range = decode_range(ws["!ref"]);
      if (rows < range.e.r) rows = range.e.r;
      if (cols < range.e.c) cols = range.e.c;
    }
    if (rows > 8191) rows = 8191;
    out.write_shift(2, rows);
    out.write_shift(1, wscnt);
    out.write_shift(1, cols);
    out.write_shift(2, 0);
    out.write_shift(2, 0);
    out.write_shift(1, 1);
    out.write_shift(1, 2);
    out.write_shift(4, 0);
    out.write_shift(4, 0);
    return out;
  }
  function parse_RANGE(blob, length, opts) {
    var o = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    if (length == 8 && opts.qpro) {
      o.s.c = blob.read_shift(1);
      blob.l++;
      o.s.r = blob.read_shift(2);
      o.e.c = blob.read_shift(1);
      blob.l++;
      o.e.r = blob.read_shift(2);
      return o;
    }
    o.s.c = blob.read_shift(2);
    o.s.r = blob.read_shift(2);
    if (length == 12 && opts.qpro) blob.l += 2;
    o.e.c = blob.read_shift(2);
    o.e.r = blob.read_shift(2);
    if (length == 12 && opts.qpro) blob.l += 2;
    if (o.s.c == 65535) o.s.c = o.e.c = o.s.r = o.e.r = 0;
    return o;
  }
  function write_RANGE(range) {
    var out = new_buf(8);
    out.write_shift(2, range.s.c);
    out.write_shift(2, range.s.r);
    out.write_shift(2, range.e.c);
    out.write_shift(2, range.e.r);
    return out;
  }
  function parse_cell(blob, length, opts) {
    var o = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0, 0];
    if (opts.qpro && opts.vers != 20768) {
      o[0].c = blob.read_shift(1);
      o[3] = blob.read_shift(1);
      o[0].r = blob.read_shift(2);
      blob.l += 2;
    } else if (opts.works) {
      o[0].c = blob.read_shift(2);
      o[0].r = blob.read_shift(2);
      o[2] = blob.read_shift(2);
    } else {
      o[2] = blob.read_shift(1);
      o[0].c = blob.read_shift(2);
      o[0].r = blob.read_shift(2);
    }
    return o;
  }
  function get_wk1_fmt(cell) {
    if (cell.z && fmt_is_date(cell.z)) {
      return 240 | (LOTUS_DATE_FMTS.indexOf(cell.z) + 1 || 2);
    }
    return 255;
  }
  function parse_LABEL(blob, length, opts) {
    var tgt = blob.l + length;
    var o = parse_cell(blob, length, opts);
    o[1].t = "s";
    if ((opts.vers & 65534) == 20768) {
      blob.l++;
      var len = blob.read_shift(1);
      o[1].v = blob.read_shift(len, "utf8");
      return o;
    }
    if (opts.qpro) blob.l++;
    o[1].v = blob.read_shift(tgt - blob.l, "cstr");
    return o;
  }
  function write_LABEL(R, C2, s) {
    var o = new_buf(7 + s.length);
    o.write_shift(1, 255);
    o.write_shift(2, C2);
    o.write_shift(2, R);
    o.write_shift(1, 39);
    for (var i = 0; i < o.length; ++i) {
      var cc = s.charCodeAt(i);
      o.write_shift(1, cc >= 128 ? 95 : cc);
    }
    o.write_shift(1, 0);
    return o;
  }
  function parse_STRING(blob, length, opts) {
    var tgt = blob.l + length;
    var o = parse_cell(blob, length, opts);
    o[1].t = "s";
    if (opts.vers == 20768) {
      var len = blob.read_shift(1);
      o[1].v = blob.read_shift(len, "utf8");
      return o;
    }
    o[1].v = blob.read_shift(tgt - blob.l, "cstr");
    return o;
  }
  function parse_INTEGER(blob, length, opts) {
    var o = parse_cell(blob, length, opts);
    o[1].v = blob.read_shift(2, "i");
    return o;
  }
  function write_INTEGER(R, C2, cell) {
    var o = new_buf(7);
    o.write_shift(1, get_wk1_fmt(cell));
    o.write_shift(2, C2);
    o.write_shift(2, R);
    o.write_shift(2, cell.v, "i");
    return o;
  }
  function parse_NUMBER(blob, length, opts) {
    var o = parse_cell(blob, length, opts);
    o[1].v = blob.read_shift(8, "f");
    return o;
  }
  function write_NUMBER(R, C2, cell) {
    var o = new_buf(13);
    o.write_shift(1, get_wk1_fmt(cell));
    o.write_shift(2, C2);
    o.write_shift(2, R);
    o.write_shift(8, cell.v, "f");
    return o;
  }
  function parse_FORMULA(blob, length, opts) {
    var tgt = blob.l + length;
    var o = parse_cell(blob, length, opts);
    o[1].v = blob.read_shift(8, "f");
    if (opts.qpro) blob.l = tgt;
    else {
      var flen = blob.read_shift(2);
      wk1_fmla_to_csf(blob.slice(blob.l, blob.l + flen), o);
      blob.l += flen;
    }
    return o;
  }
  function wk1_parse_rc(B, V, col) {
    var rel = V & 32768;
    V &= ~32768;
    V = (rel ? B : 0) + (V >= 8192 ? V - 16384 : V);
    return (rel ? "" : "$") + (col ? encode_col(V) : encode_row(V));
  }
  var FuncTab = {
    31: ["NA", 0],
    // 0x20: ["ERR", 0],
    33: ["ABS", 1],
    34: ["TRUNC", 1],
    35: ["SQRT", 1],
    36: ["LOG", 1],
    37: ["LN", 1],
    38: ["PI", 0],
    39: ["SIN", 1],
    40: ["COS", 1],
    41: ["TAN", 1],
    42: ["ATAN2", 2],
    43: ["ATAN", 1],
    44: ["ASIN", 1],
    45: ["ACOS", 1],
    46: ["EXP", 1],
    47: ["MOD", 2],
    // 0x30
    49: ["ISNA", 1],
    50: ["ISERR", 1],
    51: ["FALSE", 0],
    52: ["TRUE", 0],
    53: ["RAND", 0],
    54: ["DATE", 3],
    // 0x37 NOW
    // 0x38 PMT
    // 0x39 PV
    // 0x3A FV
    // 0x3B IF
    // 0x3C DAY
    // 0x3D MONTH
    // 0x3E YEAR
    63: ["ROUND", 2],
    64: ["TIME", 3],
    // 0x41 HOUR
    // 0x42 MINUTE
    // 0x43 SECOND
    68: ["ISNUMBER", 1],
    69: ["ISTEXT", 1],
    70: ["LEN", 1],
    71: ["VALUE", 1],
    // 0x48: ["FIXED", ?? 1],
    73: ["MID", 3],
    74: ["CHAR", 1],
    // 0x4B
    // 0x4C FIND
    // 0x4D DATEVALUE
    // 0x4E TIMEVALUE
    // 0x4F CELL
    80: ["SUM", 69],
    81: ["AVERAGEA", 69],
    82: ["COUNTA", 69],
    83: ["MINA", 69],
    84: ["MAXA", 69],
    // 0x55 VLOOKUP
    // 0x56 NPV
    // 0x57 VAR
    // 0x58 STD
    // 0x59 IRR
    // 0x5A HLOOKUP
    // 0x5B DSUM
    // 0x5C DAVERAGE
    // 0x5D DCOUNTA
    // 0x5E DMIN
    // 0x5F DMAX
    // 0x60 DVARP
    // 0x61 DSTDEVP
    // 0x62 INDEX
    // 0x63 COLS
    // 0x64 ROWS
    // 0x65 REPEAT
    102: ["UPPER", 1],
    103: ["LOWER", 1],
    // 0x68 LEFT
    // 0x69 RIGHT
    // 0x6A REPLACE
    107: ["PROPER", 1],
    // 0x6C CELL
    109: ["TRIM", 1],
    // 0x6E CLEAN
    111: ["T", 1]
    // 0x70 V
  };
  var BinOpTab = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "",
    "+",
    "-",
    "*",
    "/",
    "^",
    "=",
    "<>",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "<=",
    ">=",
    "<",
    ">",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "&",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
    // eslint-disable-line no-mixed-spaces-and-tabs
  ];
  function wk1_fmla_to_csf(blob, o) {
    prep_blob(blob, 0);
    var out = [], argc = 0, R = "", C2 = "", argL = "", argR = "";
    while (blob.l < blob.length) {
      var cc = blob[blob.l++];
      switch (cc) {
        case 0:
          out.push(blob.read_shift(8, "f"));
          break;
        case 1:
          {
            C2 = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
            R = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
            out.push(C2 + R);
          }
          break;
        case 2:
          {
            var c2 = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
            var r = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
            C2 = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
            R = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
            out.push(c2 + r + ":" + C2 + R);
          }
          break;
        case 3:
          if (blob.l < blob.length) {
            console.error("WK1 premature formula end");
            return;
          }
          break;
        case 4:
          out.push("(" + out.pop() + ")");
          break;
        case 5:
          out.push(blob.read_shift(2));
          break;
        case 6:
          {
            var Z2 = "";
            while (cc = blob[blob.l++]) Z2 += String.fromCharCode(cc);
            out.push('"' + Z2.replace(/"/g, '""') + '"');
          }
          break;
        case 8:
          out.push("-" + out.pop());
          break;
        case 23:
          out.push("+" + out.pop());
          break;
        case 22:
          out.push("NOT(" + out.pop() + ")");
          break;
        case 20:
        case 21:
          {
            argR = out.pop();
            argL = out.pop();
            out.push(["AND", "OR"][cc - 20] + "(" + argL + "," + argR + ")");
          }
          break;
        default:
          if (cc < 32 && BinOpTab[cc]) {
            argR = out.pop();
            argL = out.pop();
            out.push(argL + BinOpTab[cc] + argR);
          } else if (FuncTab[cc]) {
            argc = FuncTab[cc][1];
            if (argc == 69) argc = blob[blob.l++];
            if (argc > out.length) {
              console.error("WK1 bad formula parse 0x" + cc.toString(16) + ":|" + out.join("|") + "|");
              return;
            }
            var args = out.slice(-argc);
            out.length -= argc;
            out.push(FuncTab[cc][0] + "(" + args.join(",") + ")");
          } else if (cc <= 7) return console.error("WK1 invalid opcode " + cc.toString(16));
          else if (cc <= 24) return console.error("WK1 unsupported op " + cc.toString(16));
          else if (cc <= 30) return console.error("WK1 invalid opcode " + cc.toString(16));
          else if (cc <= 115) return console.error("WK1 unsupported function opcode " + cc.toString(16));
          else return console.error("WK1 unrecognized opcode " + cc.toString(16));
      }
    }
    if (out.length == 1) o[1].f = "" + out[0];
    else console.error("WK1 bad formula parse |" + out.join("|") + "|");
  }
  function parse_cell_3(blob) {
    var o = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0];
    o[0].r = blob.read_shift(2);
    o[3] = blob[blob.l++];
    o[0].c = blob[blob.l++];
    return o;
  }
  function parse_LABEL_16(blob, length) {
    var o = parse_cell_3(blob);
    o[1].t = "s";
    o[1].v = blob.read_shift(length - 4, "cstr");
    return o;
  }
  function write_LABEL_16(R, C2, wsidx, s) {
    var o = new_buf(6 + s.length);
    o.write_shift(2, R);
    o.write_shift(1, wsidx);
    o.write_shift(1, C2);
    o.write_shift(1, 39);
    for (var i = 0; i < s.length; ++i) {
      var cc = s.charCodeAt(i);
      o.write_shift(1, cc >= 128 ? 95 : cc);
    }
    o.write_shift(1, 0);
    return o;
  }
  function parse_NUMBER_18(blob, length) {
    var o = parse_cell_3(blob);
    o[1].v = blob.read_shift(2);
    var v2 = o[1].v >> 1;
    if (o[1].v & 1) {
      switch (v2 & 7) {
        case 0:
          v2 = (v2 >> 3) * 5e3;
          break;
        case 1:
          v2 = (v2 >> 3) * 500;
          break;
        case 2:
          v2 = (v2 >> 3) / 20;
          break;
        case 3:
          v2 = (v2 >> 3) / 200;
          break;
        case 4:
          v2 = (v2 >> 3) / 2e3;
          break;
        case 5:
          v2 = (v2 >> 3) / 2e4;
          break;
        case 6:
          v2 = (v2 >> 3) / 16;
          break;
        case 7:
          v2 = (v2 >> 3) / 64;
          break;
      }
    }
    o[1].v = v2;
    return o;
  }
  function parse_NUMBER_17(blob, length) {
    var o = parse_cell_3(blob);
    var v1 = blob.read_shift(4);
    var v2 = blob.read_shift(4);
    var e = blob.read_shift(2);
    if (e == 65535) {
      if (v1 === 0 && v2 === 3221225472) {
        o[1].t = "e";
        o[1].v = 15;
      } else if (v1 === 0 && v2 === 3489660928) {
        o[1].t = "e";
        o[1].v = 42;
      } else o[1].v = 0;
      return o;
    }
    var s = e & 32768;
    e = (e & 32767) - 16446;
    o[1].v = (1 - s * 2) * (v2 * Math.pow(2, e + 32) + v1 * Math.pow(2, e));
    return o;
  }
  function write_NUMBER_17(R, C2, wsidx, v2) {
    var o = new_buf(14);
    o.write_shift(2, R);
    o.write_shift(1, wsidx);
    o.write_shift(1, C2);
    if (v2 == 0) {
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      o.write_shift(2, 65535);
      return o;
    }
    var s = 0, e = 0, v1 = 0, v22 = 0;
    if (v2 < 0) {
      s = 1;
      v2 = -v2;
    }
    e = Math.log2(v2) | 0;
    v2 /= Math.pow(2, e - 31);
    v22 = v2 >>> 0;
    if ((v22 & 2147483648) == 0) {
      v2 /= 2;
      ++e;
      v22 = v2 >>> 0;
    }
    v2 -= v22;
    v22 |= 2147483648;
    v22 >>>= 0;
    v2 *= Math.pow(2, 32);
    v1 = v2 >>> 0;
    o.write_shift(4, v1);
    o.write_shift(4, v22);
    e += 16383 + (s ? 32768 : 0);
    o.write_shift(2, e);
    return o;
  }
  function parse_FORMULA_19(blob, length) {
    var o = parse_NUMBER_17(blob);
    blob.l += length - 14;
    return o;
  }
  function parse_NUMBER_25(blob, length) {
    var o = parse_cell_3(blob);
    var v1 = blob.read_shift(4);
    o[1].v = v1 >> 6;
    return o;
  }
  function parse_NUMBER_27(blob, length) {
    var o = parse_cell_3(blob);
    var v1 = blob.read_shift(8, "f");
    o[1].v = v1;
    return o;
  }
  function parse_FORMULA_28(blob, length) {
    var o = parse_NUMBER_27(blob);
    blob.l += length - 12;
    return o;
  }
  function parse_SHEETNAMECS(blob, length) {
    return blob[blob.l + length - 1] == 0 ? blob.read_shift(length, "cstr") : "";
  }
  function parse_SHEETNAMELP(blob, length) {
    var len = blob[blob.l++];
    if (len > length - 1) len = length - 1;
    var o = "";
    while (o.length < len) o += String.fromCharCode(blob[blob.l++]);
    return o;
  }
  function parse_SHEETINFOQP(blob, length, opts) {
    if (!opts.qpro || length < 21) return;
    var id = blob.read_shift(1);
    blob.l += 17;
    blob.l += 1;
    blob.l += 2;
    var nm = blob.read_shift(length - 21, "cstr");
    return [id, nm];
  }
  function parse_XFORMAT(blob, length) {
    var o = {}, tgt = blob.l + length;
    while (blob.l < tgt) {
      var dt = blob.read_shift(2);
      if (dt == 14e3) {
        o[dt] = [0, ""];
        o[dt][0] = blob.read_shift(2);
        while (blob[blob.l]) {
          o[dt][1] += String.fromCharCode(blob[blob.l]);
          blob.l++;
        }
        blob.l++;
      }
    }
    return o;
  }
  function write_XFORMAT_SHEETNAME(name, wsidx) {
    var out = new_buf(5 + name.length);
    out.write_shift(2, 14e3);
    out.write_shift(2, wsidx);
    for (var i = 0; i < name.length; ++i) {
      var cc = name.charCodeAt(i);
      out[out.l++] = cc > 127 ? 95 : cc;
    }
    out[out.l++] = 0;
    return out;
  }
  var WK1Enum = {
    0: { n: "BOF", f: parseuint16 },
    1: { n: "EOF" },
    2: { n: "CALCMODE" },
    3: { n: "CALCORDER" },
    4: { n: "SPLIT" },
    5: { n: "SYNC" },
    6: { n: "RANGE", f: parse_RANGE },
    7: { n: "WINDOW1" },
    8: { n: "COLW1" },
    9: { n: "WINTWO" },
    10: { n: "COLW2" },
    11: { n: "NAME" },
    12: { n: "BLANK" },
    13: { n: "INTEGER", f: parse_INTEGER },
    14: { n: "NUMBER", f: parse_NUMBER },
    15: { n: "LABEL", f: parse_LABEL },
    16: { n: "FORMULA", f: parse_FORMULA },
    24: { n: "TABLE" },
    25: { n: "ORANGE" },
    26: { n: "PRANGE" },
    27: { n: "SRANGE" },
    28: { n: "FRANGE" },
    29: { n: "KRANGE1" },
    32: { n: "HRANGE" },
    35: { n: "KRANGE2" },
    36: { n: "PROTEC" },
    37: { n: "FOOTER" },
    38: { n: "HEADER" },
    39: { n: "SETUP" },
    40: { n: "MARGINS" },
    41: { n: "LABELFMT" },
    42: { n: "TITLES" },
    43: { n: "SHEETJS" },
    45: { n: "GRAPH" },
    46: { n: "NGRAPH" },
    47: { n: "CALCCOUNT" },
    48: { n: "UNFORMATTED" },
    49: { n: "CURSORW12" },
    50: { n: "WINDOW" },
    51: { n: "STRING", f: parse_STRING },
    55: { n: "PASSWORD" },
    56: { n: "LOCKED" },
    60: { n: "QUERY" },
    61: { n: "QUERYNAME" },
    62: { n: "PRINT" },
    63: { n: "PRINTNAME" },
    64: { n: "GRAPH2" },
    65: { n: "GRAPHNAME" },
    66: { n: "ZOOM" },
    67: { n: "SYMSPLIT" },
    68: { n: "NSROWS" },
    69: { n: "NSCOLS" },
    70: { n: "RULER" },
    71: { n: "NNAME" },
    72: { n: "ACOMM" },
    73: { n: "AMACRO" },
    74: { n: "PARSE" },
    // 0x0064
    102: { n: "PRANGES??" },
    103: { n: "RRANGES??" },
    104: { n: "FNAME??" },
    105: { n: "MRANGES??" },
    // 0x0096
    // 0x0099
    // 0x009A
    // 0x009B
    // 0x009C
    // 0x00C0
    // 0x00C7
    // 0x00C9
    204: { n: "SHEETNAMECS", f: parse_SHEETNAMECS },
    // 0x00CD
    222: { n: "SHEETNAMELP", f: parse_SHEETNAMELP },
    255: { n: "BOF", f: parseuint16 },
    21506: { n: "WKSNF", f: parseuint16 },
    65535: { n: "" }
  };
  var WK3Enum = {
    0: { n: "BOF" },
    1: { n: "EOF" },
    2: { n: "PASSWORD" },
    3: { n: "CALCSET" },
    4: { n: "WINDOWSET" },
    5: { n: "SHEETCELLPTR" },
    6: { n: "SHEETLAYOUT" },
    7: { n: "COLUMNWIDTH" },
    8: { n: "HIDDENCOLUMN" },
    9: { n: "USERRANGE" },
    10: { n: "SYSTEMRANGE" },
    11: { n: "ZEROFORCE" },
    12: { n: "SORTKEYDIR" },
    13: { n: "FILESEAL" },
    14: { n: "DATAFILLNUMS" },
    15: { n: "PRINTMAIN" },
    16: { n: "PRINTSTRING" },
    17: { n: "GRAPHMAIN" },
    18: { n: "GRAPHSTRING" },
    19: { n: "??" },
    20: { n: "ERRCELL" },
    21: { n: "NACELL" },
    22: { n: "LABEL16", f: parse_LABEL_16 },
    23: { n: "NUMBER17", f: parse_NUMBER_17 },
    24: { n: "NUMBER18", f: parse_NUMBER_18 },
    25: { n: "FORMULA19", f: parse_FORMULA_19 },
    26: { n: "FORMULA1A" },
    27: { n: "XFORMAT", f: parse_XFORMAT },
    28: { n: "DTLABELMISC" },
    29: { n: "DTLABELCELL" },
    30: { n: "GRAPHWINDOW" },
    31: { n: "CPA" },
    32: { n: "LPLAUTO" },
    33: { n: "QUERY" },
    34: { n: "HIDDENSHEET" },
    35: { n: "??" },
    37: { n: "NUMBER25", f: parse_NUMBER_25 },
    38: { n: "??" },
    39: { n: "NUMBER27", f: parse_NUMBER_27 },
    40: { n: "FORMULA28", f: parse_FORMULA_28 },
    142: { n: "??" },
    147: { n: "??" },
    150: { n: "??" },
    151: { n: "??" },
    152: { n: "??" },
    153: { n: "??" },
    154: { n: "??" },
    155: { n: "??" },
    156: { n: "??" },
    163: { n: "??" },
    174: { n: "??" },
    175: { n: "??" },
    176: { n: "??" },
    177: { n: "??" },
    184: { n: "??" },
    185: { n: "??" },
    186: { n: "??" },
    187: { n: "??" },
    188: { n: "??" },
    195: { n: "??" },
    201: { n: "??" },
    204: { n: "SHEETNAMECS", f: parse_SHEETNAMECS },
    205: { n: "??" },
    206: { n: "??" },
    207: { n: "??" },
    208: { n: "??" },
    256: { n: "??" },
    259: { n: "??" },
    260: { n: "??" },
    261: { n: "??" },
    262: { n: "??" },
    263: { n: "??" },
    265: { n: "??" },
    266: { n: "??" },
    267: { n: "??" },
    268: { n: "??" },
    270: { n: "??" },
    271: { n: "??" },
    384: { n: "??" },
    389: { n: "??" },
    390: { n: "??" },
    393: { n: "??" },
    396: { n: "??" },
    512: { n: "??" },
    514: { n: "??" },
    513: { n: "??" },
    516: { n: "??" },
    517: { n: "??" },
    640: { n: "??" },
    641: { n: "??" },
    642: { n: "??" },
    643: { n: "??" },
    644: { n: "??" },
    645: { n: "??" },
    646: { n: "??" },
    647: { n: "??" },
    648: { n: "??" },
    658: { n: "??" },
    659: { n: "??" },
    660: { n: "??" },
    661: { n: "??" },
    662: { n: "??" },
    665: { n: "??" },
    666: { n: "??" },
    768: { n: "??" },
    772: { n: "??" },
    1537: { n: "SHEETINFOQP", f: parse_SHEETINFOQP },
    1600: { n: "??" },
    1602: { n: "??" },
    1793: { n: "??" },
    1794: { n: "??" },
    1795: { n: "??" },
    1796: { n: "??" },
    1920: { n: "??" },
    2048: { n: "??" },
    2049: { n: "??" },
    2052: { n: "??" },
    2688: { n: "??" },
    10998: { n: "??" },
    12849: { n: "??" },
    28233: { n: "??" },
    28484: { n: "??" },
    65535: { n: "" }
  };
  var QPWNFTable = {
    5: "dd-mmm-yy",
    6: "dd-mmm",
    7: "mmm-yy",
    8: "mm/dd/yy",
    // Long Date Intl
    10: "hh:mm:ss AM/PM",
    11: "hh:mm AM/PM",
    14: "dd-mmm-yyyy",
    15: "mmm-yyyy",
    /* It is suspected that the the low nybble specifies decimal places */
    34: "0.00",
    50: "0.00;[Red]0.00",
    66: "0.00;(0.00)",
    82: "0.00;[Red](0.00)",
    162: '"$"#,##0.00;\\("$"#,##0.00\\)',
    288: "0%",
    304: "0E+00",
    320: "# ?/?"
  };
  function parse_qpw_str(p) {
    var cch = p.read_shift(2);
    var flags = p.read_shift(1);
    if (flags != 0) throw "unsupported QPW string type " + flags.toString(16);
    return p.read_shift(cch, "sbcs-cont");
  }
  function qpw_to_workbook_buf(d, opts) {
    prep_blob(d, 0);
    var o = opts || {};
    var s = {};
    if (o.dense) s["!data"] = [];
    var SST = [], sname = "";
    var range = { s: { r: -1, c: -1 }, e: { r: -1, c: -1 } };
    var cnt = 0, type = 0, C2 = 0, R = 0;
    var wb = { SheetNames: [], Sheets: {} };
    var FMTS = [];
    outer: while (d.l < d.length) {
      var RT = d.read_shift(2), length = d.read_shift(2);
      var p = d.slice(d.l, d.l + length);
      prep_blob(p, 0);
      switch (RT) {
        case 1:
          if (p.read_shift(4) != 962023505) throw "Bad QPW9 BOF!";
          break;
        case 2:
          break outer;
        case 8:
          break;
        case 10:
          {
            var fcnt = p.read_shift(4);
            var step = (p.length - p.l) / fcnt | 0;
            for (var ifmt = 0; ifmt < fcnt; ++ifmt) {
              var end = p.l + step;
              var fmt = {};
              p.l += 2;
              fmt.numFmtId = p.read_shift(2);
              if (QPWNFTable[fmt.numFmtId]) fmt.z = QPWNFTable[fmt.numFmtId];
              p.l = end;
              FMTS.push(fmt);
            }
          }
          break;
        case 1025:
          break;
        case 1026:
          break;
        case 1031:
          {
            p.l += 12;
            while (p.l < p.length) {
              cnt = p.read_shift(2);
              type = p.read_shift(1);
              SST.push(p.read_shift(cnt, "cstr"));
            }
          }
          break;
        case 1032:
          break;
        case 1537:
          {
            var sidx = p.read_shift(2);
            s = {};
            if (o.dense) s["!data"] = [];
            range.s.c = p.read_shift(2);
            range.e.c = p.read_shift(2);
            range.s.r = p.read_shift(4);
            range.e.r = p.read_shift(4);
            p.l += 4;
            if (p.l + 2 < p.length) {
              cnt = p.read_shift(2);
              type = p.read_shift(1);
              sname = cnt == 0 ? "" : p.read_shift(cnt, "cstr");
            }
            if (!sname) sname = encode_col(sidx);
          }
          break;
        case 1538:
          {
            if (range.s.c > 255 || range.s.r > 999999) break;
            if (range.e.c < range.s.c) range.e.c = range.s.c;
            if (range.e.r < range.s.r) range.e.r = range.s.r;
            s["!ref"] = encode_range(range);
            book_append_sheet(wb, s, sname);
          }
          break;
        case 2561:
          {
            C2 = p.read_shift(2);
            if (range.e.c < C2) range.e.c = C2;
            if (range.s.c > C2) range.s.c = C2;
            R = p.read_shift(4);
            if (range.s.r > R) range.s.r = R;
            R = p.read_shift(4);
            if (range.e.r < R) range.e.r = R;
          }
          break;
        case 3073:
          {
            R = p.read_shift(4), cnt = p.read_shift(4);
            if (range.s.r > R) range.s.r = R;
            if (range.e.r < R + cnt - 1) range.e.r = R + cnt - 1;
            var CC = encode_col(C2);
            while (p.l < p.length) {
              var cell = { t: "z" };
              var flags = p.read_shift(1), fmtidx = -1;
              if (flags & 128) fmtidx = p.read_shift(2);
              var mul = flags & 64 ? p.read_shift(2) - 1 : 0;
              switch (flags & 31) {
                case 0:
                  break;
                case 1:
                  break;
                case 2:
                  cell = { t: "n", v: p.read_shift(2) };
                  break;
                case 3:
                  cell = { t: "n", v: p.read_shift(2, "i") };
                  break;
                case 4:
                  cell = { t: "n", v: parse_RkNumber(p) };
                  break;
                case 5:
                  cell = { t: "n", v: p.read_shift(8, "f") };
                  break;
                case 7:
                  cell = { t: "s", v: SST[type = p.read_shift(4) - 1] };
                  break;
                case 8:
                  cell = { t: "n", v: p.read_shift(8, "f") };
                  p.l += 2;
                  p.l += 4;
                  if (isNaN(cell.v)) cell = { t: "e", v: 15 };
                  break;
                default:
                  throw "Unrecognized QPW cell type " + (flags & 31);
              }
              if (fmtidx != -1 && (FMTS[fmtidx - 1] || {}).z) cell.z = FMTS[fmtidx - 1].z;
              var delta = 0;
              if (flags & 32) switch (flags & 31) {
                case 2:
                  delta = p.read_shift(2);
                  break;
                case 3:
                  delta = p.read_shift(2, "i");
                  break;
                case 7:
                  delta = p.read_shift(2);
                  break;
                default:
                  throw "Unsupported delta for QPW cell type " + (flags & 31);
              }
              if (!(!o.sheetStubs && cell.t == "z")) {
                var newcell = dup(cell);
                if (cell.t == "n" && cell.z && fmt_is_date(cell.z) && o.cellDates) {
                  newcell.v = numdate(cell.v);
                  newcell.t = typeof newcell.v == "number" ? "n" : "d";
                }
                if (s["!data"] != null) {
                  if (!s["!data"][R]) s["!data"][R] = [];
                  s["!data"][R][C2] = newcell;
                } else s[CC + encode_row(R)] = newcell;
              }
              ++R;
              --cnt;
              while (mul-- > 0 && cnt >= 0) {
                if (flags & 32) switch (flags & 31) {
                  case 2:
                    cell = { t: "n", v: cell.v + delta & 65535 };
                    break;
                  case 3:
                    cell = { t: "n", v: cell.v + delta & 65535 };
                    if (cell.v > 32767) cell.v -= 65536;
                    break;
                  case 7:
                    cell = { t: "s", v: SST[type = type + delta >>> 0] };
                    break;
                  default:
                    throw "Cannot apply delta for QPW cell type " + (flags & 31);
                }
                else switch (flags & 31) {
                  case 1:
                    cell = { t: "z" };
                    break;
                  case 2:
                    cell = { t: "n", v: p.read_shift(2) };
                    break;
                  case 7:
                    cell = { t: "s", v: SST[type = p.read_shift(4) - 1] };
                    break;
                  default:
                    throw "Cannot apply repeat for QPW cell type " + (flags & 31);
                }
                if (!(!o.sheetStubs && cell.t == "z")) {
                  if (s["!data"] != null) {
                    if (!s["!data"][R]) s["!data"][R] = [];
                    s["!data"][R][C2] = cell;
                  } else s[CC + encode_row(R)] = cell;
                }
                ++R;
                --cnt;
              }
            }
          }
          break;
        case 3074:
          {
            C2 = p.read_shift(2);
            R = p.read_shift(4);
            var str = parse_qpw_str(p);
            if (s["!data"] != null) {
              if (!s["!data"][R]) s["!data"][R] = [];
              s["!data"][R][C2] = { t: "s", v: str };
            } else s[encode_col(C2) + encode_row(R)] = { t: "s", v: str };
          }
          break;
      }
      d.l += length;
    }
    return wb;
  }
  return {
    sheet_to_wk1,
    book_to_wk3,
    to_workbook: lotus_to_workbook
  };
}();
function parse_rpr(rpr) {
  var font = {}, m = rpr.match(tagregex), i = 0;
  var pass = false;
  if (m) for (; i != m.length; ++i) {
    var y = parsexmltag(m[i]);
    switch (y[0].replace(/<\w*:/g, "<")) {
      case "<condense":
        break;
      case "<extend":
        break;
      case "<shadow":
        if (!y.val) break;
      case "<shadow>":
      case "<shadow/>":
        font.shadow = 1;
        break;
      case "</shadow>":
        break;
      case "<charset":
        if (y.val == "1") break;
        font.cp = CS2CP[parseInt(y.val, 10)];
        break;
      case "<outline":
        if (!y.val) break;
      case "<outline>":
      case "<outline/>":
        font.outline = 1;
        break;
      case "</outline>":
        break;
      case "<rFont":
        font.name = y.val;
        break;
      case "<sz":
        font.sz = y.val;
        break;
      case "<strike":
        if (!y.val) break;
      case "<strike>":
      case "<strike/>":
        font.strike = 1;
        break;
      case "</strike>":
        break;
      case "<u":
        if (!y.val) break;
        switch (y.val) {
          case "double":
            font.uval = "double";
            break;
          case "singleAccounting":
            font.uval = "single-accounting";
            break;
          case "doubleAccounting":
            font.uval = "double-accounting";
            break;
        }
      case "<u>":
      case "<u/>":
        font.u = 1;
        break;
      case "</u>":
        break;
      case "<b":
        if (y.val == "0") break;
      case "<b>":
      case "<b/>":
        font.b = 1;
        break;
      case "</b>":
        break;
      case "<i":
        if (y.val == "0") break;
      case "<i>":
      case "<i/>":
        font.i = 1;
        break;
      case "</i>":
        break;
      case "<color":
        if (y.rgb) font.color = y.rgb.slice(2, 8);
        break;
      case "<color>":
      case "<color/>":
      case "</color>":
        break;
      case "<family":
        font.family = y.val;
        break;
      case "<family>":
      case "<family/>":
      case "</family>":
        break;
      case "<vertAlign":
        font.valign = y.val;
        break;
      case "<vertAlign>":
      case "<vertAlign/>":
      case "</vertAlign>":
        break;
      case "<scheme":
        break;
      case "<scheme>":
      case "<scheme/>":
      case "</scheme>":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (y[0].charCodeAt(1) !== 47 && !pass) throw new Error("Unrecognized rich format " + y[0]);
    }
  }
  return font;
}
var parse_rs = /* @__PURE__ */ function() {
  function parse_r(r) {
    var t = str_match_xml_ns(r, "t");
    if (!t) return { t: "s", v: "" };
    var o = { t: "s", v: unescapexml(t[1]) };
    var rpr = str_match_xml_ns(r, "rPr");
    if (rpr) o.s = parse_rpr(rpr[1]);
    return o;
  }
  var rregex = /<(?:\w+:)?r>/g, rend = /<\/(?:\w+:)?r>/;
  return function parse_rs2(rs) {
    return rs.replace(rregex, "").split(rend).map(parse_r).filter(function(r) {
      return r.v;
    });
  };
}();
var rs_to_html = /* @__PURE__ */ function parse_rs_factory() {
  var nlregex = /(\r\n|\n)/g;
  function parse_rpr2(font, intro, outro) {
    var style = [];
    if (font.u) style.push("text-decoration: underline;");
    if (font.uval) style.push("text-underline-style:" + font.uval + ";");
    if (font.sz) style.push("font-size:" + font.sz + "pt;");
    if (font.outline) style.push("text-effect: outline;");
    if (font.shadow) style.push("text-shadow: auto;");
    intro.push('<span style="' + style.join("") + '">');
    if (font.b) {
      intro.push("<b>");
      outro.push("</b>");
    }
    if (font.i) {
      intro.push("<i>");
      outro.push("</i>");
    }
    if (font.strike) {
      intro.push("<s>");
      outro.push("</s>");
    }
    var align = font.valign || "";
    if (align == "superscript" || align == "super") align = "sup";
    else if (align == "subscript") align = "sub";
    if (align != "") {
      intro.push("<" + align + ">");
      outro.push("</" + align + ">");
    }
    outro.push("</span>");
    return font;
  }
  function r_to_html(r) {
    var terms = [[], r.v, []];
    if (!r.v) return "";
    if (r.s) parse_rpr2(r.s, terms[0], terms[2]);
    return terms[0].join("") + terms[1].replace(nlregex, "<br/>") + terms[2].join("");
  }
  return function parse_rs2(rs) {
    return rs.map(r_to_html).join("");
  };
}();
var sitregex = /<(?:\w+:)?t\b[^<>]*>([^<]*)<\/(?:\w+:)?t>/g, sirregex = /<(?:\w+:)?r\b[^<>]*>/;
function parse_si(x, opts) {
  var html = opts ? opts.cellHTML : true;
  var z = {};
  if (!x) return { t: "" };
  if (x.match(/^\s*<(?:\w+:)?t[^>]*>/)) {
    z.t = unescapexml(utf8read(x.slice(x.indexOf(">") + 1).split(/<\/(?:\w+:)?t>/)[0] || ""), true);
    z.r = utf8read(x);
    if (html) z.h = escapehtml(z.t);
  } else if (
    /*y = */
    x.match(sirregex)
  ) {
    z.r = utf8read(x);
    z.t = unescapexml(utf8read((str_remove_xml_ns_g(x, "rPh").match(sitregex) || []).join("").replace(tagregex, "")), true);
    if (html) z.h = rs_to_html(parse_rs(z.r));
  }
  return z;
}
var sstr1 = /<(?:\w+:)?(?:si|sstItem)>/g;
var sstr2 = /<\/(?:\w+:)?(?:si|sstItem)>/;
function parse_sst_xml(data, opts) {
  var s = [], ss = "";
  if (!data) return s;
  var sst = str_match_xml_ns(data, "sst");
  if (sst) {
    ss = sst[1].replace(sstr1, "").split(sstr2);
    for (var i = 0; i != ss.length; ++i) {
      var o = parse_si(ss[i].trim(), opts);
      if (o != null) s[s.length] = o;
    }
    sst = parsexmltag(sst[0].slice(0, sst[0].indexOf(">")));
    s.Count = sst.count;
    s.Unique = sst.uniqueCount;
  }
  return s;
}
function parse_BrtBeginSst(data) {
  return [data.read_shift(4), data.read_shift(4)];
}
function parse_sst_bin(data, opts) {
  var s = [];
  var pass = false;
  recordhopper(data, function hopper_sst(val, R, RT) {
    switch (RT) {
      case 159:
        s.Count = val[0];
        s.Unique = val[1];
        break;
      case 19:
        s.push(val);
        break;
      case 160:
        return true;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      default:
        if (R.T) ;
        if (!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return s;
}
function _JS2ANSI(str) {
  var o = [], oo = str.split("");
  for (var i = 0; i < oo.length; ++i) o[i] = oo[i].charCodeAt(0);
  return o;
}
function parse_CRYPTOVersion(blob, length) {
  var o = {};
  o.Major = blob.read_shift(2);
  o.Minor = blob.read_shift(2);
  if (length >= 4) blob.l += length - 4;
  return o;
}
function parse_DataSpaceVersionInfo(blob) {
  var o = {};
  o.id = blob.read_shift(0, "lpp4");
  o.R = parse_CRYPTOVersion(blob, 4);
  o.U = parse_CRYPTOVersion(blob, 4);
  o.W = parse_CRYPTOVersion(blob, 4);
  return o;
}
function parse_DataSpaceMapEntry(blob) {
  var len = blob.read_shift(4);
  var end = blob.l + len - 4;
  var o = {};
  var cnt = blob.read_shift(4);
  var comps = [];
  while (cnt-- > 0) comps.push({ t: blob.read_shift(4), v: blob.read_shift(0, "lpp4") });
  o.name = blob.read_shift(0, "lpp4");
  o.comps = comps;
  if (blob.l != end) throw new Error("Bad DataSpaceMapEntry: " + blob.l + " != " + end);
  return o;
}
function parse_DataSpaceMap(blob) {
  var o = [];
  blob.l += 4;
  var cnt = blob.read_shift(4);
  while (cnt-- > 0) o.push(parse_DataSpaceMapEntry(blob));
  return o;
}
function parse_DataSpaceDefinition(blob) {
  var o = [];
  blob.l += 4;
  var cnt = blob.read_shift(4);
  while (cnt-- > 0) o.push(blob.read_shift(0, "lpp4"));
  return o;
}
function parse_TransformInfoHeader(blob) {
  var o = {};
  blob.read_shift(4);
  blob.l += 4;
  o.id = blob.read_shift(0, "lpp4");
  o.name = blob.read_shift(0, "lpp4");
  o.R = parse_CRYPTOVersion(blob, 4);
  o.U = parse_CRYPTOVersion(blob, 4);
  o.W = parse_CRYPTOVersion(blob, 4);
  return o;
}
function parse_Primary(blob) {
  var hdr = parse_TransformInfoHeader(blob);
  hdr.ename = blob.read_shift(0, "8lpp4");
  hdr.blksz = blob.read_shift(4);
  hdr.cmode = blob.read_shift(4);
  if (blob.read_shift(4) != 4) throw new Error("Bad !Primary record");
  return hdr;
}
function parse_EncryptionHeader(blob, length) {
  var tgt = blob.l + length;
  var o = {};
  o.Flags = blob.read_shift(4) & 63;
  blob.l += 4;
  o.AlgID = blob.read_shift(4);
  var valid = false;
  switch (o.AlgID) {
    case 26126:
    case 26127:
    case 26128:
      valid = o.Flags == 36;
      break;
    case 26625:
      valid = o.Flags == 4;
      break;
    case 0:
      valid = o.Flags == 16 || o.Flags == 4 || o.Flags == 36;
      break;
    default:
      throw "Unrecognized encryption algorithm: " + o.AlgID;
  }
  if (!valid) throw new Error("Encryption Flags/AlgID mismatch");
  o.AlgIDHash = blob.read_shift(4);
  o.KeySize = blob.read_shift(4);
  o.ProviderType = blob.read_shift(4);
  blob.l += 8;
  o.CSPName = blob.read_shift(tgt - blob.l >> 1, "utf16le");
  blob.l = tgt;
  return o;
}
function parse_EncryptionVerifier(blob, length) {
  var o = {}, tgt = blob.l + length;
  blob.l += 4;
  o.Salt = blob.slice(blob.l, blob.l + 16);
  blob.l += 16;
  o.Verifier = blob.slice(blob.l, blob.l + 16);
  blob.l += 16;
  blob.read_shift(4);
  o.VerifierHash = blob.slice(blob.l, tgt);
  blob.l = tgt;
  return o;
}
function parse_EncryptionInfo(blob) {
  var vers = parse_CRYPTOVersion(blob);
  switch (vers.Minor) {
    case 2:
      return [vers.Minor, parse_EncInfoStd(blob)];
    case 3:
      return [vers.Minor, parse_EncInfoExt()];
    case 4:
      return [vers.Minor, parse_EncInfoAgl(blob)];
  }
  throw new Error("ECMA-376 Encrypted file unrecognized Version: " + vers.Minor);
}
function parse_EncInfoStd(blob) {
  var flags = blob.read_shift(4);
  if ((flags & 63) != 36) throw new Error("EncryptionInfo mismatch");
  var sz = blob.read_shift(4);
  var hdr = parse_EncryptionHeader(blob, sz);
  var verifier = parse_EncryptionVerifier(blob, blob.length - blob.l);
  return { t: "Std", h: hdr, v: verifier };
}
function parse_EncInfoExt() {
  throw new Error("File is password-protected: ECMA-376 Extensible");
}
function parse_EncInfoAgl(blob) {
  var KeyData = ["saltSize", "blockSize", "keyBits", "hashSize", "cipherAlgorithm", "cipherChaining", "hashAlgorithm", "saltValue"];
  blob.l += 4;
  var xml = blob.read_shift(blob.length - blob.l, "utf8");
  var o = {};
  xml.replace(tagregex, function xml_agile(x) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<?xml":
        break;
      case "<encryption":
      case "</encryption>":
        break;
      case "<keyData":
        KeyData.forEach(function(k2) {
          o[k2] = y[k2];
        });
        break;
      case "<dataIntegrity":
        o.encryptedHmacKey = y.encryptedHmacKey;
        o.encryptedHmacValue = y.encryptedHmacValue;
        break;
      case "<keyEncryptors>":
      case "<keyEncryptors":
        o.encs = [];
        break;
      case "</keyEncryptors>":
        break;
      case "<keyEncryptor":
        o.uri = y.uri;
        break;
      case "</keyEncryptor>":
        break;
      case "<encryptedKey":
        o.encs.push(y);
        break;
      default:
        throw y[0];
    }
  });
  return o;
}
function parse_RC4CryptoHeader(blob, length) {
  var o = {};
  var vers = o.EncryptionVersionInfo = parse_CRYPTOVersion(blob, 4);
  length -= 4;
  if (vers.Minor != 2) throw new Error("unrecognized minor version code: " + vers.Minor);
  if (vers.Major > 4 || vers.Major < 2) throw new Error("unrecognized major version code: " + vers.Major);
  o.Flags = blob.read_shift(4);
  length -= 4;
  var sz = blob.read_shift(4);
  length -= 4;
  o.EncryptionHeader = parse_EncryptionHeader(blob, sz);
  length -= sz;
  o.EncryptionVerifier = parse_EncryptionVerifier(blob, length);
  return o;
}
function parse_RC4Header(blob) {
  var o = {};
  var vers = o.EncryptionVersionInfo = parse_CRYPTOVersion(blob, 4);
  if (vers.Major != 1 || vers.Minor != 1) throw "unrecognized version code " + vers.Major + " : " + vers.Minor;
  o.Salt = blob.read_shift(16);
  o.EncryptedVerifier = blob.read_shift(16);
  o.EncryptedVerifierHash = blob.read_shift(16);
  return o;
}
function crypto_CreatePasswordVerifier_Method1(Password) {
  var Verifier = 0, PasswordArray;
  var PasswordDecoded = _JS2ANSI(Password);
  var len = PasswordDecoded.length + 1, i, PasswordByte;
  var Intermediate1, Intermediate2, Intermediate3;
  PasswordArray = new_raw_buf(len);
  PasswordArray[0] = PasswordDecoded.length;
  for (i = 1; i != len; ++i) PasswordArray[i] = PasswordDecoded[i - 1];
  for (i = len - 1; i >= 0; --i) {
    PasswordByte = PasswordArray[i];
    Intermediate1 = (Verifier & 16384) === 0 ? 0 : 1;
    Intermediate2 = Verifier << 1 & 32767;
    Intermediate3 = Intermediate1 | Intermediate2;
    Verifier = Intermediate3 ^ PasswordByte;
  }
  return Verifier ^ 52811;
}
var crypto_CreateXorArray_Method1 = /* @__PURE__ */ function() {
  var PadArray = [187, 255, 255, 186, 255, 255, 185, 128, 0, 190, 15, 0, 191, 15, 0];
  var InitialCode = [57840, 7439, 52380, 33984, 4364, 3600, 61902, 12606, 6258, 57657, 54287, 34041, 10252, 43370, 20163];
  var XorMatrix = [44796, 19929, 39858, 10053, 20106, 40212, 10761, 31585, 63170, 64933, 60267, 50935, 40399, 11199, 17763, 35526, 1453, 2906, 5812, 11624, 23248, 885, 1770, 3540, 7080, 14160, 28320, 56640, 55369, 41139, 20807, 41614, 21821, 43642, 17621, 28485, 56970, 44341, 19019, 38038, 14605, 29210, 60195, 50791, 40175, 10751, 21502, 43004, 24537, 18387, 36774, 3949, 7898, 15796, 31592, 63184, 47201, 24803, 49606, 37805, 14203, 28406, 56812, 17824, 35648, 1697, 3394, 6788, 13576, 27152, 43601, 17539, 35078, 557, 1114, 2228, 4456, 30388, 60776, 51953, 34243, 7079, 14158, 28316, 14128, 28256, 56512, 43425, 17251, 34502, 7597, 13105, 26210, 52420, 35241, 883, 1766, 3532, 4129, 8258, 16516, 33032, 4657, 9314, 18628];
  var Ror = function(Byte) {
    return (Byte / 2 | Byte * 128) & 255;
  };
  var XorRor = function(byte1, byte2) {
    return Ror(byte1 ^ byte2);
  };
  var CreateXorKey_Method1 = function(Password) {
    var XorKey = InitialCode[Password.length - 1];
    var CurrentElement = 104;
    for (var i = Password.length - 1; i >= 0; --i) {
      var Char = Password[i];
      for (var j = 0; j != 7; ++j) {
        if (Char & 64) XorKey ^= XorMatrix[CurrentElement];
        Char *= 2;
        --CurrentElement;
      }
    }
    return XorKey;
  };
  return function(password) {
    var Password = _JS2ANSI(password);
    var XorKey = CreateXorKey_Method1(Password);
    var Index = Password.length;
    var ObfuscationArray = new_raw_buf(16);
    for (var i = 0; i != 16; ++i) ObfuscationArray[i] = 0;
    var Temp, PasswordLastChar, PadIndex;
    if ((Index & 1) === 1) {
      Temp = XorKey >> 8;
      ObfuscationArray[Index] = XorRor(PadArray[0], Temp);
      --Index;
      Temp = XorKey & 255;
      PasswordLastChar = Password[Password.length - 1];
      ObfuscationArray[Index] = XorRor(PasswordLastChar, Temp);
    }
    while (Index > 0) {
      --Index;
      Temp = XorKey >> 8;
      ObfuscationArray[Index] = XorRor(Password[Index], Temp);
      --Index;
      Temp = XorKey & 255;
      ObfuscationArray[Index] = XorRor(Password[Index], Temp);
    }
    Index = 15;
    PadIndex = 15 - Password.length;
    while (PadIndex > 0) {
      Temp = XorKey >> 8;
      ObfuscationArray[Index] = XorRor(PadArray[PadIndex], Temp);
      --Index;
      --PadIndex;
      Temp = XorKey & 255;
      ObfuscationArray[Index] = XorRor(Password[Index], Temp);
      --Index;
      --PadIndex;
    }
    return ObfuscationArray;
  };
}();
var crypto_DecryptData_Method1 = function(password, Data, XorArrayIndex, XorArray, O) {
  if (!O) O = Data;
  if (!XorArray) XorArray = crypto_CreateXorArray_Method1(password);
  var Index, Value;
  for (Index = 0; Index != Data.length; ++Index) {
    Value = Data[Index];
    Value ^= XorArray[XorArrayIndex];
    Value = (Value >> 5 | Value << 3) & 255;
    O[Index] = Value;
    ++XorArrayIndex;
  }
  return [O, XorArrayIndex, XorArray];
};
var crypto_MakeXorDecryptor = function(password) {
  var XorArrayIndex = 0, XorArray = crypto_CreateXorArray_Method1(password);
  return function(Data) {
    var O = crypto_DecryptData_Method1("", Data, XorArrayIndex, XorArray);
    XorArrayIndex = O[1];
    return O[0];
  };
};
function parse_XORObfuscation(blob, length, opts, out) {
  var o = { key: parseuint16(blob), verificationBytes: parseuint16(blob) };
  if (opts.password) o.verifier = crypto_CreatePasswordVerifier_Method1(opts.password);
  out.valid = o.verificationBytes === o.verifier;
  if (out.valid) out.insitu = crypto_MakeXorDecryptor(opts.password);
  return o;
}
function parse_FilePassHeader(blob, length, oo) {
  var o = oo;
  o.Info = blob.read_shift(2);
  blob.l -= 2;
  if (o.Info === 1) o.Data = parse_RC4Header(blob);
  else o.Data = parse_RC4CryptoHeader(blob, length);
  return o;
}
function parse_FilePass(blob, length, opts) {
  var o = { Type: opts.biff >= 8 ? blob.read_shift(2) : 0 };
  if (o.Type) parse_FilePassHeader(blob, length - 2, o);
  else parse_XORObfuscation(blob, opts.biff >= 8 ? length : length - 2, opts, o);
  return o;
}
function rtf_to_sheet(d, opts) {
  switch (opts.type) {
    case "base64":
      return rtf_to_sheet_str(Base64_decode(d), opts);
    case "binary":
      return rtf_to_sheet_str(d, opts);
    case "buffer":
      return rtf_to_sheet_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
    case "array":
      return rtf_to_sheet_str(cc2str(d), opts);
  }
  throw new Error("Unrecognized type " + opts.type);
}
function rtf_to_sheet_str(str, opts) {
  var o = opts || {};
  var ws = {};
  var dense = o.dense;
  if (dense)
    ws["!data"] = [];
  var rows = str_match_ng(str, "\\trowd", "\\row");
  if (!rows)
    throw new Error("RTF missing table");
  var range = { s: { c: 0, r: 0 }, e: { c: 0, r: rows.length - 1 } };
  var row = [];
  rows.forEach(function(rowtf, R) {
    if (dense)
      row = ws["!data"][R] = [];
    var rtfre = /\\[\w\-]+\b/g;
    var last_index = 0;
    var res;
    var C2 = -1;
    var payload = [];
    while ((res = rtfre.exec(rowtf)) != null) {
      var data = rowtf.slice(last_index, rtfre.lastIndex - res[0].length);
      if (data.charCodeAt(0) == 32)
        data = data.slice(1);
      if (data.length)
        payload.push(data);
      switch (res[0]) {
        case "\\cell":
          ++C2;
          if (payload.length) {
            var cell = { v: payload.join(""), t: "s" };
            if (cell.v == "TRUE" || cell.v == "FALSE") {
              cell.v = cell.v == "TRUE";
              cell.t = "b";
            } else if (!isNaN(fuzzynum(cell.v))) {
              cell.t = "n";
              if (o.cellText !== false)
                cell.w = cell.v;
              cell.v = fuzzynum(cell.v);
            }
            if (dense)
              row[C2] = cell;
            else
              ws[encode_cell({ r: R, c: C2 })] = cell;
          }
          payload = [];
          break;
        case "\\par":
          payload.push("\n");
          break;
      }
      last_index = rtfre.lastIndex;
    }
    if (C2 > range.e.c)
      range.e.c = C2;
  });
  ws["!ref"] = encode_range(range);
  return ws;
}
function rtf_to_workbook(d, opts) {
  var wb = sheet_to_workbook(rtf_to_sheet(d, opts), opts);
  wb.bookType = "rtf";
  return wb;
}
function hex2RGB(h2) {
  var o = h2.slice(h2[0] === "#" ? 1 : 0).slice(0, 6);
  return [parseInt(o.slice(0, 2), 16), parseInt(o.slice(2, 4), 16), parseInt(o.slice(4, 6), 16)];
}
function rgb2Hex(rgb) {
  for (var i = 0, o = 1; i != 3; ++i) o = o * 256 + (rgb[i] > 255 ? 255 : rgb[i] < 0 ? 0 : rgb[i]);
  return o.toString(16).toUpperCase().slice(1);
}
function rgb2HSL(rgb) {
  var R = rgb[0] / 255, G = rgb[1] / 255, B = rgb[2] / 255;
  var M = Math.max(R, G, B), m = Math.min(R, G, B), C2 = M - m;
  if (C2 === 0) return [0, 0, R];
  var H6 = 0, S2 = 0, L2 = M + m;
  S2 = C2 / (L2 > 1 ? 2 - L2 : L2);
  switch (M) {
    case R:
      H6 = ((G - B) / C2 + 6) % 6;
      break;
    case G:
      H6 = (B - R) / C2 + 2;
      break;
    case B:
      H6 = (R - G) / C2 + 4;
      break;
  }
  return [H6 / 6, S2, L2 / 2];
}
function hsl2RGB(hsl) {
  var H2 = hsl[0], S2 = hsl[1], L = hsl[2];
  var C2 = S2 * 2 * (L < 0.5 ? L : 1 - L), m = L - C2 / 2;
  var rgb = [m, m, m], h6 = 6 * H2;
  var X;
  if (S2 !== 0) switch (h6 | 0) {
    case 0:
    case 6:
      X = C2 * h6;
      rgb[0] += C2;
      rgb[1] += X;
      break;
    case 1:
      X = C2 * (2 - h6);
      rgb[0] += X;
      rgb[1] += C2;
      break;
    case 2:
      X = C2 * (h6 - 2);
      rgb[1] += C2;
      rgb[2] += X;
      break;
    case 3:
      X = C2 * (4 - h6);
      rgb[1] += X;
      rgb[2] += C2;
      break;
    case 4:
      X = C2 * (h6 - 4);
      rgb[2] += C2;
      rgb[0] += X;
      break;
    case 5:
      X = C2 * (6 - h6);
      rgb[2] += X;
      rgb[0] += C2;
      break;
  }
  for (var i = 0; i != 3; ++i) rgb[i] = Math.round(rgb[i] * 255);
  return rgb;
}
function rgb_tint(hex, tint) {
  if (tint === 0) return hex;
  var hsl = rgb2HSL(hex2RGB(hex));
  if (tint < 0) hsl[2] = hsl[2] * (1 + tint);
  else hsl[2] = 1 - (1 - hsl[2]) * (1 - tint);
  return rgb2Hex(hsl2RGB(hsl));
}
var DEF_MDW = 6, MAX_MDW = 15, MIN_MDW = 1, MDW = DEF_MDW;
function width2px(width) {
  return Math.floor((width + Math.round(128 / MDW) / 256) * MDW);
}
function px2char(px) {
  return Math.floor((px - 5) / MDW * 100 + 0.5) / 100;
}
function char2width(chr) {
  return Math.round((chr * MDW + 5) / MDW * 256) / 256;
}
function cycle_width(collw) {
  return char2width(px2char(width2px(collw)));
}
function find_mdw_colw(collw) {
  var delta = Math.abs(collw - cycle_width(collw)), _MDW = MDW;
  if (delta > 5e-3) {
    for (MDW = MIN_MDW; MDW < MAX_MDW; ++MDW) if (Math.abs(collw - cycle_width(collw)) <= delta) {
      delta = Math.abs(collw - cycle_width(collw));
      _MDW = MDW;
    }
  }
  MDW = _MDW;
}
function process_col(coll) {
  if (coll.width) {
    coll.wpx = width2px(coll.width);
    coll.wch = px2char(coll.wpx);
    coll.MDW = MDW;
  } else if (coll.wpx) {
    coll.wch = px2char(coll.wpx);
    coll.width = char2width(coll.wch);
    coll.MDW = MDW;
  } else if (typeof coll.wch == "number") {
    coll.width = char2width(coll.wch);
    coll.wpx = width2px(coll.width);
    coll.MDW = MDW;
  }
  if (coll.customWidth) delete coll.customWidth;
}
var DEF_PPI = 96, PPI = DEF_PPI;
function px2pt(px) {
  return px * 96 / PPI;
}
function pt2px(pt) {
  return pt * PPI / 96;
}
var XLMLPatternTypeMap = {
  "None": "none",
  "Solid": "solid",
  "Gray50": "mediumGray",
  "Gray75": "darkGray",
  "Gray25": "lightGray",
  "HorzStripe": "darkHorizontal",
  "VertStripe": "darkVertical",
  "ReverseDiagStripe": "darkDown",
  "DiagStripe": "darkUp",
  "DiagCross": "darkGrid",
  "ThickDiagCross": "darkTrellis",
  "ThinHorzStripe": "lightHorizontal",
  "ThinVertStripe": "lightVertical",
  "ThinReverseDiagStripe": "lightDown",
  "ThinHorzCross": "lightGrid"
};
function parse_borders(t, styles, themes, opts) {
  styles.Borders = [];
  var border = {};
  var pass = false;
  (t.match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<borders":
      case "<borders>":
      case "</borders>":
        break;
      case "<border":
      case "<border>":
      case "<border/>":
        border = /*::(*/
        {};
        if (y.diagonalUp) border.diagonalUp = parsexmlbool(y.diagonalUp);
        if (y.diagonalDown) border.diagonalDown = parsexmlbool(y.diagonalDown);
        styles.Borders.push(border);
        break;
      case "</border>":
        break;
      case "<left/>":
        break;
      case "<left":
      case "<left>":
        break;
      case "</left>":
        break;
      case "<right/>":
        break;
      case "<right":
      case "<right>":
        break;
      case "</right>":
        break;
      case "<top/>":
        break;
      case "<top":
      case "<top>":
        break;
      case "</top>":
        break;
      case "<bottom/>":
        break;
      case "<bottom":
      case "<bottom>":
        break;
      case "</bottom>":
        break;
      case "<diagonal":
      case "<diagonal>":
      case "<diagonal/>":
        break;
      case "</diagonal>":
        break;
      case "<horizontal":
      case "<horizontal>":
      case "<horizontal/>":
        break;
      case "</horizontal>":
        break;
      case "<vertical":
      case "<vertical>":
      case "<vertical/>":
        break;
      case "</vertical>":
        break;
      case "<start":
      case "<start>":
      case "<start/>":
        break;
      case "</start>":
        break;
      case "<end":
      case "<end>":
      case "<end/>":
        break;
      case "</end>":
        break;
      case "<color":
      case "<color>":
        break;
      case "<color/>":
      case "</color>":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (opts && opts.WTF) {
          if (!pass) throw new Error("unrecognized " + y[0] + " in borders");
        }
    }
  });
}
function parse_fills(t, styles, themes, opts) {
  styles.Fills = [];
  var fill2 = {};
  var pass = false;
  (t.match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<fills":
      case "<fills>":
      case "</fills>":
        break;
      case "<fill>":
      case "<fill":
      case "<fill/>":
        fill2 = {};
        styles.Fills.push(fill2);
        break;
      case "</fill>":
        break;
      case "<gradientFill>":
        break;
      case "<gradientFill":
      case "</gradientFill>":
        styles.Fills.push(fill2);
        fill2 = {};
        break;
      case "<patternFill":
      case "<patternFill>":
        if (y.patternType) fill2.patternType = y.patternType;
        break;
      case "<patternFill/>":
      case "</patternFill>":
        break;
      case "<bgColor":
        if (!fill2.bgColor) fill2.bgColor = {};
        if (y.indexed) fill2.bgColor.indexed = parseInt(y.indexed, 10);
        if (y.theme) fill2.bgColor.theme = parseInt(y.theme, 10);
        if (y.tint) fill2.bgColor.tint = parseFloat(y.tint);
        if (y.rgb) fill2.bgColor.rgb = y.rgb.slice(-6);
        break;
      case "<bgColor/>":
      case "</bgColor>":
        break;
      case "<fgColor":
        if (!fill2.fgColor) fill2.fgColor = {};
        if (y.theme) fill2.fgColor.theme = parseInt(y.theme, 10);
        if (y.tint) fill2.fgColor.tint = parseFloat(y.tint);
        if (y.rgb != null) fill2.fgColor.rgb = y.rgb.slice(-6);
        break;
      case "<fgColor/>":
      case "</fgColor>":
        break;
      case "<stop":
      case "<stop/>":
        break;
      case "</stop>":
        break;
      case "<color":
      case "<color/>":
        break;
      case "</color>":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (opts && opts.WTF) {
          if (!pass) throw new Error("unrecognized " + y[0] + " in fills");
        }
    }
  });
}
function parse_fonts(t, styles, themes, opts) {
  styles.Fonts = [];
  var font = {};
  var pass = false;
  (t.match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<fonts":
      case "<fonts>":
      case "</fonts>":
        break;
      case "<font":
      case "<font>":
        break;
      case "</font>":
      case "<font/>":
        styles.Fonts.push(font);
        font = {};
        break;
      case "<name":
        if (y.val) font.name = utf8read(y.val);
        break;
      case "<name/>":
      case "</name>":
        break;
      case "<b":
        font.bold = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<b/>":
        font.bold = 1;
        break;
      case "<i":
        font.italic = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<i/>":
        font.italic = 1;
        break;
      case "<u":
        switch (y.val) {
          case "none":
            font.underline = 0;
            break;
          case "single":
            font.underline = 1;
            break;
          case "double":
            font.underline = 2;
            break;
          case "singleAccounting":
            font.underline = 33;
            break;
          case "doubleAccounting":
            font.underline = 34;
            break;
        }
        break;
      case "<u/>":
        font.underline = 1;
        break;
      case "<strike":
        font.strike = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<strike/>":
        font.strike = 1;
        break;
      case "<outline":
        font.outline = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<outline/>":
        font.outline = 1;
        break;
      case "<shadow":
        font.shadow = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<shadow/>":
        font.shadow = 1;
        break;
      case "<condense":
        font.condense = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<condense/>":
        font.condense = 1;
        break;
      case "<extend":
        font.extend = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<extend/>":
        font.extend = 1;
        break;
      case "<sz":
        if (y.val) font.sz = +y.val;
        break;
      case "<sz/>":
      case "</sz>":
        break;
      case "<vertAlign":
        if (y.val) font.vertAlign = y.val;
        break;
      case "<vertAlign/>":
      case "</vertAlign>":
        break;
      case "<family":
        if (y.val) font.family = parseInt(y.val, 10);
        break;
      case "<family/>":
      case "</family>":
        break;
      case "<scheme":
        if (y.val) font.scheme = y.val;
        break;
      case "<scheme/>":
      case "</scheme>":
        break;
      case "<charset":
        if (y.val == "1") break;
        y.codepage = CS2CP[parseInt(y.val, 10)];
        break;
      case "<color":
        if (!font.color) font.color = {};
        if (y.auto) font.color.auto = parsexmlbool(y.auto);
        if (y.rgb) font.color.rgb = y.rgb.slice(-6);
        else if (y.indexed) {
          font.color.index = parseInt(y.indexed, 10);
          var icv = XLSIcv[font.color.index];
          if (font.color.index == 81) icv = XLSIcv[1];
          if (!icv) icv = XLSIcv[1];
          font.color.rgb = icv[0].toString(16) + icv[1].toString(16) + icv[2].toString(16);
        } else if (y.theme) {
          font.color.theme = parseInt(y.theme, 10);
          if (y.tint) font.color.tint = parseFloat(y.tint);
          if (y.theme && themes.themeElements && themes.themeElements.clrScheme) {
            font.color.rgb = rgb_tint(themes.themeElements.clrScheme[font.color.theme].rgb, font.color.tint || 0);
          }
        }
        break;
      case "<color/>":
      case "</color>":
        break;
      case "<AlternateContent":
        pass = true;
        break;
      case "</AlternateContent>":
        pass = false;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (opts && opts.WTF) {
          if (!pass) throw new Error("unrecognized " + y[0] + " in fonts");
        }
    }
  });
}
function parse_numFmts(t, styles, opts) {
  styles.NumberFmt = [];
  var k2 = keys(table_fmt);
  for (var i = 0; i < k2.length; ++i) styles.NumberFmt[k2[i]] = table_fmt[k2[i]];
  var m = t.match(tagregex);
  if (!m) return;
  for (i = 0; i < m.length; ++i) {
    var y = parsexmltag(m[i]);
    switch (strip_ns(y[0])) {
      case "<numFmts":
      case "</numFmts>":
      case "<numFmts/>":
      case "<numFmts>":
        break;
      case "<numFmt":
        {
          var f = unescapexml(utf8read(y.formatCode)), j = parseInt(y.numFmtId, 10);
          styles.NumberFmt[j] = f;
          if (j > 0) {
            if (j > 392) {
              for (j = 392; j > 60; --j) if (styles.NumberFmt[j] == null) break;
              styles.NumberFmt[j] = f;
            }
            SSF__load(f, j);
          }
        }
        break;
      case "</numFmt>":
        break;
      default:
        if (opts.WTF) throw new Error("unrecognized " + y[0] + " in numFmts");
    }
  }
}
var cellXF_uint = ["numFmtId", "fillId", "fontId", "borderId", "xfId"];
var cellXF_bool = ["applyAlignment", "applyBorder", "applyFill", "applyFont", "applyNumberFormat", "applyProtection", "pivotButton", "quotePrefix"];
function parse_cellXfs(t, styles, opts) {
  styles.CellXf = [];
  var xf;
  var pass = false;
  (t.match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x), i = 0;
    switch (strip_ns(y[0])) {
      case "<cellXfs":
      case "<cellXfs>":
      case "<cellXfs/>":
      case "</cellXfs>":
        break;
      case "<xf":
      case "<xf/>":
      case "<xf>":
        xf = y;
        delete xf[0];
        for (i = 0; i < cellXF_uint.length; ++i) if (xf[cellXF_uint[i]])
          xf[cellXF_uint[i]] = parseInt(xf[cellXF_uint[i]], 10);
        for (i = 0; i < cellXF_bool.length; ++i) if (xf[cellXF_bool[i]])
          xf[cellXF_bool[i]] = parsexmlbool(xf[cellXF_bool[i]]);
        if (styles.NumberFmt && xf.numFmtId > 392) {
          for (i = 392; i > 60; --i) if (styles.NumberFmt[xf.numFmtId] == styles.NumberFmt[i]) {
            xf.numFmtId = i;
            break;
          }
        }
        styles.CellXf.push(xf);
        break;
      case "</xf>":
        break;
      case "<alignment":
      case "<alignment/>":
      case "<alignment>":
        var alignment = {};
        if (y.vertical) alignment.vertical = y.vertical;
        if (y.horizontal) alignment.horizontal = y.horizontal;
        if (y.textRotation != null) alignment.textRotation = y.textRotation;
        if (y.indent) alignment.indent = y.indent;
        if (y.wrapText) alignment.wrapText = parsexmlbool(y.wrapText);
        xf.alignment = alignment;
        break;
      case "</alignment>":
        break;
      case "<protection":
      case "<protection>":
        break;
      case "</protection>":
      case "<protection/>":
        break;
      case "<AlternateContent":
      case "<AlternateContent>":
        pass = true;
        break;
      case "</AlternateContent>":
        pass = false;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (opts && opts.WTF) {
          if (!pass) throw new Error("unrecognized " + y[0] + " in cellXfs");
        }
    }
  });
}
var parse_sty_xml = /* @__PURE__ */ function make_pstyx() {
  return function parse_sty_xml2(data, themes, opts) {
    var styles = {};
    if (!data) return styles;
    data = remove_doctype(str_remove_ng(data, "<!--", "-->"));
    var t;
    if (t = str_match_xml_ns(data, "numFmts")) parse_numFmts(t[0], styles, opts);
    if (t = str_match_xml_ns(data, "fonts")) parse_fonts(t[0], styles, themes, opts);
    if (t = str_match_xml_ns(data, "fills")) parse_fills(t[0], styles, themes, opts);
    if (t = str_match_xml_ns(data, "borders")) parse_borders(t[0], styles, themes, opts);
    if (t = str_match_xml_ns(data, "cellXfs")) parse_cellXfs(t[0], styles, opts);
    return styles;
  };
}();
function parse_BrtFmt(data, length) {
  var numFmtId = data.read_shift(2);
  var stFmtCode = parse_XLWideString(data);
  return [numFmtId, stFmtCode];
}
function parse_BrtFont(data, length, opts) {
  var out = {};
  out.sz = data.read_shift(2) / 20;
  var grbit = parse_FontFlags(data);
  if (grbit.fItalic) out.italic = 1;
  if (grbit.fCondense) out.condense = 1;
  if (grbit.fExtend) out.extend = 1;
  if (grbit.fShadow) out.shadow = 1;
  if (grbit.fOutline) out.outline = 1;
  if (grbit.fStrikeout) out.strike = 1;
  var bls = data.read_shift(2);
  if (bls === 700) out.bold = 1;
  switch (data.read_shift(2)) {
    case 1:
      out.vertAlign = "superscript";
      break;
    case 2:
      out.vertAlign = "subscript";
      break;
  }
  var underline = data.read_shift(1);
  if (underline != 0) out.underline = underline;
  var family = data.read_shift(1);
  if (family > 0) out.family = family;
  var bCharSet = data.read_shift(1);
  if (bCharSet > 0) out.charset = bCharSet;
  data.l++;
  out.color = parse_BrtColor(data);
  switch (data.read_shift(1)) {
    case 1:
      out.scheme = "major";
      break;
    case 2:
      out.scheme = "minor";
      break;
  }
  out.name = parse_XLWideString(data);
  return out;
}
var parse_BrtFill = parsenoop;
function parse_BrtXF(data, length) {
  var tgt = data.l + length;
  var ixfeParent = data.read_shift(2);
  var ifmt = data.read_shift(2);
  data.l = tgt;
  return { ixfe: ixfeParent, numFmtId: ifmt };
}
var parse_BrtBorder = parsenoop;
function parse_sty_bin(data, themes, opts) {
  var styles = {};
  styles.NumberFmt = [];
  for (var y in table_fmt) styles.NumberFmt[y] = table_fmt[y];
  styles.CellXf = [];
  styles.Fonts = [];
  var state = [];
  var pass = false;
  recordhopper(data, function hopper_sty(val, R, RT) {
    switch (RT) {
      case 44:
        styles.NumberFmt[val[0]] = val[1];
        SSF__load(val[1], val[0]);
        break;
      case 43:
        styles.Fonts.push(val);
        if (val.color.theme != null && themes && themes.themeElements && themes.themeElements.clrScheme) {
          val.color.rgb = rgb_tint(themes.themeElements.clrScheme[val.color.theme].rgb, val.color.tint || 0);
        }
        break;
      case 1025:
        break;
      case 45:
        break;
      case 46:
        break;
      case 47:
        if (state[state.length - 1] == 617) {
          styles.CellXf.push(val);
        }
        break;
      case 48:
      case 507:
      case 572:
      case 475:
        break;
      case 1171:
      case 2102:
      case 1130:
      case 512:
      case 2095:
      case 3072:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      case 37:
        state.push(RT);
        pass = true;
        break;
      case 38:
        state.pop();
        pass = false;
        break;
      default:
        if (R.T > 0) state.push(RT);
        else if (R.T < 0) state.pop();
        else if (!pass || opts.WTF && state[state.length - 1] != 37) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return styles;
}
var XLSXThemeClrScheme = [
  "</a:lt1>",
  "</a:dk1>",
  "</a:lt2>",
  "</a:dk2>",
  "</a:accent1>",
  "</a:accent2>",
  "</a:accent3>",
  "</a:accent4>",
  "</a:accent5>",
  "</a:accent6>",
  "</a:hlink>",
  "</a:folHlink>"
];
function parse_clrScheme(t, themes, opts) {
  themes.themeElements.clrScheme = [];
  var color = {};
  (t[0].match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    switch (y[0]) {
      case "<a:clrScheme":
      case "</a:clrScheme>":
        break;
      case "<a:srgbClr":
        color.rgb = y.val;
        break;
      case "</a:srgbClr>":
        break;
      case "<a:sysClr":
        color.rgb = y.lastClr;
        break;
      case "</a:sysClr>":
        break;
      case "</a:dk1>":
      case "</a:lt1>":
      case "<a:dk1>":
      case "<a:lt1>":
      case "<a:dk2>":
      case "</a:dk2>":
      case "<a:lt2>":
      case "</a:lt2>":
      case "<a:accent1>":
      case "</a:accent1>":
      case "<a:accent2>":
      case "</a:accent2>":
      case "<a:accent3>":
      case "</a:accent3>":
      case "<a:accent4>":
      case "</a:accent4>":
      case "<a:accent5>":
      case "</a:accent5>":
      case "<a:accent6>":
      case "</a:accent6>":
      case "<a:hlink>":
      case "</a:hlink>":
      case "<a:folHlink>":
      case "</a:folHlink>":
        if (y[0].charAt(1) === "/") {
          themes.themeElements.clrScheme[XLSXThemeClrScheme.indexOf(y[0])] = color;
          color = {};
        } else {
          color.name = y[0].slice(3, y[0].length - 1);
        }
        break;
      default:
        if (opts && opts.WTF) throw new Error("Unrecognized " + y[0] + " in clrScheme");
    }
  });
}
function parse_themeElements(data, themes, opts) {
  themes.themeElements = {};
  var t;
  if (!(t = str_match_xml(data, "a:clrScheme"))) throw new Error("clrScheme not found in themeElements");
  parse_clrScheme(t, themes, opts);
  if (!(t = str_match_xml(data, "a:fontScheme"))) throw new Error("fontScheme not found in themeElements");
  if (!(t = str_match_xml(data, "a:fmtScheme"))) throw new Error("fmtScheme not found in themeElements");
}
function parse_theme_xml(data, opts) {
  if (!data || data.length === 0) data = write_theme();
  var t;
  var themes = {};
  if (!(t = str_match_xml(data, "a:themeElements"))) throw new Error("themeElements not found in theme");
  parse_themeElements(t[0], themes, opts);
  themes.raw = data;
  return themes;
}
function write_theme(Themes, opts) {
  var o = [XML_HEADER];
  o[o.length] = '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">';
  o[o.length] = "<a:themeElements>";
  o[o.length] = '<a:clrScheme name="Office">';
  o[o.length] = '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>';
  o[o.length] = '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>';
  o[o.length] = '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>';
  o[o.length] = '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>';
  o[o.length] = '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>';
  o[o.length] = '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>';
  o[o.length] = '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>';
  o[o.length] = '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>';
  o[o.length] = '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>';
  o[o.length] = '<a:accent6><a:srgbClr val="F79646"/></a:accent6>';
  o[o.length] = '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>';
  o[o.length] = '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>';
  o[o.length] = "</a:clrScheme>";
  o[o.length] = '<a:fontScheme name="Office">';
  o[o.length] = "<a:majorFont>";
  o[o.length] = '<a:latin typeface="Cambria"/>';
  o[o.length] = '<a:ea typeface=""/>';
  o[o.length] = '<a:cs typeface=""/>';
  o[o.length] = '<a:font script="Jpan" typeface=" "/>';
  o[o.length] = '<a:font script="Hang" typeface=" "/>';
  o[o.length] = '<a:font script="Hans" typeface=""/>';
  o[o.length] = '<a:font script="Hant" typeface=""/>';
  o[o.length] = '<a:font script="Arab" typeface="Times New Roman"/>';
  o[o.length] = '<a:font script="Hebr" typeface="Times New Roman"/>';
  o[o.length] = '<a:font script="Thai" typeface="Tahoma"/>';
  o[o.length] = '<a:font script="Ethi" typeface="Nyala"/>';
  o[o.length] = '<a:font script="Beng" typeface="Vrinda"/>';
  o[o.length] = '<a:font script="Gujr" typeface="Shruti"/>';
  o[o.length] = '<a:font script="Khmr" typeface="MoolBoran"/>';
  o[o.length] = '<a:font script="Knda" typeface="Tunga"/>';
  o[o.length] = '<a:font script="Guru" typeface="Raavi"/>';
  o[o.length] = '<a:font script="Cans" typeface="Euphemia"/>';
  o[o.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
  o[o.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
  o[o.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
  o[o.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
  o[o.length] = '<a:font script="Deva" typeface="Mangal"/>';
  o[o.length] = '<a:font script="Telu" typeface="Gautami"/>';
  o[o.length] = '<a:font script="Taml" typeface="Latha"/>';
  o[o.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
  o[o.length] = '<a:font script="Orya" typeface="Kalinga"/>';
  o[o.length] = '<a:font script="Mlym" typeface="Kartika"/>';
  o[o.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
  o[o.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
  o[o.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
  o[o.length] = '<a:font script="Viet" typeface="Times New Roman"/>';
  o[o.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
  o[o.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
  o[o.length] = "</a:majorFont>";
  o[o.length] = "<a:minorFont>";
  o[o.length] = '<a:latin typeface="Calibri"/>';
  o[o.length] = '<a:ea typeface=""/>';
  o[o.length] = '<a:cs typeface=""/>';
  o[o.length] = '<a:font script="Jpan" typeface=" "/>';
  o[o.length] = '<a:font script="Hang" typeface=" "/>';
  o[o.length] = '<a:font script="Hans" typeface=""/>';
  o[o.length] = '<a:font script="Hant" typeface=""/>';
  o[o.length] = '<a:font script="Arab" typeface="Arial"/>';
  o[o.length] = '<a:font script="Hebr" typeface="Arial"/>';
  o[o.length] = '<a:font script="Thai" typeface="Tahoma"/>';
  o[o.length] = '<a:font script="Ethi" typeface="Nyala"/>';
  o[o.length] = '<a:font script="Beng" typeface="Vrinda"/>';
  o[o.length] = '<a:font script="Gujr" typeface="Shruti"/>';
  o[o.length] = '<a:font script="Khmr" typeface="DaunPenh"/>';
  o[o.length] = '<a:font script="Knda" typeface="Tunga"/>';
  o[o.length] = '<a:font script="Guru" typeface="Raavi"/>';
  o[o.length] = '<a:font script="Cans" typeface="Euphemia"/>';
  o[o.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
  o[o.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
  o[o.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
  o[o.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
  o[o.length] = '<a:font script="Deva" typeface="Mangal"/>';
  o[o.length] = '<a:font script="Telu" typeface="Gautami"/>';
  o[o.length] = '<a:font script="Taml" typeface="Latha"/>';
  o[o.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
  o[o.length] = '<a:font script="Orya" typeface="Kalinga"/>';
  o[o.length] = '<a:font script="Mlym" typeface="Kartika"/>';
  o[o.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
  o[o.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
  o[o.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
  o[o.length] = '<a:font script="Viet" typeface="Arial"/>';
  o[o.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
  o[o.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
  o[o.length] = "</a:minorFont>";
  o[o.length] = "</a:fontScheme>";
  o[o.length] = '<a:fmtScheme name="Office">';
  o[o.length] = "<a:fillStyleLst>";
  o[o.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
  o[o.length] = '<a:gradFill rotWithShape="1">';
  o[o.length] = "<a:gsLst>";
  o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  o[o.length] = '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o[o.length] = "</a:gsLst>";
  o[o.length] = '<a:lin ang="16200000" scaled="1"/>';
  o[o.length] = "</a:gradFill>";
  o[o.length] = '<a:gradFill rotWithShape="1">';
  o[o.length] = "<a:gsLst>";
  o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>';
  o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o[o.length] = "</a:gsLst>";
  o[o.length] = '<a:lin ang="16200000" scaled="0"/>';
  o[o.length] = "</a:gradFill>";
  o[o.length] = "</a:fillStyleLst>";
  o[o.length] = "<a:lnStyleLst>";
  o[o.length] = '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>';
  o[o.length] = '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
  o[o.length] = '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
  o[o.length] = "</a:lnStyleLst>";
  o[o.length] = "<a:effectStyleLst>";
  o[o.length] = "<a:effectStyle>";
  o[o.length] = "<a:effectLst>";
  o[o.length] = '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>';
  o[o.length] = "</a:effectLst>";
  o[o.length] = "</a:effectStyle>";
  o[o.length] = "<a:effectStyle>";
  o[o.length] = "<a:effectLst>";
  o[o.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
  o[o.length] = "</a:effectLst>";
  o[o.length] = "</a:effectStyle>";
  o[o.length] = "<a:effectStyle>";
  o[o.length] = "<a:effectLst>";
  o[o.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
  o[o.length] = "</a:effectLst>";
  o[o.length] = '<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>';
  o[o.length] = '<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>';
  o[o.length] = "</a:effectStyle>";
  o[o.length] = "</a:effectStyleLst>";
  o[o.length] = "<a:bgFillStyleLst>";
  o[o.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
  o[o.length] = '<a:gradFill rotWithShape="1">';
  o[o.length] = "<a:gsLst>";
  o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o[o.length] = '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>';
  o[o.length] = "</a:gsLst>";
  o[o.length] = '<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>';
  o[o.length] = "</a:gradFill>";
  o[o.length] = '<a:gradFill rotWithShape="1">';
  o[o.length] = "<a:gsLst>";
  o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>';
  o[o.length] = "</a:gsLst>";
  o[o.length] = '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>';
  o[o.length] = "</a:gradFill>";
  o[o.length] = "</a:bgFillStyleLst>";
  o[o.length] = "</a:fmtScheme>";
  o[o.length] = "</a:themeElements>";
  o[o.length] = "<a:objectDefaults>";
  o[o.length] = "<a:spDef>";
  o[o.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>';
  o[o.length] = "</a:spDef>";
  o[o.length] = "<a:lnDef>";
  o[o.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>';
  o[o.length] = "</a:lnDef>";
  o[o.length] = "</a:objectDefaults>";
  o[o.length] = "<a:extraClrSchemeLst/>";
  o[o.length] = "</a:theme>";
  return o.join("");
}
function parse_Theme(blob, length, opts) {
  var end = blob.l + length;
  var dwThemeVersion = blob.read_shift(4);
  if (dwThemeVersion === 124226) return;
  if (!opts.cellStyles) {
    blob.l = end;
    return;
  }
  var data = blob.slice(blob.l);
  blob.l = end;
  var zip;
  try {
    zip = zip_read(data, { type: "array" });
  } catch (e) {
    return;
  }
  var themeXML = getzipstr(zip, "theme/theme/theme1.xml", true);
  if (!themeXML) return;
  return parse_theme_xml(themeXML, opts);
}
function parse_ColorTheme(blob) {
  return blob.read_shift(4);
}
function parse_FullColorExt(blob) {
  var o = {};
  o.xclrType = blob.read_shift(2);
  o.nTintShade = blob.read_shift(2);
  switch (o.xclrType) {
    case 0:
      blob.l += 4;
      break;
    case 1:
      o.xclrValue = parse_IcvXF(blob, 4);
      break;
    case 2:
      o.xclrValue = parse_LongRGBA(blob);
      break;
    case 3:
      o.xclrValue = parse_ColorTheme(blob);
      break;
    case 4:
      blob.l += 4;
      break;
  }
  blob.l += 8;
  return o;
}
function parse_IcvXF(blob, length) {
  return parsenoop(blob, length);
}
function parse_XFExtGradient(blob, length) {
  return parsenoop(blob, length);
}
function parse_ExtProp(blob) {
  var extType = blob.read_shift(2);
  var cb = blob.read_shift(2) - 4;
  var o = [extType];
  switch (extType) {
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 13:
      o[1] = parse_FullColorExt(blob);
      break;
    case 6:
      o[1] = parse_XFExtGradient(blob, cb);
      break;
    case 14:
    case 15:
      o[1] = blob.read_shift(cb === 1 ? 1 : 2);
      break;
    default:
      throw new Error("Unrecognized ExtProp type: " + extType + " " + cb);
  }
  return o;
}
function parse_XFExt(blob, length) {
  var end = blob.l + length;
  blob.l += 2;
  var ixfe = blob.read_shift(2);
  blob.l += 2;
  var cexts = blob.read_shift(2);
  var ext = [];
  while (cexts-- > 0) ext.push(parse_ExtProp(blob, end - blob.l));
  return { ixfe, ext };
}
function update_xfext(xf, xfext) {
  xfext.forEach(function(xfe) {
    switch (xfe[0]) {
    }
  });
}
function parse_BrtMdtinfo(data, length) {
  return {
    flags: data.read_shift(4),
    version: data.read_shift(4),
    name: parse_XLWideString(data)
  };
}
function parse_BrtMdb(data) {
  var out = [];
  var cnt = data.read_shift(4);
  while (cnt-- > 0)
    out.push([data.read_shift(4), data.read_shift(4)]);
  return out;
}
function parse_BrtBeginEsmdb(data) {
  data.l += 4;
  return data.read_shift(4) != 0;
}
function parse_xlmeta_bin(data, name, _opts) {
  var out = { Types: [], Cell: [], Value: [] };
  var opts = _opts || {};
  var state = [];
  var pass = false;
  var metatype = 2;
  recordhopper(data, function(val, R, RT) {
    switch (RT) {
      case 335:
        out.Types.push({ name: val.name });
        break;
      case 51:
        val.forEach(function(r) {
          if (metatype == 1)
            out.Cell.push({ type: out.Types[r[0] - 1].name, index: r[1] });
          else if (metatype == 0)
            out.Value.push({ type: out.Types[r[0] - 1].name, index: r[1] });
        });
        break;
      case 337:
        metatype = val ? 1 : 0;
        break;
      case 338:
        metatype = 2;
        break;
      case 35:
        state.push(RT);
        pass = true;
        break;
      case 36:
        state.pop();
        pass = false;
        break;
      default:
        if (R.T) ;
        else if (!pass || opts.WTF && state[state.length - 1] != 35)
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return out;
}
function parse_xlmeta_xml(data, name, opts) {
  var out = { Types: [], Cell: [], Value: [] };
  if (!data)
    return out;
  var pass = false;
  var metatype = 2;
  var lastmeta;
  data.replace(tagregex, function(x) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<?xml":
        break;
      case "<metadata":
      case "</metadata>":
        break;
      case "<metadataTypes":
      case "</metadataTypes>":
        break;
      case "<metadataType":
        out.Types.push({ name: y.name });
        break;
      case "</metadataType>":
        break;
      case "<futureMetadata":
        for (var j = 0; j < out.Types.length; ++j)
          if (out.Types[j].name == y.name)
            lastmeta = out.Types[j];
        break;
      case "</futureMetadata>":
        break;
      case "<bk>":
        break;
      case "</bk>":
        break;
      case "<rc":
        if (metatype == 1)
          out.Cell.push({ type: out.Types[y.t - 1].name, index: +y.v });
        else if (metatype == 0)
          out.Value.push({ type: out.Types[y.t - 1].name, index: +y.v });
        break;
      case "</rc>":
        break;
      case "<cellMetadata":
        metatype = 1;
        break;
      case "</cellMetadata>":
        metatype = 2;
        break;
      case "<valueMetadata":
        metatype = 0;
        break;
      case "</valueMetadata>":
        metatype = 2;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      case "<rvb":
        if (!lastmeta)
          break;
        if (!lastmeta.offsets)
          lastmeta.offsets = [];
        lastmeta.offsets.push(+y.i);
        break;
      default:
        if (!pass && (opts == null ? void 0 : opts.WTF))
          throw new Error("unrecognized " + y[0] + " in metadata");
    }
    return x;
  });
  return out;
}
function parse_cc_xml(data) {
  var d = [];
  if (!data) return d;
  var i = 1;
  (data.match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    switch (y[0]) {
      case "<?xml":
        break;
      case "<calcChain":
      case "<calcChain>":
      case "</calcChain>":
        break;
      case "<c":
        delete y[0];
        if (y.i) i = y.i;
        else y.i = i;
        d.push(y);
        break;
    }
  });
  return d;
}
function parse_BrtCalcChainItem$(data) {
  var out = {};
  out.i = data.read_shift(4);
  var cell = {};
  cell.r = data.read_shift(4);
  cell.c = data.read_shift(4);
  out.r = encode_cell(cell);
  var flags = data.read_shift(1);
  if (flags & 2) out.l = "1";
  if (flags & 8) out.a = "1";
  return out;
}
function parse_cc_bin(data, name, opts) {
  var out = [];
  recordhopper(data, function hopper_cc(val, R, RT) {
    switch (RT) {
      case 63:
        out.push(val);
        break;
      default:
        if (R.T) ;
        else throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return out;
}
function parse_xlink_xml() {
}
function parse_xlink_bin(data, rel, name, _opts) {
  if (!data) return data;
  var opts = _opts || {};
  var pass = false;
  recordhopper(data, function xlink_parse(val, R, RT) {
    switch (RT) {
      case 359:
      case 363:
      case 364:
      case 366:
      case 367:
      case 368:
      case 369:
      case 370:
      case 371:
      case 472:
      case 577:
      case 578:
      case 579:
      case 580:
      case 581:
      case 582:
      case 583:
      case 584:
      case 585:
      case 586:
      case 587:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      default:
        if (R.T) ;
        else if (!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  }, opts);
}
function parse_drawing(data, rels) {
  if (!data) return "??";
  var id = (data.match(/<c:chart [^<>]*r:id="([^<>"]*)"/) || ["", ""])[1];
  return rels["!id"][id].Target;
}
function parse_vml(data, sheet, comments) {
  var cidx = 0;
  (str_match_xml_ns_g(data, "shape") || []).forEach(function(m) {
    var type = "";
    var hidden = true;
    var aidx = -1;
    var R = -1, C2 = -1;
    m.replace(tagregex, function(x, idx) {
      var y = parsexmltag(x);
      switch (strip_ns(y[0])) {
        case "<ClientData":
          if (y.ObjectType) type = y.ObjectType;
          break;
        case "<Visible":
        case "<Visible/>":
          hidden = false;
          break;
        case "<Row":
        case "<Row>":
          aidx = idx + x.length;
          break;
        case "</Row>":
          R = +m.slice(aidx, idx).trim();
          break;
        case "<Column":
        case "<Column>":
          aidx = idx + x.length;
          break;
        case "</Column>":
          C2 = +m.slice(aidx, idx).trim();
          break;
      }
      return "";
    });
    switch (type) {
      case "Note":
        var cell = ws_get_cell_stub(sheet, R >= 0 && C2 >= 0 ? encode_cell({ r: R, c: C2 }) : comments[cidx].ref);
        if (cell.c) {
          cell.c.hidden = hidden;
        }
        ++cidx;
        break;
    }
  });
}
function sheet_insert_comments(sheet, comments, threaded, people) {
  var dense = sheet["!data"] != null;
  var cell;
  comments.forEach(function(comment) {
    var r = decode_cell(comment.ref);
    if (r.r < 0 || r.c < 0) return;
    if (dense) {
      if (!sheet["!data"][r.r]) sheet["!data"][r.r] = [];
      cell = sheet["!data"][r.r][r.c];
    } else cell = sheet[comment.ref];
    if (!cell) {
      cell = { t: "z" };
      if (dense) sheet["!data"][r.r][r.c] = cell;
      else sheet[comment.ref] = cell;
      var range = safe_decode_range(sheet["!ref"] || "BDWGO1000001:A1");
      if (range.s.r > r.r) range.s.r = r.r;
      if (range.e.r < r.r) range.e.r = r.r;
      if (range.s.c > r.c) range.s.c = r.c;
      if (range.e.c < r.c) range.e.c = r.c;
      var encoded = encode_range(range);
      sheet["!ref"] = encoded;
    }
    if (!cell.c) cell.c = [];
    var o = { a: comment.author, t: comment.t, r: comment.r, T: threaded };
    if (comment.h) o.h = comment.h;
    for (var i = cell.c.length - 1; i >= 0; --i) {
      if (!threaded && cell.c[i].T) return;
      if (threaded && !cell.c[i].T) cell.c.splice(i, 1);
    }
    if (threaded && people) for (i = 0; i < people.length; ++i) {
      if (o.a == people[i].id) {
        o.a = people[i].name || o.a;
        break;
      }
    }
    cell.c.push(o);
  });
}
function parse_comments_xml(data, opts) {
  if (data.match(/<(?:\w+:)?comments *\/>/)) return [];
  var authors = [];
  var commentList = [];
  var authtag = str_match_xml_ns(data, "authors");
  if (authtag && authtag[1]) authtag[1].split(/<\/\w*:?author>/).forEach(function(x) {
    if (x === "" || x.trim() === "") return;
    var a = x.match(/<(?:\w+:)?author[^<>]*>(.*)/);
    if (a) authors.push(a[1]);
  });
  var cmnttag = str_match_xml_ns(data, "commentList");
  if (cmnttag && cmnttag[1]) cmnttag[1].split(/<\/\w*:?comment>/).forEach(function(x) {
    if (x === "" || x.trim() === "") return;
    var cm = x.match(/<(?:\w+:)?comment[^<>]*>/);
    if (!cm) return;
    var y = parsexmltag(cm[0]);
    var comment = { author: y.authorId && authors[y.authorId] || "sheetjsghost", ref: y.ref, guid: y.guid };
    var cell = decode_cell(y.ref);
    if (opts.sheetRows && opts.sheetRows <= cell.r) return;
    var textMatch = str_match_xml_ns(x, "text");
    var rt = !!textMatch && !!textMatch[1] && parse_si(textMatch[1]) || { r: "", t: "", h: "" };
    comment.r = rt.r;
    if (rt.r == "<t></t>") rt.t = rt.h = "";
    comment.t = (rt.t || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    if (opts.cellHTML) comment.h = rt.h;
    commentList.push(comment);
  });
  return commentList;
}
function parse_tcmnt_xml(data, opts) {
  var out = [];
  var pass = false, comment = {}, tidx = 0;
  data.replace(tagregex, function xml_tcmnt(x, idx) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<?xml":
        break;
      case "<ThreadedComments":
        break;
      case "</ThreadedComments>":
        break;
      case "<threadedComment":
        comment = { author: y.personId, guid: y.id, ref: y.ref, T: 1 };
        break;
      case "</threadedComment>":
        if (comment.t != null) out.push(comment);
        break;
      case "<text>":
      case "<text":
        tidx = idx + x.length;
        break;
      case "</text>":
        comment.t = data.slice(tidx, idx).replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        break;
      case "<mentions":
      case "<mentions>":
        pass = true;
        break;
      case "</mentions>":
        pass = false;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (!pass && opts.WTF) throw new Error("unrecognized " + y[0] + " in threaded comments");
    }
    return x;
  });
  return out;
}
function parse_people_xml(data, opts) {
  var out = [];
  var pass = false;
  data.replace(tagregex, function xml_tcmnt(x) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<?xml":
        break;
      case "<personList":
        break;
      case "</personList>":
        break;
      case "<person":
        out.push({ name: y.displayname, id: y.id });
        break;
      case "</person>":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (!pass && opts.WTF) throw new Error("unrecognized " + y[0] + " in threaded comments");
    }
    return x;
  });
  return out;
}
function parse_BrtBeginComment(data) {
  var out = {};
  out.iauthor = data.read_shift(4);
  var rfx = parse_UncheckedRfX(data);
  out.rfx = rfx.s;
  out.ref = encode_cell(rfx.s);
  data.l += 16;
  return out;
}
var parse_BrtCommentAuthor = parse_XLWideString;
function parse_comments_bin(data, opts) {
  var out = [];
  var authors = [];
  var c2 = {};
  var pass = false;
  recordhopper(data, function hopper_cmnt(val, R, RT) {
    switch (RT) {
      case 632:
        authors.push(val);
        break;
      case 635:
        c2 = val;
        break;
      case 637:
        c2.t = val.t;
        c2.h = val.h;
        c2.r = val.r;
        break;
      case 636:
        c2.author = authors[c2.iauthor];
        delete c2.iauthor;
        if (opts.sheetRows && c2.rfx && opts.sheetRows <= c2.rfx.r) break;
        if (!c2.t) c2.t = "";
        delete c2.rfx;
        out.push(c2);
        break;
      case 3072:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      case 37:
        break;
      case 38:
        break;
      default:
        if (R.T) ;
        else if (!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return out;
}
var CT_VBA = "application/vnd.ms-office.vbaProject";
function make_vba_xls(cfb) {
  var newcfb = CFB.utils.cfb_new({ root: "R" });
  cfb.FullPaths.forEach(function(p, i) {
    if (p.slice(-1) === "/" || !p.match(/_VBA_PROJECT_CUR/))
      return;
    var newpath = p.replace(/^[^\/]*/, "R").replace(/\/_VBA_PROJECT_CUR\u0000*/, "");
    CFB.utils.cfb_add(newcfb, newpath, cfb.FileIndex[i].content);
  });
  return CFB.write(newcfb);
}
function parse_ds_bin() {
  return { "!type": "dialog" };
}
function parse_ds_xml() {
  return { "!type": "dialog" };
}
function parse_ms_bin() {
  return { "!type": "macro" };
}
function parse_ms_xml() {
  return { "!type": "macro" };
}
var rc_to_a1 = /* @__PURE__ */ function() {
  var rcregex = /(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g;
  var rcbase = { r: 0, c: 0 };
  function rcfunc($$, $1, $2, $3) {
    var cRel = false, rRel = false;
    if ($2.length == 0) rRel = true;
    else if ($2.charAt(0) == "[") {
      rRel = true;
      $2 = $2.slice(1, -1);
    }
    if ($3.length == 0) cRel = true;
    else if ($3.charAt(0) == "[") {
      cRel = true;
      $3 = $3.slice(1, -1);
    }
    var R = $2.length > 0 ? parseInt($2, 10) | 0 : 0, C2 = $3.length > 0 ? parseInt($3, 10) | 0 : 0;
    if (cRel) C2 += rcbase.c;
    else --C2;
    if (rRel) R += rcbase.r;
    else --R;
    return $1 + (cRel ? "" : "$") + encode_col(C2) + (rRel ? "" : "$") + encode_row(R);
  }
  return function rc_to_a12(fstr, base) {
    rcbase = base;
    return fstr.replace(rcregex, rcfunc);
  };
}();
var crefregex = /(^|[^._A-Z0-9])(\$?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])(\$?)(\d{1,7})(?![_.\(A-Za-z0-9])/g;
try {
  crefregex = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g;
} catch (e) {
}
var a1_to_rc = /* @__PURE__ */ function() {
  return function a1_to_rc2(fstr, base) {
    return fstr.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
      var c2 = decode_col($3) - ($2 ? 0 : base.c);
      var r = decode_row($5) - ($4 ? 0 : base.r);
      var R = $4 == "$" ? r + 1 : r == 0 ? "" : "[" + r + "]";
      var C2 = $2 == "$" ? c2 + 1 : c2 == 0 ? "" : "[" + c2 + "]";
      return $1 + "R" + R + "C" + C2;
    });
  };
}();
function shift_formula_str(f, delta) {
  return f.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
    return $1 + ($2 == "$" ? $2 + $3 : encode_col(decode_col($3) + delta.c)) + ($4 == "$" ? $4 + $5 : encode_row(decode_row($5) + delta.r));
  });
}
function shift_formula_xlsx(f, range, cell) {
  var r = decode_range(range), s = r.s, c2 = decode_cell(cell);
  var delta = { r: c2.r - s.r, c: c2.c - s.c };
  return shift_formula_str(f, delta);
}
function fuzzyfmla(f) {
  if (f.length == 1) return false;
  return true;
}
function _xlfn(f) {
  return f.replace(/_xlfn\./g, "");
}
function parseread1(blob) {
  blob.l += 1;
  return;
}
function parse_ColRelU(blob, length) {
  var c2 = blob.read_shift(2);
  return [c2 & 16383, c2 >> 14 & 1, c2 >> 15 & 1];
}
function parse_RgceArea(blob, length, opts) {
  var w = 2;
  if (opts) {
    if (opts.biff >= 2 && opts.biff <= 5) return parse_RgceArea_BIFF2(blob);
    else if (opts.biff == 12) w = 4;
  }
  var r = blob.read_shift(w), R = blob.read_shift(w);
  var c2 = parse_ColRelU(blob);
  var C2 = parse_ColRelU(blob);
  return { s: { r, c: c2[0], cRel: c2[1], rRel: c2[2] }, e: { r: R, c: C2[0], cRel: C2[1], rRel: C2[2] } };
}
function parse_RgceArea_BIFF2(blob) {
  var r = parse_ColRelU(blob), R = parse_ColRelU(blob);
  var c2 = blob.read_shift(1);
  var C2 = blob.read_shift(1);
  return { s: { r: r[0], c: c2, cRel: r[1], rRel: r[2] }, e: { r: R[0], c: C2, cRel: R[1], rRel: R[2] } };
}
function parse_RgceAreaRel(blob, length, opts) {
  if (opts.biff < 8) return parse_RgceArea_BIFF2(blob);
  var r = blob.read_shift(opts.biff == 12 ? 4 : 2), R = blob.read_shift(opts.biff == 12 ? 4 : 2);
  var c2 = parse_ColRelU(blob);
  var C2 = parse_ColRelU(blob);
  return { s: { r, c: c2[0], cRel: c2[1], rRel: c2[2] }, e: { r: R, c: C2[0], cRel: C2[1], rRel: C2[2] } };
}
function parse_RgceLoc(blob, length, opts) {
  if (opts && opts.biff >= 2 && opts.biff <= 5) return parse_RgceLoc_BIFF2(blob);
  var r = blob.read_shift(opts && opts.biff == 12 ? 4 : 2);
  var c2 = parse_ColRelU(blob);
  return { r, c: c2[0], cRel: c2[1], rRel: c2[2] };
}
function parse_RgceLoc_BIFF2(blob) {
  var r = parse_ColRelU(blob);
  var c2 = blob.read_shift(1);
  return { r: r[0], c: c2, cRel: r[1], rRel: r[2] };
}
function parse_RgceElfLoc(blob) {
  var r = blob.read_shift(2);
  var c2 = blob.read_shift(2);
  return { r, c: c2 & 255, fQuoted: !!(c2 & 16384), cRel: c2 >> 15, rRel: c2 >> 15 };
}
function parse_RgceLocRel(blob, length, opts) {
  var biff = opts && opts.biff ? opts.biff : 8;
  if (biff >= 2 && biff <= 5) return parse_RgceLocRel_BIFF2(blob);
  var r = blob.read_shift(biff >= 12 ? 4 : 2);
  var cl = blob.read_shift(2);
  var cRel = (cl & 16384) >> 14, rRel = (cl & 32768) >> 15;
  cl &= 16383;
  if (rRel == 1) while (r > 524287) r -= 1048576;
  if (cRel == 1) while (cl > 8191) cl = cl - 16384;
  return { r, c: cl, cRel, rRel };
}
function parse_RgceLocRel_BIFF2(blob) {
  var rl = blob.read_shift(2);
  var c2 = blob.read_shift(1);
  var rRel = (rl & 32768) >> 15, cRel = (rl & 16384) >> 14;
  rl &= 16383;
  if (rRel == 1 && rl >= 8192) rl = rl - 16384;
  if (cRel == 1 && c2 >= 128) c2 = c2 - 256;
  return { r: rl, c: c2, cRel, rRel };
}
function parse_PtgArea(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var area = parse_RgceArea(blob, opts.biff >= 2 && opts.biff <= 5 ? 6 : 8, opts);
  return [type, area];
}
function parse_PtgArea3d(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var ixti = blob.read_shift(2, "i");
  var w = 8;
  if (opts) switch (opts.biff) {
    case 5:
      blob.l += 12;
      w = 6;
      break;
    case 12:
      w = 12;
      break;
  }
  var area = parse_RgceArea(blob, w, opts);
  return [type, ixti, area];
}
function parse_PtgAreaErr(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  blob.l += opts && opts.biff > 8 ? 12 : opts.biff < 8 ? 6 : 8;
  return [type];
}
function parse_PtgAreaErr3d(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var ixti = blob.read_shift(2);
  var w = 8;
  if (opts) switch (opts.biff) {
    case 5:
      blob.l += 12;
      w = 6;
      break;
    case 12:
      w = 12;
      break;
  }
  blob.l += w;
  return [type, ixti];
}
function parse_PtgAreaN(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var area = parse_RgceAreaRel(blob, length - 1, opts);
  return [type, area];
}
function parse_PtgArray(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  blob.l += opts.biff == 2 ? 6 : opts.biff == 12 ? 14 : 7;
  return [type];
}
function parse_PtgAttrBaxcel(blob) {
  var bitSemi = blob[blob.l + 1] & 1;
  var bitBaxcel = 1;
  blob.l += 4;
  return [bitSemi, bitBaxcel];
}
function parse_PtgAttrChoose(blob, length, opts) {
  blob.l += 2;
  var offset = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  var o = [];
  for (var i = 0; i <= offset; ++i) o.push(blob.read_shift(opts && opts.biff == 2 ? 1 : 2));
  return o;
}
function parse_PtgAttrGoto(blob, length, opts) {
  var bitGoto = blob[blob.l + 1] & 255 ? 1 : 0;
  blob.l += 2;
  return [bitGoto, blob.read_shift(opts && opts.biff == 2 ? 1 : 2)];
}
function parse_PtgAttrIf(blob, length, opts) {
  var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
  blob.l += 2;
  return [bitIf, blob.read_shift(opts && opts.biff == 2 ? 1 : 2)];
}
function parse_PtgAttrIfError(blob) {
  var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
  blob.l += 2;
  return [bitIf, blob.read_shift(2)];
}
function parse_PtgAttrSemi(blob, length, opts) {
  var bitSemi = blob[blob.l + 1] & 255 ? 1 : 0;
  blob.l += opts && opts.biff == 2 ? 3 : 4;
  return [bitSemi];
}
function parse_PtgAttrSpaceType(blob) {
  var type = blob.read_shift(1), cch = blob.read_shift(1);
  return [type, cch];
}
function parse_PtgAttrSpace(blob) {
  blob.read_shift(2);
  return parse_PtgAttrSpaceType(blob);
}
function parse_PtgAttrSpaceSemi(blob) {
  blob.read_shift(2);
  return parse_PtgAttrSpaceType(blob);
}
function parse_PtgRef(blob, length, opts) {
  var type = (blob[blob.l] & 96) >> 5;
  blob.l += 1;
  var loc = parse_RgceLoc(blob, 0, opts);
  return [type, loc];
}
function parse_PtgRefN(blob, length, opts) {
  var type = (blob[blob.l] & 96) >> 5;
  blob.l += 1;
  var loc = parse_RgceLocRel(blob, 0, opts);
  return [type, loc];
}
function parse_PtgRef3d(blob, length, opts) {
  var type = (blob[blob.l] & 96) >> 5;
  blob.l += 1;
  var ixti = blob.read_shift(2);
  if (opts && opts.biff == 5) blob.l += 12;
  var loc = parse_RgceLoc(blob, 0, opts);
  return [type, ixti, loc];
}
function parse_PtgFunc(blob, length, opts) {
  var type = (blob[blob.l] & 96) >> 5;
  blob.l += 1;
  var iftab = blob.read_shift(opts && opts.biff <= 3 ? 1 : 2);
  return [FtabArgc[iftab], Ftab[iftab], type];
}
function parse_PtgFuncVar(blob, length, opts) {
  var type = blob[blob.l++];
  var cparams = blob.read_shift(1), tab = opts && opts.biff <= 3 ? [type == 88 ? -1 : 0, blob.read_shift(1)] : parsetab(blob);
  return [cparams, (tab[0] === 0 ? Ftab : Cetab)[tab[1]]];
}
function parsetab(blob) {
  return [blob[blob.l + 1] >> 7, blob.read_shift(2) & 32767];
}
function parse_PtgAttrSum(blob, length, opts) {
  blob.l += opts && opts.biff == 2 ? 3 : 4;
  return;
}
function parse_PtgExp(blob, length, opts) {
  blob.l++;
  if (opts && opts.biff == 12) return [blob.read_shift(4, "i"), 0];
  var row = blob.read_shift(2);
  var col = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  return [row, col];
}
function parse_PtgErr(blob) {
  blob.l++;
  return BErr[blob.read_shift(1)];
}
function parse_PtgInt(blob) {
  blob.l++;
  return blob.read_shift(2);
}
function parse_PtgBool(blob) {
  blob.l++;
  return blob.read_shift(1) !== 0;
}
function parse_PtgNum(blob) {
  blob.l++;
  return parse_Xnum(blob);
}
function parse_PtgStr(blob, length, opts) {
  blob.l++;
  return parse_ShortXLUnicodeString(blob, length - 1, opts);
}
function parse_SerAr(blob, biff) {
  var val = [blob.read_shift(1)];
  if (biff == 12) switch (val[0]) {
    case 2:
      val[0] = 4;
      break;
    case 4:
      val[0] = 16;
      break;
    case 0:
      val[0] = 1;
      break;
    case 1:
      val[0] = 2;
      break;
  }
  switch (val[0]) {
    case 4:
      val[1] = parsebool(blob, 1) ? "TRUE" : "FALSE";
      if (biff != 12) blob.l += 7;
      break;
    case 37:
    case 16:
      val[1] = BErr[blob[blob.l]];
      blob.l += biff == 12 ? 4 : 8;
      break;
    case 0:
      blob.l += 8;
      break;
    case 1:
      val[1] = parse_Xnum(blob);
      break;
    case 2:
      val[1] = parse_XLUnicodeString2(blob, 0, { biff: biff > 0 && biff < 8 ? 2 : biff });
      break;
    default:
      throw new Error("Bad SerAr: " + val[0]);
  }
  return val;
}
function parse_PtgExtraMem(blob, cce, opts) {
  var count = blob.read_shift(opts.biff == 12 ? 4 : 2);
  var out = [];
  for (var i = 0; i != count; ++i) out.push((opts.biff == 12 ? parse_UncheckedRfX : parse_Ref8U)(blob));
  return out;
}
function parse_PtgExtraArray(blob, length, opts) {
  var rows = 0, cols = 0;
  if (opts.biff == 12) {
    rows = blob.read_shift(4);
    cols = blob.read_shift(4);
  } else {
    cols = 1 + blob.read_shift(1);
    rows = 1 + blob.read_shift(2);
  }
  if (opts.biff >= 2 && opts.biff < 8) {
    --rows;
    if (--cols == 0) cols = 256;
  }
  for (var i = 0, o = []; i != rows && (o[i] = []); ++i)
    for (var j = 0; j != cols; ++j) o[i][j] = parse_SerAr(blob, opts.biff);
  return o;
}
function parse_PtgName(blob, length, opts) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var w = !opts || opts.biff >= 8 ? 4 : 2;
  var nameindex = blob.read_shift(w);
  switch (opts.biff) {
    case 2:
      blob.l += 5;
      break;
    case 3:
    case 4:
      blob.l += 8;
      break;
    case 5:
      blob.l += 12;
      break;
  }
  return [type, 0, nameindex];
}
function parse_PtgNameX(blob, length, opts) {
  if (opts.biff == 5) return parse_PtgNameX_BIFF5(blob);
  var type = blob.read_shift(1) >>> 5 & 3;
  var ixti = blob.read_shift(2);
  var nameindex = blob.read_shift(4);
  return [type, ixti, nameindex];
}
function parse_PtgNameX_BIFF5(blob) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var ixti = blob.read_shift(2, "i");
  blob.l += 8;
  var nameindex = blob.read_shift(2);
  blob.l += 12;
  return [type, ixti, nameindex];
}
function parse_PtgMemArea(blob, length, opts) {
  var type = blob.read_shift(1) >>> 5 & 3;
  blob.l += opts && opts.biff == 2 ? 3 : 4;
  var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  return [type, cce];
}
function parse_PtgMemFunc(blob, length, opts) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  return [type, cce];
}
function parse_PtgRefErr(blob, length, opts) {
  var type = blob.read_shift(1) >>> 5 & 3;
  blob.l += 4;
  if (opts.biff < 8) blob.l--;
  if (opts.biff == 12) blob.l += 2;
  return [type];
}
function parse_PtgRefErr3d(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var ixti = blob.read_shift(2);
  var w = 4;
  if (opts) switch (opts.biff) {
    case 5:
      w = 15;
      break;
    case 12:
      w = 6;
      break;
  }
  blob.l += w;
  return [type, ixti];
}
var parse_PtgMemErr = parsenoop;
var parse_PtgMemNoMem = parsenoop;
var parse_PtgTbl = parsenoop;
function parse_PtgElfLoc(blob, length, opts) {
  blob.l += 2;
  return [parse_RgceElfLoc(blob)];
}
function parse_PtgElfNoop(blob) {
  blob.l += 6;
  return [];
}
var parse_PtgElfCol = parse_PtgElfLoc;
var parse_PtgElfColS = parse_PtgElfNoop;
var parse_PtgElfColSV = parse_PtgElfNoop;
var parse_PtgElfColV = parse_PtgElfLoc;
function parse_PtgElfLel(blob) {
  blob.l += 2;
  return [parseuint16(blob), blob.read_shift(2) & 1];
}
var parse_PtgElfRadical = parse_PtgElfLoc;
var parse_PtgElfRadicalLel = parse_PtgElfLel;
var parse_PtgElfRadicalS = parse_PtgElfNoop;
var parse_PtgElfRw = parse_PtgElfLoc;
var parse_PtgElfRwV = parse_PtgElfLoc;
var PtgListRT = [
  "Data",
  "All",
  "Headers",
  "??",
  "?Data2",
  "??",
  "?DataHeaders",
  "??",
  "Totals",
  "??",
  "??",
  "??",
  "?DataTotals",
  "??",
  "??",
  "??",
  "?Current"
];
function parse_PtgList(blob) {
  blob.l += 2;
  var ixti = blob.read_shift(2);
  var flags = blob.read_shift(2);
  var idx = blob.read_shift(4);
  var c2 = blob.read_shift(2);
  var C2 = blob.read_shift(2);
  var rt = PtgListRT[flags >> 2 & 31];
  return { ixti, coltype: flags & 3, rt, idx, c: c2, C: C2 };
}
function parse_PtgSxName(blob) {
  blob.l += 2;
  return [blob.read_shift(4)];
}
function parse_PtgSheet(blob, length, opts) {
  blob.l += 5;
  blob.l += 2;
  blob.l += opts.biff == 2 ? 1 : 4;
  return ["PTGSHEET"];
}
function parse_PtgEndSheet(blob, length, opts) {
  blob.l += opts.biff == 2 ? 4 : 5;
  return ["PTGENDSHEET"];
}
function parse_PtgMemAreaN(blob) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var cce = blob.read_shift(2);
  return [type, cce];
}
function parse_PtgMemNoMemN(blob) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var cce = blob.read_shift(2);
  return [type, cce];
}
function parse_PtgAttrNoop(blob) {
  blob.l += 4;
  return [0, 0];
}
var PtgTypes = {
  1: { n: "PtgExp", f: parse_PtgExp },
  2: { n: "PtgTbl", f: parse_PtgTbl },
  3: { n: "PtgAdd", f: parseread1 },
  4: { n: "PtgSub", f: parseread1 },
  5: { n: "PtgMul", f: parseread1 },
  6: { n: "PtgDiv", f: parseread1 },
  7: { n: "PtgPower", f: parseread1 },
  8: { n: "PtgConcat", f: parseread1 },
  9: { n: "PtgLt", f: parseread1 },
  10: { n: "PtgLe", f: parseread1 },
  11: { n: "PtgEq", f: parseread1 },
  12: { n: "PtgGe", f: parseread1 },
  13: { n: "PtgGt", f: parseread1 },
  14: { n: "PtgNe", f: parseread1 },
  15: { n: "PtgIsect", f: parseread1 },
  16: { n: "PtgUnion", f: parseread1 },
  17: { n: "PtgRange", f: parseread1 },
  18: { n: "PtgUplus", f: parseread1 },
  19: { n: "PtgUminus", f: parseread1 },
  20: { n: "PtgPercent", f: parseread1 },
  21: { n: "PtgParen", f: parseread1 },
  22: { n: "PtgMissArg", f: parseread1 },
  23: { n: "PtgStr", f: parse_PtgStr },
  26: { n: "PtgSheet", f: parse_PtgSheet },
  27: { n: "PtgEndSheet", f: parse_PtgEndSheet },
  28: { n: "PtgErr", f: parse_PtgErr },
  29: { n: "PtgBool", f: parse_PtgBool },
  30: { n: "PtgInt", f: parse_PtgInt },
  31: { n: "PtgNum", f: parse_PtgNum },
  32: { n: "PtgArray", f: parse_PtgArray },
  33: { n: "PtgFunc", f: parse_PtgFunc },
  34: { n: "PtgFuncVar", f: parse_PtgFuncVar },
  35: { n: "PtgName", f: parse_PtgName },
  36: { n: "PtgRef", f: parse_PtgRef },
  37: { n: "PtgArea", f: parse_PtgArea },
  38: { n: "PtgMemArea", f: parse_PtgMemArea },
  39: { n: "PtgMemErr", f: parse_PtgMemErr },
  40: { n: "PtgMemNoMem", f: parse_PtgMemNoMem },
  41: { n: "PtgMemFunc", f: parse_PtgMemFunc },
  42: { n: "PtgRefErr", f: parse_PtgRefErr },
  43: { n: "PtgAreaErr", f: parse_PtgAreaErr },
  44: { n: "PtgRefN", f: parse_PtgRefN },
  45: { n: "PtgAreaN", f: parse_PtgAreaN },
  46: { n: "PtgMemAreaN", f: parse_PtgMemAreaN },
  47: { n: "PtgMemNoMemN", f: parse_PtgMemNoMemN },
  57: { n: "PtgNameX", f: parse_PtgNameX },
  58: { n: "PtgRef3d", f: parse_PtgRef3d },
  59: { n: "PtgArea3d", f: parse_PtgArea3d },
  60: { n: "PtgRefErr3d", f: parse_PtgRefErr3d },
  61: { n: "PtgAreaErr3d", f: parse_PtgAreaErr3d },
  255: {}
};
var PtgDupes = {
  64: 32,
  96: 32,
  65: 33,
  97: 33,
  66: 34,
  98: 34,
  67: 35,
  99: 35,
  68: 36,
  100: 36,
  69: 37,
  101: 37,
  70: 38,
  102: 38,
  71: 39,
  103: 39,
  72: 40,
  104: 40,
  73: 41,
  105: 41,
  74: 42,
  106: 42,
  75: 43,
  107: 43,
  76: 44,
  108: 44,
  77: 45,
  109: 45,
  78: 46,
  110: 46,
  79: 47,
  111: 47,
  88: 34,
  120: 34,
  89: 57,
  121: 57,
  90: 58,
  122: 58,
  91: 59,
  123: 59,
  92: 60,
  124: 60,
  93: 61,
  125: 61
};
var Ptg18 = {
  1: { n: "PtgElfLel", f: parse_PtgElfLel },
  2: { n: "PtgElfRw", f: parse_PtgElfRw },
  3: { n: "PtgElfCol", f: parse_PtgElfCol },
  6: { n: "PtgElfRwV", f: parse_PtgElfRwV },
  7: { n: "PtgElfColV", f: parse_PtgElfColV },
  10: { n: "PtgElfRadical", f: parse_PtgElfRadical },
  11: { n: "PtgElfRadicalS", f: parse_PtgElfRadicalS },
  13: { n: "PtgElfColS", f: parse_PtgElfColS },
  15: { n: "PtgElfColSV", f: parse_PtgElfColSV },
  16: { n: "PtgElfRadicalLel", f: parse_PtgElfRadicalLel },
  25: { n: "PtgList", f: parse_PtgList },
  29: { n: "PtgSxName", f: parse_PtgSxName },
  255: {}
};
var Ptg19 = {
  0: { n: "PtgAttrNoop", f: parse_PtgAttrNoop },
  1: { n: "PtgAttrSemi", f: parse_PtgAttrSemi },
  2: { n: "PtgAttrIf", f: parse_PtgAttrIf },
  4: { n: "PtgAttrChoose", f: parse_PtgAttrChoose },
  8: { n: "PtgAttrGoto", f: parse_PtgAttrGoto },
  16: { n: "PtgAttrSum", f: parse_PtgAttrSum },
  32: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
  33: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
  64: { n: "PtgAttrSpace", f: parse_PtgAttrSpace },
  65: { n: "PtgAttrSpaceSemi", f: parse_PtgAttrSpaceSemi },
  128: { n: "PtgAttrIfError", f: parse_PtgAttrIfError },
  255: {}
};
function parse_RgbExtra(blob, length, rgce, opts) {
  if (opts.biff < 8) return parsenoop(blob, length);
  var target = blob.l + length;
  var o = [];
  for (var i = 0; i !== rgce.length; ++i) {
    switch (rgce[i][0]) {
      case "PtgArray":
        rgce[i][1] = parse_PtgExtraArray(blob, 0, opts);
        o.push(rgce[i][1]);
        break;
      case "PtgMemArea":
        rgce[i][2] = parse_PtgExtraMem(blob, rgce[i][1], opts);
        o.push(rgce[i][2]);
        break;
      case "PtgExp":
        if (opts && opts.biff == 12) {
          rgce[i][1][1] = blob.read_shift(4);
          o.push(rgce[i][1]);
        }
        break;
      case "PtgList":
      case "PtgElfRadicalS":
      case "PtgElfColS":
      case "PtgElfColSV":
        throw "Unsupported " + rgce[i][0];
    }
  }
  length = target - blob.l;
  if (length !== 0) o.push(parsenoop(blob, length));
  return o;
}
function parse_Rgce(blob, length, opts) {
  var target = blob.l + length;
  var R, id, ptgs = [];
  while (target != blob.l) {
    length = target - blob.l;
    id = blob[blob.l];
    R = PtgTypes[id] || PtgTypes[PtgDupes[id]];
    if (id === 24 || id === 25) R = (id === 24 ? Ptg18 : Ptg19)[blob[blob.l + 1]];
    if (!R || !R.f) {
      parsenoop(blob, length);
    } else {
      ptgs.push([R.n, R.f(blob, length, opts)]);
    }
  }
  return ptgs;
}
function stringify_array(f) {
  var o = [];
  for (var i = 0; i < f.length; ++i) {
    var x = f[i], r = [];
    for (var j = 0; j < x.length; ++j) {
      var y = x[j];
      if (y) switch (y[0]) {
        case 2:
          r.push('"' + y[1].replace(/"/g, '""') + '"');
          break;
        default:
          r.push(y[1]);
      }
      else r.push("");
    }
    o.push(r.join(","));
  }
  return o.join(";");
}
var PtgBinOp = {
  PtgAdd: "+",
  PtgConcat: "&",
  PtgDiv: "/",
  PtgEq: "=",
  PtgGe: ">=",
  PtgGt: ">",
  PtgLe: "<=",
  PtgLt: "<",
  PtgMul: "*",
  PtgNe: "<>",
  PtgPower: "^",
  PtgSub: "-"
};
function make_3d_range(start, end) {
  var s = start.lastIndexOf("!"), e = end.lastIndexOf("!");
  if (s == -1 && e == -1) return start + ":" + end;
  if (s > 0 && e > 0 && start.slice(0, s).toLowerCase() == end.slice(0, e).toLowerCase()) return start + ":" + end.slice(e + 1);
  console.error("Cannot hydrate range", start, end);
  return start + ":" + end;
}
function get_ixti_raw(supbooks, ixti, opts) {
  if (!supbooks) return "SH33TJSERR0";
  if (opts.biff > 8 && (!supbooks.XTI || !supbooks.XTI[ixti])) return supbooks.SheetNames[ixti];
  if (!supbooks.XTI) return "SH33TJSERR6";
  var XTI = supbooks.XTI[ixti];
  if (opts.biff < 8) {
    if (ixti > 1e4) ixti -= 65536;
    if (ixti < 0) ixti = -ixti;
    return ixti == 0 ? "" : supbooks.XTI[ixti - 1];
  }
  if (!XTI) return "SH33TJSERR1";
  var o = "";
  if (opts.biff > 8) switch (supbooks[XTI[0]][0]) {
    case 357:
      o = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]];
      return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];
    case 358:
      if (opts.SID != null) return supbooks.SheetNames[opts.SID];
      return "SH33TJSSAME" + supbooks[XTI[0]][0];
    case 355:
    default:
      return "SH33TJSSRC" + supbooks[XTI[0]][0];
  }
  switch (supbooks[XTI[0]][0][0]) {
    case 1025:
      o = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]] || "SH33TJSERR3";
      return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];
    case 14849:
      return supbooks[XTI[0]].slice(1).map(function(name) {
        return name.Name;
      }).join(";;");
    default:
      if (!supbooks[XTI[0]][0][3]) return "SH33TJSERR2";
      o = XTI[1] == -1 ? "#REF" : supbooks[XTI[0]][0][3][XTI[1]] || "SH33TJSERR4";
      return XTI[1] == XTI[2] ? o : o + ":" + supbooks[XTI[0]][0][3][XTI[2]];
  }
}
function get_ixti(supbooks, ixti, opts) {
  var ixtiraw = get_ixti_raw(supbooks, ixti, opts);
  return ixtiraw == "#REF" ? ixtiraw : formula_quote_sheet_name(ixtiraw, opts);
}
function stringify_formula(formula, range, cell, supbooks, opts) {
  var biff = opts && opts.biff || 8;
  var _range = (
    /*range != null ? range :*/
    { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } }
  );
  var stack2 = [], e1, e2, c2, ixti = 0, nameidx = 0, r, sname = "";
  if (!formula[0] || !formula[0][0]) return "";
  var last_sp = -1, sp = "";
  for (var ff = 0, fflen = formula[0].length; ff < fflen; ++ff) {
    var f = formula[0][ff];
    switch (f[0]) {
      case "PtgUminus":
        stack2.push("-" + stack2.pop());
        break;
      case "PtgUplus":
        stack2.push("+" + stack2.pop());
        break;
      case "PtgPercent":
        stack2.push(stack2.pop() + "%");
        break;
      case "PtgAdd":
      case "PtgConcat":
      case "PtgDiv":
      case "PtgEq":
      case "PtgGe":
      case "PtgGt":
      case "PtgLe":
      case "PtgLt":
      case "PtgMul":
      case "PtgNe":
      case "PtgPower":
      case "PtgSub":
        e1 = stack2.pop();
        e2 = stack2.pop();
        if (last_sp >= 0) {
          switch (formula[0][last_sp][1][0]) {
            case 0:
              sp = fill(" ", formula[0][last_sp][1][1]);
              break;
            case 1:
              sp = fill("\r", formula[0][last_sp][1][1]);
              break;
            default:
              sp = "";
              if (opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
          }
          e2 = e2 + sp;
          last_sp = -1;
        }
        stack2.push(e2 + PtgBinOp[f[0]] + e1);
        break;
      case "PtgIsect":
        e1 = stack2.pop();
        e2 = stack2.pop();
        stack2.push(e2 + " " + e1);
        break;
      case "PtgUnion":
        e1 = stack2.pop();
        e2 = stack2.pop();
        stack2.push(e2 + "," + e1);
        break;
      case "PtgRange":
        e1 = stack2.pop();
        e2 = stack2.pop();
        stack2.push(make_3d_range(e2, e1));
        break;
      case "PtgAttrChoose":
        break;
      case "PtgAttrGoto":
        break;
      case "PtgAttrIf":
        break;
      case "PtgAttrIfError":
        break;
      case "PtgRef":
        c2 = shift_cell_xls(f[1][1], _range, opts);
        stack2.push(encode_cell_xls(c2, biff));
        break;
      case "PtgRefN":
        c2 = cell ? shift_cell_xls(f[1][1], cell, opts) : f[1][1];
        stack2.push(encode_cell_xls(c2, biff));
        break;
      case "PtgRef3d":
        ixti = /*::Number(*/
        f[1][1];
        c2 = shift_cell_xls(f[1][2], _range, opts);
        sname = get_ixti(supbooks, ixti, opts);
        stack2.push(sname + "!" + encode_cell_xls(c2, biff));
        break;
      case "PtgFunc":
      case "PtgFuncVar":
        var argc = f[1][0], func = f[1][1];
        if (!argc) argc = 0;
        argc &= 127;
        var args = argc == 0 ? [] : stack2.slice(-argc);
        stack2.length -= argc;
        if (func === "User") func = args.shift();
        stack2.push(func + "(" + args.join(",") + ")");
        break;
      case "PtgBool":
        stack2.push(f[1] ? "TRUE" : "FALSE");
        break;
      case "PtgInt":
        stack2.push(
          /*::String(*/
          f[1]
          /*::)*/
        );
        break;
      case "PtgNum":
        stack2.push(String(f[1]));
        break;
      case "PtgStr":
        stack2.push('"' + f[1].replace(/"/g, '""') + '"');
        break;
      case "PtgErr":
        stack2.push(
          /*::String(*/
          f[1]
          /*::)*/
        );
        break;
      case "PtgAreaN":
        r = shift_range_xls(f[1][1], cell ? { s: cell } : _range, opts);
        stack2.push(encode_range_xls(r, opts));
        break;
      case "PtgArea":
        r = shift_range_xls(f[1][1], _range, opts);
        stack2.push(encode_range_xls(r, opts));
        break;
      case "PtgArea3d":
        ixti = /*::Number(*/
        f[1][1];
        r = f[1][2];
        sname = get_ixti(supbooks, ixti, opts);
        stack2.push(sname + "!" + encode_range_xls(r, opts));
        break;
      case "PtgAttrSum":
        stack2.push("SUM(" + stack2.pop() + ")");
        break;
      case "PtgAttrBaxcel":
      case "PtgAttrSemi":
        break;
      case "PtgName":
        nameidx = f[1][2];
        var lbl = (supbooks.names || [])[nameidx - 1] || (supbooks[0] || [])[nameidx];
        var name = lbl ? lbl.Name : "SH33TJSNAME" + String(nameidx);
        if (name && name.slice(0, 6) == "_xlfn." && !opts.xlfn) name = name.slice(6);
        stack2.push(name);
        break;
      case "PtgNameX":
        var bookidx = f[1][1];
        nameidx = f[1][2];
        var externbook;
        if (opts.biff <= 5) {
          if (bookidx < 0) bookidx = -bookidx;
          if (supbooks[bookidx]) externbook = supbooks[bookidx][nameidx];
        } else {
          var o = "";
          if (((supbooks[bookidx] || [])[0] || [])[0] == 14849) ;
          else if (((supbooks[bookidx] || [])[0] || [])[0] == 1025) {
            if (supbooks[bookidx][nameidx] && supbooks[bookidx][nameidx].itab > 0) {
              o = supbooks.SheetNames[supbooks[bookidx][nameidx].itab - 1] + "!";
            }
          } else o = supbooks.SheetNames[nameidx - 1] + "!";
          if (supbooks[bookidx] && supbooks[bookidx][nameidx]) o += supbooks[bookidx][nameidx].Name;
          else if (supbooks[0] && supbooks[0][nameidx]) o += supbooks[0][nameidx].Name;
          else {
            var ixtidata = (get_ixti_raw(supbooks, bookidx, opts) || "").split(";;");
            if (ixtidata[nameidx - 1]) o = ixtidata[nameidx - 1];
            else o += "SH33TJSERRX";
          }
          stack2.push(o);
          break;
        }
        if (!externbook) externbook = { Name: "SH33TJSERRY" };
        stack2.push(externbook.Name);
        break;
      case "PtgParen":
        var lp = "(", rp = ")";
        if (last_sp >= 0) {
          sp = "";
          switch (formula[0][last_sp][1][0]) {
            case 2:
              lp = fill(" ", formula[0][last_sp][1][1]) + lp;
              break;
            case 3:
              lp = fill("\r", formula[0][last_sp][1][1]) + lp;
              break;
            case 4:
              rp = fill(" ", formula[0][last_sp][1][1]) + rp;
              break;
            case 5:
              rp = fill("\r", formula[0][last_sp][1][1]) + rp;
              break;
            default:
              if (opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
          }
          last_sp = -1;
        }
        stack2.push(lp + stack2.pop() + rp);
        break;
      case "PtgRefErr":
        stack2.push("#REF!");
        break;
      case "PtgRefErr3d":
        stack2.push("#REF!");
        break;
      case "PtgExp":
        c2 = { c: f[1][1], r: f[1][0] };
        var q = { c: cell.c, r: cell.r };
        if (supbooks.sharedf[encode_cell(c2)]) {
          var parsedf = supbooks.sharedf[encode_cell(c2)];
          stack2.push(stringify_formula(parsedf, _range, q, supbooks, opts));
        } else {
          var fnd = false;
          for (e1 = 0; e1 != supbooks.arrayf.length; ++e1) {
            e2 = supbooks.arrayf[e1];
            if (c2.c < e2[0].s.c || c2.c > e2[0].e.c) continue;
            if (c2.r < e2[0].s.r || c2.r > e2[0].e.r) continue;
            stack2.push(stringify_formula(e2[1], _range, q, supbooks, opts));
            fnd = true;
            break;
          }
          if (!fnd) stack2.push(
            /*::String(*/
            f[1]
            /*::)*/
          );
        }
        break;
      case "PtgArray":
        stack2.push("{" + stringify_array(
          /*::(*/
          f[1]
          /*:: :any)*/
        ) + "}");
        break;
      case "PtgMemArea":
        break;
      case "PtgAttrSpace":
      case "PtgAttrSpaceSemi":
        last_sp = ff;
        break;
      case "PtgTbl":
        break;
      case "PtgMemErr":
        break;
      case "PtgMissArg":
        stack2.push("");
        break;
      case "PtgAreaErr":
        stack2.push("#REF!");
        break;
      case "PtgAreaErr3d":
        stack2.push("#REF!");
        break;
      case "PtgList":
        stack2.push("Table" + f[1].idx + "[#" + f[1].rt + "]");
        break;
      case "PtgMemAreaN":
      case "PtgMemNoMemN":
      case "PtgAttrNoop":
      case "PtgSheet":
      case "PtgEndSheet":
        break;
      case "PtgMemFunc":
        break;
      case "PtgMemNoMem":
        break;
      case "PtgElfCol":
      case "PtgElfColS":
      case "PtgElfColSV":
      case "PtgElfColV":
      case "PtgElfLel":
      case "PtgElfRadical":
      case "PtgElfRadicalLel":
      case "PtgElfRadicalS":
      case "PtgElfRw":
      case "PtgElfRwV":
        throw new Error("Unsupported ELFs");
      case "PtgSxName":
        throw new Error("Unrecognized Formula Token: " + String(f));
      default:
        throw new Error("Unrecognized Formula Token: " + String(f));
    }
    var PtgNonDisp = ["PtgAttrSpace", "PtgAttrSpaceSemi", "PtgAttrGoto"];
    if (opts.biff != 3) {
      if (last_sp >= 0 && PtgNonDisp.indexOf(formula[0][ff][0]) == -1) {
        f = formula[0][last_sp];
        var _left = true;
        switch (f[1][0]) {
          case 4:
            _left = false;
          case 0:
            sp = fill(" ", f[1][1]);
            break;
          case 5:
            _left = false;
          case 1:
            sp = fill("\r", f[1][1]);
            break;
          default:
            sp = "";
            if (opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + f[1][0]);
        }
        stack2.push((_left ? sp : "") + stack2.pop() + (_left ? "" : sp));
        last_sp = -1;
      }
    }
  }
  if (stack2.length > 1 && opts.WTF) throw new Error("bad formula stack");
  if (stack2[0] == "TRUE") return true;
  if (stack2[0] == "FALSE") return false;
  return stack2[0];
}
function parse_ArrayParsedFormula(blob, length, opts) {
  var target = blob.l + length, len = opts.biff == 2 ? 1 : 2;
  var rgcb, cce = blob.read_shift(len);
  if (cce == 65535) return [[], parsenoop(blob, length - 2)];
  var rgce = parse_Rgce(blob, cce, opts);
  if (length !== cce + len) rgcb = parse_RgbExtra(blob, length - cce - len, rgce, opts);
  blob.l = target;
  return [rgce, rgcb];
}
function parse_XLSCellParsedFormula(blob, length, opts) {
  var target = blob.l + length, len = opts.biff == 2 ? 1 : 2;
  var rgcb, cce = blob.read_shift(len);
  if (cce == 65535) return [[], parsenoop(blob, length - 2)];
  var rgce = parse_Rgce(blob, cce, opts);
  if (length !== cce + len) rgcb = parse_RgbExtra(blob, length - cce - len, rgce, opts);
  blob.l = target;
  return [rgce, rgcb];
}
function parse_NameParsedFormula(blob, length, opts, cce) {
  var target = blob.l + length;
  var rgce = parse_Rgce(blob, cce, opts);
  var rgcb;
  if (target !== blob.l) rgcb = parse_RgbExtra(blob, target - blob.l, rgce, opts);
  return [rgce, rgcb];
}
function parse_SharedParsedFormula(blob, length, opts) {
  var target = blob.l + length;
  var rgcb, cce = blob.read_shift(2);
  var rgce = parse_Rgce(blob, cce, opts);
  if (cce == 65535) return [[], parsenoop(blob, length - 2)];
  if (length !== cce + 2) rgcb = parse_RgbExtra(blob, target - cce - 2, rgce, opts);
  return [rgce, rgcb];
}
function parse_FormulaValue(blob) {
  var b;
  if (__readUInt16LE(blob, blob.l + 6) !== 65535) return [parse_Xnum(blob), "n"];
  switch (blob[blob.l]) {
    case 0:
      blob.l += 8;
      return ["String", "s"];
    case 1:
      b = blob[blob.l + 2] === 1;
      blob.l += 8;
      return [b, "b"];
    case 2:
      b = blob[blob.l + 2];
      blob.l += 8;
      return [b, "e"];
    case 3:
      blob.l += 8;
      return ["", "s"];
  }
  return [];
}
function parse_Formula(blob, length, opts) {
  var end = blob.l + length;
  var cell = parse_XLSCell(blob, 6, opts);
  var val = parse_FormulaValue(blob);
  var flags = blob.read_shift(1);
  if (opts.biff != 2) {
    blob.read_shift(1);
    if (opts.biff >= 5) {
      blob.read_shift(4);
    }
  }
  var cbf = parse_XLSCellParsedFormula(blob, end - blob.l, opts);
  return { cell, val: val[0], formula: cbf, shared: flags >> 3 & 1, tt: val[1] };
}
function parse_XLSBParsedFormula(data, length, opts) {
  var cce = data.read_shift(4);
  var rgce = parse_Rgce(data, cce, opts);
  var cb = data.read_shift(4);
  var rgcb = cb > 0 ? parse_RgbExtra(data, cb, rgce, opts) : null;
  return [rgce, rgcb];
}
var parse_XLSBArrayParsedFormula = parse_XLSBParsedFormula;
var parse_XLSBCellParsedFormula = parse_XLSBParsedFormula;
var parse_XLSBNameParsedFormula = parse_XLSBParsedFormula;
var parse_XLSBSharedParsedFormula = parse_XLSBParsedFormula;
var Cetab = {
  0: "BEEP",
  1: "OPEN",
  2: "OPEN.LINKS",
  3: "CLOSE.ALL",
  4: "SAVE",
  5: "SAVE.AS",
  6: "FILE.DELETE",
  7: "PAGE.SETUP",
  8: "PRINT",
  9: "PRINTER.SETUP",
  10: "QUIT",
  11: "NEW.WINDOW",
  12: "ARRANGE.ALL",
  13: "WINDOW.SIZE",
  14: "WINDOW.MOVE",
  15: "FULL",
  16: "CLOSE",
  17: "RUN",
  22: "SET.PRINT.AREA",
  23: "SET.PRINT.TITLES",
  24: "SET.PAGE.BREAK",
  25: "REMOVE.PAGE.BREAK",
  26: "FONT",
  27: "DISPLAY",
  28: "PROTECT.DOCUMENT",
  29: "PRECISION",
  30: "A1.R1C1",
  31: "CALCULATE.NOW",
  32: "CALCULATION",
  34: "DATA.FIND",
  35: "EXTRACT",
  36: "DATA.DELETE",
  37: "SET.DATABASE",
  38: "SET.CRITERIA",
  39: "SORT",
  40: "DATA.SERIES",
  41: "TABLE",
  42: "FORMAT.NUMBER",
  43: "ALIGNMENT",
  44: "STYLE",
  45: "BORDER",
  46: "CELL.PROTECTION",
  47: "COLUMN.WIDTH",
  48: "UNDO",
  49: "CUT",
  50: "COPY",
  51: "PASTE",
  52: "CLEAR",
  53: "PASTE.SPECIAL",
  54: "EDIT.DELETE",
  55: "INSERT",
  56: "FILL.RIGHT",
  57: "FILL.DOWN",
  61: "DEFINE.NAME",
  62: "CREATE.NAMES",
  63: "FORMULA.GOTO",
  64: "FORMULA.FIND",
  65: "SELECT.LAST.CELL",
  66: "SHOW.ACTIVE.CELL",
  67: "GALLERY.AREA",
  68: "GALLERY.BAR",
  69: "GALLERY.COLUMN",
  70: "GALLERY.LINE",
  71: "GALLERY.PIE",
  72: "GALLERY.SCATTER",
  73: "COMBINATION",
  74: "PREFERRED",
  75: "ADD.OVERLAY",
  76: "GRIDLINES",
  77: "SET.PREFERRED",
  78: "AXES",
  79: "LEGEND",
  80: "ATTACH.TEXT",
  81: "ADD.ARROW",
  82: "SELECT.CHART",
  83: "SELECT.PLOT.AREA",
  84: "PATTERNS",
  85: "MAIN.CHART",
  86: "OVERLAY",
  87: "SCALE",
  88: "FORMAT.LEGEND",
  89: "FORMAT.TEXT",
  90: "EDIT.REPEAT",
  91: "PARSE",
  92: "JUSTIFY",
  93: "HIDE",
  94: "UNHIDE",
  95: "WORKSPACE",
  96: "FORMULA",
  97: "FORMULA.FILL",
  98: "FORMULA.ARRAY",
  99: "DATA.FIND.NEXT",
  100: "DATA.FIND.PREV",
  101: "FORMULA.FIND.NEXT",
  102: "FORMULA.FIND.PREV",
  103: "ACTIVATE",
  104: "ACTIVATE.NEXT",
  105: "ACTIVATE.PREV",
  106: "UNLOCKED.NEXT",
  107: "UNLOCKED.PREV",
  108: "COPY.PICTURE",
  109: "SELECT",
  110: "DELETE.NAME",
  111: "DELETE.FORMAT",
  112: "VLINE",
  113: "HLINE",
  114: "VPAGE",
  115: "HPAGE",
  116: "VSCROLL",
  117: "HSCROLL",
  118: "ALERT",
  119: "NEW",
  120: "CANCEL.COPY",
  121: "SHOW.CLIPBOARD",
  122: "MESSAGE",
  124: "PASTE.LINK",
  125: "APP.ACTIVATE",
  126: "DELETE.ARROW",
  127: "ROW.HEIGHT",
  128: "FORMAT.MOVE",
  129: "FORMAT.SIZE",
  130: "FORMULA.REPLACE",
  131: "SEND.KEYS",
  132: "SELECT.SPECIAL",
  133: "APPLY.NAMES",
  134: "REPLACE.FONT",
  135: "FREEZE.PANES",
  136: "SHOW.INFO",
  137: "SPLIT",
  138: "ON.WINDOW",
  139: "ON.DATA",
  140: "DISABLE.INPUT",
  142: "OUTLINE",
  143: "LIST.NAMES",
  144: "FILE.CLOSE",
  145: "SAVE.WORKBOOK",
  146: "DATA.FORM",
  147: "COPY.CHART",
  148: "ON.TIME",
  149: "WAIT",
  150: "FORMAT.FONT",
  151: "FILL.UP",
  152: "FILL.LEFT",
  153: "DELETE.OVERLAY",
  155: "SHORT.MENUS",
  159: "SET.UPDATE.STATUS",
  161: "COLOR.PALETTE",
  162: "DELETE.STYLE",
  163: "WINDOW.RESTORE",
  164: "WINDOW.MAXIMIZE",
  166: "CHANGE.LINK",
  167: "CALCULATE.DOCUMENT",
  168: "ON.KEY",
  169: "APP.RESTORE",
  170: "APP.MOVE",
  171: "APP.SIZE",
  172: "APP.MINIMIZE",
  173: "APP.MAXIMIZE",
  174: "BRING.TO.FRONT",
  175: "SEND.TO.BACK",
  185: "MAIN.CHART.TYPE",
  186: "OVERLAY.CHART.TYPE",
  187: "SELECT.END",
  188: "OPEN.MAIL",
  189: "SEND.MAIL",
  190: "STANDARD.FONT",
  191: "CONSOLIDATE",
  192: "SORT.SPECIAL",
  193: "GALLERY.3D.AREA",
  194: "GALLERY.3D.COLUMN",
  195: "GALLERY.3D.LINE",
  196: "GALLERY.3D.PIE",
  197: "VIEW.3D",
  198: "GOAL.SEEK",
  199: "WORKGROUP",
  200: "FILL.GROUP",
  201: "UPDATE.LINK",
  202: "PROMOTE",
  203: "DEMOTE",
  204: "SHOW.DETAIL",
  206: "UNGROUP",
  207: "OBJECT.PROPERTIES",
  208: "SAVE.NEW.OBJECT",
  209: "SHARE",
  210: "SHARE.NAME",
  211: "DUPLICATE",
  212: "APPLY.STYLE",
  213: "ASSIGN.TO.OBJECT",
  214: "OBJECT.PROTECTION",
  215: "HIDE.OBJECT",
  216: "SET.EXTRACT",
  217: "CREATE.PUBLISHER",
  218: "SUBSCRIBE.TO",
  219: "ATTRIBUTES",
  220: "SHOW.TOOLBAR",
  222: "PRINT.PREVIEW",
  223: "EDIT.COLOR",
  224: "SHOW.LEVELS",
  225: "FORMAT.MAIN",
  226: "FORMAT.OVERLAY",
  227: "ON.RECALC",
  228: "EDIT.SERIES",
  229: "DEFINE.STYLE",
  240: "LINE.PRINT",
  243: "ENTER.DATA",
  249: "GALLERY.RADAR",
  250: "MERGE.STYLES",
  251: "EDITION.OPTIONS",
  252: "PASTE.PICTURE",
  253: "PASTE.PICTURE.LINK",
  254: "SPELLING",
  256: "ZOOM",
  259: "INSERT.OBJECT",
  260: "WINDOW.MINIMIZE",
  265: "SOUND.NOTE",
  266: "SOUND.PLAY",
  267: "FORMAT.SHAPE",
  268: "EXTEND.POLYGON",
  269: "FORMAT.AUTO",
  272: "GALLERY.3D.BAR",
  273: "GALLERY.3D.SURFACE",
  274: "FILL.AUTO",
  276: "CUSTOMIZE.TOOLBAR",
  277: "ADD.TOOL",
  278: "EDIT.OBJECT",
  279: "ON.DOUBLECLICK",
  280: "ON.ENTRY",
  281: "WORKBOOK.ADD",
  282: "WORKBOOK.MOVE",
  283: "WORKBOOK.COPY",
  284: "WORKBOOK.OPTIONS",
  285: "SAVE.WORKSPACE",
  288: "CHART.WIZARD",
  289: "DELETE.TOOL",
  290: "MOVE.TOOL",
  291: "WORKBOOK.SELECT",
  292: "WORKBOOK.ACTIVATE",
  293: "ASSIGN.TO.TOOL",
  295: "COPY.TOOL",
  296: "RESET.TOOL",
  297: "CONSTRAIN.NUMERIC",
  298: "PASTE.TOOL",
  302: "WORKBOOK.NEW",
  305: "SCENARIO.CELLS",
  306: "SCENARIO.DELETE",
  307: "SCENARIO.ADD",
  308: "SCENARIO.EDIT",
  309: "SCENARIO.SHOW",
  310: "SCENARIO.SHOW.NEXT",
  311: "SCENARIO.SUMMARY",
  312: "PIVOT.TABLE.WIZARD",
  313: "PIVOT.FIELD.PROPERTIES",
  314: "PIVOT.FIELD",
  315: "PIVOT.ITEM",
  316: "PIVOT.ADD.FIELDS",
  318: "OPTIONS.CALCULATION",
  319: "OPTIONS.EDIT",
  320: "OPTIONS.VIEW",
  321: "ADDIN.MANAGER",
  322: "MENU.EDITOR",
  323: "ATTACH.TOOLBARS",
  324: "VBAActivate",
  325: "OPTIONS.CHART",
  328: "VBA.INSERT.FILE",
  330: "VBA.PROCEDURE.DEFINITION",
  336: "ROUTING.SLIP",
  338: "ROUTE.DOCUMENT",
  339: "MAIL.LOGON",
  342: "INSERT.PICTURE",
  343: "EDIT.TOOL",
  344: "GALLERY.DOUGHNUT",
  350: "CHART.TREND",
  352: "PIVOT.ITEM.PROPERTIES",
  354: "WORKBOOK.INSERT",
  355: "OPTIONS.TRANSITION",
  356: "OPTIONS.GENERAL",
  370: "FILTER.ADVANCED",
  373: "MAIL.ADD.MAILER",
  374: "MAIL.DELETE.MAILER",
  375: "MAIL.REPLY",
  376: "MAIL.REPLY.ALL",
  377: "MAIL.FORWARD",
  378: "MAIL.NEXT.LETTER",
  379: "DATA.LABEL",
  380: "INSERT.TITLE",
  381: "FONT.PROPERTIES",
  382: "MACRO.OPTIONS",
  383: "WORKBOOK.HIDE",
  384: "WORKBOOK.UNHIDE",
  385: "WORKBOOK.DELETE",
  386: "WORKBOOK.NAME",
  388: "GALLERY.CUSTOM",
  390: "ADD.CHART.AUTOFORMAT",
  391: "DELETE.CHART.AUTOFORMAT",
  392: "CHART.ADD.DATA",
  393: "AUTO.OUTLINE",
  394: "TAB.ORDER",
  395: "SHOW.DIALOG",
  396: "SELECT.ALL",
  397: "UNGROUP.SHEETS",
  398: "SUBTOTAL.CREATE",
  399: "SUBTOTAL.REMOVE",
  400: "RENAME.OBJECT",
  412: "WORKBOOK.SCROLL",
  413: "WORKBOOK.NEXT",
  414: "WORKBOOK.PREV",
  415: "WORKBOOK.TAB.SPLIT",
  416: "FULL.SCREEN",
  417: "WORKBOOK.PROTECT",
  420: "SCROLLBAR.PROPERTIES",
  421: "PIVOT.SHOW.PAGES",
  422: "TEXT.TO.COLUMNS",
  423: "FORMAT.CHARTTYPE",
  424: "LINK.FORMAT",
  425: "TRACER.DISPLAY",
  430: "TRACER.NAVIGATE",
  431: "TRACER.CLEAR",
  432: "TRACER.ERROR",
  433: "PIVOT.FIELD.GROUP",
  434: "PIVOT.FIELD.UNGROUP",
  435: "CHECKBOX.PROPERTIES",
  436: "LABEL.PROPERTIES",
  437: "LISTBOX.PROPERTIES",
  438: "EDITBOX.PROPERTIES",
  439: "PIVOT.REFRESH",
  440: "LINK.COMBO",
  441: "OPEN.TEXT",
  442: "HIDE.DIALOG",
  443: "SET.DIALOG.FOCUS",
  444: "ENABLE.OBJECT",
  445: "PUSHBUTTON.PROPERTIES",
  446: "SET.DIALOG.DEFAULT",
  447: "FILTER",
  448: "FILTER.SHOW.ALL",
  449: "CLEAR.OUTLINE",
  450: "FUNCTION.WIZARD",
  451: "ADD.LIST.ITEM",
  452: "SET.LIST.ITEM",
  453: "REMOVE.LIST.ITEM",
  454: "SELECT.LIST.ITEM",
  455: "SET.CONTROL.VALUE",
  456: "SAVE.COPY.AS",
  458: "OPTIONS.LISTS.ADD",
  459: "OPTIONS.LISTS.DELETE",
  460: "SERIES.AXES",
  461: "SERIES.X",
  462: "SERIES.Y",
  463: "ERRORBAR.X",
  464: "ERRORBAR.Y",
  465: "FORMAT.CHART",
  466: "SERIES.ORDER",
  467: "MAIL.LOGOFF",
  468: "CLEAR.ROUTING.SLIP",
  469: "APP.ACTIVATE.MICROSOFT",
  470: "MAIL.EDIT.MAILER",
  471: "ON.SHEET",
  472: "STANDARD.WIDTH",
  473: "SCENARIO.MERGE",
  474: "SUMMARY.INFO",
  475: "FIND.FILE",
  476: "ACTIVE.CELL.FONT",
  477: "ENABLE.TIPWIZARD",
  478: "VBA.MAKE.ADDIN",
  480: "INSERTDATATABLE",
  481: "WORKGROUP.OPTIONS",
  482: "MAIL.SEND.MAILER",
  485: "AUTOCORRECT",
  489: "POST.DOCUMENT",
  491: "PICKLIST",
  493: "VIEW.SHOW",
  494: "VIEW.DEFINE",
  495: "VIEW.DELETE",
  509: "SHEET.BACKGROUND",
  510: "INSERT.MAP.OBJECT",
  511: "OPTIONS.MENONO",
  517: "MSOCHECKS",
  518: "NORMAL",
  519: "LAYOUT",
  520: "RM.PRINT.AREA",
  521: "CLEAR.PRINT.AREA",
  522: "ADD.PRINT.AREA",
  523: "MOVE.BRK",
  545: "HIDECURR.NOTE",
  546: "HIDEALL.NOTES",
  547: "DELETE.NOTE",
  548: "TRAVERSE.NOTES",
  549: "ACTIVATE.NOTES",
  620: "PROTECT.REVISIONS",
  621: "UNPROTECT.REVISIONS",
  647: "OPTIONS.ME",
  653: "WEB.PUBLISH",
  667: "NEWWEBQUERY",
  673: "PIVOT.TABLE.CHART",
  753: "OPTIONS.SAVE",
  755: "OPTIONS.SPELL",
  808: "HIDEALL.INKANNOTS"
};
var Ftab = {
  0: "COUNT",
  1: "IF",
  2: "ISNA",
  3: "ISERROR",
  4: "SUM",
  5: "AVERAGE",
  6: "MIN",
  7: "MAX",
  8: "ROW",
  9: "COLUMN",
  10: "NA",
  11: "NPV",
  12: "STDEV",
  13: "DOLLAR",
  14: "FIXED",
  15: "SIN",
  16: "COS",
  17: "TAN",
  18: "ATAN",
  19: "PI",
  20: "SQRT",
  21: "EXP",
  22: "LN",
  23: "LOG10",
  24: "ABS",
  25: "INT",
  26: "SIGN",
  27: "ROUND",
  28: "LOOKUP",
  29: "INDEX",
  30: "REPT",
  31: "MID",
  32: "LEN",
  33: "VALUE",
  34: "TRUE",
  35: "FALSE",
  36: "AND",
  37: "OR",
  38: "NOT",
  39: "MOD",
  40: "DCOUNT",
  41: "DSUM",
  42: "DAVERAGE",
  43: "DMIN",
  44: "DMAX",
  45: "DSTDEV",
  46: "VAR",
  47: "DVAR",
  48: "TEXT",
  49: "LINEST",
  50: "TREND",
  51: "LOGEST",
  52: "GROWTH",
  53: "GOTO",
  54: "HALT",
  55: "RETURN",
  56: "PV",
  57: "FV",
  58: "NPER",
  59: "PMT",
  60: "RATE",
  61: "MIRR",
  62: "IRR",
  63: "RAND",
  64: "MATCH",
  65: "DATE",
  66: "TIME",
  67: "DAY",
  68: "MONTH",
  69: "YEAR",
  70: "WEEKDAY",
  71: "HOUR",
  72: "MINUTE",
  73: "SECOND",
  74: "NOW",
  75: "AREAS",
  76: "ROWS",
  77: "COLUMNS",
  78: "OFFSET",
  79: "ABSREF",
  80: "RELREF",
  81: "ARGUMENT",
  82: "SEARCH",
  83: "TRANSPOSE",
  84: "ERROR",
  85: "STEP",
  86: "TYPE",
  87: "ECHO",
  88: "SET.NAME",
  89: "CALLER",
  90: "DEREF",
  91: "WINDOWS",
  92: "SERIES",
  93: "DOCUMENTS",
  94: "ACTIVE.CELL",
  95: "SELECTION",
  96: "RESULT",
  97: "ATAN2",
  98: "ASIN",
  99: "ACOS",
  100: "CHOOSE",
  101: "HLOOKUP",
  102: "VLOOKUP",
  103: "LINKS",
  104: "INPUT",
  105: "ISREF",
  106: "GET.FORMULA",
  107: "GET.NAME",
  108: "SET.VALUE",
  109: "LOG",
  110: "EXEC",
  111: "CHAR",
  112: "LOWER",
  113: "UPPER",
  114: "PROPER",
  115: "LEFT",
  116: "RIGHT",
  117: "EXACT",
  118: "TRIM",
  119: "REPLACE",
  120: "SUBSTITUTE",
  121: "CODE",
  122: "NAMES",
  123: "DIRECTORY",
  124: "FIND",
  125: "CELL",
  126: "ISERR",
  127: "ISTEXT",
  128: "ISNUMBER",
  129: "ISBLANK",
  130: "T",
  131: "N",
  132: "FOPEN",
  133: "FCLOSE",
  134: "FSIZE",
  135: "FREADLN",
  136: "FREAD",
  137: "FWRITELN",
  138: "FWRITE",
  139: "FPOS",
  140: "DATEVALUE",
  141: "TIMEVALUE",
  142: "SLN",
  143: "SYD",
  144: "DDB",
  145: "GET.DEF",
  146: "REFTEXT",
  147: "TEXTREF",
  148: "INDIRECT",
  149: "REGISTER",
  150: "CALL",
  151: "ADD.BAR",
  152: "ADD.MENU",
  153: "ADD.COMMAND",
  154: "ENABLE.COMMAND",
  155: "CHECK.COMMAND",
  156: "RENAME.COMMAND",
  157: "SHOW.BAR",
  158: "DELETE.MENU",
  159: "DELETE.COMMAND",
  160: "GET.CHART.ITEM",
  161: "DIALOG.BOX",
  162: "CLEAN",
  163: "MDETERM",
  164: "MINVERSE",
  165: "MMULT",
  166: "FILES",
  167: "IPMT",
  168: "PPMT",
  169: "COUNTA",
  170: "CANCEL.KEY",
  171: "FOR",
  172: "WHILE",
  173: "BREAK",
  174: "NEXT",
  175: "INITIATE",
  176: "REQUEST",
  177: "POKE",
  178: "EXECUTE",
  179: "TERMINATE",
  180: "RESTART",
  181: "HELP",
  182: "GET.BAR",
  183: "PRODUCT",
  184: "FACT",
  185: "GET.CELL",
  186: "GET.WORKSPACE",
  187: "GET.WINDOW",
  188: "GET.DOCUMENT",
  189: "DPRODUCT",
  190: "ISNONTEXT",
  191: "GET.NOTE",
  192: "NOTE",
  193: "STDEVP",
  194: "VARP",
  195: "DSTDEVP",
  196: "DVARP",
  197: "TRUNC",
  198: "ISLOGICAL",
  199: "DCOUNTA",
  200: "DELETE.BAR",
  201: "UNREGISTER",
  204: "USDOLLAR",
  205: "FINDB",
  206: "SEARCHB",
  207: "REPLACEB",
  208: "LEFTB",
  209: "RIGHTB",
  210: "MIDB",
  211: "LENB",
  212: "ROUNDUP",
  213: "ROUNDDOWN",
  214: "ASC",
  215: "DBCS",
  216: "RANK",
  219: "ADDRESS",
  220: "DAYS360",
  221: "TODAY",
  222: "VDB",
  223: "ELSE",
  224: "ELSE.IF",
  225: "END.IF",
  226: "FOR.CELL",
  227: "MEDIAN",
  228: "SUMPRODUCT",
  229: "SINH",
  230: "COSH",
  231: "TANH",
  232: "ASINH",
  233: "ACOSH",
  234: "ATANH",
  235: "DGET",
  236: "CREATE.OBJECT",
  237: "VOLATILE",
  238: "LAST.ERROR",
  239: "CUSTOM.UNDO",
  240: "CUSTOM.REPEAT",
  241: "FORMULA.CONVERT",
  242: "GET.LINK.INFO",
  243: "TEXT.BOX",
  244: "INFO",
  245: "GROUP",
  246: "GET.OBJECT",
  247: "DB",
  248: "PAUSE",
  251: "RESUME",
  252: "FREQUENCY",
  253: "ADD.TOOLBAR",
  254: "DELETE.TOOLBAR",
  255: "User",
  256: "RESET.TOOLBAR",
  257: "EVALUATE",
  258: "GET.TOOLBAR",
  259: "GET.TOOL",
  260: "SPELLING.CHECK",
  261: "ERROR.TYPE",
  262: "APP.TITLE",
  263: "WINDOW.TITLE",
  264: "SAVE.TOOLBAR",
  265: "ENABLE.TOOL",
  266: "PRESS.TOOL",
  267: "REGISTER.ID",
  268: "GET.WORKBOOK",
  269: "AVEDEV",
  270: "BETADIST",
  271: "GAMMALN",
  272: "BETAINV",
  273: "BINOMDIST",
  274: "CHIDIST",
  275: "CHIINV",
  276: "COMBIN",
  277: "CONFIDENCE",
  278: "CRITBINOM",
  279: "EVEN",
  280: "EXPONDIST",
  281: "FDIST",
  282: "FINV",
  283: "FISHER",
  284: "FISHERINV",
  285: "FLOOR",
  286: "GAMMADIST",
  287: "GAMMAINV",
  288: "CEILING",
  289: "HYPGEOMDIST",
  290: "LOGNORMDIST",
  291: "LOGINV",
  292: "NEGBINOMDIST",
  293: "NORMDIST",
  294: "NORMSDIST",
  295: "NORMINV",
  296: "NORMSINV",
  297: "STANDARDIZE",
  298: "ODD",
  299: "PERMUT",
  300: "POISSON",
  301: "TDIST",
  302: "WEIBULL",
  303: "SUMXMY2",
  304: "SUMX2MY2",
  305: "SUMX2PY2",
  306: "CHITEST",
  307: "CORREL",
  308: "COVAR",
  309: "FORECAST",
  310: "FTEST",
  311: "INTERCEPT",
  312: "PEARSON",
  313: "RSQ",
  314: "STEYX",
  315: "SLOPE",
  316: "TTEST",
  317: "PROB",
  318: "DEVSQ",
  319: "GEOMEAN",
  320: "HARMEAN",
  321: "SUMSQ",
  322: "KURT",
  323: "SKEW",
  324: "ZTEST",
  325: "LARGE",
  326: "SMALL",
  327: "QUARTILE",
  328: "PERCENTILE",
  329: "PERCENTRANK",
  330: "MODE",
  331: "TRIMMEAN",
  332: "TINV",
  334: "MOVIE.COMMAND",
  335: "GET.MOVIE",
  336: "CONCATENATE",
  337: "POWER",
  338: "PIVOT.ADD.DATA",
  339: "GET.PIVOT.TABLE",
  340: "GET.PIVOT.FIELD",
  341: "GET.PIVOT.ITEM",
  342: "RADIANS",
  343: "DEGREES",
  344: "SUBTOTAL",
  345: "SUMIF",
  346: "COUNTIF",
  347: "COUNTBLANK",
  348: "SCENARIO.GET",
  349: "OPTIONS.LISTS.GET",
  350: "ISPMT",
  351: "DATEDIF",
  352: "DATESTRING",
  353: "NUMBERSTRING",
  354: "ROMAN",
  355: "OPEN.DIALOG",
  356: "SAVE.DIALOG",
  357: "VIEW.GET",
  358: "GETPIVOTDATA",
  359: "HYPERLINK",
  360: "PHONETIC",
  361: "AVERAGEA",
  362: "MAXA",
  363: "MINA",
  364: "STDEVPA",
  365: "VARPA",
  366: "STDEVA",
  367: "VARA",
  368: "BAHTTEXT",
  369: "THAIDAYOFWEEK",
  370: "THAIDIGIT",
  371: "THAIMONTHOFYEAR",
  372: "THAINUMSOUND",
  373: "THAINUMSTRING",
  374: "THAISTRINGLENGTH",
  375: "ISTHAIDIGIT",
  376: "ROUNDBAHTDOWN",
  377: "ROUNDBAHTUP",
  378: "THAIYEAR",
  379: "RTD",
  380: "CUBEVALUE",
  381: "CUBEMEMBER",
  382: "CUBEMEMBERPROPERTY",
  383: "CUBERANKEDMEMBER",
  384: "HEX2BIN",
  385: "HEX2DEC",
  386: "HEX2OCT",
  387: "DEC2BIN",
  388: "DEC2HEX",
  389: "DEC2OCT",
  390: "OCT2BIN",
  391: "OCT2HEX",
  392: "OCT2DEC",
  393: "BIN2DEC",
  394: "BIN2OCT",
  395: "BIN2HEX",
  396: "IMSUB",
  397: "IMDIV",
  398: "IMPOWER",
  399: "IMABS",
  400: "IMSQRT",
  401: "IMLN",
  402: "IMLOG2",
  403: "IMLOG10",
  404: "IMSIN",
  405: "IMCOS",
  406: "IMEXP",
  407: "IMARGUMENT",
  408: "IMCONJUGATE",
  409: "IMAGINARY",
  410: "IMREAL",
  411: "COMPLEX",
  412: "IMSUM",
  413: "IMPRODUCT",
  414: "SERIESSUM",
  415: "FACTDOUBLE",
  416: "SQRTPI",
  417: "QUOTIENT",
  418: "DELTA",
  419: "GESTEP",
  420: "ISEVEN",
  421: "ISODD",
  422: "MROUND",
  423: "ERF",
  424: "ERFC",
  425: "BESSELJ",
  426: "BESSELK",
  427: "BESSELY",
  428: "BESSELI",
  429: "XIRR",
  430: "XNPV",
  431: "PRICEMAT",
  432: "YIELDMAT",
  433: "INTRATE",
  434: "RECEIVED",
  435: "DISC",
  436: "PRICEDISC",
  437: "YIELDDISC",
  438: "TBILLEQ",
  439: "TBILLPRICE",
  440: "TBILLYIELD",
  441: "PRICE",
  442: "YIELD",
  443: "DOLLARDE",
  444: "DOLLARFR",
  445: "NOMINAL",
  446: "EFFECT",
  447: "CUMPRINC",
  448: "CUMIPMT",
  449: "EDATE",
  450: "EOMONTH",
  451: "YEARFRAC",
  452: "COUPDAYBS",
  453: "COUPDAYS",
  454: "COUPDAYSNC",
  455: "COUPNCD",
  456: "COUPNUM",
  457: "COUPPCD",
  458: "DURATION",
  459: "MDURATION",
  460: "ODDLPRICE",
  461: "ODDLYIELD",
  462: "ODDFPRICE",
  463: "ODDFYIELD",
  464: "RANDBETWEEN",
  465: "WEEKNUM",
  466: "AMORDEGRC",
  467: "AMORLINC",
  468: "CONVERT",
  724: "SHEETJS",
  469: "ACCRINT",
  470: "ACCRINTM",
  471: "WORKDAY",
  472: "NETWORKDAYS",
  473: "GCD",
  474: "MULTINOMIAL",
  475: "LCM",
  476: "FVSCHEDULE",
  477: "CUBEKPIMEMBER",
  478: "CUBESET",
  479: "CUBESETCOUNT",
  480: "IFERROR",
  481: "COUNTIFS",
  482: "SUMIFS",
  483: "AVERAGEIF",
  484: "AVERAGEIFS"
};
var FtabArgc = {
  2: 1,
  3: 1,
  10: 0,
  15: 1,
  16: 1,
  17: 1,
  18: 1,
  19: 0,
  20: 1,
  21: 1,
  22: 1,
  23: 1,
  24: 1,
  25: 1,
  26: 1,
  27: 2,
  30: 2,
  31: 3,
  32: 1,
  33: 1,
  34: 0,
  35: 0,
  38: 1,
  39: 2,
  40: 3,
  41: 3,
  42: 3,
  43: 3,
  44: 3,
  45: 3,
  47: 3,
  48: 2,
  53: 1,
  61: 3,
  63: 0,
  65: 3,
  66: 3,
  67: 1,
  68: 1,
  69: 1,
  70: 1,
  71: 1,
  72: 1,
  73: 1,
  74: 0,
  75: 1,
  76: 1,
  77: 1,
  79: 2,
  80: 2,
  83: 1,
  85: 0,
  86: 1,
  89: 0,
  90: 1,
  94: 0,
  95: 0,
  97: 2,
  98: 1,
  99: 1,
  101: 3,
  102: 3,
  105: 1,
  106: 1,
  108: 2,
  111: 1,
  112: 1,
  113: 1,
  114: 1,
  117: 2,
  118: 1,
  119: 4,
  121: 1,
  126: 1,
  127: 1,
  128: 1,
  129: 1,
  130: 1,
  131: 1,
  133: 1,
  134: 1,
  135: 1,
  136: 2,
  137: 2,
  138: 2,
  140: 1,
  141: 1,
  142: 3,
  143: 4,
  144: 4,
  161: 1,
  162: 1,
  163: 1,
  164: 1,
  165: 2,
  172: 1,
  175: 2,
  176: 2,
  177: 3,
  178: 2,
  179: 1,
  184: 1,
  186: 1,
  189: 3,
  190: 1,
  195: 3,
  196: 3,
  197: 1,
  198: 1,
  199: 3,
  201: 1,
  207: 4,
  210: 3,
  211: 1,
  212: 2,
  213: 2,
  214: 1,
  215: 1,
  225: 0,
  229: 1,
  230: 1,
  231: 1,
  232: 1,
  233: 1,
  234: 1,
  235: 3,
  244: 1,
  247: 4,
  252: 2,
  257: 1,
  261: 1,
  271: 1,
  273: 4,
  274: 2,
  275: 2,
  276: 2,
  277: 3,
  278: 3,
  279: 1,
  280: 3,
  281: 3,
  282: 3,
  283: 1,
  284: 1,
  285: 2,
  286: 4,
  287: 3,
  288: 2,
  289: 4,
  290: 3,
  291: 3,
  292: 3,
  293: 4,
  294: 1,
  295: 3,
  296: 1,
  297: 3,
  298: 1,
  299: 2,
  300: 3,
  301: 3,
  302: 4,
  303: 2,
  304: 2,
  305: 2,
  306: 2,
  307: 2,
  308: 2,
  309: 3,
  310: 2,
  311: 2,
  312: 2,
  313: 2,
  314: 2,
  315: 2,
  316: 4,
  325: 2,
  326: 2,
  327: 2,
  328: 2,
  331: 2,
  332: 2,
  337: 2,
  342: 1,
  343: 1,
  346: 2,
  347: 1,
  350: 4,
  351: 3,
  352: 1,
  353: 2,
  360: 1,
  368: 1,
  369: 1,
  370: 1,
  371: 1,
  372: 1,
  373: 1,
  374: 1,
  375: 1,
  376: 1,
  377: 1,
  378: 1,
  382: 3,
  385: 1,
  392: 1,
  393: 1,
  396: 2,
  397: 2,
  398: 2,
  399: 1,
  400: 1,
  401: 1,
  402: 1,
  403: 1,
  404: 1,
  405: 1,
  406: 1,
  407: 1,
  408: 1,
  409: 1,
  410: 1,
  414: 4,
  415: 1,
  416: 1,
  417: 2,
  420: 1,
  421: 1,
  422: 2,
  424: 1,
  425: 2,
  426: 2,
  427: 2,
  428: 2,
  430: 3,
  438: 3,
  439: 3,
  440: 3,
  443: 2,
  444: 2,
  445: 2,
  446: 2,
  447: 6,
  448: 6,
  449: 2,
  450: 2,
  464: 2,
  468: 3,
  476: 2,
  479: 1,
  480: 2,
  65535: 0
};
function ods_to_csf_formula(f) {
  if (f.slice(0, 3) == "of:") f = f.slice(3);
  if (f.charCodeAt(0) == 61) {
    f = f.slice(1);
    if (f.charCodeAt(0) == 61) f = f.slice(1);
  }
  f = f.replace(/COM\.MICROSOFT\./g, "");
  f = f.replace(/\[((?:\.[A-Z]+[0-9]+)(?::\.[A-Z]+[0-9]+)?)\]/g, function($$, $1) {
    return $1.replace(/\./g, "");
  });
  f = f.replace(/\$'([^']|'')+'/g, function($$) {
    return $$.slice(1);
  });
  f = f.replace(/\$([^\]\. #$]+)/g, function($$, $1) {
    return $1.match(/^([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])?(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})?$/) ? $$ : $1;
  });
  f = f.replace(/\[.(#[A-Z]*[?!])\]/g, "$1");
  return f.replace(/[;~]/g, ",").replace(/\|/g, ";");
}
function ods_to_csf_3D(r) {
  r = r.replace(/\$'([^']|'')+'/g, function($$) {
    return $$.slice(1);
  });
  r = r.replace(/\$([^\]\. #$]+)/g, function($$, $1) {
    return $1.match(/^([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])?(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})?$/) ? $$ : $1;
  });
  var a = r.split(":");
  var s = a[0].split(".")[0];
  return [s, a[0].split(".")[1] + (a.length > 1 ? ":" + (a[1].split(".")[1] || a[1].split(".")[0]) : "")];
}
var strs = {};
var _ssfopts = {};
function default_margins(margins, mode) {
  if (!margins) return;
  var defs = [0.7, 0.7, 0.75, 0.75, 0.3, 0.3];
  if (mode == "xlml") defs = [1, 1, 1, 1, 0.5, 0.5];
  if (margins.left == null) margins.left = defs[0];
  if (margins.right == null) margins.right = defs[1];
  if (margins.top == null) margins.top = defs[2];
  if (margins.bottom == null) margins.bottom = defs[3];
  if (margins.header == null) margins.header = defs[4];
  if (margins.footer == null) margins.footer = defs[5];
}
function safe_format(p, fmtid, fillid, opts, themes, styles, date1904) {
  try {
    if (opts.cellNF) p.z = table_fmt[fmtid];
  } catch (e) {
    if (opts.WTF) throw e;
  }
  if (p.t === "z" && !opts.cellStyles) return;
  if (p.t === "d" && typeof p.v === "string") p.v = parseDate(p.v);
  if ((!opts || opts.cellText !== false) && p.t !== "z") try {
    if (table_fmt[fmtid] == null) SSF__load(SSFImplicit[fmtid] || "General", fmtid);
    if (p.t === "e") p.w = p.w || BErr[p.v];
    else if (fmtid === 0) {
      if (p.t === "n") {
        if ((p.v | 0) === p.v) p.w = p.v.toString(10);
        else p.w = SSF_general_num(p.v);
      } else if (p.t === "d") {
        var dd = datenum(p.v, !!date1904);
        if ((dd | 0) === dd) p.w = dd.toString(10);
        else p.w = SSF_general_num(dd);
      } else if (p.v === void 0) return "";
      else p.w = SSF_general(p.v, _ssfopts);
    } else if (p.t === "d") p.w = SSF_format(fmtid, datenum(p.v, !!date1904), _ssfopts);
    else p.w = SSF_format(fmtid, p.v, _ssfopts);
  } catch (e) {
    if (opts.WTF) throw e;
  }
  if (!opts.cellStyles) return;
  if (fillid != null) try {
    p.s = styles.Fills[fillid];
    if (p.s.fgColor && p.s.fgColor.theme && !p.s.fgColor.rgb) {
      p.s.fgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p.s.fgColor.theme].rgb, p.s.fgColor.tint || 0);
      if (opts.WTF) p.s.fgColor.raw_rgb = themes.themeElements.clrScheme[p.s.fgColor.theme].rgb;
    }
    if (p.s.bgColor && p.s.bgColor.theme) {
      p.s.bgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p.s.bgColor.theme].rgb, p.s.bgColor.tint || 0);
      if (opts.WTF) p.s.bgColor.raw_rgb = themes.themeElements.clrScheme[p.s.bgColor.theme].rgb;
    }
  } catch (e) {
    if (opts.WTF && styles.Fills) throw e;
  }
}
function parse_ws_xml_dim(ws, s) {
  var d = safe_decode_range(s);
  if (d.s.r <= d.e.r && d.s.c <= d.e.c && d.s.r >= 0 && d.s.c >= 0) ws["!ref"] = encode_range(d);
}
var mergecregex = /<(?:\w+:)?mergeCell ref=["'][A-Z0-9:]+['"]\s*[\/]?>/g;
var hlinkregex = /<(?:\w+:)?hyperlink [^<>]*>/mg;
var dimregex = /"(\w*:\w*)"/;
var colregex = /<(?:\w+:)?col\b[^<>]*[\/]?>/g;
var afregex = /<(?:\w+:)?autoFilter[^>]*/g;
var marginregex = /<(?:\w+:)?pageMargins[^<>]*\/>/g;
var sheetprregex = /<(?:\w+:)?sheetPr\b[^<>]*?\/>/;
function parse_ws_xml(data, opts, idx, rels, wb, themes, styles) {
  if (!data) return data;
  if (!rels) rels = { "!id": {} };
  var s = {};
  if (opts.dense) s["!data"] = [];
  var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  var data1 = "", data2 = "";
  var mtch = str_match_xml_ns(data, "sheetData");
  if (mtch) {
    data1 = data.slice(0, mtch.index);
    data2 = data.slice(mtch.index + mtch[0].length);
  } else data1 = data2 = data;
  var sheetPr = data1.match(sheetprregex);
  if (sheetPr) parse_ws_xml_sheetpr(sheetPr[0], s, wb, idx);
  else if (sheetPr = str_match_xml_ns(data1, "sheetPr")) parse_ws_xml_sheetpr2(sheetPr[0], sheetPr[1] || "", s, wb, idx);
  var ridx = (data1.match(/<(?:\w*:)?dimension/) || { index: -1 }).index;
  if (ridx > 0) {
    var ref2 = data1.slice(ridx, ridx + 50).match(dimregex);
    if (ref2 && !(opts && opts.nodim)) parse_ws_xml_dim(s, ref2[1]);
  }
  var svs = str_match_xml_ns(data1, "sheetViews");
  if (svs && svs[1]) parse_ws_xml_sheetviews(svs[1], wb);
  var columns = [];
  if (opts.cellStyles) {
    var cols = data1.match(colregex);
    if (cols) parse_ws_xml_cols(columns, cols);
  }
  if (mtch) parse_ws_xml_data(mtch[1], s, opts, refguess, themes, styles, wb);
  var afilter = data2.match(afregex);
  if (afilter) s["!autofilter"] = parse_ws_xml_autofilter(afilter[0]);
  var merges = [];
  var _merge = data2.match(mergecregex);
  if (_merge) for (ridx = 0; ridx != _merge.length; ++ridx)
    merges[ridx] = safe_decode_range(_merge[ridx].slice(_merge[ridx].indexOf('"') + 1));
  var hlink = data2.match(hlinkregex);
  if (hlink) parse_ws_xml_hlinks(s, hlink, rels);
  var margins = data2.match(marginregex);
  if (margins) s["!margins"] = parse_ws_xml_margins(parsexmltag(margins[0]));
  var m;
  if (m = data2.match(/legacyDrawing r:id="(.*?)"/)) s["!legrel"] = m[1];
  if (opts && opts.nodim) refguess.s.c = refguess.s.r = 0;
  if (!s["!ref"] && refguess.e.c >= refguess.s.c && refguess.e.r >= refguess.s.r) s["!ref"] = encode_range(refguess);
  if (opts.sheetRows > 0 && s["!ref"]) {
    var tmpref = safe_decode_range(s["!ref"]);
    if (opts.sheetRows <= +tmpref.e.r) {
      tmpref.e.r = opts.sheetRows - 1;
      if (tmpref.e.r > refguess.e.r) tmpref.e.r = refguess.e.r;
      if (tmpref.e.r < tmpref.s.r) tmpref.s.r = tmpref.e.r;
      if (tmpref.e.c > refguess.e.c) tmpref.e.c = refguess.e.c;
      if (tmpref.e.c < tmpref.s.c) tmpref.s.c = tmpref.e.c;
      s["!fullref"] = s["!ref"];
      s["!ref"] = encode_range(tmpref);
    }
  }
  if (columns.length > 0) s["!cols"] = columns;
  if (merges.length > 0) s["!merges"] = merges;
  if (rels["!id"][s["!legrel"]]) s["!legdrawel"] = rels["!id"][s["!legrel"]];
  return s;
}
function parse_ws_xml_sheetpr(sheetPr, s, wb, idx) {
  var data = parsexmltag(sheetPr);
  if (!wb.Sheets[idx]) wb.Sheets[idx] = {};
  if (data.codeName) wb.Sheets[idx].CodeName = unescapexml(utf8read(data.codeName));
}
function parse_ws_xml_sheetpr2(sheetPr, body, s, wb, idx) {
  parse_ws_xml_sheetpr(sheetPr.slice(0, sheetPr.indexOf(">")), s, wb, idx);
}
function parse_ws_xml_hlinks(s, data, rels) {
  var dense = s["!data"] != null;
  for (var i = 0; i != data.length; ++i) {
    var val = parsexmltag(utf8read(data[i]), true);
    if (!val.ref) return;
    var rel = ((rels || {})["!id"] || [])[val.id];
    if (rel) {
      val.Target = rel.Target;
      if (val.location) val.Target += "#" + unescapexml(val.location);
    } else {
      val.Target = "#" + unescapexml(val.location);
      rel = { Target: val.Target, TargetMode: "Internal" };
    }
    val.Rel = rel;
    if (val.tooltip) {
      val.Tooltip = val.tooltip;
      delete val.tooltip;
    }
    var rng = safe_decode_range(val.ref);
    for (var R = rng.s.r; R <= rng.e.r; ++R) for (var C2 = rng.s.c; C2 <= rng.e.c; ++C2) {
      var addr = encode_col(C2) + encode_row(R);
      if (dense) {
        if (!s["!data"][R]) s["!data"][R] = [];
        if (!s["!data"][R][C2]) s["!data"][R][C2] = { t: "z", v: void 0 };
        s["!data"][R][C2].l = val;
      } else {
        if (!s[addr]) s[addr] = { t: "z", v: void 0 };
        s[addr].l = val;
      }
    }
  }
}
function parse_ws_xml_margins(margin) {
  var o = {};
  ["left", "right", "top", "bottom", "header", "footer"].forEach(function(k2) {
    if (margin[k2]) o[k2] = parseFloat(margin[k2]);
  });
  return o;
}
function parse_ws_xml_cols(columns, cols) {
  var seencol = false;
  for (var coli = 0; coli != cols.length; ++coli) {
    var coll = parsexmltag(cols[coli], true);
    if (coll.hidden) coll.hidden = parsexmlbool(coll.hidden);
    var colm = parseInt(coll.min, 10) - 1, colM = parseInt(coll.max, 10) - 1;
    if (coll.outlineLevel) coll.level = +coll.outlineLevel || 0;
    delete coll.min;
    delete coll.max;
    coll.width = +coll.width;
    if (!seencol && coll.width) {
      seencol = true;
      find_mdw_colw(coll.width);
    }
    process_col(coll);
    while (colm <= colM) columns[colm++] = dup(coll);
  }
}
function parse_ws_xml_autofilter(data) {
  var o = { ref: (data.match(/ref="([^"]*)"/) || [])[1] };
  return o;
}
var sviewregex = /<(?:\w:)?sheetView(?:[^<>a-z][^<>]*)?\/?>/g;
function parse_ws_xml_sheetviews(data, wb) {
  if (!wb.Views) wb.Views = [{}];
  (data.match(sviewregex) || []).forEach(function(r, i) {
    var tag = parsexmltag(r);
    if (!wb.Views[i]) wb.Views[i] = {};
    if (+tag.zoomScale) wb.Views[i].zoom = +tag.zoomScale;
    if (tag.rightToLeft && parsexmlbool(tag.rightToLeft)) wb.Views[i].RTL = true;
  });
}
var parse_ws_xml_data = /* @__PURE__ */ function() {
  var cellregex = /<(?:\w+:)?c[ \/>]/, rowregex = /<\/(?:\w+:)?row>/;
  var rregex = /r=["']([^"']*)["']/;
  var refregex = /ref=["']([^"']*)["']/;
  return function parse_ws_xml_data2(sdata, s, opts, guess, themes, styles, wb) {
    var ri = 0, x = "", cells = [], cref = [], idx = 0, i = 0, cc = 0, d = "", p;
    var tag, tagr = 0, tagc = 0;
    var sstr, ftag;
    var fmtid = 0, fillid = 0;
    var do_format = Array.isArray(styles.CellXf), cf;
    var arrayf = [];
    var sharedf = [];
    var dense = s["!data"] != null;
    var rows = [], rowobj = {}, rowrite = false;
    var sheetStubs = !!opts.sheetStubs;
    var date1904 = !!((wb || {}).WBProps || {}).date1904;
    for (var marr = sdata.split(rowregex), mt = 0, marrlen = marr.length; mt != marrlen; ++mt) {
      x = marr[mt].trim();
      var xlen = x.length;
      if (xlen === 0) continue;
      var rstarti = 0;
      outa: for (ri = 0; ri < xlen; ++ri) switch (
        /*x.charCodeAt(ri)*/
        x[ri]
      ) {
        case ">":
          if (
            /*x.charCodeAt(ri-1) != 47*/
            x[ri - 1] != "/"
          ) {
            ++ri;
            break outa;
          }
          if (opts && opts.cellStyles) {
            tag = parsexmltag(x.slice(rstarti, ri), true);
            tagr = tag.r != null ? parseInt(tag.r, 10) : tagr + 1;
            tagc = -1;
            if (opts.sheetRows && opts.sheetRows < tagr) continue;
            rowobj = {};
            rowrite = false;
            if (tag.ht) {
              rowrite = true;
              rowobj.hpt = parseFloat(tag.ht);
              rowobj.hpx = pt2px(rowobj.hpt);
            }
            if (tag.hidden && parsexmlbool(tag.hidden)) {
              rowrite = true;
              rowobj.hidden = true;
            }
            if (tag.outlineLevel != null) {
              rowrite = true;
              rowobj.level = +tag.outlineLevel;
            }
            if (rowrite) rows[tagr - 1] = rowobj;
          }
          break;
        case "<":
          rstarti = ri;
          break;
      }
      if (rstarti >= ri) break;
      tag = parsexmltag(x.slice(rstarti, ri), true);
      tagr = tag.r != null ? parseInt(tag.r, 10) : tagr + 1;
      tagc = -1;
      if (opts.sheetRows && opts.sheetRows < tagr) continue;
      if (!opts.nodim) {
        if (guess.s.r > tagr - 1) guess.s.r = tagr - 1;
        if (guess.e.r < tagr - 1) guess.e.r = tagr - 1;
      }
      if (opts && opts.cellStyles) {
        rowobj = {};
        rowrite = false;
        if (tag.ht) {
          rowrite = true;
          rowobj.hpt = parseFloat(tag.ht);
          rowobj.hpx = pt2px(rowobj.hpt);
        }
        if (tag.hidden && parsexmlbool(tag.hidden)) {
          rowrite = true;
          rowobj.hidden = true;
        }
        if (tag.outlineLevel != null) {
          rowrite = true;
          rowobj.level = +tag.outlineLevel;
        }
        if (rowrite) rows[tagr - 1] = rowobj;
      }
      cells = x.slice(ri).split(cellregex);
      for (var rslice = 0; rslice != cells.length; ++rslice) if (cells[rslice].trim().charAt(0) != "<") break;
      cells = cells.slice(rslice);
      for (ri = 0; ri != cells.length; ++ri) {
        x = cells[ri].trim();
        if (x.length === 0) continue;
        cref = x.match(rregex);
        idx = ri;
        i = 0;
        cc = 0;
        x = "<c " + (x.slice(0, 1) == "<" ? ">" : "") + x;
        if (cref != null && cref.length === 2) {
          idx = 0;
          d = cref[1];
          for (i = 0; i != d.length; ++i) {
            if ((cc = d.charCodeAt(i) - 64) < 1 || cc > 26) break;
            idx = 26 * idx + cc;
          }
          --idx;
          tagc = idx;
        } else ++tagc;
        for (i = 0; i != x.length; ++i) if (x.charCodeAt(i) === 62) break;
        ++i;
        tag = parsexmltag(x.slice(0, i), true);
        if (!tag.r) tag.r = encode_cell({ r: tagr - 1, c: tagc });
        d = x.slice(i);
        p = { t: "" };
        if ((cref = str_match_xml_ns(d, "v")) != null && /*::cref != null && */
        cref[1] !== "") p.v = unescapexml(cref[1]);
        if (opts.cellFormula) {
          if ((cref = str_match_xml_ns(d, "f")) != null) {
            if (cref[1] == "") {
              if (
                /*::cref != null && cref[0] != null && */
                cref[0].indexOf('t="shared"') > -1
              ) {
                ftag = parsexmltag(cref[0]);
                if (sharedf[ftag.si]) p.f = shift_formula_xlsx(sharedf[ftag.si][1], sharedf[ftag.si][2], tag.r);
              }
            } else {
              p.f = unescapexml(utf8read(cref[1]), true);
              if (!opts.xlfn) p.f = _xlfn(p.f);
              if (
                /*::cref != null && cref[0] != null && */
                cref[0].indexOf('t="array"') > -1
              ) {
                p.F = (d.match(refregex) || [])[1];
                if (p.F.indexOf(":") > -1) arrayf.push([safe_decode_range(p.F), p.F]);
              } else if (
                /*::cref != null && cref[0] != null && */
                cref[0].indexOf('t="shared"') > -1
              ) {
                ftag = parsexmltag(cref[0]);
                var ___f = unescapexml(utf8read(cref[1]));
                if (!opts.xlfn) ___f = _xlfn(___f);
                sharedf[parseInt(ftag.si, 10)] = [ftag, ___f, tag.r];
              }
            }
          } else if (cref = d.match(/<f[^<>]*\/>/)) {
            ftag = parsexmltag(cref[0]);
            if (sharedf[ftag.si]) p.f = shift_formula_xlsx(sharedf[ftag.si][1], sharedf[ftag.si][2], tag.r);
          }
          var _tag = decode_cell(tag.r);
          for (i = 0; i < arrayf.length; ++i)
            if (_tag.r >= arrayf[i][0].s.r && _tag.r <= arrayf[i][0].e.r) {
              if (_tag.c >= arrayf[i][0].s.c && _tag.c <= arrayf[i][0].e.c)
                p.F = arrayf[i][1];
            }
        }
        if (tag.t == null && p.v === void 0) {
          if (p.f || p.F) {
            p.v = 0;
            p.t = "n";
          } else if (!sheetStubs) continue;
          else p.t = "z";
        } else p.t = tag.t || "n";
        if (guess.s.c > tagc) guess.s.c = tagc;
        if (guess.e.c < tagc) guess.e.c = tagc;
        switch (p.t) {
          case "n":
            if (p.v == "" || p.v == null) {
              if (!sheetStubs) continue;
              p.t = "z";
            } else p.v = parseFloat(p.v);
            break;
          case "s":
            if (typeof p.v == "undefined") {
              if (!sheetStubs) continue;
              p.t = "z";
            } else {
              sstr = strs[parseInt(p.v, 10)];
              p.v = sstr.t;
              p.r = sstr.r;
              if (opts.cellHTML) p.h = sstr.h;
            }
            break;
          case "str":
            p.t = "s";
            p.v = p.v != null ? unescapexml(utf8read(p.v), true) : "";
            if (opts.cellHTML) p.h = escapehtml(p.v);
            break;
          case "inlineStr":
            cref = str_match_xml_ns(d, "is");
            p.t = "s";
            if (cref != null && (sstr = parse_si(cref[1]))) {
              p.v = sstr.t;
              if (opts.cellHTML) p.h = sstr.h;
            } else p.v = "";
            break;
          case "b":
            p.v = parsexmlbool(p.v);
            break;
          case "d":
            if (opts.cellDates) p.v = parseDate(p.v, date1904);
            else {
              p.v = datenum(parseDate(p.v, date1904), date1904);
              p.t = "n";
            }
            break;
          case "e":
            if (!opts || opts.cellText !== false) p.w = p.v;
            p.v = RBErr[p.v];
            break;
        }
        fmtid = fillid = 0;
        cf = null;
        if (do_format && tag.s !== void 0) {
          cf = styles.CellXf[tag.s];
          if (cf != null) {
            if (cf.numFmtId != null) fmtid = cf.numFmtId;
            if (opts.cellStyles) {
              if (cf.fillId != null) fillid = cf.fillId;
            }
          }
        }
        safe_format(p, fmtid, fillid, opts, themes, styles, date1904);
        if (opts.cellDates && do_format && p.t == "n" && fmt_is_date(table_fmt[fmtid])) {
          p.v = numdate(p.v + (date1904 ? 1462 : 0));
          p.t = typeof p.v == "number" ? "n" : "d";
        }
        if (tag.cm && opts.xlmeta) {
          var cm = (opts.xlmeta.Cell || [])[+tag.cm - 1];
          if (cm && cm.type == "XLDAPR") p.D = true;
        }
        var _r;
        if (opts.nodim) {
          _r = decode_cell(tag.r);
          if (guess.s.r > _r.r) guess.s.r = _r.r;
          if (guess.e.r < _r.r) guess.e.r = _r.r;
        }
        if (dense) {
          _r = decode_cell(tag.r);
          if (!s["!data"][_r.r]) s["!data"][_r.r] = [];
          s["!data"][_r.r][_r.c] = p;
        } else s[tag.r] = p;
      }
    }
    if (rows.length > 0) s["!rows"] = rows;
  };
}();
function parse_BrtRowHdr(data, length) {
  var z = {};
  var tgt = data.l + length;
  z.r = data.read_shift(4);
  data.l += 4;
  var miyRw = data.read_shift(2);
  data.l += 1;
  var flags = data.read_shift(1);
  data.l = tgt;
  if (flags & 7) z.level = flags & 7;
  if (flags & 16) z.hidden = true;
  if (flags & 32) z.hpt = miyRw / 20;
  return z;
}
var parse_BrtWsDim = parse_UncheckedRfX;
function parse_BrtWsFmtInfo() {
}
function parse_BrtWsProp(data, length) {
  var z = {};
  var f = data[data.l];
  ++data.l;
  z.above = !(f & 64);
  z.left = !(f & 128);
  data.l += 18;
  z.name = parse_XLSBCodeName(data);
  return z;
}
function parse_BrtCellBlank(data) {
  var cell = parse_XLSBCell(data);
  return [cell];
}
function parse_BrtShortBlank(data) {
  var cell = parse_XLSBShortCell(data);
  return [cell];
}
function parse_BrtCellBool(data) {
  var cell = parse_XLSBCell(data);
  var fBool = data.read_shift(1);
  return [cell, fBool, "b"];
}
function parse_BrtShortBool(data) {
  var cell = parse_XLSBShortCell(data);
  var fBool = data.read_shift(1);
  return [cell, fBool, "b"];
}
function parse_BrtCellError(data) {
  var cell = parse_XLSBCell(data);
  var bError = data.read_shift(1);
  return [cell, bError, "e"];
}
function parse_BrtShortError(data) {
  var cell = parse_XLSBShortCell(data);
  var bError = data.read_shift(1);
  return [cell, bError, "e"];
}
function parse_BrtCellIsst(data) {
  var cell = parse_XLSBCell(data);
  var isst = data.read_shift(4);
  return [cell, isst, "s"];
}
function parse_BrtShortIsst(data) {
  var cell = parse_XLSBShortCell(data);
  var isst = data.read_shift(4);
  return [cell, isst, "s"];
}
function parse_BrtCellReal(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_Xnum(data);
  return [cell, value, "n"];
}
function parse_BrtShortReal(data) {
  var cell = parse_XLSBShortCell(data);
  var value = parse_Xnum(data);
  return [cell, value, "n"];
}
function parse_BrtCellRk(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_RkNumber(data);
  return [cell, value, "n"];
}
function parse_BrtShortRk(data) {
  var cell = parse_XLSBShortCell(data);
  var value = parse_RkNumber(data);
  return [cell, value, "n"];
}
function parse_BrtCellRString(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_RichStr(data);
  return [cell, value, "is"];
}
function parse_BrtCellSt(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_XLWideString(data);
  return [cell, value, "str"];
}
function parse_BrtShortSt(data) {
  var cell = parse_XLSBShortCell(data);
  var value = parse_XLWideString(data);
  return [cell, value, "str"];
}
function parse_BrtFmlaBool(data, length, opts) {
  var end = data.l + length;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = data.read_shift(1);
  var o = [cell, value, "b"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else data.l = end;
  return o;
}
function parse_BrtFmlaError(data, length, opts) {
  var end = data.l + length;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = data.read_shift(1);
  var o = [cell, value, "e"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else data.l = end;
  return o;
}
function parse_BrtFmlaNum(data, length, opts) {
  var end = data.l + length;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = parse_Xnum(data);
  var o = [cell, value, "n"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else data.l = end;
  return o;
}
function parse_BrtFmlaString(data, length, opts) {
  var end = data.l + length;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = parse_XLWideString(data);
  var o = [cell, value, "str"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else data.l = end;
  return o;
}
var parse_BrtMergeCell = parse_UncheckedRfX;
function parse_BrtHLink(data, length) {
  var end = data.l + length;
  var rfx = parse_UncheckedRfX(data);
  var relId = parse_XLNullableWideString(data);
  var loc = parse_XLWideString(data);
  var tooltip = parse_XLWideString(data);
  var display = parse_XLWideString(data);
  data.l = end;
  var o = { rfx, relId, loc, display };
  if (tooltip) o.Tooltip = tooltip;
  return o;
}
function parse_BrtPane() {
}
function parse_BrtArrFmla(data, length, opts) {
  var end = data.l + length;
  var rfx = parse_RfX(data);
  var fAlwaysCalc = data.read_shift(1);
  var o = [rfx];
  o[2] = fAlwaysCalc;
  if (opts.cellFormula) {
    var formula = parse_XLSBArrayParsedFormula(data, end - data.l, opts);
    o[1] = formula;
  } else data.l = end;
  return o;
}
function parse_BrtShrFmla(data, length, opts) {
  var end = data.l + length;
  var rfx = parse_UncheckedRfX(data);
  var o = [rfx];
  if (opts.cellFormula) {
    var formula = parse_XLSBSharedParsedFormula(data, end - data.l, opts);
    o[1] = formula;
    data.l = end;
  } else data.l = end;
  return o;
}
var BrtMarginKeys = ["left", "right", "top", "bottom", "header", "footer"];
function parse_BrtMargins(data) {
  var margins = {};
  BrtMarginKeys.forEach(function(k2) {
    margins[k2] = parse_Xnum(data);
  });
  return margins;
}
function parse_BrtBeginWsView(data) {
  var f = data.read_shift(2);
  data.l += 28;
  return { RTL: f & 32 };
}
function parse_BrtDVal() {
}
function parse_BrtDVal14() {
}
function parse_ws_bin(data, _opts, idx, rels, wb, themes, styles) {
  if (!data) return data;
  var opts = _opts || {};
  if (!rels) rels = { "!id": {} };
  var s = {};
  if (opts.dense) s["!data"] = [];
  var ref2;
  var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  var pass = false, end = false;
  var row, p, cf, R, C2, addr, sstr, rr, cell;
  var merges = [];
  opts.biff = 12;
  opts["!row"] = 0;
  var ai = 0, af = false;
  var arrayf = [];
  var sharedf = {};
  var supbooks = opts.supbooks || /*::(*/
  wb.supbooks || [[]];
  supbooks.sharedf = sharedf;
  supbooks.arrayf = arrayf;
  supbooks.SheetNames = wb.SheetNames || wb.Sheets.map(function(x) {
    return x.name;
  });
  if (!opts.supbooks) {
    opts.supbooks = supbooks;
    if (wb.Names) for (var i = 0; i < wb.Names.length; ++i) supbooks[0][i + 1] = wb.Names[i];
  }
  var colinfo = [], rowinfo = [];
  var seencol = false;
  XLSBRecordEnum[16] = { n: "BrtShortReal", f: parse_BrtShortReal };
  var cm;
  var date1904 = 1462 * +!!((wb || {}).WBProps || {}).date1904;
  recordhopper(data, function ws_parse(val, RR, RT) {
    if (end) return;
    switch (RT) {
      case 148:
        ref2 = val;
        break;
      case 0:
        row = val;
        if (opts.sheetRows && opts.sheetRows <= row.r) end = true;
        rr = encode_row(R = row.r);
        opts["!row"] = row.r;
        if (val.hidden || val.hpt || val.level != null) {
          if (val.hpt) val.hpx = pt2px(val.hpt);
          rowinfo[val.r] = val;
        }
        break;
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 62:
        p = { t: val[2] };
        switch (val[2]) {
          case "n":
            p.v = val[1];
            break;
          case "s":
            sstr = strs[val[1]];
            p.v = sstr.t;
            p.r = sstr.r;
            break;
          case "b":
            p.v = val[1] ? true : false;
            break;
          case "e":
            p.v = val[1];
            if (opts.cellText !== false) p.w = BErr[p.v];
            break;
          case "str":
            p.t = "s";
            p.v = val[1];
            break;
          case "is":
            p.t = "s";
            p.v = val[1].t;
            break;
        }
        if (cf = styles.CellXf[val[0].iStyleRef]) safe_format(p, cf.numFmtId, null, opts, themes, styles, date1904 > 0);
        C2 = val[0].c == -1 ? C2 + 1 : val[0].c;
        if (opts.dense) {
          if (!s["!data"][R]) s["!data"][R] = [];
          s["!data"][R][C2] = p;
        } else s[encode_col(C2) + rr] = p;
        if (opts.cellFormula) {
          af = false;
          for (ai = 0; ai < arrayf.length; ++ai) {
            var aii = arrayf[ai];
            if (row.r >= aii[0].s.r && row.r <= aii[0].e.r) {
              if (C2 >= aii[0].s.c && C2 <= aii[0].e.c) {
                p.F = encode_range(aii[0]);
                af = true;
              }
            }
          }
          if (!af && val.length > 3) p.f = val[3];
        }
        if (refguess.s.r > row.r) refguess.s.r = row.r;
        if (refguess.s.c > C2) refguess.s.c = C2;
        if (refguess.e.r < row.r) refguess.e.r = row.r;
        if (refguess.e.c < C2) refguess.e.c = C2;
        if (opts.cellDates && cf && p.t == "n" && fmt_is_date(table_fmt[cf.numFmtId])) {
          var _d = SSF_parse_date_code(p.v + date1904);
          if (_d) {
            p.t = "d";
            p.v = new Date(Date.UTC(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u));
          }
        }
        if (cm) {
          if (cm.type == "XLDAPR") p.D = true;
          cm = void 0;
        }
        break;
      case 1:
      case 12:
        if (!opts.sheetStubs || pass) break;
        p = { t: "z", v: void 0 };
        C2 = val[0].c == -1 ? C2 + 1 : val[0].c;
        if (opts.dense) {
          if (!s["!data"][R]) s["!data"][R] = [];
          s["!data"][R][C2] = p;
        } else s[encode_col(C2) + rr] = p;
        if (refguess.s.r > row.r) refguess.s.r = row.r;
        if (refguess.s.c > C2) refguess.s.c = C2;
        if (refguess.e.r < row.r) refguess.e.r = row.r;
        if (refguess.e.c < C2) refguess.e.c = C2;
        if (cm) {
          if (cm.type == "XLDAPR") p.D = true;
          cm = void 0;
        }
        break;
      case 176:
        merges.push(val);
        break;
      case 49:
        {
          cm = ((opts.xlmeta || {}).Cell || [])[val - 1];
        }
        break;
      case 494:
        var rel = rels["!id"][val.relId];
        if (rel) {
          val.Target = rel.Target;
          if (val.loc) val.Target += "#" + val.loc;
          val.Rel = rel;
        } else if (val.relId == "") {
          val.Target = "#" + val.loc;
        }
        for (R = val.rfx.s.r; R <= val.rfx.e.r; ++R) for (C2 = val.rfx.s.c; C2 <= val.rfx.e.c; ++C2) {
          if (opts.dense) {
            if (!s["!data"][R]) s["!data"][R] = [];
            if (!s["!data"][R][C2]) s["!data"][R][C2] = { t: "z", v: void 0 };
            s["!data"][R][C2].l = val;
          } else {
            addr = encode_col(C2) + encode_row(R);
            if (!s[addr]) s[addr] = { t: "z", v: void 0 };
            s[addr].l = val;
          }
        }
        break;
      case 426:
        if (!opts.cellFormula) break;
        arrayf.push(val);
        cell = opts.dense ? s["!data"][R][C2] : s[encode_col(C2) + rr];
        cell.f = stringify_formula(val[1], refguess, { r: row.r, c: C2 }, supbooks, opts);
        cell.F = encode_range(val[0]);
        break;
      case 427:
        if (!opts.cellFormula) break;
        sharedf[encode_cell(val[0].s)] = val[1];
        cell = opts.dense ? s["!data"][R][C2] : s[encode_col(C2) + rr];
        cell.f = stringify_formula(val[1], refguess, { r: row.r, c: C2 }, supbooks, opts);
        break;
      case 60:
        if (!opts.cellStyles) break;
        while (val.e >= val.s) {
          colinfo[val.e--] = { width: val.w / 256, hidden: !!(val.flags & 1), level: val.level };
          if (!seencol) {
            seencol = true;
            find_mdw_colw(val.w / 256);
          }
          process_col(colinfo[val.e + 1]);
        }
        break;
      case 551:
        if (val) s["!legrel"] = val;
        break;
      case 161:
        s["!autofilter"] = { ref: encode_range(val) };
        break;
      case 476:
        s["!margins"] = val;
        break;
      case 147:
        if (!wb.Sheets[idx]) wb.Sheets[idx] = {};
        if (val.name) wb.Sheets[idx].CodeName = val.name;
        if (val.above || val.left) s["!outline"] = { above: val.above, left: val.left };
        break;
      case 137:
        if (!wb.Views) wb.Views = [{}];
        if (!wb.Views[0]) wb.Views[0] = {};
        if (val.RTL) wb.Views[0].RTL = true;
        break;
      case 485:
        break;
      case 64:
      case 1053:
        break;
      case 151:
        break;
      case 152:
      case 175:
      case 644:
      case 625:
      case 562:
      case 396:
      case 1112:
      case 1146:
      case 471:
      case 1050:
      case 649:
      case 1105:
      case 589:
      case 607:
      case 564:
      case 1055:
      case 168:
      case 174:
      case 1180:
      case 499:
      case 507:
      case 550:
      case 171:
      case 167:
      case 1177:
      case 169:
      case 1181:
      case 552:
      case 661:
      case 639:
      case 478:
      case 537:
      case 477:
      case 536:
      case 1103:
      case 680:
      case 1104:
      case 1024:
      case 663:
      case 535:
      case 678:
      case 504:
      case 1043:
      case 428:
      case 170:
      case 3072:
      case 50:
      case 2070:
      case 1045:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      case 37:
        pass = true;
        break;
      case 38:
        pass = false;
        break;
      default:
        if (RR.T) ;
        else if (!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  }, opts);
  delete opts.supbooks;
  delete opts["!row"];
  if (!s["!ref"] && (refguess.s.r < 2e6 || ref2 && (ref2.e.r > 0 || ref2.e.c > 0 || ref2.s.r > 0 || ref2.s.c > 0))) s["!ref"] = encode_range(ref2 || refguess);
  if (opts.sheetRows && s["!ref"]) {
    var tmpref = safe_decode_range(s["!ref"]);
    if (opts.sheetRows <= +tmpref.e.r) {
      tmpref.e.r = opts.sheetRows - 1;
      if (tmpref.e.r > refguess.e.r) tmpref.e.r = refguess.e.r;
      if (tmpref.e.r < tmpref.s.r) tmpref.s.r = tmpref.e.r;
      if (tmpref.e.c > refguess.e.c) tmpref.e.c = refguess.e.c;
      if (tmpref.e.c < tmpref.s.c) tmpref.s.c = tmpref.e.c;
      s["!fullref"] = s["!ref"];
      s["!ref"] = encode_range(tmpref);
    }
  }
  if (merges.length > 0) s["!merges"] = merges;
  if (colinfo.length > 0) s["!cols"] = colinfo;
  if (rowinfo.length > 0) s["!rows"] = rowinfo;
  if (rels["!id"][s["!legrel"]]) s["!legdrawel"] = rels["!id"][s["!legrel"]];
  return s;
}
function parse_Cache(data) {
  var col = [];
  var num = data.match(/^<c:numCache>/);
  var f;
  (data.match(/<c:pt idx="(\d*)"[^<>\/]*><c:v>([^<])<\/c:v><\/c:pt>/mg) || []).forEach(function(pt) {
    var q = pt.match(/<c:pt idx="(\d*)"[^<>\/]*><c:v>([^<]*)<\/c:v><\/c:pt>/);
    if (!q) return;
    col[+q[1]] = num ? +q[2] : q[2];
  });
  var nf = unescapexml((str_match_xml(data, "c:formatCode") || ["", "General"])[1]);
  (str_match_ng(data, "<c:f>", "</c:f>") || []).forEach(function(F) {
    f = F.replace(/<[^<>]*>/g, "");
  });
  return [col, nf, f];
}
function parse_chart(data, name, opts, rels, wb, csheet) {
  var cs = csheet || { "!type": "chart" };
  if (!data) return csheet;
  var C2 = 0, R = 0, col = "A";
  var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  (str_match_ng(data, "<c:numCache>", "</c:numCache>") || []).forEach(function(nc) {
    var cache = parse_Cache(nc);
    refguess.s.r = refguess.s.c = 0;
    refguess.e.c = C2;
    col = encode_col(C2);
    cache[0].forEach(function(n, i) {
      if (cs["!data"]) {
        if (!cs["!data"][i]) cs["!data"][i] = [];
        cs["!data"][i][C2] = { t: "n", v: n, z: cache[1] };
      } else cs[col + encode_row(i)] = { t: "n", v: n, z: cache[1] };
      R = i;
    });
    if (refguess.e.r < R) refguess.e.r = R;
    ++C2;
  });
  if (C2 > 0) cs["!ref"] = encode_range(refguess);
  return cs;
}
function parse_cs_xml(data, opts, idx, rels, wb) {
  if (!data) return data;
  if (!rels) rels = { "!id": {} };
  var s = { "!type": "chart", "!drawel": null, "!rel": "" };
  var m;
  var sheetPr = data.match(sheetprregex);
  if (sheetPr) parse_ws_xml_sheetpr(sheetPr[0], s, wb, idx);
  if (m = data.match(/drawing r:id="(.*?)"/)) s["!rel"] = m[1];
  if (rels["!id"][s["!rel"]]) s["!drawel"] = rels["!id"][s["!rel"]];
  return s;
}
function parse_BrtCsProp(data, length) {
  data.l += 10;
  var name = parse_XLWideString(data);
  return { name };
}
function parse_cs_bin(data, opts, idx, rels, wb) {
  if (!data) return data;
  if (!rels) rels = { "!id": {} };
  var s = { "!type": "chart", "!drawel": null, "!rel": "" };
  var pass = false;
  recordhopper(data, function cs_parse(val, R, RT) {
    switch (RT) {
      case 550:
        s["!rel"] = val;
        break;
      case 651:
        if (!wb.Sheets[idx]) wb.Sheets[idx] = {};
        if (val.name) wb.Sheets[idx].CodeName = val.name;
        break;
      case 562:
      case 652:
      case 669:
      case 679:
      case 551:
      case 552:
      case 476:
      case 3072:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      case 37:
        break;
      case 38:
        break;
      default:
        if (R.T > 0) ;
        else if (R.T < 0) ;
        else if (!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  }, opts);
  if (rels["!id"][s["!rel"]]) s["!drawel"] = rels["!id"][s["!rel"]];
  return s;
}
var WBPropsDef = [
  ["allowRefreshQuery", false, "bool"],
  ["autoCompressPictures", true, "bool"],
  ["backupFile", false, "bool"],
  ["checkCompatibility", false, "bool"],
  ["CodeName", ""],
  ["date1904", false, "bool"],
  ["defaultThemeVersion", 0, "int"],
  ["filterPrivacy", false, "bool"],
  ["hidePivotFieldList", false, "bool"],
  ["promptedSolutions", false, "bool"],
  ["publishItems", false, "bool"],
  ["refreshAllConnections", false, "bool"],
  ["saveExternalLinkValues", true, "bool"],
  ["showBorderUnselectedTables", true, "bool"],
  ["showInkAnnotation", true, "bool"],
  ["showObjects", "all"],
  ["showPivotChartFilter", false, "bool"],
  ["updateLinks", "userSet"]
];
var WBViewDef = [
  ["activeTab", 0, "int"],
  ["autoFilterDateGrouping", true, "bool"],
  ["firstSheet", 0, "int"],
  ["minimized", false, "bool"],
  ["showHorizontalScroll", true, "bool"],
  ["showSheetTabs", true, "bool"],
  ["showVerticalScroll", true, "bool"],
  ["tabRatio", 600, "int"],
  ["visibility", "visible"]
  //window{Height,Width}, {x,y}Window
];
var SheetDef = [
  //['state', 'visible']
];
var CalcPrDef = [
  ["calcCompleted", "true"],
  ["calcMode", "auto"],
  ["calcOnSave", "true"],
  ["concurrentCalc", "true"],
  ["fullCalcOnLoad", "false"],
  ["fullPrecision", "true"],
  ["iterate", "false"],
  ["iterateCount", "100"],
  ["iterateDelta", "0.001"],
  ["refMode", "A1"]
];
function push_defaults_array(target, defaults) {
  for (var j = 0; j != target.length; ++j) {
    var w = target[j];
    for (var i = 0; i != defaults.length; ++i) {
      var z = defaults[i];
      if (w[z[0]] == null) w[z[0]] = z[1];
      else switch (z[2]) {
        case "bool":
          if (typeof w[z[0]] == "string") w[z[0]] = parsexmlbool(w[z[0]]);
          break;
        case "int":
          if (typeof w[z[0]] == "string") w[z[0]] = parseInt(w[z[0]], 10);
          break;
      }
    }
  }
}
function push_defaults(target, defaults) {
  for (var i = 0; i != defaults.length; ++i) {
    var z = defaults[i];
    if (target[z[0]] == null) target[z[0]] = z[1];
    else switch (z[2]) {
      case "bool":
        if (typeof target[z[0]] == "string") target[z[0]] = parsexmlbool(target[z[0]]);
        break;
      case "int":
        if (typeof target[z[0]] == "string") target[z[0]] = parseInt(target[z[0]], 10);
        break;
    }
  }
}
function parse_wb_defaults(wb) {
  push_defaults(wb.WBProps, WBPropsDef);
  push_defaults(wb.CalcPr, CalcPrDef);
  push_defaults_array(wb.WBView, WBViewDef);
  push_defaults_array(wb.Sheets, SheetDef);
  _ssfopts.date1904 = parsexmlbool(wb.WBProps.date1904);
}
var badchars = /* @__PURE__ */ ":][*?/\\".split("");
function check_ws_name(n, safe) {
  try {
    if (n == "") throw new Error("Sheet name cannot be blank");
    if (n.length > 31) throw new Error("Sheet name cannot exceed 31 chars");
    if (n.charCodeAt(0) == 39 || n.charCodeAt(n.length - 1) == 39) throw new Error("Sheet name cannot start or end with apostrophe (')");
    if (n.toLowerCase() == "history") throw new Error("Sheet name cannot be 'History'");
    badchars.forEach(function(c2) {
      if (n.indexOf(c2) == -1) return;
      throw new Error("Sheet name cannot contain : \\ / ? * [ ]");
    });
  } catch (e) {
    throw e;
  }
  return true;
}
var wbnsregex = /<\w+:workbook/;
function parse_wb_xml(data, opts) {
  if (!data) throw new Error("Could not find file");
  var wb = (
    /*::(*/
    { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, Names: [], xmlns: "" }
  );
  var pass = false, xmlns = "xmlns";
  var dname = {}, dnstart = 0;
  data.replace(tagregex, function xml_wb(x, idx) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<?xml":
        break;
      case "<workbook":
        if (x.match(wbnsregex)) xmlns = "xmlns" + x.match(/<(\w+):/)[1];
        wb.xmlns = y[xmlns];
        break;
      case "</workbook>":
        break;
      case "<fileVersion":
        delete y[0];
        wb.AppVersion = y;
        break;
      case "<fileVersion/>":
      case "</fileVersion>":
        break;
      case "<fileSharing":
        break;
      case "<fileSharing/>":
        break;
      case "<workbookPr":
      case "<workbookPr/>":
        WBPropsDef.forEach(function(w) {
          if (y[w[0]] == null) return;
          switch (w[2]) {
            case "bool":
              wb.WBProps[w[0]] = parsexmlbool(y[w[0]]);
              break;
            case "int":
              wb.WBProps[w[0]] = parseInt(y[w[0]], 10);
              break;
            default:
              wb.WBProps[w[0]] = y[w[0]];
          }
        });
        if (y.codeName) wb.WBProps.CodeName = utf8read(y.codeName);
        break;
      case "</workbookPr>":
        break;
      case "<workbookProtection":
        break;
      case "<workbookProtection/>":
        break;
      case "<bookViews":
      case "<bookViews>":
      case "</bookViews>":
        break;
      case "<workbookView":
      case "<workbookView/>":
        delete y[0];
        wb.WBView.push(y);
        break;
      case "</workbookView>":
        break;
      case "<sheets":
      case "<sheets>":
      case "</sheets>":
        break;
      case "<sheet":
        switch (y.state) {
          case "hidden":
            y.Hidden = 1;
            break;
          case "veryHidden":
            y.Hidden = 2;
            break;
          default:
            y.Hidden = 0;
        }
        delete y.state;
        y.name = unescapexml(utf8read(y.name));
        delete y[0];
        wb.Sheets.push(y);
        break;
      case "</sheet>":
        break;
      case "<functionGroups":
      case "<functionGroups/>":
        break;
      case "<functionGroup":
        break;
      case "<externalReferences":
      case "</externalReferences>":
      case "<externalReferences>":
        break;
      case "<externalReference":
        break;
      case "<definedNames/>":
        break;
      case "<definedNames>":
      case "<definedNames":
        pass = true;
        break;
      case "</definedNames>":
        pass = false;
        break;
      case "<definedName":
        {
          dname = {};
          dname.Name = utf8read(y.name);
          if (y.comment) dname.Comment = y.comment;
          if (y.localSheetId) dname.Sheet = +y.localSheetId;
          if (parsexmlbool(y.hidden || "0")) dname.Hidden = true;
          dnstart = idx + x.length;
        }
        break;
      case "</definedName>":
        {
          dname.Ref = unescapexml(utf8read(data.slice(dnstart, idx)));
          wb.Names.push(dname);
        }
        break;
      case "<definedName/>":
        break;
      case "<calcPr":
        delete y[0];
        wb.CalcPr = y;
        break;
      case "<calcPr/>":
        delete y[0];
        wb.CalcPr = y;
        break;
      case "</calcPr>":
        break;
      case "<oleSize":
        break;
      case "<customWorkbookViews>":
      case "</customWorkbookViews>":
      case "<customWorkbookViews":
        break;
      case "<customWorkbookView":
      case "</customWorkbookView>":
        break;
      case "<pivotCaches>":
      case "</pivotCaches>":
      case "<pivotCaches":
        break;
      case "<pivotCache":
        break;
      case "<smartTagPr":
      case "<smartTagPr/>":
        break;
      case "<smartTagTypes":
      case "<smartTagTypes>":
      case "</smartTagTypes>":
        break;
      case "<smartTagType":
        break;
      case "<webPublishing":
      case "<webPublishing/>":
        break;
      case "<fileRecoveryPr":
      case "<fileRecoveryPr/>":
        break;
      case "<webPublishObjects>":
      case "<webPublishObjects":
      case "</webPublishObjects>":
        break;
      case "<webPublishObject":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      case "<ArchID":
        break;
      case "<AlternateContent":
      case "<AlternateContent>":
        pass = true;
        break;
      case "</AlternateContent>":
        pass = false;
        break;
      case "<revisionPtr":
        break;
      default:
        if (!pass && opts.WTF) throw new Error("unrecognized " + y[0] + " in workbook");
    }
    return x;
  });
  if (XMLNS_main.indexOf(wb.xmlns) === -1) throw new Error("Unknown Namespace: " + wb.xmlns);
  parse_wb_defaults(wb);
  return wb;
}
function parse_BrtBundleSh(data, length) {
  var z = {};
  z.Hidden = data.read_shift(4);
  z.iTabID = data.read_shift(4);
  z.strRelID = parse_RelID(data);
  z.name = parse_XLWideString(data);
  return z;
}
function parse_BrtWbProp(data, length) {
  var o = {};
  var flags = data.read_shift(4);
  o.defaultThemeVersion = data.read_shift(4);
  var strName = length > 8 ? parse_XLWideString(data) : "";
  if (strName.length > 0) o.CodeName = strName;
  o.autoCompressPictures = !!(flags & 65536);
  o.backupFile = !!(flags & 64);
  o.checkCompatibility = !!(flags & 4096);
  o.date1904 = !!(flags & 1);
  o.filterPrivacy = !!(flags & 8);
  o.hidePivotFieldList = !!(flags & 1024);
  o.promptedSolutions = !!(flags & 16);
  o.publishItems = !!(flags & 2048);
  o.refreshAllConnections = !!(flags & 262144);
  o.saveExternalLinkValues = !!(flags & 128);
  o.showBorderUnselectedTables = !!(flags & 4);
  o.showInkAnnotation = !!(flags & 32);
  o.showObjects = ["all", "placeholders", "none"][flags >> 13 & 3];
  o.showPivotChartFilter = !!(flags & 32768);
  o.updateLinks = ["userSet", "never", "always"][flags >> 8 & 3];
  return o;
}
function parse_BrtFRTArchID$(data, length) {
  var o = {};
  data.read_shift(4);
  o.ArchID = data.read_shift(4);
  data.l += length - 8;
  return o;
}
function parse_BrtName(data, length, opts) {
  var end = data.l + length;
  var flags = data.read_shift(4);
  data.l += 1;
  var itab = data.read_shift(4);
  var name = parse_XLNameWideString(data);
  var formula;
  var comment = "";
  try {
    formula = parse_XLSBNameParsedFormula(data, 0, opts);
    try {
      comment = parse_XLNullableWideString(data);
    } catch (e) {
    }
  } catch (e) {
    console.error("Could not parse defined name " + name);
  }
  if (flags & 32) name = "_xlnm." + name;
  data.l = end;
  var out = { Name: name, Ptg: formula, Flags: flags };
  if (itab < 268435455) out.Sheet = itab;
  if (comment) out.Comment = comment;
  return out;
}
function parse_wb_bin(data, opts) {
  var wb = { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, xmlns: "" };
  var state = [];
  var pass = false;
  if (!opts) opts = {};
  opts.biff = 12;
  var Names = [];
  var supbooks = [[]];
  supbooks.SheetNames = [];
  supbooks.XTI = [];
  XLSBRecordEnum[16] = { n: "BrtFRTArchID$", f: parse_BrtFRTArchID$ };
  recordhopper(data, function hopper_wb(val, R, RT) {
    switch (RT) {
      case 156:
        supbooks.SheetNames.push(val.name);
        wb.Sheets.push(val);
        break;
      case 153:
        wb.WBProps = val;
        break;
      case 39:
        if (val.Sheet != null) opts.SID = val.Sheet;
        val.Ref = val.Ptg ? stringify_formula(val.Ptg, null, null, supbooks, opts) : "#REF!";
        delete opts.SID;
        delete val.Ptg;
        Names.push(val);
        break;
      case 1036:
        break;
      case 357:
      case 358:
      case 355:
      case 667:
        if (!supbooks[0].length) supbooks[0] = [RT, val];
        else supbooks.push([RT, val]);
        supbooks[supbooks.length - 1].XTI = [];
        break;
      case 362:
        if (supbooks.length === 0) {
          supbooks[0] = [];
          supbooks[0].XTI = [];
        }
        supbooks[supbooks.length - 1].XTI = supbooks[supbooks.length - 1].XTI.concat(val);
        supbooks.XTI = supbooks.XTI.concat(val);
        break;
      case 361:
        break;
      case 2071:
      case 158:
      case 143:
      case 664:
      case 353:
        break;
      case 3072:
      case 3073:
      case 534:
      case 677:
      case 157:
      case 610:
      case 2050:
      case 155:
      case 548:
      case 676:
      case 128:
      case 665:
      case 2128:
      case 2125:
      case 549:
      case 2053:
      case 596:
      case 2076:
      case 2075:
      case 2082:
      case 397:
      case 154:
      case 1117:
      case 553:
      case 2091:
        break;
      case 35:
        state.push(RT);
        pass = true;
        break;
      case 36:
        state.pop();
        pass = false;
        break;
      case 37:
        state.push(RT);
        pass = true;
        break;
      case 38:
        state.pop();
        pass = false;
        break;
      case 16:
        break;
      default:
        if (R.T) ;
        else if (!pass || opts.WTF && state[state.length - 1] != 37 && state[state.length - 1] != 35) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  }, opts);
  parse_wb_defaults(wb);
  wb.Names = Names;
  wb.supbooks = supbooks;
  return wb;
}
function parse_wb(data, name, opts) {
  if (name.slice(-4) === ".bin") return parse_wb_bin(data, opts);
  return parse_wb_xml(data, opts);
}
function parse_ws(data, name, idx, opts, rels, wb, themes, styles) {
  if (name.slice(-4) === ".bin") return parse_ws_bin(data, opts, idx, rels, wb, themes, styles);
  return parse_ws_xml(data, opts, idx, rels, wb, themes, styles);
}
function parse_cs(data, name, idx, opts, rels, wb, themes, styles) {
  if (name.slice(-4) === ".bin") return parse_cs_bin(data, opts, idx, rels, wb);
  return parse_cs_xml(data, opts, idx, rels, wb);
}
function parse_ms(data, name, idx, opts, rels, wb, themes, styles) {
  if (name.slice(-4) === ".bin") return parse_ms_bin();
  return parse_ms_xml();
}
function parse_ds(data, name, idx, opts, rels, wb, themes, styles) {
  if (name.slice(-4) === ".bin") return parse_ds_bin();
  return parse_ds_xml();
}
function parse_sty(data, name, themes, opts) {
  if (name.slice(-4) === ".bin") return parse_sty_bin(data, themes, opts);
  return parse_sty_xml(data, themes, opts);
}
function parse_sst(data, name, opts) {
  if (name.slice(-4) === ".bin") return parse_sst_bin(data, opts);
  return parse_sst_xml(data, opts);
}
function parse_cmnt(data, name, opts) {
  if (name.slice(-4) === ".bin") return parse_comments_bin(data, opts);
  return parse_comments_xml(data, opts);
}
function parse_cc(data, name, opts) {
  if (name.slice(-4) === ".bin") return parse_cc_bin(data);
  return parse_cc_xml(data);
}
function parse_xlink(data, rel, name, opts) {
  if (name.slice(-4) === ".bin") return parse_xlink_bin(data, rel, name, opts);
  return parse_xlink_xml();
}
function parse_xlmeta(data, name, opts) {
  if (name.slice(-4) === ".bin") return parse_xlmeta_bin(data, name, opts);
  return parse_xlmeta_xml(data, name, opts);
}
var attregexg2 = /\b((?:\w+:)?[\w]+)=((?:")([^"]*)(?:")|(?:')([^']*)(?:'))/g;
var attregex2 = /\b((?:\w+:)?[\w]+)=((?:")(?:[^"]*)(?:")|(?:')(?:[^']*)(?:'))/;
function xlml_parsexmltag(tag, skip_root) {
  var words = tag.split(/\s+/);
  var z = [];
  z[0] = words[0];
  if (words.length === 1) return z;
  var m = tag.match(attregexg2), y, j, w, i;
  if (m) for (i = 0; i != m.length; ++i) {
    y = m[i].match(attregex2);
    if ((j = y[1].indexOf(":")) === -1) z[y[1]] = y[2].slice(1, y[2].length - 1);
    else {
      if (y[1].slice(0, 6) === "xmlns:") w = "xmlns" + y[1].slice(6);
      else w = y[1].slice(j + 1);
      z[w] = y[2].slice(1, y[2].length - 1);
    }
  }
  return z;
}
function xlml_parsexmltagobj(tag) {
  var words = tag.split(/\s+/);
  var z = {};
  if (words.length === 1) return z;
  var m = tag.match(attregexg2), y, j, w, i;
  if (m) for (i = 0; i != m.length; ++i) {
    y = m[i].match(attregex2);
    if ((j = y[1].indexOf(":")) === -1) z[y[1]] = y[2].slice(1, y[2].length - 1);
    else {
      if (y[1].slice(0, 6) === "xmlns:") w = "xmlns" + y[1].slice(6);
      else w = y[1].slice(j + 1);
      z[w] = y[2].slice(1, y[2].length - 1);
    }
  }
  return z;
}
var XLMLFormatMap;
function xlml_format(format2, value, date1904) {
  var fmt = XLMLFormatMap[format2] || unescapexml(format2);
  if (fmt === "General") return SSF_general(value);
  return SSF_format(fmt, value, { date1904: !!date1904 });
}
function xlml_set_custprop(Custprops, key2, cp, val) {
  var oval = val;
  switch ((cp[0].match(/dt:dt="([\w.]+)"/) || ["", ""])[1]) {
    case "boolean":
      oval = parsexmlbool(val);
      break;
    case "i2":
    case "int":
      oval = parseInt(val, 10);
      break;
    case "r4":
    case "float":
      oval = parseFloat(val);
      break;
    case "date":
    case "dateTime.tz":
      oval = parseDate(val);
      break;
    case "i8":
    case "string":
    case "fixed":
    case "uuid":
    case "bin.base64":
      break;
    default:
      throw new Error("bad custprop:" + cp[0]);
  }
  Custprops[unescapexml(key2)] = oval;
}
function safe_format_xlml(cell, nf, o, date1904) {
  if (cell.t === "z") return;
  if (!o || o.cellText !== false) try {
    if (cell.t === "e") {
      cell.w = cell.w || BErr[cell.v];
    } else if (nf === "General") {
      if (cell.t === "n") {
        if ((cell.v | 0) === cell.v) cell.w = cell.v.toString(10);
        else cell.w = SSF_general_num(cell.v);
      } else cell.w = SSF_general(cell.v);
    } else cell.w = xlml_format(nf || "General", cell.v, date1904);
  } catch (e) {
    if (o.WTF) throw e;
  }
  try {
    var z = XLMLFormatMap[nf] || nf || "General";
    if (o.cellNF) cell.z = z;
    if (o.cellDates && cell.t == "n" && fmt_is_date(z)) {
      var _d = SSF_parse_date_code(cell.v + (date1904 ? 1462 : 0));
      if (_d) {
        cell.t = "d";
        cell.v = new Date(Date.UTC(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u));
      }
    }
  } catch (e) {
    if (o.WTF) throw e;
  }
}
function process_style_xlml(styles, stag, opts) {
  if (opts.cellStyles) {
    if (stag.Interior) {
      var I = stag.Interior;
      if (I.Pattern) I.patternType = XLMLPatternTypeMap[I.Pattern] || I.Pattern;
    }
  }
  styles[stag.ID] = stag;
}
function parse_xlml_data(xml, ss, data, cell, base, styles, csty, row, arrayf, o, date1904) {
  var nf = "General", sid = cell.StyleID, S2 = {};
  o = o || {};
  var interiors = [];
  var i = 0;
  if (sid === void 0 && row) sid = row.StyleID;
  if (sid === void 0 && csty) sid = csty.StyleID;
  while (styles[sid] !== void 0) {
    var ssid = styles[sid];
    if (ssid.nf) nf = ssid.nf;
    if (ssid.Interior) interiors.push(ssid.Interior);
    if (!ssid.Parent) break;
    sid = ssid.Parent;
  }
  switch (data.Type) {
    case "Boolean":
      cell.t = "b";
      cell.v = parsexmlbool(xml);
      break;
    case "String":
      cell.t = "s";
      cell.r = xlml_fixstr(unescapexml(xml));
      cell.v = xml.indexOf("<") > -1 ? unescapexml(ss || xml).replace(/<[^<>]*>/g, "") : cell.r;
      break;
    case "DateTime":
      if (xml.slice(-1) != "Z") xml += "Z";
      cell.v = datenum(parseDate(xml, date1904), date1904);
      if (cell.v !== cell.v) cell.v = unescapexml(xml);
      if (!nf || nf == "General") nf = "yyyy-mm-dd";
    case "Number":
      if (cell.v === void 0) cell.v = +xml;
      if (!cell.t) cell.t = "n";
      break;
    case "Error":
      cell.t = "e";
      cell.v = RBErr[xml];
      if (o.cellText !== false) cell.w = xml;
      break;
    default:
      if (xml == "" && ss == "") {
        cell.t = "z";
      } else {
        cell.t = "s";
        cell.v = xlml_fixstr(ss || xml);
      }
      break;
  }
  safe_format_xlml(cell, nf, o, date1904);
  if (o.cellFormula !== false) {
    if (cell.Formula) {
      var fstr = unescapexml(cell.Formula);
      if (fstr.charCodeAt(0) == 61) fstr = fstr.slice(1);
      cell.f = rc_to_a1(fstr, base);
      delete cell.Formula;
      if (cell.ArrayRange == "RC") cell.F = rc_to_a1("RC:RC", base);
      else if (cell.ArrayRange) {
        cell.F = rc_to_a1(cell.ArrayRange, base);
        arrayf.push([safe_decode_range(cell.F), cell.F]);
      }
    } else {
      for (i = 0; i < arrayf.length; ++i)
        if (base.r >= arrayf[i][0].s.r && base.r <= arrayf[i][0].e.r) {
          if (base.c >= arrayf[i][0].s.c && base.c <= arrayf[i][0].e.c)
            cell.F = arrayf[i][1];
        }
    }
  }
  if (o.cellStyles) {
    interiors.forEach(function(x) {
      if (!S2.patternType && x.patternType) S2.patternType = x.patternType;
    });
    cell.s = S2;
  }
  if (cell.StyleID !== void 0) cell.ixfe = cell.StyleID;
}
function xlml_prefix_dname(dname) {
  return XLSLblBuiltIn.indexOf("_xlnm." + dname) > -1 ? "_xlnm." + dname : dname;
}
function xlml_clean_comment(comment) {
  comment.t = comment.v || "";
  comment.t = comment.t.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  comment.v = comment.w = comment.ixfe = void 0;
}
function parse_xlml_xml(d, _opts) {
  var opts = _opts || {};
  make_ssf();
  var str = debom(xlml_normalize(d));
  if (opts.type == "binary" || opts.type == "array" || opts.type == "base64") {
    str = utf8read(str);
  }
  var opening = str.slice(0, 1024).toLowerCase(), ishtml = false;
  opening = opening.replace(/".*?"/g, "");
  if ((opening.indexOf(">") & 1023) > Math.min(opening.indexOf(",") & 1023, opening.indexOf(";") & 1023)) {
    var _o = dup(opts);
    _o.type = "string";
    return PRN.to_workbook(str, _o);
  }
  if (opening.indexOf("<?xml") == -1) ["html", "table", "head", "meta", "script", "style", "div"].forEach(function(tag) {
    if (opening.indexOf("<" + tag) >= 0) ishtml = true;
  });
  if (ishtml) return html_to_workbook(str, opts);
  XLMLFormatMap = {
    "General Number": "General",
    "General Date": table_fmt[22],
    "Long Date": "dddd, mmmm dd, yyyy",
    "Medium Date": table_fmt[15],
    "Short Date": table_fmt[14],
    "Long Time": table_fmt[19],
    "Medium Time": table_fmt[18],
    "Short Time": table_fmt[20],
    "Currency": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
    "Fixed": table_fmt[2],
    "Standard": table_fmt[4],
    "Percent": table_fmt[10],
    "Scientific": table_fmt[11],
    "Yes/No": '"Yes";"Yes";"No";@',
    "True/False": '"True";"True";"False";@',
    "On/Off": '"Yes";"Yes";"No";@'
  };
  var Rn;
  var state = [], tmp;
  var sheets = {}, sheetnames = [], cursheet = {}, sheetname = "";
  if (opts.dense) cursheet["!data"] = [];
  var cell = {}, row = {};
  var dtag = xlml_parsexmltag('<Data ss:Type="String">'), didx = 0;
  var c2 = 0, r = 0;
  var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  var styles = {}, stag = {};
  var ss = "", fidx = 0;
  var merges = [];
  var Props = {}, Custprops = {}, pidx = 0, cp = [];
  var comments = [], comment = {};
  var cstys = [], csty, seencol = false;
  var arrayf = [];
  var rowinfo = [], rowobj = {}, cc = 0, rr = 0;
  var Workbook = { Sheets: [], WBProps: { date1904: false } }, wsprops = {};
  xlmlregex.lastIndex = 0;
  str = str_remove_ng(str, "<!--", "-->");
  var raw_Rn3 = "";
  while (Rn = xlmlregex.exec(str)) switch (Rn[3] = (raw_Rn3 = Rn[3]).toLowerCase()) {
    case "data":
      if (raw_Rn3 == "data") {
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([Rn[3], true]);
        break;
      }
      if (state[state.length - 1][1]) break;
      if (Rn[1] === "/") parse_xlml_data(str.slice(didx, Rn.index), ss, dtag, state[state.length - 1][0] == /*"Comment"*/
      "comment" ? comment : cell, { c: c2, r }, styles, cstys[c2], row, arrayf, opts, Workbook.WBProps.date1904);
      else {
        ss = "";
        dtag = xlml_parsexmltag(Rn[0]);
        didx = Rn.index + Rn[0].length;
      }
      break;
    case "cell":
      if (Rn[1] === "/") {
        if (comments.length > 0) cell.c = comments;
        if ((!opts.sheetRows || opts.sheetRows > r) && cell.v !== void 0) {
          if (opts.dense) {
            if (!cursheet["!data"][r]) cursheet["!data"][r] = [];
            cursheet["!data"][r][c2] = cell;
          } else cursheet[encode_col(c2) + encode_row(r)] = cell;
        }
        if (cell.HRef) {
          cell.l = { Target: unescapexml(cell.HRef) };
          if (cell.HRefScreenTip) cell.l.Tooltip = cell.HRefScreenTip;
          delete cell.HRef;
          delete cell.HRefScreenTip;
        }
        if (cell.MergeAcross || cell.MergeDown) {
          cc = c2 + (parseInt(cell.MergeAcross, 10) | 0);
          rr = r + (parseInt(cell.MergeDown, 10) | 0);
          if (cc > c2 || rr > r) merges.push({ s: { c: c2, r }, e: { c: cc, r: rr } });
        }
        if (!opts.sheetStubs) {
          if (cell.MergeAcross) c2 = cc + 1;
          else ++c2;
        } else if (cell.MergeAcross || cell.MergeDown) {
          for (var cma = c2; cma <= cc; ++cma) {
            for (var cmd = r; cmd <= rr; ++cmd) {
              if (cma > c2 || cmd > r) {
                if (opts.dense) {
                  if (!cursheet["!data"][cmd]) cursheet["!data"][cmd] = [];
                  cursheet["!data"][cmd][cma] = { t: "z" };
                } else cursheet[encode_col(cma) + encode_row(cmd)] = { t: "z" };
              }
            }
          }
          c2 = cc + 1;
        } else ++c2;
      } else {
        cell = xlml_parsexmltagobj(Rn[0]);
        if (cell.Index) c2 = +cell.Index - 1;
        if (c2 < refguess.s.c) refguess.s.c = c2;
        if (c2 > refguess.e.c) refguess.e.c = c2;
        if (Rn[0].slice(-2) === "/>") ++c2;
        comments = [];
      }
      break;
    case "row":
      if (Rn[1] === "/" || Rn[0].slice(-2) === "/>") {
        if (r < refguess.s.r) refguess.s.r = r;
        if (r > refguess.e.r) refguess.e.r = r;
        if (Rn[0].slice(-2) === "/>") {
          row = xlml_parsexmltag(Rn[0]);
          if (row.Index) r = +row.Index - 1;
        }
        c2 = 0;
        ++r;
      } else {
        row = xlml_parsexmltag(Rn[0]);
        if (row.Index) r = +row.Index - 1;
        rowobj = {};
        if (row.AutoFitHeight == "0" || row.Height) {
          rowobj.hpx = parseInt(row.Height, 10);
          rowobj.hpt = px2pt(rowobj.hpx);
          rowinfo[r] = rowobj;
        }
        if (row.Hidden == "1") {
          rowobj.hidden = true;
          rowinfo[r] = rowobj;
        }
      }
      break;
    case "worksheet":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
        sheetnames.push(sheetname);
        if (refguess.s.r <= refguess.e.r && refguess.s.c <= refguess.e.c) {
          cursheet["!ref"] = encode_range(refguess);
          if (opts.sheetRows && opts.sheetRows <= refguess.e.r) {
            cursheet["!fullref"] = cursheet["!ref"];
            refguess.e.r = opts.sheetRows - 1;
            cursheet["!ref"] = encode_range(refguess);
          }
        }
        if (merges.length) cursheet["!merges"] = merges;
        if (cstys.length > 0) cursheet["!cols"] = cstys;
        if (rowinfo.length > 0) cursheet["!rows"] = rowinfo;
        sheets[sheetname] = cursheet;
      } else {
        refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
        r = c2 = 0;
        state.push([Rn[3], false]);
        tmp = xlml_parsexmltag(Rn[0]);
        sheetname = unescapexml(tmp.Name);
        cursheet = {};
        if (opts.dense) cursheet["!data"] = [];
        merges = [];
        arrayf = [];
        rowinfo = [];
        wsprops = { name: sheetname, Hidden: 0 };
        Workbook.Sheets.push(wsprops);
      }
      break;
    case "table":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
      } else if (Rn[0].slice(-2) == "/>") break;
      else {
        state.push([Rn[3], false]);
        cstys = [];
        seencol = false;
      }
      break;
    case "style":
      if (Rn[1] === "/") process_style_xlml(styles, stag, opts);
      else stag = xlml_parsexmltag(Rn[0]);
      break;
    case "numberformat":
      stag.nf = unescapexml(xlml_parsexmltag(Rn[0]).Format || "General");
      if (XLMLFormatMap[stag.nf]) stag.nf = XLMLFormatMap[stag.nf];
      for (var ssfidx = 0; ssfidx != 392; ++ssfidx) if (table_fmt[ssfidx] == stag.nf) break;
      if (ssfidx == 392) {
        for (ssfidx = 57; ssfidx != 392; ++ssfidx) if (table_fmt[ssfidx] == null) {
          SSF__load(stag.nf, ssfidx);
          break;
        }
      }
      break;
    case "column":
      if (state[state.length - 1][0] !== /*'Table'*/
      "table") break;
      if (Rn[1] === "/") break;
      csty = xlml_parsexmltag(Rn[0]);
      if (csty.Hidden) {
        csty.hidden = true;
        delete csty.Hidden;
      }
      if (csty.Width) csty.wpx = parseInt(csty.Width, 10);
      if (!seencol && csty.wpx > 10) {
        seencol = true;
        MDW = DEF_MDW;
        for (var _col = 0; _col < cstys.length; ++_col) if (cstys[_col]) process_col(cstys[_col]);
      }
      if (seencol) process_col(csty);
      cstys[csty.Index - 1 || cstys.length] = csty;
      for (var i = 0; i < +csty.Span; ++i) cstys[cstys.length] = dup(csty);
      break;
    case "namedrange":
      if (Rn[1] === "/") break;
      if (!Workbook.Names) Workbook.Names = [];
      var _NamedRange = parsexmltag(Rn[0]);
      var _DefinedName = {
        Name: xlml_prefix_dname(_NamedRange.Name),
        Ref: rc_to_a1(_NamedRange.RefersTo.slice(1), { r: 0, c: 0 })
      };
      if (Workbook.Sheets.length > 0) _DefinedName.Sheet = Workbook.Sheets.length - 1;
      Workbook.Names.push(_DefinedName);
      break;
    case "namedcell":
      break;
    case "b":
      break;
    case "i":
      break;
    case "u":
      break;
    case "s":
      break;
    case "em":
      break;
    case "h2":
      break;
    case "h3":
      break;
    case "sub":
      break;
    case "sup":
      break;
    case "span":
      break;
    case "alignment":
      break;
    case "borders":
      break;
    case "border":
      break;
    case "font":
      if (Rn[0].slice(-2) === "/>") break;
      else if (Rn[1] === "/") ss += str.slice(fidx, Rn.index);
      else fidx = Rn.index + Rn[0].length;
      break;
    case "interior":
      if (!opts.cellStyles) break;
      stag.Interior = xlml_parsexmltag(Rn[0]);
      break;
    case "protection":
      break;
    case "author":
    case "title":
    case "description":
    case "created":
    case "keywords":
    case "subject":
    case "category":
    case "company":
    case "lastauthor":
    case "lastsaved":
    case "lastprinted":
    case "version":
    case "revision":
    case "totaltime":
    case "hyperlinkbase":
    case "manager":
    case "contentstatus":
    case "identifier":
    case "language":
    case "appname":
      if (Rn[0].slice(-2) === "/>") break;
      else if (Rn[1] === "/") xlml_set_prop(Props, raw_Rn3, str.slice(pidx, Rn.index));
      else pidx = Rn.index + Rn[0].length;
      break;
    case "paragraphs":
      break;
    case "styles":
    case "workbook":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
      } else state.push([Rn[3], false]);
      break;
    case "comment":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
        xlml_clean_comment(comment);
        comments.push(comment);
      } else {
        state.push([Rn[3], false]);
        tmp = xlml_parsexmltag(Rn[0]);
        if (!parsexmlbool(tmp["ShowAlways"] || "0")) comments.hidden = true;
        comment = { a: tmp.Author };
      }
      break;
    case "autofilter":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
        var AutoFilter = xlml_parsexmltag(Rn[0]);
        cursheet["!autofilter"] = { ref: rc_to_a1(AutoFilter.Range).replace(/\$/g, "") };
        state.push([Rn[3], true]);
      }
      break;
    case "name":
      break;
    case "datavalidation":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
      } else {
        if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([Rn[3], true]);
      }
      break;
    case "pixelsperinch":
      break;
    case "componentoptions":
    case "documentproperties":
    case "customdocumentproperties":
    case "officedocumentsettings":
    case "pivottable":
    case "pivotcache":
    case "names":
    case "mapinfo":
    case "pagebreaks":
    case "querytable":
    case "sorting":
    case "schema":
    case "conditionalformatting":
    case "smarttagtype":
    case "smarttags":
    case "excelworkbook":
    case "workbookoptions":
    case "worksheetoptions":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([Rn[3], true]);
      break;
    case "null":
      break;
    default:
      if (state.length == 0 && Rn[3] == "document") return parse_fods(str, opts);
      if (state.length == 0 && Rn[3] == "uof") return parse_fods(str, opts);
      var seen2 = true;
      switch (state[state.length - 1][0]) {
        case "officedocumentsettings":
          switch (Rn[3]) {
            case "allowpng":
              break;
            case "removepersonalinformation":
              break;
            case "downloadcomponents":
              break;
            case "locationofcomponents":
              break;
            case "colors":
              break;
            case "color":
              break;
            case "index":
              break;
            case "rgb":
              break;
            case "targetscreensize":
              break;
            case "readonlyrecommended":
              break;
            default:
              seen2 = false;
          }
          break;
        case "componentoptions":
          switch (Rn[3]) {
            case "toolbar":
              break;
            case "hideofficelogo":
              break;
            case "spreadsheetautofit":
              break;
            case "label":
              break;
            case "caption":
              break;
            case "maxheight":
              break;
            case "maxwidth":
              break;
            case "nextsheetnumber":
              break;
            default:
              seen2 = false;
          }
          break;
        case "excelworkbook":
          switch (Rn[3]) {
            case "date1904":
              Workbook.WBProps.date1904 = true;
              break;
            case "hidehorizontalscrollbar":
              break;
            case "hideverticalscrollbar":
              break;
            case "hideworkbooktabs":
              break;
            case "windowheight":
              break;
            case "windowwidth":
              break;
            case "windowtopx":
              break;
            case "windowtopy":
              break;
            case "tabratio":
              break;
            case "protectstructure":
              break;
            case "protectwindow":
              break;
            case "protectwindows":
              break;
            case "activesheet":
              break;
            case "displayinknotes":
              break;
            case "firstvisiblesheet":
              break;
            case "supbook":
              break;
            case "sheetname":
              break;
            case "sheetindex":
              break;
            case "sheetindexfirst":
              break;
            case "sheetindexlast":
              break;
            case "dll":
              break;
            case "acceptlabelsinformulas":
              break;
            case "donotsavelinkvalues":
              break;
            case "iteration":
              break;
            case "maxiterations":
              break;
            case "maxchange":
              break;
            case "path":
              break;
            case "xct":
              break;
            case "count":
              break;
            case "selectedsheets":
              break;
            case "calculation":
              break;
            case "uncalced":
              break;
            case "startupprompt":
              break;
            case "crn":
              break;
            case "externname":
              break;
            case "formula":
              break;
            case "colfirst":
              break;
            case "collast":
              break;
            case "wantadvise":
              break;
            case "boolean":
              break;
            case "error":
              break;
            case "text":
              break;
            case "ole":
              break;
            case "noautorecover":
              break;
            case "publishobjects":
              break;
            case "donotcalculatebeforesave":
              break;
            case "number":
              break;
            case "refmoder1c1":
              break;
            case "embedsavesmarttags":
              break;
            default:
              seen2 = false;
          }
          break;
        case "workbookoptions":
          switch (Rn[3]) {
            case "owcversion":
              break;
            case "height":
              break;
            case "width":
              break;
            default:
              seen2 = false;
          }
          break;
        case "worksheetoptions":
          switch (Rn[3]) {
            case "visible":
              if (Rn[0].slice(-2) === "/>") ;
              else if (Rn[1] === "/") switch (str.slice(pidx, Rn.index)) {
                case "SheetHidden":
                  wsprops.Hidden = 1;
                  break;
                case "SheetVeryHidden":
                  wsprops.Hidden = 2;
                  break;
              }
              else pidx = Rn.index + Rn[0].length;
              break;
            case "header":
              if (!cursheet["!margins"]) default_margins(cursheet["!margins"] = {}, "xlml");
              if (!isNaN(+parsexmltag(Rn[0]).Margin)) cursheet["!margins"].header = +parsexmltag(Rn[0]).Margin;
              break;
            case "footer":
              if (!cursheet["!margins"]) default_margins(cursheet["!margins"] = {}, "xlml");
              if (!isNaN(+parsexmltag(Rn[0]).Margin)) cursheet["!margins"].footer = +parsexmltag(Rn[0]).Margin;
              break;
            case "pagemargins":
              var pagemargins = parsexmltag(Rn[0]);
              if (!cursheet["!margins"]) default_margins(cursheet["!margins"] = {}, "xlml");
              if (!isNaN(+pagemargins.Top)) cursheet["!margins"].top = +pagemargins.Top;
              if (!isNaN(+pagemargins.Left)) cursheet["!margins"].left = +pagemargins.Left;
              if (!isNaN(+pagemargins.Right)) cursheet["!margins"].right = +pagemargins.Right;
              if (!isNaN(+pagemargins.Bottom)) cursheet["!margins"].bottom = +pagemargins.Bottom;
              break;
            case "displayrighttoleft":
              if (!Workbook.Views) Workbook.Views = [];
              if (!Workbook.Views[0]) Workbook.Views[0] = {};
              Workbook.Views[0].RTL = true;
              break;
            case "freezepanes":
              break;
            case "frozennosplit":
              break;
            case "splithorizontal":
            case "splitvertical":
              break;
            case "donotdisplaygridlines":
              break;
            case "activerow":
              break;
            case "activecol":
              break;
            case "toprowbottompane":
              break;
            case "leftcolumnrightpane":
              break;
            case "unsynced":
              break;
            case "print":
              break;
            case "printerrors":
              break;
            case "panes":
              break;
            case "scale":
              break;
            case "pane":
              break;
            case "number":
              break;
            case "layout":
              break;
            case "pagesetup":
              break;
            case "selected":
              break;
            case "protectobjects":
              break;
            case "enableselection":
              break;
            case "protectscenarios":
              break;
            case "validprinterinfo":
              break;
            case "horizontalresolution":
              break;
            case "verticalresolution":
              break;
            case "numberofcopies":
              break;
            case "activepane":
              break;
            case "toprowvisible":
              break;
            case "leftcolumnvisible":
              break;
            case "fittopage":
              break;
            case "rangeselection":
              break;
            case "papersizeindex":
              break;
            case "pagelayoutzoom":
              break;
            case "pagebreakzoom":
              break;
            case "filteron":
              break;
            case "fitwidth":
              break;
            case "fitheight":
              break;
            case "commentslayout":
              break;
            case "zoom":
              break;
            case "lefttoright":
              break;
            case "gridlines":
              break;
            case "allowsort":
              break;
            case "allowfilter":
              break;
            case "allowinsertrows":
              break;
            case "allowdeleterows":
              break;
            case "allowinsertcols":
              break;
            case "allowdeletecols":
              break;
            case "allowinserthyperlinks":
              break;
            case "allowformatcells":
              break;
            case "allowsizecols":
              break;
            case "allowsizerows":
              break;
            case "nosummaryrowsbelowdetail":
              if (!cursheet["!outline"]) cursheet["!outline"] = {};
              cursheet["!outline"].above = true;
              break;
            case "tabcolorindex":
              break;
            case "donotdisplayheadings":
              break;
            case "showpagelayoutzoom":
              break;
            case "nosummarycolumnsrightdetail":
              if (!cursheet["!outline"]) cursheet["!outline"] = {};
              cursheet["!outline"].left = true;
              break;
            case "blackandwhite":
              break;
            case "donotdisplayzeros":
              break;
            case "displaypagebreak":
              break;
            case "rowcolheadings":
              break;
            case "donotdisplayoutline":
              break;
            case "noorientation":
              break;
            case "allowusepivottables":
              break;
            case "zeroheight":
              break;
            case "viewablerange":
              break;
            case "selection":
              break;
            case "protectcontents":
              break;
            default:
              seen2 = false;
          }
          break;
        case "pivottable":
        case "pivotcache":
          switch (Rn[3]) {
            case "immediateitemsondrop":
              break;
            case "showpagemultipleitemlabel":
              break;
            case "compactrowindent":
              break;
            case "location":
              break;
            case "pivotfield":
              break;
            case "orientation":
              break;
            case "layoutform":
              break;
            case "layoutsubtotallocation":
              break;
            case "layoutcompactrow":
              break;
            case "position":
              break;
            case "pivotitem":
              break;
            case "datatype":
              break;
            case "datafield":
              break;
            case "sourcename":
              break;
            case "parentfield":
              break;
            case "ptlineitems":
              break;
            case "ptlineitem":
              break;
            case "countofsameitems":
              break;
            case "item":
              break;
            case "itemtype":
              break;
            case "ptsource":
              break;
            case "cacheindex":
              break;
            case "consolidationreference":
              break;
            case "filename":
              break;
            case "reference":
              break;
            case "nocolumngrand":
              break;
            case "norowgrand":
              break;
            case "blanklineafteritems":
              break;
            case "hidden":
              break;
            case "subtotal":
              break;
            case "basefield":
              break;
            case "mapchilditems":
              break;
            case "function":
              break;
            case "refreshonfileopen":
              break;
            case "printsettitles":
              break;
            case "mergelabels":
              break;
            case "defaultversion":
              break;
            case "refreshname":
              break;
            case "refreshdate":
              break;
            case "refreshdatecopy":
              break;
            case "versionlastrefresh":
              break;
            case "versionlastupdate":
              break;
            case "versionupdateablemin":
              break;
            case "versionrefreshablemin":
              break;
            case "calculation":
              break;
            default:
              seen2 = false;
          }
          break;
        case "pagebreaks":
          switch (Rn[3]) {
            case "colbreaks":
              break;
            case "colbreak":
              break;
            case "rowbreaks":
              break;
            case "rowbreak":
              break;
            case "colstart":
              break;
            case "colend":
              break;
            case "rowend":
              break;
            default:
              seen2 = false;
          }
          break;
        case "autofilter":
          switch (Rn[3]) {
            case "autofiltercolumn":
              break;
            case "autofiltercondition":
              break;
            case "autofilterand":
              break;
            case "autofilteror":
              break;
            default:
              seen2 = false;
          }
          break;
        case "querytable":
          switch (Rn[3]) {
            case "id":
              break;
            case "autoformatfont":
              break;
            case "autoformatpattern":
              break;
            case "querysource":
              break;
            case "querytype":
              break;
            case "enableredirections":
              break;
            case "refreshedinxl9":
              break;
            case "urlstring":
              break;
            case "htmltables":
              break;
            case "connection":
              break;
            case "commandtext":
              break;
            case "refreshinfo":
              break;
            case "notitles":
              break;
            case "nextid":
              break;
            case "columninfo":
              break;
            case "overwritecells":
              break;
            case "donotpromptforfile":
              break;
            case "textwizardsettings":
              break;
            case "source":
              break;
            case "number":
              break;
            case "decimal":
              break;
            case "thousandseparator":
              break;
            case "trailingminusnumbers":
              break;
            case "formatsettings":
              break;
            case "fieldtype":
              break;
            case "delimiters":
              break;
            case "tab":
              break;
            case "comma":
              break;
            case "autoformatname":
              break;
            case "versionlastedit":
              break;
            case "versionlastrefresh":
              break;
            default:
              seen2 = false;
          }
          break;
        case "datavalidation":
          switch (Rn[3]) {
            case "range":
              break;
            case "type":
              break;
            case "min":
              break;
            case "max":
              break;
            case "sort":
              break;
            case "descending":
              break;
            case "order":
              break;
            case "casesensitive":
              break;
            case "value":
              break;
            case "errorstyle":
              break;
            case "errormessage":
              break;
            case "errortitle":
              break;
            case "inputmessage":
              break;
            case "inputtitle":
              break;
            case "combohide":
              break;
            case "inputhide":
              break;
            case "condition":
              break;
            case "qualifier":
              break;
            case "useblank":
              break;
            case "value1":
              break;
            case "value2":
              break;
            case "format":
              break;
            case "cellrangelist":
              break;
            default:
              seen2 = false;
          }
          break;
        case "sorting":
        case "conditionalformatting":
          switch (Rn[3]) {
            case "range":
              break;
            case "type":
              break;
            case "min":
              break;
            case "max":
              break;
            case "sort":
              break;
            case "descending":
              break;
            case "order":
              break;
            case "casesensitive":
              break;
            case "value":
              break;
            case "errorstyle":
              break;
            case "errormessage":
              break;
            case "errortitle":
              break;
            case "cellrangelist":
              break;
            case "inputmessage":
              break;
            case "inputtitle":
              break;
            case "combohide":
              break;
            case "inputhide":
              break;
            case "condition":
              break;
            case "qualifier":
              break;
            case "useblank":
              break;
            case "value1":
              break;
            case "value2":
              break;
            case "format":
              break;
            default:
              seen2 = false;
          }
          break;
        case "mapinfo":
        case "schema":
        case "data":
          switch (Rn[3]) {
            case "map":
              break;
            case "entry":
              break;
            case "range":
              break;
            case "xpath":
              break;
            case "field":
              break;
            case "xsdtype":
              break;
            case "filteron":
              break;
            case "aggregate":
              break;
            case "elementtype":
              break;
            case "attributetype":
              break;
            case "schema":
            case "element":
            case "complextype":
            case "datatype":
            case "all":
            case "attribute":
            case "extends":
              break;
            case "row":
              break;
            default:
              seen2 = false;
          }
          break;
        case "smarttags":
          break;
        default:
          seen2 = false;
          break;
      }
      if (seen2) break;
      if (Rn[3].match(/!\[CDATA/)) break;
      if (!state[state.length - 1][1]) throw "Unrecognized tag: " + Rn[3] + "|" + state.join("|");
      if (state[state.length - 1][0] === /*'CustomDocumentProperties'*/
      "customdocumentproperties") {
        if (Rn[0].slice(-2) === "/>") break;
        else if (Rn[1] === "/") xlml_set_custprop(Custprops, raw_Rn3, cp, str.slice(pidx, Rn.index));
        else {
          cp = Rn;
          pidx = Rn.index + Rn[0].length;
        }
        break;
      }
      if (opts.WTF) throw "Unrecognized tag: " + Rn[3] + "|" + state.join("|");
  }
  var out = {};
  if (!opts.bookSheets && !opts.bookProps) out.Sheets = sheets;
  out.SheetNames = sheetnames;
  out.Workbook = Workbook;
  out.SSF = dup(table_fmt);
  out.Props = Props;
  out.Custprops = Custprops;
  out.bookType = "xlml";
  return out;
}
function parse_xlml(data, opts) {
  fix_read_opts(opts = opts || {});
  switch (opts.type || "base64") {
    case "base64":
      return parse_xlml_xml(Base64_decode(data), opts);
    case "binary":
    case "buffer":
    case "file":
      return parse_xlml_xml(data, opts);
    case "array":
      return parse_xlml_xml(a2s(data), opts);
  }
}
function parse_compobj(obj) {
  var v2 = {};
  var o = obj.content;
  o.l = 28;
  v2.AnsiUserType = o.read_shift(0, "lpstr-ansi");
  v2.AnsiClipboardFormat = parse_ClipboardFormatOrAnsiString(o);
  if (o.length - o.l <= 4) return v2;
  var m = o.read_shift(4);
  if (m == 0 || m > 40) return v2;
  o.l -= 4;
  v2.Reserved1 = o.read_shift(0, "lpstr-ansi");
  if (o.length - o.l <= 4) return v2;
  m = o.read_shift(4);
  if (m !== 1907505652) return v2;
  v2.UnicodeClipboardFormat = parse_ClipboardFormatOrUnicodeString(o);
  m = o.read_shift(4);
  if (m == 0 || m > 40) return v2;
  o.l -= 4;
  v2.Reserved2 = o.read_shift(0, "lpwstr");
}
var CONTINUE_RT = [60, 1084, 2066, 2165, 2175];
function slurp(RecordType, R, blob, length, opts) {
  var l2 = length;
  var bufs = [];
  var d = blob.slice(blob.l, blob.l + l2);
  if (opts.enc && opts.enc.insitu && d.length > 0) switch (RecordType) {
    case 9:
    case 521:
    case 1033:
    case 2057:
    case 47:
    case 405:
    case 225:
    case 406:
    case 312:
    case 404:
    case 10:
      break;
    case 133:
      break;
    default:
      opts.enc.insitu(d);
  }
  bufs.push(d);
  blob.l += l2;
  var nextrt = __readUInt16LE(blob, blob.l), next = XLSRecordEnum[nextrt];
  var start = 0;
  while (next != null && CONTINUE_RT.indexOf(nextrt) > -1) {
    l2 = __readUInt16LE(blob, blob.l + 2);
    start = blob.l + 4;
    if (nextrt == 2066) start += 4;
    else if (nextrt == 2165 || nextrt == 2175) {
      start += 12;
    }
    d = blob.slice(start, blob.l + 4 + l2);
    bufs.push(d);
    blob.l += 4 + l2;
    next = XLSRecordEnum[nextrt = __readUInt16LE(blob, blob.l)];
  }
  var b = bconcat(bufs);
  prep_blob(b, 0);
  var ll = 0;
  b.lens = [];
  for (var j = 0; j < bufs.length; ++j) {
    b.lens.push(ll);
    ll += bufs[j].length;
  }
  if (b.length < length) throw "XLS Record 0x" + RecordType.toString(16) + " Truncated: " + b.length + " < " + length;
  return R.f(b, b.length, opts);
}
function safe_format_xf(p, opts, date1904) {
  if (p.t === "z") return;
  if (!p.XF) return;
  var fmtid = 0;
  try {
    fmtid = p.z || p.XF.numFmtId || 0;
    if (opts.cellNF && p.z == null) p.z = table_fmt[fmtid];
  } catch (e) {
    if (opts.WTF) throw e;
  }
  if (!opts || opts.cellText !== false) try {
    if (p.t === "e") {
      p.w = p.w || BErr[p.v];
    } else if (fmtid === 0 || fmtid == "General") {
      if (p.t === "n") {
        if ((p.v | 0) === p.v) p.w = p.v.toString(10);
        else p.w = SSF_general_num(p.v);
      } else p.w = SSF_general(p.v);
    } else p.w = SSF_format(fmtid, p.v, { date1904: !!date1904, dateNF: opts && opts.dateNF });
  } catch (e) {
    if (opts.WTF) throw e;
  }
  if (opts.cellDates && fmtid && p.t == "n" && fmt_is_date(table_fmt[fmtid] || String(fmtid))) {
    var _d = SSF_parse_date_code(p.v + (date1904 ? 1462 : 0));
    if (_d) {
      p.t = "d";
      p.v = new Date(Date.UTC(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u));
    }
  }
}
function make_cell(val, ixfe, t) {
  return { v: val, ixfe, t };
}
function parse_workbook(blob, options) {
  var wb = { opts: {} };
  var Sheets = {};
  var out = {};
  if (options.dense) out["!data"] = [];
  var Directory = {};
  var range = {};
  var last_formula = null;
  var sst = [];
  var cur_sheet = "";
  var Preamble = {};
  var lastcell, last_cell = "", cc, cmnt, rngC, rngR;
  var sharedf = {};
  var arrayf = [];
  var temp_val;
  var country;
  var XFs = [];
  var palette = [];
  var Workbook = { Sheets: [], WBProps: { date1904: false }, Views: [{}] }, wsprops = {};
  var biff4w = false;
  var get_rgb = function getrgb(icv) {
    if (icv < 8) return XLSIcv[icv];
    if (icv < 64) return palette[icv - 8] || XLSIcv[icv];
    return XLSIcv[icv];
  };
  var process_cell_style = function pcs(line2, options2) {
    var xfd = line2.XF.data;
    if (!xfd || !xfd.patternType || !options2 || !options2.cellStyles) return;
    line2.s = {};
    line2.s.patternType = xfd.patternType;
    var t;
    if (t = rgb2Hex(get_rgb(xfd.icvFore))) {
      line2.s.fgColor = { rgb: t };
    }
    if (t = rgb2Hex(get_rgb(xfd.icvBack))) {
      line2.s.bgColor = { rgb: t };
    }
  };
  var addcell = function addcell2(cell, line2, options2) {
    if (!biff4w && file_depth > 1) return;
    if (options2.sheetRows && cell.r >= options2.sheetRows) return;
    if (options2.cellStyles && line2.XF && line2.XF.data) process_cell_style(line2, options2);
    delete line2.ixfe;
    delete line2.XF;
    lastcell = cell;
    last_cell = encode_cell(cell);
    if (!range || !range.s || !range.e) range = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
    if (cell.r < range.s.r) range.s.r = cell.r;
    if (cell.c < range.s.c) range.s.c = cell.c;
    if (cell.r + 1 > range.e.r) range.e.r = cell.r + 1;
    if (cell.c + 1 > range.e.c) range.e.c = cell.c + 1;
    if (options2.cellFormula && line2.f) {
      for (var afi = 0; afi < arrayf.length; ++afi) {
        if (arrayf[afi][0].s.c > cell.c || arrayf[afi][0].s.r > cell.r) continue;
        if (arrayf[afi][0].e.c < cell.c || arrayf[afi][0].e.r < cell.r) continue;
        line2.F = encode_range(arrayf[afi][0]);
        if (arrayf[afi][0].s.c != cell.c || arrayf[afi][0].s.r != cell.r) delete line2.f;
        if (line2.f) line2.f = "" + stringify_formula(arrayf[afi][1], range, cell, supbooks, opts);
        break;
      }
    }
    {
      if (options2.dense) {
        if (!out["!data"][cell.r]) out["!data"][cell.r] = [];
        out["!data"][cell.r][cell.c] = line2;
      } else out[last_cell] = line2;
    }
  };
  var opts = {
    enc: false,
    // encrypted
    sbcch: 0,
    // cch in the preceding SupBook
    snames: [],
    // sheetnames
    sharedf,
    // shared formulae by address
    arrayf,
    // array formulae array
    rrtabid: [],
    // RRTabId
    lastuser: "",
    // Last User from WriteAccess
    biff: 8,
    // BIFF version
    codepage: 0,
    // CP from CodePage record
    winlocked: 0,
    // fLockWn from WinProtect
    cellStyles: !!options && !!options.cellStyles,
    WTF: !!options && !!options.wtf
  };
  if (options.password) opts.password = options.password;
  var themes;
  var merges = [];
  var objects = [];
  var colinfo = [], rowinfo = [];
  var seencol = false;
  var supbooks = [];
  supbooks.SheetNames = opts.snames;
  supbooks.sharedf = opts.sharedf;
  supbooks.arrayf = opts.arrayf;
  supbooks.names = [];
  supbooks.XTI = [];
  var last_RT = 0;
  var file_depth = 0;
  var BIFF2Fmt = 0, BIFF2FmtTable = [];
  var FilterDatabases = [];
  var last_lbl;
  opts.codepage = 1200;
  set_cp(1200);
  var seen_codepage = false;
  while (blob.l < blob.length - 1) {
    var s = blob.l;
    var RecordType = blob.read_shift(2);
    if (RecordType === 0 && last_RT === 10) break;
    var length = blob.l === blob.length ? 0 : blob.read_shift(2);
    var R = XLSRecordEnum[RecordType];
    if (file_depth == 0 && [9, 521, 1033, 2057].indexOf(RecordType) == -1) break;
    if (R && R.f) {
      if (options.bookSheets) {
        if (last_RT === 133 && RecordType !== 133) break;
      }
      last_RT = RecordType;
      if (R.r === 2 || R.r == 12) {
        var rt = blob.read_shift(2);
        length -= 2;
        if (!opts.enc && rt !== RecordType && ((rt & 255) << 8 | rt >> 8) !== RecordType) throw new Error("rt mismatch: " + rt + "!=" + RecordType);
        if (R.r == 12) {
          blob.l += 10;
          length -= 10;
        }
      }
      var val = {};
      if (RecordType === 10) val = /*::(*/
      R.f(blob, length, opts);
      else val = /*::(*/
      slurp(RecordType, R, blob, length, opts);
      if (file_depth == 0 && [9, 521, 1033, 2057].indexOf(last_RT) === -1) continue;
      switch (RecordType) {
        case 34:
          wb.opts.Date1904 = Workbook.WBProps.date1904 = val;
          break;
        case 134:
          wb.opts.WriteProtect = true;
          break;
        case 47:
          if (!opts.enc) blob.l = 0;
          opts.enc = val;
          if (!options.password) throw new Error("File is password-protected");
          if (val.valid == null) throw new Error("Encryption scheme unsupported");
          if (!val.valid) throw new Error("Password is incorrect");
          break;
        case 92:
          opts.lastuser = val;
          break;
        case 66:
          var cpval = Number(val);
          switch (cpval) {
            case 21010:
              cpval = 1200;
              break;
            case 32768:
              cpval = 1e4;
              break;
            case 32769:
              cpval = 1252;
              break;
          }
          set_cp(opts.codepage = cpval);
          seen_codepage = true;
          break;
        case 317:
          opts.rrtabid = val;
          break;
        case 25:
          opts.winlocked = val;
          break;
        case 439:
          wb.opts["RefreshAll"] = val;
          break;
        case 12:
          wb.opts["CalcCount"] = val;
          break;
        case 16:
          wb.opts["CalcDelta"] = val;
          break;
        case 17:
          wb.opts["CalcIter"] = val;
          break;
        case 13:
          wb.opts["CalcMode"] = val;
          break;
        case 14:
          wb.opts["CalcPrecision"] = val;
          break;
        case 95:
          wb.opts["CalcSaveRecalc"] = val;
          break;
        case 15:
          opts.CalcRefMode = val;
          break;
        case 2211:
          wb.opts.FullCalc = val;
          break;
        case 129:
          if (val.fDialog) out["!type"] = "dialog";
          if (!val.fBelow) (out["!outline"] || (out["!outline"] = {})).above = true;
          if (!val.fRight) (out["!outline"] || (out["!outline"] = {})).left = true;
          break;
        case 67:
        case 579:
        case 1091:
        case 224:
          XFs.push(val);
          break;
        case 430:
          supbooks.push([val]);
          supbooks[supbooks.length - 1].XTI = [];
          break;
        case 35:
        case 547:
          supbooks[supbooks.length - 1].push(val);
          break;
        case 24:
        case 536:
          last_lbl = {
            Name: val.Name,
            Ref: stringify_formula(val.rgce, range, null, supbooks, opts)
          };
          if (val.itab > 0) last_lbl.Sheet = val.itab - 1;
          supbooks.names.push(last_lbl);
          if (!supbooks[0]) {
            supbooks[0] = [];
            supbooks[0].XTI = [];
          }
          supbooks[supbooks.length - 1].push(val);
          if (val.Name == "_xlnm._FilterDatabase" && val.itab > 0) {
            if (val.rgce && val.rgce[0] && val.rgce[0][0] && val.rgce[0][0][0] == "PtgArea3d")
              FilterDatabases[val.itab - 1] = { ref: encode_range(val.rgce[0][0][1][2]) };
          }
          break;
        case 22:
          opts.ExternCount = val;
          break;
        case 23:
          if (supbooks.length == 0) {
            supbooks[0] = [];
            supbooks[0].XTI = [];
          }
          supbooks[supbooks.length - 1].XTI = supbooks[supbooks.length - 1].XTI.concat(val);
          supbooks.XTI = supbooks.XTI.concat(val);
          break;
        case 2196:
          if (opts.biff < 8) break;
          if (last_lbl != null) last_lbl.Comment = val[1];
          break;
        case 18:
          out["!protect"] = val;
          break;
        case 19:
          if (val !== 0 && opts.WTF) console.error("Password verifier: " + val);
          break;
        case 133:
          {
            Directory[opts.biff == 4 ? opts.snames.length : val.pos] = val;
            opts.snames.push(val.name);
          }
          break;
        case 10:
          {
            if (--file_depth ? !biff4w : biff4w) break;
            if (range.e) {
              if (range.e.r > 0 && range.e.c > 0) {
                range.e.r--;
                range.e.c--;
                out["!ref"] = encode_range(range);
                if (options.sheetRows && options.sheetRows <= range.e.r) {
                  var tmpri = range.e.r;
                  range.e.r = options.sheetRows - 1;
                  out["!fullref"] = out["!ref"];
                  out["!ref"] = encode_range(range);
                  range.e.r = tmpri;
                }
                range.e.r++;
                range.e.c++;
              }
              if (merges.length > 0) out["!merges"] = merges;
              if (objects.length > 0) out["!objects"] = objects;
              if (colinfo.length > 0) out["!cols"] = colinfo;
              if (rowinfo.length > 0) out["!rows"] = rowinfo;
              Workbook.Sheets.push(wsprops);
            }
            if (cur_sheet === "") Preamble = out;
            else Sheets[cur_sheet] = out;
            out = {};
            if (options.dense) out["!data"] = [];
          }
          break;
        case 9:
        case 521:
        case 1033:
        case 2057:
          {
            if (opts.biff === 8) opts.biff = {
              9: 2,
              521: 3,
              1033: 4
            }[RecordType] || {
              512: 2,
              768: 3,
              1024: 4,
              1280: 5,
              1536: 8,
              2: 2,
              7: 2
            }[val.BIFFVer] || 8;
            opts.biffguess = val.BIFFVer == 0;
            if (val.BIFFVer == 0 && val.dt == 4096) {
              opts.biff = 5;
              seen_codepage = true;
              set_cp(opts.codepage = 28591);
            }
            if (opts.biff == 4 && val.dt & 256) biff4w = true;
            if (opts.biff == 8 && val.BIFFVer == 0 && val.dt == 16) opts.biff = 2;
            if (file_depth++ && !biff4w) break;
            out = {};
            if (options.dense) out["!data"] = [];
            if (opts.biff < 8 && !seen_codepage) {
              seen_codepage = true;
              set_cp(opts.codepage = options.codepage || 1252);
            }
            if (opts.biff == 4 && biff4w) {
              cur_sheet = (Directory[opts.snames.indexOf(cur_sheet) + 1] || { name: "" }).name;
            } else if (opts.biff < 5 || val.BIFFVer == 0 && val.dt == 4096) {
              if (cur_sheet === "") cur_sheet = "Sheet1";
              range = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
              var fakebs8 = { pos: blob.l - length, name: cur_sheet };
              Directory[fakebs8.pos] = fakebs8;
              opts.snames.push(cur_sheet);
            } else cur_sheet = (Directory[s] || { name: "" }).name;
            if (val.dt == 32) out["!type"] = "chart";
            if (val.dt == 64) out["!type"] = "macro";
            merges = [];
            objects = [];
            opts.arrayf = arrayf = [];
            colinfo = [];
            rowinfo = [];
            seencol = false;
            wsprops = { Hidden: (Directory[s] || { hs: 0 }).hs, name: cur_sheet };
          }
          break;
        case 515:
        case 3:
        case 2:
          {
            if (out["!type"] == "chart") {
              if (options.dense ? (out["!data"][val.r] || [])[val.c] : out[encode_col(val.c) + encode_row(val.r)]) ++val.c;
            }
            temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe] || {}, v: val.val, t: "n" };
            if (BIFF2Fmt > 0) temp_val.z = temp_val.XF && temp_val.XF.numFmtId && BIFF2FmtTable[temp_val.XF.numFmtId] || BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb.opts.Date1904);
            addcell({ c: val.c, r: val.r }, temp_val, options);
          }
          break;
        case 5:
        case 517:
          {
            temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe], v: val.val, t: val.t };
            if (BIFF2Fmt > 0) temp_val.z = temp_val.XF && temp_val.XF.numFmtId && BIFF2FmtTable[temp_val.XF.numFmtId] || BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb.opts.Date1904);
            addcell({ c: val.c, r: val.r }, temp_val, options);
          }
          break;
        case 638:
          {
            temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe], v: val.rknum, t: "n" };
            if (BIFF2Fmt > 0) temp_val.z = temp_val.XF && temp_val.XF.numFmtId && BIFF2FmtTable[temp_val.XF.numFmtId] || BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb.opts.Date1904);
            addcell({ c: val.c, r: val.r }, temp_val, options);
          }
          break;
        case 189:
          {
            for (var j = val.c; j <= val.C; ++j) {
              var ixfe = val.rkrec[j - val.c][0];
              temp_val = { ixfe, XF: XFs[ixfe], v: val.rkrec[j - val.c][1], t: "n" };
              if (BIFF2Fmt > 0) temp_val.z = temp_val.XF && temp_val.XF.numFmtId && BIFF2FmtTable[temp_val.XF.numFmtId] || BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
              safe_format_xf(temp_val, options, wb.opts.Date1904);
              addcell({ c: j, r: val.r }, temp_val, options);
            }
          }
          break;
        case 6:
        case 518:
        case 1030:
          {
            if (val.val == "String") {
              last_formula = val;
              break;
            }
            temp_val = make_cell(val.val, val.cell.ixfe, val.tt);
            temp_val.XF = XFs[temp_val.ixfe];
            if (options.cellFormula) {
              var _f = val.formula;
              if (_f && _f[0] && _f[0][0] && _f[0][0][0] == "PtgExp") {
                var _fr = _f[0][0][1][0], _fc = _f[0][0][1][1];
                var _fe = encode_cell({ r: _fr, c: _fc });
                if (sharedf[_fe]) temp_val.f = "" + stringify_formula(val.formula, range, val.cell, supbooks, opts);
                else temp_val.F = ((options.dense ? (out["!data"][_fr] || [])[_fc] : out[_fe]) || {}).F;
              } else temp_val.f = "" + stringify_formula(val.formula, range, val.cell, supbooks, opts);
            }
            if (BIFF2Fmt > 0) temp_val.z = temp_val.XF && temp_val.XF.numFmtId && BIFF2FmtTable[temp_val.XF.numFmtId] || BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb.opts.Date1904);
            addcell(val.cell, temp_val, options);
            last_formula = val;
          }
          break;
        case 7:
        case 519:
          {
            if (last_formula) {
              last_formula.val = val;
              temp_val = make_cell(val, last_formula.cell.ixfe, "s");
              temp_val.XF = XFs[temp_val.ixfe];
              if (options.cellFormula) {
                temp_val.f = "" + stringify_formula(last_formula.formula, range, last_formula.cell, supbooks, opts);
              }
              if (BIFF2Fmt > 0) temp_val.z = temp_val.XF && temp_val.XF.numFmtId && BIFF2FmtTable[temp_val.XF.numFmtId] || BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
              safe_format_xf(temp_val, options, wb.opts.Date1904);
              addcell(last_formula.cell, temp_val, options);
              last_formula = null;
            } else throw new Error("String record expects Formula");
          }
          break;
        case 33:
        case 545:
          {
            arrayf.push(val);
            var _arraystart = encode_cell(val[0].s);
            cc = options.dense ? (out["!data"][val[0].s.r] || [])[val[0].s.c] : out[_arraystart];
            if (options.cellFormula && cc) {
              if (!last_formula) break;
              if (!_arraystart || !cc) break;
              cc.f = "" + stringify_formula(val[1], range, val[0], supbooks, opts);
              cc.F = encode_range(val[0]);
            }
          }
          break;
        case 1212:
          {
            if (!options.cellFormula) break;
            if (last_cell) {
              if (!last_formula) break;
              sharedf[encode_cell(last_formula.cell)] = val[0];
              cc = options.dense ? (out["!data"][last_formula.cell.r] || [])[last_formula.cell.c] : out[encode_cell(last_formula.cell)];
              (cc || {}).f = "" + stringify_formula(val[0], range, lastcell, supbooks, opts);
            }
          }
          break;
        case 253:
          temp_val = make_cell(sst[val.isst].t, val.ixfe, "s");
          if (sst[val.isst].h) temp_val.h = sst[val.isst].h;
          temp_val.XF = XFs[temp_val.ixfe];
          if (BIFF2Fmt > 0) temp_val.z = temp_val.XF && temp_val.XF.numFmtId && BIFF2FmtTable[temp_val.XF.numFmtId] || BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
          safe_format_xf(temp_val, options, wb.opts.Date1904);
          addcell({ c: val.c, r: val.r }, temp_val, options);
          break;
        case 513:
          if (options.sheetStubs) {
            temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe], t: "z" };
            if (BIFF2Fmt > 0) temp_val.z = temp_val.XF && temp_val.XF.numFmtId && BIFF2FmtTable[temp_val.XF.numFmtId] || BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb.opts.Date1904);
            addcell({ c: val.c, r: val.r }, temp_val, options);
          }
          break;
        case 190:
          if (options.sheetStubs) {
            for (var _j = val.c; _j <= val.C; ++_j) {
              var _ixfe = val.ixfe[_j - val.c];
              temp_val = { ixfe: _ixfe, XF: XFs[_ixfe], t: "z" };
              if (BIFF2Fmt > 0) temp_val.z = temp_val.XF && temp_val.XF.numFmtId && BIFF2FmtTable[temp_val.XF.numFmtId] || BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
              safe_format_xf(temp_val, options, wb.opts.Date1904);
              addcell({ c: _j, r: val.r }, temp_val, options);
            }
          }
          break;
        case 214:
        case 516:
        case 4:
          temp_val = make_cell(val.val, val.ixfe, "s");
          temp_val.XF = XFs[temp_val.ixfe];
          if (BIFF2Fmt > 0) temp_val.z = temp_val.XF && temp_val.XF.numFmtId && BIFF2FmtTable[temp_val.XF.numFmtId] || BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
          safe_format_xf(temp_val, options, wb.opts.Date1904);
          addcell({ c: val.c, r: val.r }, temp_val, options);
          break;
        case 0:
        case 512:
          {
            if (file_depth === 1) range = val;
          }
          break;
        case 252:
          {
            sst = val;
          }
          break;
        case 1054:
          {
            if (opts.biff >= 3 && opts.biff <= 4) {
              BIFF2FmtTable[BIFF2Fmt++] = val[1];
              for (var b4idx = 0; b4idx < BIFF2Fmt + 163; ++b4idx) if (table_fmt[b4idx] == val[1]) break;
              if (b4idx >= 163) SSF__load(val[1], BIFF2Fmt + 163);
            } else SSF__load(val[1], val[0]);
          }
          break;
        case 30:
          {
            BIFF2FmtTable[BIFF2Fmt++] = val;
            for (var b2idx = 0; b2idx < BIFF2Fmt + 163; ++b2idx) if (table_fmt[b2idx] == val) break;
            if (b2idx >= 163) SSF__load(val, BIFF2Fmt + 163);
          }
          break;
        case 229:
          merges = merges.concat(val);
          break;
        case 93:
          objects[val.cmo[0]] = opts.lastobj = val;
          break;
        case 438:
          opts.lastobj.TxO = val;
          break;
        case 127:
          opts.lastobj.ImData = val;
          break;
        case 440:
          {
            for (rngR = val[0].s.r; rngR <= val[0].e.r; ++rngR)
              for (rngC = val[0].s.c; rngC <= val[0].e.c; ++rngC) {
                cc = options.dense ? (out["!data"][rngR] || [])[rngC] : out[encode_cell({ c: rngC, r: rngR })];
                if (cc) cc.l = val[1];
              }
          }
          break;
        case 2048:
          {
            for (rngR = val[0].s.r; rngR <= val[0].e.r; ++rngR)
              for (rngC = val[0].s.c; rngC <= val[0].e.c; ++rngC) {
                cc = options.dense ? (out["!data"][rngR] || [])[rngC] : out[encode_cell({ c: rngC, r: rngR })];
                if (cc && cc.l) cc.l.Tooltip = val[1];
              }
          }
          break;
        case 28:
          {
            cc = options.dense ? (out["!data"][val[0].r] || [])[val[0].c] : out[encode_cell(val[0])];
            if (!cc) {
              if (options.dense) {
                if (!out["!data"][val[0].r]) out["!data"][val[0].r] = [];
                cc = out["!data"][val[0].r][val[0].c] = { t: "z" };
              } else {
                cc = out[encode_cell(val[0])] = { t: "z" };
              }
              range.e.r = Math.max(range.e.r, val[0].r);
              range.s.r = Math.min(range.s.r, val[0].r);
              range.e.c = Math.max(range.e.c, val[0].c);
              range.s.c = Math.min(range.s.c, val[0].c);
            }
            if (!cc.c) cc.c = [];
            if (opts.biff <= 5 && opts.biff >= 2) cmnt = { a: "SheetJ5", t: val[1] };
            else {
              var noteobj = objects[val[2]];
              cmnt = { a: val[1], t: noteobj.TxO.t };
              if (val[3] != null && !(val[3] & 2)) cc.c.hidden = true;
            }
            cc.c.push(cmnt);
          }
          break;
        case 2173:
          update_xfext(XFs[val.ixfe], val.ext);
          break;
        case 125:
          {
            if (!opts.cellStyles) break;
            while (val.e >= val.s) {
              colinfo[val.e--] = { width: val.w / 256, level: val.level || 0, hidden: !!(val.flags & 1) };
              if (!seencol) {
                seencol = true;
                find_mdw_colw(val.w / 256);
              }
              process_col(colinfo[val.e + 1]);
            }
          }
          break;
        case 520:
          {
            var rowobj = {};
            if (val.level != null) {
              rowinfo[val.r] = rowobj;
              rowobj.level = val.level;
            }
            if (val.hidden) {
              rowinfo[val.r] = rowobj;
              rowobj.hidden = true;
            }
            if (val.hpt) {
              rowinfo[val.r] = rowobj;
              rowobj.hpt = val.hpt;
              rowobj.hpx = pt2px(val.hpt);
            }
          }
          break;
        case 38:
        case 39:
        case 40:
        case 41:
          if (!out["!margins"]) default_margins(out["!margins"] = {});
          out["!margins"][{ 38: "left", 39: "right", 40: "top", 41: "bottom" }[RecordType]] = val;
          break;
        case 161:
          if (!out["!margins"]) default_margins(out["!margins"] = {});
          out["!margins"].header = val.header;
          out["!margins"].footer = val.footer;
          break;
        case 574:
          if (val.RTL) Workbook.Views[0].RTL = true;
          break;
        case 146:
          palette = val;
          break;
        case 2198:
          themes = val;
          break;
        case 140:
          country = val;
          break;
        case 442:
          {
            if (!cur_sheet) Workbook.WBProps.CodeName = val || "ThisWorkbook";
            else wsprops.CodeName = val || wsprops.name;
          }
          break;
      }
    } else {
      if (!R) console.error("Missing Info for XLS Record 0x" + RecordType.toString(16));
      blob.l += length;
    }
  }
  wb.SheetNames = keys(Directory).sort(function(a, b) {
    return Number(a) - Number(b);
  }).map(function(x) {
    return Directory[x].name;
  });
  if (!options.bookSheets) wb.Sheets = Sheets;
  if (!wb.SheetNames.length && Preamble["!ref"]) {
    wb.SheetNames.push("Sheet1");
    if (wb.Sheets) wb.Sheets["Sheet1"] = Preamble;
  } else wb.Preamble = Preamble;
  if (wb.Sheets) FilterDatabases.forEach(function(r, i) {
    wb.Sheets[wb.SheetNames[i]]["!autofilter"] = r;
  });
  wb.Strings = sst;
  wb.SSF = dup(table_fmt);
  if (opts.enc) wb.Encryption = opts.enc;
  if (themes) wb.Themes = themes;
  wb.Metadata = {};
  if (country !== void 0) wb.Metadata.Country = country;
  if (supbooks.names.length > 0) Workbook.Names = supbooks.names;
  wb.Workbook = Workbook;
  return wb;
}
var PSCLSID = {
  SI: "e0859ff2f94f6810ab9108002b27b3d9",
  DSI: "02d5cdd59c2e1b10939708002b2cf9ae",
  UDI: "05d5cdd59c2e1b10939708002b2cf9ae"
};
function parse_xls_props(cfb, props, o) {
  var DSI = CFB.find(cfb, "/!DocumentSummaryInformation");
  if (DSI && DSI.size > 0) try {
    var DocSummary = parse_PropertySetStream(DSI, DocSummaryPIDDSI, PSCLSID.DSI);
    for (var d in DocSummary) props[d] = DocSummary[d];
  } catch (e) {
    if (o.WTF) throw e;
  }
  var SI = CFB.find(cfb, "/!SummaryInformation");
  if (SI && SI.size > 0) try {
    var Summary = parse_PropertySetStream(SI, SummaryPIDSI, PSCLSID.SI);
    for (var s in Summary) if (props[s] == null) props[s] = Summary[s];
  } catch (e) {
    if (o.WTF) throw e;
  }
  if (props.HeadingPairs && props.TitlesOfParts) {
    load_props_pairs(props.HeadingPairs, props.TitlesOfParts, props, o);
    delete props.HeadingPairs;
    delete props.TitlesOfParts;
  }
}
function parse_xlscfb(cfb, options) {
  if (!options) options = {};
  fix_read_opts(options);
  reset_cp();
  if (options.codepage) set_ansi(options.codepage);
  var CompObj, WB;
  if (cfb.FullPaths) {
    if (CFB.find(cfb, "/encryption")) throw new Error("File is password-protected");
    CompObj = CFB.find(cfb, "!CompObj");
    WB = CFB.find(cfb, "/Workbook") || CFB.find(cfb, "/Book");
  } else {
    switch (options.type) {
      case "base64":
        cfb = s2a(Base64_decode(cfb));
        break;
      case "binary":
        cfb = s2a(cfb);
        break;
      case "buffer":
        break;
      case "array":
        if (!Array.isArray(cfb)) cfb = Array.prototype.slice.call(cfb);
        break;
    }
    prep_blob(cfb, 0);
    WB = { content: cfb };
  }
  var WorkbookP;
  var _data;
  if (CompObj) parse_compobj(CompObj);
  if (options.bookProps && !options.bookSheets) WorkbookP = {};
  else {
    var T = has_buf ? "buffer" : "array";
    if (WB && WB.content) WorkbookP = parse_workbook(WB.content, options);
    else if ((_data = CFB.find(cfb, "PerfectOffice_MAIN")) && _data.content) WorkbookP = WK_.to_workbook(_data.content, (options.type = T, options));
    else if ((_data = CFB.find(cfb, "NativeContent_MAIN")) && _data.content) WorkbookP = WK_.to_workbook(_data.content, (options.type = T, options));
    else if ((_data = CFB.find(cfb, "MN0")) && _data.content) throw new Error("Unsupported Works 4 for Mac file");
    else throw new Error("Cannot find Workbook stream");
    if (options.bookVBA && cfb.FullPaths && CFB.find(cfb, "/_VBA_PROJECT_CUR/VBA/dir")) WorkbookP.vbaraw = make_vba_xls(cfb);
  }
  var props = {};
  if (cfb.FullPaths) parse_xls_props(
    /*::((*/
    cfb,
    props,
    options
  );
  WorkbookP.Props = WorkbookP.Custprops = props;
  if (options.bookFiles) WorkbookP.cfb = cfb;
  return WorkbookP;
}
var XLSBRecordEnum = {
  0: {
    /* n:"BrtRowHdr", */
    f: parse_BrtRowHdr
  },
  1: {
    /* n:"BrtCellBlank", */
    f: parse_BrtCellBlank
  },
  2: {
    /* n:"BrtCellRk", */
    f: parse_BrtCellRk
  },
  3: {
    /* n:"BrtCellError", */
    f: parse_BrtCellError
  },
  4: {
    /* n:"BrtCellBool", */
    f: parse_BrtCellBool
  },
  5: {
    /* n:"BrtCellReal", */
    f: parse_BrtCellReal
  },
  6: {
    /* n:"BrtCellSt", */
    f: parse_BrtCellSt
  },
  7: {
    /* n:"BrtCellIsst", */
    f: parse_BrtCellIsst
  },
  8: {
    /* n:"BrtFmlaString", */
    f: parse_BrtFmlaString
  },
  9: {
    /* n:"BrtFmlaNum", */
    f: parse_BrtFmlaNum
  },
  10: {
    /* n:"BrtFmlaBool", */
    f: parse_BrtFmlaBool
  },
  11: {
    /* n:"BrtFmlaError", */
    f: parse_BrtFmlaError
  },
  12: {
    /* n:"BrtShortBlank", */
    f: parse_BrtShortBlank
  },
  13: {
    /* n:"BrtShortRk", */
    f: parse_BrtShortRk
  },
  14: {
    /* n:"BrtShortError", */
    f: parse_BrtShortError
  },
  15: {
    /* n:"BrtShortBool", */
    f: parse_BrtShortBool
  },
  16: {
    /* n:"BrtShortReal", */
    f: parse_BrtShortReal
  },
  17: {
    /* n:"BrtShortSt", */
    f: parse_BrtShortSt
  },
  18: {
    /* n:"BrtShortIsst", */
    f: parse_BrtShortIsst
  },
  19: {
    /* n:"BrtSSTItem", */
    f: parse_RichStr
  },
  20: {
    /* n:"BrtPCDIMissing" */
  },
  21: {
    /* n:"BrtPCDINumber" */
  },
  22: {
    /* n:"BrtPCDIBoolean" */
  },
  23: {
    /* n:"BrtPCDIError" */
  },
  24: {
    /* n:"BrtPCDIString" */
  },
  25: {
    /* n:"BrtPCDIDatetime" */
  },
  26: {
    /* n:"BrtPCDIIndex" */
  },
  27: {
    /* n:"BrtPCDIAMissing" */
  },
  28: {
    /* n:"BrtPCDIANumber" */
  },
  29: {
    /* n:"BrtPCDIABoolean" */
  },
  30: {
    /* n:"BrtPCDIAError" */
  },
  31: {
    /* n:"BrtPCDIAString" */
  },
  32: {
    /* n:"BrtPCDIADatetime" */
  },
  33: {
    /* n:"BrtPCRRecord" */
  },
  34: {
    /* n:"BrtPCRRecordDt" */
  },
  35: {
    /* n:"BrtFRTBegin", */
    T: 1
  },
  36: {
    /* n:"BrtFRTEnd", */
    T: -1
  },
  37: {
    /* n:"BrtACBegin", */
    T: 1
  },
  38: {
    /* n:"BrtACEnd", */
    T: -1
  },
  39: {
    /* n:"BrtName", */
    f: parse_BrtName
  },
  40: {
    /* n:"BrtIndexRowBlock" */
  },
  42: {
    /* n:"BrtIndexBlock" */
  },
  43: {
    /* n:"BrtFont", */
    f: parse_BrtFont
  },
  44: {
    /* n:"BrtFmt", */
    f: parse_BrtFmt
  },
  45: {
    /* n:"BrtFill", */
    f: parse_BrtFill
  },
  46: {
    /* n:"BrtBorder", */
    f: parse_BrtBorder
  },
  47: {
    /* n:"BrtXF", */
    f: parse_BrtXF
  },
  48: {
    /* n:"BrtStyle" */
  },
  49: {
    /* n:"BrtCellMeta", */
    f: parse_Int32LE
  },
  50: {
    /* n:"BrtValueMeta" */
  },
  51: {
    /* n:"BrtMdb" */
    f: parse_BrtMdb
  },
  52: {
    /* n:"BrtBeginFmd", */
    T: 1
  },
  53: {
    /* n:"BrtEndFmd", */
    T: -1
  },
  54: {
    /* n:"BrtBeginMdx", */
    T: 1
  },
  55: {
    /* n:"BrtEndMdx", */
    T: -1
  },
  56: {
    /* n:"BrtBeginMdxTuple", */
    T: 1
  },
  57: {
    /* n:"BrtEndMdxTuple", */
    T: -1
  },
  58: {
    /* n:"BrtMdxMbrIstr" */
  },
  59: {
    /* n:"BrtStr" */
  },
  60: {
    /* n:"BrtColInfo", */
    f: parse_ColInfo
  },
  62: {
    /* n:"BrtCellRString", */
    f: parse_BrtCellRString
  },
  63: {
    /* n:"BrtCalcChainItem$", */
    f: parse_BrtCalcChainItem$
  },
  64: {
    /* n:"BrtDVal", */
    f: parse_BrtDVal
  },
  65: {
    /* n:"BrtSxvcellNum" */
  },
  66: {
    /* n:"BrtSxvcellStr" */
  },
  67: {
    /* n:"BrtSxvcellBool" */
  },
  68: {
    /* n:"BrtSxvcellErr" */
  },
  69: {
    /* n:"BrtSxvcellDate" */
  },
  70: {
    /* n:"BrtSxvcellNil" */
  },
  128: {
    /* n:"BrtFileVersion" */
  },
  129: {
    /* n:"BrtBeginSheet", */
    T: 1
  },
  130: {
    /* n:"BrtEndSheet", */
    T: -1
  },
  131: {
    /* n:"BrtBeginBook", */
    T: 1,
    f: parsenoop,
    p: 0
  },
  132: {
    /* n:"BrtEndBook", */
    T: -1
  },
  133: {
    /* n:"BrtBeginWsViews", */
    T: 1
  },
  134: {
    /* n:"BrtEndWsViews", */
    T: -1
  },
  135: {
    /* n:"BrtBeginBookViews", */
    T: 1
  },
  136: {
    /* n:"BrtEndBookViews", */
    T: -1
  },
  137: {
    /* n:"BrtBeginWsView", */
    T: 1,
    f: parse_BrtBeginWsView
  },
  138: {
    /* n:"BrtEndWsView", */
    T: -1
  },
  139: {
    /* n:"BrtBeginCsViews", */
    T: 1
  },
  140: {
    /* n:"BrtEndCsViews", */
    T: -1
  },
  141: {
    /* n:"BrtBeginCsView", */
    T: 1
  },
  142: {
    /* n:"BrtEndCsView", */
    T: -1
  },
  143: {
    /* n:"BrtBeginBundleShs", */
    T: 1
  },
  144: {
    /* n:"BrtEndBundleShs", */
    T: -1
  },
  145: {
    /* n:"BrtBeginSheetData", */
    T: 1
  },
  146: {
    /* n:"BrtEndSheetData", */
    T: -1
  },
  147: {
    /* n:"BrtWsProp", */
    f: parse_BrtWsProp
  },
  148: {
    /* n:"BrtWsDim", */
    f: parse_BrtWsDim,
    p: 16
  },
  151: {
    /* n:"BrtPane", */
    f: parse_BrtPane
  },
  152: {
    /* n:"BrtSel" */
  },
  153: {
    /* n:"BrtWbProp", */
    f: parse_BrtWbProp
  },
  154: {
    /* n:"BrtWbFactoid" */
  },
  155: {
    /* n:"BrtFileRecover" */
  },
  156: {
    /* n:"BrtBundleSh", */
    f: parse_BrtBundleSh
  },
  157: {
    /* n:"BrtCalcProp" */
  },
  158: {
    /* n:"BrtBookView" */
  },
  159: {
    /* n:"BrtBeginSst", */
    T: 1,
    f: parse_BrtBeginSst
  },
  160: {
    /* n:"BrtEndSst", */
    T: -1
  },
  161: {
    /* n:"BrtBeginAFilter", */
    T: 1,
    f: parse_UncheckedRfX
  },
  162: {
    /* n:"BrtEndAFilter", */
    T: -1
  },
  163: {
    /* n:"BrtBeginFilterColumn", */
    T: 1
  },
  164: {
    /* n:"BrtEndFilterColumn", */
    T: -1
  },
  165: {
    /* n:"BrtBeginFilters", */
    T: 1
  },
  166: {
    /* n:"BrtEndFilters", */
    T: -1
  },
  167: {
    /* n:"BrtFilter" */
  },
  168: {
    /* n:"BrtColorFilter" */
  },
  169: {
    /* n:"BrtIconFilter" */
  },
  170: {
    /* n:"BrtTop10Filter" */
  },
  171: {
    /* n:"BrtDynamicFilter" */
  },
  172: {
    /* n:"BrtBeginCustomFilters", */
    T: 1
  },
  173: {
    /* n:"BrtEndCustomFilters", */
    T: -1
  },
  174: {
    /* n:"BrtCustomFilter" */
  },
  175: {
    /* n:"BrtAFilterDateGroupItem" */
  },
  176: {
    /* n:"BrtMergeCell", */
    f: parse_BrtMergeCell
  },
  177: {
    /* n:"BrtBeginMergeCells", */
    T: 1
  },
  178: {
    /* n:"BrtEndMergeCells", */
    T: -1
  },
  179: {
    /* n:"BrtBeginPivotCacheDef", */
    T: 1
  },
  180: {
    /* n:"BrtEndPivotCacheDef", */
    T: -1
  },
  181: {
    /* n:"BrtBeginPCDFields", */
    T: 1
  },
  182: {
    /* n:"BrtEndPCDFields", */
    T: -1
  },
  183: {
    /* n:"BrtBeginPCDField", */
    T: 1
  },
  184: {
    /* n:"BrtEndPCDField", */
    T: -1
  },
  185: {
    /* n:"BrtBeginPCDSource", */
    T: 1
  },
  186: {
    /* n:"BrtEndPCDSource", */
    T: -1
  },
  187: {
    /* n:"BrtBeginPCDSRange", */
    T: 1
  },
  188: {
    /* n:"BrtEndPCDSRange", */
    T: -1
  },
  189: {
    /* n:"BrtBeginPCDFAtbl", */
    T: 1
  },
  190: {
    /* n:"BrtEndPCDFAtbl", */
    T: -1
  },
  191: {
    /* n:"BrtBeginPCDIRun", */
    T: 1
  },
  192: {
    /* n:"BrtEndPCDIRun", */
    T: -1
  },
  193: {
    /* n:"BrtBeginPivotCacheRecords", */
    T: 1
  },
  194: {
    /* n:"BrtEndPivotCacheRecords", */
    T: -1
  },
  195: {
    /* n:"BrtBeginPCDHierarchies", */
    T: 1
  },
  196: {
    /* n:"BrtEndPCDHierarchies", */
    T: -1
  },
  197: {
    /* n:"BrtBeginPCDHierarchy", */
    T: 1
  },
  198: {
    /* n:"BrtEndPCDHierarchy", */
    T: -1
  },
  199: {
    /* n:"BrtBeginPCDHFieldsUsage", */
    T: 1
  },
  200: {
    /* n:"BrtEndPCDHFieldsUsage", */
    T: -1
  },
  201: {
    /* n:"BrtBeginExtConnection", */
    T: 1
  },
  202: {
    /* n:"BrtEndExtConnection", */
    T: -1
  },
  203: {
    /* n:"BrtBeginECDbProps", */
    T: 1
  },
  204: {
    /* n:"BrtEndECDbProps", */
    T: -1
  },
  205: {
    /* n:"BrtBeginECOlapProps", */
    T: 1
  },
  206: {
    /* n:"BrtEndECOlapProps", */
    T: -1
  },
  207: {
    /* n:"BrtBeginPCDSConsol", */
    T: 1
  },
  208: {
    /* n:"BrtEndPCDSConsol", */
    T: -1
  },
  209: {
    /* n:"BrtBeginPCDSCPages", */
    T: 1
  },
  210: {
    /* n:"BrtEndPCDSCPages", */
    T: -1
  },
  211: {
    /* n:"BrtBeginPCDSCPage", */
    T: 1
  },
  212: {
    /* n:"BrtEndPCDSCPage", */
    T: -1
  },
  213: {
    /* n:"BrtBeginPCDSCPItem", */
    T: 1
  },
  214: {
    /* n:"BrtEndPCDSCPItem", */
    T: -1
  },
  215: {
    /* n:"BrtBeginPCDSCSets", */
    T: 1
  },
  216: {
    /* n:"BrtEndPCDSCSets", */
    T: -1
  },
  217: {
    /* n:"BrtBeginPCDSCSet", */
    T: 1
  },
  218: {
    /* n:"BrtEndPCDSCSet", */
    T: -1
  },
  219: {
    /* n:"BrtBeginPCDFGroup", */
    T: 1
  },
  220: {
    /* n:"BrtEndPCDFGroup", */
    T: -1
  },
  221: {
    /* n:"BrtBeginPCDFGItems", */
    T: 1
  },
  222: {
    /* n:"BrtEndPCDFGItems", */
    T: -1
  },
  223: {
    /* n:"BrtBeginPCDFGRange", */
    T: 1
  },
  224: {
    /* n:"BrtEndPCDFGRange", */
    T: -1
  },
  225: {
    /* n:"BrtBeginPCDFGDiscrete", */
    T: 1
  },
  226: {
    /* n:"BrtEndPCDFGDiscrete", */
    T: -1
  },
  227: {
    /* n:"BrtBeginPCDSDTupleCache", */
    T: 1
  },
  228: {
    /* n:"BrtEndPCDSDTupleCache", */
    T: -1
  },
  229: {
    /* n:"BrtBeginPCDSDTCEntries", */
    T: 1
  },
  230: {
    /* n:"BrtEndPCDSDTCEntries", */
    T: -1
  },
  231: {
    /* n:"BrtBeginPCDSDTCEMembers", */
    T: 1
  },
  232: {
    /* n:"BrtEndPCDSDTCEMembers", */
    T: -1
  },
  233: {
    /* n:"BrtBeginPCDSDTCEMember", */
    T: 1
  },
  234: {
    /* n:"BrtEndPCDSDTCEMember", */
    T: -1
  },
  235: {
    /* n:"BrtBeginPCDSDTCQueries", */
    T: 1
  },
  236: {
    /* n:"BrtEndPCDSDTCQueries", */
    T: -1
  },
  237: {
    /* n:"BrtBeginPCDSDTCQuery", */
    T: 1
  },
  238: {
    /* n:"BrtEndPCDSDTCQuery", */
    T: -1
  },
  239: {
    /* n:"BrtBeginPCDSDTCSets", */
    T: 1
  },
  240: {
    /* n:"BrtEndPCDSDTCSets", */
    T: -1
  },
  241: {
    /* n:"BrtBeginPCDSDTCSet", */
    T: 1
  },
  242: {
    /* n:"BrtEndPCDSDTCSet", */
    T: -1
  },
  243: {
    /* n:"BrtBeginPCDCalcItems", */
    T: 1
  },
  244: {
    /* n:"BrtEndPCDCalcItems", */
    T: -1
  },
  245: {
    /* n:"BrtBeginPCDCalcItem", */
    T: 1
  },
  246: {
    /* n:"BrtEndPCDCalcItem", */
    T: -1
  },
  247: {
    /* n:"BrtBeginPRule", */
    T: 1
  },
  248: {
    /* n:"BrtEndPRule", */
    T: -1
  },
  249: {
    /* n:"BrtBeginPRFilters", */
    T: 1
  },
  250: {
    /* n:"BrtEndPRFilters", */
    T: -1
  },
  251: {
    /* n:"BrtBeginPRFilter", */
    T: 1
  },
  252: {
    /* n:"BrtEndPRFilter", */
    T: -1
  },
  253: {
    /* n:"BrtBeginPNames", */
    T: 1
  },
  254: {
    /* n:"BrtEndPNames", */
    T: -1
  },
  255: {
    /* n:"BrtBeginPName", */
    T: 1
  },
  256: {
    /* n:"BrtEndPName", */
    T: -1
  },
  257: {
    /* n:"BrtBeginPNPairs", */
    T: 1
  },
  258: {
    /* n:"BrtEndPNPairs", */
    T: -1
  },
  259: {
    /* n:"BrtBeginPNPair", */
    T: 1
  },
  260: {
    /* n:"BrtEndPNPair", */
    T: -1
  },
  261: {
    /* n:"BrtBeginECWebProps", */
    T: 1
  },
  262: {
    /* n:"BrtEndECWebProps", */
    T: -1
  },
  263: {
    /* n:"BrtBeginEcWpTables", */
    T: 1
  },
  264: {
    /* n:"BrtEndECWPTables", */
    T: -1
  },
  265: {
    /* n:"BrtBeginECParams", */
    T: 1
  },
  266: {
    /* n:"BrtEndECParams", */
    T: -1
  },
  267: {
    /* n:"BrtBeginECParam", */
    T: 1
  },
  268: {
    /* n:"BrtEndECParam", */
    T: -1
  },
  269: {
    /* n:"BrtBeginPCDKPIs", */
    T: 1
  },
  270: {
    /* n:"BrtEndPCDKPIs", */
    T: -1
  },
  271: {
    /* n:"BrtBeginPCDKPI", */
    T: 1
  },
  272: {
    /* n:"BrtEndPCDKPI", */
    T: -1
  },
  273: {
    /* n:"BrtBeginDims", */
    T: 1
  },
  274: {
    /* n:"BrtEndDims", */
    T: -1
  },
  275: {
    /* n:"BrtBeginDim", */
    T: 1
  },
  276: {
    /* n:"BrtEndDim", */
    T: -1
  },
  277: {
    /* n:"BrtIndexPartEnd" */
  },
  278: {
    /* n:"BrtBeginStyleSheet", */
    T: 1
  },
  279: {
    /* n:"BrtEndStyleSheet", */
    T: -1
  },
  280: {
    /* n:"BrtBeginSXView", */
    T: 1
  },
  281: {
    /* n:"BrtEndSXVI", */
    T: -1
  },
  282: {
    /* n:"BrtBeginSXVI", */
    T: 1
  },
  283: {
    /* n:"BrtBeginSXVIs", */
    T: 1
  },
  284: {
    /* n:"BrtEndSXVIs", */
    T: -1
  },
  285: {
    /* n:"BrtBeginSXVD", */
    T: 1
  },
  286: {
    /* n:"BrtEndSXVD", */
    T: -1
  },
  287: {
    /* n:"BrtBeginSXVDs", */
    T: 1
  },
  288: {
    /* n:"BrtEndSXVDs", */
    T: -1
  },
  289: {
    /* n:"BrtBeginSXPI", */
    T: 1
  },
  290: {
    /* n:"BrtEndSXPI", */
    T: -1
  },
  291: {
    /* n:"BrtBeginSXPIs", */
    T: 1
  },
  292: {
    /* n:"BrtEndSXPIs", */
    T: -1
  },
  293: {
    /* n:"BrtBeginSXDI", */
    T: 1
  },
  294: {
    /* n:"BrtEndSXDI", */
    T: -1
  },
  295: {
    /* n:"BrtBeginSXDIs", */
    T: 1
  },
  296: {
    /* n:"BrtEndSXDIs", */
    T: -1
  },
  297: {
    /* n:"BrtBeginSXLI", */
    T: 1
  },
  298: {
    /* n:"BrtEndSXLI", */
    T: -1
  },
  299: {
    /* n:"BrtBeginSXLIRws", */
    T: 1
  },
  300: {
    /* n:"BrtEndSXLIRws", */
    T: -1
  },
  301: {
    /* n:"BrtBeginSXLICols", */
    T: 1
  },
  302: {
    /* n:"BrtEndSXLICols", */
    T: -1
  },
  303: {
    /* n:"BrtBeginSXFormat", */
    T: 1
  },
  304: {
    /* n:"BrtEndSXFormat", */
    T: -1
  },
  305: {
    /* n:"BrtBeginSXFormats", */
    T: 1
  },
  306: {
    /* n:"BrtEndSxFormats", */
    T: -1
  },
  307: {
    /* n:"BrtBeginSxSelect", */
    T: 1
  },
  308: {
    /* n:"BrtEndSxSelect", */
    T: -1
  },
  309: {
    /* n:"BrtBeginISXVDRws", */
    T: 1
  },
  310: {
    /* n:"BrtEndISXVDRws", */
    T: -1
  },
  311: {
    /* n:"BrtBeginISXVDCols", */
    T: 1
  },
  312: {
    /* n:"BrtEndISXVDCols", */
    T: -1
  },
  313: {
    /* n:"BrtEndSXLocation", */
    T: -1
  },
  314: {
    /* n:"BrtBeginSXLocation", */
    T: 1
  },
  315: {
    /* n:"BrtEndSXView", */
    T: -1
  },
  316: {
    /* n:"BrtBeginSXTHs", */
    T: 1
  },
  317: {
    /* n:"BrtEndSXTHs", */
    T: -1
  },
  318: {
    /* n:"BrtBeginSXTH", */
    T: 1
  },
  319: {
    /* n:"BrtEndSXTH", */
    T: -1
  },
  320: {
    /* n:"BrtBeginISXTHRws", */
    T: 1
  },
  321: {
    /* n:"BrtEndISXTHRws", */
    T: -1
  },
  322: {
    /* n:"BrtBeginISXTHCols", */
    T: 1
  },
  323: {
    /* n:"BrtEndISXTHCols", */
    T: -1
  },
  324: {
    /* n:"BrtBeginSXTDMPS", */
    T: 1
  },
  325: {
    /* n:"BrtEndSXTDMPs", */
    T: -1
  },
  326: {
    /* n:"BrtBeginSXTDMP", */
    T: 1
  },
  327: {
    /* n:"BrtEndSXTDMP", */
    T: -1
  },
  328: {
    /* n:"BrtBeginSXTHItems", */
    T: 1
  },
  329: {
    /* n:"BrtEndSXTHItems", */
    T: -1
  },
  330: {
    /* n:"BrtBeginSXTHItem", */
    T: 1
  },
  331: {
    /* n:"BrtEndSXTHItem", */
    T: -1
  },
  332: {
    /* n:"BrtBeginMetadata", */
    T: 1
  },
  333: {
    /* n:"BrtEndMetadata", */
    T: -1
  },
  334: {
    /* n:"BrtBeginEsmdtinfo", */
    T: 1
  },
  335: {
    /* n:"BrtMdtinfo", */
    f: parse_BrtMdtinfo
  },
  336: {
    /* n:"BrtEndEsmdtinfo", */
    T: -1
  },
  337: {
    /* n:"BrtBeginEsmdb", */
    f: parse_BrtBeginEsmdb,
    T: 1
  },
  338: {
    /* n:"BrtEndEsmdb", */
    T: -1
  },
  339: {
    /* n:"BrtBeginEsfmd", */
    T: 1
  },
  340: {
    /* n:"BrtEndEsfmd", */
    T: -1
  },
  341: {
    /* n:"BrtBeginSingleCells", */
    T: 1
  },
  342: {
    /* n:"BrtEndSingleCells", */
    T: -1
  },
  343: {
    /* n:"BrtBeginList", */
    T: 1
  },
  344: {
    /* n:"BrtEndList", */
    T: -1
  },
  345: {
    /* n:"BrtBeginListCols", */
    T: 1
  },
  346: {
    /* n:"BrtEndListCols", */
    T: -1
  },
  347: {
    /* n:"BrtBeginListCol", */
    T: 1
  },
  348: {
    /* n:"BrtEndListCol", */
    T: -1
  },
  349: {
    /* n:"BrtBeginListXmlCPr", */
    T: 1
  },
  350: {
    /* n:"BrtEndListXmlCPr", */
    T: -1
  },
  351: {
    /* n:"BrtListCCFmla" */
  },
  352: {
    /* n:"BrtListTrFmla" */
  },
  353: {
    /* n:"BrtBeginExternals", */
    T: 1
  },
  354: {
    /* n:"BrtEndExternals", */
    T: -1
  },
  355: {
    /* n:"BrtSupBookSrc", */
    f: parse_RelID
  },
  357: {
    /* n:"BrtSupSelf" */
  },
  358: {
    /* n:"BrtSupSame" */
  },
  359: {
    /* n:"BrtSupTabs" */
  },
  360: {
    /* n:"BrtBeginSupBook", */
    T: 1
  },
  361: {
    /* n:"BrtPlaceholderName" */
  },
  362: {
    /* n:"BrtExternSheet", */
    f: parse_ExternSheet
  },
  363: {
    /* n:"BrtExternTableStart" */
  },
  364: {
    /* n:"BrtExternTableEnd" */
  },
  366: {
    /* n:"BrtExternRowHdr" */
  },
  367: {
    /* n:"BrtExternCellBlank" */
  },
  368: {
    /* n:"BrtExternCellReal" */
  },
  369: {
    /* n:"BrtExternCellBool" */
  },
  370: {
    /* n:"BrtExternCellError" */
  },
  371: {
    /* n:"BrtExternCellString" */
  },
  372: {
    /* n:"BrtBeginEsmdx", */
    T: 1
  },
  373: {
    /* n:"BrtEndEsmdx", */
    T: -1
  },
  374: {
    /* n:"BrtBeginMdxSet", */
    T: 1
  },
  375: {
    /* n:"BrtEndMdxSet", */
    T: -1
  },
  376: {
    /* n:"BrtBeginMdxMbrProp", */
    T: 1
  },
  377: {
    /* n:"BrtEndMdxMbrProp", */
    T: -1
  },
  378: {
    /* n:"BrtBeginMdxKPI", */
    T: 1
  },
  379: {
    /* n:"BrtEndMdxKPI", */
    T: -1
  },
  380: {
    /* n:"BrtBeginEsstr", */
    T: 1
  },
  381: {
    /* n:"BrtEndEsstr", */
    T: -1
  },
  382: {
    /* n:"BrtBeginPRFItem", */
    T: 1
  },
  383: {
    /* n:"BrtEndPRFItem", */
    T: -1
  },
  384: {
    /* n:"BrtBeginPivotCacheIDs", */
    T: 1
  },
  385: {
    /* n:"BrtEndPivotCacheIDs", */
    T: -1
  },
  386: {
    /* n:"BrtBeginPivotCacheID", */
    T: 1
  },
  387: {
    /* n:"BrtEndPivotCacheID", */
    T: -1
  },
  388: {
    /* n:"BrtBeginISXVIs", */
    T: 1
  },
  389: {
    /* n:"BrtEndISXVIs", */
    T: -1
  },
  390: {
    /* n:"BrtBeginColInfos", */
    T: 1
  },
  391: {
    /* n:"BrtEndColInfos", */
    T: -1
  },
  392: {
    /* n:"BrtBeginRwBrk", */
    T: 1
  },
  393: {
    /* n:"BrtEndRwBrk", */
    T: -1
  },
  394: {
    /* n:"BrtBeginColBrk", */
    T: 1
  },
  395: {
    /* n:"BrtEndColBrk", */
    T: -1
  },
  396: {
    /* n:"BrtBrk" */
  },
  397: {
    /* n:"BrtUserBookView" */
  },
  398: {
    /* n:"BrtInfo" */
  },
  399: {
    /* n:"BrtCUsr" */
  },
  400: {
    /* n:"BrtUsr" */
  },
  401: {
    /* n:"BrtBeginUsers", */
    T: 1
  },
  403: {
    /* n:"BrtEOF" */
  },
  404: {
    /* n:"BrtUCR" */
  },
  405: {
    /* n:"BrtRRInsDel" */
  },
  406: {
    /* n:"BrtRREndInsDel" */
  },
  407: {
    /* n:"BrtRRMove" */
  },
  408: {
    /* n:"BrtRREndMove" */
  },
  409: {
    /* n:"BrtRRChgCell" */
  },
  410: {
    /* n:"BrtRREndChgCell" */
  },
  411: {
    /* n:"BrtRRHeader" */
  },
  412: {
    /* n:"BrtRRUserView" */
  },
  413: {
    /* n:"BrtRRRenSheet" */
  },
  414: {
    /* n:"BrtRRInsertSh" */
  },
  415: {
    /* n:"BrtRRDefName" */
  },
  416: {
    /* n:"BrtRRNote" */
  },
  417: {
    /* n:"BrtRRConflict" */
  },
  418: {
    /* n:"BrtRRTQSIF" */
  },
  419: {
    /* n:"BrtRRFormat" */
  },
  420: {
    /* n:"BrtRREndFormat" */
  },
  421: {
    /* n:"BrtRRAutoFmt" */
  },
  422: {
    /* n:"BrtBeginUserShViews", */
    T: 1
  },
  423: {
    /* n:"BrtBeginUserShView", */
    T: 1
  },
  424: {
    /* n:"BrtEndUserShView", */
    T: -1
  },
  425: {
    /* n:"BrtEndUserShViews", */
    T: -1
  },
  426: {
    /* n:"BrtArrFmla", */
    f: parse_BrtArrFmla
  },
  427: {
    /* n:"BrtShrFmla", */
    f: parse_BrtShrFmla
  },
  428: {
    /* n:"BrtTable" */
  },
  429: {
    /* n:"BrtBeginExtConnections", */
    T: 1
  },
  430: {
    /* n:"BrtEndExtConnections", */
    T: -1
  },
  431: {
    /* n:"BrtBeginPCDCalcMems", */
    T: 1
  },
  432: {
    /* n:"BrtEndPCDCalcMems", */
    T: -1
  },
  433: {
    /* n:"BrtBeginPCDCalcMem", */
    T: 1
  },
  434: {
    /* n:"BrtEndPCDCalcMem", */
    T: -1
  },
  435: {
    /* n:"BrtBeginPCDHGLevels", */
    T: 1
  },
  436: {
    /* n:"BrtEndPCDHGLevels", */
    T: -1
  },
  437: {
    /* n:"BrtBeginPCDHGLevel", */
    T: 1
  },
  438: {
    /* n:"BrtEndPCDHGLevel", */
    T: -1
  },
  439: {
    /* n:"BrtBeginPCDHGLGroups", */
    T: 1
  },
  440: {
    /* n:"BrtEndPCDHGLGroups", */
    T: -1
  },
  441: {
    /* n:"BrtBeginPCDHGLGroup", */
    T: 1
  },
  442: {
    /* n:"BrtEndPCDHGLGroup", */
    T: -1
  },
  443: {
    /* n:"BrtBeginPCDHGLGMembers", */
    T: 1
  },
  444: {
    /* n:"BrtEndPCDHGLGMembers", */
    T: -1
  },
  445: {
    /* n:"BrtBeginPCDHGLGMember", */
    T: 1
  },
  446: {
    /* n:"BrtEndPCDHGLGMember", */
    T: -1
  },
  447: {
    /* n:"BrtBeginQSI", */
    T: 1
  },
  448: {
    /* n:"BrtEndQSI", */
    T: -1
  },
  449: {
    /* n:"BrtBeginQSIR", */
    T: 1
  },
  450: {
    /* n:"BrtEndQSIR", */
    T: -1
  },
  451: {
    /* n:"BrtBeginDeletedNames", */
    T: 1
  },
  452: {
    /* n:"BrtEndDeletedNames", */
    T: -1
  },
  453: {
    /* n:"BrtBeginDeletedName", */
    T: 1
  },
  454: {
    /* n:"BrtEndDeletedName", */
    T: -1
  },
  455: {
    /* n:"BrtBeginQSIFs", */
    T: 1
  },
  456: {
    /* n:"BrtEndQSIFs", */
    T: -1
  },
  457: {
    /* n:"BrtBeginQSIF", */
    T: 1
  },
  458: {
    /* n:"BrtEndQSIF", */
    T: -1
  },
  459: {
    /* n:"BrtBeginAutoSortScope", */
    T: 1
  },
  460: {
    /* n:"BrtEndAutoSortScope", */
    T: -1
  },
  461: {
    /* n:"BrtBeginConditionalFormatting", */
    T: 1
  },
  462: {
    /* n:"BrtEndConditionalFormatting", */
    T: -1
  },
  463: {
    /* n:"BrtBeginCFRule", */
    T: 1
  },
  464: {
    /* n:"BrtEndCFRule", */
    T: -1
  },
  465: {
    /* n:"BrtBeginIconSet", */
    T: 1
  },
  466: {
    /* n:"BrtEndIconSet", */
    T: -1
  },
  467: {
    /* n:"BrtBeginDatabar", */
    T: 1
  },
  468: {
    /* n:"BrtEndDatabar", */
    T: -1
  },
  469: {
    /* n:"BrtBeginColorScale", */
    T: 1
  },
  470: {
    /* n:"BrtEndColorScale", */
    T: -1
  },
  471: {
    /* n:"BrtCFVO" */
  },
  472: {
    /* n:"BrtExternValueMeta" */
  },
  473: {
    /* n:"BrtBeginColorPalette", */
    T: 1
  },
  474: {
    /* n:"BrtEndColorPalette", */
    T: -1
  },
  475: {
    /* n:"BrtIndexedColor" */
  },
  476: {
    /* n:"BrtMargins", */
    f: parse_BrtMargins
  },
  477: {
    /* n:"BrtPrintOptions" */
  },
  478: {
    /* n:"BrtPageSetup" */
  },
  479: {
    /* n:"BrtBeginHeaderFooter", */
    T: 1
  },
  480: {
    /* n:"BrtEndHeaderFooter", */
    T: -1
  },
  481: {
    /* n:"BrtBeginSXCrtFormat", */
    T: 1
  },
  482: {
    /* n:"BrtEndSXCrtFormat", */
    T: -1
  },
  483: {
    /* n:"BrtBeginSXCrtFormats", */
    T: 1
  },
  484: {
    /* n:"BrtEndSXCrtFormats", */
    T: -1
  },
  485: {
    /* n:"BrtWsFmtInfo", */
    f: parse_BrtWsFmtInfo
  },
  486: {
    /* n:"BrtBeginMgs", */
    T: 1
  },
  487: {
    /* n:"BrtEndMGs", */
    T: -1
  },
  488: {
    /* n:"BrtBeginMGMaps", */
    T: 1
  },
  489: {
    /* n:"BrtEndMGMaps", */
    T: -1
  },
  490: {
    /* n:"BrtBeginMG", */
    T: 1
  },
  491: {
    /* n:"BrtEndMG", */
    T: -1
  },
  492: {
    /* n:"BrtBeginMap", */
    T: 1
  },
  493: {
    /* n:"BrtEndMap", */
    T: -1
  },
  494: {
    /* n:"BrtHLink", */
    f: parse_BrtHLink
  },
  495: {
    /* n:"BrtBeginDCon", */
    T: 1
  },
  496: {
    /* n:"BrtEndDCon", */
    T: -1
  },
  497: {
    /* n:"BrtBeginDRefs", */
    T: 1
  },
  498: {
    /* n:"BrtEndDRefs", */
    T: -1
  },
  499: {
    /* n:"BrtDRef" */
  },
  500: {
    /* n:"BrtBeginScenMan", */
    T: 1
  },
  501: {
    /* n:"BrtEndScenMan", */
    T: -1
  },
  502: {
    /* n:"BrtBeginSct", */
    T: 1
  },
  503: {
    /* n:"BrtEndSct", */
    T: -1
  },
  504: {
    /* n:"BrtSlc" */
  },
  505: {
    /* n:"BrtBeginDXFs", */
    T: 1
  },
  506: {
    /* n:"BrtEndDXFs", */
    T: -1
  },
  507: {
    /* n:"BrtDXF" */
  },
  508: {
    /* n:"BrtBeginTableStyles", */
    T: 1
  },
  509: {
    /* n:"BrtEndTableStyles", */
    T: -1
  },
  510: {
    /* n:"BrtBeginTableStyle", */
    T: 1
  },
  511: {
    /* n:"BrtEndTableStyle", */
    T: -1
  },
  512: {
    /* n:"BrtTableStyleElement" */
  },
  513: {
    /* n:"BrtTableStyleClient" */
  },
  514: {
    /* n:"BrtBeginVolDeps", */
    T: 1
  },
  515: {
    /* n:"BrtEndVolDeps", */
    T: -1
  },
  516: {
    /* n:"BrtBeginVolType", */
    T: 1
  },
  517: {
    /* n:"BrtEndVolType", */
    T: -1
  },
  518: {
    /* n:"BrtBeginVolMain", */
    T: 1
  },
  519: {
    /* n:"BrtEndVolMain", */
    T: -1
  },
  520: {
    /* n:"BrtBeginVolTopic", */
    T: 1
  },
  521: {
    /* n:"BrtEndVolTopic", */
    T: -1
  },
  522: {
    /* n:"BrtVolSubtopic" */
  },
  523: {
    /* n:"BrtVolRef" */
  },
  524: {
    /* n:"BrtVolNum" */
  },
  525: {
    /* n:"BrtVolErr" */
  },
  526: {
    /* n:"BrtVolStr" */
  },
  527: {
    /* n:"BrtVolBool" */
  },
  528: {
    /* n:"BrtBeginCalcChain$", */
    T: 1
  },
  529: {
    /* n:"BrtEndCalcChain$", */
    T: -1
  },
  530: {
    /* n:"BrtBeginSortState", */
    T: 1
  },
  531: {
    /* n:"BrtEndSortState", */
    T: -1
  },
  532: {
    /* n:"BrtBeginSortCond", */
    T: 1
  },
  533: {
    /* n:"BrtEndSortCond", */
    T: -1
  },
  534: {
    /* n:"BrtBookProtection" */
  },
  535: {
    /* n:"BrtSheetProtection" */
  },
  536: {
    /* n:"BrtRangeProtection" */
  },
  537: {
    /* n:"BrtPhoneticInfo" */
  },
  538: {
    /* n:"BrtBeginECTxtWiz", */
    T: 1
  },
  539: {
    /* n:"BrtEndECTxtWiz", */
    T: -1
  },
  540: {
    /* n:"BrtBeginECTWFldInfoLst", */
    T: 1
  },
  541: {
    /* n:"BrtEndECTWFldInfoLst", */
    T: -1
  },
  542: {
    /* n:"BrtBeginECTwFldInfo", */
    T: 1
  },
  548: {
    /* n:"BrtFileSharing" */
  },
  549: {
    /* n:"BrtOleSize" */
  },
  550: {
    /* n:"BrtDrawing", */
    f: parse_RelID
  },
  551: {
    /* n:"BrtLegacyDrawing", */
    f: parse_XLNullableWideString
  },
  552: {
    /* n:"BrtLegacyDrawingHF" */
  },
  553: {
    /* n:"BrtWebOpt" */
  },
  554: {
    /* n:"BrtBeginWebPubItems", */
    T: 1
  },
  555: {
    /* n:"BrtEndWebPubItems", */
    T: -1
  },
  556: {
    /* n:"BrtBeginWebPubItem", */
    T: 1
  },
  557: {
    /* n:"BrtEndWebPubItem", */
    T: -1
  },
  558: {
    /* n:"BrtBeginSXCondFmt", */
    T: 1
  },
  559: {
    /* n:"BrtEndSXCondFmt", */
    T: -1
  },
  560: {
    /* n:"BrtBeginSXCondFmts", */
    T: 1
  },
  561: {
    /* n:"BrtEndSXCondFmts", */
    T: -1
  },
  562: {
    /* n:"BrtBkHim" */
  },
  564: {
    /* n:"BrtColor" */
  },
  565: {
    /* n:"BrtBeginIndexedColors", */
    T: 1
  },
  566: {
    /* n:"BrtEndIndexedColors", */
    T: -1
  },
  569: {
    /* n:"BrtBeginMRUColors", */
    T: 1
  },
  570: {
    /* n:"BrtEndMRUColors", */
    T: -1
  },
  572: {
    /* n:"BrtMRUColor" */
  },
  573: {
    /* n:"BrtBeginDVals", */
    T: 1
  },
  574: {
    /* n:"BrtEndDVals", */
    T: -1
  },
  577: {
    /* n:"BrtSupNameStart" */
  },
  578: {
    /* n:"BrtSupNameValueStart" */
  },
  579: {
    /* n:"BrtSupNameValueEnd" */
  },
  580: {
    /* n:"BrtSupNameNum" */
  },
  581: {
    /* n:"BrtSupNameErr" */
  },
  582: {
    /* n:"BrtSupNameSt" */
  },
  583: {
    /* n:"BrtSupNameNil" */
  },
  584: {
    /* n:"BrtSupNameBool" */
  },
  585: {
    /* n:"BrtSupNameFmla" */
  },
  586: {
    /* n:"BrtSupNameBits" */
  },
  587: {
    /* n:"BrtSupNameEnd" */
  },
  588: {
    /* n:"BrtEndSupBook", */
    T: -1
  },
  589: {
    /* n:"BrtCellSmartTagProperty" */
  },
  590: {
    /* n:"BrtBeginCellSmartTag", */
    T: 1
  },
  591: {
    /* n:"BrtEndCellSmartTag", */
    T: -1
  },
  592: {
    /* n:"BrtBeginCellSmartTags", */
    T: 1
  },
  593: {
    /* n:"BrtEndCellSmartTags", */
    T: -1
  },
  594: {
    /* n:"BrtBeginSmartTags", */
    T: 1
  },
  595: {
    /* n:"BrtEndSmartTags", */
    T: -1
  },
  596: {
    /* n:"BrtSmartTagType" */
  },
  597: {
    /* n:"BrtBeginSmartTagTypes", */
    T: 1
  },
  598: {
    /* n:"BrtEndSmartTagTypes", */
    T: -1
  },
  599: {
    /* n:"BrtBeginSXFilters", */
    T: 1
  },
  600: {
    /* n:"BrtEndSXFilters", */
    T: -1
  },
  601: {
    /* n:"BrtBeginSXFILTER", */
    T: 1
  },
  602: {
    /* n:"BrtEndSXFilter", */
    T: -1
  },
  603: {
    /* n:"BrtBeginFills", */
    T: 1
  },
  604: {
    /* n:"BrtEndFills", */
    T: -1
  },
  605: {
    /* n:"BrtBeginCellWatches", */
    T: 1
  },
  606: {
    /* n:"BrtEndCellWatches", */
    T: -1
  },
  607: {
    /* n:"BrtCellWatch" */
  },
  608: {
    /* n:"BrtBeginCRErrs", */
    T: 1
  },
  609: {
    /* n:"BrtEndCRErrs", */
    T: -1
  },
  610: {
    /* n:"BrtCrashRecErr" */
  },
  611: {
    /* n:"BrtBeginFonts", */
    T: 1
  },
  612: {
    /* n:"BrtEndFonts", */
    T: -1
  },
  613: {
    /* n:"BrtBeginBorders", */
    T: 1
  },
  614: {
    /* n:"BrtEndBorders", */
    T: -1
  },
  615: {
    /* n:"BrtBeginFmts", */
    T: 1
  },
  616: {
    /* n:"BrtEndFmts", */
    T: -1
  },
  617: {
    /* n:"BrtBeginCellXFs", */
    T: 1
  },
  618: {
    /* n:"BrtEndCellXFs", */
    T: -1
  },
  619: {
    /* n:"BrtBeginStyles", */
    T: 1
  },
  620: {
    /* n:"BrtEndStyles", */
    T: -1
  },
  625: {
    /* n:"BrtBigName" */
  },
  626: {
    /* n:"BrtBeginCellStyleXFs", */
    T: 1
  },
  627: {
    /* n:"BrtEndCellStyleXFs", */
    T: -1
  },
  628: {
    /* n:"BrtBeginComments", */
    T: 1
  },
  629: {
    /* n:"BrtEndComments", */
    T: -1
  },
  630: {
    /* n:"BrtBeginCommentAuthors", */
    T: 1
  },
  631: {
    /* n:"BrtEndCommentAuthors", */
    T: -1
  },
  632: {
    /* n:"BrtCommentAuthor", */
    f: parse_BrtCommentAuthor
  },
  633: {
    /* n:"BrtBeginCommentList", */
    T: 1
  },
  634: {
    /* n:"BrtEndCommentList", */
    T: -1
  },
  635: {
    /* n:"BrtBeginComment", */
    T: 1,
    f: parse_BrtBeginComment
  },
  636: {
    /* n:"BrtEndComment", */
    T: -1
  },
  637: {
    /* n:"BrtCommentText", */
    f: parse_BrtCommentText
  },
  638: {
    /* n:"BrtBeginOleObjects", */
    T: 1
  },
  639: {
    /* n:"BrtOleObject" */
  },
  640: {
    /* n:"BrtEndOleObjects", */
    T: -1
  },
  641: {
    /* n:"BrtBeginSxrules", */
    T: 1
  },
  642: {
    /* n:"BrtEndSxRules", */
    T: -1
  },
  643: {
    /* n:"BrtBeginActiveXControls", */
    T: 1
  },
  644: {
    /* n:"BrtActiveX" */
  },
  645: {
    /* n:"BrtEndActiveXControls", */
    T: -1
  },
  646: {
    /* n:"BrtBeginPCDSDTCEMembersSortBy", */
    T: 1
  },
  648: {
    /* n:"BrtBeginCellIgnoreECs", */
    T: 1
  },
  649: {
    /* n:"BrtCellIgnoreEC" */
  },
  650: {
    /* n:"BrtEndCellIgnoreECs", */
    T: -1
  },
  651: {
    /* n:"BrtCsProp", */
    f: parse_BrtCsProp
  },
  652: {
    /* n:"BrtCsPageSetup" */
  },
  653: {
    /* n:"BrtBeginUserCsViews", */
    T: 1
  },
  654: {
    /* n:"BrtEndUserCsViews", */
    T: -1
  },
  655: {
    /* n:"BrtBeginUserCsView", */
    T: 1
  },
  656: {
    /* n:"BrtEndUserCsView", */
    T: -1
  },
  657: {
    /* n:"BrtBeginPcdSFCIEntries", */
    T: 1
  },
  658: {
    /* n:"BrtEndPCDSFCIEntries", */
    T: -1
  },
  659: {
    /* n:"BrtPCDSFCIEntry" */
  },
  660: {
    /* n:"BrtBeginListParts", */
    T: 1
  },
  661: {
    /* n:"BrtListPart" */
  },
  662: {
    /* n:"BrtEndListParts", */
    T: -1
  },
  663: {
    /* n:"BrtSheetCalcProp" */
  },
  664: {
    /* n:"BrtBeginFnGroup", */
    T: 1
  },
  665: {
    /* n:"BrtFnGroup" */
  },
  666: {
    /* n:"BrtEndFnGroup", */
    T: -1
  },
  667: {
    /* n:"BrtSupAddin" */
  },
  668: {
    /* n:"BrtSXTDMPOrder" */
  },
  669: {
    /* n:"BrtCsProtection" */
  },
  671: {
    /* n:"BrtBeginWsSortMap", */
    T: 1
  },
  672: {
    /* n:"BrtEndWsSortMap", */
    T: -1
  },
  673: {
    /* n:"BrtBeginRRSort", */
    T: 1
  },
  674: {
    /* n:"BrtEndRRSort", */
    T: -1
  },
  675: {
    /* n:"BrtRRSortItem" */
  },
  676: {
    /* n:"BrtFileSharingIso" */
  },
  677: {
    /* n:"BrtBookProtectionIso" */
  },
  678: {
    /* n:"BrtSheetProtectionIso" */
  },
  679: {
    /* n:"BrtCsProtectionIso" */
  },
  680: {
    /* n:"BrtRangeProtectionIso" */
  },
  681: {
    /* n:"BrtDValList" */
  },
  1024: {
    /* n:"BrtRwDescent" */
  },
  1025: {
    /* n:"BrtKnownFonts" */
  },
  1026: {
    /* n:"BrtBeginSXTupleSet", */
    T: 1
  },
  1027: {
    /* n:"BrtEndSXTupleSet", */
    T: -1
  },
  1028: {
    /* n:"BrtBeginSXTupleSetHeader", */
    T: 1
  },
  1029: {
    /* n:"BrtEndSXTupleSetHeader", */
    T: -1
  },
  1030: {
    /* n:"BrtSXTupleSetHeaderItem" */
  },
  1031: {
    /* n:"BrtBeginSXTupleSetData", */
    T: 1
  },
  1032: {
    /* n:"BrtEndSXTupleSetData", */
    T: -1
  },
  1033: {
    /* n:"BrtBeginSXTupleSetRow", */
    T: 1
  },
  1034: {
    /* n:"BrtEndSXTupleSetRow", */
    T: -1
  },
  1035: {
    /* n:"BrtSXTupleSetRowItem" */
  },
  1036: {
    /* n:"BrtNameExt" */
  },
  1037: {
    /* n:"BrtPCDH14" */
  },
  1038: {
    /* n:"BrtBeginPCDCalcMem14", */
    T: 1
  },
  1039: {
    /* n:"BrtEndPCDCalcMem14", */
    T: -1
  },
  1040: {
    /* n:"BrtSXTH14" */
  },
  1041: {
    /* n:"BrtBeginSparklineGroup", */
    T: 1
  },
  1042: {
    /* n:"BrtEndSparklineGroup", */
    T: -1
  },
  1043: {
    /* n:"BrtSparkline" */
  },
  1044: {
    /* n:"BrtSXDI14" */
  },
  1045: {
    /* n:"BrtWsFmtInfoEx14" */
  },
  1046: {
    /* n:"BrtBeginConditionalFormatting14", */
    T: 1
  },
  1047: {
    /* n:"BrtEndConditionalFormatting14", */
    T: -1
  },
  1048: {
    /* n:"BrtBeginCFRule14", */
    T: 1
  },
  1049: {
    /* n:"BrtEndCFRule14", */
    T: -1
  },
  1050: {
    /* n:"BrtCFVO14" */
  },
  1051: {
    /* n:"BrtBeginDatabar14", */
    T: 1
  },
  1052: {
    /* n:"BrtBeginIconSet14", */
    T: 1
  },
  1053: {
    /* n:"BrtDVal14", */
    f: parse_BrtDVal14
  },
  1054: {
    /* n:"BrtBeginDVals14", */
    T: 1
  },
  1055: {
    /* n:"BrtColor14" */
  },
  1056: {
    /* n:"BrtBeginSparklines", */
    T: 1
  },
  1057: {
    /* n:"BrtEndSparklines", */
    T: -1
  },
  1058: {
    /* n:"BrtBeginSparklineGroups", */
    T: 1
  },
  1059: {
    /* n:"BrtEndSparklineGroups", */
    T: -1
  },
  1061: {
    /* n:"BrtSXVD14" */
  },
  1062: {
    /* n:"BrtBeginSXView14", */
    T: 1
  },
  1063: {
    /* n:"BrtEndSXView14", */
    T: -1
  },
  1064: {
    /* n:"BrtBeginSXView16", */
    T: 1
  },
  1065: {
    /* n:"BrtEndSXView16", */
    T: -1
  },
  1066: {
    /* n:"BrtBeginPCD14", */
    T: 1
  },
  1067: {
    /* n:"BrtEndPCD14", */
    T: -1
  },
  1068: {
    /* n:"BrtBeginExtConn14", */
    T: 1
  },
  1069: {
    /* n:"BrtEndExtConn14", */
    T: -1
  },
  1070: {
    /* n:"BrtBeginSlicerCacheIDs", */
    T: 1
  },
  1071: {
    /* n:"BrtEndSlicerCacheIDs", */
    T: -1
  },
  1072: {
    /* n:"BrtBeginSlicerCacheID", */
    T: 1
  },
  1073: {
    /* n:"BrtEndSlicerCacheID", */
    T: -1
  },
  1075: {
    /* n:"BrtBeginSlicerCache", */
    T: 1
  },
  1076: {
    /* n:"BrtEndSlicerCache", */
    T: -1
  },
  1077: {
    /* n:"BrtBeginSlicerCacheDef", */
    T: 1
  },
  1078: {
    /* n:"BrtEndSlicerCacheDef", */
    T: -1
  },
  1079: {
    /* n:"BrtBeginSlicersEx", */
    T: 1
  },
  1080: {
    /* n:"BrtEndSlicersEx", */
    T: -1
  },
  1081: {
    /* n:"BrtBeginSlicerEx", */
    T: 1
  },
  1082: {
    /* n:"BrtEndSlicerEx", */
    T: -1
  },
  1083: {
    /* n:"BrtBeginSlicer", */
    T: 1
  },
  1084: {
    /* n:"BrtEndSlicer", */
    T: -1
  },
  1085: {
    /* n:"BrtSlicerCachePivotTables" */
  },
  1086: {
    /* n:"BrtBeginSlicerCacheOlapImpl", */
    T: 1
  },
  1087: {
    /* n:"BrtEndSlicerCacheOlapImpl", */
    T: -1
  },
  1088: {
    /* n:"BrtBeginSlicerCacheLevelsData", */
    T: 1
  },
  1089: {
    /* n:"BrtEndSlicerCacheLevelsData", */
    T: -1
  },
  1090: {
    /* n:"BrtBeginSlicerCacheLevelData", */
    T: 1
  },
  1091: {
    /* n:"BrtEndSlicerCacheLevelData", */
    T: -1
  },
  1092: {
    /* n:"BrtBeginSlicerCacheSiRanges", */
    T: 1
  },
  1093: {
    /* n:"BrtEndSlicerCacheSiRanges", */
    T: -1
  },
  1094: {
    /* n:"BrtBeginSlicerCacheSiRange", */
    T: 1
  },
  1095: {
    /* n:"BrtEndSlicerCacheSiRange", */
    T: -1
  },
  1096: {
    /* n:"BrtSlicerCacheOlapItem" */
  },
  1097: {
    /* n:"BrtBeginSlicerCacheSelections", */
    T: 1
  },
  1098: {
    /* n:"BrtSlicerCacheSelection" */
  },
  1099: {
    /* n:"BrtEndSlicerCacheSelections", */
    T: -1
  },
  1100: {
    /* n:"BrtBeginSlicerCacheNative", */
    T: 1
  },
  1101: {
    /* n:"BrtEndSlicerCacheNative", */
    T: -1
  },
  1102: {
    /* n:"BrtSlicerCacheNativeItem" */
  },
  1103: {
    /* n:"BrtRangeProtection14" */
  },
  1104: {
    /* n:"BrtRangeProtectionIso14" */
  },
  1105: {
    /* n:"BrtCellIgnoreEC14" */
  },
  1111: {
    /* n:"BrtList14" */
  },
  1112: {
    /* n:"BrtCFIcon" */
  },
  1113: {
    /* n:"BrtBeginSlicerCachesPivotCacheIDs", */
    T: 1
  },
  1114: {
    /* n:"BrtEndSlicerCachesPivotCacheIDs", */
    T: -1
  },
  1115: {
    /* n:"BrtBeginSlicers", */
    T: 1
  },
  1116: {
    /* n:"BrtEndSlicers", */
    T: -1
  },
  1117: {
    /* n:"BrtWbProp14" */
  },
  1118: {
    /* n:"BrtBeginSXEdit", */
    T: 1
  },
  1119: {
    /* n:"BrtEndSXEdit", */
    T: -1
  },
  1120: {
    /* n:"BrtBeginSXEdits", */
    T: 1
  },
  1121: {
    /* n:"BrtEndSXEdits", */
    T: -1
  },
  1122: {
    /* n:"BrtBeginSXChange", */
    T: 1
  },
  1123: {
    /* n:"BrtEndSXChange", */
    T: -1
  },
  1124: {
    /* n:"BrtBeginSXChanges", */
    T: 1
  },
  1125: {
    /* n:"BrtEndSXChanges", */
    T: -1
  },
  1126: {
    /* n:"BrtSXTupleItems" */
  },
  1128: {
    /* n:"BrtBeginSlicerStyle", */
    T: 1
  },
  1129: {
    /* n:"BrtEndSlicerStyle", */
    T: -1
  },
  1130: {
    /* n:"BrtSlicerStyleElement" */
  },
  1131: {
    /* n:"BrtBeginStyleSheetExt14", */
    T: 1
  },
  1132: {
    /* n:"BrtEndStyleSheetExt14", */
    T: -1
  },
  1133: {
    /* n:"BrtBeginSlicerCachesPivotCacheID", */
    T: 1
  },
  1134: {
    /* n:"BrtEndSlicerCachesPivotCacheID", */
    T: -1
  },
  1135: {
    /* n:"BrtBeginConditionalFormattings", */
    T: 1
  },
  1136: {
    /* n:"BrtEndConditionalFormattings", */
    T: -1
  },
  1137: {
    /* n:"BrtBeginPCDCalcMemExt", */
    T: 1
  },
  1138: {
    /* n:"BrtEndPCDCalcMemExt", */
    T: -1
  },
  1139: {
    /* n:"BrtBeginPCDCalcMemsExt", */
    T: 1
  },
  1140: {
    /* n:"BrtEndPCDCalcMemsExt", */
    T: -1
  },
  1141: {
    /* n:"BrtPCDField14" */
  },
  1142: {
    /* n:"BrtBeginSlicerStyles", */
    T: 1
  },
  1143: {
    /* n:"BrtEndSlicerStyles", */
    T: -1
  },
  1144: {
    /* n:"BrtBeginSlicerStyleElements", */
    T: 1
  },
  1145: {
    /* n:"BrtEndSlicerStyleElements", */
    T: -1
  },
  1146: {
    /* n:"BrtCFRuleExt" */
  },
  1147: {
    /* n:"BrtBeginSXCondFmt14", */
    T: 1
  },
  1148: {
    /* n:"BrtEndSXCondFmt14", */
    T: -1
  },
  1149: {
    /* n:"BrtBeginSXCondFmts14", */
    T: 1
  },
  1150: {
    /* n:"BrtEndSXCondFmts14", */
    T: -1
  },
  1152: {
    /* n:"BrtBeginSortCond14", */
    T: 1
  },
  1153: {
    /* n:"BrtEndSortCond14", */
    T: -1
  },
  1154: {
    /* n:"BrtEndDVals14", */
    T: -1
  },
  1155: {
    /* n:"BrtEndIconSet14", */
    T: -1
  },
  1156: {
    /* n:"BrtEndDatabar14", */
    T: -1
  },
  1157: {
    /* n:"BrtBeginColorScale14", */
    T: 1
  },
  1158: {
    /* n:"BrtEndColorScale14", */
    T: -1
  },
  1159: {
    /* n:"BrtBeginSxrules14", */
    T: 1
  },
  1160: {
    /* n:"BrtEndSxrules14", */
    T: -1
  },
  1161: {
    /* n:"BrtBeginPRule14", */
    T: 1
  },
  1162: {
    /* n:"BrtEndPRule14", */
    T: -1
  },
  1163: {
    /* n:"BrtBeginPRFilters14", */
    T: 1
  },
  1164: {
    /* n:"BrtEndPRFilters14", */
    T: -1
  },
  1165: {
    /* n:"BrtBeginPRFilter14", */
    T: 1
  },
  1166: {
    /* n:"BrtEndPRFilter14", */
    T: -1
  },
  1167: {
    /* n:"BrtBeginPRFItem14", */
    T: 1
  },
  1168: {
    /* n:"BrtEndPRFItem14", */
    T: -1
  },
  1169: {
    /* n:"BrtBeginCellIgnoreECs14", */
    T: 1
  },
  1170: {
    /* n:"BrtEndCellIgnoreECs14", */
    T: -1
  },
  1171: {
    /* n:"BrtDxf14" */
  },
  1172: {
    /* n:"BrtBeginDxF14s", */
    T: 1
  },
  1173: {
    /* n:"BrtEndDxf14s", */
    T: -1
  },
  1177: {
    /* n:"BrtFilter14" */
  },
  1178: {
    /* n:"BrtBeginCustomFilters14", */
    T: 1
  },
  1180: {
    /* n:"BrtCustomFilter14" */
  },
  1181: {
    /* n:"BrtIconFilter14" */
  },
  1182: {
    /* n:"BrtPivotCacheConnectionName" */
  },
  2048: {
    /* n:"BrtBeginDecoupledPivotCacheIDs", */
    T: 1
  },
  2049: {
    /* n:"BrtEndDecoupledPivotCacheIDs", */
    T: -1
  },
  2050: {
    /* n:"BrtDecoupledPivotCacheID" */
  },
  2051: {
    /* n:"BrtBeginPivotTableRefs", */
    T: 1
  },
  2052: {
    /* n:"BrtEndPivotTableRefs", */
    T: -1
  },
  2053: {
    /* n:"BrtPivotTableRef" */
  },
  2054: {
    /* n:"BrtSlicerCacheBookPivotTables" */
  },
  2055: {
    /* n:"BrtBeginSxvcells", */
    T: 1
  },
  2056: {
    /* n:"BrtEndSxvcells", */
    T: -1
  },
  2057: {
    /* n:"BrtBeginSxRow", */
    T: 1
  },
  2058: {
    /* n:"BrtEndSxRow", */
    T: -1
  },
  2060: {
    /* n:"BrtPcdCalcMem15" */
  },
  2067: {
    /* n:"BrtQsi15" */
  },
  2068: {
    /* n:"BrtBeginWebExtensions", */
    T: 1
  },
  2069: {
    /* n:"BrtEndWebExtensions", */
    T: -1
  },
  2070: {
    /* n:"BrtWebExtension" */
  },
  2071: {
    /* n:"BrtAbsPath15" */
  },
  2072: {
    /* n:"BrtBeginPivotTableUISettings", */
    T: 1
  },
  2073: {
    /* n:"BrtEndPivotTableUISettings", */
    T: -1
  },
  2075: {
    /* n:"BrtTableSlicerCacheIDs" */
  },
  2076: {
    /* n:"BrtTableSlicerCacheID" */
  },
  2077: {
    /* n:"BrtBeginTableSlicerCache", */
    T: 1
  },
  2078: {
    /* n:"BrtEndTableSlicerCache", */
    T: -1
  },
  2079: {
    /* n:"BrtSxFilter15" */
  },
  2080: {
    /* n:"BrtBeginTimelineCachePivotCacheIDs", */
    T: 1
  },
  2081: {
    /* n:"BrtEndTimelineCachePivotCacheIDs", */
    T: -1
  },
  2082: {
    /* n:"BrtTimelineCachePivotCacheID" */
  },
  2083: {
    /* n:"BrtBeginTimelineCacheIDs", */
    T: 1
  },
  2084: {
    /* n:"BrtEndTimelineCacheIDs", */
    T: -1
  },
  2085: {
    /* n:"BrtBeginTimelineCacheID", */
    T: 1
  },
  2086: {
    /* n:"BrtEndTimelineCacheID", */
    T: -1
  },
  2087: {
    /* n:"BrtBeginTimelinesEx", */
    T: 1
  },
  2088: {
    /* n:"BrtEndTimelinesEx", */
    T: -1
  },
  2089: {
    /* n:"BrtBeginTimelineEx", */
    T: 1
  },
  2090: {
    /* n:"BrtEndTimelineEx", */
    T: -1
  },
  2091: {
    /* n:"BrtWorkBookPr15" */
  },
  2092: {
    /* n:"BrtPCDH15" */
  },
  2093: {
    /* n:"BrtBeginTimelineStyle", */
    T: 1
  },
  2094: {
    /* n:"BrtEndTimelineStyle", */
    T: -1
  },
  2095: {
    /* n:"BrtTimelineStyleElement" */
  },
  2096: {
    /* n:"BrtBeginTimelineStylesheetExt15", */
    T: 1
  },
  2097: {
    /* n:"BrtEndTimelineStylesheetExt15", */
    T: -1
  },
  2098: {
    /* n:"BrtBeginTimelineStyles", */
    T: 1
  },
  2099: {
    /* n:"BrtEndTimelineStyles", */
    T: -1
  },
  2100: {
    /* n:"BrtBeginTimelineStyleElements", */
    T: 1
  },
  2101: {
    /* n:"BrtEndTimelineStyleElements", */
    T: -1
  },
  2102: {
    /* n:"BrtDxf15" */
  },
  2103: {
    /* n:"BrtBeginDxfs15", */
    T: 1
  },
  2104: {
    /* n:"BrtEndDxfs15", */
    T: -1
  },
  2105: {
    /* n:"BrtSlicerCacheHideItemsWithNoData" */
  },
  2106: {
    /* n:"BrtBeginItemUniqueNames", */
    T: 1
  },
  2107: {
    /* n:"BrtEndItemUniqueNames", */
    T: -1
  },
  2108: {
    /* n:"BrtItemUniqueName" */
  },
  2109: {
    /* n:"BrtBeginExtConn15", */
    T: 1
  },
  2110: {
    /* n:"BrtEndExtConn15", */
    T: -1
  },
  2111: {
    /* n:"BrtBeginOledbPr15", */
    T: 1
  },
  2112: {
    /* n:"BrtEndOledbPr15", */
    T: -1
  },
  2113: {
    /* n:"BrtBeginDataFeedPr15", */
    T: 1
  },
  2114: {
    /* n:"BrtEndDataFeedPr15", */
    T: -1
  },
  2115: {
    /* n:"BrtTextPr15" */
  },
  2116: {
    /* n:"BrtRangePr15" */
  },
  2117: {
    /* n:"BrtDbCommand15" */
  },
  2118: {
    /* n:"BrtBeginDbTables15", */
    T: 1
  },
  2119: {
    /* n:"BrtEndDbTables15", */
    T: -1
  },
  2120: {
    /* n:"BrtDbTable15" */
  },
  2121: {
    /* n:"BrtBeginDataModel", */
    T: 1
  },
  2122: {
    /* n:"BrtEndDataModel", */
    T: -1
  },
  2123: {
    /* n:"BrtBeginModelTables", */
    T: 1
  },
  2124: {
    /* n:"BrtEndModelTables", */
    T: -1
  },
  2125: {
    /* n:"BrtModelTable" */
  },
  2126: {
    /* n:"BrtBeginModelRelationships", */
    T: 1
  },
  2127: {
    /* n:"BrtEndModelRelationships", */
    T: -1
  },
  2128: {
    /* n:"BrtModelRelationship" */
  },
  2129: {
    /* n:"BrtBeginECTxtWiz15", */
    T: 1
  },
  2130: {
    /* n:"BrtEndECTxtWiz15", */
    T: -1
  },
  2131: {
    /* n:"BrtBeginECTWFldInfoLst15", */
    T: 1
  },
  2132: {
    /* n:"BrtEndECTWFldInfoLst15", */
    T: -1
  },
  2133: {
    /* n:"BrtBeginECTWFldInfo15", */
    T: 1
  },
  2134: {
    /* n:"BrtFieldListActiveItem" */
  },
  2135: {
    /* n:"BrtPivotCacheIdVersion" */
  },
  2136: {
    /* n:"BrtSXDI15" */
  },
  2137: {
    /* n:"BrtBeginModelTimeGroupings", */
    T: 1
  },
  2138: {
    /* n:"BrtEndModelTimeGroupings", */
    T: -1
  },
  2139: {
    /* n:"BrtBeginModelTimeGrouping", */
    T: 1
  },
  2140: {
    /* n:"BrtEndModelTimeGrouping", */
    T: -1
  },
  2141: {
    /* n:"BrtModelTimeGroupingCalcCol" */
  },
  3072: {
    /* n:"BrtUid" */
  },
  3073: {
    /* n:"BrtRevisionPtr" */
  },
  4096: {
    /* n:"BrtBeginDynamicArrayPr", */
    T: 1
  },
  4097: {
    /* n:"BrtEndDynamicArrayPr", */
    T: -1
  },
  5002: {
    /* n:"BrtBeginRichValueBlock", */
    T: 1
  },
  5003: {
    /* n:"BrtEndRichValueBlock", */
    T: -1
  },
  5081: {
    /* n:"BrtBeginRichFilters", */
    T: 1
  },
  5082: {
    /* n:"BrtEndRichFilters", */
    T: -1
  },
  5083: {
    /* n:"BrtRichFilter" */
  },
  5084: {
    /* n:"BrtBeginRichFilterColumn", */
    T: 1
  },
  5085: {
    /* n:"BrtEndRichFilterColumn", */
    T: -1
  },
  5086: {
    /* n:"BrtBeginCustomRichFilters", */
    T: 1
  },
  5087: {
    /* n:"BrtEndCustomRichFilters", */
    T: -1
  },
  5088: {
    /* n:"BrtCustomRichFilter" */
  },
  5089: {
    /* n:"BrtTop10RichFilter" */
  },
  5090: {
    /* n:"BrtDynamicRichFilter" */
  },
  5092: {
    /* n:"BrtBeginRichSortCondition", */
    T: 1
  },
  5093: {
    /* n:"BrtEndRichSortCondition", */
    T: -1
  },
  5094: {
    /* n:"BrtRichFilterDateGroupItem" */
  },
  5095: {
    /* n:"BrtBeginCalcFeatures", */
    T: 1
  },
  5096: {
    /* n:"BrtEndCalcFeatures", */
    T: -1
  },
  5097: {
    /* n:"BrtCalcFeature" */
  },
  5099: {
    /* n:"BrtExternalLinksPr" */
  },
  65535: { n: "" }
};
var XLSRecordEnum = {
  /* [MS-XLS] 2.3 Record Enumeration 2021-08-17 */
  6: {
    /* n:"Formula", */
    f: parse_Formula
  },
  10: {
    /* n:"EOF", */
    f: parsenoop2
  },
  12: {
    /* n:"CalcCount", */
    f: parseuint16
  },
  //
  13: {
    /* n:"CalcMode", */
    f: parseuint16
  },
  //
  14: {
    /* n:"CalcPrecision", */
    f: parsebool
  },
  //
  15: {
    /* n:"CalcRefMode", */
    f: parsebool
  },
  //
  16: {
    /* n:"CalcDelta", */
    f: parse_Xnum
  },
  //
  17: {
    /* n:"CalcIter", */
    f: parsebool
  },
  //
  18: {
    /* n:"Protect", */
    f: parsebool
  },
  19: {
    /* n:"Password", */
    f: parseuint16
  },
  20: {
    /* n:"Header", */
    f: parse_XLHeaderFooter
  },
  21: {
    /* n:"Footer", */
    f: parse_XLHeaderFooter
  },
  23: {
    /* n:"ExternSheet", */
    f: parse_ExternSheet
  },
  24: {
    /* n:"Lbl", */
    f: parse_Lbl
  },
  25: {
    /* n:"WinProtect", */
    f: parsebool
  },
  26: {
    /* n:"VerticalPageBreaks", */
  },
  27: {
    /* n:"HorizontalPageBreaks", */
  },
  28: {
    /* n:"Note", */
    f: parse_Note
  },
  29: {
    /* n:"Selection", */
  },
  34: {
    /* n:"Date1904", */
    f: parsebool
  },
  35: {
    /* n:"ExternName", */
    f: parse_ExternName
  },
  38: {
    /* n:"LeftMargin", */
    f: parse_Xnum
  },
  // *
  39: {
    /* n:"RightMargin", */
    f: parse_Xnum
  },
  // *
  40: {
    /* n:"TopMargin", */
    f: parse_Xnum
  },
  // *
  41: {
    /* n:"BottomMargin", */
    f: parse_Xnum
  },
  // *
  42: {
    /* n:"PrintRowCol", */
    f: parsebool
  },
  43: {
    /* n:"PrintGrid", */
    f: parsebool
  },
  47: {
    /* n:"FilePass", */
    f: parse_FilePass
  },
  49: {
    /* n:"Font", */
    f: parse_Font
  },
  51: {
    /* n:"PrintSize", */
    f: parseuint16
  },
  60: {
    /* n:"Continue", */
  },
  61: {
    /* n:"Window1", */
    f: parse_Window1
  },
  64: {
    /* n:"Backup", */
    f: parsebool
  },
  65: {
    /* n:"Pane", */
    f: parse_Pane
  },
  66: {
    /* n:"CodePage", */
    f: parseuint16
  },
  77: {
    /* n:"Pls", */
  },
  80: {
    /* n:"DCon", */
  },
  81: {
    /* n:"DConRef", */
  },
  82: {
    /* n:"DConName", */
  },
  85: {
    /* n:"DefColWidth", */
    f: parseuint16
  },
  89: {
    /* n:"XCT", */
  },
  90: {
    /* n:"CRN", */
  },
  91: {
    /* n:"FileSharing", */
  },
  92: {
    /* n:"WriteAccess", */
    f: parse_WriteAccess
  },
  93: {
    /* n:"Obj", */
    f: parse_Obj
  },
  94: {
    /* n:"Uncalced", */
  },
  95: {
    /* n:"CalcSaveRecalc", */
    f: parsebool
  },
  //
  96: {
    /* n:"Template", */
  },
  97: {
    /* n:"Intl", */
  },
  99: {
    /* n:"ObjProtect", */
    f: parsebool
  },
  125: {
    /* n:"ColInfo", */
    f: parse_ColInfo
  },
  128: {
    /* n:"Guts", */
    f: parse_Guts
  },
  129: {
    /* n:"WsBool", */
    f: parse_WsBool
  },
  130: {
    /* n:"GridSet", */
    f: parseuint16
  },
  131: {
    /* n:"HCenter", */
    f: parsebool
  },
  132: {
    /* n:"VCenter", */
    f: parsebool
  },
  133: {
    /* n:"BoundSheet8", */
    f: parse_BoundSheet8
  },
  134: {
    /* n:"WriteProtect", */
  },
  140: {
    /* n:"Country", */
    f: parse_Country
  },
  141: {
    /* n:"HideObj", */
    f: parseuint16
  },
  144: {
    /* n:"Sort", */
  },
  146: {
    /* n:"Palette", */
    f: parse_Palette
  },
  151: {
    /* n:"Sync", */
  },
  152: {
    /* n:"LPr", */
  },
  153: {
    /* n:"DxGCol", */
  },
  154: {
    /* n:"FnGroupName", */
  },
  155: {
    /* n:"FilterMode", */
  },
  156: {
    /* n:"BuiltInFnGroupCount", */
    f: parseuint16
  },
  157: {
    /* n:"AutoFilterInfo", */
  },
  158: {
    /* n:"AutoFilter", */
  },
  160: {
    /* n:"Scl", */
    f: parse_Scl
  },
  161: {
    /* n:"Setup", */
    f: parse_Setup
  },
  174: {
    /* n:"ScenMan", */
  },
  175: {
    /* n:"SCENARIO", */
  },
  176: {
    /* n:"SxView", */
  },
  177: {
    /* n:"Sxvd", */
  },
  178: {
    /* n:"SXVI", */
  },
  180: {
    /* n:"SxIvd", */
  },
  181: {
    /* n:"SXLI", */
  },
  182: {
    /* n:"SXPI", */
  },
  184: {
    /* n:"DocRoute", */
  },
  185: {
    /* n:"RecipName", */
  },
  189: {
    /* n:"MulRk", */
    f: parse_MulRk
  },
  190: {
    /* n:"MulBlank", */
    f: parse_MulBlank
  },
  193: {
    /* n:"Mms", */
    f: parsenoop2
  },
  197: {
    /* n:"SXDI", */
  },
  198: {
    /* n:"SXDB", */
  },
  199: {
    /* n:"SXFDB", */
  },
  200: {
    /* n:"SXDBB", */
  },
  201: {
    /* n:"SXNum", */
  },
  202: {
    /* n:"SxBool", */
    f: parsebool
  },
  203: {
    /* n:"SxErr", */
  },
  204: {
    /* n:"SXInt", */
  },
  205: {
    /* n:"SXString", */
  },
  206: {
    /* n:"SXDtr", */
  },
  207: {
    /* n:"SxNil", */
  },
  208: {
    /* n:"SXTbl", */
  },
  209: {
    /* n:"SXTBRGIITM", */
  },
  210: {
    /* n:"SxTbpg", */
  },
  211: {
    /* n:"ObProj", */
  },
  213: {
    /* n:"SXStreamID", */
  },
  215: {
    /* n:"DBCell", */
  },
  216: {
    /* n:"SXRng", */
  },
  217: {
    /* n:"SxIsxoper", */
  },
  218: {
    /* n:"BookBool", */
    f: parseuint16
  },
  220: {
    /* n:"DbOrParamQry", */
  },
  221: {
    /* n:"ScenarioProtect", */
    f: parsebool
  },
  222: {
    /* n:"OleObjectSize", */
  },
  224: {
    /* n:"XF", */
    f: parse_XF
  },
  225: {
    /* n:"InterfaceHdr", */
    f: parse_InterfaceHdr
  },
  226: {
    /* n:"InterfaceEnd", */
    f: parsenoop2
  },
  227: {
    /* n:"SXVS", */
  },
  229: {
    /* n:"MergeCells", */
    f: parse_MergeCells
  },
  233: {
    /* n:"BkHim", */
  },
  235: {
    /* n:"MsoDrawingGroup", */
  },
  236: {
    /* n:"MsoDrawing", */
  },
  237: {
    /* n:"MsoDrawingSelection", */
  },
  239: {
    /* n:"PhoneticInfo", */
  },
  240: {
    /* n:"SxRule", */
  },
  241: {
    /* n:"SXEx", */
  },
  242: {
    /* n:"SxFilt", */
  },
  244: {
    /* n:"SxDXF", */
  },
  245: {
    /* n:"SxItm", */
  },
  246: {
    /* n:"SxName", */
  },
  247: {
    /* n:"SxSelect", */
  },
  248: {
    /* n:"SXPair", */
  },
  249: {
    /* n:"SxFmla", */
  },
  251: {
    /* n:"SxFormat", */
  },
  252: {
    /* n:"SST", */
    f: parse_SST
  },
  253: {
    /* n:"LabelSst", */
    f: parse_LabelSst
  },
  255: {
    /* n:"ExtSST", */
    f: parse_ExtSST
  },
  256: {
    /* n:"SXVDEx", */
  },
  259: {
    /* n:"SXFormula", */
  },
  290: {
    /* n:"SXDBEx", */
  },
  311: {
    /* n:"RRDInsDel", */
  },
  312: {
    /* n:"RRDHead", */
  },
  315: {
    /* n:"RRDChgCell", */
  },
  317: {
    /* n:"RRTabId", */
    f: parseuint16a
  },
  318: {
    /* n:"RRDRenSheet", */
  },
  319: {
    /* n:"RRSort", */
  },
  320: {
    /* n:"RRDMove", */
  },
  330: {
    /* n:"RRFormat", */
  },
  331: {
    /* n:"RRAutoFmt", */
  },
  333: {
    /* n:"RRInsertSh", */
  },
  334: {
    /* n:"RRDMoveBegin", */
  },
  335: {
    /* n:"RRDMoveEnd", */
  },
  336: {
    /* n:"RRDInsDelBegin", */
  },
  337: {
    /* n:"RRDInsDelEnd", */
  },
  338: {
    /* n:"RRDConflict", */
  },
  339: {
    /* n:"RRDDefName", */
  },
  340: {
    /* n:"RRDRstEtxp", */
  },
  351: {
    /* n:"LRng", */
  },
  352: {
    /* n:"UsesELFs", */
    f: parsebool
  },
  353: {
    /* n:"DSF", */
    f: parsenoop2
  },
  401: {
    /* n:"CUsr", */
  },
  402: {
    /* n:"CbUsr", */
  },
  403: {
    /* n:"UsrInfo", */
  },
  404: {
    /* n:"UsrExcl", */
  },
  405: {
    /* n:"FileLock", */
  },
  406: {
    /* n:"RRDInfo", */
  },
  407: {
    /* n:"BCUsrs", */
  },
  408: {
    /* n:"UsrChk", */
  },
  425: {
    /* n:"UserBView", */
  },
  426: {
    /* n:"UserSViewBegin", */
  },
  427: {
    /* n:"UserSViewEnd", */
  },
  428: {
    /* n:"RRDUserView", */
  },
  429: {
    /* n:"Qsi", */
  },
  430: {
    /* n:"SupBook", */
    f: parse_SupBook
  },
  431: {
    /* n:"Prot4Rev", */
    f: parsebool
  },
  432: {
    /* n:"CondFmt", */
  },
  433: {
    /* n:"CF", */
  },
  434: {
    /* n:"DVal", */
  },
  437: {
    /* n:"DConBin", */
  },
  438: {
    /* n:"TxO", */
    f: parse_TxO
  },
  439: {
    /* n:"RefreshAll", */
    f: parsebool
  },
  //
  440: {
    /* n:"HLink", */
    f: parse_HLink
  },
  441: {
    /* n:"Lel", */
  },
  442: {
    /* n:"CodeName", */
    f: parse_XLUnicodeString
  },
  443: {
    /* n:"SXFDBType", */
  },
  444: {
    /* n:"Prot4RevPass", */
    f: parseuint16
  },
  445: {
    /* n:"ObNoMacros", */
  },
  446: {
    /* n:"Dv", */
  },
  448: {
    /* n:"Excel9File", */
    f: parsenoop2
  },
  449: {
    /* n:"RecalcId", */
    f: parse_RecalcId,
    r: 2
  },
  450: {
    /* n:"EntExU2", */
    f: parsenoop2
  },
  512: {
    /* n:"Dimensions", */
    f: parse_Dimensions
  },
  513: {
    /* n:"Blank", */
    f: parse_Blank
  },
  515: {
    /* n:"Number", */
    f: parse_Number
  },
  516: {
    /* n:"Label", */
    f: parse_Label
  },
  517: {
    /* n:"BoolErr", */
    f: parse_BoolErr
  },
  519: {
    /* n:"String", */
    f: parse_String
  },
  520: {
    /* n:"Row", */
    f: parse_Row
  },
  523: {
    /* n:"Index", */
  },
  545: {
    /* n:"Array", */
    f: parse_Array
  },
  549: {
    /* n:"DefaultRowHeight", */
    f: parse_DefaultRowHeight
  },
  566: {
    /* n:"Table", */
  },
  574: {
    /* n:"Window2", */
    f: parse_Window2
  },
  638: {
    /* n:"RK", */
    f: parse_RK
  },
  659: {
    /* n:"Style", */
  },
  1048: {
    /* n:"BigName", */
  },
  1054: {
    /* n:"Format", */
    f: parse_Format
  },
  1084: {
    /* n:"ContinueBigName", */
  },
  1212: {
    /* n:"ShrFmla", */
    f: parse_ShrFmla
  },
  2048: {
    /* n:"HLinkTooltip", */
    f: parse_HLinkTooltip
  },
  2049: {
    /* n:"WebPub", */
  },
  2050: {
    /* n:"QsiSXTag", */
  },
  2051: {
    /* n:"DBQueryExt", */
  },
  2052: {
    /* n:"ExtString", */
  },
  2053: {
    /* n:"TxtQry", */
  },
  2054: {
    /* n:"Qsir", */
  },
  2055: {
    /* n:"Qsif", */
  },
  2056: {
    /* n:"RRDTQSIF", */
  },
  2057: {
    /* n:"BOF", */
    f: parse_BOF
  },
  2058: {
    /* n:"OleDbConn", */
  },
  2059: {
    /* n:"WOpt", */
  },
  2060: {
    /* n:"SXViewEx", */
  },
  2061: {
    /* n:"SXTH", */
  },
  2062: {
    /* n:"SXPIEx", */
  },
  2063: {
    /* n:"SXVDTEx", */
  },
  2064: {
    /* n:"SXViewEx9", */
  },
  2066: {
    /* n:"ContinueFrt", */
  },
  2067: {
    /* n:"RealTimeData", */
  },
  2128: {
    /* n:"ChartFrtInfo", */
  },
  2129: {
    /* n:"FrtWrapper", */
  },
  2130: {
    /* n:"StartBlock", */
  },
  2131: {
    /* n:"EndBlock", */
  },
  2132: {
    /* n:"StartObject", */
  },
  2133: {
    /* n:"EndObject", */
  },
  2134: {
    /* n:"CatLab", */
  },
  2135: {
    /* n:"YMult", */
  },
  2136: {
    /* n:"SXViewLink", */
  },
  2137: {
    /* n:"PivotChartBits", */
  },
  2138: {
    /* n:"FrtFontList", */
  },
  2146: {
    /* n:"SheetExt", */
  },
  2147: {
    /* n:"BookExt", */
    r: 12
  },
  2148: {
    /* n:"SXAddl", */
  },
  2149: {
    /* n:"CrErr", */
  },
  2150: {
    /* n:"HFPicture", */
  },
  2151: {
    /* n:"FeatHdr", */
    f: parsenoop2
  },
  2152: {
    /* n:"Feat", */
  },
  2154: {
    /* n:"DataLabExt", */
  },
  2155: {
    /* n:"DataLabExtContents", */
  },
  2156: {
    /* n:"CellWatch", */
  },
  2161: {
    /* n:"FeatHdr11", */
  },
  2162: {
    /* n:"Feature11", */
  },
  2164: {
    /* n:"DropDownObjIds", */
  },
  2165: {
    /* n:"ContinueFrt11", */
  },
  2166: {
    /* n:"DConn", */
  },
  2167: {
    /* n:"List12", */
  },
  2168: {
    /* n:"Feature12", */
  },
  2169: {
    /* n:"CondFmt12", */
  },
  2170: {
    /* n:"CF12", */
  },
  2171: {
    /* n:"CFEx", */
  },
  2172: {
    /* n:"XFCRC", */
    f: parse_XFCRC,
    r: 12
  },
  2173: {
    /* n:"XFExt", */
    f: parse_XFExt,
    r: 12
  },
  2174: {
    /* n:"AutoFilter12", */
  },
  2175: {
    /* n:"ContinueFrt12", */
  },
  2180: {
    /* n:"MDTInfo", */
  },
  2181: {
    /* n:"MDXStr", */
  },
  2182: {
    /* n:"MDXTuple", */
  },
  2183: {
    /* n:"MDXSet", */
  },
  2184: {
    /* n:"MDXProp", */
  },
  2185: {
    /* n:"MDXKPI", */
  },
  2186: {
    /* n:"MDB", */
  },
  2187: {
    /* n:"PLV", */
  },
  2188: {
    /* n:"Compat12", */
    f: parsebool,
    r: 12
  },
  2189: {
    /* n:"DXF", */
  },
  2190: {
    /* n:"TableStyles", */
    r: 12
  },
  2191: {
    /* n:"TableStyle", */
  },
  2192: {
    /* n:"TableStyleElement", */
  },
  2194: {
    /* n:"StyleExt", */
  },
  2195: {
    /* n:"NamePublish", */
  },
  2196: {
    /* n:"NameCmt", */
    f: parse_NameCmt,
    r: 12
  },
  2197: {
    /* n:"SortData", */
  },
  2198: {
    /* n:"Theme", */
    f: parse_Theme,
    r: 12
  },
  2199: {
    /* n:"GUIDTypeLib", */
  },
  2200: {
    /* n:"FnGrp12", */
  },
  2201: {
    /* n:"NameFnGrp12", */
  },
  2202: {
    /* n:"MTRSettings", */
    f: parse_MTRSettings,
    r: 12
  },
  2203: {
    /* n:"CompressPictures", */
    f: parsenoop2
  },
  2204: {
    /* n:"HeaderFooter", */
  },
  2205: {
    /* n:"CrtLayout12", */
  },
  2206: {
    /* n:"CrtMlFrt", */
  },
  2207: {
    /* n:"CrtMlFrtContinue", */
  },
  2211: {
    /* n:"ForceFullCalculation", */
    f: parse_ForceFullCalculation
  },
  2212: {
    /* n:"ShapePropsStream", */
  },
  2213: {
    /* n:"TextPropsStream", */
  },
  2214: {
    /* n:"RichTextStream", */
  },
  2215: {
    /* n:"CrtLayout12A", */
  },
  4097: {
    /* n:"Units", */
  },
  4098: {
    /* n:"Chart", */
  },
  4099: {
    /* n:"Series", */
  },
  4102: {
    /* n:"DataFormat", */
  },
  4103: {
    /* n:"LineFormat", */
  },
  4105: {
    /* n:"MarkerFormat", */
  },
  4106: {
    /* n:"AreaFormat", */
  },
  4107: {
    /* n:"PieFormat", */
  },
  4108: {
    /* n:"AttachedLabel", */
  },
  4109: {
    /* n:"SeriesText", */
  },
  4116: {
    /* n:"ChartFormat", */
  },
  4117: {
    /* n:"Legend", */
  },
  4118: {
    /* n:"SeriesList", */
  },
  4119: {
    /* n:"Bar", */
  },
  4120: {
    /* n:"Line", */
  },
  4121: {
    /* n:"Pie", */
  },
  4122: {
    /* n:"Area", */
  },
  4123: {
    /* n:"Scatter", */
  },
  4124: {
    /* n:"CrtLine", */
  },
  4125: {
    /* n:"Axis", */
  },
  4126: {
    /* n:"Tick", */
  },
  4127: {
    /* n:"ValueRange", */
  },
  4128: {
    /* n:"CatSerRange", */
  },
  4129: {
    /* n:"AxisLine", */
  },
  4130: {
    /* n:"CrtLink", */
  },
  4132: {
    /* n:"DefaultText", */
  },
  4133: {
    /* n:"Text", */
  },
  4134: {
    /* n:"FontX", */
    f: parseuint16
  },
  4135: {
    /* n:"ObjectLink", */
  },
  4146: {
    /* n:"Frame", */
  },
  4147: {
    /* n:"Begin", */
  },
  4148: {
    /* n:"End", */
  },
  4149: {
    /* n:"PlotArea", */
  },
  4154: {
    /* n:"Chart3d", */
  },
  4156: {
    /* n:"PicF", */
  },
  4157: {
    /* n:"DropBar", */
  },
  4158: {
    /* n:"Radar", */
  },
  4159: {
    /* n:"Surf", */
  },
  4160: {
    /* n:"RadarArea", */
  },
  4161: {
    /* n:"AxisParent", */
  },
  4163: {
    /* n:"LegendException", */
  },
  4164: {
    /* n:"ShtProps", */
    f: parse_ShtProps
  },
  4165: {
    /* n:"SerToCrt", */
  },
  4166: {
    /* n:"AxesUsed", */
  },
  4168: {
    /* n:"SBaseRef", */
  },
  4170: {
    /* n:"SerParent", */
  },
  4171: {
    /* n:"SerAuxTrend", */
  },
  4174: {
    /* n:"IFmtRecord", */
  },
  4175: {
    /* n:"Pos", */
  },
  4176: {
    /* n:"AlRuns", */
  },
  4177: {
    /* n:"BRAI", */
  },
  4187: {
    /* n:"SerAuxErrBar", */
  },
  4188: {
    /* n:"ClrtClient", */
    f: parse_ClrtClient
  },
  4189: {
    /* n:"SerFmt", */
  },
  4191: {
    /* n:"Chart3DBarShape", */
  },
  4192: {
    /* n:"Fbi", */
  },
  4193: {
    /* n:"BopPop", */
  },
  4194: {
    /* n:"AxcExt", */
  },
  4195: {
    /* n:"Dat", */
  },
  4196: {
    /* n:"PlotGrowth", */
  },
  4197: {
    /* n:"SIIndex", */
  },
  4198: {
    /* n:"GelFrame", */
  },
  4199: {
    /* n:"BopPopCustom", */
  },
  4200: {
    /* n:"Fbi2", */
  },
  0: {
    /* n:"Dimensions", */
    f: parse_Dimensions
  },
  1: {
    /* n:"BIFF2BLANK", */
  },
  2: {
    /* n:"BIFF2INT", */
    f: parse_BIFF2INT
  },
  3: {
    /* n:"BIFF2NUM", */
    f: parse_BIFF2NUM
  },
  4: {
    /* n:"BIFF2STR", */
    f: parse_BIFF2STR
  },
  5: {
    /* n:"BIFF2BOOLERR", */
    f: parse_BIFF2BOOLERR
  },
  7: {
    /* n:"String", */
    f: parse_BIFF2STRING
  },
  8: {
    /* n:"BIFF2ROW", */
  },
  9: {
    /* n:"BOF", */
    f: parse_BOF
  },
  11: {
    /* n:"Index", */
  },
  22: {
    /* n:"ExternCount", */
    f: parseuint16
  },
  30: {
    /* n:"BIFF2FORMAT", */
    f: parse_BIFF2Format
  },
  31: {
    /* n:"BIFF2FMTCNT", */
  },
  /* 16-bit cnt of BIFF2FORMAT records */
  32: {
    /* n:"BIFF2COLINFO", */
  },
  33: {
    /* n:"Array", */
    f: parse_Array
  },
  36: {
    /* n:"COLWIDTH", */
  },
  37: {
    /* n:"DefaultRowHeight", */
    f: parse_DefaultRowHeight
  },
  // 0x002c ??
  // 0x002d ??
  // 0x002e ??
  // 0x0030 FONTCOUNT: number of fonts
  50: {
    /* n:"BIFF2FONTXTRA", */
    f: parse_BIFF2FONTXTRA
  },
  // 0x0035: INFOOPTS
  // 0x0036: TABLE (BIFF2 only)
  // 0x0037: TABLE2 (BIFF2 only)
  // 0x0038: WNDESK
  // 0x0039 ??
  // 0x003a: BEGINPREF
  // 0x003b: ENDPREF
  62: {
    /* n:"BIFF2WINDOW2", */
  },
  // 0x003f ??
  // 0x0046: SHOWSCROLL
  // 0x0047: SHOWFORMULA
  // 0x0048: STATUSBAR
  // 0x0049: SHORTMENUS
  // 0x004A:
  // 0x004B:
  // 0x004C:
  // 0x004E:
  // 0x004F:
  // 0x0058: TOOLBAR (BIFF3)
  /* - - - */
  52: {
    /* n:"DDEObjName", */
  },
  67: {
    /* n:"BIFF2XF", */
    f: parse_BIFF2XF
  },
  68: {
    /* n:"BIFF2XFINDEX", */
    f: parseuint16
  },
  69: {
    /* n:"BIFF2FONTCLR", */
  },
  86: {
    /* n:"BIFF4FMTCNT", */
  },
  /* 16-bit cnt, similar to BIFF2 */
  126: {
    /* n:"RK", */
  },
  /* Not necessarily same as 0x027e */
  127: {
    /* n:"ImData", */
    f: parse_ImData
  },
  135: {
    /* n:"Addin", */
  },
  136: {
    /* n:"Edg", */
  },
  137: {
    /* n:"Pub", */
  },
  // 0x8A
  // 0x8B LH: alternate menu key flag (BIFF3/4)
  // 0x8E
  143: {
    /* n:"BIFF4SheetInfo", */
    f: parse_BIFF4SheetInfo
  },
  145: {
    /* n:"Sub", */
  },
  // 0x93 STYLE
  148: {
    /* n:"LHRecord", */
  },
  149: {
    /* n:"LHNGraph", */
  },
  150: {
    /* n:"Sound", */
  },
  // 0xA2 FNPROTO: function prototypes (BIFF4)
  // 0xA3
  // 0xA8
  169: {
    /* n:"CoordList", */
  },
  171: {
    /* n:"GCW", */
  },
  188: {
    /* n:"ShrFmla", */
  },
  /* Not necessarily same as 0x04bc */
  191: {
    /* n:"ToolbarHdr", */
  },
  192: {
    /* n:"ToolbarEnd", */
  },
  194: {
    /* n:"AddMenu", */
  },
  195: {
    /* n:"DelMenu", */
  },
  214: {
    /* n:"RString", */
    f: parse_RString
  },
  223: {
    /* n:"UDDesc", */
  },
  234: {
    /* n:"TabIdConf", */
  },
  354: {
    /* n:"XL5Modify", */
  },
  421: {
    /* n:"FileSharing2", */
  },
  518: {
    /* n:"Formula", */
    f: parse_Formula
  },
  521: {
    /* n:"BOF", */
    f: parse_BOF
  },
  536: {
    /* n:"Lbl", */
    f: parse_Lbl
  },
  547: {
    /* n:"ExternName", */
    f: parse_ExternName
  },
  561: {
    /* n:"Font", */
  },
  579: {
    /* n:"BIFF3XF", */
    f: parse_BIFF3XF
  },
  1030: {
    /* n:"Formula", */
    f: parse_Formula
  },
  1033: {
    /* n:"BOF", */
    f: parse_BOF
  },
  1091: {
    /* n:"BIFF4XF", */
    f: parse_BIFF4XF
  },
  2157: {
    /* n:"FeatInfo", */
  },
  2163: {
    /* n:"FeatInfo11", */
  },
  2177: {
    /* n:"SXAddl12", */
  },
  2240: {
    /* n:"AutoWebPub", */
  },
  2241: {
    /* n:"ListObj", */
  },
  2242: {
    /* n:"ListField", */
  },
  2243: {
    /* n:"ListDV", */
  },
  2244: {
    /* n:"ListCondFmt", */
  },
  2245: {
    /* n:"ListCF", */
  },
  2246: {
    /* n:"FMQry", */
  },
  2247: {
    /* n:"FMSQry", */
  },
  2248: {
    /* n:"PLV", */
  },
  2249: {
    /* n:"LnExt", */
  },
  2250: {
    /* n:"MkrExt", */
  },
  2251: {
    /* n:"CrtCoopt", */
  },
  2262: {
    /* n:"FRTArchId$", */
    r: 12
  },
  /* --- multiplan 4 records --- */
  101: {
    /* n:"", */
  },
  // one per window
  102: {
    /* n:"", */
  },
  // calc settings
  105: {
    /* n:"", */
  },
  // print header
  106: {
    /* n:"", */
  },
  // print footer
  107: {
    /* n:"", */
  },
  // print settings
  109: {
    /* n:"", */
  },
  // one per window
  112: {
    /* n:"", */
  },
  // includes default col width
  114: {
    /* n:"", */
  },
  // includes selected cell
  29282: {}
};
function write_biff_rec(ba, type, payload, length) {
  var t = type;
  if (isNaN(t)) return;
  var len = (payload || []).length || 0;
  var o = ba.next(4);
  o.write_shift(2, t);
  o.write_shift(2, len);
  if (
    /*:: len != null &&*/
    len > 0 && is_buf(payload)
  ) ba.push(payload);
}
function html_to_sheet(str, _opts) {
  var opts = _opts;
  var dense = opts.dense != null ? opts.dense : DENSE;
  var ws = {};
  if (dense) ws["!data"] = [];
  str = str_remove_ng(str, "<!--", "-->");
  var mtch = str.match(/<table/i);
  if (!mtch) throw new Error("Invalid HTML: could not find <table>");
  var mtch2 = str.match(/<\/table/i);
  var i = mtch.index, j = mtch2 && mtch2.index || str.length;
  var rows = split_regex(str.slice(i, j), /(:?<tr[^<>]*>)/i, "<tr>");
  var R = -1, C2 = 0, RS = 0, CS = 0;
  var range = { s: { r: 1e7, c: 1e7 }, e: { r: 0, c: 0 } };
  var merges = [];
  for (i = 0; i < rows.length; ++i) {
    var row = rows[i].trim();
    var hd = row.slice(0, 3).toLowerCase();
    if (hd == "<tr") {
      ++R;
      if (opts.sheetRows && opts.sheetRows <= R) {
        --R;
        break;
      }
      C2 = 0;
      continue;
    }
    if (hd != "<td" && hd != "<th") continue;
    var cells = row.split(/<\/t[dh]>/i);
    for (j = 0; j < cells.length; ++j) {
      var cell = cells[j].trim();
      if (!cell.match(/<t[dh]/i)) continue;
      var m = cell, cc = 0;
      while (m.charAt(0) == "<" && (cc = m.indexOf(">")) > -1) m = m.slice(cc + 1);
      for (var midx = 0; midx < merges.length; ++midx) {
        var _merge = merges[midx];
        if (_merge.s.c == C2 && _merge.s.r < R && R <= _merge.e.r) {
          C2 = _merge.e.c + 1;
          midx = -1;
        }
      }
      var tag = parsexmltag(cell.slice(0, cell.indexOf(">")));
      CS = tag.colspan ? +tag.colspan : 1;
      if ((RS = +tag.rowspan) > 1 || CS > 1) merges.push({ s: { r: R, c: C2 }, e: { r: R + (RS || 1) - 1, c: C2 + CS - 1 } });
      var _t = tag.t || tag["data-t"] || "";
      if (!m.length) {
        C2 += CS;
        continue;
      }
      m = htmldecode(m);
      if (range.s.r > R) range.s.r = R;
      if (range.e.r < R) range.e.r = R;
      if (range.s.c > C2) range.s.c = C2;
      if (range.e.c < C2) range.e.c = C2;
      if (!m.length) {
        C2 += CS;
        continue;
      }
      var o = { t: "s", v: m };
      if (opts.raw || !m.trim().length || _t == "s") ;
      else if (m === "TRUE") o = { t: "b", v: true };
      else if (m === "FALSE") o = { t: "b", v: false };
      else if (!isNaN(fuzzynum(m))) o = { t: "n", v: fuzzynum(m) };
      else if (!isNaN(fuzzydate(m).getDate())) {
        o = { t: "d", v: parseDate(m) };
        if (opts.UTC === false) o.v = utc_to_local(o.v);
        if (!opts.cellDates) o = { t: "n", v: datenum(o.v) };
        o.z = opts.dateNF || table_fmt[14];
      }
      if (o.cellText !== false) o.w = m;
      if (dense) {
        if (!ws["!data"][R]) ws["!data"][R] = [];
        ws["!data"][R][C2] = o;
      } else ws[encode_cell({ r: R, c: C2 })] = o;
      C2 += CS;
    }
  }
  ws["!ref"] = encode_range(range);
  if (merges.length) ws["!merges"] = merges;
  return ws;
}
function make_html_row(ws, r, R, o) {
  var M = ws["!merges"] || [];
  var oo = [];
  var sp = {};
  var dense = ws["!data"] != null;
  for (var C2 = r.s.c; C2 <= r.e.c; ++C2) {
    var RS = 0, CS = 0;
    for (var j = 0; j < M.length; ++j) {
      if (M[j].s.r > R || M[j].s.c > C2) continue;
      if (M[j].e.r < R || M[j].e.c < C2) continue;
      if (M[j].s.r < R || M[j].s.c < C2) {
        RS = -1;
        break;
      }
      RS = M[j].e.r - M[j].s.r + 1;
      CS = M[j].e.c - M[j].s.c + 1;
      break;
    }
    if (RS < 0) continue;
    var coord = encode_col(C2) + encode_row(R);
    var cell = dense ? (ws["!data"][R] || [])[C2] : ws[coord];
    var w = cell && cell.v != null && (cell.h || escapehtml(cell.w || (format_cell(cell), cell.w) || "")) || "";
    sp = {};
    if (RS > 1) sp.rowspan = RS;
    if (CS > 1) sp.colspan = CS;
    if (o.editable) w = '<span contenteditable="true">' + w + "</span>";
    else if (cell) {
      sp["data-t"] = cell && cell.t || "z";
      if (cell.v != null) sp["data-v"] = escapehtml(cell.v instanceof Date ? cell.v.toISOString() : cell.v);
      if (cell.z != null) sp["data-z"] = cell.z;
      if (cell.l && (cell.l.Target || "#").charAt(0) != "#") w = '<a href="' + escapehtml(cell.l.Target) + '">' + w + "</a>";
    }
    sp.id = (o.id || "sjs") + "-" + coord;
    oo.push(writextag("td", w, sp));
  }
  var preamble = "<tr>";
  return preamble + oo.join("") + "</tr>";
}
var HTML_BEGIN = '<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>';
var HTML_END = "</body></html>";
function html_to_workbook(str, opts) {
  var mtch = str_match_xml_ig(str, "table");
  if (!mtch || mtch.length == 0) throw new Error("Invalid HTML: could not find <table>");
  if (mtch.length == 1) {
    var w = sheet_to_workbook(html_to_sheet(mtch[0], opts), opts);
    w.bookType = "html";
    return w;
  }
  var wb = book_new();
  mtch.forEach(function(s, idx) {
    book_append_sheet(wb, html_to_sheet(s, opts), "Sheet" + (idx + 1));
  });
  wb.bookType = "html";
  return wb;
}
function make_html_preamble(ws, R, o) {
  var out = [];
  return out.join("") + "<table" + (o.id ? ' id="' + o.id + '"' : "") + ">";
}
function sheet_to_html(ws, opts) {
  var o = opts || {};
  var header = o.header != null ? o.header : HTML_BEGIN;
  var footer = o.footer != null ? o.footer : HTML_END;
  var out = [header];
  var r = decode_range(ws["!ref"] || "A1");
  out.push(make_html_preamble(ws, r, o));
  if (ws["!ref"]) for (var R = r.s.r; R <= r.e.r; ++R) out.push(make_html_row(ws, r, R, o));
  out.push("</table>" + footer);
  return out.join("");
}
function sheet_add_dom(ws, table, _opts) {
  var rows = table.rows;
  if (!rows) {
    throw "Unsupported origin when " + table.tagName + " is not a TABLE";
  }
  var opts = _opts || {};
  var dense = ws["!data"] != null;
  var or_R = 0, or_C = 0;
  if (opts.origin != null) {
    if (typeof opts.origin == "number") or_R = opts.origin;
    else {
      var _origin = typeof opts.origin == "string" ? decode_cell(opts.origin) : opts.origin;
      or_R = _origin.r;
      or_C = _origin.c;
    }
  }
  var sheetRows = Math.min(opts.sheetRows || 1e7, rows.length);
  var range = { s: { r: 0, c: 0 }, e: { r: or_R, c: or_C } };
  if (ws["!ref"]) {
    var _range = decode_range(ws["!ref"]);
    range.s.r = Math.min(range.s.r, _range.s.r);
    range.s.c = Math.min(range.s.c, _range.s.c);
    range.e.r = Math.max(range.e.r, _range.e.r);
    range.e.c = Math.max(range.e.c, _range.e.c);
    if (or_R == -1) range.e.r = or_R = _range.e.r + 1;
  }
  var merges = [], midx = 0;
  var rowinfo = ws["!rows"] || (ws["!rows"] = []);
  var _R = 0, R = 0, _C = 0, C2 = 0, RS = 0, CS = 0;
  if (!ws["!cols"]) ws["!cols"] = [];
  for (; _R < rows.length && R < sheetRows; ++_R) {
    var row = rows[_R];
    if (is_dom_element_hidden(row)) {
      if (opts.display) continue;
      rowinfo[R] = { hidden: true };
    }
    var elts = row.cells;
    for (_C = C2 = 0; _C < elts.length; ++_C) {
      var elt = elts[_C];
      if (opts.display && is_dom_element_hidden(elt)) continue;
      var v2 = elt.hasAttribute("data-v") ? elt.getAttribute("data-v") : elt.hasAttribute("v") ? elt.getAttribute("v") : htmldecode(elt.innerHTML);
      var z = elt.getAttribute("data-z") || elt.getAttribute("z");
      for (midx = 0; midx < merges.length; ++midx) {
        var m = merges[midx];
        if (m.s.c == C2 + or_C && m.s.r < R + or_R && R + or_R <= m.e.r) {
          C2 = m.e.c + 1 - or_C;
          midx = -1;
        }
      }
      CS = +elt.getAttribute("colspan") || 1;
      if ((RS = +elt.getAttribute("rowspan") || 1) > 1 || CS > 1) merges.push({ s: { r: R + or_R, c: C2 + or_C }, e: { r: R + or_R + (RS || 1) - 1, c: C2 + or_C + (CS || 1) - 1 } });
      var o = { t: "s", v: v2 };
      var _t = elt.getAttribute("data-t") || elt.getAttribute("t") || "";
      if (v2 != null) {
        if (v2.length == 0) o.t = _t || "z";
        else if (opts.raw || v2.trim().length == 0 || _t == "s") ;
        else if (v2 === "TRUE") o = { t: "b", v: true };
        else if (v2 === "FALSE") o = { t: "b", v: false };
        else if (!isNaN(fuzzynum(v2))) o = { t: "n", v: fuzzynum(v2) };
        else if (!isNaN(fuzzydate(v2).getDate())) {
          o = { t: "d", v: parseDate(v2) };
          if (opts.UTC) o.v = local_to_utc(o.v);
          if (!opts.cellDates) o = { t: "n", v: datenum(o.v) };
          o.z = opts.dateNF || table_fmt[14];
        }
      }
      if (o.z === void 0 && z != null) o.z = z;
      var l2 = "", Aelts = elt.getElementsByTagName("A");
      if (Aelts && Aelts.length) {
        for (var Aelti = 0; Aelti < Aelts.length; ++Aelti) if (Aelts[Aelti].hasAttribute("href")) {
          l2 = Aelts[Aelti].getAttribute("href");
          if (l2.charAt(0) != "#") break;
        }
      }
      if (l2 && l2.charAt(0) != "#" && l2.slice(0, 11).toLowerCase() != "javascript:") o.l = { Target: l2 };
      if (dense) {
        if (!ws["!data"][R + or_R]) ws["!data"][R + or_R] = [];
        ws["!data"][R + or_R][C2 + or_C] = o;
      } else ws[encode_cell({ c: C2 + or_C, r: R + or_R })] = o;
      if (range.e.c < C2 + or_C) range.e.c = C2 + or_C;
      C2 += CS;
    }
    ++R;
  }
  if (merges.length) ws["!merges"] = (ws["!merges"] || []).concat(merges);
  range.e.r = Math.max(range.e.r, R - 1 + or_R);
  ws["!ref"] = encode_range(range);
  if (R >= sheetRows) ws["!fullref"] = encode_range((range.e.r = rows.length - _R + R - 1 + or_R, range));
  return ws;
}
function parse_dom_table(table, _opts) {
  var opts = _opts || {};
  var ws = {};
  if (opts.dense) ws["!data"] = [];
  return sheet_add_dom(ws, table, _opts);
}
function table_to_book(table, opts) {
  var o = sheet_to_workbook(parse_dom_table(table, opts), opts);
  return o;
}
function is_dom_element_hidden(element) {
  var display = "";
  var get_computed_style = get_get_computed_style_function(element);
  if (get_computed_style) display = get_computed_style(element).getPropertyValue("display");
  if (!display) display = element.style && element.style.display;
  return display === "none";
}
function get_get_computed_style_function(element) {
  if (element.ownerDocument.defaultView && typeof element.ownerDocument.defaultView.getComputedStyle === "function") return element.ownerDocument.defaultView.getComputedStyle;
  if (typeof getComputedStyle === "function") return getComputedStyle;
  return null;
}
function parse_text_p(text) {
  var fixed = text.replace(/[\t\r\n]/g, " ").trim().replace(/ +/g, " ").replace(/<text:s\/>/g, " ").replace(/<text:s text:c="(\d+)"\/>/g, function($$, $1) {
    return Array(parseInt($1, 10) + 1).join(" ");
  }).replace(/<text:tab[^<>]*\/>/g, "	").replace(/<text:line-break\/>/g, "\n");
  var v2 = unescapexml(fixed.replace(/<[^<>]*>/g, ""));
  return [v2];
}
function parse_ods_styles(d, _opts, _nfm) {
  var number_format_map = _nfm || {};
  var str = xlml_normalize(d);
  xlmlregex.lastIndex = 0;
  str = remove_doctype(str_remove_ng(str, "<!--", "-->"));
  var Rn, NFtag, NF = "", tNF = "", y, etpos = 0, tidx = -1, payload = "";
  while (Rn = xlmlregex.exec(str)) {
    switch (Rn[3] = Rn[3].replace(/_[\s\S]*$/, "")) {
      case "number-style":
      case "currency-style":
      case "percentage-style":
      case "date-style":
      case "time-style":
      case "text-style":
        if (Rn[1] === "/") {
          if (NFtag["truncate-on-overflow"] == "false") {
            if (NF.match(/h/)) NF = NF.replace(/h+/, "[$&]");
            else if (NF.match(/m/)) NF = NF.replace(/m+/, "[$&]");
            else if (NF.match(/s/)) NF = NF.replace(/s+/, "[$&]");
          }
          number_format_map[NFtag.name] = NF;
          NF = "";
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          NF = "";
          NFtag = parsexmltag(Rn[0], false);
        }
        break;
      case "boolean-style":
        if (Rn[1] === "/") {
          number_format_map[NFtag.name] = "General";
          NF = "";
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          NF = "";
          NFtag = parsexmltag(Rn[0], false);
        }
        break;
      case "boolean":
        NF += "General";
        break;
      case "text":
        if (Rn[1] === "/") {
          payload = str.slice(tidx, xlmlregex.lastIndex - Rn[0].length);
          if (payload == "%" && NFtag[0] == "<number:percentage-style") NF += "%";
          else NF += '"' + payload.replace(/"/g, '""') + '"';
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          tidx = xlmlregex.lastIndex;
        }
        break;
      case "day":
        {
          y = parsexmltag(Rn[0], false);
          switch (y["style"]) {
            case "short":
              NF += "d";
              break;
            case "long":
              NF += "dd";
              break;
            default:
              NF += "dd";
              break;
          }
        }
        break;
      case "day-of-week":
        {
          y = parsexmltag(Rn[0], false);
          switch (y["style"]) {
            case "short":
              NF += "ddd";
              break;
            case "long":
              NF += "dddd";
              break;
            default:
              NF += "ddd";
              break;
          }
        }
        break;
      case "era":
        {
          y = parsexmltag(Rn[0], false);
          switch (y["style"]) {
            case "short":
              NF += "ee";
              break;
            case "long":
              NF += "eeee";
              break;
            default:
              NF += "eeee";
              break;
          }
        }
        break;
      case "hours":
        {
          y = parsexmltag(Rn[0], false);
          switch (y["style"]) {
            case "short":
              NF += "h";
              break;
            case "long":
              NF += "hh";
              break;
            default:
              NF += "hh";
              break;
          }
        }
        break;
      case "minutes":
        {
          y = parsexmltag(Rn[0], false);
          switch (y["style"]) {
            case "short":
              NF += "m";
              break;
            case "long":
              NF += "mm";
              break;
            default:
              NF += "mm";
              break;
          }
        }
        break;
      case "month":
        {
          y = parsexmltag(Rn[0], false);
          if (y["textual"]) NF += "mm";
          switch (y["style"]) {
            case "short":
              NF += "m";
              break;
            case "long":
              NF += "mm";
              break;
            default:
              NF += "m";
              break;
          }
        }
        break;
      case "seconds":
        {
          y = parsexmltag(Rn[0], false);
          switch (y["style"]) {
            case "short":
              NF += "s";
              break;
            case "long":
              NF += "ss";
              break;
            default:
              NF += "ss";
              break;
          }
          if (y["decimal-places"]) NF += "." + fill("0", +y["decimal-places"]);
        }
        break;
      case "year":
        {
          y = parsexmltag(Rn[0], false);
          switch (y["style"]) {
            case "short":
              NF += "yy";
              break;
            case "long":
              NF += "yyyy";
              break;
            default:
              NF += "yy";
              break;
          }
        }
        break;
      case "am-pm":
        NF += "AM/PM";
        break;
      case "week-of-year":
      case "quarter":
        console.error("Excel does not support ODS format token " + Rn[3]);
        break;
      case "fill-character":
        if (Rn[1] === "/") {
          payload = str.slice(tidx, xlmlregex.lastIndex - Rn[0].length);
          NF += '"' + payload.replace(/"/g, '""') + '"*';
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          tidx = xlmlregex.lastIndex;
        }
        break;
      case "scientific-number":
        y = parsexmltag(Rn[0], false);
        NF += "0." + fill("0", +y["min-decimal-places"] || +y["decimal-places"] || 2) + fill("?", +y["decimal-places"] - +y["min-decimal-places"] || 0) + "E" + (parsexmlbool(y["forced-exponent-sign"]) ? "+" : "") + fill("0", +y["min-exponent-digits"] || 2);
        break;
      case "fraction":
        y = parsexmltag(Rn[0], false);
        if (!+y["min-integer-digits"]) NF += "#";
        else NF += fill("0", +y["min-integer-digits"]);
        NF += " ";
        NF += fill("?", +y["min-numerator-digits"] || 1);
        NF += "/";
        if (+y["denominator-value"]) NF += y["denominator-value"];
        else NF += fill("?", +y["min-denominator-digits"] || 1);
        break;
      case "currency-symbol":
        if (Rn[1] === "/") {
          NF += '"' + str.slice(tidx, xlmlregex.lastIndex - Rn[0].length).replace(/"/g, '""') + '"';
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          tidx = xlmlregex.lastIndex;
        } else NF += "$";
        break;
      case "text-properties":
        y = parsexmltag(Rn[0], false);
        switch ((y["color"] || "").toLowerCase().replace("#", "")) {
          case "ff0000":
          case "red":
            NF = "[Red]" + NF;
            break;
        }
        break;
      case "text-content":
        NF += "@";
        break;
      case "map":
        y = parsexmltag(Rn[0], false);
        if (unescapexml(y["condition"]) == "value()>=0") NF = number_format_map[y["apply-style-name"]] + ";" + NF;
        else console.error("ODS number format may be incorrect: " + y["condition"]);
        break;
      case "number":
        if (Rn[1] === "/") break;
        y = parsexmltag(Rn[0], false);
        tNF = "";
        tNF += fill("0", +y["min-integer-digits"] || 1);
        if (parsexmlbool(y["grouping"])) tNF = commaify(fill("#", Math.max(0, 4 - tNF.length)) + tNF);
        if (+y["min-decimal-places"] || +y["decimal-places"]) tNF += ".";
        if (+y["min-decimal-places"]) tNF += fill("0", +y["min-decimal-places"] || 1);
        if (+y["decimal-places"] - (+y["min-decimal-places"] || 0)) tNF += fill("0", +y["decimal-places"] - (+y["min-decimal-places"] || 0));
        NF += tNF;
        break;
      case "embedded-text":
        if (Rn[1] === "/") {
          if (etpos == 0) NF += '"' + str.slice(tidx, xlmlregex.lastIndex - Rn[0].length).replace(/"/g, '""') + '"';
          else NF = NF.slice(0, etpos) + '"' + str.slice(tidx, xlmlregex.lastIndex - Rn[0].length).replace(/"/g, '""') + '"' + NF.slice(etpos);
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          tidx = xlmlregex.lastIndex;
          etpos = -+parsexmltag(Rn[0], false)["position"] || 0;
        }
        break;
    }
  }
  return number_format_map;
}
function parse_content_xml(d, _opts, _nfm) {
  var opts = _opts || {};
  var str = xlml_normalize(d);
  var state = [], tmp;
  var tag;
  var nfidx, NF = "", pidx = 0;
  var sheetag;
  var rowtag;
  var Sheets = {}, SheetNames = [];
  var ws = {};
  if (opts.dense) ws["!data"] = [];
  var Rn, q;
  var ctag = { value: "" };
  var textp = "", textpidx = 0, oldtextp = "", oldtextpidx = 0;
  var textR = [], oldtextR = [];
  var R = -1, C2 = -1, range = { s: { r: 1e6, c: 1e7 }, e: { r: 0, c: 0 } };
  var row_ol = 0;
  var number_format_map = _nfm || {}, styles = {};
  var merges = [], mrange = {}, mR = 0, mC = 0;
  var rowinfo = [], rowpeat = 1, colpeat = 1;
  var arrayf = [];
  var WB = { Names: [], WBProps: {} };
  var atag = {};
  var _Ref = ["", ""];
  var comments = [], comment = {};
  var creator = "", creatoridx = 0;
  var isstub = false, intable = false;
  var i = 0;
  xlmlregex.lastIndex = 0;
  str = remove_doctype(str_remove_ng(str, "<!--", "-->"));
  while (Rn = xlmlregex.exec(str)) switch (Rn[3] = Rn[3].replace(/_[\s\S]*$/, "")) {
    case "table":
    case "":
      if (Rn[1] === "/") {
        if (range.e.c >= range.s.c && range.e.r >= range.s.r) ws["!ref"] = encode_range(range);
        else ws["!ref"] = "A1:A1";
        if (opts.sheetRows > 0 && opts.sheetRows <= range.e.r) {
          ws["!fullref"] = ws["!ref"];
          range.e.r = opts.sheetRows - 1;
          ws["!ref"] = encode_range(range);
        }
        if (merges.length) ws["!merges"] = merges;
        if (rowinfo.length) ws["!rows"] = rowinfo;
        sheetag.name = sheetag[""] || sheetag.name;
        if (typeof JSON !== "undefined") JSON.stringify(sheetag);
        SheetNames.push(sheetag.name);
        Sheets[sheetag.name] = ws;
        intable = false;
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
        sheetag = parsexmltag(Rn[0], false);
        R = C2 = -1;
        range.s.r = range.s.c = 1e7;
        range.e.r = range.e.c = 0;
        ws = {};
        if (opts.dense) ws["!data"] = [];
        merges = [];
        rowinfo = [];
        intable = true;
      }
      break;
    case "table-row-group":
      if (Rn[1] === "/") --row_ol;
      else ++row_ol;
      break;
    case "table-row":
    case "":
      if (Rn[1] === "/") {
        R += rowpeat;
        rowpeat = 1;
        break;
      }
      rowtag = parsexmltag(Rn[0], false);
      if (rowtag[""]) R = rowtag[""] - 1;
      else if (R == -1) R = 0;
      rowpeat = +rowtag["number-rows-repeated"] || 1;
      if (rowpeat < 10) {
        for (i = 0; i < rowpeat; ++i) if (row_ol > 0) rowinfo[R + i] = { level: row_ol };
      }
      C2 = -1;
      break;
    case "covered-table-cell":
      if (Rn[1] !== "/") ++C2;
      if (opts.sheetStubs) {
        if (opts.dense) {
          if (!ws["!data"][R]) ws["!data"][R] = [];
          ws["!data"][R][C2] = { t: "z" };
        } else ws[encode_cell({ r: R, c: C2 })] = { t: "z" };
      }
      textp = "";
      textR = [];
      break;
    case "table-cell":
    case "":
      if (Rn[0].charAt(Rn[0].length - 2) === "/") {
        ++C2;
        ctag = parsexmltag(Rn[0], false);
        colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
        q = {
          t: "z",
          v: null
          /*:: , z:null, w:"",c:[]*/
        };
        if (ctag.formula && opts.cellFormula != false) q.f = ods_to_csf_formula(unescapexml(ctag.formula));
        if (ctag["style-name"] && styles[ctag["style-name"]]) q.z = styles[ctag["style-name"]];
        if ((ctag[""] || ctag["value-type"]) == "string") {
          q.t = "s";
          q.v = unescapexml(ctag["string-value"] || "");
          if (opts.dense) {
            if (!ws["!data"][R]) ws["!data"][R] = [];
            ws["!data"][R][C2] = q;
          } else {
            ws[encode_col(C2) + encode_row(R)] = q;
          }
        }
        C2 += colpeat - 1;
      } else if (Rn[1] !== "/") {
        ++C2;
        textp = oldtextp = "";
        textpidx = oldtextpidx = 0;
        textR = [];
        oldtextR = [];
        colpeat = 1;
        var rptR = rowpeat ? R + rowpeat - 1 : R;
        if (C2 > range.e.c) range.e.c = C2;
        if (C2 < range.s.c) range.s.c = C2;
        if (R < range.s.r) range.s.r = R;
        if (rptR > range.e.r) range.e.r = rptR;
        ctag = parsexmltag(Rn[0], false);
        comments = [];
        comment = {};
        q = {
          t: ctag[""] || ctag["value-type"],
          v: null
          /*:: , z:null, w:"",c:[]*/
        };
        if (ctag["style-name"] && styles[ctag["style-name"]]) q.z = styles[ctag["style-name"]];
        if (opts.cellFormula) {
          if (ctag.formula) ctag.formula = unescapexml(ctag.formula);
          if (ctag["number-matrix-columns-spanned"] && ctag["number-matrix-rows-spanned"]) {
            mR = parseInt(ctag["number-matrix-rows-spanned"], 10) || 0;
            mC = parseInt(ctag["number-matrix-columns-spanned"], 10) || 0;
            mrange = { s: { r: R, c: C2 }, e: { r: R + mR - 1, c: C2 + mC - 1 } };
            q.F = encode_range(mrange);
            arrayf.push([mrange, q.F]);
          }
          if (ctag.formula) q.f = ods_to_csf_formula(ctag.formula);
          else for (i = 0; i < arrayf.length; ++i)
            if (R >= arrayf[i][0].s.r && R <= arrayf[i][0].e.r) {
              if (C2 >= arrayf[i][0].s.c && C2 <= arrayf[i][0].e.c)
                q.F = arrayf[i][1];
            }
        }
        if (ctag["number-columns-spanned"] || ctag["number-rows-spanned"]) {
          mR = parseInt(ctag["number-rows-spanned"], 10) || 0;
          mC = parseInt(ctag["number-columns-spanned"], 10) || 0;
          mrange = { s: { r: R, c: C2 }, e: { r: R + mR - 1, c: C2 + mC - 1 } };
          merges.push(mrange);
        }
        if (ctag["number-columns-repeated"]) colpeat = parseInt(ctag["number-columns-repeated"], 10);
        switch (q.t) {
          case "boolean":
            q.t = "b";
            q.v = parsexmlbool(ctag["boolean-value"]) || +ctag["boolean-value"] >= 1;
            break;
          case "float":
            q.t = "n";
            q.v = parseFloat(ctag.value);
            if (opts.cellDates && q.z && fmt_is_date(q.z)) {
              q.v = numdate(q.v + (WB.WBProps.date1904 ? 1462 : 0));
              q.t = typeof q.v == "number" ? "n" : "d";
            }
            break;
          case "percentage":
            q.t = "n";
            q.v = parseFloat(ctag.value);
            break;
          case "currency":
            q.t = "n";
            q.v = parseFloat(ctag.value);
            break;
          case "date":
            q.t = "d";
            q.v = parseDate(ctag["date-value"], WB.WBProps.date1904);
            if (!opts.cellDates) {
              q.t = "n";
              q.v = datenum(q.v, WB.WBProps.date1904);
            }
            if (!q.z) q.z = "m/d/yy";
            break;
          case "time":
            q.t = "n";
            q.v = parse_isodur(ctag["time-value"]) / 86400;
            if (opts.cellDates) {
              q.v = numdate(q.v);
              q.t = typeof q.v == "number" ? "n" : "d";
            }
            if (!q.z) q.z = "HH:MM:SS";
            break;
          case "number":
            q.t = "n";
            q.v = parseFloat(ctag[""]);
            break;
          default:
            if (q.t === "string" || q.t === "text" || !q.t) {
              q.t = "s";
              if (ctag["string-value"] != null) {
                textp = unescapexml(ctag["string-value"]);
                textR = [];
              }
            } else throw new Error("Unsupported value type " + q.t);
        }
      } else {
        isstub = false;
        if (q.t === "s") {
          q.v = textp || "";
          if (textR.length) q.R = textR;
          isstub = textpidx == 0;
        }
        if (atag.Target) q.l = atag;
        if (comments.length > 0) {
          q.c = comments;
          comments = [];
        }
        if (textp && opts.cellText !== false) q.w = textp;
        if (isstub) {
          q.t = "z";
          delete q.v;
        }
        if (!isstub || opts.sheetStubs) {
          if (!(opts.sheetRows && opts.sheetRows <= R)) {
            for (var rpt = 0; rpt < rowpeat; ++rpt) {
              colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
              if (opts.dense) {
                if (!ws["!data"][R + rpt]) ws["!data"][R + rpt] = [];
                ws["!data"][R + rpt][C2] = rpt == 0 ? q : dup(q);
                while (--colpeat > 0) ws["!data"][R + rpt][C2 + colpeat] = dup(q);
              } else {
                ws[encode_cell({ r: R + rpt, c: C2 })] = q;
                while (--colpeat > 0) ws[encode_cell({ r: R + rpt, c: C2 + colpeat })] = dup(q);
              }
              if (range.e.c <= C2) range.e.c = C2;
            }
          }
        }
        colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
        C2 += colpeat - 1;
        colpeat = 0;
        q = {
          /*:: t:"", v:null, z:null, w:"",c:[]*/
        };
        textp = "";
        textR = [];
      }
      atag = {};
      break;
    case "document":
    case "document-content":
    case "":
    case "spreadsheet":
    case "":
    case "scripts":
    case "styles":
    case "font-face-decls":
    case "master-styles":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw "Bad state: " + tmp;
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([Rn[3], true]);
      break;
    case "annotation":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw "Bad state: " + tmp;
        comment.t = textp;
        if (textR.length) comment.R = textR;
        comment.a = creator;
        comments.push(comment);
        textp = oldtextp;
        textpidx = oldtextpidx;
        textR = oldtextR;
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
        state.push([Rn[3], false]);
        var annotag = parsexmltag(Rn[0], true);
        if (!(annotag["display"] && parsexmlbool(annotag["display"]))) comments.hidden = true;
        oldtextp = textp;
        oldtextpidx = textpidx;
        oldtextR = textR;
        textp = "";
        textpidx = 0;
        textR = [];
      }
      creator = "";
      creatoridx = 0;
      break;
    case "creator":
      if (Rn[1] === "/") {
        creator = str.slice(creatoridx, Rn.index);
      } else creatoridx = Rn.index + Rn[0].length;
      break;
    case "meta":
    case "":
    case "settings":
    case "config-item-set":
    case "config-item-map-indexed":
    case "config-item-map-entry":
    case "config-item-map-named":
    case "shapes":
    case "frame":
    case "text-box":
    case "image":
    case "data-pilot-tables":
    case "list-style":
    case "form":
    case "dde-links":
    case "event-listeners":
    case "chart":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw "Bad state: " + tmp;
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([Rn[3], false]);
      textp = "";
      textpidx = 0;
      textR = [];
      break;
    case "scientific-number":
    case "currency-symbol":
    case "fill-character":
      break;
    case "text-style":
    case "boolean-style":
    case "number-style":
    case "currency-style":
    case "percentage-style":
    case "date-style":
    case "time-style":
      if (Rn[1] === "/") {
        var xlmlidx = xlmlregex.lastIndex;
        parse_ods_styles(str.slice(nfidx, xlmlregex.lastIndex), _opts, number_format_map);
        xlmlregex.lastIndex = xlmlidx;
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
        nfidx = xlmlregex.lastIndex - Rn[0].length;
      }
      break;
    case "script":
      break;
    case "libraries":
      break;
    case "automatic-styles":
      break;
    case "default-style":
    case "page-layout":
      break;
    case "style":
      {
        var styletag = parsexmltag(Rn[0], false);
        if (styletag["family"] == "table-cell" && number_format_map[styletag["data-style-name"]]) styles[styletag["name"]] = number_format_map[styletag["data-style-name"]];
      }
      break;
    case "map":
      break;
    case "font-face":
      break;
    case "paragraph-properties":
      break;
    case "table-properties":
      break;
    case "table-column-properties":
      break;
    case "table-row-properties":
      break;
    case "table-cell-properties":
      break;
    case "number":
      break;
    case "fraction":
      break;
    case "day":
    case "month":
    case "year":
    case "era":
    case "day-of-week":
    case "week-of-year":
    case "quarter":
    case "hours":
    case "minutes":
    case "seconds":
    case "am-pm":
      break;
    case "boolean":
      break;
    case "text":
      if (Rn[0].slice(-2) === "/>") break;
      else if (Rn[1] === "/") switch (state[state.length - 1][0]) {
        case "number-style":
        case "date-style":
        case "time-style":
          NF += str.slice(pidx, Rn.index);
          break;
      }
      else pidx = Rn.index + Rn[0].length;
      break;
    case "named-range":
      tag = parsexmltag(Rn[0], false);
      _Ref = ods_to_csf_3D(tag["cell-range-address"]);
      var nrange = { Name: tag.name, Ref: _Ref[0] + "!" + _Ref[1] };
      if (intable) nrange.Sheet = SheetNames.length;
      WB.Names.push(nrange);
      break;
    case "text-content":
      break;
    case "text-properties":
      break;
    case "embedded-text":
      break;
    case "body":
    case "":
      break;
    case "forms":
      break;
    case "table-column":
      break;
    case "table-header-rows":
      break;
    case "table-rows":
      break;
    case "table-column-group":
      break;
    case "table-header-columns":
      break;
    case "table-columns":
      break;
    case "null-date":
      tag = parsexmltag(Rn[0], false);
      switch (tag["date-value"]) {
        case "1904-01-01":
          WB.WBProps.date1904 = true;
          break;
      }
      break;
    case "graphic-properties":
      break;
    case "calculation-settings":
      break;
    case "named-expressions":
      break;
    case "label-range":
      break;
    case "label-ranges":
      break;
    case "named-expression":
      break;
    case "sort":
      break;
    case "sort-by":
      break;
    case "sort-groups":
      break;
    case "tab":
      break;
    case "line-break":
      break;
    case "span":
      break;
    case "p":
    case "":
      if (["master-styles"].indexOf(state[state.length - 1][0]) > -1) break;
      if (Rn[1] === "/" && (!ctag || !ctag["string-value"])) {
        var ptp = parse_text_p(str.slice(textpidx, Rn.index));
        textp = (textp.length > 0 ? textp + "\n" : "") + ptp[0];
      } else if (Rn[0].slice(-2) == "/>") {
        textp += "\n";
      } else {
        parsexmltag(Rn[0], false);
        textpidx = Rn.index + Rn[0].length;
      }
      break;
    case "s":
      break;
    case "database-range":
      if (Rn[1] === "/") break;
      try {
        _Ref = ods_to_csf_3D(parsexmltag(Rn[0])["target-range-address"]);
        Sheets[_Ref[0]]["!autofilter"] = { ref: _Ref[1] };
      } catch (e) {
      }
      break;
    case "date":
      break;
    case "object":
      break;
    case "title":
    case "":
      break;
    case "desc":
      break;
    case "binary-data":
      break;
    case "table-source":
      break;
    case "scenario":
      break;
    case "iteration":
      break;
    case "content-validations":
      break;
    case "content-validation":
      break;
    case "help-message":
      break;
    case "error-message":
      break;
    case "database-ranges":
      break;
    case "filter":
      break;
    case "filter-and":
      break;
    case "filter-or":
      break;
    case "filter-condition":
      break;
    case "filter-set-item":
      break;
    case "list-level-style-bullet":
      break;
    case "list-level-style-number":
      break;
    case "list-level-properties":
      break;
    case "sender-firstname":
    case "sender-lastname":
    case "sender-initials":
    case "sender-title":
    case "sender-position":
    case "sender-email":
    case "sender-phone-private":
    case "sender-fax":
    case "sender-company":
    case "sender-phone-work":
    case "sender-street":
    case "sender-city":
    case "sender-postal-code":
    case "sender-country":
    case "sender-state-or-province":
    case "author-name":
    case "author-initials":
    case "chapter":
    case "file-name":
    case "template-name":
    case "sheet-name":
      break;
    case "event-listener":
      break;
    case "initial-creator":
    case "creation-date":
    case "print-date":
    case "generator":
    case "document-statistic":
    case "user-defined":
    case "editing-duration":
    case "editing-cycles":
      break;
    case "config-item":
      break;
    case "page-number":
      break;
    case "page-count":
      break;
    case "time":
      break;
    case "cell-range-source":
      break;
    case "detective":
      break;
    case "operation":
      break;
    case "highlighted-range":
      break;
    case "data-pilot-table":
    case "source-cell-range":
    case "source-service":
    case "data-pilot-field":
    case "data-pilot-level":
    case "data-pilot-subtotals":
    case "data-pilot-subtotal":
    case "data-pilot-members":
    case "data-pilot-member":
    case "data-pilot-display-info":
    case "data-pilot-sort-info":
    case "data-pilot-layout-info":
    case "data-pilot-field-reference":
    case "data-pilot-groups":
    case "data-pilot-group":
    case "data-pilot-group-member":
      break;
    case "rect":
      break;
    case "dde-connection-decls":
    case "dde-connection-decl":
    case "dde-link":
    case "dde-source":
      break;
    case "properties":
      break;
    case "property":
      break;
    case "a":
      if (Rn[1] !== "/") {
        atag = parsexmltag(Rn[0], false);
        if (!atag.href) break;
        atag.Target = unescapexml(atag.href);
        delete atag.href;
        if (atag.Target.charAt(0) == "#" && atag.Target.indexOf(".") > -1) {
          _Ref = ods_to_csf_3D(atag.Target.slice(1));
          atag.Target = "#" + _Ref[0] + "!" + _Ref[1];
        } else if (atag.Target.match(/^\.\.[\\\/]/)) atag.Target = atag.Target.slice(3);
      }
      break;
    case "table-protection":
      break;
    case "data-pilot-grand-total":
      break;
    case "office-document-common-attrs":
      break;
    default:
      switch (Rn[2]) {
        case "dc:":
        case "calcext:":
        case "loext:":
        case "ooo:":
        case "chartooo:":
        case "draw:":
        case "style:":
        case "chart:":
        case "form:":
        case "uof:":
        case ":":
        case ":":
          break;
        default:
          if (opts.WTF) throw new Error(Rn);
      }
  }
  var out = {
    Sheets,
    SheetNames,
    Workbook: WB
  };
  if (opts.bookSheets) delete /*::(*/
  out.Sheets;
  return out;
}
function parse_ods(zip, opts) {
  opts = opts || {};
  if (safegetzipfile(zip, "META-INF/manifest.xml")) parse_manifest(getzipdata(zip, "META-INF/manifest.xml"), opts);
  var styles = getzipstr(zip, "styles.xml");
  var Styles = styles && parse_ods_styles(utf8read(styles));
  var content = getzipstr(zip, "content.xml");
  if (!content) throw new Error("Missing content.xml in ODS / UOF file");
  var wb = parse_content_xml(utf8read(content), opts, Styles);
  if (safegetzipfile(zip, "meta.xml")) wb.Props = parse_core_props(getzipdata(zip, "meta.xml"));
  wb.bookType = "ods";
  return wb;
}
function parse_fods(data, opts) {
  var wb = parse_content_xml(data, opts);
  wb.bookType = "fods";
  return wb;
}
/*! sheetjs (C) 2013-present SheetJS -- http://sheetjs.com */
var subarray = function() {
  try {
    if (typeof Uint8Array == "undefined")
      return "slice";
    if (typeof Uint8Array.prototype.subarray == "undefined")
      return "slice";
    if (typeof Buffer !== "undefined") {
      if (typeof Buffer.prototype.subarray == "undefined")
        return "slice";
      if ((typeof Buffer.from == "function" ? Buffer.from([72, 62]) : new Buffer([72, 62])) instanceof Uint8Array)
        return "subarray";
      return "slice";
    }
    return "subarray";
  } catch (e) {
    return "slice";
  }
}();
function u8_to_dataview(array) {
  return new DataView(array.buffer, array.byteOffset, array.byteLength);
}
function u8str(u8) {
  return typeof TextDecoder != "undefined" ? new TextDecoder().decode(u8) : utf8read(a2s(u8));
}
function u8concat(u8a) {
  var len = 0;
  for (var i = 0; i < u8a.length; ++i)
    len += u8a[i].length;
  var out = new Uint8Array(len);
  var off = 0;
  for (i = 0; i < u8a.length; ++i) {
    var u8 = u8a[i], L = u8.length;
    if (L < 250) {
      for (var j = 0; j < L; ++j)
        out[off++] = u8[j];
    } else {
      out.set(u8, off);
      off += L;
    }
  }
  return out;
}
function popcnt(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  return (x + (x >> 4) & 252645135) * 16843009 >>> 24;
}
function readDecimal128LE(buf, offset) {
  var exp = (buf[offset + 15] & 127) << 7 | buf[offset + 14] >> 1;
  var mantissa = buf[offset + 14] & 1;
  for (var j = offset + 13; j >= offset; --j)
    mantissa = mantissa * 256 + buf[j];
  return (buf[offset + 15] & 128 ? -mantissa : mantissa) * Math.pow(10, exp - 6176);
}
function parse_varint49(buf, ptr) {
  var l2 = ptr.l;
  var usz = buf[l2] & 127;
  varint:
    if (buf[l2++] >= 128) {
      usz |= (buf[l2] & 127) << 7;
      if (buf[l2++] < 128)
        break varint;
      usz |= (buf[l2] & 127) << 14;
      if (buf[l2++] < 128)
        break varint;
      usz |= (buf[l2] & 127) << 21;
      if (buf[l2++] < 128)
        break varint;
      usz += (buf[l2] & 127) * Math.pow(2, 28);
      ++l2;
      if (buf[l2++] < 128)
        break varint;
      usz += (buf[l2] & 127) * Math.pow(2, 35);
      ++l2;
      if (buf[l2++] < 128)
        break varint;
      usz += (buf[l2] & 127) * Math.pow(2, 42);
      ++l2;
      if (buf[l2++] < 128)
        break varint;
    }
  ptr.l = l2;
  return usz;
}
function varint_to_i32(buf) {
  var l2 = 0, i32 = buf[l2] & 127;
  if (buf[l2++] < 128)
    return i32;
  i32 |= (buf[l2] & 127) << 7;
  if (buf[l2++] < 128)
    return i32;
  i32 |= (buf[l2] & 127) << 14;
  if (buf[l2++] < 128)
    return i32;
  i32 |= (buf[l2] & 127) << 21;
  if (buf[l2++] < 128)
    return i32;
  i32 |= (buf[l2] & 15) << 28;
  return i32;
}
function parse_shallow(buf) {
  var out = [], ptr = { l: 0 };
  while (ptr.l < buf.length) {
    var off = ptr.l;
    var num = parse_varint49(buf, ptr);
    var type = num & 7;
    num = num / 8 | 0;
    var data;
    var l2 = ptr.l;
    switch (type) {
      case 0:
        {
          while (buf[l2++] >= 128)
            ;
          data = buf[subarray](ptr.l, l2);
          ptr.l = l2;
        }
        break;
      case 1:
        {
          data = buf[subarray](l2, l2 + 8);
          ptr.l = l2 + 8;
        }
        break;
      case 2:
        {
          var len = parse_varint49(buf, ptr);
          data = buf[subarray](ptr.l, ptr.l + len);
          ptr.l += len;
        }
        break;
      case 5:
        {
          data = buf[subarray](l2, l2 + 4);
          ptr.l = l2 + 4;
        }
        break;
      default:
        throw new Error("PB Type ".concat(type, " for Field ").concat(num, " at offset ").concat(off));
    }
    var v2 = { data, type };
    if (out[num] == null)
      out[num] = [];
    out[num].push(v2);
  }
  return out;
}
function mappa(data, cb) {
  return (data == null ? void 0 : data.map(function(d) {
    return cb(d.data);
  })) || [];
}
function parse_iwa_file(buf) {
  var _a;
  var out = [], ptr = { l: 0 };
  while (ptr.l < buf.length) {
    var len = parse_varint49(buf, ptr);
    var ai = parse_shallow(buf[subarray](ptr.l, ptr.l + len));
    ptr.l += len;
    var res = {
      id: varint_to_i32(ai[1][0].data),
      messages: []
    };
    ai[2].forEach(function(b) {
      var mi = parse_shallow(b.data);
      var fl = varint_to_i32(mi[3][0].data);
      res.messages.push({
        meta: mi,
        data: buf[subarray](ptr.l, ptr.l + fl)
      });
      ptr.l += fl;
    });
    if ((_a = ai[3]) == null ? void 0 : _a[0])
      res.merge = varint_to_i32(ai[3][0].data) >>> 0 > 0;
    out.push(res);
  }
  return out;
}
function parse_snappy_chunk(type, buf) {
  if (type != 0)
    throw new Error("Unexpected Snappy chunk type ".concat(type));
  var ptr = { l: 0 };
  var usz = parse_varint49(buf, ptr);
  var chunks = [];
  var l2 = ptr.l;
  while (l2 < buf.length) {
    var tag = buf[l2] & 3;
    if (tag == 0) {
      var len = buf[l2++] >> 2;
      if (len < 60)
        ++len;
      else {
        var c2 = len - 59;
        len = buf[l2];
        if (c2 > 1)
          len |= buf[l2 + 1] << 8;
        if (c2 > 2)
          len |= buf[l2 + 2] << 16;
        if (c2 > 3)
          len |= buf[l2 + 3] << 24;
        len >>>= 0;
        len++;
        l2 += c2;
      }
      chunks.push(buf[subarray](l2, l2 + len));
      l2 += len;
      continue;
    } else {
      var offset = 0, length = 0;
      if (tag == 1) {
        length = (buf[l2] >> 2 & 7) + 4;
        offset = (buf[l2++] & 224) << 3;
        offset |= buf[l2++];
      } else {
        length = (buf[l2++] >> 2) + 1;
        if (tag == 2) {
          offset = buf[l2] | buf[l2 + 1] << 8;
          l2 += 2;
        } else {
          offset = (buf[l2] | buf[l2 + 1] << 8 | buf[l2 + 2] << 16 | buf[l2 + 3] << 24) >>> 0;
          l2 += 4;
        }
      }
      if (offset == 0)
        throw new Error("Invalid offset 0");
      var j = chunks.length - 1, off = offset;
      while (j >= 0 && off >= chunks[j].length) {
        off -= chunks[j].length;
        --j;
      }
      if (j < 0) {
        if (off == 0)
          off = chunks[j = 0].length;
        else
          throw new Error("Invalid offset beyond length");
      }
      if (length < off)
        chunks.push(chunks[j][subarray](chunks[j].length - off, chunks[j].length - off + length));
      else {
        if (off > 0) {
          chunks.push(chunks[j][subarray](chunks[j].length - off));
          length -= off;
        }
        ++j;
        while (length >= chunks[j].length) {
          chunks.push(chunks[j]);
          length -= chunks[j].length;
          ++j;
        }
        if (length)
          chunks.push(chunks[j][subarray](0, length));
      }
      if (chunks.length > 25)
        chunks = [u8concat(chunks)];
    }
  }
  var clen = 0;
  for (var u8i = 0; u8i < chunks.length; ++u8i)
    clen += chunks[u8i].length;
  if (clen != usz)
    throw new Error("Unexpected length: ".concat(clen, " != ").concat(usz));
  return chunks;
}
function decompress_iwa_file(buf) {
  if (Array.isArray(buf))
    buf = new Uint8Array(buf);
  var out = [];
  var l2 = 0;
  while (l2 < buf.length) {
    var t = buf[l2++];
    var len = buf[l2] | buf[l2 + 1] << 8 | buf[l2 + 2] << 16;
    l2 += 3;
    out.push.apply(out, parse_snappy_chunk(t, buf[subarray](l2, l2 + len)));
    l2 += len;
  }
  if (l2 !== buf.length)
    throw new Error("data is not a valid framed stream!");
  return out.length == 1 ? out[0] : u8concat(out);
}
var numbers_lut_new = function() {
  return { sst: [], rsst: [], ofmt: [], nfmt: [], fmla: [], ferr: [], cmnt: [] };
};
function numbers_format_cell(cell, t, flags, ofmt, nfmt) {
  var _a, _b, _c, _d;
  var ctype = t & 255, ver = t >> 8;
  var fmt = ver >= 5 ? nfmt : ofmt;
  dur:
    if (flags & (ver > 4 ? 8 : 4) && cell.t == "n" && ctype == 7) {
      var dstyle = ((_a = fmt[7]) == null ? void 0 : _a[0]) ? varint_to_i32(fmt[7][0].data) : -1;
      if (dstyle == -1)
        break dur;
      var dmin = ((_b = fmt[15]) == null ? void 0 : _b[0]) ? varint_to_i32(fmt[15][0].data) : -1;
      var dmax = ((_c = fmt[16]) == null ? void 0 : _c[0]) ? varint_to_i32(fmt[16][0].data) : -1;
      var auto = ((_d = fmt[40]) == null ? void 0 : _d[0]) ? varint_to_i32(fmt[40][0].data) : -1;
      var d = cell.v, dd = d;
      autodur:
        if (auto) {
          if (d == 0) {
            dmin = dmax = 2;
            break autodur;
          }
          if (d >= 604800)
            dmin = 1;
          else if (d >= 86400)
            dmin = 2;
          else if (d >= 3600)
            dmin = 4;
          else if (d >= 60)
            dmin = 8;
          else if (d >= 1)
            dmin = 16;
          else
            dmin = 32;
          if (Math.floor(d) != d)
            dmax = 32;
          else if (d % 60)
            dmax = 16;
          else if (d % 3600)
            dmax = 8;
          else if (d % 86400)
            dmax = 4;
          else if (d % 604800)
            dmax = 2;
          if (dmax < dmin)
            dmax = dmin;
        }
      if (dmin == -1 || dmax == -1)
        break dur;
      var dstr = [], zstr = [];
      if (dmin == 1) {
        dd = d / 604800;
        if (dmax == 1) {
          zstr.push('d"d"');
        } else {
          dd |= 0;
          d -= 604800 * dd;
        }
        dstr.push(dd + (dstyle == 2 ? " week" + (dd == 1 ? "" : "s") : dstyle == 1 ? "w" : ""));
      }
      if (dmin <= 2 && dmax >= 2) {
        dd = d / 86400;
        if (dmax > 2) {
          dd |= 0;
          d -= 86400 * dd;
        }
        zstr.push('d"d"');
        dstr.push(dd + (dstyle == 2 ? " day" + (dd == 1 ? "" : "s") : dstyle == 1 ? "d" : ""));
      }
      if (dmin <= 4 && dmax >= 4) {
        dd = d / 3600;
        if (dmax > 4) {
          dd |= 0;
          d -= 3600 * dd;
        }
        zstr.push((dmin >= 4 ? "[h]" : "h") + '"h"');
        dstr.push(dd + (dstyle == 2 ? " hour" + (dd == 1 ? "" : "s") : dstyle == 1 ? "h" : ""));
      }
      if (dmin <= 8 && dmax >= 8) {
        dd = d / 60;
        if (dmax > 8) {
          dd |= 0;
          d -= 60 * dd;
        }
        zstr.push((dmin >= 8 ? "[m]" : "m") + '"m"');
        if (dstyle == 0)
          dstr.push((dmin == 8 && dmax == 8 || dd >= 10 ? "" : "0") + dd);
        else
          dstr.push(dd + (dstyle == 2 ? " minute" + (dd == 1 ? "" : "s") : dstyle == 1 ? "m" : ""));
      }
      if (dmin <= 16 && dmax >= 16) {
        dd = d;
        if (dmax > 16) {
          dd |= 0;
          d -= dd;
        }
        zstr.push((dmin >= 16 ? "[s]" : "s") + '"s"');
        if (dstyle == 0)
          dstr.push((dmax == 16 && dmin == 16 || dd >= 10 ? "" : "0") + dd);
        else
          dstr.push(dd + (dstyle == 2 ? " second" + (dd == 1 ? "" : "s") : dstyle == 1 ? "s" : ""));
      }
      if (dmax >= 32) {
        dd = Math.round(1e3 * d);
        if (dmin < 32)
          zstr.push('.000"ms"');
        if (dstyle == 0)
          dstr.push((dd >= 100 ? "" : dd >= 10 ? "0" : "00") + dd);
        else
          dstr.push(dd + (dstyle == 2 ? " millisecond" + (dd == 1 ? "" : "s") : dstyle == 1 ? "ms" : ""));
      }
      cell.w = dstr.join(dstyle == 0 ? ":" : " ");
      cell.z = zstr.join(dstyle == 0 ? '":"' : " ");
      if (dstyle == 0)
        cell.w = cell.w.replace(/:(\d\d\d)$/, ".$1");
    }
}
function parse_old_storage(buf, lut, v2, opts) {
  var dv = u8_to_dataview(buf);
  var flags = dv.getUint32(4, true);
  var ridx = -1, sidx = -1, zidx = -1, ieee = NaN, dc = 0, dt = new Date(Date.UTC(2001, 0, 1));
  var doff = v2 > 1 ? 12 : 8;
  if (flags & 2) {
    zidx = dv.getUint32(doff, true);
    doff += 4;
  }
  doff += popcnt(flags & (v2 > 1 ? 3468 : 396)) * 4;
  if (flags & 512) {
    ridx = dv.getUint32(doff, true);
    doff += 4;
  }
  doff += popcnt(flags & (v2 > 1 ? 12288 : 4096)) * 4;
  if (flags & 16) {
    sidx = dv.getUint32(doff, true);
    doff += 4;
  }
  if (flags & 32) {
    ieee = dv.getFloat64(doff, true);
    doff += 8;
  }
  if (flags & 64) {
    dt.setTime(dt.getTime() + (dc = dv.getFloat64(doff, true)) * 1e3);
    doff += 8;
  }
  if (v2 > 1) {
    flags = dv.getUint32(8, true) >>> 16;
    if (flags & 255) {
      if (zidx == -1)
        zidx = dv.getUint32(doff, true);
      doff += 4;
    }
  }
  var ret;
  var t = buf[v2 >= 4 ? 1 : 2];
  switch (t) {
    case 0:
      return void 0;
    case 2:
      ret = { t: "n", v: ieee };
      break;
    case 3:
      ret = { t: "s", v: lut.sst[sidx] };
      break;
    case 5:
      {
        if (opts == null ? void 0 : opts.cellDates)
          ret = { t: "d", v: dt };
        else
          ret = { t: "n", v: dc / 86400 + 35430, z: table_fmt[14] };
      }
      break;
    case 6:
      ret = { t: "b", v: ieee > 0 };
      break;
    case 7:
      ret = { t: "n", v: ieee };
      break;
    case 8:
      ret = { t: "e", v: 0 };
      break;
    case 9:
      {
        if (ridx > -1) {
          var rts = lut.rsst[ridx];
          ret = { t: "s", v: rts.v };
          if (rts.l)
            ret.l = { Target: rts.l };
        } else
          throw new Error("Unsupported cell type ".concat(buf[subarray](0, 4)));
      }
      break;
    default:
      throw new Error("Unsupported cell type ".concat(buf[subarray](0, 4)));
  }
  if (zidx > -1)
    numbers_format_cell(ret, t | v2 << 8, flags, lut.ofmt[zidx], lut.nfmt[zidx]);
  if (t == 7)
    ret.v /= 86400;
  return ret;
}
function parse_new_storage(buf, lut, opts) {
  var dv = u8_to_dataview(buf);
  dv.getUint32(4, true);
  var fields = dv.getUint32(8, true);
  var doff = 12;
  var ridx = -1, sidx = -1, zidx = -1, d128 = NaN, ieee = NaN, dc = 0, dt = new Date(Date.UTC(2001, 0, 1));
  if (fields & 1) {
    d128 = readDecimal128LE(buf, doff);
    doff += 16;
  }
  if (fields & 2) {
    ieee = dv.getFloat64(doff, true);
    doff += 8;
  }
  if (fields & 4) {
    dt.setTime(dt.getTime() + (dc = dv.getFloat64(doff, true)) * 1e3);
    doff += 8;
  }
  if (fields & 8) {
    sidx = dv.getUint32(doff, true);
    doff += 4;
  }
  if (fields & 16) {
    ridx = dv.getUint32(doff, true);
    doff += 4;
  }
  doff += popcnt(fields & 480) * 4;
  if (fields & 512) {
    dv.getUint32(doff, true);
    doff += 4;
  }
  doff += popcnt(fields & 1024) * 4;
  if (fields & 2048) {
    dv.getUint32(doff, true);
    doff += 4;
  }
  var ret;
  var t = buf[1];
  switch (t) {
    case 0:
      ret = { t: "z" };
      break;
    case 2:
      ret = { t: "n", v: d128 };
      break;
    case 3:
      ret = { t: "s", v: lut.sst[sidx] };
      break;
    case 5:
      {
        if (opts == null ? void 0 : opts.cellDates)
          ret = { t: "d", v: dt };
        else
          ret = { t: "n", v: dc / 86400 + 35430, z: table_fmt[14] };
      }
      break;
    case 6:
      ret = { t: "b", v: ieee > 0 };
      break;
    case 7:
      ret = { t: "n", v: ieee };
      break;
    case 8:
      ret = { t: "e", v: 0 };
      break;
    case 9:
      {
        if (ridx > -1) {
          var rts = lut.rsst[ridx];
          ret = { t: "s", v: rts.v };
          if (rts.l)
            ret.l = { Target: rts.l };
        } else
          throw new Error("Unsupported cell type ".concat(buf[1], " : ").concat(fields & 31, " : ").concat(buf[subarray](0, 4)));
      }
      break;
    case 10:
      ret = { t: "n", v: d128 };
      break;
    default:
      throw new Error("Unsupported cell type ".concat(buf[1], " : ").concat(fields & 31, " : ").concat(buf[subarray](0, 4)));
  }
  doff += popcnt(fields & 4096) * 4;
  if (fields & 516096) {
    if (zidx == -1)
      zidx = dv.getUint32(doff, true);
    doff += 4;
  }
  if (fields & 524288) {
    var cmntidx = dv.getUint32(doff, true);
    doff += 4;
    if (lut.cmnt[cmntidx])
      ret.c = iwa_to_s5s_comment(lut.cmnt[cmntidx]);
  }
  if (zidx > -1)
    numbers_format_cell(ret, t | 5 << 8, fields >> 13, lut.ofmt[zidx], lut.nfmt[zidx]);
  if (t == 7)
    ret.v /= 86400;
  return ret;
}
function parse_cell_storage(buf, lut, opts) {
  switch (buf[0]) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return parse_old_storage(buf, lut, buf[0], opts);
    case 5:
      return parse_new_storage(buf, lut, opts);
    default:
      throw new Error("Unsupported payload version ".concat(buf[0]));
  }
}
function parse_TSP_Reference(buf) {
  var pb = parse_shallow(buf);
  return varint_to_i32(pb[1][0].data);
}
function parse_TST_TableDataList(M, root2) {
  var pb = parse_shallow(root2.data);
  var type = varint_to_i32(pb[1][0].data);
  var entries = pb[3];
  var data = [];
  (entries || []).forEach(function(entry) {
    var _a, _b;
    var le2 = parse_shallow(entry.data);
    if (!le2[1])
      return;
    var key2 = varint_to_i32(le2[1][0].data) >>> 0;
    switch (type) {
      case 1:
        data[key2] = u8str(le2[3][0].data);
        break;
      case 8:
        {
          var rt = M[parse_TSP_Reference(le2[9][0].data)][0];
          var rtp = parse_shallow(rt.data);
          var rtpref = M[parse_TSP_Reference(rtp[1][0].data)][0];
          var mtype = varint_to_i32(rtpref.meta[1][0].data);
          if (mtype != 2001)
            throw new Error("2000 unexpected reference to ".concat(mtype));
          var tswpsa = parse_shallow(rtpref.data);
          var richtext = { v: tswpsa[3].map(function(x) {
            return u8str(x.data);
          }).join("") };
          data[key2] = richtext;
          sfields:
            if ((_a = tswpsa == null ? void 0 : tswpsa[11]) == null ? void 0 : _a[0]) {
              var smartfields = (_b = parse_shallow(tswpsa[11][0].data)) == null ? void 0 : _b[1];
              if (!smartfields)
                break sfields;
              smartfields.forEach(function(sf) {
                var _a2, _b2, _c;
                var attr = parse_shallow(sf.data);
                if ((_a2 = attr[2]) == null ? void 0 : _a2[0]) {
                  var obj = M[parse_TSP_Reference((_b2 = attr[2]) == null ? void 0 : _b2[0].data)][0];
                  var objtype = varint_to_i32(obj.meta[1][0].data);
                  switch (objtype) {
                    case 2032:
                      var hlink = parse_shallow(obj.data);
                      if (((_c = hlink == null ? void 0 : hlink[2]) == null ? void 0 : _c[0]) && !richtext.l)
                        richtext.l = u8str(hlink[2][0].data);
                      break;
                    case 2039:
                      break;
                    default:
                      console.log("unrecognized ObjectAttribute type ".concat(objtype));
                  }
                }
              });
            }
        }
        break;
      case 2:
        data[key2] = parse_shallow(le2[6][0].data);
        break;
      case 3:
        data[key2] = parse_shallow(le2[5][0].data);
        break;
      case 10:
        {
          var cs = M[parse_TSP_Reference(le2[10][0].data)][0];
          data[key2] = parse_TSD_CommentStorageArchive(M, cs.data);
        }
        break;
      default:
        throw type;
    }
  });
  return data;
}
function parse_TST_TileRowInfo(u8, type) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  var pb = parse_shallow(u8);
  var R = varint_to_i32(pb[1][0].data) >>> 0;
  var cnt = varint_to_i32(pb[2][0].data) >>> 0;
  var wide_offsets = ((_b = (_a = pb[8]) == null ? void 0 : _a[0]) == null ? void 0 : _b.data) && varint_to_i32(pb[8][0].data) > 0 || false;
  var used_storage_u8, used_storage;
  if (((_d = (_c = pb[7]) == null ? void 0 : _c[0]) == null ? void 0 : _d.data) && type != 0) {
    used_storage_u8 = (_f = (_e2 = pb[7]) == null ? void 0 : _e2[0]) == null ? void 0 : _f.data;
    used_storage = (_h = (_g = pb[6]) == null ? void 0 : _g[0]) == null ? void 0 : _h.data;
  } else if (((_j = (_i = pb[4]) == null ? void 0 : _i[0]) == null ? void 0 : _j.data) && type != 1) {
    used_storage_u8 = (_l = (_k = pb[4]) == null ? void 0 : _k[0]) == null ? void 0 : _l.data;
    used_storage = (_n = (_m = pb[3]) == null ? void 0 : _m[0]) == null ? void 0 : _n.data;
  } else
    throw "NUMBERS Tile missing ".concat(type, " cell storage");
  var width = wide_offsets ? 4 : 1;
  var used_storage_offsets = u8_to_dataview(used_storage_u8);
  var offsets = [];
  for (var C2 = 0; C2 < used_storage_u8.length / 2; ++C2) {
    var off = used_storage_offsets.getUint16(C2 * 2, true);
    if (off < 65535)
      offsets.push([C2, off]);
  }
  if (offsets.length != cnt)
    throw "Expected ".concat(cnt, " cells, found ").concat(offsets.length);
  var cells = [];
  for (C2 = 0; C2 < offsets.length - 1; ++C2)
    cells[offsets[C2][0]] = used_storage[subarray](offsets[C2][1] * width, offsets[C2 + 1][1] * width);
  if (offsets.length >= 1)
    cells[offsets[offsets.length - 1][0]] = used_storage[subarray](offsets[offsets.length - 1][1] * width);
  return { R, cells };
}
function parse_TST_Tile(M, root2) {
  var _a;
  var pb = parse_shallow(root2.data);
  var storage = -1;
  if ((_a = pb == null ? void 0 : pb[7]) == null ? void 0 : _a[0]) {
    if (varint_to_i32(pb[7][0].data) >>> 0)
      storage = 1;
    else
      storage = 0;
  }
  var ri = mappa(pb[5], function(u8) {
    return parse_TST_TileRowInfo(u8, storage);
  });
  return {
    nrows: varint_to_i32(pb[4][0].data) >>> 0,
    data: ri.reduce(function(acc, x) {
      if (!acc[x.R])
        acc[x.R] = [];
      x.cells.forEach(function(cell, C2) {
        if (acc[x.R][C2])
          throw new Error("Duplicate cell r=".concat(x.R, " c=").concat(C2));
        acc[x.R][C2] = cell;
      });
      return acc;
    }, [])
  };
}
function parse_TSD_CommentStorageArchive(M, data) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j;
  var out = { t: "", a: "" };
  var csp = parse_shallow(data);
  if ((_b = (_a = csp == null ? void 0 : csp[1]) == null ? void 0 : _a[0]) == null ? void 0 : _b.data)
    out.t = u8str((_d = (_c = csp == null ? void 0 : csp[1]) == null ? void 0 : _c[0]) == null ? void 0 : _d.data) || "";
  if ((_f = (_e2 = csp == null ? void 0 : csp[3]) == null ? void 0 : _e2[0]) == null ? void 0 : _f.data) {
    var as = M[parse_TSP_Reference((_h = (_g = csp == null ? void 0 : csp[3]) == null ? void 0 : _g[0]) == null ? void 0 : _h.data)][0];
    var asp = parse_shallow(as.data);
    if ((_j = (_i = asp[1]) == null ? void 0 : _i[0]) == null ? void 0 : _j.data)
      out.a = u8str(asp[1][0].data);
  }
  if (csp == null ? void 0 : csp[4]) {
    out.replies = [];
    csp[4].forEach(function(pi) {
      var cs = M[parse_TSP_Reference(pi.data)][0];
      out.replies.push(parse_TSD_CommentStorageArchive(M, cs.data));
    });
  }
  return out;
}
function iwa_to_s5s_comment(iwa) {
  var out = [];
  out.push({ t: iwa.t || "", a: iwa.a, T: iwa.replies && iwa.replies.length > 0 });
  if (iwa.replies)
    iwa.replies.forEach(function(reply) {
      out.push({ t: reply.t || "", a: reply.a, T: true });
    });
  return out;
}
function parse_TST_TableModelArchive(M, root2, ws, opts) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j;
  var pb = parse_shallow(root2.data);
  var range = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
  range.e.r = (varint_to_i32(pb[6][0].data) >>> 0) - 1;
  if (range.e.r < 0)
    throw new Error("Invalid row varint ".concat(pb[6][0].data));
  range.e.c = (varint_to_i32(pb[7][0].data) >>> 0) - 1;
  if (range.e.c < 0)
    throw new Error("Invalid col varint ".concat(pb[7][0].data));
  ws["!ref"] = encode_range(range);
  var dense = ws["!data"] != null, dws = ws;
  var store = parse_shallow(pb[4][0].data);
  var lut = numbers_lut_new();
  if ((_a = store[4]) == null ? void 0 : _a[0])
    lut.sst = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[4][0].data)][0]);
  if ((_b = store[6]) == null ? void 0 : _b[0])
    lut.fmla = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[6][0].data)][0]);
  if ((_c = store[11]) == null ? void 0 : _c[0])
    lut.ofmt = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[11][0].data)][0]);
  if ((_d = store[12]) == null ? void 0 : _d[0])
    lut.ferr = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[12][0].data)][0]);
  if ((_e2 = store[17]) == null ? void 0 : _e2[0])
    lut.rsst = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[17][0].data)][0]);
  if ((_f = store[19]) == null ? void 0 : _f[0])
    lut.cmnt = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[19][0].data)][0]);
  if ((_g = store[22]) == null ? void 0 : _g[0])
    lut.nfmt = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[22][0].data)][0]);
  var tile = parse_shallow(store[3][0].data);
  var _R = 0;
  if (!((_h = store[9]) == null ? void 0 : _h[0]))
    throw "NUMBERS file missing row tree";
  var rtt = parse_shallow(store[9][0].data)[1].map(function(p) {
    return parse_shallow(p.data);
  });
  rtt.forEach(function(kv) {
    _R = varint_to_i32(kv[1][0].data);
    var tidx = varint_to_i32(kv[2][0].data);
    var t = tile[1][tidx];
    if (!t)
      throw "NUMBERS missing tile " + tidx;
    var tl = parse_shallow(t.data);
    var ref22 = M[parse_TSP_Reference(tl[2][0].data)][0];
    var mtype2 = varint_to_i32(ref22.meta[1][0].data);
    if (mtype2 != 6002)
      throw new Error("6001 unexpected reference to ".concat(mtype2));
    var _tile = parse_TST_Tile(M, ref22);
    _tile.data.forEach(function(row, R) {
      row.forEach(function(buf, C2) {
        var res = parse_cell_storage(buf, lut, opts);
        if (res) {
          if (dense) {
            if (!dws["!data"][_R + R])
              dws["!data"][_R + R] = [];
            dws["!data"][_R + R][C2] = res;
          } else {
            ws[encode_col(C2) + encode_row(_R + R)] = res;
          }
        }
      });
    });
    _R += _tile.nrows;
  });
  if ((_i = store[13]) == null ? void 0 : _i[0]) {
    var ref2 = M[parse_TSP_Reference(store[13][0].data)][0];
    var mtype = varint_to_i32(ref2.meta[1][0].data);
    if (mtype != 6144)
      throw new Error("Expected merge type 6144, found ".concat(mtype));
    ws["!merges"] = (_j = parse_shallow(ref2.data)) == null ? void 0 : _j[1].map(function(pi) {
      var merge2 = parse_shallow(pi.data);
      var origin = u8_to_dataview(parse_shallow(merge2[1][0].data)[1][0].data), size = u8_to_dataview(parse_shallow(merge2[2][0].data)[1][0].data);
      return {
        s: { r: origin.getUint16(0, true), c: origin.getUint16(2, true) },
        e: {
          r: origin.getUint16(0, true) + size.getUint16(0, true) - 1,
          c: origin.getUint16(2, true) + size.getUint16(2, true) - 1
        }
      };
    });
  }
}
function parse_TST_TableInfoArchive(M, root2, opts) {
  var pb = parse_shallow(root2.data);
  var out = { "!ref": "A1" };
  if (opts == null ? void 0 : opts.dense)
    out["!data"] = [];
  var tableref = M[parse_TSP_Reference(pb[2][0].data)];
  var mtype = varint_to_i32(tableref[0].meta[1][0].data);
  if (mtype != 6001)
    throw new Error("6000 unexpected reference to ".concat(mtype));
  parse_TST_TableModelArchive(M, tableref[0], out, opts);
  return out;
}
function parse_TN_SheetArchive(M, root2, opts) {
  var _a;
  var pb = parse_shallow(root2.data);
  var out = {
    name: ((_a = pb[1]) == null ? void 0 : _a[0]) ? u8str(pb[1][0].data) : "",
    sheets: []
  };
  var shapeoffs = mappa(pb[2], parse_TSP_Reference);
  shapeoffs.forEach(function(off) {
    M[off].forEach(function(m) {
      var mtype = varint_to_i32(m.meta[1][0].data);
      if (mtype == 6e3)
        out.sheets.push(parse_TST_TableInfoArchive(M, m, opts));
    });
  });
  return out;
}
function parse_TN_DocumentArchive(M, root2, opts) {
  var _a;
  var out = book_new();
  out.Workbook = { WBProps: { date1904: true } };
  var pb = parse_shallow(root2.data);
  if ((_a = pb[2]) == null ? void 0 : _a[0])
    throw new Error("Keynote presentations are not supported");
  var sheetoffs = mappa(pb[1], parse_TSP_Reference);
  sheetoffs.forEach(function(off) {
    M[off].forEach(function(m) {
      var mtype = varint_to_i32(m.meta[1][0].data);
      if (mtype == 2) {
        var root22 = parse_TN_SheetArchive(M, m, opts);
        root22.sheets.forEach(function(sheet, idx) {
          book_append_sheet(out, sheet, idx == 0 ? root22.name : root22.name + "_" + idx, true);
        });
      }
    });
  });
  if (out.SheetNames.length == 0)
    throw new Error("Empty NUMBERS file");
  out.bookType = "numbers";
  return out;
}
function parse_numbers_iwa(cfb, opts) {
  var _a, _b, _c, _d, _e2, _f, _g;
  var M = {}, indices = [];
  cfb.FullPaths.forEach(function(p) {
    if (p.match(/\.iwpv2/))
      throw new Error("Unsupported password protection");
  });
  cfb.FileIndex.forEach(function(s) {
    if (!s.name.match(/\.iwa$/))
      return;
    if (s.content[0] != 0)
      return;
    var o;
    try {
      o = decompress_iwa_file(s.content);
    } catch (e) {
      return console.log("?? " + s.content.length + " " + (e.message || e));
    }
    var packets;
    try {
      packets = parse_iwa_file(o);
    } catch (e) {
      return console.log("## " + (e.message || e));
    }
    packets.forEach(function(packet) {
      M[packet.id] = packet.messages;
      indices.push(packet.id);
    });
  });
  if (!indices.length)
    throw new Error("File has no messages");
  if (((_c = (_b = (_a = M == null ? void 0 : M[1]) == null ? void 0 : _a[0].meta) == null ? void 0 : _b[1]) == null ? void 0 : _c[0].data) && varint_to_i32(M[1][0].meta[1][0].data) == 1e4)
    throw new Error("Pages documents are not supported");
  var docroot = ((_g = (_f = (_e2 = (_d = M == null ? void 0 : M[1]) == null ? void 0 : _d[0]) == null ? void 0 : _e2.meta) == null ? void 0 : _f[1]) == null ? void 0 : _g[0].data) && varint_to_i32(M[1][0].meta[1][0].data) == 1 && M[1][0];
  if (!docroot)
    indices.forEach(function(idx) {
      M[idx].forEach(function(iwam) {
        var mtype = varint_to_i32(iwam.meta[1][0].data) >>> 0;
        if (mtype == 1) {
          if (!docroot)
            docroot = iwam;
          else
            throw new Error("Document has multiple roots");
        }
      });
    });
  if (!docroot)
    throw new Error("Cannot find Document root");
  return parse_TN_DocumentArchive(M, docroot, opts);
}
function fix_opts_func(defaults) {
  return function fix_opts(opts) {
    for (var i = 0; i != defaults.length; ++i) {
      var d = defaults[i];
      if (opts[d[0]] === void 0) opts[d[0]] = d[1];
      if (d[2] === "n") opts[d[0]] = Number(opts[d[0]]);
    }
  };
}
function fix_read_opts(opts) {
  fix_opts_func([
    ["cellNF", false],
    /* emit cell number format string as .z */
    ["cellHTML", true],
    /* emit html string as .h */
    ["cellFormula", true],
    /* emit formulae as .f */
    ["cellStyles", false],
    /* emits style/theme as .s */
    ["cellText", true],
    /* emit formatted text as .w */
    ["cellDates", false],
    /* emit date cells with type `d` */
    ["sheetStubs", false],
    /* emit empty cells */
    ["sheetRows", 0, "n"],
    /* read n rows (0 = read all rows) */
    ["bookDeps", false],
    /* parse calculation chains */
    ["bookSheets", false],
    /* only try to get sheet names (no Sheets) */
    ["bookProps", false],
    /* only try to get properties (no Sheets) */
    ["bookFiles", false],
    /* include raw file structure (keys, files, cfb) */
    ["bookVBA", false],
    /* include vba raw data (vbaraw) */
    ["password", ""],
    /* password */
    ["WTF", false]
    /* WTF mode (throws errors) */
  ])(opts);
}
function get_sheet_type(n) {
  if (RELS.WS.indexOf(n) > -1) return "sheet";
  if (n == RELS.CS) return "chart";
  if (n == RELS.DS) return "dialog";
  if (n == RELS.MS) return "macro";
  return n && n.length ? n : "sheet";
}
function safe_parse_wbrels(wbrels, sheets) {
  if (!wbrels) return 0;
  try {
    wbrels = sheets.map(function pwbr(w) {
      if (!w.id) w.id = w.strRelID;
      return [w.name, wbrels["!id"][w.id].Target, get_sheet_type(wbrels["!id"][w.id].Type)];
    });
  } catch (e) {
    return null;
  }
  return !wbrels || wbrels.length === 0 ? null : wbrels;
}
function parse_sheet_legacy_drawing(sheet, type, zip, path, idx, opts, wb, comments) {
  if (!sheet || !sheet["!legdrawel"]) return;
  var dfile = resolve_path(sheet["!legdrawel"].Target, path);
  var draw = getzipstr(zip, dfile, true);
  if (draw) parse_vml(utf8read(draw), sheet, comments || []);
}
function safe_parse_sheet(zip, path, relsPath, sheet, idx, sheetRels, sheets, stype, opts, wb, themes, styles) {
  try {
    sheetRels[sheet] = parse_rels(getzipstr(zip, relsPath, true), path);
    var data = getzipdata(zip, path);
    var _ws;
    switch (stype) {
      case "sheet":
        _ws = parse_ws(data, path, idx, opts, sheetRels[sheet], wb, themes, styles);
        break;
      case "chart":
        _ws = parse_cs(data, path, idx, opts, sheetRels[sheet], wb, themes, styles);
        if (!_ws || !_ws["!drawel"]) break;
        var dfile = resolve_path(_ws["!drawel"].Target, path);
        var drelsp = get_rels_path(dfile);
        var draw = parse_drawing(getzipstr(zip, dfile, true), parse_rels(getzipstr(zip, drelsp, true), dfile));
        var chartp = resolve_path(draw, dfile);
        var crelsp = get_rels_path(chartp);
        _ws = parse_chart(getzipstr(zip, chartp, true), chartp, opts, parse_rels(getzipstr(zip, crelsp, true), chartp), wb, _ws);
        break;
      case "macro":
        _ws = parse_ms(data, path, idx, opts, sheetRels[sheet], wb, themes, styles);
        break;
      case "dialog":
        _ws = parse_ds(data, path, idx, opts, sheetRels[sheet], wb, themes, styles);
        break;
      default:
        throw new Error("Unrecognized sheet type " + stype);
    }
    sheets[sheet] = _ws;
    var comments = [], tcomments = [];
    if (sheetRels && sheetRels[sheet]) keys(sheetRels[sheet]).forEach(function(n) {
      var dfile2 = "";
      if (sheetRels[sheet][n].Type == RELS.CMNT) {
        dfile2 = resolve_path(sheetRels[sheet][n].Target, path);
        comments = parse_cmnt(getzipdata(zip, dfile2, true), dfile2, opts);
        if (!comments || !comments.length) return;
        sheet_insert_comments(_ws, comments, false);
      }
      if (sheetRels[sheet][n].Type == RELS.TCMNT) {
        dfile2 = resolve_path(sheetRels[sheet][n].Target, path);
        tcomments = tcomments.concat(parse_tcmnt_xml(getzipdata(zip, dfile2, true), opts));
      }
    });
    if (tcomments && tcomments.length) sheet_insert_comments(_ws, tcomments, true, opts.people || []);
    parse_sheet_legacy_drawing(_ws, stype, zip, path, idx, opts, wb, comments);
  } catch (e) {
    if (opts.WTF) throw e;
  }
}
function strip_front_slash(x) {
  return x.charAt(0) == "/" ? x.slice(1) : x;
}
function parse_zip(zip, opts) {
  make_ssf();
  opts = opts || {};
  fix_read_opts(opts);
  if (safegetzipfile(zip, "META-INF/manifest.xml")) return parse_ods(zip, opts);
  if (safegetzipfile(zip, "objectdata.xml")) return parse_ods(zip, opts);
  if (safegetzipfile(zip, "Index/Document.iwa")) {
    if (typeof Uint8Array == "undefined") throw new Error("NUMBERS file parsing requires Uint8Array support");
    if (typeof parse_numbers_iwa != "undefined") {
      if (zip.FileIndex) return parse_numbers_iwa(zip, opts);
      var _zip = CFB.utils.cfb_new();
      zipentries(zip).forEach(function(e) {
        zip_add_file(_zip, e, getzipbin(zip, e));
      });
      return parse_numbers_iwa(_zip, opts);
    }
    throw new Error("Unsupported NUMBERS file");
  }
  if (!safegetzipfile(zip, "[Content_Types].xml")) {
    if (safegetzipfile(zip, "index.xml.gz")) throw new Error("Unsupported NUMBERS 08 file");
    if (safegetzipfile(zip, "index.xml")) throw new Error("Unsupported NUMBERS 09 file");
    var index_zip = CFB.find(zip, "Index.zip");
    if (index_zip) {
      opts = dup(opts);
      delete opts.type;
      if (typeof index_zip.content == "string") opts.type = "binary";
      if (typeof Bun !== "undefined" && Buffer.isBuffer(index_zip.content)) return readSync(new Uint8Array(index_zip.content), opts);
      return readSync(index_zip.content, opts);
    }
    throw new Error("Unsupported ZIP file");
  }
  var entries = zipentries(zip);
  var dir = parse_ct(getzipstr(zip, "[Content_Types].xml"));
  var xlsb = false;
  var sheets, binname;
  if (dir.workbooks.length === 0) {
    binname = "xl/workbook.xml";
    if (getzipdata(zip, binname, true)) dir.workbooks.push(binname);
  }
  if (dir.workbooks.length === 0) {
    binname = "xl/workbook.bin";
    if (!getzipdata(zip, binname, true)) throw new Error("Could not find workbook");
    dir.workbooks.push(binname);
    xlsb = true;
  }
  if (dir.workbooks[0].slice(-3) == "bin") xlsb = true;
  var themes = {};
  var styles = {};
  if (!opts.bookSheets && !opts.bookProps) {
    strs = [];
    if (dir.sst) try {
      strs = parse_sst(getzipdata(zip, strip_front_slash(dir.sst)), dir.sst, opts);
    } catch (e) {
      if (opts.WTF) throw e;
    }
    if (opts.cellStyles && dir.themes.length) themes = parse_theme_xml(getzipstr(zip, dir.themes[0].replace(/^\//, ""), true) || "", opts);
    if (dir.style) styles = parse_sty(getzipdata(zip, strip_front_slash(dir.style)), dir.style, themes, opts);
  }
  dir.links.map(function(link) {
    try {
      var rels = parse_rels(getzipstr(zip, get_rels_path(strip_front_slash(link))), link);
      return parse_xlink(getzipdata(zip, strip_front_slash(link)), rels, link, opts);
    } catch (e) {
    }
  });
  var wb = parse_wb(getzipdata(zip, strip_front_slash(dir.workbooks[0])), dir.workbooks[0], opts);
  var props = {}, propdata = "";
  if (dir.coreprops.length) {
    propdata = getzipdata(zip, strip_front_slash(dir.coreprops[0]), true);
    if (propdata) props = parse_core_props(propdata);
    if (dir.extprops.length !== 0) {
      propdata = getzipdata(zip, strip_front_slash(dir.extprops[0]), true);
      if (propdata) parse_ext_props(propdata, props, opts);
    }
  }
  var custprops = {};
  if (!opts.bookSheets || opts.bookProps) {
    if (dir.custprops.length !== 0) {
      propdata = getzipstr(zip, strip_front_slash(dir.custprops[0]), true);
      if (propdata) custprops = parse_cust_props(propdata, opts);
    }
  }
  var out = {};
  if (opts.bookSheets || opts.bookProps) {
    if (wb.Sheets) sheets = wb.Sheets.map(function pluck(x) {
      return x.name;
    });
    else if (props.Worksheets && props.SheetNames.length > 0) sheets = props.SheetNames;
    if (opts.bookProps) {
      out.Props = props;
      out.Custprops = custprops;
    }
    if (opts.bookSheets && typeof sheets !== "undefined") out.SheetNames = sheets;
    if (opts.bookSheets ? out.SheetNames : opts.bookProps) return out;
  }
  sheets = {};
  var deps = {};
  if (opts.bookDeps && dir.calcchain) deps = parse_cc(getzipdata(zip, strip_front_slash(dir.calcchain)), dir.calcchain);
  var i = 0;
  var sheetRels = {};
  var path, relsPath;
  {
    var wbsheets = wb.Sheets;
    props.Worksheets = wbsheets.length;
    props.SheetNames = [];
    for (var j = 0; j != wbsheets.length; ++j) {
      props.SheetNames[j] = wbsheets[j].name;
    }
  }
  var wbext = xlsb ? "bin" : "xml";
  var wbrelsi = dir.workbooks[0].lastIndexOf("/");
  var wbrelsfile = (dir.workbooks[0].slice(0, wbrelsi + 1) + "_rels/" + dir.workbooks[0].slice(wbrelsi + 1) + ".rels").replace(/^\//, "");
  if (!safegetzipfile(zip, wbrelsfile)) wbrelsfile = "xl/_rels/workbook." + wbext + ".rels";
  var wbrels = parse_rels(getzipstr(zip, wbrelsfile, true), wbrelsfile.replace(/_rels.*/, "s5s"));
  if ((dir.metadata || []).length >= 1) {
    opts.xlmeta = parse_xlmeta(getzipdata(zip, strip_front_slash(dir.metadata[0])), dir.metadata[0], opts);
  }
  if ((dir.people || []).length >= 1) {
    opts.people = parse_people_xml(getzipdata(zip, strip_front_slash(dir.people[0])), opts);
  }
  if (wbrels) wbrels = safe_parse_wbrels(wbrels, wb.Sheets);
  var nmode = getzipdata(zip, "xl/worksheets/sheet.xml", true) ? 1 : 0;
  wsloop: for (i = 0; i != props.Worksheets; ++i) {
    var stype = "sheet";
    if (wbrels && wbrels[i]) {
      path = "xl/" + wbrels[i][1].replace(/[\/]?xl\//, "");
      if (!safegetzipfile(zip, path)) path = wbrels[i][1];
      if (!safegetzipfile(zip, path)) path = wbrelsfile.replace(/_rels\/[\S\s]*$/, "") + wbrels[i][1];
      stype = wbrels[i][2];
    } else {
      path = "xl/worksheets/sheet" + (i + 1 - nmode) + "." + wbext;
      path = path.replace(/sheet0\./, "sheet.");
    }
    relsPath = path.replace(/^(.*)(\/)([^\/]*)$/, "$1/_rels/$3.rels");
    if (opts && opts.sheets != null) switch (typeof opts.sheets) {
      case "number":
        if (i != opts.sheets) continue wsloop;
        break;
      case "string":
        if (props.SheetNames[i].toLowerCase() != opts.sheets.toLowerCase()) continue wsloop;
        break;
      default:
        if (Array.isArray && Array.isArray(opts.sheets)) {
          var snjseen = false;
          for (var snj = 0; snj != opts.sheets.length; ++snj) {
            if (typeof opts.sheets[snj] == "number" && opts.sheets[snj] == i) snjseen = 1;
            if (typeof opts.sheets[snj] == "string" && opts.sheets[snj].toLowerCase() == props.SheetNames[i].toLowerCase()) snjseen = 1;
          }
          if (!snjseen) continue wsloop;
        }
    }
    safe_parse_sheet(zip, path, relsPath, props.SheetNames[i], i, sheetRels, sheets, stype, opts, wb, themes, styles);
  }
  out = {
    Directory: dir,
    Workbook: wb,
    Props: props,
    Custprops: custprops,
    Deps: deps,
    Sheets: sheets,
    SheetNames: props.SheetNames,
    Strings: strs,
    Styles: styles,
    Themes: themes,
    SSF: dup(table_fmt)
  };
  if (opts && opts.bookFiles) {
    if (zip.files) {
      out.keys = entries;
      out.files = zip.files;
    } else {
      out.keys = [];
      out.files = {};
      zip.FullPaths.forEach(function(p, idx) {
        p = p.replace(/^Root Entry[\/]/, "");
        out.keys.push(p);
        out.files[p] = zip.FileIndex[idx];
      });
    }
  }
  if (opts && opts.bookVBA) {
    if (dir.vba.length > 0) out.vbaraw = getzipdata(zip, strip_front_slash(dir.vba[0]), true);
    else if (dir.defaults && dir.defaults.bin === CT_VBA) out.vbaraw = getzipdata(zip, "xl/vbaProject.bin", true);
  }
  out.bookType = xlsb ? "xlsb" : "xlsx";
  return out;
}
function parse_xlsxcfb(cfb, _opts) {
  var opts = _opts || {};
  var f = "Workbook", data = CFB.find(cfb, f);
  try {
    f = "/!DataSpaces/Version";
    data = CFB.find(cfb, f);
    if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);
    parse_DataSpaceVersionInfo(data.content);
    f = "/!DataSpaces/DataSpaceMap";
    data = CFB.find(cfb, f);
    if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);
    var dsm = parse_DataSpaceMap(data.content);
    if (dsm.length !== 1 || dsm[0].comps.length !== 1 || dsm[0].comps[0].t !== 0 || dsm[0].name !== "StrongEncryptionDataSpace" || dsm[0].comps[0].v !== "EncryptedPackage")
      throw new Error("ECMA-376 Encrypted file bad " + f);
    f = "/!DataSpaces/DataSpaceInfo/StrongEncryptionDataSpace";
    data = CFB.find(cfb, f);
    if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);
    var seds = parse_DataSpaceDefinition(data.content);
    if (seds.length != 1 || seds[0] != "StrongEncryptionTransform")
      throw new Error("ECMA-376 Encrypted file bad " + f);
    f = "/!DataSpaces/TransformInfo/StrongEncryptionTransform/!Primary";
    data = CFB.find(cfb, f);
    if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);
    parse_Primary(data.content);
  } catch (e) {
  }
  f = "/EncryptionInfo";
  data = CFB.find(cfb, f);
  if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);
  var einfo = parse_EncryptionInfo(data.content);
  f = "/EncryptedPackage";
  data = CFB.find(cfb, f);
  if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);
  if (einfo[0] == 4 && typeof decrypt_agile !== "undefined") return decrypt_agile(einfo[1], data.content, opts.password || "", opts);
  if (einfo[0] == 2 && typeof decrypt_std76 !== "undefined") return decrypt_std76(einfo[1], data.content, opts.password || "", opts);
  throw new Error("File is password-protected");
}
function firstbyte(f, o) {
  var x = "";
  switch ((o || {}).type || "base64") {
    case "buffer":
      return [f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]];
    case "base64":
      x = Base64_decode(f.slice(0, 12));
      break;
    case "binary":
      x = f;
      break;
    case "array":
      return [f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]];
    default:
      throw new Error("Unrecognized type " + (o && o.type || "undefined"));
  }
  return [x.charCodeAt(0), x.charCodeAt(1), x.charCodeAt(2), x.charCodeAt(3), x.charCodeAt(4), x.charCodeAt(5), x.charCodeAt(6), x.charCodeAt(7)];
}
function read_cfb(cfb, opts) {
  if (CFB.find(cfb, "EncryptedPackage")) return parse_xlsxcfb(cfb, opts);
  return parse_xlscfb(cfb, opts);
}
function read_zip(data, opts) {
  var zip, d = data;
  var o = opts || {};
  if (!o.type) o.type = has_buf && Buffer.isBuffer(data) ? "buffer" : "base64";
  zip = zip_read(d, o);
  return parse_zip(zip, o);
}
function read_plaintext(data, o) {
  var i = 0;
  main: while (i < data.length) switch (data.charCodeAt(i)) {
    case 10:
    case 13:
    case 32:
      ++i;
      break;
    case 60:
      return parse_xlml(data.slice(i), o);
    default:
      break main;
  }
  return PRN.to_workbook(data, o);
}
function read_plaintext_raw(data, o) {
  var str = "", bytes = firstbyte(data, o);
  switch (o.type) {
    case "base64":
      str = Base64_decode(data);
      break;
    case "binary":
      str = data;
      break;
    case "buffer":
      str = data.toString("binary");
      break;
    case "array":
      str = cc2str(data);
      break;
    default:
      throw new Error("Unrecognized type " + o.type);
  }
  if (bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191) str = utf8read(str);
  o.type = "binary";
  return read_plaintext(str, o);
}
function read_utf16(data, o) {
  var d = data;
  if (o.type == "base64") d = Base64_decode(d);
  if (typeof ArrayBuffer !== "undefined" && data instanceof ArrayBuffer) d = new Uint8Array(data);
  d = has_buf && Buffer.isBuffer(data) ? data.slice(2).toString("utf16le") : typeof Uint8Array !== "undefined" && d instanceof Uint8Array ? typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le").decode(d.slice(2)) : utf16lereadu(d.slice(2)) : utf16leread(d.slice(2));
  o.type = "binary";
  return read_plaintext(d, o);
}
function bstrify(data) {
  return !data.match(/[^\x00-\x7F]/) ? data : utf8write(data);
}
function read_prn(data, d, o, str) {
  if (str) {
    o.type = "string";
    return PRN.to_workbook(data, o);
  }
  return PRN.to_workbook(d, o);
}
function readSync(data, opts) {
  reset_cp();
  var o = opts || {};
  if (o.codepage && typeof $cptable === "undefined") console.error("Codepage tables are not loaded.  Non-ASCII characters may not give expected results");
  if (typeof ArrayBuffer !== "undefined" && data instanceof ArrayBuffer) return readSync(new Uint8Array(data), (o = dup(o), o.type = "array", o));
  if (typeof Uint8Array !== "undefined" && data instanceof Uint8Array && !o.type) o.type = typeof Deno !== "undefined" ? "buffer" : "array";
  var d = data, n = [0, 0, 0, 0], str = false;
  if (o.cellStyles) {
    o.cellNF = true;
    o.sheetStubs = true;
  }
  _ssfopts = {};
  if (o.dateNF) _ssfopts.dateNF = o.dateNF;
  if (!o.type) o.type = has_buf && Buffer.isBuffer(data) ? "buffer" : "base64";
  if (o.type == "file") {
    o.type = has_buf ? "buffer" : "binary";
    d = read_binary(data);
    if (typeof Uint8Array !== "undefined" && !has_buf) o.type = "array";
  }
  if (o.type == "string") {
    str = true;
    o.type = "binary";
    o.codepage = 65001;
    d = bstrify(data);
  }
  if (o.type == "array" && typeof Uint8Array !== "undefined" && data instanceof Uint8Array && typeof ArrayBuffer !== "undefined") {
    var ab = new ArrayBuffer(3), vu = new Uint8Array(ab);
    vu.foo = "bar";
    if (!vu.foo) {
      o = dup(o);
      o.type = "array";
      return readSync(ab2a(d), o);
    }
  }
  switch ((n = firstbyte(d, o))[0]) {
    case 208:
      if (n[1] === 207 && n[2] === 17 && n[3] === 224 && n[4] === 161 && n[5] === 177 && n[6] === 26 && n[7] === 225) return read_cfb(CFB.read(d, o), o);
      break;
    case 9:
      if (n[1] <= 8) return parse_xlscfb(d, o);
      break;
    case 60:
      return parse_xlml(d, o);
    case 73:
      if (n[1] === 73 && n[2] === 42 && n[3] === 0) throw new Error("TIFF Image File is not a spreadsheet");
      if (n[1] === 68) return read_wb_ID(d, o);
      break;
    case 84:
      if (n[1] === 65 && n[2] === 66 && n[3] === 76) return DIF.to_workbook(d, o);
      break;
    case 80:
      return n[1] === 75 && n[2] < 9 && n[3] < 9 ? read_zip(d, o) : read_prn(data, d, o, str);
    case 239:
      return n[3] === 60 ? parse_xlml(d, o) : read_prn(data, d, o, str);
    case 255:
      if (n[1] === 254) {
        return read_utf16(d, o);
      } else if (n[1] === 0 && n[2] === 2 && n[3] === 0) return WK_.to_workbook(d, o);
      break;
    case 0:
      if (n[1] === 0) {
        if (n[2] >= 2 && n[3] === 0) return WK_.to_workbook(d, o);
        if (n[2] === 0 && (n[3] === 8 || n[3] === 9)) return WK_.to_workbook(d, o);
      }
      break;
    case 3:
    case 131:
    case 139:
    case 140:
      return DBF.to_workbook(d, o);
    case 123:
      if (n[1] === 92 && n[2] === 114 && n[3] === 116) return rtf_to_workbook(d, o);
      break;
    case 10:
    case 13:
    case 32:
      return read_plaintext_raw(d, o);
    case 137:
      if (n[1] === 80 && n[2] === 78 && n[3] === 71) throw new Error("PNG Image File is not a spreadsheet");
      break;
    case 8:
      if (n[1] === 231) throw new Error("Unsupported Multiplan 1.x file!");
      break;
    case 12:
      if (n[1] === 236) throw new Error("Unsupported Multiplan 2.x file!");
      if (n[1] === 237) throw new Error("Unsupported Multiplan 3.x file!");
      break;
  }
  if (DBF_SUPPORTED_VERSIONS.indexOf(n[0]) > -1 && n[2] <= 12 && n[3] <= 31) return DBF.to_workbook(d, o);
  return read_prn(data, d, o, str);
}
function make_json_row(sheet, r, R, cols, header, hdr, o) {
  var rr = encode_row(R);
  var defval = o.defval, raw = o.raw || !Object.prototype.hasOwnProperty.call(o, "raw");
  var isempty = true, dense = sheet["!data"] != null;
  var row = header === 1 ? [] : {};
  if (header !== 1) {
    if (Object.defineProperty) try {
      Object.defineProperty(row, "__rowNum__", { value: R, enumerable: false });
    } catch (e) {
      row.__rowNum__ = R;
    }
    else row.__rowNum__ = R;
  }
  if (!dense || sheet["!data"][R]) for (var C2 = r.s.c; C2 <= r.e.c; ++C2) {
    var val = dense ? (sheet["!data"][R] || [])[C2] : sheet[cols[C2] + rr];
    if (val == null || val.t === void 0) {
      if (defval === void 0) continue;
      if (hdr[C2] != null) {
        row[hdr[C2]] = defval;
      }
      continue;
    }
    var v2 = val.v;
    switch (val.t) {
      case "z":
        if (v2 == null) break;
        continue;
      case "e":
        v2 = v2 == 0 ? null : void 0;
        break;
      case "s":
      case "b":
      case "n":
        if (!val.z || !fmt_is_date(val.z)) break;
        v2 = numdate(v2);
        if (typeof v2 == "number") break;
      case "d":
        if (!(o.UTC || o.raw === false)) v2 = utc_to_local(new Date(v2));
        break;
      default:
        throw new Error("unrecognized type " + val.t);
    }
    if (hdr[C2] != null) {
      if (v2 == null) {
        if (val.t == "e" && v2 === null) row[hdr[C2]] = null;
        else if (defval !== void 0) row[hdr[C2]] = defval;
        else if (raw && v2 === null) row[hdr[C2]] = null;
        else continue;
      } else {
        row[hdr[C2]] = (val.t === "n" && typeof o.rawNumbers === "boolean" ? o.rawNumbers : raw) ? v2 : format_cell(val, v2, o);
      }
      if (v2 != null) isempty = false;
    }
  }
  return { row, isempty };
}
function sheet_to_json(sheet, opts) {
  if (sheet == null || sheet["!ref"] == null) return [];
  var val = { t: "n", v: 0 }, header = 0, offset = 1, hdr = [], v2 = 0, vv = "";
  var r = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
  var o = opts || {};
  var range = o.range != null ? o.range : sheet["!ref"];
  if (o.header === 1) header = 1;
  else if (o.header === "A") header = 2;
  else if (Array.isArray(o.header)) header = 3;
  else if (o.header == null) header = 0;
  switch (typeof range) {
    case "string":
      r = safe_decode_range(range);
      break;
    case "number":
      r = safe_decode_range(sheet["!ref"]);
      r.s.r = range;
      break;
    default:
      r = range;
  }
  if (header > 0) offset = 0;
  var rr = encode_row(r.s.r);
  var cols = [];
  var out = [];
  var outi = 0, counter = 0;
  var dense = sheet["!data"] != null;
  var R = r.s.r, C2 = 0;
  var header_cnt = {};
  if (dense && !sheet["!data"][R]) sheet["!data"][R] = [];
  var colinfo = o.skipHidden && sheet["!cols"] || [];
  var rowinfo = o.skipHidden && sheet["!rows"] || [];
  for (C2 = r.s.c; C2 <= r.e.c; ++C2) {
    if ((colinfo[C2] || {}).hidden) continue;
    cols[C2] = encode_col(C2);
    val = dense ? sheet["!data"][R][C2] : sheet[cols[C2] + rr];
    switch (header) {
      case 1:
        hdr[C2] = C2 - r.s.c;
        break;
      case 2:
        hdr[C2] = cols[C2];
        break;
      case 3:
        hdr[C2] = o.header[C2 - r.s.c];
        break;
      default:
        if (val == null) val = { w: "__EMPTY", t: "s" };
        vv = v2 = format_cell(val, null, o);
        counter = header_cnt[v2] || 0;
        if (!counter) header_cnt[v2] = 1;
        else {
          do {
            vv = v2 + "_" + counter++;
          } while (header_cnt[vv]);
          header_cnt[v2] = counter;
          header_cnt[vv] = 1;
        }
        hdr[C2] = vv;
    }
  }
  for (R = r.s.r + offset; R <= r.e.r; ++R) {
    if ((rowinfo[R] || {}).hidden) continue;
    var row = make_json_row(sheet, r, R, cols, header, hdr, o);
    if (row.isempty === false || (header === 1 ? o.blankrows !== false : !!o.blankrows)) out[outi++] = row.row;
  }
  out.length = outi;
  return out;
}
var qreg = /"/g;
function make_csv_row(sheet, r, R, cols, fs, rs, FS, o) {
  var isempty = true;
  var row = [], txt = "", rr = encode_row(R);
  var dense = sheet["!data"] != null;
  var datarow = dense && sheet["!data"][R] || [];
  for (var C2 = r.s.c; C2 <= r.e.c; ++C2) {
    if (!cols[C2]) continue;
    var val = dense ? datarow[C2] : sheet[cols[C2] + rr];
    if (val == null) txt = "";
    else if (val.v != null) {
      isempty = false;
      txt = "" + (o.rawNumbers && val.t == "n" ? val.v : format_cell(val, null, o));
      for (var i = 0, cc = 0; i !== txt.length; ++i) if ((cc = txt.charCodeAt(i)) === fs || cc === rs || cc === 34 || o.forceQuotes) {
        txt = '"' + txt.replace(qreg, '""') + '"';
        break;
      }
      if (txt == "ID") txt = '"ID"';
    } else if (val.f != null && !val.F) {
      isempty = false;
      txt = "=" + val.f;
      if (txt.indexOf(",") >= 0) txt = '"' + txt.replace(qreg, '""') + '"';
    } else txt = "";
    row.push(txt);
  }
  if (o.strip) while (row[row.length - 1] === "") --row.length;
  if (o.blankrows === false && isempty) return null;
  return row.join(FS);
}
function sheet_to_csv(sheet, opts) {
  var out = [];
  var o = opts == null ? {} : opts;
  if (sheet == null || sheet["!ref"] == null) return "";
  var r = safe_decode_range(sheet["!ref"]);
  var FS = o.FS !== void 0 ? o.FS : ",", fs = FS.charCodeAt(0);
  var RS = o.RS !== void 0 ? o.RS : "\n", rs = RS.charCodeAt(0);
  var row = "", cols = [];
  var colinfo = o.skipHidden && sheet["!cols"] || [];
  var rowinfo = o.skipHidden && sheet["!rows"] || [];
  for (var C2 = r.s.c; C2 <= r.e.c; ++C2) if (!(colinfo[C2] || {}).hidden) cols[C2] = encode_col(C2);
  var w = 0;
  for (var R = r.s.r; R <= r.e.r; ++R) {
    if ((rowinfo[R] || {}).hidden) continue;
    row = make_csv_row(sheet, r, R, cols, fs, rs, FS, o);
    if (row == null) {
      continue;
    }
    if (row || o.blankrows !== false) out.push((w++ ? RS : "") + row);
  }
  return out.join("");
}
function sheet_to_txt(sheet, opts) {
  if (!opts) opts = {};
  opts.FS = "	";
  opts.RS = "\n";
  var s = sheet_to_csv(sheet, opts);
  return s;
}
function sheet_to_formulae(sheet) {
  var y = "", x, val = "";
  if (sheet == null || sheet["!ref"] == null) return [];
  var r = safe_decode_range(sheet["!ref"]), rr = "", cols = [], C2;
  var cmds = [];
  var dense = sheet["!data"] != null;
  for (C2 = r.s.c; C2 <= r.e.c; ++C2) cols[C2] = encode_col(C2);
  for (var R = r.s.r; R <= r.e.r; ++R) {
    rr = encode_row(R);
    for (C2 = r.s.c; C2 <= r.e.c; ++C2) {
      y = cols[C2] + rr;
      x = dense ? (sheet["!data"][R] || [])[C2] : sheet[y];
      val = "";
      if (x === void 0) continue;
      else if (x.F != null) {
        y = x.F;
        if (!x.f) continue;
        val = x.f;
        if (y.indexOf(":") == -1) y = y + ":" + y;
      }
      if (x.f != null) val = x.f;
      else if (x.t == "z") continue;
      else if (x.t == "n" && x.v != null) val = "" + x.v;
      else if (x.t == "b") val = x.v ? "TRUE" : "FALSE";
      else if (x.w !== void 0) val = "'" + x.w;
      else if (x.v === void 0) continue;
      else if (x.t == "s") val = "'" + x.v;
      else val = "" + x.v;
      cmds[cmds.length] = y + "=" + val;
    }
  }
  return cmds;
}
function sheet_add_json(_ws, js, opts) {
  var o = opts || {};
  var dense = _ws ? _ws["!data"] != null : o.dense;
  var offset = +!o.skipHeader;
  var ws = _ws || {};
  if (!_ws && dense) ws["!data"] = [];
  var _R = 0, _C = 0;
  if (o.origin != null) {
    if (typeof o.origin == "number") _R = o.origin;
    else {
      var _origin = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;
      _R = _origin.r;
      _C = _origin.c;
    }
  }
  var range = { s: { c: 0, r: 0 }, e: { c: _C, r: _R + js.length - 1 + offset } };
  if (ws["!ref"]) {
    var _range = safe_decode_range(ws["!ref"]);
    range.e.c = Math.max(range.e.c, _range.e.c);
    range.e.r = Math.max(range.e.r, _range.e.r);
    if (_R == -1) {
      _R = _range.e.r + 1;
      range.e.r = _R + js.length - 1 + offset;
    }
  } else {
    if (_R == -1) {
      _R = 0;
      range.e.r = js.length - 1 + offset;
    }
  }
  var hdr = o.header || [], C2 = 0;
  var ROW = [];
  js.forEach(function(JS, R) {
    if (dense && !ws["!data"][_R + R + offset]) ws["!data"][_R + R + offset] = [];
    if (dense) ROW = ws["!data"][_R + R + offset];
    keys(JS).forEach(function(k2) {
      if ((C2 = hdr.indexOf(k2)) == -1) hdr[C2 = hdr.length] = k2;
      var v2 = JS[k2];
      var t = "z";
      var z = "";
      var ref2 = dense ? "" : encode_col(_C + C2) + encode_row(_R + R + offset);
      var cell = dense ? ROW[_C + C2] : ws[ref2];
      if (v2 && typeof v2 === "object" && !(v2 instanceof Date)) {
        if (dense) ROW[_C + C2] = v2;
        else ws[ref2] = v2;
      } else {
        if (typeof v2 == "number") t = "n";
        else if (typeof v2 == "boolean") t = "b";
        else if (typeof v2 == "string") t = "s";
        else if (v2 instanceof Date) {
          t = "d";
          if (!o.UTC) v2 = local_to_utc(v2);
          if (!o.cellDates) {
            t = "n";
            v2 = datenum(v2);
          }
          z = cell != null && cell.z && fmt_is_date(cell.z) ? cell.z : o.dateNF || table_fmt[14];
        } else if (v2 === null && o.nullError) {
          t = "e";
          v2 = 0;
        }
        if (!cell) {
          if (!dense) ws[ref2] = cell = { t, v: v2 };
          else ROW[_C + C2] = cell = { t, v: v2 };
        } else {
          cell.t = t;
          cell.v = v2;
          delete cell.w;
          delete cell.R;
          if (z) cell.z = z;
        }
        if (z) cell.z = z;
      }
    });
  });
  range.e.c = Math.max(range.e.c, _C + hdr.length - 1);
  var __R = encode_row(_R);
  if (dense && !ws["!data"][_R]) ws["!data"][_R] = [];
  if (offset) for (C2 = 0; C2 < hdr.length; ++C2) {
    if (dense) ws["!data"][_R][C2 + _C] = { t: "s", v: hdr[C2] };
    else ws[encode_col(C2 + _C) + __R] = { t: "s", v: hdr[C2] };
  }
  ws["!ref"] = encode_range(range);
  return ws;
}
function json_to_sheet(js, opts) {
  return sheet_add_json(null, js, opts);
}
function ws_get_cell_stub(ws, R, C2) {
  if (typeof R == "string") {
    if (ws["!data"] != null) {
      var RC = decode_cell(R);
      if (!ws["!data"][RC.r]) ws["!data"][RC.r] = [];
      return ws["!data"][RC.r][RC.c] || (ws["!data"][RC.r][RC.c] = { t: "z" });
    }
    return ws[R] || (ws[R] = { t: "z" });
  }
  if (typeof R != "number") return ws_get_cell_stub(ws, encode_cell(R));
  return ws_get_cell_stub(ws, encode_col(C2 || 0) + encode_row(R));
}
function wb_sheet_idx(wb, sh) {
  if (typeof sh == "number") {
    if (sh >= 0 && wb.SheetNames.length > sh) return sh;
    throw new Error("Cannot find sheet # " + sh);
  } else if (typeof sh == "string") {
    var idx = wb.SheetNames.indexOf(sh);
    if (idx > -1) return idx;
    throw new Error("Cannot find sheet name |" + sh + "|");
  } else throw new Error("Cannot find sheet |" + sh + "|");
}
function book_new(ws, wsname) {
  var wb = { SheetNames: [], Sheets: {} };
  if (ws) book_append_sheet(wb, ws, wsname || "Sheet1");
  return wb;
}
function book_append_sheet(wb, ws, name, roll) {
  var i = 1;
  if (!name) {
    for (; i <= 65535; ++i, name = void 0) if (wb.SheetNames.indexOf(name = "Sheet" + i) == -1) break;
  }
  if (!name || wb.SheetNames.length >= 65535) throw new Error("Too many worksheets");
  if (roll && wb.SheetNames.indexOf(name) >= 0 && name.length < 32) {
    var m = name.match(/\d+$/);
    i = m && +m[0] || 0;
    var root2 = m && name.slice(0, m.index) || name;
    for (++i; i <= 65535; ++i) if (wb.SheetNames.indexOf(name = root2 + i) == -1) break;
  }
  check_ws_name(name);
  if (wb.SheetNames.indexOf(name) >= 0) throw new Error("Worksheet with name |" + name + "| already exists!");
  wb.SheetNames.push(name);
  wb.Sheets[name] = ws;
  return name;
}
function book_set_sheet_visibility(wb, sh, vis) {
  if (!wb.Workbook) wb.Workbook = {};
  if (!wb.Workbook.Sheets) wb.Workbook.Sheets = [];
  var idx = wb_sheet_idx(wb, sh);
  if (!wb.Workbook.Sheets[idx]) wb.Workbook.Sheets[idx] = {};
  switch (vis) {
    case 0:
    case 1:
    case 2:
      break;
    default:
      throw new Error("Bad sheet visibility setting " + vis);
  }
  wb.Workbook.Sheets[idx].Hidden = vis;
}
function cell_set_number_format(cell, fmt) {
  cell.z = fmt;
  return cell;
}
function cell_set_hyperlink(cell, target, tooltip) {
  if (!target) {
    delete cell.l;
  } else {
    cell.l = { Target: target };
    if (tooltip) cell.l.Tooltip = tooltip;
  }
  return cell;
}
function cell_set_internal_link(cell, range, tooltip) {
  return cell_set_hyperlink(cell, "#" + range, tooltip);
}
function cell_add_comment(cell, text, author) {
  if (!cell.c) cell.c = [];
  cell.c.push({ t: text, a: author || "SheetJS" });
}
function sheet_set_array_formula(ws, range, formula, dynamic) {
  var rng = typeof range != "string" ? range : safe_decode_range(range);
  var rngstr = typeof range == "string" ? range : encode_range(range);
  for (var R = rng.s.r; R <= rng.e.r; ++R) for (var C2 = rng.s.c; C2 <= rng.e.c; ++C2) {
    var cell = ws_get_cell_stub(ws, R, C2);
    cell.t = "n";
    cell.F = rngstr;
    delete cell.v;
    if (R == rng.s.r && C2 == rng.s.c) {
      cell.f = formula;
      if (dynamic) cell.D = true;
    }
  }
  var wsr = decode_range(ws["!ref"]);
  if (wsr.s.r > rng.s.r) wsr.s.r = rng.s.r;
  if (wsr.s.c > rng.s.c) wsr.s.c = rng.s.c;
  if (wsr.e.r < rng.e.r) wsr.e.r = rng.e.r;
  if (wsr.e.c < rng.e.c) wsr.e.c = rng.e.c;
  ws["!ref"] = encode_range(wsr);
  return ws;
}
var utils = {
  encode_col,
  encode_row,
  encode_cell,
  encode_range,
  decode_col,
  decode_row,
  split_cell,
  decode_cell,
  decode_range,
  format_cell,
  sheet_new,
  sheet_add_aoa,
  sheet_add_json,
  sheet_add_dom,
  aoa_to_sheet,
  json_to_sheet,
  table_to_sheet: parse_dom_table,
  table_to_book,
  sheet_to_csv,
  sheet_to_txt,
  sheet_to_json,
  sheet_to_html,
  sheet_to_formulae,
  sheet_to_row_object_array: sheet_to_json,
  sheet_get_cell: ws_get_cell_stub,
  book_new,
  book_append_sheet,
  book_set_sheet_visibility,
  cell_set_number_format,
  cell_set_hyperlink,
  cell_set_internal_link,
  cell_add_comment,
  sheet_set_array_formula,
  consts: {
    SHEET_VISIBLE: 0,
    SHEET_HIDDEN: 1,
    SHEET_VERY_HIDDEN: 2
  }
};
const React$6 = await importShared("react");
const { useState: useState$4, useRef: useRef$4, useEffect: useEffect$5 } = React$6;
const { getPropertyInPath: getPropertyInPath2, mergeDeep: mergeDeep$1, resolveProperty: resolveProperty2, isPropertyBuilder: isPropertyBuilder$2, EntityReference: EntityReference2, useSnackbarController: useSnackbarController$3, useCustomizationController: useCustomizationController$5, getFieldConfig: getFieldConfig$1, PropertyConfigBadge: PropertyConfigBadge$1, ErrorBoundary: ErrorBoundary$1, useDataSource: useDataSource$2, resolveCollection: resolveCollection$3, getPropertiesWithPropertiesOrder: getPropertiesWithPropertiesOrder2, useSelectionController: useSelectionController$2, EntityCollectionTable: EntityCollectionTable$2, slugify: slugify$1 } = await importShared("@firecms/core");
const { TableRow: TableRow$1, TableCell: TableCell$1, Typography: Typography$4, ChevronRightIcon: ChevronRightIcon2, TableHeader: TableHeader2, Table: Table$1, TableBody: TableBody$1, ExpandablePanel: ExpandablePanel$1, SelectItem: SelectItem$2, TextField: TextField$4, BooleanSwitchWithLabel: BooleanSwitchWithLabel$3, DateTimeField: DateTimeField2, Select: Select$2, UploadIcon: UploadIcon2, FileUpload: FileUpload$1, EditIcon: EditIcon2, IconButton: IconButton$5, Button: Button$5, CenteredView: CenteredView$1, CircularProgress: CircularProgress$4, cls: cls$5, defaultBorderMixin: defaultBorderMixin$2, Tooltip: Tooltip$5, DialogTitle: DialogTitle$4, DialogContent: DialogContent$4, DialogActions: DialogActions$3, Dialog: Dialog$4 } = await importShared("@firecms/ui");
const useImportConfig = () => {
  const $2 = c_1(18);
  const [inUse, setInUse] = useState$4(false);
  let t0;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $2[0] = t0;
  } else {
    t0 = $2[0];
  }
  const [defaultValues, setDefaultValues] = useState$4(t0);
  const [idColumn, setIdColumn] = useState$4();
  let t1;
  if ($2[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [];
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  const [importData, setImportData] = useState$4(t1);
  let t2;
  if ($2[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = [];
    $2[2] = t2;
  } else {
    t2 = $2[2];
  }
  const [entities, setEntities] = useState$4(t2);
  let t3;
  if ($2[3] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = {};
    $2[3] = t3;
  } else {
    t3 = $2[3];
  }
  const [headersMapping, setHeadersMapping] = useState$4(t3);
  let t4;
  if ($2[4] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = [];
    $2[4] = t4;
  } else {
    t4 = $2[4];
  }
  const [headingsOrder, setHeadingsOrder] = useState$4(t4);
  let t5;
  if ($2[5] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = {};
    $2[5] = t5;
  } else {
    t5 = $2[5];
  }
  const [originProperties, setOriginProperties] = useState$4(t5);
  let t6;
  if ($2[6] !== headersMapping || $2[7] !== headingsOrder) {
    t6 = (headingsOrder ?? []).length > 0 ? headingsOrder : Object.keys(headersMapping);
    $2[6] = headersMapping;
    $2[7] = headingsOrder;
    $2[8] = t6;
  } else {
    t6 = $2[8];
  }
  let t7;
  if ($2[9] !== defaultValues || $2[10] !== entities || $2[11] !== headersMapping || $2[12] !== idColumn || $2[13] !== importData || $2[14] !== inUse || $2[15] !== originProperties || $2[16] !== t6) {
    t7 = {
      inUse,
      setInUse,
      idColumn,
      setIdColumn,
      entities,
      setEntities,
      importData,
      setImportData,
      headingsOrder: t6,
      setHeadingsOrder,
      headersMapping,
      setHeadersMapping,
      originProperties,
      setOriginProperties,
      defaultValues,
      setDefaultValues
    };
    $2[9] = defaultValues;
    $2[10] = entities;
    $2[11] = headersMapping;
    $2[12] = idColumn;
    $2[13] = importData;
    $2[14] = inUse;
    $2[15] = originProperties;
    $2[16] = t6;
    $2[17] = t7;
  } else {
    t7 = $2[17];
  }
  return t7;
};
function getXLSXHeaders(sheet) {
  let header = 0;
  const hdr = [];
  const o = {};
  if (sheet == null || sheet["!ref"] == null) return [];
  const range = o.range !== void 0 ? o.range : sheet["!ref"];
  let r;
  if (o.header === 1) header = 1;
  else if (o.header === "A") header = 2;
  else if (Array.isArray(o.header)) header = 3;
  switch (typeof range) {
    case "string":
      r = safeDecodeRange(range);
      break;
    case "number":
      r = safeDecodeRange(sheet["!ref"]);
      r.s.r = range;
      break;
    default:
      r = range;
  }
  const rr = utils.encode_row(r.s.r);
  const cols = new Array(r.e.c - r.s.c + 1);
  for (let C2 = r.s.c; C2 <= r.e.c; ++C2) {
    cols[C2] = utils.encode_col(C2);
    const val = sheet[cols[C2] + rr];
    switch (header) {
      case 1:
        hdr.push(C2);
        break;
      case 2:
        hdr.push(cols[C2]);
        break;
      case 3:
        hdr.push(o.header[C2 - r.s.c]);
        break;
      default:
        if (val === void 0) continue;
        hdr.push(utils.format_cell(val));
    }
  }
  return hdr;
}
function safeDecodeRange(range) {
  const o = {
    s: {
      c: 0,
      r: 0
    },
    e: {
      c: 0,
      r: 0
    }
  };
  let idx = 0;
  let i = 0;
  let cc = 0;
  const len = range.length;
  for (idx = 0; i < len; ++i) {
    if ((cc = range.charCodeAt(i) - 64) < 1 || cc > 26) break;
    idx = 26 * idx + cc;
  }
  o.s.c = --idx;
  for (idx = 0; i < len; ++i) {
    if ((cc = range.charCodeAt(i) - 48) < 0 || cc > 9) break;
    idx = 10 * idx + cc;
  }
  o.s.r = --idx;
  if (i === len || range.charCodeAt(++i) === 58) {
    o.e.c = o.s.c;
    o.e.r = o.s.r;
    return o;
  }
  for (idx = 0; i !== len; ++i) {
    if ((cc = range.charCodeAt(i) - 64) < 1 || cc > 26) break;
    idx = 26 * idx + cc;
  }
  o.e.c = --idx;
  for (idx = 0; i !== len; ++i) {
    if ((cc = range.charCodeAt(i) - 48) < 0 || cc > 9) break;
    idx = 10 * idx + cc;
  }
  o.e.r = --idx;
  return o;
}
function convertFileToJson(file) {
  return new Promise((resolve, reject) => {
    if (file.type === "application/json") {
      console.debug("Converting JSON file to JSON", file.name);
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = e.target?.result;
          const jsonData = JSON.parse(data);
          if (!Array.isArray(jsonData)) {
            reject(new Error("JSON file should contain an array of objects"));
          } else {
            const propertiesOrder = jsonData.length > 0 ? Object.keys(jsonData[0]) : [];
            resolve({
              data: jsonData,
              propertiesOrder
            });
          }
        } catch (e2) {
          console.error("Error parsing JSON file", e2);
          reject(e2);
        }
      };
      reader.readAsText(file);
    } else {
      console.debug("Converting Excel file to JSON", file.name);
      const reader = new FileReader();
      reader.onload = function(e) {
        const data = new Uint8Array(e.target?.result);
        const workbook = readSync(data, {
          type: "array",
          codepage: 65001,
          cellDates: true
        });
        const worksheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[worksheetName];
        const parsedData = utils.sheet_to_json(worksheet);
        const headers = getXLSXHeaders(worksheet);
        const cleanedData = parsedData.map(mapJsonParse);
        const jsonData = cleanedData.map(unflattenObject);
        resolve({
          data: jsonData,
          propertiesOrder: headers
        });
      };
      reader.readAsArrayBuffer(file);
    }
  });
}
function mapJsonParse(obj) {
  return Object.keys(obj).reduce((acc, key2) => {
    try {
      acc[key2] = JSON.parse(obj[key2]);
    } catch (e) {
      acc[key2] = obj[key2];
    }
    return acc;
  }, {});
}
function unflattenObject(flatObj) {
  return Object.keys(flatObj).reduce((nestedObj, key2) => {
    let currentObj = nestedObj;
    const keyParts = key2.split(".");
    keyParts.forEach((keyPart, i) => {
      if (/^[\w]+\[\d+\]$/.test(keyPart)) {
        const mainPropertyName = keyPart.slice(0, keyPart.indexOf("["));
        const index2 = parseInt(keyPart.slice(keyPart.indexOf("[") + 1, keyPart.indexOf("]")));
        if (!currentObj[mainPropertyName]) {
          currentObj[mainPropertyName] = [];
        }
        if (i !== keyParts.length - 1) {
          currentObj[mainPropertyName][index2] = currentObj[mainPropertyName][index2] || {};
          currentObj = currentObj[mainPropertyName][index2];
        } else {
          currentObj[mainPropertyName][index2] = flatObj[key2];
        }
      } else if (i !== keyParts.length - 1) {
        currentObj[keyPart] = currentObj[keyPart] || {};
        currentObj = currentObj[keyPart];
      } else {
        currentObj[keyPart] = flatObj[key2];
      }
    });
    return nestedObj;
  }, {});
}
function convertDataToEntity(data, idColumn, headersMapping, properties, path, defaultValues) {
  const flatObject = flattenEntry(data);
  if (idColumn) delete flatObject[idColumn];
  const mappedKeysObject = Object.entries(flatObject).map(([key2, value]) => {
    const mappedKey = getIn(headersMapping, key2) ?? key2;
    const mappedProperty = getPropertyInPath2(properties, mappedKey);
    if (!mappedProperty) {
      return {};
    }
    const processedValue = processValueMapping(value, mappedProperty);
    return {
      [mappedKey]: processedValue
    };
  }).reduce((acc, curr) => ({
    ...acc,
    ...curr
  }), {});
  const values = mergeDeep$1(defaultValues ?? {}, unflattenObject(mappedKeysObject));
  let id = idColumn ? data[idColumn] : void 0;
  if (typeof id === "string") {
    id = id.trim();
  } else if (typeof id === "number") {
    id = id.toString();
  } else if (typeof id === "boolean") {
    id = id.toString();
  } else if (id instanceof Date) {
    id = id.toISOString();
  } else if (id && "toString" in id) {
    id = id.toString();
  }
  return {
    id,
    values,
    path
  };
}
function flattenEntry(obj, parent = "") {
  return Object.keys(obj).reduce((acc, key2) => {
    const prefixedKey = parent ? `${parent}.${key2}` : key2;
    if (typeof obj[key2] === "object" && !(obj[key2] instanceof Date) && obj[key2] !== null && !Array.isArray(obj[key2])) {
      Object.assign(acc, flattenEntry(obj[key2], prefixedKey));
    } else {
      acc[prefixedKey] = obj[key2];
    }
    return acc;
  }, {});
}
function processValueMapping(value, property) {
  if (value === null) return null;
  if (property === void 0) return value;
  const usedProperty = resolveProperty2({
    propertyOrBuilder: property
  });
  if (usedProperty === null) return value;
  const from = inferTypeFromValue(value);
  const to = usedProperty.dataType;
  if (from === "array" && to === "array" && Array.isArray(value) && usedProperty.of && !isPropertyBuilder$2(usedProperty.of)) {
    return value.map((v2) => processValueMapping(v2, usedProperty.of));
  } else if (from === "string" && to === "number" && typeof value === "string") {
    return Number(value);
  } else if (from === "string" && to === "array" && typeof value === "string" && usedProperty.of && !isPropertyBuilder$2(usedProperty.of)) {
    return value.split(",").map((v2) => processValueMapping(v2, usedProperty.of));
  } else if (from === "string" && to === "boolean") {
    return value === "true";
  } else if (from === "number" && to === "boolean") {
    return value === 1;
  } else if (from === "boolean" && to === "number") {
    return value ? 1 : 0;
  } else if (from === "boolean" && to === "string") {
    return value ? "true" : "false";
  } else if (from === "number" && to === "string" && typeof value === "number") {
    return value.toString();
  } else if (from === "string" && to === "array" && typeof value === "string") {
    return value.split(",").map((v2) => v2.trim());
  } else if (from === "string" && to === "date" && typeof value === "string") {
    try {
      return new Date(value);
    } catch (e) {
      return value;
    }
  } else if (from === "date" && to === "string") {
    return value instanceof Date && value.toISOString();
  } else if (from === "number" && to === "date" && typeof value === "number") {
    try {
      return new Date(value);
    } catch (e) {
      return value;
    }
  } else if (from === "string" && to === "reference" && typeof value === "string") {
    const path = value.split("/").slice(0, -1).join("/");
    const entityId = value.split("/").slice(-1)[0];
    return new EntityReference2(entityId, path);
  } else if (from === to) {
    return value;
  } else if (from === "array" && to === "string" && Array.isArray(value)) {
    return value.join(",");
  }
  return value;
}
function getInferenceType(value) {
  if (typeof value === "number") return "number";
  else if (typeof value === "string") return "string";
  else if (typeof value === "boolean") return "boolean";
  else if (value instanceof Date) return "date";
  else if (Array.isArray(value)) return "array";
  return "map";
}
function DataNewPropertiesMapping(t0) {
  const $2 = c_1(35);
  const {
    importConfig,
    destinationProperties,
    buildPropertyView
  } = t0;
  const headersMapping = importConfig.headersMapping;
  const headingsOrder = importConfig.headingsOrder;
  const idColumn = importConfig.idColumn;
  const originProperties = importConfig.originProperties;
  let t1;
  if ($2[0] !== importConfig) {
    t1 = (value) => importConfig.setIdColumn(value ?? void 0);
    $2[0] = importConfig;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  let t2;
  if ($2[2] !== headersMapping || $2[3] !== idColumn || $2[4] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(IdSelectField, { idColumn, headersMapping, onChange: t1 });
    $2[2] = headersMapping;
    $2[3] = idColumn;
    $2[4] = t1;
    $2[5] = t2;
  } else {
    t2 = $2[5];
  }
  let t3;
  if ($2[6] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-4" });
    $2[6] = t3;
  } else {
    t3 = $2[6];
  }
  let t4;
  if ($2[7] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = {
      tableLayout: "fixed"
    };
    $2[7] = t4;
  } else {
    t4 = $2[7];
  }
  let t5;
  let t6;
  if ($2[8] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { header: true, style: {
      width: "20%"
    }, children: "Column in file" });
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { header: true });
    $2[8] = t5;
    $2[9] = t6;
  } else {
    t5 = $2[8];
    t6 = $2[9];
  }
  let t7;
  if ($2[10] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs(TableHeader2, { children: [
      t5,
      t6,
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { header: true, style: {
        width: "75%"
      }, children: "Map to Property" })
    ] });
    $2[10] = t7;
  } else {
    t7 = $2[10];
  }
  let t8;
  if ($2[11] !== buildPropertyView || $2[12] !== destinationProperties || $2[13] !== headersMapping || $2[14] !== headingsOrder || $2[15] !== idColumn || $2[16] !== originProperties) {
    t8 = destinationProperties && headingsOrder.map((importKey) => {
      const mappedKey = headersMapping[importKey];
      const propertyKey = headersMapping[importKey];
      const property = mappedKey ? getPropertyInPath2(destinationProperties, mappedKey) : null;
      const originProperty = getPropertyInPath2(originProperties, importKey);
      const originDataType = originProperty ? originProperty.dataType === "array" && typeof originProperty.of === "object" ? `${originProperty.dataType} - ${originProperty.of.dataType}` : originProperty.dataType : void 0;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow$1, { style: {
        height: "90px"
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(TableCell$1, { style: {
          width: "20%"
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$4, { variant: "body2", children: importKey }),
          originProperty && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$4, { variant: "caption", color: "secondary", children: originDataType })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightIcon2, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { className: importKey === idColumn ? "text-center" : void 0, style: {
          width: "75%"
        }, children: buildPropertyView?.({
          isIdColumn: importKey === idColumn,
          property,
          propertyKey,
          importKey
        }) })
      ] }, importKey);
    });
    $2[11] = buildPropertyView;
    $2[12] = destinationProperties;
    $2[13] = headersMapping;
    $2[14] = headingsOrder;
    $2[15] = idColumn;
    $2[16] = originProperties;
    $2[17] = t8;
  } else {
    t8 = $2[17];
  }
  let t9;
  if ($2[18] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Table$1, { style: t4, children: [
      t7,
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody$1, { children: t8 })
    ] });
    $2[18] = t8;
    $2[19] = t9;
  } else {
    t9 = $2[19];
  }
  let t10;
  if ($2[20] === Symbol.for("react.memo_cache_sentinel")) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-surface-accent-500 dark:text-surface-accent-300 font-medium ml-3.5 mb-1", children: "You can select a default value for unmapped columns and empty values:" });
    $2[20] = t10;
  } else {
    t10 = $2[20];
  }
  let t11;
  if ($2[21] === Symbol.for("react.memo_cache_sentinel")) {
    t11 = {
      tableLayout: "fixed"
    };
    $2[21] = t11;
  } else {
    t11 = $2[21];
  }
  let t12;
  let t13;
  if ($2[22] === Symbol.for("react.memo_cache_sentinel")) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { header: true, style: {
      width: "30%"
    }, children: "Property" });
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { header: true });
    $2[22] = t12;
    $2[23] = t13;
  } else {
    t12 = $2[22];
    t13 = $2[23];
  }
  let t14;
  if ($2[24] === Symbol.for("react.memo_cache_sentinel")) {
    t14 = /* @__PURE__ */ jsxRuntimeExports.jsxs(TableHeader2, { children: [
      t12,
      t13,
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { header: true, style: {
        width: "65%"
      }, children: "Default value" })
    ] });
    $2[24] = t14;
  } else {
    t14 = $2[24];
  }
  let t15;
  if ($2[25] !== destinationProperties || $2[26] !== idColumn || $2[27] !== importConfig) {
    t15 = destinationProperties && getAllPropertyKeys(destinationProperties).map((key2) => {
      const property_0 = getPropertyInPath2(destinationProperties, key2);
      if (typeof property_0 !== "object" || property_0 === null) {
        return null;
      }
      if (!["number", "string", "boolean", "map"].includes(property_0.dataType)) {
        return null;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow$1, { style: {
        height: "70px"
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { style: {
          width: "20%"
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$4, { variant: "body2", children: key2 }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightIcon2, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell$1, { className: key2 === idColumn ? "text-center" : void 0, style: {
          width: "75%"
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultValuesField, { property: property_0, defaultValue: getIn(importConfig.defaultValues, key2), onValueChange: (value_0) => {
          const newValues = setIn(importConfig.defaultValues, key2, value_0);
          importConfig.setDefaultValues(newValues);
        } }) })
      ] }, key2);
    });
    $2[25] = destinationProperties;
    $2[26] = idColumn;
    $2[27] = importConfig;
    $2[28] = t15;
  } else {
    t15 = $2[28];
  }
  let t16;
  if ($2[29] !== t15) {
    t16 = /* @__PURE__ */ jsxRuntimeExports.jsxs(ExpandablePanel$1, { title: "Default values", initiallyExpanded: false, innerClassName: "p-4 mt-4", children: [
      t10,
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Table$1, { style: t11, children: [
        t14,
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody$1, { children: t15 })
      ] })
    ] });
    $2[29] = t15;
    $2[30] = t16;
  } else {
    t16 = $2[30];
  }
  let t17;
  if ($2[31] !== t16 || $2[32] !== t2 || $2[33] !== t9) {
    t17 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t2,
      t3,
      t9,
      t16
    ] });
    $2[31] = t16;
    $2[32] = t2;
    $2[33] = t9;
    $2[34] = t17;
  } else {
    t17 = $2[34];
  }
  return t17;
}
function getAllPropertyKeys(properties, currentKey) {
  return Object.entries(properties).reduce((acc, [key2, property]) => {
    const accumulatedKey = currentKey ? `${currentKey}.${key2}` : key2;
    if (typeof property !== "function" && property.dataType === "map" && property.properties) {
      const childProperties = getAllPropertyKeys(property.properties, accumulatedKey);
      return [...acc, ...childProperties];
    }
    return [...acc, accumulatedKey];
  }, []);
}
function IdSelectField(t0) {
  const $2 = c_1(9);
  const {
    idColumn,
    headersMapping,
    onChange
  } = t0;
  const t1 = idColumn ?? "";
  let t2;
  if ($2[0] !== onChange) {
    t2 = (event) => {
      const value = event.target.value;
      onChange(value === "__none__" ? null : value);
    };
    $2[0] = onChange;
    $2[1] = t2;
  } else {
    t2 = $2[1];
  }
  let t3;
  if ($2[2] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$2, { value: "__none__", children: "Autogenerate ID" });
    $2[2] = t3;
  } else {
    t3 = $2[2];
  }
  let t4;
  if ($2[3] !== headersMapping) {
    t4 = Object.entries(headersMapping).map(_temp2$1$2);
    $2[3] = headersMapping;
    $2[4] = t4;
  } else {
    t4 = $2[4];
  }
  let t5;
  if ($2[5] !== t1 || $2[6] !== t2 || $2[7] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Select$2, { size: "medium", value: t1, fullWidth: true, onChange: t2, placeholder: "Autogenerate ID", renderValue: _temp$1$2, label: "Column that will be used as ID for each document", children: [
      t3,
      t4
    ] }) });
    $2[5] = t1;
    $2[6] = t2;
    $2[7] = t4;
    $2[8] = t5;
  } else {
    t5 = $2[8];
  }
  return t5;
}
function _temp2$1$2(t0) {
  const [key2] = t0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$2, { value: key2, children: key2 }, key2);
}
function _temp$1$2(value_0) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$4, { variant: "body2", children: value_0 !== "__none__" ? value_0 : "Autogenerate ID" });
}
function DefaultValuesField(t0) {
  const $2 = c_1(22);
  const {
    property,
    onValueChange,
    defaultValue
  } = t0;
  if (property.dataType === "string") {
    const t1 = defaultValue ?? "";
    let t2;
    if ($2[0] !== onValueChange) {
      t2 = (event) => onValueChange(event.target.value);
      $2[0] = onValueChange;
      $2[1] = t2;
    } else {
      t2 = $2[1];
    }
    let t3;
    if ($2[2] !== t1 || $2[3] !== t2) {
      t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$4, { size: "medium", placeholder: "Default value", value: t1, onChange: t2 });
      $2[2] = t1;
      $2[3] = t2;
      $2[4] = t3;
    } else {
      t3 = $2[4];
    }
    return t3;
  } else {
    if (property.dataType === "number") {
      const t1 = defaultValue ?? "";
      let t2;
      if ($2[5] !== onValueChange) {
        t2 = (event_0) => onValueChange(event_0.target.value);
        $2[5] = onValueChange;
        $2[6] = t2;
      } else {
        t2 = $2[6];
      }
      let t3;
      if ($2[7] !== t1 || $2[8] !== t2) {
        t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$4, { size: "medium", type: "number", value: t1, placeholder: "Default value", onChange: t2 });
        $2[7] = t1;
        $2[8] = t2;
        $2[9] = t3;
      } else {
        t3 = $2[9];
      }
      return t3;
    } else {
      if (property.dataType === "boolean") {
        const t1 = defaultValue ?? null;
        let t2;
        if ($2[10] !== onValueChange) {
          t2 = (v2) => onValueChange(v2 === null ? void 0 : v2);
          $2[10] = onValueChange;
          $2[11] = t2;
        } else {
          t2 = $2[11];
        }
        const t3 = defaultValue === void 0 ? "Do not set value" : defaultValue === true ? "Set value to true" : "Set value to false";
        let t4;
        if ($2[12] !== t1 || $2[13] !== t2 || $2[14] !== t3) {
          t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanSwitchWithLabel$3, { value: t1, allowIndeterminate: true, size: "small", onValueChange: t2, label: t3 });
          $2[12] = t1;
          $2[13] = t2;
          $2[14] = t3;
          $2[15] = t4;
        } else {
          t4 = $2[15];
        }
        return t4;
      } else {
        if (property.dataType === "date") {
          const t1 = property.mode ?? "date";
          const t2 = defaultValue ?? void 0;
          let t3;
          if ($2[16] !== onValueChange) {
            t3 = (dateValue) => {
              onValueChange(dateValue);
            };
            $2[16] = onValueChange;
            $2[17] = t3;
          } else {
            t3 = $2[17];
          }
          let t4;
          if ($2[18] !== t1 || $2[19] !== t2 || $2[20] !== t3) {
            t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(DateTimeField2, { mode: t1, size: "medium", value: t2, onChange: t3, clearable: true });
            $2[18] = t1;
            $2[19] = t2;
            $2[20] = t3;
            $2[21] = t4;
          } else {
            t4 = $2[21];
          }
          return t4;
        }
      }
    }
  }
  return null;
}
function ImportFileUpload(t0) {
  const $2 = c_1(5);
  const {
    onDataAdded
  } = t0;
  const snackbarController = useSnackbarController$3();
  let t1;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = {
      "text/*": [".csv", ".xls", ".xlsx"],
      "application/vnd.ms-excel": [".xls", ".xlsx"],
      "application/msexcel": [".xls", ".xlsx"],
      "application/vnd.ms-office": [".xls", ".xlsx"],
      "application/xls": [".xls", ".xlsx"],
      "application/x-xls": [".xls", ".xlsx"],
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": [".xls", ".xlsx"],
      "application/json": [".json"]
    };
    $2[0] = t1;
  } else {
    t1 = $2[0];
  }
  let t2;
  if ($2[1] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(UploadIcon2, {}),
      "Drag and drop a file here or click to upload"
    ] });
    $2[1] = t2;
  } else {
    t2 = $2[1];
  }
  let t3;
  if ($2[2] !== onDataAdded || $2[3] !== snackbarController) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(FileUpload$1, { accept: t1, preventDropOnDocument: true, size: "medium", maxFiles: 1, uploadDescription: t2, onFilesAdded: (files) => {
      if (files.length > 0) {
        convertFileToJson(files[0]).then((t4) => {
          const {
            data,
            propertiesOrder
          } = t4;
          onDataAdded(data, propertiesOrder);
        }).catch((error) => {
          console.error("Error parsing file", error);
          snackbarController.open({
            type: "error",
            message: error.message
          });
        });
      }
    } });
    $2[2] = onDataAdded;
    $2[3] = snackbarController;
    $2[4] = t3;
  } else {
    t3 = $2[4];
  }
  return t3;
}
function ImportNewPropertyFieldPreview(t0) {
  const $2 = c_1(22);
  const {
    propertyKey,
    property,
    onEditClick,
    includeName: t1,
    onPropertyNameChanged,
    propertyTypeView
  } = t0;
  const includeName = t1 === void 0 ? true : t1;
  const {
    propertyConfigs
  } = useCustomizationController$5();
  let t2;
  if ($2[0] !== property || $2[1] !== propertyConfigs) {
    t2 = property ? getFieldConfig$1(property, propertyConfigs) : null;
    $2[0] = property;
    $2[1] = propertyConfigs;
    $2[2] = t2;
  } else {
    t2 = $2[2];
  }
  const widget = t2;
  let t3;
  if ($2[3] !== propertyTypeView || $2[4] !== widget) {
    t3 = propertyTypeView ?? /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyConfigBadge$1, { propertyConfig: widget ?? void 0 });
    $2[3] = propertyTypeView;
    $2[4] = widget;
    $2[5] = t3;
  } else {
    t3 = $2[5];
  }
  let t4;
  if ($2[6] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mx-4", children: t3 });
    $2[6] = t3;
    $2[7] = t4;
  } else {
    t4 = $2[7];
  }
  let t5;
  if ($2[8] !== includeName || $2[9] !== onPropertyNameChanged || $2[10] !== property?.name || $2[11] !== propertyKey) {
    t5 = includeName && /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$4, { size: "medium", className: "text-base grow", value: property?.name ?? "", onChange: (e) => {
      if (onPropertyNameChanged && propertyKey) {
        onPropertyNameChanged(propertyKey, e.target.value);
      }
    } });
    $2[8] = includeName;
    $2[9] = onPropertyNameChanged;
    $2[10] = property?.name;
    $2[11] = propertyKey;
    $2[12] = t5;
  } else {
    t5 = $2[12];
  }
  let t6;
  if ($2[13] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(EditIcon2, { size: "small" });
    $2[13] = t6;
  } else {
    t6 = $2[13];
  }
  let t7;
  if ($2[14] !== onEditClick) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$5, { onClick: onEditClick, size: "small", children: t6 });
    $2[14] = onEditClick;
    $2[15] = t7;
  } else {
    t7 = $2[15];
  }
  let t8;
  if ($2[16] !== t5 || $2[17] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full flex flex-col grow", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row items-center gap-2", children: [
      t5,
      t7
    ] }) });
    $2[16] = t5;
    $2[17] = t7;
    $2[18] = t8;
  } else {
    t8 = $2[18];
  }
  let t9;
  if ($2[19] !== t4 || $2[20] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row w-full items-center", children: [
      t4,
      t8
    ] }) });
    $2[19] = t4;
    $2[20] = t8;
    $2[21] = t9;
  } else {
    t9 = $2[21];
  }
  return t9;
}
function ImportSaveInProgress(t0) {
  const $2 = c_1(25);
  const {
    path,
    importConfig,
    collection: collection2,
    onImportSuccess
  } = t0;
  const [errorSaving, setErrorSaving] = useState$4(void 0);
  const dataSource = useDataSource$2();
  const savingRef = useRef$4(false);
  const [processedEntities, setProcessedEntities] = useState$4(0);
  let t1;
  if ($2[0] !== collection2 || $2[1] !== dataSource || $2[2] !== importConfig || $2[3] !== onImportSuccess || $2[4] !== path) {
    t1 = function save2() {
      if (savingRef.current) {
        return;
      }
      savingRef.current = true;
      saveDataBatch(dataSource, collection2, path, importConfig.entities, 0, 25, setProcessedEntities).then(() => {
        onImportSuccess(collection2);
        savingRef.current = false;
      }).catch((e) => {
        setErrorSaving(e);
        savingRef.current = false;
      });
    };
    $2[0] = collection2;
    $2[1] = dataSource;
    $2[2] = importConfig;
    $2[3] = onImportSuccess;
    $2[4] = path;
    $2[5] = t1;
  } else {
    t1 = $2[5];
  }
  const save = t1;
  let t2;
  if ($2[6] !== save) {
    t2 = () => {
      save();
    };
    $2[6] = save;
    $2[7] = t2;
  } else {
    t2 = $2[7];
  }
  let t3;
  if ($2[8] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = [];
    $2[8] = t3;
  } else {
    t3 = $2[8];
  }
  useEffect$5(t2, t3);
  if (errorSaving) {
    let t42;
    if ($2[9] === Symbol.for("react.memo_cache_sentinel")) {
      t42 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$4, { variant: "h6", children: "Error saving data" });
      $2[9] = t42;
    } else {
      t42 = $2[9];
    }
    let t52;
    if ($2[10] !== errorSaving.message) {
      t52 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$4, { variant: "body2", color: "error", children: errorSaving.message });
      $2[10] = errorSaving.message;
      $2[11] = t52;
    } else {
      t52 = $2[11];
    }
    let t62;
    if ($2[12] !== save) {
      t62 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button$5, { onClick: save, variant: "outlined", children: "Retry" });
      $2[12] = save;
      $2[13] = t62;
    } else {
      t62 = $2[13];
    }
    let t72;
    if ($2[14] !== t52 || $2[15] !== t62) {
      t72 = /* @__PURE__ */ jsxRuntimeExports.jsxs(CenteredView$1, { className: "flex flex-col gap-4 items-center", children: [
        t42,
        t52,
        t62
      ] });
      $2[14] = t52;
      $2[15] = t62;
      $2[16] = t72;
    } else {
      t72 = $2[16];
    }
    return t72;
  }
  let t4;
  let t5;
  if ($2[17] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress$4, {});
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$4, { variant: "h6", children: "Saving data" });
    $2[17] = t4;
    $2[18] = t5;
  } else {
    t4 = $2[17];
    t5 = $2[18];
  }
  let t6;
  if ($2[19] !== importConfig.entities.length || $2[20] !== processedEntities) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography$4, { variant: "body2", children: [
      processedEntities,
      "/",
      importConfig.entities.length,
      " entities saved"
    ] });
    $2[19] = importConfig.entities.length;
    $2[20] = processedEntities;
    $2[21] = t6;
  } else {
    t6 = $2[21];
  }
  let t7;
  if ($2[22] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$4, { variant: "caption", children: "Do not close this tab or the import will be interrupted." });
    $2[22] = t7;
  } else {
    t7 = $2[22];
  }
  let t8;
  if ($2[23] !== t6) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsxs(CenteredView$1, { className: "flex flex-col gap-4 items-center", children: [
      t4,
      t5,
      t6,
      t7
    ] });
    $2[23] = t6;
    $2[24] = t8;
  } else {
    t8 = $2[24];
  }
  return t8;
}
function saveDataBatch(dataSource, collection2, path, data, offset = 0, batchSize = 25, onProgressUpdate) {
  console.debug("Saving imported data", offset, batchSize);
  const batch = data.slice(offset, offset + batchSize);
  return Promise.all(batch.map((d) => dataSource.saveEntity({
    path,
    values: d.values,
    entityId: d.id,
    collection: collection2,
    status: "new"
  }))).then(() => {
    if (offset + batchSize < data.length) {
      onProgressUpdate(offset + batchSize);
      return saveDataBatch(dataSource, collection2, path, data, offset + batchSize, batchSize, onProgressUpdate);
    }
    onProgressUpdate(data.length);
    return Promise.resolve();
  });
}
function ImportCollectionAction(t0) {
  const $2 = c_1(73);
  const {
    collection: collection2,
    path,
    onAnalyticsEvent
  } = t0;
  const customizationController = useCustomizationController$5();
  const snackbarController = useSnackbarController$3();
  const [open, setOpen] = React$6.useState(false);
  const [step, setStep] = React$6.useState("initial");
  const importConfig = useImportConfig();
  let t1;
  if ($2[0] !== onAnalyticsEvent) {
    t1 = () => {
      setOpen(true);
      onAnalyticsEvent?.("import_open");
      setStep("initial");
    };
    $2[0] = onAnalyticsEvent;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  const handleClickOpen = t1;
  let t2;
  if ($2[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = () => {
      setOpen(false);
    };
    $2[2] = t2;
  } else {
    t2 = $2[2];
  }
  const handleClose = t2;
  let t3;
  if ($2[3] !== onAnalyticsEvent) {
    t3 = () => {
      onAnalyticsEvent?.("import_mapping_complete");
      setStep("preview");
    };
    $2[3] = onAnalyticsEvent;
    $2[4] = t3;
  } else {
    t3 = $2[4];
  }
  const onMappingComplete = t3;
  let t4;
  if ($2[5] !== onAnalyticsEvent) {
    t4 = () => {
      onAnalyticsEvent?.("import_data_save");
      setStep("import_data_saving");
    };
    $2[5] = onAnalyticsEvent;
    $2[6] = t4;
  } else {
    t4 = $2[6];
  }
  const onPreviewComplete = t4;
  let t5;
  if ($2[7] !== collection2.properties || $2[8] !== importConfig || $2[9] !== onAnalyticsEvent) {
    t5 = async (data) => {
      importConfig.setImportData(data);
      if (data.length > 0) {
        const originProperties = await buildEntityPropertiesFromData(data, getInferenceType);
        importConfig.setOriginProperties(originProperties);
        const headersMapping = buildHeadersMappingFromData(data, collection2?.properties);
        importConfig.setHeadersMapping(headersMapping);
        const firstKey = Object.keys(headersMapping)?.[0];
        if (firstKey?.includes("id") || firstKey?.includes("key")) {
          importConfig.setIdColumn(firstKey);
        }
      }
      setTimeout(() => {
        onAnalyticsEvent?.("import_data_added");
        setStep("mapping");
      }, 100);
    };
    $2[7] = collection2.properties;
    $2[8] = importConfig;
    $2[9] = onAnalyticsEvent;
    $2[10] = t5;
  } else {
    t5 = $2[10];
  }
  const onDataAdded = t5;
  let properties;
  let propertiesAndLevel;
  let t6;
  if ($2[11] !== collection2 || $2[12] !== customizationController.propertyConfigs || $2[13] !== path) {
    const resolvedCollection = resolveCollection$3({
      collection: collection2,
      path,
      propertyConfigs: customizationController.propertyConfigs
    });
    properties = getPropertiesWithPropertiesOrder2(resolvedCollection.properties, resolvedCollection.propertiesOrder);
    propertiesAndLevel = Object.entries(properties).flatMap(_temp$d);
    t6 = resolvedCollection.propertiesOrder ?? Object.keys(resolvedCollection.properties);
    $2[11] = collection2;
    $2[12] = customizationController.propertyConfigs;
    $2[13] = path;
    $2[14] = properties;
    $2[15] = propertiesAndLevel;
    $2[16] = t6;
  } else {
    properties = $2[14];
    propertiesAndLevel = $2[15];
    t6 = $2[16];
  }
  const propertiesOrder = t6;
  if (collection2.collectionGroup) {
    return null;
  }
  let t7;
  if ($2[17] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(UploadIcon2, {});
    $2[17] = t7;
  } else {
    t7 = $2[17];
  }
  let t8;
  if ($2[18] !== handleClickOpen) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$5, { title: "Import", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$5, { color: "primary", onClick: handleClickOpen, children: t7 }) });
    $2[18] = handleClickOpen;
    $2[19] = t8;
  } else {
    t8 = $2[19];
  }
  const t9 = step === "preview";
  const t10 = step === "preview";
  const t11 = step === "initial" ? "lg" : "7xl";
  let t12;
  if ($2[20] === Symbol.for("react.memo_cache_sentinel")) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle$4, { variant: "h6", children: "Import data" });
    $2[20] = t12;
  } else {
    t12 = $2[20];
  }
  const t13 = step === "preview";
  let t14;
  if ($2[21] !== onDataAdded || $2[22] !== step) {
    t14 = step === "initial" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$4, { variant: "body2", children: "Upload a CSV, Excel or JSON file and map it to your existing schema" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ImportFileUpload, { onDataAdded })
    ] });
    $2[21] = onDataAdded;
    $2[22] = step;
    $2[23] = t14;
  } else {
    t14 = $2[23];
  }
  let t15;
  if ($2[24] !== importConfig || $2[25] !== onAnalyticsEvent || $2[26] !== properties || $2[27] !== propertiesAndLevel || $2[28] !== step) {
    t15 = step === "mapping" && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DataNewPropertiesMapping, { importConfig, destinationProperties: properties, buildPropertyView: (t162) => {
      const {
        isIdColumn,
        propertyKey,
        importKey
      } = t162;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyTreeSelect, { selectedPropertyKey: propertyKey ?? "", properties, propertiesAndLevel, isIdColumn, onIdSelected: () => {
        importConfig.setIdColumn(importKey);
      }, onPropertySelected: (newPropertyKey) => {
        onAnalyticsEvent?.("import_mapping_field_updated");
        const newHeadersMapping = Object.entries(importConfig.headersMapping).map((t172) => {
          const [currentImportKey, currentPropertyKey] = t172;
          if (currentPropertyKey === newPropertyKey) {
            return {
              [currentImportKey]: null
            };
          }
          if (currentImportKey === importKey) {
            return {
              [currentImportKey]: newPropertyKey
            };
          }
          return {
            [currentImportKey]: currentPropertyKey
          };
        }).reduce(_temp2$9, {});
        importConfig.setHeadersMapping(newHeadersMapping);
        if (newPropertyKey === importConfig.idColumn) {
          importConfig.setIdColumn(void 0);
        }
      } });
    } }) });
    $2[24] = importConfig;
    $2[25] = onAnalyticsEvent;
    $2[26] = properties;
    $2[27] = propertiesAndLevel;
    $2[28] = step;
    $2[29] = t15;
  } else {
    t15 = $2[29];
  }
  let t16;
  if ($2[30] !== importConfig || $2[31] !== properties || $2[32] !== propertiesOrder || $2[33] !== step) {
    t16 = step === "preview" && /* @__PURE__ */ jsxRuntimeExports.jsx(ImportDataPreview, { importConfig, properties, propertiesOrder });
    $2[30] = importConfig;
    $2[31] = properties;
    $2[32] = propertiesOrder;
    $2[33] = step;
    $2[34] = t16;
  } else {
    t16 = $2[34];
  }
  let t17;
  if ($2[35] !== collection2 || $2[36] !== importConfig || $2[37] !== path || $2[38] !== snackbarController || $2[39] !== step) {
    t17 = step === "import_data_saving" && importConfig && /* @__PURE__ */ jsxRuntimeExports.jsx(ImportSaveInProgress, { importConfig, collection: collection2, path, onImportSuccess: (importedCollection) => {
      handleClose();
      snackbarController.open({
        type: "info",
        message: "Data imported successfully"
      });
    } });
    $2[35] = collection2;
    $2[36] = importConfig;
    $2[37] = path;
    $2[38] = snackbarController;
    $2[39] = step;
    $2[40] = t17;
  } else {
    t17 = $2[40];
  }
  let t18;
  if ($2[41] !== t13 || $2[42] !== t14 || $2[43] !== t15 || $2[44] !== t16 || $2[45] !== t17) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent$4, { className: "flex flex-col gap-4 my-4", fullHeight: t13, children: [
      t14,
      t15,
      t16,
      t17
    ] });
    $2[41] = t13;
    $2[42] = t14;
    $2[43] = t15;
    $2[44] = t16;
    $2[45] = t17;
    $2[46] = t18;
  } else {
    t18 = $2[46];
  }
  let t19;
  if ($2[47] !== step) {
    t19 = step === "mapping" && /* @__PURE__ */ jsxRuntimeExports.jsx(Button$5, { onClick: () => setStep("initial"), variant: "text", children: "Back" });
    $2[47] = step;
    $2[48] = t19;
  } else {
    t19 = $2[48];
  }
  let t20;
  if ($2[49] !== step) {
    t20 = step === "preview" && /* @__PURE__ */ jsxRuntimeExports.jsx(Button$5, { onClick: () => setStep("mapping"), variant: "text", children: "Back" });
    $2[49] = step;
    $2[50] = t20;
  } else {
    t20 = $2[50];
  }
  let t21;
  if ($2[51] === Symbol.for("react.memo_cache_sentinel")) {
    t21 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button$5, { onClick: handleClose, variant: "text", children: "Cancel" });
    $2[51] = t21;
  } else {
    t21 = $2[51];
  }
  let t22;
  if ($2[52] !== onMappingComplete || $2[53] !== step) {
    t22 = step === "mapping" && /* @__PURE__ */ jsxRuntimeExports.jsx(Button$5, { variant: "filled", onClick: onMappingComplete, children: "Next" });
    $2[52] = onMappingComplete;
    $2[53] = step;
    $2[54] = t22;
  } else {
    t22 = $2[54];
  }
  let t23;
  if ($2[55] !== onPreviewComplete || $2[56] !== step) {
    t23 = step === "preview" && /* @__PURE__ */ jsxRuntimeExports.jsx(Button$5, { variant: "filled", onClick: onPreviewComplete, children: "Save data" });
    $2[55] = onPreviewComplete;
    $2[56] = step;
    $2[57] = t23;
  } else {
    t23 = $2[57];
  }
  let t24;
  if ($2[58] !== t19 || $2[59] !== t20 || $2[60] !== t22 || $2[61] !== t23) {
    t24 = /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions$3, { children: [
      t19,
      t20,
      t21,
      t22,
      t23
    ] });
    $2[58] = t19;
    $2[59] = t20;
    $2[60] = t22;
    $2[61] = t23;
    $2[62] = t24;
  } else {
    t24 = $2[62];
  }
  let t25;
  if ($2[63] !== open || $2[64] !== t10 || $2[65] !== t11 || $2[66] !== t18 || $2[67] !== t24 || $2[68] !== t9) {
    t25 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog$4, { open, fullWidth: t9, fullHeight: t10, maxWidth: t11, children: [
      t12,
      t18,
      t24
    ] });
    $2[63] = open;
    $2[64] = t10;
    $2[65] = t11;
    $2[66] = t18;
    $2[67] = t24;
    $2[68] = t9;
    $2[69] = t25;
  } else {
    t25 = $2[69];
  }
  let t26;
  if ($2[70] !== t25 || $2[71] !== t8) {
    t26 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t8,
      t25
    ] });
    $2[70] = t25;
    $2[71] = t8;
    $2[72] = t26;
  } else {
    t26 = $2[72];
  }
  return t26;
}
function _temp2$9(acc, curr) {
  return {
    ...acc,
    ...curr
  };
}
function _temp$d(t0) {
  const [key2, property] = t0;
  return getPropertiesAndLevel(key2, property, 0);
}
const internalIDValue = "__internal_id__";
function PropertyTreeSelect(t0) {
  const $2 = c_1(17);
  const {
    selectedPropertyKey,
    properties,
    onPropertySelected,
    onIdSelected,
    propertiesAndLevel,
    isIdColumn
  } = t0;
  let t1;
  if ($2[0] !== properties || $2[1] !== selectedPropertyKey) {
    t1 = selectedPropertyKey ? getPropertyInPath2(properties, selectedPropertyKey) : null;
    $2[0] = properties;
    $2[1] = selectedPropertyKey;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  const selectedProperty = t1;
  let t2;
  if ($2[3] !== selectedProperty) {
    t2 = (selectedPropertyKey_0) => {
      if (selectedPropertyKey_0 === internalIDValue) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$4, { variant: "body2", className: "p-4", children: "Use this column as ID" });
      }
      if (!selectedPropertyKey_0 || !selectedProperty) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$4, { variant: "body2", color: "disabled", className: "p-4", children: "Do not import this property" });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PropertySelectEntry, { propertyKey: selectedPropertyKey_0, property: selectedProperty });
    };
    $2[3] = selectedProperty;
    $2[4] = t2;
  } else {
    t2 = $2[4];
  }
  const renderValue = t2;
  let t3;
  if ($2[5] !== onIdSelected || $2[6] !== onPropertySelected) {
    t3 = (value) => {
      if (value === internalIDValue) {
        onIdSelected();
        onPropertySelected(null);
      } else {
        if (value === "__do_not_import") {
          onPropertySelected(null);
        } else {
          onPropertySelected(value);
        }
      }
    };
    $2[5] = onIdSelected;
    $2[6] = onPropertySelected;
    $2[7] = t3;
  } else {
    t3 = $2[7];
  }
  const onSelectValueChange = t3;
  const t4 = isIdColumn ? internalIDValue : selectedPropertyKey ?? void 0;
  let t5;
  if ($2[8] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$2, { value: "__do_not_import", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$4, { variant: "body2", color: "disabled", className: "p-4", children: "Do not import this property" }) });
    $2[8] = t5;
  } else {
    t5 = $2[8];
  }
  let t6;
  if ($2[9] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$2, { value: internalIDValue, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$4, { variant: "body2", className: "p-4", children: "Use this column as ID" }) });
    $2[9] = t6;
  } else {
    t6 = $2[9];
  }
  let t7;
  if ($2[10] !== propertiesAndLevel) {
    t7 = propertiesAndLevel.map(_temp3$6);
    $2[10] = propertiesAndLevel;
    $2[11] = t7;
  } else {
    t7 = $2[11];
  }
  let t8;
  if ($2[12] !== onSelectValueChange || $2[13] !== renderValue || $2[14] !== t4 || $2[15] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Select$2, { value: t4, size: "large", fullWidth: true, onValueChange: onSelectValueChange, renderValue, children: [
      t5,
      t6,
      t7
    ] });
    $2[12] = onSelectValueChange;
    $2[13] = renderValue;
    $2[14] = t4;
    $2[15] = t7;
    $2[16] = t8;
  } else {
    t8 = $2[16];
  }
  return t8;
}
function _temp3$6(t0) {
  const {
    property,
    level,
    propertyKey
  } = t0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$2, { value: propertyKey, disabled: property.dataType === "map", children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertySelectEntry, { propertyKey, property, level }) }, propertyKey);
}
function getPropertiesAndLevel(key2, property, level) {
  const properties = [];
  properties.push({
    property,
    level,
    propertyKey: key2
  });
  if (property.dataType === "map" && property.properties) {
    Object.entries(property.properties).forEach(([childKey, value]) => {
      properties.push(...getPropertiesAndLevel(`${key2}.${childKey}`, value, level + 1));
    });
  }
  return properties;
}
function PropertySelectEntry(t0) {
  const $2 = c_1(21);
  const {
    propertyKey,
    property,
    level: t1
  } = t0;
  const level = t1 === void 0 ? 0 : t1;
  const {
    propertyConfigs
  } = useCustomizationController$5();
  let t2;
  if ($2[0] !== property || $2[1] !== propertyConfigs) {
    t2 = getFieldConfig$1(property, propertyConfigs);
    $2[0] = property;
    $2[1] = propertyConfigs;
    $2[2] = t2;
  } else {
    t2 = $2[2];
  }
  const widget = t2;
  let t3;
  if ($2[3] !== level) {
    t3 = new Array(level).fill(0).map(_temp4$2);
    $2[3] = level;
    $2[4] = t3;
  } else {
    t3 = $2[4];
  }
  const t4 = widget?.name;
  let t5;
  if ($2[5] !== widget) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyConfigBadge$1, { propertyConfig: widget });
    $2[5] = widget;
    $2[6] = t5;
  } else {
    t5 = $2[6];
  }
  let t6;
  if ($2[7] !== t4 || $2[8] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$5, { title: t4, children: t5 }) });
    $2[7] = t4;
    $2[8] = t5;
    $2[9] = t6;
  } else {
    t6 = $2[9];
  }
  const t7 = property.name ? property.name : "";
  let t8;
  if ($2[10] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$4, { variant: "body1", component: "span", className: "flex-grow pr-2", children: t7 });
    $2[10] = t7;
    $2[11] = t8;
  } else {
    t8 = $2[11];
  }
  let t9;
  if ($2[12] !== propertyKey) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$4, { className: " pr-2", variant: "body2", component: "span", color: "secondary", children: propertyKey });
    $2[12] = propertyKey;
    $2[13] = t9;
  } else {
    t9 = $2[13];
  }
  let t10;
  if ($2[14] !== t8 || $2[15] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col flex-grow p-2 pl-2", children: [
      t8,
      t9
    ] });
    $2[14] = t8;
    $2[15] = t9;
    $2[16] = t10;
  } else {
    t10 = $2[16];
  }
  let t11;
  if ($2[17] !== t10 || $2[18] !== t3 || $2[19] !== t6) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row w-full text-start items-center h-full", children: [
      t3,
      t6,
      t10
    ] });
    $2[17] = t10;
    $2[18] = t3;
    $2[19] = t6;
    $2[20] = t11;
  } else {
    t11 = $2[20];
  }
  return t11;
}
function _temp4$2(_2, index2) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls$5(defaultBorderMixin$2, "ml-8 border-l h-12") }, index2);
}
function ImportDataPreview(t0) {
  const $2 = c_1(12);
  const {
    importConfig,
    properties
  } = t0;
  let t1;
  if ($2[0] !== importConfig || $2[1] !== properties) {
    t1 = () => {
      const mappedData = importConfig.importData.map((d) => convertDataToEntity(d, importConfig.idColumn, importConfig.headersMapping, properties, "TEMP_PATH", importConfig.defaultValues));
      importConfig.setEntities(mappedData);
    };
    $2[0] = importConfig;
    $2[1] = properties;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  let t2;
  if ($2[3] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = [];
    $2[3] = t2;
  } else {
    t2 = $2[3];
  }
  useEffect$5(t1, t2);
  const selectionController = useSelectionController$2();
  let t3;
  if ($2[4] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$4, { variant: "subtitle2", children: "Imported data preview" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$4, { variant: "caption", children: "Entities with the same id will be overwritten" })
    ] });
    $2[4] = t3;
  } else {
    t3 = $2[4];
  }
  let t4;
  if ($2[5] !== importConfig.entities) {
    t4 = {
      data: importConfig.entities,
      dataLoading: false,
      noMoreToLoad: false
    };
    $2[5] = importConfig.entities;
    $2[6] = t4;
  } else {
    t4 = $2[6];
  }
  let t5;
  if ($2[7] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-12" });
    $2[7] = t5;
  } else {
    t5 = $2[7];
  }
  let t6;
  if ($2[8] !== properties || $2[9] !== selectionController || $2[10] !== t4) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(EntityCollectionTable$2, { title: t3, tableController: t4, enablePopupIcon: false, endAdornment: t5, filterable: false, sortable: false, selectionController, properties });
    $2[8] = properties;
    $2[9] = selectionController;
    $2[10] = t4;
    $2[11] = t6;
  } else {
    t6 = $2[11];
  }
  return t6;
}
function buildHeadersMappingFromData(objArr, properties) {
  const headersMapping = {};
  objArr.filter(Boolean).forEach((obj) => {
    Object.keys(obj).forEach((key2) => {
      const child = obj[key2];
      if (typeof child === "object" && !Array.isArray(child)) {
        const childProperty = properties?.[key2];
        const childProperties = childProperty && "properties" in childProperty ? childProperty.properties : void 0;
        const childHeadersMapping = buildHeadersMappingFromData([child], childProperties);
        Object.entries(childHeadersMapping).forEach(([subKey, mapping]) => {
          headersMapping[`${key2}.${subKey}`] = `${key2}.${mapping}`;
        });
      }
      if (!properties) {
        headersMapping[key2] = key2;
      } else if (key2 in properties) {
        headersMapping[key2] = key2;
      } else {
        const slug = slugify$1(key2);
        if (slug in properties) {
          headersMapping[key2] = slug;
        } else {
          headersMapping[key2] = key2;
        }
      }
    });
  });
  return headersMapping;
}
function useImportPlugin(props) {
  const $2 = c_1(3);
  let t0;
  let t1;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [ImportCollectionAction];
    $2[0] = t1;
  } else {
    t1 = $2[0];
  }
  let t2;
  if ($2[1] !== props) {
    t2 = {
      key: "import_export",
      collectionView: {
        CollectionActions: t1,
        collectionActionsProps: props
      }
    };
    $2[1] = props;
    $2[2] = t2;
  } else {
    t2 = $2[2];
  }
  t0 = t2;
  return t0;
}
const { getArrayValuesCount: getArrayValuesCount2, getValueInPath: getValueInPath$1, useCustomizationController: useCustomizationController$4, useFireCMSContext: useFireCMSContext2, useDataSource: useDataSource$1, useNavigationController: useNavigationController$4, resolveCollection: resolveCollection$2, getDefaultValuesFor: getDefaultValuesFor2 } = await importShared("@firecms/core");
const React$5 = await importShared("react");
const { useCallback: useCallback$4 } = React$5;
const { Tooltip: Tooltip$4, IconButton: IconButton$4, DownloadIcon: DownloadIcon2, Dialog: Dialog$3, DialogTitle: DialogTitle$3, DialogContent: DialogContent$3, cls: cls$4, BooleanSwitchWithLabel: BooleanSwitchWithLabel$2, DialogActions: DialogActions$2, Button: Button$4, Alert: Alert$3, CircularProgress: CircularProgress$3 } = await importShared("@firecms/ui");
function downloadEntitiesExport({
  data,
  additionalData,
  properties,
  propertiesOrder,
  name,
  flattenArrays,
  additionalHeaders,
  exportType,
  dateExportType
}) {
  console.debug("Downloading export", {
    dataLength: data.length,
    properties,
    exportType,
    dateExportType
  });
  if (exportType === "csv") {
    const arrayValuesCount = flattenArrays ? getArrayValuesCount2(data.map((d) => d.values)) : {};
    const headers = getExportHeaders(properties, propertiesOrder, additionalHeaders, arrayValuesCount);
    const exportableData = getEntityCSVExportableData(data, additionalData, properties, headers, dateExportType);
    const headersData = entryToCSVRow(headers.map((h2) => h2.label));
    const csvData = exportableData.map((entry) => entryToCSVRow(entry));
    downloadBlob([headersData, ...csvData], `${name}.csv`, "text/csv");
  } else {
    const exportableData = getEntityJsonExportableData(data, additionalData, properties, dateExportType);
    const json = JSON.stringify(exportableData, null, 2);
    downloadBlob([json], `${name}.json`, "application/json");
  }
}
function getEntityCSVExportableData(data, additionalData, properties, headers, dateExportType) {
  const mergedData = data.map((e) => ({
    id: e.id,
    ...processValuesForExport(e.values, properties, "csv", dateExportType)
  }));
  if (additionalData) {
    additionalData.forEach((additional, index2) => {
      mergedData[index2] = {
        ...mergedData[index2],
        ...additional
      };
    });
  }
  return mergedData && mergedData.map((entry) => {
    return headers.map((header) => getValueInPath$1(entry, header.key));
  });
}
function getEntityJsonExportableData(data, additionalData, properties, dateExportType) {
  const mergedData = data.map((e) => ({
    id: e.id,
    ...processValuesForExport(e.values, properties, "json", dateExportType)
  }));
  if (additionalData) {
    additionalData.forEach((additional, index2) => {
      mergedData[index2] = {
        ...mergedData[index2],
        ...additional
      };
    });
  }
  return mergedData;
}
function getExportHeaders(properties, propertiesOrder, additionalHeaders, arrayValuesCount) {
  const headers = [{
    label: "id",
    key: "id"
  }, ...(propertiesOrder ?? Object.keys(properties)).flatMap((childKey) => {
    const property = properties[childKey];
    if (!property) {
      console.warn("Property not found", childKey, properties);
      return [];
    }
    if (arrayValuesCount && arrayValuesCount[childKey] > 1) {
      return Array.from({
        length: arrayValuesCount[childKey]
      }, (_2, i) => getHeaders(property, `${childKey}[${i}]`, "")).flat();
    } else {
      return getHeaders(property, childKey, "");
    }
  })];
  if (additionalHeaders) {
    headers.push(...additionalHeaders.map((h2) => ({
      label: h2,
      key: h2
    })));
  }
  return headers;
}
function getHeaders(property, propertyKey, prefix = "") {
  const currentKey = prefix ? `${prefix}.${propertyKey}` : propertyKey;
  if (property.dataType === "map" && property.properties) {
    return Object.entries(property.properties).map(([childKey, p]) => getHeaders(p, childKey, currentKey)).flat();
  } else {
    return [{
      label: currentKey,
      key: currentKey
    }];
  }
}
function processValueForExport(inputValue, property, exportType, dateExportType) {
  let value;
  if (property.dataType === "map" && property.properties) {
    value = processValuesForExport(inputValue, property.properties, exportType, dateExportType);
  } else if (property.dataType === "array") {
    if (property.of && Array.isArray(inputValue)) {
      if (Array.isArray(property.of)) {
        value = property.of.map((p, i) => processValueForExport(inputValue[i], p, exportType, dateExportType));
      } else if (property.of.dataType === "map") {
        value = exportType === "csv" ? inputValue.map((e) => JSON.stringify(e)) : inputValue.map((e) => processValueForExport(e, property.of, exportType, dateExportType));
      } else {
        value = inputValue.map((e) => processValueForExport(e, property.of, exportType, dateExportType));
      }
    } else {
      value = inputValue;
    }
  } else if (property.dataType === "reference" && inputValue && inputValue.isEntityReference && inputValue.isEntityReference()) {
    const ref2 = inputValue ? inputValue : void 0;
    value = ref2 ? ref2.pathWithId : null;
  } else if (property.dataType === "date" && inputValue instanceof Date) {
    value = inputValue ? dateExportType === "timestamp" ? inputValue.getTime() : inputValue.toISOString() : null;
  } else {
    value = inputValue;
  }
  return value;
}
function processValuesForExport(inputValues, properties, exportType, dateExportType) {
  const updatedValues = Object.entries(properties).map(([key2, property]) => {
    const inputValue = inputValues && inputValues[key2];
    const updatedValue = processValueForExport(inputValue, property, exportType, dateExportType);
    if (updatedValue === void 0) return {};
    return {
      [key2]: updatedValue
    };
  }).reduce((a, b) => ({
    ...a,
    ...b
  }), {});
  return {
    ...inputValues,
    ...updatedValues
  };
}
function entryToCSVRow(entry) {
  return entry.map((v2) => {
    if (v2 === null || v2 === void 0) return "";
    if (Array.isArray(v2)) return '"' + JSON.stringify(v2).replaceAll('"', '\\"') + '"';
    const s = String(v2);
    return '"' + s.replaceAll('"', '""') + '"';
  }).join(",") + "\r\n";
}
function downloadBlob(content, filename, contentType) {
  const blob = new Blob(content, {
    type: contentType
  });
  const url = URL.createObjectURL(blob);
  const pom = document.createElement("a");
  pom.href = url;
  pom.setAttribute("download", filename);
  pom.click();
}
function BasicExportAction({
  data,
  properties,
  propertiesOrder
}) {
  const dateRef = React$5.useRef(/* @__PURE__ */ new Date());
  const [flattenArrays, setFlattenArrays] = React$5.useState(true);
  const [exportType, setExportType] = React$5.useState("csv");
  const [dateExportType, setDateExportType] = React$5.useState("string");
  const [open, setOpen] = React$5.useState(false);
  const handleClickOpen = useCallback$4(() => {
    setOpen(true);
  }, [setOpen]);
  const handleClose = useCallback$4(() => {
    setOpen(false);
  }, [setOpen]);
  const onOkClicked = useCallback$4(() => {
    downloadEntitiesExport({
      data,
      additionalData: [],
      properties,
      propertiesOrder,
      name: "export.csv",
      flattenArrays,
      additionalHeaders: [],
      exportType,
      dateExportType
    });
    handleClose();
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$4, { title: "Export", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$4, { color: "primary", onClick: handleClickOpen, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadIcon2, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog$3, { open, onOpenChange: setOpen, maxWidth: "xl", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle$3, { variant: "h6", children: "Export data" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent$3, { className: "flex flex-col gap-4 my-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Download the the content of this table as a CSV" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 flex flex-col", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("input", { id: "radio-csv", type: "radio", value: "csv", name: "exportType", checked: exportType === "csv", onChange: () => setExportType("csv"), className: cls$4("w-4 bg-surface-100 border-surface-300 dark:bg-surface-700 dark:border-surface-600") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "radio-csv", className: "p-2 text-sm font-medium text-surface-900 dark:text-surface-accent-300", children: "CSV" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("input", { id: "radio-json", type: "radio", value: "json", name: "exportType", checked: exportType === "json", onChange: () => setExportType("json"), className: cls$4("w-4 bg-surface-100 border-surface-300 dark:bg-surface-700 dark:border-surface-600") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "radio-json", className: "p-2 text-sm font-medium text-surface-900 dark:text-surface-accent-300", children: "JSON" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 flex flex-col", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("input", { id: "radio-timestamp", type: "radio", value: "timestamp", name: "dateExportType", checked: dateExportType === "timestamp", onChange: () => setDateExportType("timestamp"), className: cls$4("w-4 bg-surface-100 border-surface-300 dark:bg-surface-700 dark:border-surface-600") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: "radio-timestamp", className: "p-2 text-sm font-medium text-surface-900 dark:text-surface-accent-300", children: [
                "Dates as timestamps (",
                dateRef.current.getTime(),
                ")"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("input", { id: "radio-string", type: "radio", value: "string", name: "dateExportType", checked: dateExportType === "string", onChange: () => setDateExportType("string"), className: cls$4("w-4 bg-surface-100 border-surface-300 dark:bg-surface-700 dark:border-surface-600") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: "radio-string", className: "p-2 text-sm font-medium text-surface-900 dark:text-surface-accent-300", children: [
                "Dates as strings (",
                dateRef.current.toISOString(),
                ")"
              ] })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanSwitchWithLabel$2, { size: "small", disabled: exportType !== "csv", value: flattenArrays, onValueChange: setFlattenArrays, label: "Flatten arrays" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions$2, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button$4, { onClick: handleClose, variant: "text", children: "Cancel" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button$4, { variant: "filled", onClick: onOkClicked, children: "Download" })
      ] })
    ] })
  ] });
}
const DOCS_LIMIT$1 = 500;
function ExportCollectionAction({
  collection: inputCollection,
  path: inputPath,
  collectionEntitiesCount,
  onAnalyticsEvent,
  exportAllowed,
  notAllowedView
}) {
  const customizationController = useCustomizationController$4();
  const exportConfig = typeof inputCollection.exportable === "object" ? inputCollection.exportable : void 0;
  const dateRef = React$5.useRef(/* @__PURE__ */ new Date());
  const [includeUndefinedValues, setIncludeUndefinedValues] = React$5.useState(false);
  const [flattenArrays, setFlattenArrays] = React$5.useState(true);
  const [exportType, setExportType] = React$5.useState("csv");
  const [dateExportType, setDateExportType] = React$5.useState("string");
  const context = useFireCMSContext2();
  const dataSource = useDataSource$1();
  const navigationController = useNavigationController$4();
  const path = navigationController.resolveAliasesFrom(inputPath);
  const canExport = !exportAllowed || exportAllowed({
    collectionEntitiesCount,
    path,
    collection: inputCollection
  });
  const collection2 = React$5.useMemo(() => resolveCollection$2({
    collection: inputCollection,
    path,
    propertyConfigs: customizationController.propertyConfigs
  }), [inputCollection, path]);
  const [dataLoading, setDataLoading] = React$5.useState(false);
  const [dataLoadingError, setDataLoadingError] = React$5.useState();
  const [open, setOpen] = React$5.useState(false);
  const handleClickOpen = useCallback$4(() => {
    setOpen(true);
  }, [setOpen]);
  const handleClose = useCallback$4(() => {
    setOpen(false);
  }, [setOpen]);
  const fetchAdditionalFields = useCallback$4(async (entities) => {
    const additionalExportFields = exportConfig?.additionalFields;
    const additionalFields = collection2.additionalFields;
    const resolvedExportColumnsValues = additionalExportFields ? await Promise.all(entities.map(async (entity) => {
      return (await Promise.all(additionalExportFields.map(async (column2) => {
        return {
          [column2.key]: await column2.builder({
            entity,
            context
          })
        };
      }))).reduce((a, b) => ({
        ...a,
        ...b
      }), {});
    })) : [];
    const resolvedColumnsValues = additionalFields ? await Promise.all(entities.map(async (entity_0) => {
      return (await Promise.all(additionalFields.map(async (field) => {
        if (!field.value) return {};
        return {
          [field.key]: await field.value({
            entity: entity_0,
            context
          })
        };
      }))).reduce((a_0, b_0) => ({
        ...a_0,
        ...b_0
      }), {});
    })) : [];
    return [...resolvedExportColumnsValues, ...resolvedColumnsValues];
  }, [exportConfig?.additionalFields]);
  const doDownload = useCallback$4(async (collection_0, exportConfig_0) => {
    onAnalyticsEvent?.("export_collection", {
      collection: collection_0.path
    });
    setDataLoading(true);
    dataSource.fetchCollection({
      path,
      collection: collection_0
    }).then(async (data) => {
      setDataLoadingError(void 0);
      const additionalData = await fetchAdditionalFields(data);
      const additionalHeaders = [...exportConfig_0?.additionalFields?.map((column_0) => column_0.key) ?? [], ...collection_0.additionalFields?.map((field_0) => field_0.key) ?? []];
      const dataWithDefaults = includeUndefinedValues ? data.map((entity_1) => {
        const defaultValues = getDefaultValuesFor2(collection_0.properties);
        return {
          ...entity_1,
          values: {
            ...defaultValues,
            ...entity_1.values
          }
        };
      }) : data;
      downloadEntitiesExport({
        data: dataWithDefaults,
        additionalData,
        properties: collection_0.properties,
        propertiesOrder: collection_0.propertiesOrder,
        name: collection_0.name,
        flattenArrays,
        additionalHeaders,
        exportType,
        dateExportType
      });
      onAnalyticsEvent?.("export_collection_success", {
        collection: collection_0.path
      });
    }).catch((e) => {
      console.error("Error loading export data", e);
      setDataLoadingError(e);
    }).finally(() => setDataLoading(false));
  }, [onAnalyticsEvent, dataSource, path, fetchAdditionalFields, includeUndefinedValues, flattenArrays, exportType, dateExportType]);
  const onOkClicked = useCallback$4(() => {
    doDownload(collection2, exportConfig);
    handleClose();
  }, [doDownload, collection2, exportConfig, handleClose]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$4, { title: "Export", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$4, { color: "primary", onClick: handleClickOpen, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadIcon2, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog$3, { open, onOpenChange: setOpen, maxWidth: "xl", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle$3, { variant: "h6", children: "Export data" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent$3, { className: "flex flex-col gap-4 my-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Download the the content of this table as a CSV" }),
        collectionEntitiesCount > DOCS_LIMIT$1 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert$3, { color: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          "This collections has a large number of documents (",
          collectionEntitiesCount,
          ")."
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 flex flex-col", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("input", { id: "radio-csv", type: "radio", value: "csv", name: "exportType", checked: exportType === "csv", onChange: () => setExportType("csv"), className: cls$4("w-4 bg-surface-100 border-surface-300 dark:bg-surface-700 dark:border-surface-600") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "radio-csv", className: "p-2 text-sm font-medium text-surface-900 dark:text-surface-accent-300", children: "CSV" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("input", { id: "radio-json", type: "radio", value: "json", name: "exportType", checked: exportType === "json", onChange: () => setExportType("json"), className: cls$4("w-4 bg-surface-100 border-surface-300 dark:bg-surface-700 dark:border-surface-600") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "radio-json", className: "p-2 text-sm font-medium text-surface-900 dark:text-surface-accent-300", children: "JSON" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 flex flex-col", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("input", { id: "radio-timestamp", type: "radio", value: "timestamp", name: "dateExportType", checked: dateExportType === "timestamp", onChange: () => setDateExportType("timestamp"), className: cls$4("w-4 bg-surface-100 border-surface-300 dark:bg-surface-700 dark:border-surface-600") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: "radio-timestamp", className: "p-2 text-sm font-medium text-surface-900 dark:text-surface-accent-300", children: [
                "Dates as timestamps (",
                dateRef.current.getTime(),
                ")"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("input", { id: "radio-string", type: "radio", value: "string", name: "dateExportType", checked: dateExportType === "string", onChange: () => setDateExportType("string"), className: cls$4("w-4 bg-surface-100 border-surface-300 dark:bg-surface-700 dark:border-surface-600") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: "radio-string", className: "p-2 text-sm font-medium text-surface-900 dark:text-surface-accent-300", children: [
                "Dates as strings (",
                dateRef.current.toISOString(),
                ")"
              ] })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanSwitchWithLabel$2, { size: "small", disabled: exportType !== "csv", value: flattenArrays, onValueChange: setFlattenArrays, label: "Flatten arrays" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanSwitchWithLabel$2, { size: "small", value: includeUndefinedValues, onValueChange: setIncludeUndefinedValues, label: "Include undefined values" }),
        !canExport && notAllowedView
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions$2, { children: [
        dataLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress$3, { size: "small" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button$4, { onClick: handleClose, variant: "text", children: "Cancel" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button$4, { variant: "filled", onClick: onOkClicked, disabled: dataLoading || !canExport, children: "Download" })
      ] })
    ] })
  ] });
}
function useExportPlugin(props) {
  const $2 = c_1(3);
  let t0;
  let t1;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [ExportCollectionAction];
    $2[0] = t1;
  } else {
    t1 = $2[0];
  }
  let t2;
  if ($2[1] !== props) {
    t2 = {
      key: "export",
      collectionView: {
        CollectionActions: t1,
        collectionActionsProps: props
      }
    };
    $2[1] = props;
    $2[2] = t2;
  } else {
    t2 = $2[2];
  }
  t0 = t2;
  return t0;
}
await importShared("react");
const { FieldCaption: FieldCaption2, SearchIconsView: SearchIconsView2, toSnakeCase: toSnakeCase2, singular: singular$1, IconForView: IconForView$1, ArrayContainer: ArrayContainer2, serializeRegExp: serializeRegExp2, useSnackbarController: useSnackbarController$2, resolveEnumValues: resolveEnumValues2, isPropertyBuilder: isPropertyBuilder$1, useCustomizationController: useCustomizationController$3, getFieldConfig: getFieldConfig2, ErrorBoundary: ErrorBoundary2, PropertyConfigBadge: PropertyConfigBadge2, unslugify: unslugify$2, useNavigationController: useNavigationController$3, mergeDeep: mergeDeep2, DEFAULT_FIELD_CONFIGS: DEFAULT_FIELD_CONFIGS2, getFieldId: getFieldId$1, isValidRegExp: isValidRegExp2, isEmptyObject: isEmptyObject2, ConfirmationDialog: ConfirmationDialog2, useLargeLayout: useLargeLayout2, makePropertiesEditable: makePropertiesEditable2, resolveEntityView: resolveEntityView2, useSelectionController: useSelectionController$1, CircularProgressCenter: CircularProgressCenter$2, EntityCollectionTable: EntityCollectionTable$1, slugify: slugify2, useAuthController: useAuthController$2, randomString: randomString$1, removeUndefined: removeUndefined$1, ErrorView: ErrorView$1, removeInitialAndTrailingSlashes: removeInitialAndTrailingSlashes$1, getDefaultPropertiesOrder: getDefaultPropertiesOrder2, joinCollectionLists: joinCollectionLists2 } = await importShared("@firecms/core");
const React$4 = await importShared("react");
const React__default = await importShared("react");
const { useContext: useContext$3, useState: useState$3, useEffect: useEffect$4, useMemo: useMemo$4, useRef: useRef$3, useDeferredValue: useDeferredValue$2 } = React__default;
const { useAutoComplete: useAutoComplete$1, Chip: Chip$1, Typography: Typography$3, cls: cls$3, TextField: TextField$3, Autocomplete: Autocomplete$1, AutocompleteItem: AutocompleteItem$1, SelectItem: SelectItem$1, Container: Container$1, Tooltip: Tooltip$3, IconButton: IconButton$3, DebouncedTextField: DebouncedTextField2, SettingsIcon: SettingsIcon2, CloseIcon: CloseIcon$3, Select: Select$1, BooleanSwitchWithLabel: BooleanSwitchWithLabel$1, ExpandablePanel: ExpandablePanel2, Dialog: Dialog$2, Badge: Badge2, AutorenewIcon: AutorenewIcon2, ListIcon: ListIcon2, Button: Button$3, CircularProgress: CircularProgress$2, Paper: Paper$2, DialogTitle: DialogTitle$2, DialogContent: DialogContent$2, DialogActions: DialogActions$1, RuleIcon: RuleIcon2, MultiSelectItem: MultiSelectItem2, CloudUploadIcon: CloudUploadIcon2, MultiSelect: MultiSelect2, cardMixin: cardMixin2, cardClickableMixin: cardClickableMixin2, cardSelectedMixin: cardSelectedMixin2, FunctionsIcon: FunctionsIcon2, DoNotDisturbOnIcon: DoNotDisturbOnIcon2, defaultBorderMixin: defaultBorderMixin$1, RemoveIcon: RemoveIcon2, DragHandleIcon: DragHandleIcon2, AddIcon: AddIcon$1, SelectGroup: SelectGroup2, DeleteIcon: DeleteIcon2, InfoLabel: InfoLabel2, fieldBackgroundMixin: fieldBackgroundMixin$1, fieldBackgroundDisabledMixin: fieldBackgroundDisabledMixin$1, fieldBackgroundHoverMixin: fieldBackgroundHoverMixin$1, WarningIcon: WarningIcon2, Card: Card$2, ContentCopyIcon: ContentCopyIcon$1, CodeIcon: CodeIcon2, Table: Table2, TableBody: TableBody2, TableRow: TableRow2, TableCell: TableCell2, Alert: Alert$2, Icon: Icon2, coolIconKeys: coolIconKeys2, Tabs: Tabs2, Tab: Tab2, ArrowBackIcon: ArrowBackIcon2, LoadingButton: LoadingButton$1, CheckIcon: CheckIcon$1, Menu: Menu$3, MoreVertIcon: MoreVertIcon$1, MenuItem: MenuItem$3, UndoIcon: UndoIcon2, SaveIcon: SaveIcon2 } = await importShared("@firecms/ui");
const YupSchema = create$1().shape({
  id: create$2().required("Required"),
  name: create$2().required("Required"),
  path: create$2().required("Required")
});
const useCollectionEditorController = () => {
  return useContext$3(CollectionEditorContext);
};
function CollectionDetailsForm(t0) {
  const $2 = c_1(168);
  const {
    isNewCollection,
    reservedGroups,
    groups,
    parentCollection
  } = t0;
  const groupRef = React__default.useRef(null);
  const {
    values,
    setFieldValue,
    handleChange,
    touched,
    errors,
    setFieldTouched,
    isSubmitting,
    submitCount
  } = useFormex();
  const collectionEditor = useCollectionEditorController();
  const [iconDialogOpen, setIconDialogOpen] = useState$3(false);
  const [advancedPanelExpanded, setAdvancedPanelExpanded] = useState$3(false);
  let t1;
  if ($2[0] !== setFieldValue) {
    t1 = (databaseId) => {
      setFieldValue("databaseId", databaseId ?? void 0);
    };
    $2[0] = setFieldValue;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  const updateDatabaseId = t1;
  let t2;
  if ($2[2] !== isNewCollection || $2[3] !== setFieldValue || $2[4] !== touched) {
    t2 = (name) => {
      setFieldValue("name", name);
      const pathTouched = getIn(touched, "path");
      if (!pathTouched && isNewCollection && name) {
        setFieldValue("path", toSnakeCase2(name));
      }
      const idTouched = getIn(touched, "id");
      if (!idTouched && isNewCollection && name) {
        setFieldValue("id", toSnakeCase2(name));
      }
      const singularNameTouched = getIn(touched, "singularName");
      if (!singularNameTouched && isNewCollection && name) {
        setFieldValue("singularName", singular$1(name));
      }
    };
    $2[2] = isNewCollection;
    $2[3] = setFieldValue;
    $2[4] = touched;
    $2[5] = t2;
  } else {
    t2 = $2[5];
  }
  const updateName = t2;
  let t3;
  let t4;
  if ($2[6] !== errors.id) {
    t3 = () => {
      if (errors.id) {
        setAdvancedPanelExpanded(true);
      }
    };
    t4 = [errors.id];
    $2[6] = errors.id;
    $2[7] = t3;
    $2[8] = t4;
  } else {
    t3 = $2[7];
    t4 = $2[8];
  }
  useEffect$4(t3, t4);
  const DatabaseField = collectionEditor.components?.DatabaseField ?? DefaultDatabaseField;
  let t5;
  if ($2[9] !== values) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(IconForView$1, { collectionOrView: values });
    $2[9] = values;
    $2[10] = t5;
  } else {
    t5 = $2[10];
  }
  const collectionIcon = t5;
  const groupOptions = groups?.filter((group) => !reservedGroups?.includes(group));
  let t6;
  if ($2[11] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = {
      ref: groupRef
    };
    $2[11] = t6;
  } else {
    t6 = $2[11];
  }
  const {
    autoCompleteOpen,
    setAutoCompleteOpen
  } = useAutoComplete$1(t6);
  const isSubcollection = !!parentCollection;
  let customIdValue;
  if (typeof values.customId === "object") {
    customIdValue = "code_defined";
  } else {
    if (values.customId === true) {
      customIdValue = "true";
    } else {
      if (values.customId === false) {
        customIdValue = "false";
      } else {
        if (values.customId === "optional") {
          customIdValue = "optional";
        }
      }
    }
  }
  const showErrors = submitCount > 0;
  const t7 = "overflow-auto my-auto";
  const T0 = Container$1;
  const t8 = "4xl";
  const t9 = "flex flex-col gap-4 p-8 m-auto";
  const t10 = !isNewCollection ? "h5" : "h4";
  const t11 = isNewCollection ? "New collection" : `${values?.name} collection`;
  let t12;
  if ($2[12] !== t10 || $2[13] !== t11) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: t10, className: "flex-grow", children: t11 });
    $2[12] = t10;
    $2[13] = t11;
    $2[14] = t12;
  } else {
    t12 = $2[14];
  }
  let t13;
  if ($2[15] !== DatabaseField || $2[16] !== updateDatabaseId || $2[17] !== values.databaseId) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsx(DatabaseField, { databaseId: values.databaseId, onDatabaseIdUpdate: updateDatabaseId });
    $2[15] = DatabaseField;
    $2[16] = updateDatabaseId;
    $2[17] = values.databaseId;
    $2[18] = t13;
  } else {
    t13 = $2[18];
  }
  let t14;
  if ($2[19] === Symbol.for("react.memo_cache_sentinel")) {
    t14 = () => setIconDialogOpen(true);
    $2[19] = t14;
  } else {
    t14 = $2[19];
  }
  let t15;
  if ($2[20] !== collectionIcon) {
    t15 = /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$3, { title: "Change icon", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$3, { shape: "square", onClick: t14, children: collectionIcon }) });
    $2[20] = collectionIcon;
    $2[21] = t15;
  } else {
    t15 = $2[21];
  }
  let t16;
  if ($2[22] !== t12 || $2[23] !== t13 || $2[24] !== t15) {
    t16 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row gap-2 py-2 pt-3 items-center", children: [
      t12,
      t13,
      t15
    ] });
    $2[22] = t12;
    $2[23] = t13;
    $2[24] = t15;
    $2[25] = t16;
  } else {
    t16 = $2[25];
  }
  let t17;
  if ($2[26] !== parentCollection) {
    t17 = parentCollection && /* @__PURE__ */ jsxRuntimeExports.jsx(Chip$1, { colorScheme: "tealDarker", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography$3, { variant: "caption", children: [
      "This is a subcollection of ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: parentCollection.name })
    ] }) });
    $2[26] = parentCollection;
    $2[27] = t17;
  } else {
    t17 = $2[27];
  }
  let t18;
  if ($2[28] !== t16 || $2[29] !== t17) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      t16,
      t17
    ] });
    $2[28] = t16;
    $2[29] = t17;
    $2[30] = t18;
  } else {
    t18 = $2[30];
  }
  const t19 = "grid grid-cols-12 gap-4";
  const t20 = values.name ?? "";
  let t21;
  if ($2[31] !== updateName) {
    t21 = (e) => updateName(e.target.value);
    $2[31] = updateName;
    $2[32] = t21;
  } else {
    t21 = $2[32];
  }
  const t22 = showErrors && Boolean(errors.name);
  let t23;
  if ($2[33] !== t20 || $2[34] !== t21 || $2[35] !== t22) {
    t23 = /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$3, { value: t20, onChange: t21, label: "Name", autoFocus: true, required: true, error: t22 });
    $2[33] = t20;
    $2[34] = t21;
    $2[35] = t22;
    $2[36] = t23;
  } else {
    t23 = $2[36];
  }
  const t24 = touched.name && Boolean(errors.name);
  const t25 = touched.name && Boolean(errors.name) ? errors.name : "Name of this collection, usually a plural name (e.g. Products)";
  let t26;
  if ($2[37] !== t24 || $2[38] !== t25) {
    t26 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption2, { error: t24, children: t25 });
    $2[37] = t24;
    $2[38] = t25;
    $2[39] = t26;
  } else {
    t26 = $2[39];
  }
  let t27;
  if ($2[40] !== t23 || $2[41] !== t26) {
    t27 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
      t23,
      t26
    ] });
    $2[40] = t23;
    $2[41] = t26;
    $2[42] = t27;
  } else {
    t27 = $2[42];
  }
  const t28 = isSubcollection ? "" : "sm:col-span-8";
  let t29;
  if ($2[43] !== t28) {
    t29 = cls$3("col-span-12 ", t28);
    $2[43] = t28;
    $2[44] = t29;
  } else {
    t29 = $2[44];
  }
  const t30 = !isNewCollection;
  const t31 = showErrors && Boolean(errors.path);
  let t32;
  if ($2[45] !== t30 || $2[46] !== t31) {
    t32 = /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: "path", as: DebouncedTextField2, label: "Path", disabled: t30, required: true, error: t31 });
    $2[45] = t30;
    $2[46] = t31;
    $2[47] = t32;
  } else {
    t32 = $2[47];
  }
  const t33 = touched.path && Boolean(errors.path);
  const t34 = touched.path && Boolean(errors.path) ? errors.path : isSubcollection ? "Relative path to the parent (no need to include the parent path)" : "Path that this collection is stored in, in the database";
  let t35;
  if ($2[48] !== t33 || $2[49] !== t34) {
    t35 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption2, { error: t33, children: t34 });
    $2[48] = t33;
    $2[49] = t34;
    $2[50] = t35;
  } else {
    t35 = $2[50];
  }
  let t36;
  if ($2[51] !== t29 || $2[52] !== t32 || $2[53] !== t35) {
    t36 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t29, children: [
      t32,
      t35
    ] });
    $2[51] = t29;
    $2[52] = t32;
    $2[53] = t35;
    $2[54] = t36;
  } else {
    t36 = $2[54];
  }
  const t37 = !isSubcollection && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12 sm:col-span-4 relative", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$3, { error: showErrors && Boolean(errors.group), disabled: isSubmitting, value: values.group ?? "", autoComplete: "off", onChange: (event) => setFieldValue("group", event.target.value), name: "group", inputRef: groupRef, label: "Group" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Autocomplete$1, { open: autoCompleteOpen && (groupOptions ?? []).length > 0, setOpen: setAutoCompleteOpen, children: groupOptions?.map((group_0, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteItem$1, { onClick: () => {
      setAutoCompleteOpen(false);
      setFieldValue("group", group_0 ?? null);
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow", children: group_0 }) }, index2 + "_" + group_0)) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption2, { children: showErrors && Boolean(errors.group) ? errors.group : "Group in the home page" })
  ] });
  let t38;
  if ($2[55] === Symbol.for("react.memo_cache_sentinel")) {
    t38 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row text-surface-500", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsIcon2, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "subtitle2", className: "ml-2", children: "Advanced" })
    ] });
    $2[55] = t38;
  } else {
    t38 = $2[55];
  }
  const t39 = !isNewCollection;
  const t40 = showErrors && Boolean(errors.id);
  let t41;
  if ($2[56] !== t39 || $2[57] !== t40) {
    t41 = /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: "id", as: DebouncedTextField2, disabled: t39, label: "Collection id", error: t40 });
    $2[56] = t39;
    $2[57] = t40;
    $2[58] = t41;
  } else {
    t41 = $2[58];
  }
  const t42 = touched.id && Boolean(errors.id);
  const t43 = touched.id && Boolean(errors.id) ? errors.id : "This id identifies this collection. Typically the same as the path.";
  let t44;
  if ($2[59] !== t42 || $2[60] !== t43) {
    t44 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption2, { error: t42, children: t43 });
    $2[59] = t42;
    $2[60] = t43;
    $2[61] = t44;
  } else {
    t44 = $2[61];
  }
  let t45;
  if ($2[62] !== t41 || $2[63] !== t44) {
    t45 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
      t41,
      t44
    ] });
    $2[62] = t41;
    $2[63] = t44;
    $2[64] = t45;
  } else {
    t45 = $2[64];
  }
  const t46 = showErrors && Boolean(errors.singularName);
  let t47;
  if ($2[65] !== handleChange || $2[66] !== setFieldTouched) {
    t47 = (e_0) => {
      setFieldTouched("singularName", true);
      return handleChange(e_0);
    };
    $2[65] = handleChange;
    $2[66] = setFieldTouched;
    $2[67] = t47;
  } else {
    t47 = $2[67];
  }
  const t48 = values.singularName ?? "";
  let t49;
  if ($2[68] !== t46 || $2[69] !== t47 || $2[70] !== t48) {
    t49 = /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$3, { error: t46, name: "singularName", "aria-describedby": "singularName-helper", onChange: t47, value: t48, label: "Singular name" });
    $2[68] = t46;
    $2[69] = t47;
    $2[70] = t48;
    $2[71] = t49;
  } else {
    t49 = $2[71];
  }
  const t50 = showErrors && Boolean(errors.singularName);
  const t51 = showErrors && Boolean(errors.singularName) ? errors.singularName : "Optionally define a singular name for your entities";
  let t52;
  if ($2[72] !== t50 || $2[73] !== t51) {
    t52 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption2, { error: t50, children: t51 });
    $2[72] = t50;
    $2[73] = t51;
    $2[74] = t52;
  } else {
    t52 = $2[74];
  }
  let t53;
  if ($2[75] !== t49 || $2[76] !== t52) {
    t53 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
      t49,
      t52
    ] });
    $2[75] = t49;
    $2[76] = t52;
    $2[77] = t53;
  } else {
    t53 = $2[77];
  }
  const t54 = showErrors && Boolean(errors.sideDialogWidth);
  let t55;
  if ($2[78] !== setFieldTouched || $2[79] !== setFieldValue) {
    t55 = (e_1) => {
      setFieldTouched("sideDialogWidth", true);
      const value = e_1.target.value;
      if (!value) {
        setFieldValue("sideDialogWidth", null);
      } else {
        if (!isNaN(Number(value))) {
          setFieldValue("sideDialogWidth", Number(value));
        }
      }
    };
    $2[78] = setFieldTouched;
    $2[79] = setFieldValue;
    $2[80] = t55;
  } else {
    t55 = $2[80];
  }
  let t56;
  if ($2[81] !== setFieldValue) {
    t56 = () => {
      setFieldValue("sideDialogWidth", null);
    };
    $2[81] = setFieldValue;
    $2[82] = t56;
  } else {
    t56 = $2[82];
  }
  const t57 = !values.sideDialogWidth;
  let t58;
  if ($2[83] === Symbol.for("react.memo_cache_sentinel")) {
    t58 = /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon$3, { size: "small" });
    $2[83] = t58;
  } else {
    t58 = $2[83];
  }
  let t59;
  if ($2[84] !== t56 || $2[85] !== t57) {
    t59 = /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$3, { size: "small", onClick: t56, disabled: t57, children: t58 });
    $2[84] = t56;
    $2[85] = t57;
    $2[86] = t59;
  } else {
    t59 = $2[86];
  }
  const t60 = values.sideDialogWidth ?? "";
  let t61;
  if ($2[87] !== t54 || $2[88] !== t55 || $2[89] !== t59 || $2[90] !== t60) {
    t61 = /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$3, { error: t54, name: "sideDialogWidth", type: "number", "aria-describedby": "sideDialogWidth-helper", onChange: t55, endAdornment: t59, value: t60, label: "Side dialog width" });
    $2[87] = t54;
    $2[88] = t55;
    $2[89] = t59;
    $2[90] = t60;
    $2[91] = t61;
  } else {
    t61 = $2[91];
  }
  const t62 = showErrors && Boolean(errors.singularName);
  const t63 = showErrors && Boolean(errors.singularName) ? errors.singularName : "Optionally define the width (in pixels) of entities side dialog. Default is 768px";
  let t64;
  if ($2[92] !== t62 || $2[93] !== t63) {
    t64 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption2, { error: t62, children: t63 });
    $2[92] = t62;
    $2[93] = t63;
    $2[94] = t64;
  } else {
    t64 = $2[94];
  }
  let t65;
  if ($2[95] !== t61 || $2[96] !== t64) {
    t65 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
      t61,
      t64
    ] });
    $2[95] = t61;
    $2[96] = t64;
    $2[97] = t65;
  } else {
    t65 = $2[97];
  }
  const t66 = showErrors && Boolean(errors.description);
  const t67 = values.description ?? "";
  let t68;
  if ($2[98] !== handleChange || $2[99] !== t66 || $2[100] !== t67) {
    t68 = /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$3, { error: t66, name: "description", value: t67, onChange: handleChange, multiline: true, rows: 2, "aria-describedby": "description-helper-text", label: "Description" });
    $2[98] = handleChange;
    $2[99] = t66;
    $2[100] = t67;
    $2[101] = t68;
  } else {
    t68 = $2[101];
  }
  const t69 = showErrors && Boolean(errors.description);
  const t70 = showErrors && Boolean(errors.description) ? errors.description : "Description of the collection, you can use markdown";
  let t71;
  if ($2[102] !== t69 || $2[103] !== t70) {
    t71 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption2, { error: t69, children: t70 });
    $2[102] = t69;
    $2[103] = t70;
    $2[104] = t71;
  } else {
    t71 = $2[104];
  }
  let t72;
  if ($2[105] !== t68 || $2[106] !== t71) {
    t72 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
      t68,
      t71
    ] });
    $2[105] = t68;
    $2[106] = t71;
    $2[107] = t72;
  } else {
    t72 = $2[107];
  }
  const t73 = values.defaultSize ?? "";
  let t74;
  if ($2[108] === Symbol.for("react.memo_cache_sentinel")) {
    t74 = ["xs", "s", "m", "l", "xl"].map(_temp2$7);
    $2[108] = t74;
  } else {
    t74 = $2[108];
  }
  let t75;
  if ($2[109] !== handleChange || $2[110] !== t73) {
    t75 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1, { name: "defaultSize", size: "large", fullWidth: true, label: "Default row size", position: "item-aligned", onChange: handleChange, value: t73, renderValue: _temp$b, children: t74 }) });
    $2[109] = handleChange;
    $2[110] = t73;
    $2[111] = t75;
  } else {
    t75 = $2[111];
  }
  const t76 = customIdValue === "code_defined";
  let t77;
  if ($2[112] !== setFieldValue) {
    t77 = (v2) => {
      if (v2 === "code_defined") {
        throw new Error("This should not happen");
      } else {
        if (v2 === "true") {
          setFieldValue("customId", true);
        } else {
          if (v2 === "false") {
            setFieldValue("customId", false);
          } else {
            if (v2 === "optional") {
              setFieldValue("customId", "optional");
            }
          }
        }
      }
    };
    $2[112] = setFieldValue;
    $2[113] = t77;
  } else {
    t77 = $2[113];
  }
  const t78 = customIdValue ?? "";
  let t79;
  let t80;
  let t81;
  if ($2[114] === Symbol.for("react.memo_cache_sentinel")) {
    t79 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$1, { value: "false", children: "Document ID is generated automatically" });
    t80 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$1, { value: "true", children: "Users must define an ID" });
    t81 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$1, { value: "optional", children: "Users can define an ID, but it is not required" });
    $2[114] = t79;
    $2[115] = t80;
    $2[116] = t81;
  } else {
    t79 = $2[114];
    t80 = $2[115];
    t81 = $2[116];
  }
  let t82;
  if ($2[117] !== t76 || $2[118] !== t77 || $2[119] !== t78) {
    t82 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Select$1, { name: "customId", label: "Document IDs generation", position: "item-aligned", size: "large", fullWidth: true, disabled: t76, onValueChange: t77, value: t78, renderValue: _temp3$4, children: [
      t79,
      t80,
      t81
    ] }) });
    $2[117] = t76;
    $2[118] = t77;
    $2[119] = t78;
    $2[120] = t82;
  } else {
    t82 = $2[120];
  }
  let t83;
  if ($2[121] !== setFieldValue) {
    t83 = (v_0) => setFieldValue("collectionGroup", v_0);
    $2[121] = setFieldValue;
    $2[122] = t83;
  } else {
    t83 = $2[122];
  }
  const t84 = values.collectionGroup ?? false;
  let t85;
  if ($2[123] !== t83 || $2[124] !== t84) {
    t85 = /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanSwitchWithLabel$1, { position: "start", label: "Collection group", onValueChange: t83, value: t84 });
    $2[123] = t83;
    $2[124] = t84;
    $2[125] = t85;
  } else {
    t85 = $2[125];
  }
  let t86;
  if ($2[126] === Symbol.for("react.memo_cache_sentinel")) {
    t86 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption2, { children: "A collection group consists of all collections with the same path. This allows you to query over multiple collections at once." });
    $2[126] = t86;
  } else {
    t86 = $2[126];
  }
  let t87;
  if ($2[127] !== t85) {
    t87 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
      t85,
      t86
    ] });
    $2[127] = t85;
    $2[128] = t87;
  } else {
    t87 = $2[128];
  }
  let t88;
  if ($2[129] !== setFieldValue) {
    t88 = (v_1) => setFieldValue("textSearchEnabled", v_1);
    $2[129] = setFieldValue;
    $2[130] = t88;
  } else {
    t88 = $2[130];
  }
  const t89 = values.textSearchEnabled ?? false;
  let t90;
  if ($2[131] !== t88 || $2[132] !== t89) {
    t90 = /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanSwitchWithLabel$1, { position: "start", label: "Enable text search for this collection", onValueChange: t88, value: t89 });
    $2[131] = t88;
    $2[132] = t89;
    $2[133] = t90;
  } else {
    t90 = $2[133];
  }
  let t91;
  if ($2[134] === Symbol.for("react.memo_cache_sentinel")) {
    t91 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption2, { children: "Allow text search for this collection. If you have not specified a text search delegate, this will use the built-in local text search. This is not recommended for large collections, as it may incur in performance and cost issues." });
    $2[134] = t91;
  } else {
    t91 = $2[134];
  }
  let t92;
  if ($2[135] !== t90) {
    t92 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
      t90,
      t91
    ] });
    $2[135] = t90;
    $2[136] = t92;
  } else {
    t92 = $2[136];
  }
  let t93;
  if ($2[137] !== t45 || $2[138] !== t53 || $2[139] !== t65 || $2[140] !== t72 || $2[141] !== t75 || $2[142] !== t82 || $2[143] !== t87 || $2[144] !== t92) {
    t93 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-12 gap-4 p-4", children: [
      t45,
      t53,
      t65,
      t72,
      t75,
      t82,
      t87,
      t92
    ] });
    $2[137] = t45;
    $2[138] = t53;
    $2[139] = t65;
    $2[140] = t72;
    $2[141] = t75;
    $2[142] = t82;
    $2[143] = t87;
    $2[144] = t92;
    $2[145] = t93;
  } else {
    t93 = $2[145];
  }
  let t94;
  if ($2[146] !== advancedPanelExpanded || $2[147] !== t93) {
    t94 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandablePanel2, { expanded: advancedPanelExpanded, onExpandedChange: setAdvancedPanelExpanded, title: t38, initiallyExpanded: false, children: t93 }) });
    $2[146] = advancedPanelExpanded;
    $2[147] = t93;
    $2[148] = t94;
  } else {
    t94 = $2[148];
  }
  let t95;
  if ($2[149] !== t27 || $2[150] !== t36 || $2[151] !== t37 || $2[152] !== t94) {
    t95 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t19, children: [
      t27,
      t36,
      t37,
      t94
    ] });
    $2[149] = t27;
    $2[150] = t36;
    $2[151] = t37;
    $2[152] = t94;
    $2[153] = t95;
  } else {
    t95 = $2[153];
  }
  let t96;
  if ($2[154] === Symbol.for("react.memo_cache_sentinel")) {
    t96 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
      height: "52px"
    } });
    $2[154] = t96;
  } else {
    t96 = $2[154];
  }
  let t97;
  if ($2[155] !== setFieldValue) {
    t97 = (icon) => {
      setIconDialogOpen(false);
      setFieldValue("icon", icon);
    };
    $2[155] = setFieldValue;
    $2[156] = t97;
  } else {
    t97 = $2[156];
  }
  let t98;
  if ($2[157] !== t97 || $2[158] !== values.icon) {
    t98 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 overflow-auto min-h-[200px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SearchIconsView2, { selectedIcon: values.icon, onIconSelected: t97 }) });
    $2[157] = t97;
    $2[158] = values.icon;
    $2[159] = t98;
  } else {
    t98 = $2[159];
  }
  let t99;
  if ($2[160] !== iconDialogOpen || $2[161] !== t98) {
    t99 = /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog$2, { open: iconDialogOpen, onOpenChange: setIconDialogOpen, maxWidth: "xl", fullWidth: true, children: t98 });
    $2[160] = iconDialogOpen;
    $2[161] = t98;
    $2[162] = t99;
  } else {
    t99 = $2[162];
  }
  let t100;
  if ($2[163] !== T0 || $2[164] !== t18 || $2[165] !== t95 || $2[166] !== t99) {
    t100 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t7, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(T0, { maxWidth: t8, className: t9, children: [
      t18,
      t95,
      t96,
      t99
    ] }) });
    $2[163] = T0;
    $2[164] = t18;
    $2[165] = t95;
    $2[166] = t99;
    $2[167] = t100;
  } else {
    t100 = $2[167];
  }
  return t100;
}
function _temp3$4(value_2) {
  if (value_2 === "code_defined") {
    return "Code defined";
  } else {
    if (value_2 === "true") {
      return "Users must define an ID";
    } else {
      if (value_2 === "optional") {
        return "Users can define an ID, but it is not required";
      } else {
        return "Document ID is generated automatically";
      }
    }
  }
}
function _temp2$7(value_1) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$1, { value: value_1, children: value_1.toUpperCase() }, `size-select-${value_1}`);
}
function _temp$b(value_0) {
  return value_0.toUpperCase();
}
function DefaultDatabaseField(t0) {
  const $2 = c_1(5);
  const {
    databaseId,
    onDatabaseIdUpdate
  } = t0;
  const t1 = databaseId ?? "";
  let t2;
  if ($2[0] !== onDatabaseIdUpdate) {
    t2 = (e) => onDatabaseIdUpdate(e.target.value);
    $2[0] = onDatabaseIdUpdate;
    $2[1] = t2;
  } else {
    t2 = $2[1];
  }
  let t3;
  if ($2[2] !== t1 || $2[3] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$3, { title: "Database ID", side: "top", align: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$3, { size: "small", invisible: true, inputClassName: "text-end", value: t1, onChange: t2, placeholder: "(default)" }) });
    $2[2] = t1;
    $2[3] = t2;
    $2[4] = t3;
  } else {
    t3 = $2[4];
  }
  return t3;
}
function idToPropertiesPath(id) {
  return "properties." + id.replaceAll(".", ".properties.");
}
function namespaceToPropertiesPath(namespace) {
  return namespace ? "properties." + namespace.replaceAll(".", ".properties.") + ".properties" : "properties";
}
function namespaceToPropertiesOrderPath(namespace) {
  return namespace ? "properties." + namespace.replaceAll(".", ".properties.") + ".propertiesOrder" : "propertiesOrder";
}
function getFullId(propertyKey, propertyNamespace) {
  return propertyNamespace ? `${propertyNamespace}.${propertyKey}` : propertyKey;
}
function getFullIdPath(propertyKey, propertyNamespace) {
  const keyWithNamespace = propertyNamespace ? `${propertyNamespace}.${propertyKey}` : propertyKey;
  return idToPropertiesPath(keyWithNamespace);
}
function EnumForm(t0) {
  const $2 = c_1(22);
  const {
    enumValues,
    onValuesChanged,
    onError,
    updateIds,
    disabled,
    allowDataInference,
    getData
  } = t0;
  let t1;
  if ($2[0] !== enumValues) {
    t1 = {
      enumValues
    };
    $2[0] = enumValues;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  let t2;
  if ($2[2] !== onError) {
    t2 = (values) => {
      const errors = {};
      if (values.enumValues) {
        values.enumValues.forEach((enumValue, index2) => {
          if (!enumValue?.label) {
            errors.enumValues = errors.enumValues ?? [];
            errors.enumValues[index2] = errors.enumValues[index2] ?? {};
            errors.enumValues[index2].label = "You must specify a label for this enum value entry";
          }
          if (!enumValue?.id) {
            errors.enumValues = errors.enumValues ?? [];
            errors.enumValues[index2] = errors.enumValues[index2] ?? {};
            errors.enumValues[index2].id = "You must specify an ID for this enum value entry";
          }
        });
      }
      const hasError = Boolean(errors?.enumValues && Object.keys(errors?.enumValues).length > 0);
      onError?.(hasError);
      return errors;
    };
    $2[2] = onError;
    $2[3] = t2;
  } else {
    t2 = $2[3];
  }
  let t3;
  if ($2[4] !== t1 || $2[5] !== t2) {
    t3 = {
      initialValues: t1,
      validateOnChange: true,
      validation: t2
    };
    $2[4] = t1;
    $2[5] = t2;
    $2[6] = t3;
  } else {
    t3 = $2[6];
  }
  const formex = useCreateFormex(t3);
  const {
    values: values_0,
    errors: errors_0
  } = formex;
  let t4;
  if ($2[7] !== onValuesChanged || $2[8] !== values_0.enumValues) {
    t4 = () => {
      if (onValuesChanged) {
        onValuesChanged(values_0.enumValues);
      }
    };
    $2[7] = onValuesChanged;
    $2[8] = values_0.enumValues;
    $2[9] = t4;
  } else {
    t4 = $2[9];
  }
  let t5;
  if ($2[10] !== values_0.enumValues) {
    t5 = [values_0.enumValues];
    $2[10] = values_0.enumValues;
    $2[11] = t5;
  } else {
    t5 = $2[11];
  }
  useEffect$4(t4, t5);
  let t6;
  if ($2[12] !== allowDataInference || $2[13] !== disabled || $2[14] !== errors_0 || $2[15] !== getData || $2[16] !== updateIds || $2[17] !== values_0) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(EnumFormFields, { enumValuesPath: "enumValues", values: values_0, errors: errors_0, shouldUpdateId: updateIds, disabled, allowDataInference, getData });
    $2[12] = allowDataInference;
    $2[13] = disabled;
    $2[14] = errors_0;
    $2[15] = getData;
    $2[16] = updateIds;
    $2[17] = values_0;
    $2[18] = t6;
  } else {
    t6 = $2[18];
  }
  let t7;
  if ($2[19] !== formex || $2[20] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(Formex, { value: formex, children: t6 });
    $2[19] = formex;
    $2[20] = t6;
    $2[21] = t7;
  } else {
    t7 = $2[21];
  }
  return t7;
}
function EnumFormFields(t0) {
  const $2 = c_1(43);
  const {
    values,
    errors,
    disabled,
    enumValuesPath,
    shouldUpdateId,
    allowDataInference,
    getData
  } = t0;
  const {
    setFieldValue
  } = useFormex();
  const [lastInternalIdAdded, setLastInternalIdAdded] = React__default.useState();
  const [editDialogIndex, setEditDialogIndex] = React__default.useState();
  const [inferring, setInferring] = React__default.useState(false);
  let t1;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /* @__PURE__ */ new Set();
    $2[0] = t1;
  } else {
    t1 = $2[0];
  }
  const inferredValuesRef = React__default.useRef(t1);
  const inferredValues = inferredValuesRef.current;
  let t2;
  if ($2[1] !== disabled || $2[2] !== enumValuesPath || $2[3] !== errors?.enumValues || $2[4] !== lastInternalIdAdded || $2[5] !== shouldUpdateId || $2[6] !== values.enumValues) {
    t2 = (t32) => {
      const {
        index: index2,
        internalId
      } = t32;
      const justAdded = lastInternalIdAdded === internalId;
      const entryError = errors?.enumValues && errors?.enumValues[index2];
      return /* @__PURE__ */ jsxRuntimeExports.jsx(EnumEntry, { index: index2, disabled, enumValuesPath, autoFocus: justAdded, entryError, shouldUpdateId: shouldUpdateId || justAdded, onDialogOpen: () => setEditDialogIndex(index2), inferredEntry: inferredValues.has(values.enumValues[index2]?.id) }, `${internalId}`);
    };
    $2[1] = disabled;
    $2[2] = enumValuesPath;
    $2[3] = errors?.enumValues;
    $2[4] = lastInternalIdAdded;
    $2[5] = shouldUpdateId;
    $2[6] = values.enumValues;
    $2[7] = t2;
  } else {
    t2 = $2[7];
  }
  const buildEntry = t2;
  let t3;
  if ($2[8] !== enumValuesPath || $2[9] !== getData || $2[10] !== setFieldValue || $2[11] !== values.enumValues) {
    t3 = async () => {
      if (!getData) {
        return;
      }
      setInferring(true);
      getData?.().then((data) => {
        if (!data) {
          return;
        }
        const flatData = data.flat();
        const fieldData = Array.from(new Set(flatData));
        const currentEnumValues = values.enumValues;
        const foundEnumValues = extractEnumFromValues(fieldData);
        const newEnumValues = foundEnumValues.filter((enumValue) => !currentEnumValues?.some((v2) => v2.id === enumValue.id));
        newEnumValues.forEach((enumValue_0) => {
          inferredValues.add(enumValue_0.id);
        });
        setFieldValue(enumValuesPath, [...newEnumValues, ...currentEnumValues], true);
      }).catch(_temp$a$1).finally(() => setInferring(false));
    };
    $2[8] = enumValuesPath;
    $2[9] = getData;
    $2[10] = setFieldValue;
    $2[11] = values.enumValues;
    $2[12] = t3;
  } else {
    t3 = $2[12];
  }
  const inferValues = t3;
  let t4;
  let t5;
  if ($2[13] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(ListIcon2, {});
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "subtitle2", className: "ml-2 grow", children: "Values" });
    $2[13] = t4;
    $2[14] = t5;
  } else {
    t4 = $2[13];
    t5 = $2[14];
  }
  let t6;
  if ($2[15] !== allowDataInference || $2[16] !== disabled || $2[17] !== inferValues || $2[18] !== inferring) {
    t6 = allowDataInference && /* @__PURE__ */ jsxRuntimeExports.jsxs(Button$3, { loading: inferring, disabled: disabled || inferring, variant: "text", size: "small", onClick: inferValues, children: [
      inferring ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress$2, { size: "small" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(AutorenewIcon2, {}),
      "Infer values from data"
    ] });
    $2[15] = allowDataInference;
    $2[16] = disabled;
    $2[17] = inferValues;
    $2[18] = inferring;
    $2[19] = t6;
  } else {
    t6 = $2[19];
  }
  let t7;
  if ($2[20] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ml-3.5 flex flex-row items-center", children: [
      t4,
      t5,
      t6
    ] });
    $2[20] = t6;
    $2[21] = t7;
  } else {
    t7 = $2[21];
  }
  let t8;
  if ($2[22] !== enumValuesPath || $2[23] !== setFieldValue) {
    t8 = (value) => setFieldValue(enumValuesPath, value);
    $2[22] = enumValuesPath;
    $2[23] = setFieldValue;
    $2[24] = t8;
  } else {
    t8 = $2[24];
  }
  let t9;
  if ($2[25] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = {
      id: "",
      label: ""
    };
    $2[25] = t9;
  } else {
    t9 = $2[25];
  }
  let t10;
  if ($2[26] !== buildEntry || $2[27] !== disabled || $2[28] !== enumValuesPath || $2[29] !== t8 || $2[30] !== values.enumValues) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayContainer2, { droppableId: enumValuesPath, addLabel: "Add enum value", value: values.enumValues, disabled, size: "small", buildEntry, onInternalIdAdded: setLastInternalIdAdded, includeAddButton: true, onValueChange: t8, newDefaultEntry: t9 });
    $2[26] = buildEntry;
    $2[27] = disabled;
    $2[28] = enumValuesPath;
    $2[29] = t8;
    $2[30] = values.enumValues;
    $2[31] = t10;
  } else {
    t10 = $2[31];
  }
  const t11 = editDialogIndex !== void 0;
  let t12;
  if ($2[32] === Symbol.for("react.memo_cache_sentinel")) {
    t12 = () => setEditDialogIndex(void 0);
    $2[32] = t12;
  } else {
    t12 = $2[32];
  }
  let t13;
  if ($2[33] !== editDialogIndex || $2[34] !== enumValuesPath || $2[35] !== t11) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsx(EnumEntryDialog, { index: editDialogIndex, open: t11, enumValuesPath, onClose: t12 });
    $2[33] = editDialogIndex;
    $2[34] = enumValuesPath;
    $2[35] = t11;
    $2[36] = t13;
  } else {
    t13 = $2[36];
  }
  let t14;
  if ($2[37] !== t10 || $2[38] !== t13) {
    t14 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper$2, { className: "p-4 m-1", children: [
      t10,
      t13
    ] });
    $2[37] = t10;
    $2[38] = t13;
    $2[39] = t14;
  } else {
    t14 = $2[39];
  }
  let t15;
  if ($2[40] !== t14 || $2[41] !== t7) {
    t15 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
      t7,
      t14
    ] });
    $2[40] = t14;
    $2[41] = t7;
    $2[42] = t15;
  } else {
    t15 = $2[42];
  }
  return t15;
}
function _temp$a$1(e) {
  console.error(e);
}
const EnumEntry = React__default.memo(function EnumEntryInternal(t0) {
  const $2 = c_1(38);
  const {
    index: index2,
    shouldUpdateId: updateId,
    enumValuesPath,
    autoFocus,
    onDialogOpen,
    disabled,
    inferredEntry,
    entryError
  } = t0;
  const {
    values,
    setFieldValue
  } = useFormex();
  const shouldUpdateIdRef = React__default.useRef(!getIn(values, `${enumValuesPath}[${index2}].id`));
  const shouldUpdateId = updateId || shouldUpdateIdRef.current;
  const t1 = `${enumValuesPath}[${index2}].id`;
  let t2;
  if ($2[0] !== t1 || $2[1] !== values) {
    t2 = getIn(values, t1);
    $2[0] = t1;
    $2[1] = values;
    $2[2] = t2;
  } else {
    t2 = $2[2];
  }
  const idValue = t2;
  const t3 = `${enumValuesPath}[${index2}].label`;
  let t4;
  if ($2[3] !== t3 || $2[4] !== values) {
    t4 = getIn(values, t3);
    $2[3] = t3;
    $2[4] = values;
    $2[5] = t4;
  } else {
    t4 = $2[5];
  }
  const labelValue = t4;
  const currentLabelRef = React__default.useRef(labelValue);
  let t5;
  if ($2[6] !== enumValuesPath || $2[7] !== idValue || $2[8] !== index2 || $2[9] !== labelValue || $2[10] !== setFieldValue || $2[11] !== shouldUpdateId) {
    t5 = () => {
      if ((currentLabelRef.current === idValue || !idValue) && shouldUpdateId) {
        setFieldValue(`${enumValuesPath}[${index2}].id`, labelValue);
      }
      currentLabelRef.current = labelValue;
    };
    $2[6] = enumValuesPath;
    $2[7] = idValue;
    $2[8] = index2;
    $2[9] = labelValue;
    $2[10] = setFieldValue;
    $2[11] = shouldUpdateId;
    $2[12] = t5;
  } else {
    t5 = $2[12];
  }
  let t6;
  if ($2[13] !== labelValue) {
    t6 = [labelValue];
    $2[13] = labelValue;
    $2[14] = t6;
  } else {
    t6 = $2[14];
  }
  React__default.useEffect(t5, t6);
  const t7 = `${enumValuesPath}[${index2}].label`;
  let t8;
  if ($2[15] !== inferredEntry) {
    t8 = inferredEntry && /* @__PURE__ */ jsxRuntimeExports.jsx(AutorenewIcon2, { size: "small" });
    $2[15] = inferredEntry;
    $2[16] = t8;
  } else {
    t8 = $2[16];
  }
  const t9 = Boolean(entryError?.label);
  let t10;
  if ($2[17] !== autoFocus || $2[18] !== disabled || $2[19] !== t7 || $2[20] !== t8 || $2[21] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: t7, as: DebouncedTextField2, className: "flex-grow", required: true, disabled, size: "small", autoFocus, autoComplete: "off", endAdornment: t8, error: t9 });
    $2[17] = autoFocus;
    $2[18] = disabled;
    $2[19] = t7;
    $2[20] = t8;
    $2[21] = t9;
    $2[22] = t10;
  } else {
    t10 = $2[22];
  }
  let t11;
  if ($2[23] !== disabled || $2[24] !== entryError?.id || $2[25] !== onDialogOpen) {
    t11 = !disabled && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge2, { color: "error", invisible: !entryError?.id, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$3, { size: "small", "aria-label": "edit", className: "m-1", onClick: () => onDialogOpen(), children: /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsIcon2, { size: "small" }) }) });
    $2[23] = disabled;
    $2[24] = entryError?.id;
    $2[25] = onDialogOpen;
    $2[26] = t11;
  } else {
    t11 = $2[26];
  }
  let t12;
  if ($2[27] !== t10 || $2[28] !== t11) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full align-center justify-center", children: [
      t10,
      t11
    ] });
    $2[27] = t10;
    $2[28] = t11;
    $2[29] = t12;
  } else {
    t12 = $2[29];
  }
  let t13;
  if ($2[30] !== entryError?.label) {
    t13 = entryError?.label && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "caption", className: "ml-3.5 text-red-500 dark:text-red-500", children: entryError?.label });
    $2[30] = entryError?.label;
    $2[31] = t13;
  } else {
    t13 = $2[31];
  }
  let t14;
  if ($2[32] !== entryError?.id) {
    t14 = entryError?.id && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "caption", className: "ml-3.5 text-red-500 dark:text-red-500", children: entryError?.id });
    $2[32] = entryError?.id;
    $2[33] = t14;
  } else {
    t14 = $2[33];
  }
  let t15;
  if ($2[34] !== t12 || $2[35] !== t13 || $2[36] !== t14) {
    t15 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t12,
      t13,
      t14
    ] });
    $2[34] = t12;
    $2[35] = t13;
    $2[36] = t14;
    $2[37] = t15;
  } else {
    t15 = $2[37];
  }
  return t15;
}, function areEqual(prevProps, nextProps) {
  return prevProps.index === nextProps.index && prevProps.enumValuesPath === nextProps.enumValuesPath && prevProps.shouldUpdateId === nextProps.shouldUpdateId && prevProps.inferredEntry === nextProps.inferredEntry && equal(prevProps.entryError, nextProps.entryError) && prevProps.autoFocus === nextProps.autoFocus;
});
function EnumEntryDialog(t0) {
  const $2 = c_1(20);
  const {
    index: index2,
    open,
    onClose,
    enumValuesPath
  } = t0;
  const {
    errors
  } = useFormex();
  let t1;
  if ($2[0] !== enumValuesPath || $2[1] !== errors || $2[2] !== index2) {
    t1 = index2 !== void 0 ? getIn(errors, `${enumValuesPath}[${index2}].id`) : void 0;
    $2[0] = enumValuesPath;
    $2[1] = errors;
    $2[2] = index2;
    $2[3] = t1;
  } else {
    t1 = $2[3];
  }
  const idError = t1;
  let t2;
  if ($2[4] !== onClose) {
    t2 = (open_0) => !open_0 ? onClose() : void 0;
    $2[4] = onClose;
    $2[5] = t2;
  } else {
    t2 = $2[5];
  }
  let t3;
  if ($2[6] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle$2, { hidden: true, children: "Enum form dialog" });
    $2[6] = t3;
  } else {
    t3 = $2[6];
  }
  let t4;
  if ($2[7] !== enumValuesPath || $2[8] !== idError || $2[9] !== index2) {
    t4 = index2 !== void 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: `${enumValuesPath}[${index2}].id`, as: DebouncedTextField2, required: true, label: "ID", size: "small", autoComplete: "off", error: Boolean(idError) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption2, { error: Boolean(idError), children: idError ?? "Value saved in the data source" })
    ] });
    $2[7] = enumValuesPath;
    $2[8] = idError;
    $2[9] = index2;
    $2[10] = t4;
  } else {
    t4 = $2[10];
  }
  let t5;
  if ($2[11] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent$2, { children: t4 });
    $2[11] = t4;
    $2[12] = t5;
  } else {
    t5 = $2[12];
  }
  let t6;
  if ($2[13] !== onClose) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { autoFocus: true, variant: "outlined", onClick: onClose, color: "primary", children: "Ok" }) });
    $2[13] = onClose;
    $2[14] = t6;
  } else {
    t6 = $2[14];
  }
  let t7;
  if ($2[15] !== open || $2[16] !== t2 || $2[17] !== t5 || $2[18] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog$2, { maxWidth: "md", "aria-labelledby": "enum-edit-dialog", open, onOpenChange: t2, children: [
      t3,
      t5,
      t6
    ] });
    $2[15] = open;
    $2[16] = t2;
    $2[17] = t5;
    $2[18] = t6;
    $2[19] = t7;
  } else {
    t7 = $2[19];
  }
  return t7;
}
function SwitchControl(t0) {
  const $2 = c_1(13);
  const {
    field,
    form,
    label,
    tooltip,
    disabled,
    size: t1,
    allowIndeterminate
  } = t0;
  const size = t1 === void 0 ? "small" : t1;
  let t2;
  if ($2[0] !== field.name || $2[1] !== form) {
    t2 = (checked) => form.setFieldValue(field.name, checked);
    $2[0] = field.name;
    $2[1] = form;
    $2[2] = t2;
  } else {
    t2 = $2[2];
  }
  let t3;
  if ($2[3] !== allowIndeterminate || $2[4] !== disabled || $2[5] !== field.value || $2[6] !== label || $2[7] !== size || $2[8] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanSwitchWithLabel$1, { label, size, position: "start", value: field.value, disabled, allowIndeterminate, onValueChange: t2 });
    $2[3] = allowIndeterminate;
    $2[4] = disabled;
    $2[5] = field.value;
    $2[6] = label;
    $2[7] = size;
    $2[8] = t2;
    $2[9] = t3;
  } else {
    t3 = $2[9];
  }
  const formControlLabel = t3;
  if (tooltip) {
    let t4;
    if ($2[10] !== formControlLabel || $2[11] !== tooltip) {
      t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$3, { title: tooltip, children: formControlLabel });
      $2[10] = formControlLabel;
      $2[11] = tooltip;
      $2[12] = t4;
    } else {
      t4 = $2[12];
    }
    return t4;
  }
  return formControlLabel;
}
function GeneralPropertyValidation(t0) {
  const $2 = c_1(12);
  const {
    disabled
  } = t0;
  const {
    values,
    handleChange
  } = useFormex();
  let t1;
  if ($2[0] !== disabled) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: "validation.required", type: "checkbox", children: (t22) => {
      const {
        field,
        form
      } = t22;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchControl, { disabled, label: "Required", tooltip: "You won't be able to save this entity if this value is not set", form, field });
    } }) });
    $2[0] = disabled;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  let t2;
  if ($2[2] !== disabled) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: "validation.unique", type: "checkbox", children: (t32) => {
      const {
        field: field_0,
        form: form_0
      } = t32;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchControl, { disabled, label: "Unique", tooltip: "There cannot be multiple entities with the same value", form: form_0, field: field_0 });
    } }) });
    $2[2] = disabled;
    $2[3] = t2;
  } else {
    t2 = $2[3];
  }
  let t3;
  if ($2[4] !== disabled || $2[5] !== handleChange || $2[6] !== values) {
    t3 = getIn(values, "validation.required") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DebouncedTextField2, { disabled, value: getIn(values, "validation.requiredMessage"), label: "Required message", name: "validation.requiredMessage", size: "small", onChange: handleChange }) });
    $2[4] = disabled;
    $2[5] = handleChange;
    $2[6] = values;
    $2[7] = t3;
  } else {
    t3 = $2[7];
  }
  let t4;
  if ($2[8] !== t1 || $2[9] !== t2 || $2[10] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t1,
      t2,
      t3
    ] });
    $2[8] = t1;
    $2[9] = t2;
    $2[10] = t3;
    $2[11] = t4;
  } else {
    t4 = $2[11];
  }
  return t4;
}
function StringPropertyValidation(t0) {
  const $2 = c_1(48);
  const {
    length,
    lowercase,
    matches,
    max,
    min,
    trim,
    uppercase,
    disabled
  } = t0;
  const {
    values,
    handleChange,
    errors
  } = useFormex();
  let t1;
  if ($2[0] !== errors) {
    t1 = getIn(errors, "validation.matches");
    $2[0] = errors;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  const matchesError = t1;
  let t2;
  if ($2[2] !== values) {
    const matchesValue = getIn(values, "validation.matches");
    t2 = typeof matchesValue === "string" ? matchesValue : serializeRegExp2(matchesValue);
    $2[2] = values;
    $2[3] = t2;
  } else {
    t2 = $2[3];
  }
  const matchesStringValue = t2;
  let t3;
  if ($2[4] !== disabled) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(GeneralPropertyValidation, { disabled });
    $2[4] = disabled;
    $2[5] = t3;
  } else {
    t3 = $2[5];
  }
  let t4;
  if ($2[6] !== disabled || $2[7] !== lowercase) {
    t4 = lowercase && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: "validation.lowercase", type: "checkbox", children: (t52) => {
      const {
        field,
        form
      } = t52;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchControl, { label: "Lowercase", disabled, form, field });
    } }) });
    $2[6] = disabled;
    $2[7] = lowercase;
    $2[8] = t4;
  } else {
    t4 = $2[8];
  }
  let t5;
  if ($2[9] !== disabled || $2[10] !== uppercase) {
    t5 = uppercase && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: "validation.uppercase", type: "checkbox", children: (t62) => {
      const {
        field: field_0,
        form: form_0
      } = t62;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchControl, { label: "Uppercase", disabled, form: form_0, field: field_0 });
    } }) });
    $2[9] = disabled;
    $2[10] = uppercase;
    $2[11] = t5;
  } else {
    t5 = $2[11];
  }
  let t6;
  if ($2[12] !== disabled || $2[13] !== trim) {
    t6 = trim && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: "validation.trim", type: "checkbox", children: (t72) => {
      const {
        field: field_1,
        form: form_1
      } = t72;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchControl, { label: "Trim", disabled, form: form_1, field: field_1 });
    } }) });
    $2[12] = disabled;
    $2[13] = trim;
    $2[14] = t6;
  } else {
    t6 = $2[14];
  }
  let t7;
  if ($2[15] !== t4 || $2[16] !== t5 || $2[17] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-12 gap-2 col-span-12", children: [
      t4,
      t5,
      t6
    ] });
    $2[15] = t4;
    $2[16] = t5;
    $2[17] = t6;
    $2[18] = t7;
  } else {
    t7 = $2[18];
  }
  let t8;
  if ($2[19] !== disabled || $2[20] !== handleChange || $2[21] !== length || $2[22] !== values) {
    t8 = length && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DebouncedTextField2, { value: getIn(values, "validation.length"), label: "Exact length", name: "validation.length", type: "number", size: "small", disabled, onChange: handleChange }) });
    $2[19] = disabled;
    $2[20] = handleChange;
    $2[21] = length;
    $2[22] = values;
    $2[23] = t8;
  } else {
    t8 = $2[23];
  }
  let t9;
  if ($2[24] !== disabled || $2[25] !== handleChange || $2[26] !== min || $2[27] !== values) {
    t9 = min && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DebouncedTextField2, { value: getIn(values, "validation.min"), label: "Min length", name: "validation.min", type: "number", size: "small", disabled, onChange: handleChange }) });
    $2[24] = disabled;
    $2[25] = handleChange;
    $2[26] = min;
    $2[27] = values;
    $2[28] = t9;
  } else {
    t9 = $2[28];
  }
  let t10;
  if ($2[29] !== disabled || $2[30] !== handleChange || $2[31] !== max || $2[32] !== values) {
    t10 = max && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DebouncedTextField2, { value: getIn(values, "validation.max"), label: "Max length", name: "validation.max", type: "number", size: "small", disabled, onChange: handleChange }) });
    $2[29] = disabled;
    $2[30] = handleChange;
    $2[31] = max;
    $2[32] = values;
    $2[33] = t10;
  } else {
    t10 = $2[33];
  }
  let t11;
  if ($2[34] !== t10 || $2[35] !== t8 || $2[36] !== t9) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-12 gap-2 col-span-12", children: [
      t8,
      t9,
      t10
    ] });
    $2[34] = t10;
    $2[35] = t8;
    $2[36] = t9;
    $2[37] = t11;
  } else {
    t11 = $2[37];
  }
  let t12;
  if ($2[38] !== disabled || $2[39] !== matches || $2[40] !== matchesError || $2[41] !== matchesStringValue) {
    t12 = matches && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: "validation.matches", as: DebouncedTextField2, label: "Matches regex", size: "small", disabled, value: matchesStringValue, error: Boolean(matchesError) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption2, { error: Boolean(matchesError), children: matchesError ? "Not a valid regexp" : "e.g. /^\\d+$/ for digits only" })
    ] });
    $2[38] = disabled;
    $2[39] = matches;
    $2[40] = matchesError;
    $2[41] = matchesStringValue;
    $2[42] = t12;
  } else {
    t12 = $2[42];
  }
  let t13;
  if ($2[43] !== t11 || $2[44] !== t12 || $2[45] !== t3 || $2[46] !== t7) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-12 gap-2", children: [
      t3,
      t7,
      t11,
      t12
    ] });
    $2[43] = t11;
    $2[44] = t12;
    $2[45] = t3;
    $2[46] = t7;
    $2[47] = t13;
  } else {
    t13 = $2[47];
  }
  return t13;
}
function ArrayPropertyValidation(t0) {
  const $2 = c_1(16);
  const {
    max: t1,
    min: t2,
    disabled
  } = t0;
  const max = t1 === void 0 ? true : t1;
  const min = t2 === void 0 ? true : t2;
  const {
    values,
    handleChange
  } = useFormex();
  let t3;
  if ($2[0] !== disabled) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(GeneralPropertyValidation, { disabled });
    $2[0] = disabled;
    $2[1] = t3;
  } else {
    t3 = $2[1];
  }
  let t4;
  if ($2[2] !== disabled || $2[3] !== handleChange || $2[4] !== min || $2[5] !== values) {
    t4 = min && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DebouncedTextField2, { value: getIn(values, "validation.min"), disabled, label: "Min length", name: "validation.min", type: "number", size: "small", onChange: handleChange }) });
    $2[2] = disabled;
    $2[3] = handleChange;
    $2[4] = min;
    $2[5] = values;
    $2[6] = t4;
  } else {
    t4 = $2[6];
  }
  let t5;
  if ($2[7] !== disabled || $2[8] !== handleChange || $2[9] !== max || $2[10] !== values) {
    t5 = max && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DebouncedTextField2, { value: getIn(values, "validation.max"), disabled, label: "Max length", name: "validation.max", type: "number", size: "small", onChange: handleChange }) });
    $2[7] = disabled;
    $2[8] = handleChange;
    $2[9] = max;
    $2[10] = values;
    $2[11] = t5;
  } else {
    t5 = $2[11];
  }
  let t6;
  if ($2[12] !== t3 || $2[13] !== t4 || $2[14] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-12 gap-2", children: [
      t3,
      t4,
      t5
    ] });
    $2[12] = t3;
    $2[13] = t4;
    $2[14] = t5;
    $2[15] = t6;
  } else {
    t6 = $2[15];
  }
  return t6;
}
function ValidationPanel(t0) {
  const $2 = c_1(3);
  const {
    children
  } = t0;
  let t1;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row text-surface-500", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(RuleIcon2, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "subtitle2", className: "ml-2", children: "Validation" })
    ] });
    $2[0] = t1;
  } else {
    t1 = $2[0];
  }
  let t2;
  if ($2[1] !== children) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandablePanel2, { initiallyExpanded: false, asField: true, innerClassName: "p-4", title: t1, children });
    $2[1] = children;
    $2[2] = t2;
  } else {
    t2 = $2[2];
  }
  return t2;
}
function EnumPropertyField({
  multiselect,
  updateIds,
  disabled,
  showErrors,
  allowDataInference,
  getData
}) {
  const {
    values,
    setFieldError,
    setFieldValue
  } = useFormex();
  const snackbarContext = useSnackbarController$2();
  const enumValuesPath = multiselect ? "of.enumValues" : "enumValues";
  const defaultValue = getIn(values, "defaultValue");
  const valuesEnumValues = getIn(values, enumValuesPath);
  const enumValues = useMemo$4(() => {
    if (!valuesEnumValues || typeof valuesEnumValues === "boolean") return [];
    return resolveEnumValues2(valuesEnumValues) ?? [];
  }, [valuesEnumValues]);
  const onValuesChanged = (value) => {
    if (!values) return;
    setFieldValue(enumValuesPath, value);
    if (!multiselect) {
      const enumIds = value.filter((v2) => Boolean(v2?.id)).map((v_0) => v_0.id);
      if (defaultValue && !enumIds.includes(defaultValue)) {
        setFieldValue("defaultValue", void 0);
        snackbarContext.open({
          type: "warning",
          message: "Default value was cleared"
        });
      }
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(EnumForm, { enumValues, updateIds, disabled, allowDataInference, onError: (hasError) => {
      setFieldError(enumValuesPath, hasError ? "This enum property is missing some values" : void 0);
    }, getData: getData ? () => getData().then((res) => res.map((entry) => values.id && getIn(entry, values.id)).filter(Boolean)) : void 0, onValuesChanged }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ValidationPanel, { children: [
      !multiselect && /* @__PURE__ */ jsxRuntimeExports.jsx(StringPropertyValidation, { disabled, showErrors }),
      multiselect && /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayPropertyValidation, { disabled })
    ] }) }),
    !multiselect && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1, { disabled, position: "item-aligned", fullWidth: true, onValueChange: (value_0) => {
      setFieldValue("defaultValue", value_0);
    }, size: "large", label: "Default value", value: defaultValue ?? "", children: enumValues.filter((enumValue) => Boolean(enumValue?.id)).map((enumValue_0) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$1, { value: enumValue_0.id?.toString(), children: enumValue_0.label }, enumValue_0.id)) }) })
  ] });
}
const fileTypes = {
  "image/*": "Images",
  "video/*": "Videos",
  "audio/*": "Audio files",
  "application/*": "Files (pdf, zip, csv, excel...)",
  "text/*": "Text files"
};
function StoragePropertyField(t0) {
  const $2 = c_1(108);
  const {
    multiple,
    existing,
    disabled
  } = t0;
  const {
    values,
    setFieldValue
  } = useFormex();
  const baseStoragePath = multiple ? "of.storage" : "storage";
  const acceptedFiles = `${baseStoragePath}.acceptedFiles`;
  const fileName = `${baseStoragePath}.fileName`;
  const maxSize = `${baseStoragePath}.maxSize`;
  const storagePath = `${baseStoragePath}.storagePath`;
  const storeUrl = `${baseStoragePath}.storeUrl`;
  let t1;
  if ($2[0] !== fileName || $2[1] !== values) {
    t1 = getIn(values, fileName) ?? "{rand}_{file}";
    $2[0] = fileName;
    $2[1] = values;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  const fileNameValue = t1;
  let t2;
  if ($2[3] !== storagePath || $2[4] !== values) {
    t2 = getIn(values, storagePath) ?? "/";
    $2[3] = storagePath;
    $2[4] = values;
    $2[5] = t2;
  } else {
    t2 = $2[5];
  }
  const storagePathValue = t2;
  let T0;
  let T1;
  let t10;
  let t11;
  let t12;
  let t13;
  let t14;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  if ($2[6] !== acceptedFiles || $2[7] !== disabled || $2[8] !== existing || $2[9] !== fileName || $2[10] !== fileNameValue || $2[11] !== maxSize || $2[12] !== setFieldValue || $2[13] !== storagePath || $2[14] !== storagePathValue || $2[15] !== storeUrl || $2[16] !== values) {
    const maxSizeValue = getIn(values, maxSize);
    let t152;
    if ($2[31] !== acceptedFiles || $2[32] !== values) {
      t152 = getIn(values, acceptedFiles);
      $2[31] = acceptedFiles;
      $2[32] = values;
      $2[33] = t152;
    } else {
      t152 = $2[33];
    }
    const storedValue = t152;
    const fileTypesValue = Array.isArray(storedValue) ? storedValue : void 0;
    const allFileTypesSelected = !fileTypesValue || fileTypesValue.length === 0;
    let t162;
    if ($2[34] !== acceptedFiles || $2[35] !== setFieldValue) {
      t162 = (value) => {
        if (!value) {
          setFieldValue(acceptedFiles, void 0);
        } else {
          setFieldValue(acceptedFiles, value);
        }
      };
      $2[34] = acceptedFiles;
      $2[35] = setFieldValue;
      $2[36] = t162;
    } else {
      t162 = $2[36];
    }
    const handleTypesChange = t162;
    const hasFilenameCallback = typeof fileNameValue === "function";
    const hasStoragePathCallback = typeof storagePathValue === "function";
    t14 = "col-span-12";
    T1 = ExpandablePanel2;
    if ($2[37] === Symbol.for("react.memo_cache_sentinel")) {
      t13 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row text-surface-500", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CloudUploadIcon2, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "subtitle2", className: "ml-2", children: "File upload config" })
      ] });
      $2[37] = t13;
    } else {
      t13 = $2[37];
    }
    t9 = "grid grid-cols-12 gap-2 p-4";
    let t172;
    if ($2[38] !== fileTypesValue) {
      t172 = fileTypesValue ?? [];
      $2[38] = fileTypesValue;
      $2[39] = t172;
    } else {
      t172 = $2[39];
    }
    const t182 = allFileTypesSelected ? void 0 : "Allowed file types";
    let t192;
    if ($2[40] !== acceptedFiles || $2[41] !== setFieldValue) {
      t192 = Object.entries(fileTypes).map((t203) => {
        const [value_0, label] = t203;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(MultiSelectItem2, { value: value_0, className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow", children: label }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { size: "small", variant: "text", onClick: (e) => {
            e.preventDefault();
            e.stopPropagation();
            return setFieldValue(acceptedFiles, [value_0]);
          }, children: "Only" })
        ] }, value_0);
      });
      $2[40] = acceptedFiles;
      $2[41] = setFieldValue;
      $2[42] = t192;
    } else {
      t192 = $2[42];
    }
    if ($2[43] !== acceptedFiles || $2[44] !== disabled || $2[45] !== handleTypesChange || $2[46] !== t172 || $2[47] !== t182 || $2[48] !== t192) {
      t10 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSelect2, { className: "w-full", placeholder: "All file types allowed", disabled, name: acceptedFiles, value: t172, onValueChange: handleTypesChange, label: t182, renderValues: _temp3$3, children: t192 }) });
      $2[43] = acceptedFiles;
      $2[44] = disabled;
      $2[45] = handleTypesChange;
      $2[46] = t172;
      $2[47] = t182;
      $2[48] = t192;
      $2[49] = t10;
    } else {
      t10 = $2[49];
    }
    const t202 = hasFilenameCallback || disabled;
    const t212 = hasFilenameCallback ? "-" : fileNameValue;
    if ($2[50] !== fileName || $2[51] !== t202 || $2[52] !== t212) {
      t11 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: fileName, as: DebouncedTextField2, label: "File name", size: "small", disabled: t202, value: t212 }) });
      $2[50] = fileName;
      $2[51] = t202;
      $2[52] = t212;
      $2[53] = t11;
    } else {
      t11 = $2[53];
    }
    const t222 = hasStoragePathCallback || disabled;
    const t232 = hasStoragePathCallback ? "-" : storagePathValue;
    let t242;
    if ($2[54] !== storagePath || $2[55] !== t222 || $2[56] !== t232) {
      t242 = /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: storagePath, as: DebouncedTextField2, label: "Storage path", disabled: t222, size: "small", value: t232 });
      $2[54] = storagePath;
      $2[55] = t222;
      $2[56] = t232;
      $2[57] = t242;
    } else {
      t242 = $2[57];
    }
    let t25;
    if ($2[58] === Symbol.for("react.memo_cache_sentinel")) {
      t25 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography$3, { variant: "caption", className: "ml-3.5 mt-1 mb-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "You can use the following placeholders in the file name and storage path values:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "{file} - Full name of the uploaded file" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "{file.name} - Name of the uploaded file without extension" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "{file.ext} - Extension of the uploaded file" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "{entityId} - ID of the entity" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "{propertyKey} - ID of this field" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "{path} - Path of this entity" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "{rand} - Random value used to avoid name collisions" })
        ] })
      ] });
      $2[58] = t25;
    } else {
      t25 = $2[58];
    }
    let t26;
    if ($2[59] !== disabled || $2[60] !== existing) {
      t26 = (t272) => {
        const {
          field,
          form
        } = t272;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchControl, { label: "Save URL instead of storage path", disabled: existing || disabled, form, field });
      };
      $2[59] = disabled;
      $2[60] = existing;
      $2[61] = t26;
    } else {
      t26 = $2[61];
    }
    let t27;
    if ($2[62] !== storeUrl || $2[63] !== t26) {
      t27 = /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: storeUrl, type: "checkbox", children: t26 });
      $2[62] = storeUrl;
      $2[63] = t26;
      $2[64] = t27;
    } else {
      t27 = $2[64];
    }
    let t28;
    if ($2[65] === Symbol.for("react.memo_cache_sentinel")) {
      t28 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "caption", className: "ml-3.5 mt-1 mb-2", children: "Turn this setting on, if you prefer to save the download URL of the uploaded file instead of the storage path. You can only change this prop upon creation." });
      $2[65] = t28;
    } else {
      t28 = $2[65];
    }
    if ($2[66] !== t242 || $2[67] !== t27) {
      t12 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
        t242,
        t25,
        t27,
        t28
      ] });
      $2[66] = t242;
      $2[67] = t27;
      $2[68] = t12;
    } else {
      t12 = $2[68];
    }
    t8 = "col-span-12";
    T0 = DebouncedTextField2;
    t3 = maxSize;
    t4 = "number";
    t5 = "Max size (in bytes)";
    t6 = "small";
    t7 = maxSizeValue !== void 0 && maxSizeValue !== null ? maxSizeValue.toString() : "";
    $2[6] = acceptedFiles;
    $2[7] = disabled;
    $2[8] = existing;
    $2[9] = fileName;
    $2[10] = fileNameValue;
    $2[11] = maxSize;
    $2[12] = setFieldValue;
    $2[13] = storagePath;
    $2[14] = storagePathValue;
    $2[15] = storeUrl;
    $2[16] = values;
    $2[17] = T0;
    $2[18] = T1;
    $2[19] = t10;
    $2[20] = t11;
    $2[21] = t12;
    $2[22] = t13;
    $2[23] = t14;
    $2[24] = t3;
    $2[25] = t4;
    $2[26] = t5;
    $2[27] = t6;
    $2[28] = t7;
    $2[29] = t8;
    $2[30] = t9;
  } else {
    T0 = $2[17];
    T1 = $2[18];
    t10 = $2[19];
    t11 = $2[20];
    t12 = $2[21];
    t13 = $2[22];
    t14 = $2[23];
    t3 = $2[24];
    t4 = $2[25];
    t5 = $2[26];
    t6 = $2[27];
    t7 = $2[28];
    t8 = $2[29];
    t9 = $2[30];
  }
  let t15;
  if ($2[69] !== maxSize || $2[70] !== setFieldValue) {
    t15 = (e_0) => {
      const value_1 = e_0.target.value;
      if (value_1 === "") {
        setFieldValue(maxSize, void 0);
      } else {
        setFieldValue(maxSize, parseInt(value_1));
      }
    };
    $2[69] = maxSize;
    $2[70] = setFieldValue;
    $2[71] = t15;
  } else {
    t15 = $2[71];
  }
  let t16;
  if ($2[72] !== T0 || $2[73] !== t15 || $2[74] !== t3 || $2[75] !== t4 || $2[76] !== t5 || $2[77] !== t6 || $2[78] !== t7) {
    t16 = /* @__PURE__ */ jsxRuntimeExports.jsx(T0, { name: t3, type: t4, label: t5, size: t6, value: t7, onChange: t15 });
    $2[72] = T0;
    $2[73] = t15;
    $2[74] = t3;
    $2[75] = t4;
    $2[76] = t5;
    $2[77] = t6;
    $2[78] = t7;
    $2[79] = t16;
  } else {
    t16 = $2[79];
  }
  let t17;
  if ($2[80] !== t16 || $2[81] !== t8) {
    t17 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t8, children: t16 });
    $2[80] = t16;
    $2[81] = t8;
    $2[82] = t17;
  } else {
    t17 = $2[82];
  }
  let t18;
  if ($2[83] !== t10 || $2[84] !== t11 || $2[85] !== t12 || $2[86] !== t17 || $2[87] !== t9) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t9, children: [
      t10,
      t11,
      t12,
      t17
    ] });
    $2[83] = t10;
    $2[84] = t11;
    $2[85] = t12;
    $2[86] = t17;
    $2[87] = t9;
    $2[88] = t18;
  } else {
    t18 = $2[88];
  }
  let t19;
  if ($2[89] !== T1 || $2[90] !== t13 || $2[91] !== t18) {
    t19 = /* @__PURE__ */ jsxRuntimeExports.jsx(T1, { title: t13, children: t18 });
    $2[89] = T1;
    $2[90] = t13;
    $2[91] = t18;
    $2[92] = t19;
  } else {
    t19 = $2[92];
  }
  let t20;
  if ($2[93] !== t14 || $2[94] !== t19) {
    t20 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t14, children: t19 });
    $2[93] = t14;
    $2[94] = t19;
    $2[95] = t20;
  } else {
    t20 = $2[95];
  }
  let t21;
  if ($2[96] !== disabled || $2[97] !== multiple) {
    t21 = !multiple && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-12 gap-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(GeneralPropertyValidation, { disabled }) });
    $2[96] = disabled;
    $2[97] = multiple;
    $2[98] = t21;
  } else {
    t21 = $2[98];
  }
  let t22;
  if ($2[99] !== disabled || $2[100] !== multiple) {
    t22 = multiple && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayPropertyValidation, { disabled }) });
    $2[99] = disabled;
    $2[100] = multiple;
    $2[101] = t22;
  } else {
    t22 = $2[101];
  }
  let t23;
  if ($2[102] !== t21 || $2[103] !== t22) {
    t23 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ValidationPanel, { children: [
      t21,
      t22
    ] }) });
    $2[102] = t21;
    $2[103] = t22;
    $2[104] = t23;
  } else {
    t23 = $2[104];
  }
  let t24;
  if ($2[105] !== t20 || $2[106] !== t23) {
    t24 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t20,
      t23
    ] });
    $2[105] = t20;
    $2[106] = t23;
    $2[107] = t24;
  } else {
    t24 = $2[107];
  }
  return t24;
}
function _temp3$3(selected) {
  if (!selected || selected.length === 0) {
    return "All file types allowed";
  }
  return selected.map(_temp$9$1).filter(_temp2$6).join(", ");
}
function _temp2$6(v_0) {
  return Boolean(v_0);
}
function _temp$9$1(v2) {
  return fileTypes[v2];
}
function editableProperty(property) {
  if (isPropertyBuilder$1(property)) return false;
  if (isPropertyBuilder$1(property)) return false;
  else {
    const eProperty = property;
    if (eProperty.dataType === "array" && typeof eProperty.of === "function") return false;
    else if (eProperty.dataType === "array" && Array.isArray(eProperty.of)) return false;
    return Boolean(eProperty.editable);
  }
}
function PropertyFieldPreview(t0) {
  const $2 = c_1(33);
  const {
    property,
    onClick,
    hasError,
    includeName,
    includeEditButton,
    selected
  } = t0;
  const {
    propertyConfigs
  } = useCustomizationController$3();
  let t1;
  if ($2[0] !== property || $2[1] !== propertyConfigs) {
    t1 = getFieldConfig2(property, propertyConfigs);
    $2[0] = property;
    $2[1] = propertyConfigs;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  const propertyConfig = t1;
  editableProperty(property);
  const borderColorClass = hasError ? "border-red-500 dark:border-red-500 border-opacity-100 dark:border-opacity-100 ring-0 dark:ring-0" : selected ? "border-primary" : "border-transparent";
  let t2;
  if ($2[3] !== propertyConfig) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyConfigBadge2, { propertyConfig }) });
    $2[3] = propertyConfig;
    $2[4] = t2;
  } else {
    t2 = $2[4];
  }
  const t3 = onClick ? cardClickableMixin2 : "";
  const t4 = selected ? cardSelectedMixin2 : "";
  let t5;
  if ($2[5] !== borderColorClass || $2[6] !== t3 || $2[7] !== t4) {
    t5 = cls$3("border", "pl-2 w-full flex flex-row gap-4 items-center", cardMixin2, t3, t4, "flex-grow p-4 border transition-colors duration-200", borderColorClass);
    $2[5] = borderColorClass;
    $2[6] = t3;
    $2[7] = t4;
    $2[8] = t5;
  } else {
    t5 = $2[8];
  }
  let t6;
  if ($2[9] !== includeName || $2[10] !== property.name) {
    t6 = includeName && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "body1", component: "span", className: "flex-grow pr-2", children: property.name ? property.name : "" }) });
    $2[9] = includeName;
    $2[10] = property.name;
    $2[11] = t6;
  } else {
    t6 = $2[11];
  }
  const t7 = includeName ? "body2" : "subtitle1";
  const t8 = propertyConfig?.name;
  let t9;
  if ($2[12] !== t7 || $2[13] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { className: "flex-grow pr-2", variant: t7, component: "span", color: "secondary", children: t8 }) });
    $2[12] = t7;
    $2[13] = t8;
    $2[14] = t9;
  } else {
    t9 = $2[14];
  }
  let t10;
  if ($2[15] !== property.dataType) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "body2", component: "span", color: "disabled", children: property.dataType }) });
    $2[15] = property.dataType;
    $2[16] = t10;
  } else {
    t10 = $2[16];
  }
  let t11;
  if ($2[17] !== t10 || $2[18] !== t9) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row items-center", children: [
      t9,
      t10
    ] });
    $2[17] = t10;
    $2[18] = t9;
    $2[19] = t11;
  } else {
    t11 = $2[19];
  }
  let t12;
  if ($2[20] !== t11 || $2[21] !== t6) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full flex flex-col", children: [
      t6,
      t11
    ] });
    $2[20] = t11;
    $2[21] = t6;
    $2[22] = t12;
  } else {
    t12 = $2[22];
  }
  let t13;
  if ($2[23] !== includeEditButton) {
    t13 = includeEditButton && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "button", children: "EDIT" });
    $2[23] = includeEditButton;
    $2[24] = t13;
  } else {
    t13 = $2[24];
  }
  let t14;
  if ($2[25] !== t12 || $2[26] !== t13 || $2[27] !== t5) {
    t14 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper$2, { className: t5, children: [
      t12,
      t13
    ] });
    $2[25] = t12;
    $2[26] = t13;
    $2[27] = t5;
    $2[28] = t14;
  } else {
    t14 = $2[28];
  }
  let t15;
  if ($2[29] !== onClick || $2[30] !== t14 || $2[31] !== t2) {
    t15 = /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick, className: "flex flex-row w-full cursor-pointer", children: [
      t2,
      t14
    ] }) });
    $2[29] = onClick;
    $2[30] = t14;
    $2[31] = t2;
    $2[32] = t15;
  } else {
    t15 = $2[32];
  }
  return t15;
}
function NonEditablePropertyPreview(t0) {
  const $2 = c_1(40);
  const {
    name,
    selected,
    onClick,
    property
  } = t0;
  const {
    propertyConfigs
  } = useCustomizationController$3();
  let t1;
  if ($2[0] !== property || $2[1] !== propertyConfigs) {
    t1 = !isPropertyBuilder$1(property) && property ? getFieldConfig2(property, propertyConfigs) : void 0;
    $2[0] = property;
    $2[1] = propertyConfigs;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  const propertyConfig = t1;
  let t2;
  if ($2[3] !== propertyConfig) {
    t2 = propertyConfig && /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyConfigBadge2, { propertyConfig });
    $2[3] = propertyConfig;
    $2[4] = t2;
  } else {
    t2 = $2[4];
  }
  let t3;
  if ($2[5] !== propertyConfig) {
    t3 = !propertyConfig && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-8 w-8 p-1 rounded-full shadow text-white bg-surface-500", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FunctionsIcon2, { color: "inherit", size: "medium" }) });
    $2[5] = propertyConfig;
    $2[6] = t3;
  } else {
    t3 = $2[6];
  }
  let t4;
  if ($2[7] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(DoNotDisturbOnIcon2, { color: "disabled", size: "small", className: "absolute -right-2 -top-2" });
    $2[7] = t4;
  } else {
    t4 = $2[7];
  }
  let t5;
  if ($2[8] !== t2 || $2[9] !== t3) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative m-4", children: [
      t2,
      t3,
      t4
    ] });
    $2[8] = t2;
    $2[9] = t3;
    $2[10] = t5;
  } else {
    t5 = $2[10];
  }
  const t6 = onClick ? cardClickableMixin2 : "";
  const t7 = selected ? cardSelectedMixin2 : "";
  const t8 = selected ? "border-primary" : "border-transparent";
  let t9;
  if ($2[11] !== t6 || $2[12] !== t7 || $2[13] !== t8) {
    t9 = cls$3("pl-2 w-full flex flex-row gap-4 items-center", cardMixin2, t6, t7, "flex-grow p-4 border transition-colors duration-200", t8);
    $2[11] = t6;
    $2[12] = t7;
    $2[13] = t8;
    $2[14] = t9;
  } else {
    t9 = $2[14];
  }
  const t10 = property?.name ? property.name : name;
  let t11;
  if ($2[15] !== t10) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "body1", component: "span", className: "flex-grow pr-2", children: t10 });
    $2[15] = t10;
    $2[16] = t11;
  } else {
    t11 = $2[16];
  }
  let t12;
  if ($2[17] !== propertyConfig) {
    t12 = propertyConfig && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { className: "flex-grow pr-2", variant: "body2", component: "span", color: "secondary", children: propertyConfig?.name });
    $2[17] = propertyConfig;
    $2[18] = t12;
  } else {
    t12 = $2[18];
  }
  let t13;
  if ($2[19] !== property) {
    t13 = property && !isPropertyBuilder$1(property) && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "body2", component: "span", color: "disabled", children: property.dataType }) });
    $2[19] = property;
    $2[20] = t13;
  } else {
    t13 = $2[20];
  }
  let t14;
  if ($2[21] !== property) {
    t14 = property && isPropertyBuilder$1(property) && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "body2", component: "span", color: "disabled", children: "This property is defined as a property builder in code" }) });
    $2[21] = property;
    $2[22] = t14;
  } else {
    t14 = $2[22];
  }
  let t15;
  if ($2[23] !== property) {
    t15 = !property && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "body2", component: "span", color: "disabled", children: "This field is defined as an additional field in code" }) });
    $2[23] = property;
    $2[24] = t15;
  } else {
    t15 = $2[24];
  }
  let t16;
  if ($2[25] !== t12 || $2[26] !== t13 || $2[27] !== t14 || $2[28] !== t15) {
    t16 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row items-center", children: [
      t12,
      t13,
      t14,
      t15
    ] });
    $2[25] = t12;
    $2[26] = t13;
    $2[27] = t14;
    $2[28] = t15;
    $2[29] = t16;
  } else {
    t16 = $2[29];
  }
  let t17;
  if ($2[30] !== t11 || $2[31] !== t16) {
    t17 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full flex flex-col", children: [
      t11,
      t16
    ] });
    $2[30] = t11;
    $2[31] = t16;
    $2[32] = t17;
  } else {
    t17 = $2[32];
  }
  let t18;
  if ($2[33] !== t17 || $2[34] !== t9) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsx(Paper$2, { className: t9, children: t17 });
    $2[33] = t17;
    $2[34] = t9;
    $2[35] = t18;
  } else {
    t18 = $2[35];
  }
  let t19;
  if ($2[36] !== onClick || $2[37] !== t18 || $2[38] !== t5) {
    t19 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick, className: "flex flex-row w-full cursor-pointer", children: [
      t5,
      t18
    ] });
    $2[36] = onClick;
    $2[37] = t18;
    $2[38] = t5;
    $2[39] = t19;
  } else {
    t19 = $2[39];
  }
  return t19;
}
const PropertyTree = React__default.memo(function PropertyTree2(t0) {
  const $2 = c_1(26);
  const {
    namespace,
    selectedPropertyKey,
    onPropertyClick,
    properties,
    propertiesOrder: propertiesOrderProp,
    additionalFields,
    errors,
    onPropertyMove,
    onPropertyRemove,
    className,
    inferredPropertyKeys,
    collectionEditable
  } = t0;
  let t1;
  if ($2[0] !== properties || $2[1] !== propertiesOrderProp) {
    t1 = propertiesOrderProp ?? Object.keys(properties);
    $2[0] = properties;
    $2[1] = propertiesOrderProp;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  const propertiesOrder = t1;
  let t2;
  if ($2[3] !== namespace || $2[4] !== onPropertyMove || $2[5] !== propertiesOrder) {
    t2 = (result) => {
      if (!result.destination) {
        return;
      }
      const startIndex = result.source.index;
      const endIndex = result.destination.index;
      const newPropertiesOrder = Array.from(propertiesOrder);
      const [removed] = newPropertiesOrder.splice(startIndex, 1);
      newPropertiesOrder.splice(endIndex, 0, removed);
      if (onPropertyMove) {
        onPropertyMove(newPropertiesOrder, namespace);
      }
    };
    $2[3] = namespace;
    $2[4] = onPropertyMove;
    $2[5] = propertiesOrder;
    $2[6] = t2;
  } else {
    t2 = $2[6];
  }
  const onDragEnd = t2;
  const t3 = `droppable_${namespace}`;
  let t4;
  if ($2[7] !== additionalFields || $2[8] !== className || $2[9] !== collectionEditable || $2[10] !== errors || $2[11] !== inferredPropertyKeys || $2[12] !== namespace || $2[13] !== onPropertyClick || $2[14] !== onPropertyMove || $2[15] !== onPropertyRemove || $2[16] !== properties || $2[17] !== propertiesOrder || $2[18] !== selectedPropertyKey) {
    t4 = (droppableProvided, droppableSnapshot) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ...droppableProvided.droppableProps, ref: droppableProvided.innerRef, className, children: [
      propertiesOrder && propertiesOrder.map((propertyKey, index2) => {
        const property = properties[propertyKey];
        const additionalField = additionalFields?.find((field) => field.key === propertyKey);
        if (!property && !additionalField) {
          console.warn(`Property ${propertyKey} not found in properties or additionalFields`);
          return null;
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(PublicDraggable, { draggableId: `array_field_${namespace}_${propertyKey}}`, index: index2, children: (provided, snapshot) => /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyTreeEntry, { propertyKey, propertyOrBuilder: property, additionalField, provided, errors, namespace, inferredPropertyKeys, onPropertyMove, onPropertyRemove, onPropertyClick: snapshot.isDragging ? void 0 : onPropertyClick, selectedPropertyKey, collectionEditable }) }) }, `array_field_${namespace}_${propertyKey}}`);
      }).filter(Boolean),
      droppableProvided.placeholder
    ] });
    $2[7] = additionalFields;
    $2[8] = className;
    $2[9] = collectionEditable;
    $2[10] = errors;
    $2[11] = inferredPropertyKeys;
    $2[12] = namespace;
    $2[13] = onPropertyClick;
    $2[14] = onPropertyMove;
    $2[15] = onPropertyRemove;
    $2[16] = properties;
    $2[17] = propertiesOrder;
    $2[18] = selectedPropertyKey;
    $2[19] = t4;
  } else {
    t4 = $2[19];
  }
  let t5;
  if ($2[20] !== t3 || $2[21] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectedDroppable$1, { droppableId: t3, children: t4 });
    $2[20] = t3;
    $2[21] = t4;
    $2[22] = t5;
  } else {
    t5 = $2[22];
  }
  let t6;
  if ($2[23] !== onDragEnd || $2[24] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DragDropContext, { onDragEnd, children: t5 }) });
    $2[23] = onDragEnd;
    $2[24] = t5;
    $2[25] = t6;
  } else {
    t6 = $2[25];
  }
  return t6;
}, (prevProps, nextProps) => {
  const isSelected = nextProps.selectedPropertyKey?.startsWith(nextProps.namespace ?? "");
  const wasSelected = prevProps.selectedPropertyKey?.startsWith(prevProps.namespace ?? "");
  if (isSelected || wasSelected) return false;
  return equal(prevProps.properties, nextProps.properties) && prevProps.propertiesOrder === nextProps.propertiesOrder && equal(prevProps.additionalFields, nextProps.additionalFields) && equal(prevProps.errors, nextProps.errors) && equal(prevProps.onPropertyClick, nextProps.onPropertyClick) && // equal(prevProps.onPropertyMove, nextProps.onPropertyMove) &&
  // equal(prevProps.onPropertyRemove, nextProps.onPropertyRemove) &&
  prevProps.namespace === nextProps.namespace && prevProps.collectionEditable === nextProps.collectionEditable;
});
function PropertyTreeEntry(t0) {
  const $2 = c_1(53);
  const {
    propertyKey,
    namespace,
    propertyOrBuilder,
    additionalField,
    provided,
    selectedPropertyKey,
    errors,
    onPropertyClick,
    onPropertyMove,
    onPropertyRemove,
    inferredPropertyKeys,
    collectionEditable
  } = t0;
  let t1;
  if ($2[0] !== inferredPropertyKeys || $2[1] !== namespace || $2[2] !== propertyKey) {
    t1 = inferredPropertyKeys?.includes(namespace ? `${namespace}.${propertyKey}` : propertyKey);
    $2[0] = inferredPropertyKeys;
    $2[1] = namespace;
    $2[2] = propertyKey;
    $2[3] = t1;
  } else {
    t1 = $2[3];
  }
  const isPropertyInferred = t1;
  let t2;
  if ($2[4] !== namespace || $2[5] !== propertyKey) {
    t2 = getFullId(propertyKey, namespace);
    $2[4] = namespace;
    $2[5] = propertyKey;
    $2[6] = t2;
  } else {
    t2 = $2[6];
  }
  const fullId = t2;
  const fullIdPath = getFullIdPath(propertyKey, namespace);
  const hasError = fullIdPath in errors;
  let subtree;
  if (typeof propertyOrBuilder === "object") {
    const property = propertyOrBuilder;
    if (property.dataType === "map" && property.properties) {
      let t32;
      if ($2[7] !== collectionEditable || $2[8] !== errors || $2[9] !== fullId || $2[10] !== onPropertyClick || $2[11] !== onPropertyMove || $2[12] !== onPropertyRemove || $2[13] !== property.properties || $2[14] !== property.propertiesOrder || $2[15] !== selectedPropertyKey) {
        t32 = /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyTree, { selectedPropertyKey, namespace: fullId, properties: property.properties, propertiesOrder: property.propertiesOrder, errors, onPropertyClick, onPropertyMove, onPropertyRemove, collectionEditable });
        $2[7] = collectionEditable;
        $2[8] = errors;
        $2[9] = fullId;
        $2[10] = onPropertyClick;
        $2[11] = onPropertyMove;
        $2[12] = onPropertyRemove;
        $2[13] = property.properties;
        $2[14] = property.propertiesOrder;
        $2[15] = selectedPropertyKey;
        $2[16] = t32;
      } else {
        t32 = $2[16];
      }
      subtree = t32;
    }
  }
  const selected = selectedPropertyKey === fullId;
  let t3;
  if ($2[17] !== collectionEditable || $2[18] !== propertyOrBuilder) {
    t3 = propertyOrBuilder && (collectionEditable && !isPropertyBuilder$1(propertyOrBuilder) || editableProperty(propertyOrBuilder));
    $2[17] = collectionEditable;
    $2[18] = propertyOrBuilder;
    $2[19] = t3;
  } else {
    t3 = $2[19];
  }
  const editable = t3;
  let t4;
  if ($2[20] !== subtree) {
    t4 = subtree && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute border-l " + defaultBorderMixin$1, style: {
      left: "32px",
      top: "64px",
      bottom: "16px"
    } });
    $2[20] = subtree;
    $2[21] = t4;
  } else {
    t4 = $2[21];
  }
  let t5;
  if ($2[22] !== additionalField || $2[23] !== editable || $2[24] !== hasError || $2[25] !== namespace || $2[26] !== onPropertyClick || $2[27] !== propertyKey || $2[28] !== propertyOrBuilder || $2[29] !== selected) {
    t5 = !isPropertyBuilder$1(propertyOrBuilder) && !additionalField && editable ? /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyFieldPreview, { property: propertyOrBuilder, onClick: onPropertyClick ? () => onPropertyClick(propertyKey, namespace) : void 0, includeName: true, selected, hasError }) : /* @__PURE__ */ jsxRuntimeExports.jsx(NonEditablePropertyPreview, { name: propertyKey, property: propertyOrBuilder, onClick: onPropertyClick ? () => onPropertyClick(propertyKey, namespace) : void 0, selected });
    $2[22] = additionalField;
    $2[23] = editable;
    $2[24] = hasError;
    $2[25] = namespace;
    $2[26] = onPropertyClick;
    $2[27] = propertyKey;
    $2[28] = propertyOrBuilder;
    $2[29] = selected;
    $2[30] = t5;
  } else {
    t5 = $2[30];
  }
  let t6;
  if ($2[31] !== isPropertyInferred) {
    t6 = isPropertyInferred && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$3, { title: "Inferred property", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AutorenewIcon2, { size: "small", className: "p-2" }) });
    $2[31] = isPropertyInferred;
    $2[32] = t6;
  } else {
    t6 = $2[32];
  }
  let t7;
  if ($2[33] !== namespace || $2[34] !== onPropertyRemove || $2[35] !== propertyKey) {
    t7 = onPropertyRemove && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$3, { title: "Remove", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$3, { size: "small", color: "inherit", onClick: () => onPropertyRemove(propertyKey, namespace), children: /* @__PURE__ */ jsxRuntimeExports.jsx(RemoveIcon2, { size: "small" }) }) });
    $2[33] = namespace;
    $2[34] = onPropertyRemove;
    $2[35] = propertyKey;
    $2[36] = t7;
  } else {
    t7 = $2[36];
  }
  let t8;
  if ($2[37] !== onPropertyMove) {
    t8 = onPropertyMove && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$3, { title: "Move", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$3, { component: "span", size: "small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DragHandleIcon2, { size: "small" }) }) });
    $2[37] = onPropertyMove;
    $2[38] = t8;
  } else {
    t8 = $2[38];
  }
  let t9;
  if ($2[39] !== t6 || $2[40] !== t7 || $2[41] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute top-2 right-2 flex flex-row ", children: [
      t6,
      t7,
      t8
    ] });
    $2[39] = t6;
    $2[40] = t7;
    $2[41] = t8;
    $2[42] = t9;
  } else {
    t9 = $2[42];
  }
  let t10;
  if ($2[43] !== subtree) {
    t10 = subtree && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-16", children: subtree });
    $2[43] = subtree;
    $2[44] = t10;
  } else {
    t10 = $2[44];
  }
  let t11;
  if ($2[45] !== provided.dragHandleProps || $2[46] !== provided.draggableProps || $2[47] !== provided.innerRef || $2[48] !== t10 || $2[49] !== t4 || $2[50] !== t5 || $2[51] !== t9) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: provided.innerRef, ...provided.draggableProps, ...provided.dragHandleProps, className: "relative -ml-8", children: [
      t4,
      t5,
      t9,
      t10
    ] });
    $2[45] = provided.dragHandleProps;
    $2[46] = provided.draggableProps;
    $2[47] = provided.innerRef;
    $2[48] = t10;
    $2[49] = t4;
    $2[50] = t5;
    $2[51] = t9;
    $2[52] = t11;
  } else {
    t11 = $2[52];
  }
  return t11;
}
function MapPropertyField(t0) {
  const $2 = c_1(67);
  const {
    getData,
    allowDataInference,
    propertyConfigs,
    collectionEditable
  } = t0;
  const {
    values,
    setFieldValue
  } = useFormex();
  const [propertyDialogOpen, setPropertyDialogOpen] = useState$3(false);
  const [selectedPropertyKey, setSelectedPropertyKey] = useState$3();
  const [selectedPropertyNamespace, setSelectedPropertyNamespace] = useState$3();
  let t1;
  if ($2[0] !== values.properties || $2[1] !== values.propertiesOrder) {
    t1 = values.propertiesOrder ?? Object.keys(values.properties ?? {});
    $2[0] = values.properties;
    $2[1] = values.propertiesOrder;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  const propertiesOrder = t1;
  let t2;
  if ($2[3] !== setFieldValue || $2[4] !== values.properties || $2[5] !== values.propertiesOrder) {
    t2 = (t32) => {
      const {
        id,
        property
      } = t32;
      if (!id) {
        throw Error();
      }
      setFieldValue("properties", {
        ...values.properties ?? {},
        [id]: property
      }, false);
      const currentPropertiesOrder = values.propertiesOrder ?? Object.keys(values.properties ?? {});
      const newPropertiesOrder = currentPropertiesOrder.includes(id) ? currentPropertiesOrder : [...currentPropertiesOrder, id];
      setFieldValue("propertiesOrder", newPropertiesOrder, false);
      setPropertyDialogOpen(false);
    };
    $2[3] = setFieldValue;
    $2[4] = values.properties;
    $2[5] = values.propertiesOrder;
    $2[6] = t2;
  } else {
    t2 = $2[6];
  }
  const onPropertyCreated = t2;
  let t3;
  if ($2[7] !== setFieldValue || $2[8] !== values) {
    t3 = (propertyKey, namespace) => {
      const fullId = propertyKey ? getFullId(propertyKey, namespace) : void 0;
      if (!fullId) {
        throw Error("collection editor miss config");
      }
      const propertiesPath = idToPropertiesPath(fullId);
      const propertiesOrderPath = namespaceToPropertiesOrderPath(namespace);
      const currentPropertiesOrder_0 = getIn(values, propertiesOrderPath) ?? Object.keys(getIn(values, namespaceToPropertiesPath(namespace)));
      setFieldValue(propertiesPath, void 0, false);
      setFieldValue(propertiesOrderPath, currentPropertiesOrder_0.filter((p) => p !== propertyKey), false);
      setPropertyDialogOpen(false);
      setSelectedPropertyKey(void 0);
      setSelectedPropertyNamespace(void 0);
    };
    $2[7] = setFieldValue;
    $2[8] = values;
    $2[9] = t3;
  } else {
    t3 = $2[9];
  }
  const deleteProperty = t3;
  let t4;
  if ($2[10] !== selectedPropertyKey || $2[11] !== selectedPropertyNamespace || $2[12] !== values.properties) {
    const selectedPropertyFullId = selectedPropertyKey ? getFullId(selectedPropertyKey, selectedPropertyNamespace) : void 0;
    t4 = selectedPropertyFullId ? getIn(values.properties, selectedPropertyFullId.replaceAll(".", ".properties.")) : void 0;
    $2[10] = selectedPropertyKey;
    $2[11] = selectedPropertyNamespace;
    $2[12] = values.properties;
    $2[13] = t4;
  } else {
    t4 = $2[13];
  }
  const selectedProperty = t4;
  const empty = !propertiesOrder || propertiesOrder.length < 1;
  let t5;
  if ($2[14] !== setFieldValue) {
    t5 = (propertiesOrder_0, namespace_0) => {
      setFieldValue(namespaceToPropertiesOrderPath(namespace_0), propertiesOrder_0, false);
    };
    $2[14] = setFieldValue;
    $2[15] = t5;
  } else {
    t5 = $2[15];
  }
  const onPropertyMove = t5;
  let t6;
  if ($2[16] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "subtitle2", children: "Properties in this group" });
    $2[16] = t6;
  } else {
    t6 = $2[16];
  }
  let t7;
  let t8;
  if ($2[17] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = () => setPropertyDialogOpen(true);
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon$1, {});
    $2[17] = t7;
    $2[18] = t8;
  } else {
    t7 = $2[17];
    t8 = $2[18];
  }
  const t9 = values.name ?? "this group";
  let t10;
  if ($2[19] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-end my-4", children: [
      t6,
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Button$3, { color: "primary", variant: "outlined", onClick: t7, startIcon: t8, children: [
        "Add property to ",
        t9
      ] })
    ] });
    $2[19] = t9;
    $2[20] = t10;
  } else {
    t10 = $2[20];
  }
  let t11;
  if ($2[21] !== values.properties) {
    t11 = values.properties ?? {};
    $2[21] = values.properties;
    $2[22] = t11;
  } else {
    t11 = $2[22];
  }
  let t12;
  if ($2[23] === Symbol.for("react.memo_cache_sentinel")) {
    t12 = {};
    $2[23] = t12;
  } else {
    t12 = $2[23];
  }
  let t13;
  if ($2[24] === Symbol.for("react.memo_cache_sentinel")) {
    t13 = (propertyKey_0, namespace_1) => {
      setSelectedPropertyKey(propertyKey_0);
      setSelectedPropertyNamespace(namespace_1);
      setPropertyDialogOpen(true);
    };
    $2[24] = t13;
  } else {
    t13 = $2[24];
  }
  let t14;
  if ($2[25] !== collectionEditable || $2[26] !== onPropertyMove || $2[27] !== propertiesOrder || $2[28] !== t11) {
    t14 = /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyTree, { properties: t11, propertiesOrder, errors: t12, collectionEditable, onPropertyClick: t13, onPropertyMove });
    $2[25] = collectionEditable;
    $2[26] = onPropertyMove;
    $2[27] = propertiesOrder;
    $2[28] = t11;
    $2[29] = t14;
  } else {
    t14 = $2[29];
  }
  let t15;
  if ($2[30] !== empty) {
    t15 = empty && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "label", className: "h-full flex items-center justify-center p-4", children: "Add the first property to this group" });
    $2[30] = empty;
    $2[31] = t15;
  } else {
    t15 = $2[31];
  }
  let t16;
  if ($2[32] !== t14 || $2[33] !== t15) {
    t16 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper$2, { className: "p-2 pl-8", children: [
      t14,
      t15
    ] });
    $2[32] = t14;
    $2[33] = t15;
    $2[34] = t16;
  } else {
    t16 = $2[34];
  }
  let t17;
  if ($2[35] !== t10 || $2[36] !== t16) {
    t17 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
      t10,
      t16
    ] });
    $2[35] = t10;
    $2[36] = t16;
    $2[37] = t17;
  } else {
    t17 = $2[37];
  }
  let t18;
  if ($2[38] !== setFieldValue) {
    t18 = (v2) => setFieldValue("spreadChildren", v2);
    $2[38] = setFieldValue;
    $2[39] = t18;
  } else {
    t18 = $2[39];
  }
  const t19 = values.spreadChildren ?? false;
  let t20;
  if ($2[40] !== t18 || $2[41] !== t19) {
    t20 = /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanSwitchWithLabel$1, { position: "start", size: "small", label: "Spread children as columns", onValueChange: t18, value: t19 });
    $2[40] = t18;
    $2[41] = t19;
    $2[42] = t20;
  } else {
    t20 = $2[42];
  }
  let t21;
  if ($2[43] === Symbol.for("react.memo_cache_sentinel")) {
    t21 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption2, { children: "Set this flag to true if you want to display the children of this group as individual columns. This will only work for top level groups." });
    $2[43] = t21;
  } else {
    t21 = $2[43];
  }
  let t22;
  if ($2[44] !== t20) {
    t22 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
      t20,
      t21
    ] });
    $2[44] = t20;
    $2[45] = t22;
  } else {
    t22 = $2[45];
  }
  let t23;
  let t24;
  if ($2[46] === Symbol.for("react.memo_cache_sentinel")) {
    t23 = () => {
      setPropertyDialogOpen(false);
      setSelectedPropertyKey(void 0);
      setSelectedPropertyNamespace(void 0);
    };
    t24 = () => {
      setPropertyDialogOpen(false);
      setSelectedPropertyKey(void 0);
      setSelectedPropertyNamespace(void 0);
    };
    $2[46] = t23;
    $2[47] = t24;
  } else {
    t23 = $2[46];
    t24 = $2[47];
  }
  const t25 = Boolean(selectedPropertyKey);
  const t26 = !selectedPropertyKey;
  const t27 = !selectedPropertyKey;
  const t28 = selectedPropertyKey ? void 0 : propertiesOrder;
  let t29;
  if ($2[48] !== allowDataInference || $2[49] !== collectionEditable || $2[50] !== deleteProperty || $2[51] !== getData || $2[52] !== onPropertyCreated || $2[53] !== propertyConfigs || $2[54] !== propertyDialogOpen || $2[55] !== selectedProperty || $2[56] !== selectedPropertyKey || $2[57] !== selectedPropertyNamespace || $2[58] !== t25 || $2[59] !== t26 || $2[60] !== t27 || $2[61] !== t28) {
    t29 = /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyFormDialog, { inArray: false, forceShowErrors: false, open: propertyDialogOpen, allowDataInference, collectionEditable, onCancel: t23, onOkClicked: t24, getData, onDelete: deleteProperty, propertyKey: selectedPropertyKey, propertyNamespace: selectedPropertyNamespace, property: selectedProperty, existingProperty: t25, autoUpdateId: t26, autoOpenTypeSelect: t27, onPropertyChanged: onPropertyCreated, existingPropertyKeys: t28, propertyConfigs });
    $2[48] = allowDataInference;
    $2[49] = collectionEditable;
    $2[50] = deleteProperty;
    $2[51] = getData;
    $2[52] = onPropertyCreated;
    $2[53] = propertyConfigs;
    $2[54] = propertyDialogOpen;
    $2[55] = selectedProperty;
    $2[56] = selectedPropertyKey;
    $2[57] = selectedPropertyNamespace;
    $2[58] = t25;
    $2[59] = t26;
    $2[60] = t27;
    $2[61] = t28;
    $2[62] = t29;
  } else {
    t29 = $2[62];
  }
  let t30;
  if ($2[63] !== t17 || $2[64] !== t22 || $2[65] !== t29) {
    t30 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t17,
      t22,
      t29
    ] });
    $2[63] = t17;
    $2[64] = t22;
    $2[65] = t29;
    $2[66] = t30;
  } else {
    t30 = $2[66];
  }
  return t30;
}
function RepeatPropertyField(t0) {
  const $2 = c_1(36);
  const {
    showErrors,
    existing,
    disabled,
    getData,
    allowDataInference,
    propertyConfigs,
    collectionEditable
  } = t0;
  const {
    values,
    errors,
    setFieldValue,
    touched
  } = useFormex();
  const [propertyDialogOpen, setPropertyDialogOpen] = useState$3(false);
  let ofProperty;
  let ofPropertyError;
  let onPropertyChanged;
  let t1;
  if ($2[0] !== errors || $2[1] !== propertyConfigs || $2[2] !== setFieldValue || $2[3] !== touched || $2[4] !== values) {
    ofProperty = getIn(values, "of");
    let t22;
    if ($2[9] !== errors || $2[10] !== touched) {
      t22 = getIn(touched, "of") && getIn(errors, "of");
      $2[9] = errors;
      $2[10] = touched;
      $2[11] = t22;
    } else {
      t22 = $2[11];
    }
    ofPropertyError = t22;
    let t32;
    if ($2[12] !== setFieldValue) {
      t32 = (t42) => {
        const {
          property
        } = t42;
        setFieldValue("of", property);
      };
      $2[12] = setFieldValue;
      $2[13] = t32;
    } else {
      t32 = $2[13];
    }
    onPropertyChanged = t32;
    t1 = ofProperty && getFieldConfig2(ofProperty, propertyConfigs);
    $2[0] = errors;
    $2[1] = propertyConfigs;
    $2[2] = setFieldValue;
    $2[3] = touched;
    $2[4] = values;
    $2[5] = ofProperty;
    $2[6] = ofPropertyError;
    $2[7] = onPropertyChanged;
    $2[8] = t1;
  } else {
    ofProperty = $2[5];
    ofPropertyError = $2[6];
    onPropertyChanged = $2[7];
    t1 = $2[8];
  }
  const widget = t1;
  let t2;
  if ($2[14] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "subtitle2", children: "Repeat component" });
    $2[14] = t2;
  } else {
    t2 = $2[14];
  }
  let t3;
  if ($2[15] !== allowDataInference || $2[16] !== collectionEditable || $2[17] !== disabled || $2[18] !== existing || $2[19] !== getData || $2[20] !== ofProperty || $2[21] !== ofPropertyError || $2[22] !== onPropertyChanged || $2[23] !== propertyConfigs || $2[24] !== propertyDialogOpen || $2[25] !== showErrors || $2[26] !== widget) {
    t3 = (t42) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper$2, { className: "p-2 mt-4", children: [
      ofProperty && /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyFieldPreview, { property: ofProperty, onClick: disabled ? void 0 : () => setPropertyDialogOpen(true), includeName: false, includeEditButton: true, selected: false, hasError: false }),
      !disabled && !ofProperty && /* @__PURE__ */ jsxRuntimeExports.jsxs(Button$3, { variant: "text", size: "large", color: ofPropertyError ? "error" : "primary", onClick: () => setPropertyDialogOpen(true), children: [
        "Edit ",
        `${widget ? widget.name : "repeat component"}`
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyFormDialog, { inArray: true, open: propertyDialogOpen, existingProperty: existing, getData, autoUpdateId: !existing, autoOpenTypeSelect: !existing, onOkClicked: () => setPropertyDialogOpen(false), allowDataInference, property: ofProperty, includeIdAndName: false, onPropertyChanged, forceShowErrors: showErrors, propertyConfigs, collectionEditable })
    ] });
    $2[15] = allowDataInference;
    $2[16] = collectionEditable;
    $2[17] = disabled;
    $2[18] = existing;
    $2[19] = getData;
    $2[20] = ofProperty;
    $2[21] = ofPropertyError;
    $2[22] = onPropertyChanged;
    $2[23] = propertyConfigs;
    $2[24] = propertyDialogOpen;
    $2[25] = showErrors;
    $2[26] = widget;
    $2[27] = t3;
  } else {
    t3 = $2[27];
  }
  let t4;
  if ($2[28] !== ofProperty || $2[29] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
      t2,
      /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: "of", value: ofProperty, children: t3 })
    ] });
    $2[28] = ofProperty;
    $2[29] = t3;
    $2[30] = t4;
  } else {
    t4 = $2[30];
  }
  let t5;
  if ($2[31] !== disabled) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ValidationPanel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayPropertyValidation, { disabled }) }) });
    $2[31] = disabled;
    $2[32] = t5;
  } else {
    t5 = $2[32];
  }
  let t6;
  if ($2[33] !== t4 || $2[34] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t4,
      t5
    ] });
    $2[33] = t4;
    $2[34] = t5;
    $2[35] = t6;
  } else {
    t6 = $2[35];
  }
  return t6;
}
const CommonPropertyFields = React__default.forwardRef(function CommonPropertyFields2(t0, ref2) {
  const $2 = c_1(56);
  const {
    showErrors,
    disabledId,
    disabled,
    autoUpdateId
  } = t0;
  const {
    errors,
    values,
    setFieldValue,
    setFieldTouched,
    touched
  } = useFormex();
  let t1;
  if ($2[0] !== errors || $2[1] !== showErrors) {
    t1 = showErrors && getIn(errors, "name");
    $2[0] = errors;
    $2[1] = showErrors;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  const nameError = t1;
  let t2;
  if ($2[3] !== errors || $2[4] !== showErrors) {
    t2 = showErrors && getIn(errors, "id");
    $2[3] = errors;
    $2[4] = showErrors;
    $2[5] = t2;
  } else {
    t2 = $2[5];
  }
  const idError = t2;
  let t3;
  if ($2[6] !== errors || $2[7] !== showErrors) {
    t3 = showErrors && getIn(errors, "description");
    $2[6] = errors;
    $2[7] = showErrors;
    $2[8] = t3;
  } else {
    t3 = $2[8];
  }
  const descriptionError = t3;
  const t4 = values.name;
  let t5;
  if ($2[9] !== autoUpdateId || $2[10] !== setFieldTouched || $2[11] !== setFieldValue || $2[12] !== touched) {
    t5 = (e) => {
      const newNameValue = e.target.value;
      const idTouched = getIn(touched, "id");
      if (!idTouched && autoUpdateId) {
        setFieldValue("id", newNameValue ? toSnakeCase2(newNameValue) : "", false);
      }
      setFieldValue("name", newNameValue, true);
      setFieldTouched("name", true);
    };
    $2[9] = autoUpdateId;
    $2[10] = setFieldTouched;
    $2[11] = setFieldValue;
    $2[12] = touched;
    $2[13] = t5;
  } else {
    t5 = $2[13];
  }
  let t6;
  if ($2[14] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = {
      fontSize: 20
    };
    $2[14] = t6;
  } else {
    t6 = $2[14];
  }
  const t7 = Boolean(nameError);
  let t8;
  if ($2[15] !== disabled || $2[16] !== ref2 || $2[17] !== t5 || $2[18] !== t7 || $2[19] !== values.name) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: "name", inputRef: ref2, as: DebouncedTextField2, value: t4, onChange: t5, style: t6, placeholder: "Field name", required: true, disabled, error: t7 });
    $2[15] = disabled;
    $2[16] = ref2;
    $2[17] = t5;
    $2[18] = t7;
    $2[19] = values.name;
    $2[20] = t8;
  } else {
    t8 = $2[20];
  }
  const t9 = Boolean(nameError);
  let t10;
  if ($2[21] !== nameError || $2[22] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption2, { error: t9, children: nameError });
    $2[21] = nameError;
    $2[22] = t9;
    $2[23] = t10;
  } else {
    t10 = $2[23];
  }
  let t11;
  if ($2[24] !== t10 || $2[25] !== t8) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      t8,
      t10
    ] });
    $2[24] = t10;
    $2[25] = t8;
    $2[26] = t11;
  } else {
    t11 = $2[26];
  }
  const t12 = values.id;
  let t13;
  if ($2[27] !== autoUpdateId || $2[28] !== setFieldTouched || $2[29] !== setFieldValue || $2[30] !== touched) {
    t13 = (e_0) => {
      const newIdValue = e_0.target.value;
      const nameTouched = getIn(touched, "name");
      if (!nameTouched && autoUpdateId) {
        setFieldValue("name", newIdValue ? unslugify$2(newIdValue) : "");
      }
      setFieldValue("id", newIdValue, true);
      setFieldTouched("id", true);
    };
    $2[27] = autoUpdateId;
    $2[28] = setFieldTouched;
    $2[29] = setFieldValue;
    $2[30] = touched;
    $2[31] = t13;
  } else {
    t13 = $2[31];
  }
  const t14 = disabledId || disabled;
  const t15 = Boolean(idError);
  let t16;
  if ($2[32] !== t13 || $2[33] !== t14 || $2[34] !== t15 || $2[35] !== values.id) {
    t16 = /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: "id", as: DebouncedTextField2, label: "ID", value: t12, onChange: t13, disabled: t14, required: true, size: "small", error: t15 });
    $2[32] = t13;
    $2[33] = t14;
    $2[34] = t15;
    $2[35] = values.id;
    $2[36] = t16;
  } else {
    t16 = $2[36];
  }
  const t17 = Boolean(idError);
  let t18;
  if ($2[37] !== idError || $2[38] !== t17) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption2, { error: t17, children: idError });
    $2[37] = idError;
    $2[38] = t17;
    $2[39] = t18;
  } else {
    t18 = $2[39];
  }
  let t19;
  if ($2[40] !== t16 || $2[41] !== t18) {
    t19 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      t16,
      t18
    ] });
    $2[40] = t16;
    $2[41] = t18;
    $2[42] = t19;
  } else {
    t19 = $2[42];
  }
  const t20 = Boolean(descriptionError);
  let t21;
  if ($2[43] !== disabled || $2[44] !== t20) {
    t21 = /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: "description", as: DebouncedTextField2, label: "Description", disabled, error: t20 });
    $2[43] = disabled;
    $2[44] = t20;
    $2[45] = t21;
  } else {
    t21 = $2[45];
  }
  const t22 = Boolean(descriptionError);
  let t23;
  if ($2[46] !== descriptionError || $2[47] !== t22) {
    t23 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption2, { error: t22, children: descriptionError });
    $2[46] = descriptionError;
    $2[47] = t22;
    $2[48] = t23;
  } else {
    t23 = $2[48];
  }
  let t24;
  if ($2[49] !== t21 || $2[50] !== t23) {
    t24 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      t21,
      t23
    ] });
    $2[49] = t21;
    $2[50] = t23;
    $2[51] = t24;
  } else {
    t24 = $2[51];
  }
  let t25;
  if ($2[52] !== t11 || $2[53] !== t19 || $2[54] !== t24) {
    t25 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2 col-span-12", children: [
      t11,
      t19,
      t24
    ] });
    $2[52] = t11;
    $2[53] = t19;
    $2[54] = t24;
    $2[55] = t25;
  } else {
    t25 = $2[55];
  }
  return t25;
});
function StringPropertyField(t0) {
  const $2 = c_1(27);
  const {
    widgetId,
    disabled,
    showErrors
  } = t0;
  const {
    values,
    setFieldValue
  } = useFormex();
  let t1;
  if ($2[0] !== disabled || $2[1] !== showErrors || $2[2] !== widgetId) {
    t1 = widgetId === "text_field" && /* @__PURE__ */ jsxRuntimeExports.jsx(StringPropertyValidation, { disabled, length: true, lowercase: true, matches: true, max: true, min: true, trim: true, uppercase: true, showErrors });
    $2[0] = disabled;
    $2[1] = showErrors;
    $2[2] = widgetId;
    $2[3] = t1;
  } else {
    t1 = $2[3];
  }
  let t2;
  if ($2[4] !== disabled || $2[5] !== showErrors || $2[6] !== widgetId) {
    t2 = widgetId === "multiline" && /* @__PURE__ */ jsxRuntimeExports.jsx(StringPropertyValidation, { disabled, length: true, lowercase: true, max: true, min: true, trim: true, uppercase: true, showErrors });
    $2[4] = disabled;
    $2[5] = showErrors;
    $2[6] = widgetId;
    $2[7] = t2;
  } else {
    t2 = $2[7];
  }
  let t3;
  if ($2[8] !== disabled || $2[9] !== showErrors || $2[10] !== widgetId) {
    t3 = widgetId === "email" && /* @__PURE__ */ jsxRuntimeExports.jsx(StringPropertyValidation, { disabled, max: true, min: true, trim: true, showErrors });
    $2[8] = disabled;
    $2[9] = showErrors;
    $2[10] = widgetId;
    $2[11] = t3;
  } else {
    t3 = $2[11];
  }
  let t4;
  if ($2[12] !== t1 || $2[13] !== t2 || $2[14] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ValidationPanel, { children: [
      t1,
      t2,
      t3
    ] }) });
    $2[12] = t1;
    $2[13] = t2;
    $2[14] = t3;
    $2[15] = t4;
  } else {
    t4 = $2[15];
  }
  let t5;
  if ($2[16] !== setFieldValue) {
    t5 = (e) => {
      setFieldValue("defaultValue", e.target.value === "" ? void 0 : e.target.value);
    };
    $2[16] = setFieldValue;
    $2[17] = t5;
  } else {
    t5 = $2[17];
  }
  let t6;
  if ($2[18] !== values) {
    t6 = getIn(values, "defaultValue") ?? "";
    $2[18] = values;
    $2[19] = t6;
  } else {
    t6 = $2[19];
  }
  let t7;
  if ($2[20] !== disabled || $2[21] !== t5 || $2[22] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$3, { name: "defaultValue", disabled, onChange: t5, label: "Default value", value: t6 }) });
    $2[20] = disabled;
    $2[21] = t5;
    $2[22] = t6;
    $2[23] = t7;
  } else {
    t7 = $2[23];
  }
  let t8;
  if ($2[24] !== t4 || $2[25] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t4,
      t7
    ] });
    $2[24] = t4;
    $2[25] = t7;
    $2[26] = t8;
  } else {
    t8 = $2[26];
  }
  return t8;
}
function BooleanPropertyField(t0) {
  const $2 = c_1(10);
  const {
    disabled
  } = t0;
  const {
    values
  } = useFormex();
  let t1;
  if ($2[0] !== values) {
    t1 = getIn(values, "defaultValue");
    $2[0] = values;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  const defaultValue = t1;
  let t2;
  if ($2[2] !== disabled) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ValidationPanel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(GeneralPropertyValidation, { disabled }) }) });
    $2[2] = disabled;
    $2[3] = t2;
  } else {
    t2 = $2[3];
  }
  let t3;
  if ($2[4] !== defaultValue || $2[5] !== disabled) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: "defaultValue", children: (t42) => {
      const {
        field,
        form
      } = t42;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchControl, { label: defaultValue === null || defaultValue === void 0 ? "Default value not set" : "Default value is " + defaultValue.toString(), disabled, allowIndeterminate: true, field, form });
    } }) });
    $2[4] = defaultValue;
    $2[5] = disabled;
    $2[6] = t3;
  } else {
    t3 = $2[6];
  }
  let t4;
  if ($2[7] !== t2 || $2[8] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t2,
      t3
    ] });
    $2[7] = t2;
    $2[8] = t3;
    $2[9] = t4;
  } else {
    t4 = $2[9];
  }
  return t4;
}
function BlockPropertyField(t0) {
  const $2 = c_1(56);
  const {
    disabled,
    getData,
    allowDataInference,
    propertyConfigs,
    collectionEditable
  } = t0;
  const {
    values,
    setFieldValue
  } = useFormex();
  const [propertyDialogOpen, setPropertyDialogOpen] = useState$3(false);
  const [selectedPropertyKey, setSelectedPropertyKey] = useState$3();
  const [selectedPropertyNamespace, setSelectedPropertyNamespace] = useState$3();
  let t1;
  if ($2[0] !== setFieldValue || $2[1] !== values.oneOf?.properties || $2[2] !== values.oneOf?.propertiesOrder) {
    t1 = (t22) => {
      const {
        id,
        namespace,
        property
      } = t22;
      if (!id) {
        throw Error();
      }
      setFieldValue("oneOf." + getFullIdPath(id, namespace), property, false);
      const currentPropertiesOrder = values.oneOf?.propertiesOrder ?? Object.keys(values.oneOf?.properties ?? {});
      const newPropertiesOrder = currentPropertiesOrder.includes(id) ? currentPropertiesOrder : [...currentPropertiesOrder, id];
      setFieldValue("oneOf." + namespaceToPropertiesOrderPath(namespace), newPropertiesOrder, false);
      setPropertyDialogOpen(false);
    };
    $2[0] = setFieldValue;
    $2[1] = values.oneOf?.properties;
    $2[2] = values.oneOf?.propertiesOrder;
    $2[3] = t1;
  } else {
    t1 = $2[3];
  }
  const onPropertyChanged = t1;
  let t2;
  if ($2[4] !== selectedPropertyKey || $2[5] !== selectedPropertyNamespace || $2[6] !== values.oneOf?.properties) {
    const selectedPropertyFullId = selectedPropertyKey ? getFullId(selectedPropertyKey, selectedPropertyNamespace) : void 0;
    t2 = selectedPropertyFullId ? getIn(values.oneOf?.properties, selectedPropertyFullId.replaceAll(".", ".properties.")) : void 0;
    $2[4] = selectedPropertyKey;
    $2[5] = selectedPropertyNamespace;
    $2[6] = values.oneOf?.properties;
    $2[7] = t2;
  } else {
    t2 = $2[7];
  }
  const selectedProperty = t2;
  let t3;
  if ($2[8] !== setFieldValue || $2[9] !== values) {
    t3 = (propertyKey, namespace_0) => {
      const fullId = propertyKey ? getFullId(propertyKey, namespace_0) : void 0;
      if (!fullId) {
        throw Error("collection editor miss config");
      }
      setFieldValue(`oneOf.${idToPropertiesPath(fullId)}`, void 0, false);
      const propertiesOrderPath = `oneOf.${namespaceToPropertiesOrderPath(namespace_0)}`;
      const currentPropertiesOrder_0 = getIn(values, propertiesOrderPath) ?? Object.keys(getIn(values, namespaceToPropertiesPath(namespace_0)));
      setFieldValue(propertiesOrderPath, currentPropertiesOrder_0.filter((p) => p !== propertyKey), false);
      setPropertyDialogOpen(false);
      setSelectedPropertyKey(void 0);
      setSelectedPropertyNamespace(void 0);
    };
    $2[8] = setFieldValue;
    $2[9] = values;
    $2[10] = t3;
  } else {
    t3 = $2[10];
  }
  const deleteProperty = t3;
  let t4;
  let t5;
  if ($2[11] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = () => setPropertyDialogOpen(true);
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon$1, {});
    $2[11] = t4;
    $2[12] = t5;
  } else {
    t4 = $2[11];
    t5 = $2[12];
  }
  const t6 = values.name ?? "this block";
  let t7;
  if ($2[13] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Button$3, { autoFocus: true, color: "primary", onClick: t4, startIcon: t5, children: [
      "Add property to ",
      t6
    ] });
    $2[13] = t6;
    $2[14] = t7;
  } else {
    t7 = $2[14];
  }
  const addChildButton = t7;
  let t8;
  if ($2[15] !== setFieldValue) {
    t8 = (propertiesOrder, namespace_1) => {
      setFieldValue(`oneOf.${namespaceToPropertiesOrderPath(namespace_1)}`, propertiesOrder, false);
    };
    $2[15] = setFieldValue;
    $2[16] = t8;
  } else {
    t8 = $2[16];
  }
  const onPropertyMove = t8;
  let t9;
  if ($2[17] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "subtitle2", children: "Properties in this block" });
    $2[17] = t9;
  } else {
    t9 = $2[17];
  }
  let t10;
  if ($2[18] !== addChildButton) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-end mt-8 mb-4", children: [
      t9,
      addChildButton
    ] });
    $2[18] = addChildButton;
    $2[19] = t10;
  } else {
    t10 = $2[19];
  }
  let t11;
  if ($2[20] !== values.oneOf?.properties) {
    t11 = values.oneOf?.properties ?? {};
    $2[20] = values.oneOf?.properties;
    $2[21] = t11;
  } else {
    t11 = $2[21];
  }
  const t12 = values.oneOf?.propertiesOrder;
  let t13;
  if ($2[22] === Symbol.for("react.memo_cache_sentinel")) {
    t13 = {};
    $2[22] = t13;
  } else {
    t13 = $2[22];
  }
  let t14;
  if ($2[23] !== disabled) {
    t14 = disabled ? void 0 : (propertyKey_0, namespace_2) => {
      setSelectedPropertyKey(propertyKey_0);
      setSelectedPropertyNamespace(namespace_2);
      setPropertyDialogOpen(true);
    };
    $2[23] = disabled;
    $2[24] = t14;
  } else {
    t14 = $2[24];
  }
  const t15 = disabled ? void 0 : onPropertyMove;
  let t16;
  if ($2[25] !== collectionEditable || $2[26] !== t11 || $2[27] !== t12 || $2[28] !== t14 || $2[29] !== t15) {
    t16 = /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyTree, { properties: t11, propertiesOrder: t12, errors: t13, collectionEditable, onPropertyClick: t14, onPropertyMove: t15 });
    $2[25] = collectionEditable;
    $2[26] = t11;
    $2[27] = t12;
    $2[28] = t14;
    $2[29] = t15;
    $2[30] = t16;
  } else {
    t16 = $2[30];
  }
  let t17;
  if ($2[31] !== disabled || $2[32] !== values.oneOf?.propertiesOrder?.length) {
    t17 = !disabled && values.oneOf?.propertiesOrder?.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-full flex items-center justify-center p-4", children: "Add the first property to this block" });
    $2[31] = disabled;
    $2[32] = values.oneOf?.propertiesOrder?.length;
    $2[33] = t17;
  } else {
    t17 = $2[33];
  }
  let t18;
  if ($2[34] !== t16 || $2[35] !== t17) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper$2, { className: "p-2 pl-8", children: [
      t16,
      t17
    ] });
    $2[34] = t16;
    $2[35] = t17;
    $2[36] = t18;
  } else {
    t18 = $2[36];
  }
  let t19;
  if ($2[37] !== t10 || $2[38] !== t18) {
    t19 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
      t10,
      t18
    ] });
    $2[37] = t10;
    $2[38] = t18;
    $2[39] = t19;
  } else {
    t19 = $2[39];
  }
  let t20;
  if ($2[40] !== allowDataInference || $2[41] !== collectionEditable || $2[42] !== deleteProperty || $2[43] !== disabled || $2[44] !== getData || $2[45] !== onPropertyChanged || $2[46] !== propertyConfigs || $2[47] !== propertyDialogOpen || $2[48] !== selectedProperty || $2[49] !== selectedPropertyKey || $2[50] !== selectedPropertyNamespace || $2[51] !== values.oneOf?.propertiesOrder) {
    t20 = !disabled && /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyFormDialog, { inArray: false, forceShowErrors: false, open: propertyDialogOpen, getData, allowDataInference, onCancel: () => {
      setPropertyDialogOpen(false);
      setSelectedPropertyKey(void 0);
      setSelectedPropertyNamespace(void 0);
    }, onOkClicked: () => {
      setPropertyDialogOpen(false);
      setSelectedPropertyKey(void 0);
      setSelectedPropertyNamespace(void 0);
    }, collectionEditable, onDelete: deleteProperty, propertyKey: selectedPropertyKey, propertyNamespace: selectedPropertyNamespace, property: selectedProperty, existingProperty: Boolean(selectedPropertyKey), autoUpdateId: !selectedPropertyKey, autoOpenTypeSelect: !selectedPropertyKey, onPropertyChanged, existingPropertyKeys: selectedPropertyKey ? void 0 : values.oneOf?.propertiesOrder, propertyConfigs });
    $2[40] = allowDataInference;
    $2[41] = collectionEditable;
    $2[42] = deleteProperty;
    $2[43] = disabled;
    $2[44] = getData;
    $2[45] = onPropertyChanged;
    $2[46] = propertyConfigs;
    $2[47] = propertyDialogOpen;
    $2[48] = selectedProperty;
    $2[49] = selectedPropertyKey;
    $2[50] = selectedPropertyNamespace;
    $2[51] = values.oneOf?.propertiesOrder;
    $2[52] = t20;
  } else {
    t20 = $2[52];
  }
  let t21;
  if ($2[53] !== t19 || $2[54] !== t20) {
    t21 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t19,
      t20
    ] });
    $2[53] = t19;
    $2[54] = t20;
    $2[55] = t21;
  } else {
    t21 = $2[55];
  }
  return t21;
}
function NumberPropertyValidation(t0) {
  const $2 = c_1(41);
  const {
    disabled
  } = t0;
  const {
    values,
    handleChange
  } = useFormex();
  let t1;
  if ($2[0] !== disabled) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(GeneralPropertyValidation, { disabled });
    $2[0] = disabled;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  let t2;
  if ($2[2] !== values) {
    t2 = getIn(values, "validation.min");
    $2[2] = values;
    $2[3] = t2;
  } else {
    t2 = $2[3];
  }
  let t3;
  if ($2[4] !== disabled || $2[5] !== handleChange || $2[6] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DebouncedTextField2, { value: t2, label: "Min value", name: "validation.min", type: "number", size: "small", disabled, onChange: handleChange }) });
    $2[4] = disabled;
    $2[5] = handleChange;
    $2[6] = t2;
    $2[7] = t3;
  } else {
    t3 = $2[7];
  }
  let t4;
  if ($2[8] !== values) {
    t4 = getIn(values, "validation.max");
    $2[8] = values;
    $2[9] = t4;
  } else {
    t4 = $2[9];
  }
  let t5;
  if ($2[10] !== disabled || $2[11] !== handleChange || $2[12] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DebouncedTextField2, { value: t4, label: "Max value", name: "validation.max", type: "number", size: "small", disabled, onChange: handleChange }) });
    $2[10] = disabled;
    $2[11] = handleChange;
    $2[12] = t4;
    $2[13] = t5;
  } else {
    t5 = $2[13];
  }
  let t6;
  if ($2[14] !== values) {
    t6 = getIn(values, "validation.lessThan");
    $2[14] = values;
    $2[15] = t6;
  } else {
    t6 = $2[15];
  }
  let t7;
  if ($2[16] !== disabled || $2[17] !== handleChange || $2[18] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DebouncedTextField2, { value: t6, label: "Less than", name: "validation.lessThan", type: "number", size: "small", disabled, onChange: handleChange }) });
    $2[16] = disabled;
    $2[17] = handleChange;
    $2[18] = t6;
    $2[19] = t7;
  } else {
    t7 = $2[19];
  }
  let t8;
  if ($2[20] !== values) {
    t8 = getIn(values, "validation.moreThan");
    $2[20] = values;
    $2[21] = t8;
  } else {
    t8 = $2[21];
  }
  let t9;
  if ($2[22] !== disabled || $2[23] !== handleChange || $2[24] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DebouncedTextField2, { value: t8, label: "More than", name: "validation.moreThan", type: "number", size: "small", disabled, onChange: handleChange }) });
    $2[22] = disabled;
    $2[23] = handleChange;
    $2[24] = t8;
    $2[25] = t9;
  } else {
    t9 = $2[25];
  }
  let t10;
  if ($2[26] !== disabled) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: "validation.positive", type: "checkbox", children: (t112) => {
      const {
        field,
        form
      } = t112;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchControl, { label: "Positive value", disabled, form, field });
    } }) });
    $2[26] = disabled;
    $2[27] = t10;
  } else {
    t10 = $2[27];
  }
  let t11;
  if ($2[28] !== disabled) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: "validation.negative", type: "checkbox", children: (t122) => {
      const {
        field: field_0,
        form: form_0
      } = t122;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchControl, { label: "Negative value", disabled, form: form_0, field: field_0 });
    } }) });
    $2[28] = disabled;
    $2[29] = t11;
  } else {
    t11 = $2[29];
  }
  let t12;
  if ($2[30] !== disabled) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: "validation.integer", type: "checkbox", children: (t132) => {
      const {
        field: field_1,
        form: form_1
      } = t132;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchControl, { label: "Integer value", disabled, form: form_1, field: field_1 });
    } }) });
    $2[30] = disabled;
    $2[31] = t12;
  } else {
    t12 = $2[31];
  }
  let t13;
  if ($2[32] !== t1 || $2[33] !== t10 || $2[34] !== t11 || $2[35] !== t12 || $2[36] !== t3 || $2[37] !== t5 || $2[38] !== t7 || $2[39] !== t9) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-12 gap-2", children: [
      t1,
      t3,
      t5,
      t7,
      t9,
      t10,
      t11,
      t12
    ] });
    $2[32] = t1;
    $2[33] = t10;
    $2[34] = t11;
    $2[35] = t12;
    $2[36] = t3;
    $2[37] = t5;
    $2[38] = t7;
    $2[39] = t9;
    $2[40] = t13;
  } else {
    t13 = $2[40];
  }
  return t13;
}
function NumberPropertyField(t0) {
  const $2 = c_1(13);
  const {
    disabled
  } = t0;
  const {
    values,
    setFieldValue
  } = useFormex();
  let t1;
  if ($2[0] !== disabled) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ValidationPanel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(NumberPropertyValidation, { disabled }) }) });
    $2[0] = disabled;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  let t2;
  if ($2[2] !== setFieldValue) {
    t2 = (e) => {
      setFieldValue("defaultValue", e.target.value === "" ? void 0 : parseFloat(e.target.value));
    };
    $2[2] = setFieldValue;
    $2[3] = t2;
  } else {
    t2 = $2[3];
  }
  let t3;
  if ($2[4] !== values) {
    t3 = getIn(values, "defaultValue") ?? "";
    $2[4] = values;
    $2[5] = t3;
  } else {
    t3 = $2[5];
  }
  let t4;
  if ($2[6] !== disabled || $2[7] !== t2 || $2[8] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$3, { name: "defaultValue", disabled, type: "number", onChange: t2, label: "Default value", value: t3 }) });
    $2[6] = disabled;
    $2[7] = t2;
    $2[8] = t3;
    $2[9] = t4;
  } else {
    t4 = $2[9];
  }
  let t5;
  if ($2[10] !== t1 || $2[11] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t1,
      t4
    ] });
    $2[10] = t1;
    $2[11] = t4;
    $2[12] = t5;
  } else {
    t5 = $2[12];
  }
  return t5;
}
function ReferencePropertyField(t0) {
  const $2 = c_1(14);
  const {
    existing,
    multiple,
    disabled,
    showErrors
  } = t0;
  const {
    values,
    handleChange,
    errors
  } = useFormex();
  const navigation = useNavigationController$3();
  if (!navigation) {
    let t12;
    if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
      t12 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress$2, {}) });
      $2[0] = t12;
    } else {
      t12 = $2[0];
    }
    return t12;
  }
  const pathPath = multiple ? "of.path" : "path";
  let t1;
  if ($2[1] !== pathPath || $2[2] !== values) {
    t1 = getIn(values, pathPath);
    $2[1] = pathPath;
    $2[2] = values;
    $2[3] = t1;
  } else {
    t1 = $2[3];
  }
  const pathValue = t1;
  let t2;
  if ($2[4] !== errors || $2[5] !== pathPath || $2[6] !== showErrors) {
    t2 = showErrors && getIn(errors, pathPath);
    $2[4] = errors;
    $2[5] = pathPath;
    $2[6] = showErrors;
    $2[7] = t2;
  } else {
    t2 = $2[7];
  }
  const pathError = t2;
  const t3 = existing && Boolean(pathValue) || disabled;
  let t4;
  if ($2[8] !== handleChange || $2[9] !== pathError || $2[10] !== pathPath || $2[11] !== pathValue || $2[12] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: pathPath, pathPath, type: "select", disabled: t3, value: pathValue, error: pathError, handleChange, as: CollectionsSelect }) }) });
    $2[8] = handleChange;
    $2[9] = pathError;
    $2[10] = pathPath;
    $2[11] = pathValue;
    $2[12] = t3;
    $2[13] = t4;
  } else {
    t4 = $2[13];
  }
  return t4;
}
function CollectionsSelect(t0) {
  const $2 = c_1(25);
  let disabled;
  let error;
  let handleChange;
  let pathPath;
  let props;
  let value;
  if ($2[0] !== t0) {
    ({
      disabled,
      pathPath,
      value,
      handleChange,
      error,
      ...props
    } = t0);
    $2[0] = t0;
    $2[1] = disabled;
    $2[2] = error;
    $2[3] = handleChange;
    $2[4] = pathPath;
    $2[5] = props;
    $2[6] = value;
  } else {
    disabled = $2[1];
    error = $2[2];
    handleChange = $2[3];
    pathPath = $2[4];
    props = $2[5];
    value = $2[6];
  }
  const navigation = useNavigationController$3();
  if (!navigation) {
    let t12;
    if ($2[7] === Symbol.for("react.memo_cache_sentinel")) {
      t12 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress$2, {}) });
      $2[7] = t12;
    } else {
      t12 = $2[7];
    }
    return t12;
  }
  let t1;
  if ($2[8] !== navigation?.collections) {
    t1 = navigation?.collections ?? [];
    $2[8] = navigation?.collections;
    $2[9] = t1;
  } else {
    t1 = $2[9];
  }
  const collections = t1;
  let t2;
  if ($2[10] !== collections || $2[11] !== disabled || $2[12] !== error || $2[13] !== handleChange || $2[14] !== pathPath || $2[15] !== props || $2[16] !== value) {
    const groups = Array.from(new Set(Object.values(collections).map(_temp$8$1).filter(Boolean)).values());
    const ungroupedCollections = collections.filter(_temp2$5);
    let t32;
    if ($2[18] !== collections) {
      t32 = (selected) => {
        const selectedCollection = collections.find((collection2) => collection2.id === selected || collection2.path === selected);
        if (!selectedCollection) {
          return null;
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconForView$1, { collectionOrView: selectedCollection }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "subtitle2", className: "font-medium ml-4", children: selectedCollection?.name.toUpperCase() })
        ] });
      };
      $2[18] = collections;
      $2[19] = t32;
    } else {
      t32 = $2[19];
    }
    let t42;
    if ($2[20] !== collections) {
      t42 = (group) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroup2, { label: group || "Views", children: collections.filter((collection_0) => collection_0.group === group).map((collection_1) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$1, { value: collection_1.id ?? collection_1.path, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IconForView$1, { collectionOrView: collection_1 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "subtitle2", className: "font-medium ml-4", children: collection_1?.name.toUpperCase() })
      ] }) }, `${collection_1.id ?? collection_1.path}-${group}`)) }, `group_${group}`);
      $2[20] = collections;
      $2[21] = t42;
    } else {
      t42 = $2[21];
    }
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Select$1, { error: Boolean(error), disabled, value: value ?? "", position: "item-aligned", name: pathPath, size: "large", fullWidth: true, onChange: handleChange, label: "Target collection", renderValue: t32, ...props, children: [
      groups.flatMap(t42),
      ungroupedCollections && /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroup2, { label: "Views", children: ungroupedCollections.map(_temp3$2) })
    ] });
    $2[10] = collections;
    $2[11] = disabled;
    $2[12] = error;
    $2[13] = handleChange;
    $2[14] = pathPath;
    $2[15] = props;
    $2[16] = value;
    $2[17] = t2;
  } else {
    t2 = $2[17];
  }
  let t3;
  if ($2[22] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption2, { children: "You can only edit the reference collection upon field creation." });
    $2[22] = t3;
  } else {
    t3 = $2[22];
  }
  let t4;
  if ($2[23] !== t2) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t2,
      t3
    ] });
    $2[23] = t2;
    $2[24] = t4;
  } else {
    t4 = $2[24];
  }
  return t4;
}
function _temp3$2(collection_2) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$1, { value: collection_2.id ?? collection_2.path, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IconForView$1, { collectionOrView: collection_2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "subtitle2", className: "font-medium ml-4", children: collection_2?.name.toUpperCase() })
  ] }) }, collection_2.id ?? collection_2.path);
}
function _temp2$5(col) {
  return !col.group;
}
function _temp$8$1(e) {
  return e.group;
}
function DateTimePropertyField(t0) {
  const $2 = c_1(49);
  const {
    disabled
  } = t0;
  const {
    values,
    errors,
    touched,
    setFieldValue
  } = useFormex();
  let t1;
  if ($2[0] !== values) {
    t1 = getIn(values, "mode");
    $2[0] = values;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  const modeValue = t1;
  let t2;
  if ($2[2] !== errors || $2[3] !== touched) {
    t2 = getIn(touched, "mode") && getIn(errors, "mode");
    $2[2] = errors;
    $2[3] = touched;
    $2[4] = t2;
  } else {
    t2 = $2[4];
  }
  const modeError = t2;
  let t3;
  if ($2[5] !== values) {
    t3 = getIn(values, "autoValue");
    $2[5] = values;
    $2[6] = t3;
  } else {
    t3 = $2[6];
  }
  const autoValueValue = t3;
  let t4;
  if ($2[7] !== errors || $2[8] !== touched) {
    t4 = getIn(touched, "autoValue") && getIn(errors, "autoValue");
    $2[7] = errors;
    $2[8] = touched;
    $2[9] = t4;
  } else {
    t4 = $2[9];
  }
  const autoValueError = t4;
  const t5 = modeValue ?? "date";
  const t6 = Boolean(modeError);
  let t7;
  if ($2[10] !== setFieldValue) {
    t7 = (v2) => setFieldValue("mode", v2);
    $2[10] = setFieldValue;
    $2[11] = t7;
  } else {
    t7 = $2[11];
  }
  let t8;
  let t9;
  if ($2[12] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$1, { value: "date_time", children: " Date/Time " });
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$1, { value: "date", children: " Date " });
    $2[12] = t8;
    $2[13] = t9;
  } else {
    t8 = $2[12];
    t9 = $2[13];
  }
  let t10;
  if ($2[14] !== disabled || $2[15] !== t5 || $2[16] !== t6 || $2[17] !== t7) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Select$1, { name: "mode", value: t5, error: t6, size: "large", onValueChange: t7, label: "Mode", fullWidth: true, renderValue: _temp$7$1, disabled, children: [
      t8,
      t9
    ] });
    $2[14] = disabled;
    $2[15] = t5;
    $2[16] = t6;
    $2[17] = t7;
    $2[18] = t10;
  } else {
    t10 = $2[18];
  }
  const t11 = Boolean(modeError);
  let t12;
  if ($2[19] !== modeError || $2[20] !== t11) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption2, { error: t11, children: modeError });
    $2[19] = modeError;
    $2[20] = t11;
    $2[21] = t12;
  } else {
    t12 = $2[21];
  }
  let t13;
  if ($2[22] !== t10 || $2[23] !== t12) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      t10,
      t12
    ] });
    $2[22] = t10;
    $2[23] = t12;
    $2[24] = t13;
  } else {
    t13 = $2[24];
  }
  const t14 = autoValueValue ?? "";
  let t15;
  if ($2[25] !== setFieldValue) {
    t15 = (v_1) => setFieldValue("autoValue", v_1 === "none" ? null : v_1);
    $2[25] = setFieldValue;
    $2[26] = t15;
  } else {
    t15 = $2[26];
  }
  const t16 = Boolean(autoValueError);
  let t17;
  let t18;
  let t19;
  if ($2[27] === Symbol.for("react.memo_cache_sentinel")) {
    t17 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$1, { value: "none", children: " None " });
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$1, { value: "on_create", children: " On create " });
    t19 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$1, { value: "on_update", children: " On any update " });
    $2[27] = t17;
    $2[28] = t18;
    $2[29] = t19;
  } else {
    t17 = $2[27];
    t18 = $2[28];
    t19 = $2[29];
  }
  let t20;
  if ($2[30] !== disabled || $2[31] !== t14 || $2[32] !== t15 || $2[33] !== t16) {
    t20 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Select$1, { name: "autoValue", disabled, size: "large", fullWidth: true, value: t14, onValueChange: t15, renderValue: _temp2$4, error: t16, label: "Automatic value", children: [
      t17,
      t18,
      t19
    ] });
    $2[30] = disabled;
    $2[31] = t14;
    $2[32] = t15;
    $2[33] = t16;
    $2[34] = t20;
  } else {
    t20 = $2[34];
  }
  const t21 = Boolean(autoValueError);
  const t22 = autoValueError ?? "Update this field automatically when creating or updating the entity";
  let t23;
  if ($2[35] !== t21 || $2[36] !== t22) {
    t23 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldCaption2, { error: t21, children: t22 });
    $2[35] = t21;
    $2[36] = t22;
    $2[37] = t23;
  } else {
    t23 = $2[37];
  }
  let t24;
  if ($2[38] !== t20 || $2[39] !== t23) {
    t24 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      t20,
      t23
    ] });
    $2[38] = t20;
    $2[39] = t23;
    $2[40] = t24;
  } else {
    t24 = $2[40];
  }
  let t25;
  if ($2[41] !== t13 || $2[42] !== t24) {
    t25 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col col-span-12 gap-2", children: [
      t13,
      t24
    ] });
    $2[41] = t13;
    $2[42] = t24;
    $2[43] = t25;
  } else {
    t25 = $2[43];
  }
  let t26;
  if ($2[44] !== disabled) {
    t26 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ValidationPanel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(GeneralPropertyValidation, { disabled }) }) });
    $2[44] = disabled;
    $2[45] = t26;
  } else {
    t26 = $2[45];
  }
  let t27;
  if ($2[46] !== t25 || $2[47] !== t26) {
    t27 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t25,
      t26
    ] });
    $2[46] = t25;
    $2[47] = t26;
    $2[48] = t27;
  } else {
    t27 = $2[48];
  }
  return t27;
}
function _temp2$4(v_2) {
  switch (v_2) {
    case "on_create": {
      return "On create";
    }
    case "on_update": {
      return "On any update";
    }
    default: {
      return "None";
    }
  }
}
function _temp$7$1(v_0) {
  switch (v_0) {
    case "date_time": {
      return "Date/Time";
    }
    case "date": {
      return "Date";
    }
    default: {
      return "";
    }
  }
}
function AdvancedPropertyValidation(t0) {
  const $2 = c_1(7);
  const {
    disabled
  } = t0;
  let t1;
  if ($2[0] !== disabled) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { type: "checkbox", name: "hideFromCollection", children: (t22) => {
      const {
        field,
        form
      } = t22;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchControl, { label: "Hide from collection", disabled, form, tooltip: "Hide this field from the collection view. It will still be visible in the form view", field });
    } }) });
    $2[0] = disabled;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  let t2;
  if ($2[2] !== disabled) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: "readOnly", type: "checkbox", children: (t32) => {
      const {
        field: field_0,
        form: form_0
      } = t32;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchControl, { label: "Read only", disabled, tooltip: "Is this a read only field. Display only as a preview", form: form_0, field: field_0 });
    } }) });
    $2[2] = disabled;
    $2[3] = t2;
  } else {
    t2 = $2[3];
  }
  let t3;
  if ($2[4] !== t1 || $2[5] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-12 gap-2", children: [
      t1,
      t2
    ] });
    $2[4] = t1;
    $2[5] = t2;
    $2[6] = t3;
  } else {
    t3 = $2[6];
  }
  return t3;
}
function KeyValuePropertyField(t0) {
  const $2 = c_1(2);
  const {
    disabled
  } = t0;
  let t1;
  if ($2[0] !== disabled) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ValidationPanel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(GeneralPropertyValidation, { disabled }) }) }) });
    $2[0] = disabled;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  return t1;
}
function updatePropertyFromWidget(propertyData, selectedWidgetId, propertyConfigs) {
  let updatedProperty;
  if (selectedWidgetId === "text_field") {
    updatedProperty = mergeDeep2(propertyData, {
      dataType: "string",
      propertyConfig: "text_field",
      editable: propertyData.editable !== void 0 ? propertyData.editable : true,
      storage: void 0,
      multiline: void 0,
      markdown: void 0,
      email: void 0,
      url: void 0,
      enumValues: void 0
    });
  } else if (selectedWidgetId === "multiline") {
    updatedProperty = mergeDeep2(propertyData, {
      dataType: "string",
      propertyConfig: "multiline",
      editable: propertyData.editable !== void 0 ? propertyData.editable : true,
      multiline: true,
      storage: void 0,
      markdown: void 0,
      email: void 0,
      url: void 0,
      enumValues: void 0
    });
  } else if (selectedWidgetId === "markdown") {
    updatedProperty = mergeDeep2(propertyData, {
      dataType: "string",
      propertyConfig: "markdown",
      editable: propertyData.editable !== void 0 ? propertyData.editable : true,
      storage: void 0,
      multiline: void 0,
      markdown: true,
      email: void 0,
      url: void 0
    });
  } else if (selectedWidgetId === "url") {
    updatedProperty = mergeDeep2(propertyData, {
      dataType: "string",
      propertyConfig: "url",
      editable: propertyData.editable !== void 0 ? propertyData.editable : true,
      storage: void 0,
      multiline: void 0,
      markdown: void 0,
      email: void 0,
      url: true,
      enumValues: void 0
    });
  } else if (selectedWidgetId === "email") {
    updatedProperty = mergeDeep2(propertyData, {
      dataType: "string",
      propertyConfig: "email",
      editable: propertyData.editable !== void 0 ? propertyData.editable : true,
      storage: void 0,
      multiline: void 0,
      markdown: void 0,
      email: true,
      url: void 0,
      enumValues: void 0
    });
  } else if (selectedWidgetId === "select") {
    updatedProperty = mergeDeep2(propertyData, {
      dataType: "string",
      propertyConfig: "select",
      editable: propertyData.editable !== void 0 ? propertyData.editable : true,
      storage: void 0,
      multiline: void 0,
      markdown: void 0,
      email: void 0,
      url: void 0,
      enumValues: propertyData.enumValues ?? []
    });
  } else if (selectedWidgetId === "multi_select") {
    updatedProperty = mergeDeep2(propertyData, {
      dataType: "array",
      propertyConfig: "multi_select",
      editable: propertyData.editable !== void 0 ? propertyData.editable : true,
      of: {
        dataType: "string",
        enumValues: propertyData.of?.enumValues ?? []
      }
    });
  } else if (selectedWidgetId === "number_input") {
    updatedProperty = mergeDeep2(propertyData, {
      dataType: "number",
      propertyConfig: "number_input",
      editable: propertyData.editable !== void 0 ? propertyData.editable : true,
      enumValues: void 0
    });
  } else if (selectedWidgetId === "number_select") {
    updatedProperty = mergeDeep2(propertyData, {
      dataType: "number",
      propertyConfig: "number_select",
      editable: propertyData.editable !== void 0 ? propertyData.editable : true,
      enumValues: propertyData.enumValues ?? []
    });
  } else if (selectedWidgetId === "multi_number_select") {
    updatedProperty = mergeDeep2(propertyData, {
      dataType: "array",
      propertyConfig: "multi_number_select",
      editable: propertyData.editable !== void 0 ? propertyData.editable : true,
      of: {
        dataType: "number",
        enumValues: propertyData.of?.enumValues ?? []
      }
    });
  } else if (selectedWidgetId === "file_upload") {
    updatedProperty = mergeDeep2(propertyData, {
      dataType: "string",
      propertyConfig: "file_upload",
      editable: propertyData.editable !== void 0 ? propertyData.editable : true,
      storage: {
        storagePath: "/"
      }
    });
  } else if (selectedWidgetId === "multi_file_upload") {
    updatedProperty = mergeDeep2(propertyData, {
      dataType: "array",
      propertyConfig: "multi_file_upload",
      editable: propertyData.editable !== void 0 ? propertyData.editable : true,
      of: {
        dataType: "string",
        storage: propertyData.of?.storage ?? {
          storagePath: "/"
        }
      }
    });
  } else if (selectedWidgetId === "group") {
    updatedProperty = mergeDeep2(propertyData, {
      dataType: "map",
      propertyConfig: "group",
      editable: propertyData.editable !== void 0 ? propertyData.editable : true,
      keyValue: false,
      properties: propertyData.properties ?? {}
    });
  } else if (selectedWidgetId === "key_value") {
    updatedProperty = mergeDeep2(propertyData, {
      dataType: "map",
      propertyConfig: "key_value",
      editable: propertyData.editable !== void 0 ? propertyData.editable : true,
      keyValue: true,
      properties: void 0
    });
  } else if (selectedWidgetId === "reference") {
    updatedProperty = mergeDeep2(propertyData, {
      dataType: "reference",
      propertyConfig: "reference",
      editable: propertyData.editable !== void 0 ? propertyData.editable : true
    });
  } else if (selectedWidgetId === "multi_references") {
    updatedProperty = mergeDeep2(propertyData, {
      dataType: "array",
      propertyConfig: "multi_references",
      editable: propertyData.editable !== void 0 ? propertyData.editable : true,
      of: {
        dataType: "reference"
      }
    });
  } else if (selectedWidgetId === "switch") {
    updatedProperty = mergeDeep2(propertyData, {
      dataType: "boolean",
      propertyConfig: "switch",
      editable: propertyData.editable !== void 0 ? propertyData.editable : true
    });
  } else if (selectedWidgetId === "date_time") {
    updatedProperty = mergeDeep2(propertyData, {
      dataType: "date",
      propertyConfig: "date_time",
      editable: propertyData.editable !== void 0 ? propertyData.editable : true,
      mode: "date_time"
    });
  } else if (selectedWidgetId === "repeat") {
    updatedProperty = mergeDeep2(propertyData, {
      dataType: "array",
      propertyConfig: "repeat",
      editable: propertyData.editable !== void 0 ? propertyData.editable : true
    });
  } else if (selectedWidgetId === "block") {
    updatedProperty = mergeDeep2(propertyData, {
      dataType: "array",
      propertyConfig: "block",
      editable: propertyData.editable !== void 0 ? propertyData.editable : true,
      oneOf: {
        properties: {}
      }
    });
  } else if (selectedWidgetId && propertyConfigs[selectedWidgetId]) {
    updatedProperty = {
      ...propertyConfigs[selectedWidgetId].property,
      propertyConfig: selectedWidgetId
    };
  }
  return updatedProperty;
}
function UrlPropertyField(t0) {
  const $2 = c_1(27);
  const {
    disabled,
    showErrors
  } = t0;
  const {
    values,
    setFieldValue
  } = useFormex();
  let t1;
  if ($2[0] !== values) {
    t1 = getIn(values, "url");
    $2[0] = values;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  const urlValue = t1;
  let t2;
  if ($2[2] !== setFieldValue) {
    t2 = (value) => {
      if (value === "[NONE]") {
        setFieldValue("url", true);
      } else {
        setFieldValue("url", value);
      }
    };
    $2[2] = setFieldValue;
    $2[3] = t2;
  } else {
    t2 = $2[3];
  }
  const t3 = urlValue ?? "[NONE]";
  let t4;
  let t5;
  let t6;
  let t7;
  if ($2[4] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$1, { value: "[NONE]", children: "Display URL" });
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$1, { value: "image", children: "Image" });
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$1, { value: "video", children: "Video" });
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$1, { value: "audio", children: "Audio" });
    $2[4] = t4;
    $2[5] = t5;
    $2[6] = t6;
    $2[7] = t7;
  } else {
    t4 = $2[4];
    t5 = $2[5];
    t6 = $2[6];
    t7 = $2[7];
  }
  let t8;
  if ($2[8] !== disabled || $2[9] !== t2 || $2[10] !== t3) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Select$1, { disabled, position: "item-aligned", fullWidth: true, onValueChange: t2, label: "Preview type", renderValue: _temp$6$1, value: t3, children: [
      t4,
      t5,
      t6,
      t7
    ] }) });
    $2[8] = disabled;
    $2[9] = t2;
    $2[10] = t3;
    $2[11] = t8;
  } else {
    t8 = $2[11];
  }
  let t9;
  if ($2[12] !== disabled || $2[13] !== showErrors) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ValidationPanel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(StringPropertyValidation, { disabled, max: true, min: true, trim: true, showErrors }) }) });
    $2[12] = disabled;
    $2[13] = showErrors;
    $2[14] = t9;
  } else {
    t9 = $2[14];
  }
  let t10;
  if ($2[15] !== setFieldValue) {
    t10 = (e) => {
      setFieldValue("defaultValue", e.target.value === "" ? void 0 : e.target.value);
    };
    $2[15] = setFieldValue;
    $2[16] = t10;
  } else {
    t10 = $2[16];
  }
  let t11;
  if ($2[17] !== values) {
    t11 = getIn(values, "defaultValue") ?? "";
    $2[17] = values;
    $2[18] = t11;
  } else {
    t11 = $2[18];
  }
  let t12;
  if ($2[19] !== disabled || $2[20] !== t10 || $2[21] !== t11) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$3, { name: "defaultValue", disabled, onChange: t10, label: "Default value", value: t11 }) });
    $2[19] = disabled;
    $2[20] = t10;
    $2[21] = t11;
    $2[22] = t12;
  } else {
    t12 = $2[22];
  }
  let t13;
  if ($2[23] !== t12 || $2[24] !== t8 || $2[25] !== t9) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t8,
      t9,
      t12
    ] });
    $2[23] = t12;
    $2[24] = t8;
    $2[25] = t9;
    $2[26] = t13;
  } else {
    t13 = $2[26];
  }
  return t13;
}
function _temp$6$1(value_0) {
  switch (value_0) {
    case "image": {
      return "Image";
    }
    case "video": {
      return "Video";
    }
    case "audio": {
      return "Audio";
    }
    default: {
      return "Display URL";
    }
  }
}
const supportedFieldsIds = ["text_field", "multiline", "markdown", "url", "email", "select", "multi_select", "number_input", "number_select", "multi_number_select", "file_upload", "multi_file_upload", "reference", "multi_references", "switch", "date_time", "group", "key_value", "repeat", "block"];
const supportedFields = Object.entries(DEFAULT_FIELD_CONFIGS2).filter(([id]) => supportedFieldsIds.includes(id)).map(([id, config2]) => ({
  [id]: config2
})).reduce((a, b) => ({
  ...a,
  ...b
}), {});
function MarkdownPropertyField(t0) {
  const $2 = c_1(74);
  const {
    disabled,
    showErrors
  } = t0;
  const {
    values,
    setFieldValue
  } = useFormex();
  const fileName = `${"storage"}.fileName`;
  const maxSize = `${"storage"}.maxSize`;
  const storagePath = `${"storage"}.storagePath`;
  let t1;
  if ($2[0] !== values) {
    t1 = getIn(values, fileName) ?? "{rand}_{file}";
    $2[0] = values;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  const fileNameValue = t1;
  let t2;
  if ($2[2] !== values) {
    t2 = getIn(values, storagePath) ?? "/";
    $2[2] = values;
    $2[3] = t2;
  } else {
    t2 = $2[3];
  }
  const storagePathValue = t2;
  let T0;
  let T1;
  let t10;
  let t11;
  let t12;
  let t13;
  let t14;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  if ($2[4] !== disabled || $2[5] !== fileNameValue || $2[6] !== showErrors || $2[7] !== storagePathValue || $2[8] !== values) {
    const maxSizeValue = getIn(values, maxSize);
    const hasFilenameCallback = typeof fileNameValue === "function";
    const hasStoragePathCallback = typeof storagePathValue === "function";
    if ($2[23] !== disabled || $2[24] !== showErrors) {
      t14 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ValidationPanel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(StringPropertyValidation, { disabled, length: true, lowercase: true, max: true, min: true, trim: true, uppercase: true, showErrors }) }) });
      $2[23] = disabled;
      $2[24] = showErrors;
      $2[25] = t14;
    } else {
      t14 = $2[25];
    }
    t13 = "col-span-12";
    T1 = ExpandablePanel2;
    if ($2[26] === Symbol.for("react.memo_cache_sentinel")) {
      t12 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row text-surface-500", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CloudUploadIcon2, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "subtitle2", className: "ml-2", children: "File upload config" })
      ] });
      $2[26] = t12;
    } else {
      t12 = $2[26];
    }
    t9 = "grid grid-cols-12 gap-2 p-4";
    const t152 = hasFilenameCallback || disabled;
    const t162 = hasFilenameCallback ? "-" : fileNameValue;
    if ($2[27] !== t152 || $2[28] !== t162) {
      t10 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: fileName, as: DebouncedTextField2, label: "File name", size: "small", disabled: t152, value: t162 }) });
      $2[27] = t152;
      $2[28] = t162;
      $2[29] = t10;
    } else {
      t10 = $2[29];
    }
    const t172 = hasStoragePathCallback || disabled;
    const t182 = hasStoragePathCallback ? "-" : storagePathValue;
    let t192;
    if ($2[30] !== t172 || $2[31] !== t182) {
      t192 = /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: storagePath, as: DebouncedTextField2, label: "Storage path", disabled: t172, size: "small", value: t182 });
      $2[30] = t172;
      $2[31] = t182;
      $2[32] = t192;
    } else {
      t192 = $2[32];
    }
    let t202;
    let t212;
    if ($2[33] === Symbol.for("react.memo_cache_sentinel")) {
      t202 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography$3, { variant: "caption", className: "ml-3.5 mt-1 mb-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "You can use the following placeholders in the file name and storage path values:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "{file} - Full name of the uploaded file" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "{file.name} - Name of the uploaded file without extension" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "{file.ext} - Extension of the uploaded file" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "{entityId} - ID of the entity" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "{propertyKey} - ID of this field" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "{path} - Path of this entity" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "{rand} - Random value used to avoid name collisions" })
        ] })
      ] });
      t212 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "caption", className: "ml-3.5 mt-1 mb-2", children: "When using Markdown, the URL of the uploaded files are always saved in the text value (not the path)." });
      $2[33] = t202;
      $2[34] = t212;
    } else {
      t202 = $2[33];
      t212 = $2[34];
    }
    if ($2[35] !== t192) {
      t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12", children: [
        t192,
        t202,
        t212
      ] });
      $2[35] = t192;
      $2[36] = t11;
    } else {
      t11 = $2[36];
    }
    t8 = "col-span-12";
    T0 = DebouncedTextField2;
    t3 = maxSize;
    t4 = "number";
    t5 = "Max size (in bytes)";
    t6 = "small";
    t7 = maxSizeValue !== void 0 && maxSizeValue !== null ? maxSizeValue.toString() : "";
    $2[4] = disabled;
    $2[5] = fileNameValue;
    $2[6] = showErrors;
    $2[7] = storagePathValue;
    $2[8] = values;
    $2[9] = T0;
    $2[10] = T1;
    $2[11] = t10;
    $2[12] = t11;
    $2[13] = t12;
    $2[14] = t13;
    $2[15] = t14;
    $2[16] = t3;
    $2[17] = t4;
    $2[18] = t5;
    $2[19] = t6;
    $2[20] = t7;
    $2[21] = t8;
    $2[22] = t9;
  } else {
    T0 = $2[9];
    T1 = $2[10];
    t10 = $2[11];
    t11 = $2[12];
    t12 = $2[13];
    t13 = $2[14];
    t14 = $2[15];
    t3 = $2[16];
    t4 = $2[17];
    t5 = $2[18];
    t6 = $2[19];
    t7 = $2[20];
    t8 = $2[21];
    t9 = $2[22];
  }
  let t15;
  if ($2[37] !== setFieldValue) {
    t15 = (e) => {
      const value = e.target.value;
      if (value === "") {
        setFieldValue(maxSize, void 0);
      } else {
        setFieldValue(maxSize, parseInt(value));
      }
    };
    $2[37] = setFieldValue;
    $2[38] = t15;
  } else {
    t15 = $2[38];
  }
  let t16;
  if ($2[39] !== T0 || $2[40] !== t15 || $2[41] !== t3 || $2[42] !== t4 || $2[43] !== t5 || $2[44] !== t6 || $2[45] !== t7) {
    t16 = /* @__PURE__ */ jsxRuntimeExports.jsx(T0, { name: t3, type: t4, label: t5, size: t6, value: t7, onChange: t15 });
    $2[39] = T0;
    $2[40] = t15;
    $2[41] = t3;
    $2[42] = t4;
    $2[43] = t5;
    $2[44] = t6;
    $2[45] = t7;
    $2[46] = t16;
  } else {
    t16 = $2[46];
  }
  let t17;
  if ($2[47] !== t16 || $2[48] !== t8) {
    t17 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t8, children: t16 });
    $2[47] = t16;
    $2[48] = t8;
    $2[49] = t17;
  } else {
    t17 = $2[49];
  }
  let t18;
  if ($2[50] !== t10 || $2[51] !== t11 || $2[52] !== t17 || $2[53] !== t9) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t9, children: [
      t10,
      t11,
      t17
    ] });
    $2[50] = t10;
    $2[51] = t11;
    $2[52] = t17;
    $2[53] = t9;
    $2[54] = t18;
  } else {
    t18 = $2[54];
  }
  let t19;
  if ($2[55] !== T1 || $2[56] !== t12 || $2[57] !== t18) {
    t19 = /* @__PURE__ */ jsxRuntimeExports.jsx(T1, { title: t12, children: t18 });
    $2[55] = T1;
    $2[56] = t12;
    $2[57] = t18;
    $2[58] = t19;
  } else {
    t19 = $2[58];
  }
  let t20;
  if ($2[59] !== t13 || $2[60] !== t19) {
    t20 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t13, children: t19 });
    $2[59] = t13;
    $2[60] = t19;
    $2[61] = t20;
  } else {
    t20 = $2[61];
  }
  let t21;
  if ($2[62] !== setFieldValue) {
    t21 = (e_0) => {
      setFieldValue("defaultValue", e_0.target.value === "" ? void 0 : e_0.target.value);
    };
    $2[62] = setFieldValue;
    $2[63] = t21;
  } else {
    t21 = $2[63];
  }
  let t22;
  if ($2[64] !== values) {
    t22 = getIn(values, "defaultValue") ?? "";
    $2[64] = values;
    $2[65] = t22;
  } else {
    t22 = $2[65];
  }
  let t23;
  if ($2[66] !== disabled || $2[67] !== t21 || $2[68] !== t22) {
    t23 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$3, { name: "defaultValue", disabled, onChange: t21, label: "Default value", value: t22 }) });
    $2[66] = disabled;
    $2[67] = t21;
    $2[68] = t22;
    $2[69] = t23;
  } else {
    t23 = $2[69];
  }
  let t24;
  if ($2[70] !== t14 || $2[71] !== t20 || $2[72] !== t23) {
    t24 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t14,
      t20,
      t23
    ] });
    $2[70] = t14;
    $2[71] = t20;
    $2[72] = t23;
    $2[73] = t24;
  } else {
    t24 = $2[73];
  }
  return t24;
}
const PropertyForm = React__default.memo(function PropertyForm2(props) {
  const $2 = c_1(49);
  const {
    includeIdAndName: t0,
    autoOpenTypeSelect,
    existingProperty,
    autoUpdateId,
    inArray,
    propertyKey,
    existingPropertyKeys,
    propertyNamespace,
    property,
    onPropertyChanged,
    onPropertyChangedImmediate: t1,
    onDismiss,
    onDelete,
    onError,
    initialErrors,
    forceShowErrors,
    allowDataInference,
    getController,
    getData,
    propertyConfigs,
    collectionEditable
  } = props;
  const includeIdAndName = t0 === void 0 ? true : t0;
  const onPropertyChangedImmediate = t1 === void 0 ? true : t1;
  let t2;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = {
      id: "",
      name: ""
    };
    $2[0] = t2;
  } else {
    t2 = $2[0];
  }
  const initialValue = t2;
  let t3;
  if ($2[1] !== collectionEditable || $2[2] !== property) {
    t3 = Boolean(property && !editableProperty(property)) && !collectionEditable;
    $2[1] = collectionEditable;
    $2[2] = property;
    $2[3] = t3;
  } else {
    t3 = $2[3];
  }
  const disabled = t3;
  let t4;
  if ($2[4] !== property || $2[5] !== propertyKey) {
    t4 = property ? {
      id: propertyKey,
      previousId: propertyKey,
      property
    } : void 0;
    $2[4] = property;
    $2[5] = propertyKey;
    $2[6] = t4;
  } else {
    t4 = $2[6];
  }
  const lastSubmittedProperty = useRef$3(t4);
  let t5;
  if ($2[7] !== onPropertyChanged || $2[8] !== propertyNamespace) {
    t5 = (t62) => {
      const {
        id,
        property: property_0
      } = t62;
      const params = {
        id,
        previousId: lastSubmittedProperty.current?.id,
        property: property_0,
        namespace: propertyNamespace
      };
      lastSubmittedProperty.current = params;
      onPropertyChanged?.(params);
    };
    $2[7] = onPropertyChanged;
    $2[8] = propertyNamespace;
    $2[9] = t5;
  } else {
    t5 = $2[9];
  }
  const doOnPropertyChanged = t5;
  let t6;
  if ($2[10] !== property || $2[11] !== propertyKey) {
    t6 = property ? {
      id: propertyKey,
      ...property
    } : initialValue;
    $2[10] = property;
    $2[11] = propertyKey;
    $2[12] = t6;
  } else {
    t6 = $2[12];
  }
  let t7;
  if ($2[13] !== doOnPropertyChanged || $2[14] !== existingProperty) {
    t7 = (newPropertyWithId, controller) => {
      console.debug("onSubmit", newPropertyWithId);
      const {
        id: id_0,
        ...property_1
      } = newPropertyWithId;
      doOnPropertyChanged({
        id: id_0,
        property: {
          ...property_1,
          editable: property_1.editable ?? true
        }
      });
      if (!existingProperty) {
        controller.resetForm({
          values: initialValue
        });
      }
    };
    $2[13] = doOnPropertyChanged;
    $2[14] = existingProperty;
    $2[15] = t7;
  } else {
    t7 = $2[15];
  }
  let t8;
  if ($2[16] !== existingPropertyKeys || $2[17] !== includeIdAndName) {
    t8 = (values) => {
      const errors = {};
      if (includeIdAndName) {
        if (!values.name) {
          errors.name = "Required";
        } else {
          const nameError = validateName(values.name);
          if (nameError) {
            errors.name = nameError;
          }
        }
        if (!values.id) {
          errors.id = "Required";
        } else {
          const idError = validateId$1(values.id, existingPropertyKeys);
          if (idError) {
            errors.id = idError;
          }
        }
      }
      if (values.dataType === "string") {
        if (values.validation?.matches && !isValidRegExp2(values.validation?.matches.toString())) {
          errors.validation = {
            matches: "Invalid regular expression"
          };
        }
      }
      if (values.dataType === "reference" && !values.path) {
        errors.path = "You must specify a target collection for the field";
      }
      if (values.propertyConfig === "repeat") {
        if (!values.of) {
          errors.of = "You need to specify a repeat field";
        }
      }
      if (values.propertyConfig === "block") {
        if (!values.oneOf) {
          errors.oneOf = "You need to specify the properties of this block";
        }
      }
      return errors;
    };
    $2[16] = existingPropertyKeys;
    $2[17] = includeIdAndName;
    $2[18] = t8;
  } else {
    t8 = $2[18];
  }
  let t9;
  if ($2[19] !== initialErrors || $2[20] !== t6 || $2[21] !== t7 || $2[22] !== t8) {
    t9 = {
      debugId: "PROPERTY_FORM",
      initialValues: t6,
      initialErrors,
      validateOnChange: true,
      validateOnInitialRender: true,
      onSubmit: t7,
      validation: t8
    };
    $2[19] = initialErrors;
    $2[20] = t6;
    $2[21] = t7;
    $2[22] = t8;
    $2[23] = t9;
  } else {
    t9 = $2[23];
  }
  const formexController = useCreateFormex(t9);
  let t10;
  let t11;
  if ($2[24] !== formexController || $2[25] !== getController) {
    t10 = () => {
      getController?.(formexController);
    };
    t11 = [formexController, getController];
    $2[24] = formexController;
    $2[25] = getController;
    $2[26] = t10;
    $2[27] = t11;
  } else {
    t10 = $2[26];
    t11 = $2[27];
  }
  useEffect$4(t10, t11);
  const t12 = onPropertyChangedImmediate ? doOnPropertyChanged : void 0;
  const t13 = forceShowErrors || formexController.submitCount > 0;
  let t14;
  if ($2[28] !== allowDataInference || $2[29] !== autoOpenTypeSelect || $2[30] !== autoUpdateId || $2[31] !== collectionEditable || $2[32] !== disabled || $2[33] !== existingProperty || $2[34] !== formexController || $2[35] !== getData || $2[36] !== inArray || $2[37] !== includeIdAndName || $2[38] !== onDelete || $2[39] !== onDismiss || $2[40] !== onError || $2[41] !== propertyConfigs || $2[42] !== propertyNamespace || $2[43] !== t12 || $2[44] !== t13) {
    t14 = /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyEditFormFields, { onPropertyChanged: t12, onDelete, includeIdAndTitle: includeIdAndName, propertyNamespace, onError, onDismiss, showErrors: t13, existing: existingProperty, autoUpdateId, inArray, autoOpenTypeSelect, disabled, getData, allowDataInference, propertyConfigs, collectionEditable, ...formexController });
    $2[28] = allowDataInference;
    $2[29] = autoOpenTypeSelect;
    $2[30] = autoUpdateId;
    $2[31] = collectionEditable;
    $2[32] = disabled;
    $2[33] = existingProperty;
    $2[34] = formexController;
    $2[35] = getData;
    $2[36] = inArray;
    $2[37] = includeIdAndName;
    $2[38] = onDelete;
    $2[39] = onDismiss;
    $2[40] = onError;
    $2[41] = propertyConfigs;
    $2[42] = propertyNamespace;
    $2[43] = t12;
    $2[44] = t13;
    $2[45] = t14;
  } else {
    t14 = $2[45];
  }
  let t15;
  if ($2[46] !== formexController || $2[47] !== t14) {
    t15 = /* @__PURE__ */ jsxRuntimeExports.jsx(Formex, { value: formexController, children: t14 });
    $2[46] = formexController;
    $2[47] = t14;
    $2[48] = t15;
  } else {
    t15 = $2[48];
  }
  return t15;
}, (a, b) => a.getData === b.getData && a.propertyKey === b.propertyKey && a.propertyNamespace === b.propertyNamespace && a.includeIdAndName === b.includeIdAndName && a.autoOpenTypeSelect === b.autoOpenTypeSelect && a.autoUpdateId === b.autoUpdateId && a.existingPropertyKeys === b.existingPropertyKeys && a.existingProperty === b.existingProperty);
function PropertyFormDialog(t0) {
  const $2 = c_1(31);
  let collectionEditable;
  let formProps;
  let getData;
  let onCancel;
  let onOkClicked;
  let onPropertyChanged;
  let open;
  if ($2[0] !== t0) {
    ({
      open,
      onCancel,
      onOkClicked,
      onPropertyChanged,
      getData,
      collectionEditable,
      ...formProps
    } = t0);
    $2[0] = t0;
    $2[1] = collectionEditable;
    $2[2] = formProps;
    $2[3] = getData;
    $2[4] = onCancel;
    $2[5] = onOkClicked;
    $2[6] = onPropertyChanged;
    $2[7] = open;
  } else {
    collectionEditable = $2[1];
    formProps = $2[2];
    getData = $2[3];
    onCancel = $2[4];
    onOkClicked = $2[5];
    onPropertyChanged = $2[6];
    open = $2[7];
  }
  const formexRef = useRef$3();
  let t1;
  if ($2[8] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (helpers) => {
      formexRef.current = helpers;
    };
    $2[8] = t1;
  } else {
    t1 = $2[8];
  }
  const getController = t1;
  const t2 = open ?? false;
  let t3;
  let t4;
  if ($2[9] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = (e) => {
      e.preventDefault();
      e.stopPropagation();
      formexRef.current?.handleSubmit(e);
    };
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle$2, { hidden: true, children: "Property edit view" });
    $2[9] = t3;
    $2[10] = t4;
  } else {
    t3 = $2[9];
    t4 = $2[10];
  }
  let t5;
  if ($2[11] !== onOkClicked || $2[12] !== onPropertyChanged) {
    t5 = (params) => {
      onPropertyChanged?.(params);
      onOkClicked?.();
    };
    $2[11] = onOkClicked;
    $2[12] = onPropertyChanged;
    $2[13] = t5;
  } else {
    t5 = $2[13];
  }
  let t6;
  if ($2[14] !== collectionEditable || $2[15] !== formProps || $2[16] !== getData || $2[17] !== onCancel || $2[18] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent$2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyForm, { ...formProps, onDismiss: onCancel, onPropertyChanged: t5, collectionEditable, onPropertyChangedImmediate: false, getController, getData }) });
    $2[14] = collectionEditable;
    $2[15] = formProps;
    $2[16] = getData;
    $2[17] = onCancel;
    $2[18] = t5;
    $2[19] = t6;
  } else {
    t6 = $2[19];
  }
  let t7;
  if ($2[20] !== onCancel) {
    t7 = onCancel && /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { variant: "text", onClick: () => {
      onCancel();
      formexRef.current?.resetForm();
    }, children: "Cancel" });
    $2[20] = onCancel;
    $2[21] = t7;
  } else {
    t7 = $2[21];
  }
  let t8;
  if ($2[22] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { variant: "outlined", type: "submit", color: "primary", children: "Ok" });
    $2[22] = t8;
  } else {
    t8 = $2[22];
  }
  let t9;
  if ($2[23] !== t7) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions$1, { children: [
      t7,
      t8
    ] });
    $2[23] = t7;
    $2[24] = t9;
  } else {
    t9 = $2[24];
  }
  let t10;
  if ($2[25] !== t6 || $2[26] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { noValidate: true, autoComplete: "off", onSubmit: t3, children: [
      t4,
      t6,
      t9
    ] });
    $2[25] = t6;
    $2[26] = t9;
    $2[27] = t10;
  } else {
    t10 = $2[27];
  }
  let t11;
  if ($2[28] !== t10 || $2[29] !== t2) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog$2, { open: t2, maxWidth: "xl", fullWidth: true, children: t10 });
    $2[28] = t10;
    $2[29] = t2;
    $2[30] = t11;
  } else {
    t11 = $2[30];
  }
  return t11;
}
function PropertyEditFormFields(t0) {
  const $2 = c_1(142);
  const {
    values,
    errors,
    setValues,
    existing,
    autoUpdateId: t1,
    autoOpenTypeSelect,
    includeIdAndTitle,
    onPropertyChanged,
    onDelete,
    propertyNamespace,
    onDismiss,
    onError,
    showErrors,
    disabled,
    inArray,
    getData,
    allowDataInference,
    propertyConfigs,
    collectionEditable
  } = t0;
  const autoUpdateId = t1 === void 0 ? false : t1;
  const [selectOpen, setSelectOpen] = useState$3(autoOpenTypeSelect);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState$3(false);
  let t2;
  if ($2[0] !== values) {
    t2 = values?.dataType ? getFieldId$1(values) : void 0;
    $2[0] = values;
    $2[1] = t2;
  } else {
    t2 = $2[1];
  }
  const [selectedFieldConfigId, setSelectedFieldConfigId] = useState$3(t2);
  const deferredValues = useDeferredValue$2(values);
  const nameFieldRef = useRef$3(null);
  const lastSubmittedProperty = useRef$3(values);
  let t3;
  if ($2[2] !== errors || $2[3] !== showErrors) {
    t3 = showErrors && getIn(errors, "selectedWidget");
    $2[2] = errors;
    $2[3] = showErrors;
    $2[4] = t3;
  } else {
    t3 = $2[4];
  }
  const selectedWidgetError = t3;
  let t4;
  if ($2[5] !== deferredValues || $2[6] !== includeIdAndTitle || $2[7] !== onPropertyChanged || $2[8] !== propertyNamespace) {
    t4 = () => {
      if (onPropertyChanged) {
        if (!includeIdAndTitle || deferredValues.id) {
          const {
            id,
            ...property
          } = deferredValues;
          if (!equal(deferredValues, lastSubmittedProperty.current)) {
            onPropertyChanged({
              id,
              property,
              namespace: propertyNamespace
            });
            lastSubmittedProperty.current = deferredValues;
          }
        }
      }
    };
    $2[5] = deferredValues;
    $2[6] = includeIdAndTitle;
    $2[7] = onPropertyChanged;
    $2[8] = propertyNamespace;
    $2[9] = t4;
  } else {
    t4 = $2[9];
  }
  let t5;
  if ($2[10] !== deferredValues || $2[11] !== includeIdAndTitle || $2[12] !== propertyNamespace) {
    t5 = [deferredValues, includeIdAndTitle, propertyNamespace];
    $2[10] = deferredValues;
    $2[11] = includeIdAndTitle;
    $2[12] = propertyNamespace;
    $2[13] = t5;
  } else {
    t5 = $2[13];
  }
  useEffect$4(t4, t5);
  let t6;
  if ($2[14] !== errors || $2[15] !== onError || $2[16] !== propertyNamespace || $2[17] !== values?.id) {
    t6 = () => {
      if (values?.id && onError && !isEmptyObject2(errors)) {
        onError(values?.id, propertyNamespace, errors);
      }
    };
    $2[14] = errors;
    $2[15] = onError;
    $2[16] = propertyNamespace;
    $2[17] = values?.id;
    $2[18] = t6;
  } else {
    t6 = $2[18];
  }
  const t7 = values?.id;
  let t8;
  if ($2[19] !== errors || $2[20] !== propertyNamespace || $2[21] !== t7) {
    t8 = [errors, propertyNamespace, t7];
    $2[19] = errors;
    $2[20] = propertyNamespace;
    $2[21] = t7;
    $2[22] = t8;
  } else {
    t8 = $2[22];
  }
  useEffect$4(t6, t8);
  let t9;
  if ($2[23] !== propertyConfigs || $2[24] !== setValues || $2[25] !== values) {
    t9 = (newSelectedWidgetId) => {
      setSelectedFieldConfigId(newSelectedWidgetId);
      setValues(updatePropertyFromWidget(values, newSelectedWidgetId, propertyConfigs));
      setTimeout(() => {
        nameFieldRef.current?.focus();
      }, 0);
    };
    $2[23] = propertyConfigs;
    $2[24] = setValues;
    $2[25] = values;
    $2[26] = t9;
  } else {
    t9 = $2[26];
  }
  const onWidgetSelectChanged = t9;
  let childComponent;
  if (selectedFieldConfigId === "text_field" || selectedFieldConfigId === "multiline" || selectedFieldConfigId === "email") {
    let t102;
    if ($2[27] !== disabled || $2[28] !== selectedFieldConfigId || $2[29] !== showErrors) {
      t102 = /* @__PURE__ */ jsxRuntimeExports.jsx(StringPropertyField, { widgetId: selectedFieldConfigId, disabled, showErrors });
      $2[27] = disabled;
      $2[28] = selectedFieldConfigId;
      $2[29] = showErrors;
      $2[30] = t102;
    } else {
      t102 = $2[30];
    }
    childComponent = t102;
  } else {
    if (selectedFieldConfigId === "url") {
      let t102;
      if ($2[31] !== disabled || $2[32] !== showErrors) {
        t102 = /* @__PURE__ */ jsxRuntimeExports.jsx(UrlPropertyField, { disabled, showErrors });
        $2[31] = disabled;
        $2[32] = showErrors;
        $2[33] = t102;
      } else {
        t102 = $2[33];
      }
      childComponent = t102;
    } else {
      if (selectedFieldConfigId === "markdown") {
        let t102;
        if ($2[34] !== disabled || $2[35] !== showErrors) {
          t102 = /* @__PURE__ */ jsxRuntimeExports.jsx(MarkdownPropertyField, { disabled, showErrors });
          $2[34] = disabled;
          $2[35] = showErrors;
          $2[36] = t102;
        } else {
          t102 = $2[36];
        }
        childComponent = t102;
      } else {
        if (selectedFieldConfigId === "select" || selectedFieldConfigId === "number_select") {
          const t102 = !existing;
          let t112;
          if ($2[37] !== allowDataInference || $2[38] !== disabled || $2[39] !== getData || $2[40] !== showErrors || $2[41] !== t102) {
            t112 = /* @__PURE__ */ jsxRuntimeExports.jsx(EnumPropertyField, { multiselect: false, allowDataInference, updateIds: t102, disabled, getData, showErrors });
            $2[37] = allowDataInference;
            $2[38] = disabled;
            $2[39] = getData;
            $2[40] = showErrors;
            $2[41] = t102;
            $2[42] = t112;
          } else {
            t112 = $2[42];
          }
          childComponent = t112;
        } else {
          if (selectedFieldConfigId === "multi_select" || selectedFieldConfigId === "multi_number_select") {
            const t102 = !existing;
            let t112;
            if ($2[43] !== allowDataInference || $2[44] !== disabled || $2[45] !== getData || $2[46] !== showErrors || $2[47] !== t102) {
              t112 = /* @__PURE__ */ jsxRuntimeExports.jsx(EnumPropertyField, { multiselect: true, updateIds: t102, disabled, allowDataInference, getData, showErrors });
              $2[43] = allowDataInference;
              $2[44] = disabled;
              $2[45] = getData;
              $2[46] = showErrors;
              $2[47] = t102;
              $2[48] = t112;
            } else {
              t112 = $2[48];
            }
            childComponent = t112;
          } else {
            if (selectedFieldConfigId === "file_upload") {
              let t102;
              if ($2[49] !== disabled || $2[50] !== existing) {
                t102 = /* @__PURE__ */ jsxRuntimeExports.jsx(StoragePropertyField, { existing, multiple: false, disabled });
                $2[49] = disabled;
                $2[50] = existing;
                $2[51] = t102;
              } else {
                t102 = $2[51];
              }
              childComponent = t102;
            } else {
              if (selectedFieldConfigId === "multi_file_upload") {
                let t102;
                if ($2[52] !== disabled || $2[53] !== existing) {
                  t102 = /* @__PURE__ */ jsxRuntimeExports.jsx(StoragePropertyField, { existing, multiple: true, disabled });
                  $2[52] = disabled;
                  $2[53] = existing;
                  $2[54] = t102;
                } else {
                  t102 = $2[54];
                }
                childComponent = t102;
              } else {
                if (selectedFieldConfigId === "switch") {
                  let t102;
                  if ($2[55] !== disabled) {
                    t102 = /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanPropertyField, { disabled });
                    $2[55] = disabled;
                    $2[56] = t102;
                  } else {
                    t102 = $2[56];
                  }
                  childComponent = t102;
                } else {
                  if (selectedFieldConfigId === "number_input") {
                    let t102;
                    if ($2[57] !== disabled) {
                      t102 = /* @__PURE__ */ jsxRuntimeExports.jsx(NumberPropertyField, { disabled });
                      $2[57] = disabled;
                      $2[58] = t102;
                    } else {
                      t102 = $2[58];
                    }
                    childComponent = t102;
                  } else {
                    if (selectedFieldConfigId === "group") {
                      let t102;
                      if ($2[59] !== allowDataInference || $2[60] !== collectionEditable || $2[61] !== disabled || $2[62] !== getData || $2[63] !== propertyConfigs) {
                        t102 = /* @__PURE__ */ jsxRuntimeExports.jsx(MapPropertyField, { disabled, getData, allowDataInference, collectionEditable, propertyConfigs });
                        $2[59] = allowDataInference;
                        $2[60] = collectionEditable;
                        $2[61] = disabled;
                        $2[62] = getData;
                        $2[63] = propertyConfigs;
                        $2[64] = t102;
                      } else {
                        t102 = $2[64];
                      }
                      childComponent = t102;
                    } else {
                      if (selectedFieldConfigId === "block") {
                        let t102;
                        if ($2[65] !== allowDataInference || $2[66] !== collectionEditable || $2[67] !== disabled || $2[68] !== getData || $2[69] !== propertyConfigs) {
                          t102 = /* @__PURE__ */ jsxRuntimeExports.jsx(BlockPropertyField, { disabled, getData, allowDataInference, collectionEditable, propertyConfigs });
                          $2[65] = allowDataInference;
                          $2[66] = collectionEditable;
                          $2[67] = disabled;
                          $2[68] = getData;
                          $2[69] = propertyConfigs;
                          $2[70] = t102;
                        } else {
                          t102 = $2[70];
                        }
                        childComponent = t102;
                      } else {
                        if (selectedFieldConfigId === "reference") {
                          let t102;
                          if ($2[71] !== disabled || $2[72] !== existing || $2[73] !== showErrors) {
                            t102 = /* @__PURE__ */ jsxRuntimeExports.jsx(ReferencePropertyField, { showErrors, existing, multiple: false, disabled });
                            $2[71] = disabled;
                            $2[72] = existing;
                            $2[73] = showErrors;
                            $2[74] = t102;
                          } else {
                            t102 = $2[74];
                          }
                          childComponent = t102;
                        } else {
                          if (selectedFieldConfigId === "date_time") {
                            let t102;
                            if ($2[75] !== disabled) {
                              t102 = /* @__PURE__ */ jsxRuntimeExports.jsx(DateTimePropertyField, { disabled });
                              $2[75] = disabled;
                              $2[76] = t102;
                            } else {
                              t102 = $2[76];
                            }
                            childComponent = t102;
                          } else {
                            if (selectedFieldConfigId === "multi_references") {
                              let t102;
                              if ($2[77] !== disabled || $2[78] !== existing || $2[79] !== showErrors) {
                                t102 = /* @__PURE__ */ jsxRuntimeExports.jsx(ReferencePropertyField, { showErrors, existing, multiple: true, disabled });
                                $2[77] = disabled;
                                $2[78] = existing;
                                $2[79] = showErrors;
                                $2[80] = t102;
                              } else {
                                t102 = $2[80];
                              }
                              childComponent = t102;
                            } else {
                              if (selectedFieldConfigId === "repeat") {
                                let t102;
                                if ($2[81] !== allowDataInference || $2[82] !== collectionEditable || $2[83] !== disabled || $2[84] !== existing || $2[85] !== getData || $2[86] !== propertyConfigs || $2[87] !== showErrors) {
                                  t102 = /* @__PURE__ */ jsxRuntimeExports.jsx(RepeatPropertyField, { showErrors, existing, getData, allowDataInference, disabled, collectionEditable, propertyConfigs });
                                  $2[81] = allowDataInference;
                                  $2[82] = collectionEditable;
                                  $2[83] = disabled;
                                  $2[84] = existing;
                                  $2[85] = getData;
                                  $2[86] = propertyConfigs;
                                  $2[87] = showErrors;
                                  $2[88] = t102;
                                } else {
                                  t102 = $2[88];
                                }
                                childComponent = t102;
                              } else {
                                if (selectedFieldConfigId === "key_value") {
                                  let t102;
                                  if ($2[89] !== disabled) {
                                    t102 = /* @__PURE__ */ jsxRuntimeExports.jsx(KeyValuePropertyField, { disabled });
                                    $2[89] = disabled;
                                    $2[90] = t102;
                                  } else {
                                    t102 = $2[90];
                                  }
                                  childComponent = t102;
                                } else {
                                  childComponent = null;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  let t10;
  if ($2[91] !== disabled) {
    t10 = disabled && /* @__PURE__ */ jsxRuntimeExports.jsxs(InfoLabel2, { mode: "warn", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { children: "This property can't be edited" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography$3, { variant: "caption", children: [
        "You may not have permission to edit it or it is defined in code with no ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: "editable" }),
        " flag"
      ] })
    ] });
    $2[91] = disabled;
    $2[92] = t10;
  } else {
    t10 = $2[92];
  }
  const t11 = selectedFieldConfigId;
  let t12;
  if ($2[93] !== onWidgetSelectChanged) {
    t12 = (value) => onWidgetSelectChanged(value);
    $2[93] = onWidgetSelectChanged;
    $2[94] = t12;
  } else {
    t12 = $2[94];
  }
  let t13;
  if ($2[95] !== onDismiss) {
    t13 = (open, hasValue) => {
      if (!hasValue) {
        onDismiss?.();
      }
      setSelectOpen(open);
    };
    $2[95] = onDismiss;
    $2[96] = t13;
  } else {
    t13 = $2[96];
  }
  const t14 = Boolean(selectedWidgetError);
  let t15;
  if ($2[97] !== disabled || $2[98] !== existing || $2[99] !== inArray || $2[100] !== propertyConfigs || $2[101] !== selectOpen || $2[102] !== t11 || $2[103] !== t12 || $2[104] !== t13 || $2[105] !== t14 || $2[106] !== values) {
    t15 = /* @__PURE__ */ jsxRuntimeExports.jsx(WidgetSelectView, { initialProperty: values, value: t11, onValueChange: t12, open: selectOpen, onOpenChange: t13, disabled, showError: t14, existing, propertyConfigs, inArray });
    $2[97] = disabled;
    $2[98] = existing;
    $2[99] = inArray;
    $2[100] = propertyConfigs;
    $2[101] = selectOpen;
    $2[102] = t11;
    $2[103] = t12;
    $2[104] = t13;
    $2[105] = t14;
    $2[106] = values;
    $2[107] = t15;
  } else {
    t15 = $2[107];
  }
  let t16;
  if ($2[108] !== selectedWidgetError) {
    t16 = selectedWidgetError && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "caption", className: "ml-3.5", color: "error", children: "Required" });
    $2[108] = selectedWidgetError;
    $2[109] = t16;
  } else {
    t16 = $2[109];
  }
  let t17;
  if ($2[110] !== t15 || $2[111] !== t16) {
    t17 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full flex flex-col gap-2", children: [
      t15,
      t16
    ] });
    $2[110] = t15;
    $2[111] = t16;
    $2[112] = t17;
  } else {
    t17 = $2[112];
  }
  let t18;
  if ($2[113] !== disabled || $2[114] !== onDelete || $2[115] !== values?.id) {
    t18 = onDelete && values?.id && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$3, { variant: "ghost", className: "m-4", disabled, onClick: () => setDeleteDialogOpen(true), children: /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteIcon2, {}) });
    $2[113] = disabled;
    $2[114] = onDelete;
    $2[115] = values?.id;
    $2[116] = t18;
  } else {
    t18 = $2[116];
  }
  let t19;
  if ($2[117] !== t17 || $2[118] !== t18) {
    t19 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex mt-2 justify-between", children: [
      t17,
      t18
    ] });
    $2[117] = t17;
    $2[118] = t18;
    $2[119] = t19;
  } else {
    t19 = $2[119];
  }
  let t20;
  if ($2[120] !== autoUpdateId || $2[121] !== disabled || $2[122] !== existing || $2[123] !== includeIdAndTitle || $2[124] !== showErrors) {
    t20 = includeIdAndTitle && /* @__PURE__ */ jsxRuntimeExports.jsx(CommonPropertyFields, { showErrors, disabledId: existing, isNewProperty: !existing, disabled, autoUpdateId, ref: nameFieldRef });
    $2[120] = autoUpdateId;
    $2[121] = disabled;
    $2[122] = existing;
    $2[123] = includeIdAndTitle;
    $2[124] = showErrors;
    $2[125] = t20;
  } else {
    t20 = $2[125];
  }
  let t21;
  if ($2[126] !== disabled) {
    t21 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AdvancedPropertyValidation, { disabled }) });
    $2[126] = disabled;
    $2[127] = t21;
  } else {
    t21 = $2[127];
  }
  let t22;
  if ($2[128] !== childComponent || $2[129] !== t20 || $2[130] !== t21) {
    t22 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-12 gap-y-12 mt-8 mb-8", children: [
      t20,
      childComponent,
      t21
    ] });
    $2[128] = childComponent;
    $2[129] = t20;
    $2[130] = t21;
    $2[131] = t22;
  } else {
    t22 = $2[131];
  }
  let t23;
  if ($2[132] !== deleteDialogOpen || $2[133] !== onDelete || $2[134] !== propertyNamespace || $2[135] !== values?.id) {
    t23 = onDelete && /* @__PURE__ */ jsxRuntimeExports.jsx(ConfirmationDialog2, { open: deleteDialogOpen, onAccept: () => onDelete(values?.id, propertyNamespace), onCancel: () => setDeleteDialogOpen(false), title: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Delete this property?" }), body: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      " This will ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: "not delete any data" }),
      ", only modify the collection."
    ] }) });
    $2[132] = deleteDialogOpen;
    $2[133] = onDelete;
    $2[134] = propertyNamespace;
    $2[135] = values?.id;
    $2[136] = t23;
  } else {
    t23 = $2[136];
  }
  let t24;
  if ($2[137] !== t10 || $2[138] !== t19 || $2[139] !== t22 || $2[140] !== t23) {
    t24 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t10,
      t19,
      t22,
      t23
    ] });
    $2[137] = t10;
    $2[138] = t19;
    $2[139] = t22;
    $2[140] = t23;
    $2[141] = t24;
  } else {
    t24 = $2[141];
  }
  return t24;
}
const idRegEx = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
function validateId$1(value, existingPropertyKeys) {
  let error;
  if (!value) {
    error = "You must specify an id for the field";
  }
  if (value && !value.match(idRegEx)) {
    error = "The id can only contain letters, numbers and underscores (_), and not start with a number";
  }
  if (value && existingPropertyKeys && existingPropertyKeys.includes(value)) {
    error = "There is another field with this ID already";
  }
  return error;
}
function validateName(value) {
  let error;
  if (!value) {
    error = "You must specify a title for the field";
  }
  return error;
}
const WIDGET_TYPE_MAP = {
  text_field: "Text",
  multiline: "Text",
  markdown: "Text",
  url: "Text",
  email: "Text",
  switch: "Boolean",
  select: "Select",
  multi_select: "Select",
  number_input: "Number",
  number_select: "Select",
  multi_number_select: "Select",
  file_upload: "File",
  multi_file_upload: "File",
  reference: "Reference",
  multi_references: "Reference",
  date_time: "Date",
  group: "Group",
  key_value: "Group",
  repeat: "Array",
  custom_array: "Array",
  block: "Group"
};
function WidgetSelectView(t0) {
  const $2 = c_1(55);
  const {
    initialProperty,
    value,
    onValueChange,
    open,
    onOpenChange,
    disabled,
    existing,
    propertyConfigs,
    inArray
  } = t0;
  let T0;
  let T1;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  if ($2[0] !== disabled || $2[1] !== existing || $2[2] !== inArray || $2[3] !== initialProperty || $2[4] !== onOpenChange || $2[5] !== onValueChange || $2[6] !== open || $2[7] !== propertyConfigs || $2[8] !== value) {
    const allSupportedFields = Object.entries(supportedFields).concat(Object.entries(propertyConfigs));
    const displayedWidgets = (inArray ? allSupportedFields.filter(_temp$5$1) : allSupportedFields).map(_temp2$3$1).reduce(_temp3$1$1, {});
    const key_0 = value;
    const propertyConfig_1 = key_0 ? DEFAULT_FIELD_CONFIGS2[key_0] ?? propertyConfigs[key_0] : void 0;
    const baseProperty = propertyConfig_1?.property;
    let t72;
    if ($2[17] !== baseProperty || $2[18] !== propertyConfig_1 || $2[19] !== propertyConfigs) {
      const baseFieldConfig = baseProperty && !isPropertyBuilder$1(baseProperty) ? getFieldConfig2(baseProperty, propertyConfigs) : void 0;
      t72 = baseFieldConfig && propertyConfig_1 ? mergeDeep2(baseFieldConfig, propertyConfig_1) : propertyConfig_1;
      $2[17] = baseProperty;
      $2[18] = propertyConfig_1;
      $2[19] = propertyConfigs;
      $2[20] = t72;
    } else {
      t72 = $2[20];
    }
    const computedFieldConfig = t72;
    const groups = [...new Set(Object.keys(displayedWidgets).map(_temp4$1))];
    let t82;
    if ($2[21] !== disabled || $2[22] !== onOpenChange || $2[23] !== open || $2[24] !== value) {
      t82 = () => {
        if (!disabled) {
          onOpenChange(!open, Boolean(value));
        }
      };
      $2[21] = disabled;
      $2[22] = onOpenChange;
      $2[23] = open;
      $2[24] = value;
      $2[25] = t82;
    } else {
      t82 = $2[25];
    }
    const t92 = disabled ? fieldBackgroundDisabledMixin$1 : fieldBackgroundHoverMixin$1;
    let t10;
    if ($2[26] !== t92) {
      t10 = cls$3("select-none rounded-md text-sm p-4", fieldBackgroundMixin$1, t92, "relative flex items-center");
      $2[26] = t92;
      $2[27] = t10;
    } else {
      t10 = $2[27];
    }
    let t11;
    if ($2[28] !== value) {
      t11 = !value && /* @__PURE__ */ jsxRuntimeExports.jsx("em", { children: "Select a property widget" });
      $2[28] = value;
      $2[29] = t11;
    } else {
      t11 = $2[29];
    }
    let t12;
    if ($2[30] !== computedFieldConfig || $2[31] !== value) {
      t12 = value && computedFieldConfig && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cls$3("flex items-center"), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mr-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyConfigBadge2, { propertyConfig: computedFieldConfig }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-start text-base text-left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: computedFieldConfig.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "caption", color: "secondary", children: computedFieldConfig.description })
        ] })
      ] });
      $2[30] = computedFieldConfig;
      $2[31] = value;
      $2[32] = t12;
    } else {
      t12 = $2[32];
    }
    if ($2[33] !== t10 || $2[34] !== t11 || $2[35] !== t12 || $2[36] !== t82) {
      t5 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: t82, className: t10, children: [
        t11,
        t12
      ] });
      $2[33] = t10;
      $2[34] = t11;
      $2[35] = t12;
      $2[36] = t82;
      $2[37] = t5;
    } else {
      t5 = $2[37];
    }
    T1 = Dialog$2;
    t1 = open;
    if ($2[38] !== onOpenChange || $2[39] !== value) {
      t2 = (open_0) => onOpenChange(open_0, Boolean(value));
      $2[38] = onOpenChange;
      $2[39] = value;
      $2[40] = t2;
    } else {
      t2 = $2[40];
    }
    t3 = "4xl";
    if ($2[41] === Symbol.for("react.memo_cache_sentinel")) {
      t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle$2, { children: "Select a property widget" });
      $2[41] = t4;
    } else {
      t4 = $2[41];
    }
    T0 = DialogContent$2;
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: groups.map((group_0) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "label", children: group_0 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-2 mt-4", children: Object.entries(displayedWidgets).map((t13) => {
        const [key_2, propertyConfig_2] = t13;
        const groupKey = WIDGET_TYPE_MAP[key_2];
        if (groupKey === group_0) {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(WidgetSelectViewItem, { initialProperty, onClick: () => {
            onValueChange(key_2);
            onOpenChange(false, true);
          }, propertyConfig: propertyConfig_2, existing }, key_2);
        }
        return null;
      }) })
    ] }, group_0)) });
    $2[0] = disabled;
    $2[1] = existing;
    $2[2] = inArray;
    $2[3] = initialProperty;
    $2[4] = onOpenChange;
    $2[5] = onValueChange;
    $2[6] = open;
    $2[7] = propertyConfigs;
    $2[8] = value;
    $2[9] = T0;
    $2[10] = T1;
    $2[11] = t1;
    $2[12] = t2;
    $2[13] = t3;
    $2[14] = t4;
    $2[15] = t5;
    $2[16] = t6;
  } else {
    T0 = $2[9];
    T1 = $2[10];
    t1 = $2[11];
    t2 = $2[12];
    t3 = $2[13];
    t4 = $2[14];
    t5 = $2[15];
    t6 = $2[16];
  }
  let t7;
  if ($2[42] !== T0 || $2[43] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(T0, { children: t6 });
    $2[42] = T0;
    $2[43] = t6;
    $2[44] = t7;
  } else {
    t7 = $2[44];
  }
  let t8;
  if ($2[45] !== T1 || $2[46] !== t1 || $2[47] !== t2 || $2[48] !== t3 || $2[49] !== t4 || $2[50] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsxs(T1, { open: t1, onOpenChange: t2, maxWidth: t3, children: [
      t4,
      t7
    ] });
    $2[45] = T1;
    $2[46] = t1;
    $2[47] = t2;
    $2[48] = t3;
    $2[49] = t4;
    $2[50] = t7;
    $2[51] = t8;
  } else {
    t8 = $2[51];
  }
  let t9;
  if ($2[52] !== t5 || $2[53] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t5,
      t8
    ] });
    $2[52] = t5;
    $2[53] = t8;
    $2[54] = t9;
  } else {
    t9 = $2[54];
  }
  return t9;
}
function _temp4$1(key_1) {
  const group = WIDGET_TYPE_MAP[key_1];
  if (group) {
    return group;
  }
  return "Custom/Other";
}
function _temp3$1$1(a, b) {
  return {
    ...a,
    ...b
  };
}
function _temp2$3$1(t0) {
  const [key2, propertyConfig_0] = t0;
  return {
    [key2]: propertyConfig_0
  };
}
function _temp$5$1(t0) {
  const [, propertyConfig] = t0;
  return !isPropertyBuilder$1(propertyConfig.property) && propertyConfig.property?.dataType !== "array";
}
function WidgetSelectViewItem(t0) {
  const $2 = c_1(23);
  const {
    onClick,
    initialProperty,
    propertyConfig,
    existing
  } = t0;
  const baseProperty = propertyConfig.property;
  const shouldWarnChangingDataType = existing && !isPropertyBuilder$1(baseProperty) && baseProperty.dataType !== initialProperty?.dataType;
  let t1;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = cls$3("flex flex-row items-center text-base min-h-[48px]");
    $2[0] = t1;
  } else {
    t1 = $2[0];
  }
  let t2;
  if ($2[1] !== propertyConfig || $2[2] !== shouldWarnChangingDataType) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mr-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyConfigBadge2, { propertyConfig, disabled: shouldWarnChangingDataType }) });
    $2[1] = propertyConfig;
    $2[2] = shouldWarnChangingDataType;
    $2[3] = t2;
  } else {
    t2 = $2[3];
  }
  let t3;
  if ($2[4] !== shouldWarnChangingDataType) {
    t3 = shouldWarnChangingDataType && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$3, { title: "This widget uses a different data type than the initially selected widget. This can cause errors with existing data.", children: /* @__PURE__ */ jsxRuntimeExports.jsx(WarningIcon2, { size: "smallest", className: "w-4" }) });
    $2[4] = shouldWarnChangingDataType;
    $2[5] = t3;
  } else {
    t3 = $2[5];
  }
  const t4 = shouldWarnChangingDataType ? "secondary" : void 0;
  let t5;
  if ($2[6] !== propertyConfig.name || $2[7] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { color: t4, children: propertyConfig.name });
    $2[6] = propertyConfig.name;
    $2[7] = t4;
    $2[8] = t5;
  } else {
    t5 = $2[8];
  }
  let t6;
  if ($2[9] !== t3 || $2[10] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row gap-2 items-center", children: [
      t3,
      t5
    ] });
    $2[9] = t3;
    $2[10] = t5;
    $2[11] = t6;
  } else {
    t6 = $2[11];
  }
  let t7;
  if ($2[12] !== propertyConfig.description) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "caption", color: "secondary", className: "max-w-sm", children: propertyConfig.description });
    $2[12] = propertyConfig.description;
    $2[13] = t7;
  } else {
    t7 = $2[13];
  }
  let t8;
  if ($2[14] !== t6 || $2[15] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      t6,
      t7
    ] });
    $2[14] = t6;
    $2[15] = t7;
    $2[16] = t8;
  } else {
    t8 = $2[16];
  }
  let t9;
  if ($2[17] !== t2 || $2[18] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t1, children: [
      t2,
      t8
    ] });
    $2[17] = t2;
    $2[18] = t8;
    $2[19] = t9;
  } else {
    t9 = $2[19];
  }
  let t10;
  if ($2[20] !== onClick || $2[21] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(Card$2, { onClick, className: "flex flex-row items-center px-4 py-2", children: t9 });
    $2[20] = onClick;
    $2[21] = t9;
    $2[22] = t10;
  } else {
    t10 = $2[22];
  }
  return t10;
}
function camelCase(str) {
  if (!str) return "";
  return (str.slice(0, 1).toLowerCase() + str.slice(1)).replace(/([-_ ]){1,}/g, " ").split(/[-_ ]/).reduce((cur, acc) => {
    return cur + acc[0].toUpperCase() + acc.substring(1);
  }, "");
}
function GetCodeDialog(t0) {
  const $2 = c_1(22);
  const {
    collection: collection2,
    onOpenChange,
    open
  } = t0;
  const snackbarController = useSnackbarController$2();
  const code = collection2 ? 'import { EntityCollection } from "@firecms/core";\n\nconst ' + (collection2?.name ? camelCase(collection2.name) : "my") + "Collection:EntityCollection = " + lib.stringify(collectionToCode({
    ...collection2
  }), null, "	") : "No collection selected";
  let t1;
  if ($2[0] !== collection2.name) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogTitle$2, { variant: "h6", children: [
      "Code for ",
      collection2.name
    ] });
    $2[0] = collection2.name;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  let t2;
  if ($2[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography$3, { variant: "body2", className: "my-4 mb-8", children: [
      "If you want to customise the collection in code, you can add this collection code to your CMS app configuration. More info in the ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("a", { rel: "noopener noreferrer", href: "https://firecms.co/docs/customization_quickstart", children: "docs" }),
      "."
    ] });
    $2[2] = t2;
  } else {
    t2 = $2[2];
  }
  let t3;
  if ($2[3] !== code) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent$2, { children: [
      t2,
      /* @__PURE__ */ jsxRuntimeExports.jsx(Highlight2, { theme: themes_exports.vsDark, code, language: "typescript", children: _temp$4$1 })
    ] });
    $2[3] = code;
    $2[4] = t3;
  } else {
    t3 = $2[4];
  }
  let t4;
  if ($2[5] !== code || $2[6] !== snackbarController) {
    t4 = (e) => {
      e.stopPropagation();
      e.preventDefault();
      snackbarController.open({
        type: "success",
        message: `Copied`
      });
      return navigator.clipboard.writeText(code);
    };
    $2[5] = code;
    $2[6] = snackbarController;
    $2[7] = t4;
  } else {
    t4 = $2[7];
  }
  let t5;
  if ($2[8] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(ContentCopyIcon$1, { size: "small" });
    $2[8] = t5;
  } else {
    t5 = $2[8];
  }
  let t6;
  if ($2[9] !== t4) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Button$3, { variant: "text", size: "small", onClick: t4, children: [
      t5,
      "Copy to clipboard"
    ] });
    $2[9] = t4;
    $2[10] = t6;
  } else {
    t6 = $2[10];
  }
  let t7;
  if ($2[11] !== onOpenChange) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { onClick: () => onOpenChange(false), children: "Close" });
    $2[11] = onOpenChange;
    $2[12] = t7;
  } else {
    t7 = $2[12];
  }
  let t8;
  if ($2[13] !== t6 || $2[14] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions$1, { children: [
      t6,
      t7
    ] });
    $2[13] = t6;
    $2[14] = t7;
    $2[15] = t8;
  } else {
    t8 = $2[15];
  }
  let t9;
  if ($2[16] !== onOpenChange || $2[17] !== open || $2[18] !== t1 || $2[19] !== t3 || $2[20] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog$2, { open, onOpenChange, maxWidth: "4xl", children: [
      t1,
      t3,
      t8
    ] });
    $2[16] = onOpenChange;
    $2[17] = open;
    $2[18] = t1;
    $2[19] = t3;
    $2[20] = t8;
    $2[21] = t9;
  } else {
    t9 = $2[21];
  }
  return t9;
}
function _temp$4$1(t0) {
  const {
    style,
    tokens,
    getLineProps,
    getTokenProps
  } = t0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { style, className: "p-4 rounded text-sm", children: tokens.map((line2, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...getLineProps({
    line: line2
  }), children: line2.map((token2, key2) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { ...getTokenProps({
    token: token2
  }) }, key2)) }, i)) });
}
function collectionToCode(collection2) {
  const propertyCleanup = (value) => {
    if (value === void 0 || value === null) {
      return value;
    }
    const valueCopy = clone(value);
    if (typeof valueCopy === "function") {
      return valueCopy;
    }
    if (Array.isArray(valueCopy)) {
      return valueCopy.map((v2) => propertyCleanup(v2));
    }
    if (typeof valueCopy === "object") {
      if (valueCopy === null) return valueCopy;
      Object.keys(valueCopy).forEach((key2) => {
        if (!isEmptyObject2(valueCopy)) {
          const childRes = propertyCleanup(valueCopy[key2]);
          if (childRes !== null && childRes !== void 0 && childRes !== false && !isEmptyObject2(childRes)) {
            valueCopy[key2] = childRes;
          } else {
            delete valueCopy[key2];
          }
        }
      });
      delete valueCopy.fromBuilder;
      delete valueCopy.resolved;
      delete valueCopy.propertiesOrder;
      delete valueCopy.propertyConfig;
      delete valueCopy.resolvedProperties;
      delete valueCopy.editable;
    }
    return valueCopy;
  };
  return {
    id: collection2.id,
    name: collection2.name,
    singularName: collection2.singularName,
    path: collection2.path,
    description: collection2.description,
    editable: true,
    collectionGroup: collection2.collectionGroup,
    icon: collection2.icon,
    group: collection2.group,
    customId: collection2.customId,
    initialFilter: collection2.initialFilter,
    initialSort: collection2.initialSort,
    properties: Object.entries({
      ...collection2.properties ?? {}
    }).map(([key2, value]) => ({
      [key2]: propertyCleanup(value)
    })).reduce((a, b) => ({
      ...a,
      ...b
    }), {}),
    subcollections: (collection2.subcollections ?? []).map(collectionToCode)
  };
}
function CollectionPropertiesEditorForm({
  showErrors,
  isNewCollection,
  propertyErrorsRef,
  onPropertyError,
  setDirty,
  reservedGroups,
  extraIcon,
  getUser,
  getData,
  doCollectionInference,
  propertyConfigs,
  collectionEditable
}) {
  const {
    values,
    setFieldValue,
    setFieldError,
    setFieldTouched,
    errors,
    dirty
  } = useFormex();
  const snackbarController = useSnackbarController$2();
  const largeLayout = useLargeLayout2();
  const asDialog = !largeLayout;
  const [selectedPropertyIndex, setSelectedPropertyIndex] = useState$3();
  const [selectedPropertyKey, setSelectedPropertyKey] = useState$3();
  const [selectedPropertyNamespace, setSelectedPropertyNamespace] = useState$3();
  const selectedPropertyFullId = selectedPropertyKey ? getFullId(selectedPropertyKey, selectedPropertyNamespace) : void 0;
  const selectedProperty = selectedPropertyFullId ? getIn(values.properties, selectedPropertyFullId.replaceAll(".", ".properties.")) : void 0;
  const [codeDialogOpen, setCodeDialogOpen] = useState$3(false);
  const [inferringProperties, setInferringProperties] = useState$3(false);
  const [newPropertyDialogOpen, setNewPropertyDialogOpen] = useState$3(false);
  const [inferredPropertyKeys, setInferredPropertyKeys] = useState$3([]);
  const currentPropertiesOrderRef = React__default.useRef(values.propertiesOrder ? {
    "": values.propertiesOrder
  } : {});
  useEffect$4(() => {
    if (setDirty) setDirty(dirty);
  }, [dirty]);
  const inferPropertiesFromData = doCollectionInference ? () => {
    if (!doCollectionInference) return;
    setInferringProperties(true);
    doCollectionInference(values).then((newCollection) => {
      if (newCollection) makePropertiesEditable2(newCollection.properties);
      if (!newCollection) {
        snackbarController.open({
          type: "error",
          message: "Could not infer properties from data"
        });
        return;
      }
      const newPropertyKeys = (newCollection.properties ? Object.keys(newCollection.properties) : []).filter((propertyKey) => !values.properties[propertyKey]);
      if (newPropertyKeys.length === 0) {
        snackbarController.open({
          type: "info",
          message: "No new properties found in existing data"
        });
        return;
      }
      const updatedProperties = {
        ...newPropertyKeys.reduce((acc, propertyKey_0) => {
          acc[propertyKey_0] = (newCollection.properties ?? {})[propertyKey_0];
          return acc;
        }, {}),
        ...values.properties
      };
      const updatedPropertiesOrder = [...newPropertyKeys, ...values.propertiesOrder ?? []];
      setFieldValue("properties", updatedProperties, false);
      updatePropertiesOrder(updatedPropertiesOrder);
      setInferredPropertyKeys(newPropertyKeys);
    }).finally(() => {
      setInferringProperties(false);
    });
  } : void 0;
  const getCurrentPropertiesOrder = (namespace) => {
    if (!namespace) return currentPropertiesOrderRef.current[""] ?? getIn(values, namespaceToPropertiesOrderPath());
    return currentPropertiesOrderRef.current[namespace] ?? getIn(values, namespaceToPropertiesOrderPath(namespace));
  };
  const updatePropertiesOrder = (newPropertiesOrder, namespace_0) => {
    const propertiesOrderPath = namespaceToPropertiesOrderPath(namespace_0);
    setFieldValue(propertiesOrderPath, newPropertiesOrder, false);
    currentPropertiesOrderRef.current[namespace_0 ?? ""] = newPropertiesOrder;
  };
  const deleteProperty = (propertyKey_1, namespace_1) => {
    const fullId = propertyKey_1 ? getFullId(propertyKey_1, namespace_1) : void 0;
    if (!fullId) throw Error("collection editor miss config");
    setFieldValue(idToPropertiesPath(fullId), void 0, false);
    const currentPropertiesOrder = getCurrentPropertiesOrder(namespace_1);
    if (currentPropertiesOrder) {
      const newPropertiesOrder_0 = currentPropertiesOrder.filter((p) => p !== propertyKey_1);
      updatePropertiesOrder(newPropertiesOrder_0, namespace_1);
    }
    setNewPropertyDialogOpen(false);
    setSelectedPropertyIndex(void 0);
    setSelectedPropertyKey(void 0);
    setSelectedPropertyNamespace(void 0);
  };
  const onPropertyMove = (propertiesOrder, namespace_2) => {
    setFieldValue(namespaceToPropertiesOrderPath(namespace_2), propertiesOrder, false);
  };
  const onPropertyCreated = ({
    id,
    property
  }) => {
    if (!id) {
      throw Error("Need to include an ID when creating a new property");
    }
    setFieldValue("properties", {
      ...values.properties ?? {},
      [id]: property
    }, false);
    const newPropertiesOrder_1 = [...values.propertiesOrder ?? Object.keys(values.properties), id];
    updatePropertiesOrder(newPropertiesOrder_1);
    setNewPropertyDialogOpen(false);
    if (largeLayout) {
      setSelectedPropertyIndex(newPropertiesOrder_1.indexOf(id));
      setSelectedPropertyKey(id);
    }
    setSelectedPropertyNamespace(void 0);
  };
  const onPropertyChanged = ({
    id: id_0,
    property: property_0,
    previousId,
    namespace: namespace_3
  }) => {
    console.log("!!!!!! onPropertyChanged", property_0);
    const fullId_0 = id_0 ? getFullId(id_0, namespace_3) : void 0;
    const propertyPath = fullId_0 ? idToPropertiesPath(fullId_0) : void 0;
    if (previousId && previousId !== id_0) {
      const previousFullId = getFullId(previousId, namespace_3);
      const previousPropertyPath = idToPropertiesPath(previousFullId);
      const currentPropertiesOrder_0 = getCurrentPropertiesOrder(namespace_3);
      const newPropertiesOrder_2 = currentPropertiesOrder_0.map((p_0) => p_0 === previousId ? id_0 : p_0).filter((p_1) => p_1 !== void 0);
      updatePropertiesOrder(newPropertiesOrder_2, namespace_3);
      if (id_0) {
        setSelectedPropertyIndex(newPropertiesOrder_2.indexOf(id_0));
        setSelectedPropertyKey(id_0);
      }
      setFieldValue(previousPropertyPath, void 0, false);
      setFieldTouched(previousPropertyPath, false, false);
    }
    console.debug("onPropertyChanged", {
      id: id_0,
      property: property_0,
      previousId,
      namespace: namespace_3,
      propertyPath
    });
    if (propertyPath) {
      setFieldValue(propertyPath, property_0, false);
      setFieldTouched(propertyPath, true, false);
    }
  };
  const onPropertyErrorInternal = (id_1, namespace_4, error) => {
    const propertyPath_0 = id_1 ? getFullId(id_1, namespace_4) : void 0;
    console.debug("onPropertyErrorInternal", {
      id: id_1,
      namespace: namespace_4,
      error,
      propertyPath: propertyPath_0
    });
    if (propertyPath_0) {
      const hasError = error && Object.keys(error).length > 0;
      onPropertyError(id_1, namespace_4, hasError ? error : void 0);
      setFieldError(idToPropertiesPath(propertyPath_0), hasError ? "Property error" : void 0);
    }
  };
  const closePropertyDialog = () => {
    setSelectedPropertyIndex(void 0);
    setSelectedPropertyKey(void 0);
  };
  const initialErrors = selectedPropertyKey && propertyErrorsRef?.current?.properties ? propertyErrorsRef.current.properties[selectedPropertyKey] : void 0;
  const emptyCollection = values?.propertiesOrder === void 0 || values.propertiesOrder.length === 0;
  const usedPropertiesOrder = values.propertiesOrder ? values.propertiesOrder : Object.keys(values.properties);
  const owner = useMemo$4(() => values.ownerId && getUser ? getUser(values.ownerId) : null, [getUser, values.ownerId]);
  const onPropertyClick = (propertyKey_2, namespace_5) => {
    console.debug("CollectionEditor: onPropertyClick", {
      propertyKey: propertyKey_2,
      namespace: namespace_5
    });
    setSelectedPropertyIndex(usedPropertiesOrder.indexOf(propertyKey_2));
    setSelectedPropertyKey(propertyKey_2);
    setSelectedPropertyNamespace(namespace_5);
  };
  const body = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-12 gap-2 h-full bg-surface-50 dark:bg-surface-900", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cls$3("p-4 md:p-8 pb-20 md:pb-20", "col-span-12 lg:col-span-5 h-full overflow-auto", !asDialog && "border-r " + defaultBorderMixin$1), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex my-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-grow mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: "name", as: DebouncedTextField2, invisible: true, className: "-ml-1", inputClassName: "text-2xl font-headers", placeholder: "Collection name", size: "small", required: true, error: Boolean(errors?.name) }),
          owner && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography$3, { variant: "body2", className: "ml-2", color: "secondary", children: [
            "Created by ",
            owner.displayName
          ] })
        ] }),
        extraIcon && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-4", children: extraIcon }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ml-1 mt-2 flex flex-row gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$3, { title: "Get the code for this collection", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$3, { variant: "filled", disabled: inferringProperties, onClick: () => setCodeDialogOpen(true), children: /* @__PURE__ */ jsxRuntimeExports.jsx(CodeIcon2, {}) }) }),
          inferPropertiesFromData && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$3, { title: "Add new properties based on data", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$3, { variant: "filled", disabled: inferringProperties, onClick: inferPropertiesFromData, children: inferringProperties ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress$2, { size: "small" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(AutorenewIcon2, {}) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$3, { title: "Add new property", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { variant: "outlined", onClick: () => setNewPropertyDialogOpen(true), children: /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon$1, {}) }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyTree, { className: "pl-8", inferredPropertyKeys, selectedPropertyKey: selectedPropertyKey ? getFullId(selectedPropertyKey, selectedPropertyNamespace) : void 0, properties: values.properties, additionalFields: values.additionalFields, propertiesOrder: usedPropertiesOrder, onPropertyClick, onPropertyMove, onPropertyRemove: isNewCollection ? deleteProperty : void 0, collectionEditable, errors }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { className: "mt-8 w-full", color: "primary", variant: "outlined", size: "large", onClick: () => setNewPropertyDialogOpen(true), startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon$1, {}), children: "Add new property" })
    ] }),
    !asDialog && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12 lg:col-span-7 p-4 md:py-8 md:px-4 h-full overflow-auto pb-20 md:pb-20", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper$2, { className: "sticky top-8 p-4 min-h-full border border-transparent w-full flex flex-col justify-center ", children: [
      selectedPropertyFullId && selectedProperty && !isPropertyBuilder$1(selectedProperty) && /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyForm, { inArray: false, existingProperty: !isNewCollection, autoUpdateId: false, allowDataInference: !isNewCollection, autoOpenTypeSelect: false, propertyKey: selectedPropertyKey, propertyNamespace: selectedPropertyNamespace, property: selectedProperty, onPropertyChanged, onDelete: deleteProperty, onError: onPropertyErrorInternal, forceShowErrors: showErrors, initialErrors, getData, propertyConfigs, collectionEditable }, `edit_view_${selectedPropertyIndex}`),
      !selectedProperty && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full flex flex-col items-center justify-center h-full gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "label", className: "", children: emptyCollection ? "Now you can add your first property" : "Select a property to edit it" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Button$3, { variant: "outlined", onClick: () => setNewPropertyDialogOpen(true), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon$1, {}),
          "Add new property"
        ] })
      ] }),
      selectedProperty && isPropertyBuilder$1(selectedProperty) && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "label", className: "flex items-center justify-center", children: "This property is defined as a property builder in code" })
    ] }) }),
    asDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyFormDialog, { inArray: false, open: selectedPropertyIndex !== void 0, autoUpdateId: !selectedProperty, allowDataInference: !isNewCollection, existingProperty: true, autoOpenTypeSelect: false, propertyKey: selectedPropertyKey, propertyNamespace: selectedPropertyNamespace, property: selectedProperty, onPropertyChanged, onDelete: deleteProperty, onError: onPropertyErrorInternal, forceShowErrors: showErrors, initialErrors, getData, propertyConfigs, collectionEditable, onCancel: closePropertyDialog, onOkClicked: asDialog ? closePropertyDialog : void 0 }, `edit_view_${selectedPropertyIndex}`)
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    body,
    /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyFormDialog, { inArray: false, existingProperty: false, autoOpenTypeSelect: true, autoUpdateId: true, forceShowErrors: showErrors, open: newPropertyDialogOpen, onCancel: () => setNewPropertyDialogOpen(false), onPropertyChanged: onPropertyCreated, getData, allowDataInference: !isNewCollection, propertyConfigs, collectionEditable, existingPropertyKeys: values.propertiesOrder }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(GetCodeDialog, { collection: values, open: codeDialogOpen, onOpenChange: setCodeDialogOpen }) })
  ] });
}
function UnsavedChangesDialog(t0) {
  const $2 = c_1(23);
  const {
    open,
    handleOk,
    handleCancel,
    body,
    title
  } = t0;
  let t1;
  if ($2[0] !== handleCancel || $2[1] !== handleOk) {
    t1 = (open_0) => open_0 ? handleCancel() : handleOk();
    $2[0] = handleCancel;
    $2[1] = handleOk;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  const t2 = title ?? "Unsaved changes";
  let t3;
  if ($2[3] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle$2, { children: t2 });
    $2[3] = t2;
    $2[4] = t3;
  } else {
    t3 = $2[4];
  }
  let t4;
  if ($2[5] !== body) {
    t4 = body && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { children: body });
    $2[5] = body;
    $2[6] = t4;
  } else {
    t4 = $2[6];
  }
  let t5;
  if ($2[7] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { children: "Are you sure?" });
    $2[7] = t5;
  } else {
    t5 = $2[7];
  }
  let t6;
  if ($2[8] !== t4) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent$2, { children: [
      t4,
      t5
    ] });
    $2[8] = t4;
    $2[9] = t6;
  } else {
    t6 = $2[9];
  }
  let t7;
  if ($2[10] !== handleCancel) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { variant: "text", onClick: handleCancel, autoFocus: true, children: " Cancel " });
    $2[10] = handleCancel;
    $2[11] = t7;
  } else {
    t7 = $2[11];
  }
  let t8;
  if ($2[12] !== handleOk) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { onClick: handleOk, children: " Ok " });
    $2[12] = handleOk;
    $2[13] = t8;
  } else {
    t8 = $2[13];
  }
  let t9;
  if ($2[14] !== t7 || $2[15] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions$1, { children: [
      t7,
      t8
    ] });
    $2[14] = t7;
    $2[15] = t8;
    $2[16] = t9;
  } else {
    t9 = $2[16];
  }
  let t10;
  if ($2[17] !== open || $2[18] !== t1 || $2[19] !== t3 || $2[20] !== t6 || $2[21] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog$2, { open, onOpenChange: t1, "aria-labelledby": "alert-dialog-title", "aria-describedby": "alert-dialog-description", children: [
      t3,
      t6,
      t9
    ] });
    $2[17] = open;
    $2[18] = t1;
    $2[19] = t3;
    $2[20] = t6;
    $2[21] = t9;
    $2[22] = t10;
  } else {
    t10 = $2[22];
  }
  return t10;
}
function EntityCustomViewsSelectDialog(t0) {
  const $2 = c_1(15);
  const {
    open,
    onClose
  } = t0;
  const {
    entityViews
  } = useCustomizationController$3();
  let t1;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle$2, { children: "Select custom view" });
    $2[0] = t1;
  } else {
    t1 = $2[0];
  }
  let t2;
  if ($2[1] !== entityViews || $2[2] !== onClose) {
    t2 = entityViews?.map((view) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Button$3, { onClick: () => onClose(view.key), fullWidth: true, variant: "text", children: [
      view.name,
      " (",
      view.key,
      ")"
    ] }, view.key));
    $2[1] = entityViews;
    $2[2] = onClose;
    $2[3] = t2;
  } else {
    t2 = $2[3];
  }
  let t3;
  if ($2[4] !== entityViews) {
    t3 = (entityViews ?? []).length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "body2", children: "No custom views defined" });
    $2[4] = entityViews;
    $2[5] = t3;
  } else {
    t3 = $2[5];
  }
  let t4;
  if ($2[6] !== t2 || $2[7] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent$2, { className: "flex flex-col gap-4", children: [
      t2,
      t3
    ] });
    $2[6] = t2;
    $2[7] = t3;
    $2[8] = t4;
  } else {
    t4 = $2[8];
  }
  let t5;
  if ($2[9] !== onClose) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { variant: "outlined", onClick: () => onClose(), children: "Cancel" }) });
    $2[9] = onClose;
    $2[10] = t5;
  } else {
    t5 = $2[10];
  }
  let t6;
  if ($2[11] !== open || $2[12] !== t4 || $2[13] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog$2, { maxWidth: "md", open, children: [
      t1,
      t4,
      t5
    ] });
    $2[11] = open;
    $2[12] = t4;
    $2[13] = t5;
    $2[14] = t6;
  } else {
    t6 = $2[14];
  }
  return t6;
}
function SubcollectionsEditTab(t0) {
  const $2 = c_1(104);
  const {
    collection: collection2,
    configController,
    collectionInference,
    getUser,
    parentCollectionIds
  } = t0;
  const {
    entityViews: contextEntityViews
  } = useCustomizationController$3();
  const [subcollectionToDelete, setSubcollectionToDelete] = React__default.useState();
  const [addEntityViewDialogOpen, setAddEntityViewDialogOpen] = React__default.useState(false);
  const [viewToDelete, setViewToDelete] = React__default.useState();
  const [currentDialog, setCurrentDialog] = React__default.useState();
  const {
    values,
    setFieldValue
  } = useFormex();
  let t1;
  if ($2[0] !== collection2.subcollections) {
    t1 = collection2.subcollections ?? [];
    $2[0] = collection2.subcollections;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  const [subcollections, setSubcollections] = React__default.useState(t1);
  let T0;
  let T1;
  let T2;
  let T3;
  let t10;
  let t11;
  let t12;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  if ($2[2] !== collection2.entityViews || $2[3] !== contextEntityViews || $2[4] !== subcollections || $2[5] !== values.entityViews || $2[6] !== values.name) {
    const resolvedEntityViews = values.entityViews?.filter(_temp$3$1).map((e_0) => resolveEntityView2(e_0, contextEntityViews)).filter(Boolean) ?? [];
    const hardCodedEntityViews = collection2.entityViews?.filter(_temp2$2$1) ?? [];
    const totalEntityViews = resolvedEntityViews.length + hardCodedEntityViews.length;
    t12 = "overflow-auto my-auto";
    T3 = Container$1;
    t10 = "2xl";
    t11 = "flex flex-col gap-4 p-8 m-auto";
    t8 = "flex  flex-col gap-16";
    let t132;
    if ($2[22] !== values.name) {
      t132 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography$3, { variant: "h5", children: [
        "Subcollections of ",
        values.name
      ] });
      $2[22] = values.name;
      $2[23] = t132;
    } else {
      t132 = $2[23];
    }
    let t142;
    if ($2[24] !== subcollections) {
      t142 = subcollections && subcollections.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Table2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody2, { children: subcollections.map((subcollection) => /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow2, { onClick: () => setCurrentDialog({
        isNewCollection: false,
        editedCollectionId: subcollection.id
      }), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell2, { align: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "subtitle2", className: "flex-grow", children: subcollection.name }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell2, { align: "right", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$3, { title: "Remove", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$3, { size: "small", onClick: (e_2) => {
          e_2.preventDefault();
          e_2.stopPropagation();
          setSubcollectionToDelete(subcollection.id);
        }, color: "inherit", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteIcon2, { size: "small" }) }) }) })
      ] }, subcollection.path)) }) });
      $2[24] = subcollections;
      $2[25] = t142;
    } else {
      t142 = $2[25];
    }
    let t152;
    if ($2[26] === Symbol.for("react.memo_cache_sentinel")) {
      t152 = () => {
        setCurrentDialog({
          isNewCollection: true
        });
      };
      $2[26] = t152;
    } else {
      t152 = $2[26];
    }
    let t162;
    if ($2[27] === Symbol.for("react.memo_cache_sentinel")) {
      t162 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { onClick: t152, variant: "text", startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon$1, {}), children: "Add subcollection" });
      $2[27] = t162;
    } else {
      t162 = $2[27];
    }
    let t172;
    if ($2[28] !== t142) {
      t172 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper$2, { className: "flex flex-col gap-4 p-2 w-full", children: [
        t142,
        t162
      ] });
      $2[28] = t142;
      $2[29] = t172;
    } else {
      t172 = $2[29];
    }
    if ($2[30] !== t132 || $2[31] !== t172) {
      t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-grow flex flex-col gap-4 items-start", children: [
        t132,
        t172
      ] });
      $2[30] = t132;
      $2[31] = t172;
      $2[32] = t9;
    } else {
      t9 = $2[32];
    }
    t5 = "flex-grow  flex flex-col gap-4 items-start";
    if ($2[33] === Symbol.for("react.memo_cache_sentinel")) {
      t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "h5", children: "Custom views" });
      $2[33] = t6;
    } else {
      t6 = $2[33];
    }
    if ($2[34] !== totalEntityViews) {
      t7 = totalEntityViews === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert$2, { action: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { variant: "text", size: "small", href: "https://firecms.co/docs/cloud/quickstart", component: "a", rel: "noopener noreferrer", target: "_blank", children: "More info" }), children: "Define your own custom views by uploading them with the CLI." });
      $2[34] = totalEntityViews;
      $2[35] = t7;
    } else {
      t7 = $2[35];
    }
    T2 = Paper$2;
    t4 = "flex flex-col gap-4 p-2 w-full";
    T1 = Table2;
    T0 = TableBody2;
    let t182;
    if ($2[36] === Symbol.for("react.memo_cache_sentinel")) {
      t182 = (view) => /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow2, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell2, { align: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "subtitle2", className: "flex-grow", children: view.name }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell2, { align: "right", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$3, { title: "Remove", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$3, { size: "small", onClick: (e_3) => {
          e_3.preventDefault();
          e_3.stopPropagation();
          setViewToDelete(view.key);
        }, color: "inherit", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteIcon2, { size: "small" }) }) }) })
      ] }, view.key);
      $2[36] = t182;
    } else {
      t182 = $2[36];
    }
    t2 = resolvedEntityViews.map(t182);
    t3 = hardCodedEntityViews.map(_temp3$5);
    $2[2] = collection2.entityViews;
    $2[3] = contextEntityViews;
    $2[4] = subcollections;
    $2[5] = values.entityViews;
    $2[6] = values.name;
    $2[7] = T0;
    $2[8] = T1;
    $2[9] = T2;
    $2[10] = T3;
    $2[11] = t10;
    $2[12] = t11;
    $2[13] = t12;
    $2[14] = t2;
    $2[15] = t3;
    $2[16] = t4;
    $2[17] = t5;
    $2[18] = t6;
    $2[19] = t7;
    $2[20] = t8;
    $2[21] = t9;
  } else {
    T0 = $2[7];
    T1 = $2[8];
    T2 = $2[9];
    T3 = $2[10];
    t10 = $2[11];
    t11 = $2[12];
    t12 = $2[13];
    t2 = $2[14];
    t3 = $2[15];
    t4 = $2[16];
    t5 = $2[17];
    t6 = $2[18];
    t7 = $2[19];
    t8 = $2[20];
    t9 = $2[21];
  }
  let t13;
  if ($2[37] !== T0 || $2[38] !== t2 || $2[39] !== t3) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsxs(T0, { children: [
      t2,
      t3
    ] });
    $2[37] = T0;
    $2[38] = t2;
    $2[39] = t3;
    $2[40] = t13;
  } else {
    t13 = $2[40];
  }
  let t14;
  if ($2[41] !== T1 || $2[42] !== t13) {
    t14 = /* @__PURE__ */ jsxRuntimeExports.jsx(T1, { children: t13 });
    $2[41] = T1;
    $2[42] = t13;
    $2[43] = t14;
  } else {
    t14 = $2[43];
  }
  let t15;
  if ($2[44] === Symbol.for("react.memo_cache_sentinel")) {
    t15 = () => {
      setAddEntityViewDialogOpen(true);
    };
    $2[44] = t15;
  } else {
    t15 = $2[44];
  }
  let t16;
  if ($2[45] === Symbol.for("react.memo_cache_sentinel")) {
    t16 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { onClick: t15, variant: "text", startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon$1, {}), children: "Add custom entity view" });
    $2[45] = t16;
  } else {
    t16 = $2[45];
  }
  let t17;
  if ($2[46] !== T2 || $2[47] !== t14 || $2[48] !== t4) {
    t17 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(T2, { className: t4, children: [
      t14,
      t16
    ] }) });
    $2[46] = T2;
    $2[47] = t14;
    $2[48] = t4;
    $2[49] = t17;
  } else {
    t17 = $2[49];
  }
  let t18;
  if ($2[50] !== t17 || $2[51] !== t5 || $2[52] !== t6 || $2[53] !== t7) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t5, children: [
      t6,
      t7,
      t17
    ] });
    $2[50] = t17;
    $2[51] = t5;
    $2[52] = t6;
    $2[53] = t7;
    $2[54] = t18;
  } else {
    t18 = $2[54];
  }
  let t19;
  if ($2[55] !== t18 || $2[56] !== t8 || $2[57] !== t9) {
    t19 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t8, children: [
      t9,
      t18
    ] });
    $2[55] = t18;
    $2[56] = t8;
    $2[57] = t9;
    $2[58] = t19;
  } else {
    t19 = $2[58];
  }
  let t20;
  if ($2[59] !== T3 || $2[60] !== t10 || $2[61] !== t11 || $2[62] !== t19) {
    t20 = /* @__PURE__ */ jsxRuntimeExports.jsx(T3, { maxWidth: t10, className: t11, children: t19 });
    $2[59] = T3;
    $2[60] = t10;
    $2[61] = t11;
    $2[62] = t19;
    $2[63] = t20;
  } else {
    t20 = $2[63];
  }
  let t21;
  if ($2[64] === Symbol.for("react.memo_cache_sentinel")) {
    t21 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
      height: "52px"
    } });
    $2[64] = t21;
  } else {
    t21 = $2[64];
  }
  let t22;
  if ($2[65] !== collection2.id || $2[66] !== configController || $2[67] !== parentCollectionIds || $2[68] !== subcollectionToDelete || $2[69] !== subcollections) {
    t22 = subcollectionToDelete && /* @__PURE__ */ jsxRuntimeExports.jsx(ConfirmationDialog2, { open: Boolean(subcollectionToDelete), onAccept: () => {
      const props = {
        id: subcollectionToDelete,
        parentCollectionIds: [...parentCollectionIds ?? [], collection2.id]
      };
      console.debug("Deleting subcollection", props);
      configController.deleteCollection(props).then(() => {
        setSubcollectionToDelete(void 0);
        setSubcollections(subcollections?.filter((e_4) => e_4.id !== subcollectionToDelete));
      });
    }, onCancel: () => setSubcollectionToDelete(void 0), title: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "Delete this subcollection?" }), body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      " This will ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: "not delete any data" }),
      ", only the collection in the CMS"
    ] }) });
    $2[65] = collection2.id;
    $2[66] = configController;
    $2[67] = parentCollectionIds;
    $2[68] = subcollectionToDelete;
    $2[69] = subcollections;
    $2[70] = t22;
  } else {
    t22 = $2[70];
  }
  let t23;
  if ($2[71] !== setFieldValue || $2[72] !== values.entityViews || $2[73] !== viewToDelete) {
    t23 = viewToDelete && /* @__PURE__ */ jsxRuntimeExports.jsx(ConfirmationDialog2, { open: Boolean(viewToDelete), onAccept: () => {
      setFieldValue("entityViews", values.entityViews?.filter((e_5) => e_5 !== viewToDelete));
      setViewToDelete(void 0);
    }, onCancel: () => setViewToDelete(void 0), title: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "Remove this view?" }), body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      "This will ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: "not delete any data" }),
      ", only the view in the CMS"
    ] }) });
    $2[71] = setFieldValue;
    $2[72] = values.entityViews;
    $2[73] = viewToDelete;
    $2[74] = t23;
  } else {
    t23 = $2[74];
  }
  const t24 = Boolean(currentDialog);
  let t25;
  if ($2[75] !== parentCollectionIds) {
    t25 = parentCollectionIds ?? [];
    $2[75] = parentCollectionIds;
    $2[76] = t25;
  } else {
    t25 = $2[76];
  }
  let t26;
  if ($2[77] !== t25 || $2[78] !== values.id) {
    t26 = [...t25, values.id];
    $2[77] = t25;
    $2[78] = values.id;
    $2[79] = t26;
  } else {
    t26 = $2[79];
  }
  let t27;
  if ($2[80] !== subcollections) {
    t27 = (updatedCollection) => {
      if (updatedCollection && !subcollections.map(_temp4).includes(updatedCollection.id)) {
        setSubcollections([...subcollections, updatedCollection]);
      }
      setCurrentDialog(void 0);
    };
    $2[80] = subcollections;
    $2[81] = t27;
  } else {
    t27 = $2[81];
  }
  let t28;
  if ($2[82] !== collection2 || $2[83] !== collectionInference || $2[84] !== configController || $2[85] !== currentDialog || $2[86] !== getUser || $2[87] !== t24 || $2[88] !== t26 || $2[89] !== t27) {
    t28 = /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionEditorDialog, { open: t24, configController, parentCollection: collection2, collectionInference, parentCollectionIds: t26, isNewCollection: false, ...currentDialog, getUser, handleClose: t27 });
    $2[82] = collection2;
    $2[83] = collectionInference;
    $2[84] = configController;
    $2[85] = currentDialog;
    $2[86] = getUser;
    $2[87] = t24;
    $2[88] = t26;
    $2[89] = t27;
    $2[90] = t28;
  } else {
    t28 = $2[90];
  }
  let t29;
  if ($2[91] !== setFieldValue || $2[92] !== values.entityViews) {
    t29 = (selectedViewKey) => {
      if (selectedViewKey) {
        setFieldValue("entityViews", [...values.entityViews ?? [], selectedViewKey]);
      }
      setAddEntityViewDialogOpen(false);
    };
    $2[91] = setFieldValue;
    $2[92] = values.entityViews;
    $2[93] = t29;
  } else {
    t29 = $2[93];
  }
  let t30;
  if ($2[94] !== addEntityViewDialogOpen || $2[95] !== t29) {
    t30 = /* @__PURE__ */ jsxRuntimeExports.jsx(EntityCustomViewsSelectDialog, { open: addEntityViewDialogOpen, onClose: t29 });
    $2[94] = addEntityViewDialogOpen;
    $2[95] = t29;
    $2[96] = t30;
  } else {
    t30 = $2[96];
  }
  let t31;
  if ($2[97] !== t12 || $2[98] !== t20 || $2[99] !== t22 || $2[100] !== t23 || $2[101] !== t28 || $2[102] !== t30) {
    t31 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t12, children: [
      t20,
      t21,
      t22,
      t23,
      t28,
      t30
    ] });
    $2[97] = t12;
    $2[98] = t20;
    $2[99] = t22;
    $2[100] = t23;
    $2[101] = t28;
    $2[102] = t30;
    $2[103] = t31;
  } else {
    t31 = $2[103];
  }
  return t31;
}
function _temp4(e_6) {
  return e_6.id;
}
function _temp3$5(view_0) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableRow2, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableCell2, { align: "left", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "subtitle2", className: "flex-grow", children: view_0.name }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography$3, { variant: "caption", className: "flex-grow", children: [
      "This view is defined in code with key ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: view_0.key })
    ] })
  ] }) }, view_0.key);
}
function _temp2$2$1(e_1) {
  return typeof e_1 !== "string";
}
function _temp$3$1(e) {
  return typeof e === "string";
}
const productsCollectionTemplate = {
  id: "products",
  path: "products",
  name: "Products",
  singularName: "Product",
  icon: "shopping_cart",
  description: "List of the products currently sold in your shop",
  properties: makePropertiesEditable2({
    name: {
      dataType: "string",
      name: "Name",
      description: "Name of this product",
      validation: {
        required: true
      }
    },
    brand: {
      dataType: "string",
      name: "Brand",
      validation: {
        required: true
      }
    },
    description: {
      dataType: "string",
      name: "Description",
      description: "Description of this product, supports markdown",
      markdown: true
    },
    main_image: {
      dataType: "string",
      name: "Image",
      storage: {
        storagePath: "images",
        acceptedFiles: ["image/*"]
      },
      description: "Upload field for images"
    },
    available: {
      dataType: "boolean",
      name: "Available",
      columnWidth: 100,
      description: "Is this product available in the website"
    },
    price: {
      dataType: "number",
      name: "Price",
      validation: {
        requiredMessage: "You must set a positive price",
        min: 0
      }
    },
    images: {
      dataType: "array",
      name: "Images",
      hideFromCollection: true,
      of: {
        dataType: "string",
        storage: {
          storagePath: "images",
          acceptedFiles: ["image/*"]
        }
      }
    },
    related_products: {
      dataType: "array",
      name: "Related products",
      description: "Products related to this one",
      of: {
        dataType: "reference",
        path: "products"
      }
    },
    metadata: {
      name: "Metadata",
      description: "This is an example of a map property",
      dataType: "map",
      keyValue: true
    },
    added_on: {
      dataType: "date",
      name: "Added on",
      autoValue: "on_create"
    }
  })
};
const blogCollectionTemplate = {
  id: "blog",
  path: "blog",
  name: "Blog",
  singularName: "Blog entry",
  icon: "article",
  description: "A collection of blog entries",
  defaultSize: "l",
  properties: makePropertiesEditable2({
    name: {
      name: "Name",
      validation: {
        required: true
      },
      dataType: "string"
    },
    header_image: {
      name: "Header image",
      dataType: "string",
      storage: {
        storagePath: "images",
        acceptedFiles: ["image/*"],
        metadata: {
          cacheControl: "max-age=1000000"
        }
      }
    },
    content: {
      name: "Content",
      description: "Content blocks for the blog entry",
      validation: {
        required: true
      },
      dataType: "array",
      oneOf: {
        typeField: "type",
        valueField: "value",
        properties: {
          text: {
            dataType: "string",
            name: "Text",
            markdown: true
          },
          quote: {
            dataType: "string",
            name: "Quote",
            multiline: true
          },
          images: {
            name: "Images",
            dataType: "array",
            of: {
              dataType: "string",
              storage: {
                storagePath: "images",
                acceptedFiles: ["image/*"],
                metadata: {
                  cacheControl: "max-age=1000000"
                }
              }
            },
            description: "This fields allows uploading multiple images at once and reordering"
          },
          products: {
            name: "Products",
            dataType: "array",
            of: {
              dataType: "reference",
              path: "products",
              previewProperties: ["name", "main_image"]
            }
          }
        },
        propertiesOrder: ["text", "quote", "images", "products"]
      }
    },
    created_on: {
      name: "Created on",
      dataType: "date",
      autoValue: "on_create"
    },
    status: {
      name: "Status",
      validation: {
        required: true
      },
      dataType: "string",
      enumValues: {
        published: {
          id: "published",
          label: "Published"
        },
        draft: "Draft"
      },
      defaultValue: "draft"
    },
    publish_date: {
      name: "Publish date",
      dataType: "date",
      clearable: true
    },
    reviewed: {
      name: "Reviewed",
      dataType: "boolean"
    },
    tags: {
      name: "Tags",
      description: "Example of generic array",
      dataType: "array",
      of: {
        dataType: "string",
        previewAsTag: true
      }
    }
  }),
  initialFilter: {
    status: ["==", "published"]
  }
};
const usersCollectionTemplate = {
  id: "users",
  path: "users",
  name: "Users",
  singularName: "User",
  description: "Registered users in the app/web",
  icon: "person",
  properties: makePropertiesEditable2({
    displayName: {
      name: "Display name",
      dataType: "string"
    },
    email: {
      name: "Email",
      dataType: "string",
      email: true
    },
    emailVerified: {
      name: "Email verified",
      dataType: "boolean"
    },
    phone: {
      name: "Phone",
      dataType: "string"
    },
    favourite_products: {
      name: "Favourite products",
      dataType: "array",
      of: {
        dataType: "reference",
        path: "products"
      }
    },
    photoURL: {
      name: "Photo URL",
      dataType: "string",
      url: "image"
    }
  })
};
const pagesCollectionTemplate = {
  id: "pages",
  path: "pages",
  name: "Pages",
  singularName: "Page",
  icon: "insert_drive_file",
  description: "List of website pages that can be edited here",
  properties: {
    title: {
      dataType: "string",
      name: "Page Title",
      validation: {
        required: true
      }
    },
    slug: {
      dataType: "string",
      name: "URL Slug",
      validation: {
        required: true,
        unique: true,
        matches: "^[a-z0-9]+(?:-[a-z0-9]+)*$",
        matchesMessage: "Must be lowercase, alphanumeric, and hyphenated"
      }
    },
    hero_section: {
      dataType: "map",
      name: "Hero Section",
      properties: {
        headline: {
          dataType: "string",
          name: "Headline",
          validation: {
            required: true
          }
        },
        subhead: {
          dataType: "string",
          name: "Subheadline"
        },
        background_image: {
          dataType: "string",
          name: "Background Image",
          storage: {
            storagePath: "page_hero/images",
            acceptedFiles: ["image/*"]
          }
        },
        call_to_action: {
          dataType: "string",
          name: "Call to Action"
        },
        call_to_action_link: {
          dataType: "string",
          name: "CTA Link",
          url: true
        }
      }
    },
    content: {
      dataType: "array",
      name: "Content",
      oneOf: {
        properties: {
          section: {
            dataType: "map",
            name: "Section",
            properties: {
              title: {
                dataType: "string",
                name: "Section Title",
                validation: {
                  required: true
                }
              },
              content: {
                dataType: "string",
                name: "Section Content",
                markdown: true
              },
              image: {
                dataType: "string",
                name: "Section Image",
                storage: {
                  storagePath: "page_sections/images",
                  acceptedFiles: ["image/*"]
                }
              },
              link: {
                dataType: "string",
                name: "Section Link",
                url: true
              }
            }
          },
          image: {
            dataType: "string",
            name: "Image",
            storage: {
              storagePath: "page_sections/images",
              acceptedFiles: ["image/*"]
            }
          },
          slider: {
            dataType: "array",
            name: "Slider",
            of: {
              dataType: "map",
              properties: {
                title: {
                  dataType: "string",
                  name: "Title",
                  validation: {
                    required: true
                  }
                },
                image: {
                  dataType: "string",
                  storage: {
                    storagePath: "page_sections/images",
                    acceptedFiles: ["image/*"]
                  }
                }
              }
            }
          }
        }
      }
    },
    sidebar: {
      dataType: "map",
      name: "Sidebar",
      properties: {
        title: {
          dataType: "string",
          name: "Sidebar Title",
          validation: {
            required: false
          }
        },
        content: {
          dataType: "string",
          name: "Sidebar Content",
          markdown: true
        }
      }
    },
    seo_metadata: {
      dataType: "map",
      name: "SEO Metadata",
      properties: {
        meta_title: {
          dataType: "string",
          name: "Meta Title"
        },
        meta_description: {
          dataType: "string",
          name: "Meta Description"
        },
        focus_keywords: {
          dataType: "array",
          name: "Focus Keywords",
          of: {
            dataType: "string"
          }
        }
      }
    },
    footer_override: {
      dataType: "string",
      name: "Footer Override",
      markdown: true
    },
    publish_date: {
      dataType: "date",
      name: "Publish Date",
      validation: {
        required: true
      }
    },
    last_updated: {
      dataType: "date",
      name: "Last Updated",
      autoValue: "on_update"
    },
    is_published: {
      dataType: "boolean",
      name: "Is Published",
      columnWidth: 100,
      description: "Should this page be live on the site?"
    }
  }
};
function CollectionEditorWelcomeView(t0) {
  const $2 = c_1(56);
  const {
    path,
    pathSuggestions,
    parentCollection,
    onContinue,
    existingCollectionPaths
  } = t0;
  const [loadingPathSuggestions, setLoadingPathSuggestions] = useState$3(false);
  const [filteredPathSuggestions, setFilteredPathSuggestions] = useState$3();
  let t1;
  let t2;
  if ($2[0] !== existingCollectionPaths || $2[1] !== path || $2[2] !== pathSuggestions) {
    t1 = () => {
      if (pathSuggestions && existingCollectionPaths) {
        setLoadingPathSuggestions(true);
        pathSuggestions(path).then((suggestions) => {
          const filteredSuggestions = suggestions.filter((s) => !(existingCollectionPaths ?? []).find((c2) => c2.trim().toLowerCase() === s.trim().toLowerCase()));
          setFilteredPathSuggestions(filteredSuggestions);
        }).finally(() => setLoadingPathSuggestions(false));
      }
    };
    t2 = [existingCollectionPaths, path, pathSuggestions];
    $2[0] = existingCollectionPaths;
    $2[1] = path;
    $2[2] = pathSuggestions;
    $2[3] = t1;
    $2[4] = t2;
  } else {
    t1 = $2[3];
    t2 = $2[4];
  }
  useEffect$4(t1, t2);
  const {
    setFieldValue,
    setValues
  } = useFormex();
  let t3;
  if ($2[5] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-row py-2 pt-3 items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "h4", className: "flex-grow", children: "New collection" }) });
    $2[5] = t3;
  } else {
    t3 = $2[5];
  }
  let t4;
  if ($2[6] !== parentCollection) {
    t4 = parentCollection && /* @__PURE__ */ jsxRuntimeExports.jsx(Chip$1, { colorScheme: "tealDarker", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography$3, { variant: "caption", children: [
      "This is a subcollection of ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: parentCollection.name })
    ] }) });
    $2[6] = parentCollection;
    $2[7] = t4;
  } else {
    t4 = $2[7];
  }
  let t5;
  if ($2[8] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "caption", color: "secondary", children: " Use one of the existing paths in your database:" });
    $2[8] = t5;
  } else {
    t5 = $2[8];
  }
  let t6;
  if ($2[9] !== filteredPathSuggestions || $2[10] !== loadingPathSuggestions) {
    t6 = loadingPathSuggestions && !filteredPathSuggestions && /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress$2, { size: "small" });
    $2[9] = filteredPathSuggestions;
    $2[10] = loadingPathSuggestions;
    $2[11] = t6;
  } else {
    t6 = $2[11];
  }
  let t7;
  if ($2[12] !== filteredPathSuggestions || $2[13] !== onContinue || $2[14] !== setFieldValue) {
    t7 = filteredPathSuggestions?.map((suggestion, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Chip$1, { colorScheme: "cyanLighter", onClick: () => {
      setFieldValue("name", unslugify$2(suggestion));
      setFieldValue("id", suggestion);
      setFieldValue("path", suggestion);
      setFieldValue("properties", void 0);
      onContinue();
    }, size: "small", children: suggestion }, suggestion));
    $2[12] = filteredPathSuggestions;
    $2[13] = onContinue;
    $2[14] = setFieldValue;
    $2[15] = t7;
  } else {
    t7 = $2[15];
  }
  let t8;
  if ($2[16] !== filteredPathSuggestions || $2[17] !== loadingPathSuggestions) {
    t8 = !loadingPathSuggestions && (filteredPathSuggestions ?? [])?.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "caption", children: "No suggestions" });
    $2[16] = filteredPathSuggestions;
    $2[17] = loadingPathSuggestions;
    $2[18] = t8;
  } else {
    t8 = $2[18];
  }
  let t9;
  if ($2[19] !== t6 || $2[20] !== t7 || $2[21] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "my-2", children: [
      t5,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-x-2 gap-y-1 items-center my-2 min-h-7", children: [
        t6,
        t7,
        t8
      ] })
    ] });
    $2[19] = t6;
    $2[20] = t7;
    $2[21] = t8;
    $2[22] = t9;
  } else {
    t9 = $2[22];
  }
  let t10;
  if ($2[23] === Symbol.for("react.memo_cache_sentinel")) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "caption", color: "secondary", children: " Select a template:" });
    $2[23] = t10;
  } else {
    t10 = $2[23];
  }
  let t11;
  if ($2[24] === Symbol.for("react.memo_cache_sentinel")) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { size: "small", iconKey: productsCollectionTemplate.icon });
    $2[24] = t11;
  } else {
    t11 = $2[24];
  }
  let t12;
  if ($2[25] !== onContinue || $2[26] !== setValues) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(TemplateButton, { title: "Products", subtitle: "A collection of products with images, prices and stock", icon: t11, onClick: () => {
      setValues(productsCollectionTemplate);
      onContinue();
    } });
    $2[25] = onContinue;
    $2[26] = setValues;
    $2[27] = t12;
  } else {
    t12 = $2[27];
  }
  let t13;
  if ($2[28] === Symbol.for("react.memo_cache_sentinel")) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { size: "small", iconKey: usersCollectionTemplate.icon });
    $2[28] = t13;
  } else {
    t13 = $2[28];
  }
  let t14;
  if ($2[29] !== onContinue || $2[30] !== setValues) {
    t14 = /* @__PURE__ */ jsxRuntimeExports.jsx(TemplateButton, { title: "Users", subtitle: "A collection of users with emails, names and roles", icon: t13, onClick: () => {
      setValues(usersCollectionTemplate);
      onContinue();
    } });
    $2[29] = onContinue;
    $2[30] = setValues;
    $2[31] = t14;
  } else {
    t14 = $2[31];
  }
  let t15;
  if ($2[32] === Symbol.for("react.memo_cache_sentinel")) {
    t15 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { size: "small", iconKey: blogCollectionTemplate.icon });
    $2[32] = t15;
  } else {
    t15 = $2[32];
  }
  let t16;
  if ($2[33] !== onContinue || $2[34] !== setValues) {
    t16 = /* @__PURE__ */ jsxRuntimeExports.jsx(TemplateButton, { title: "Blog posts", subtitle: "A collection of blog posts with images, authors and complex content", icon: t15, onClick: () => {
      setValues(blogCollectionTemplate);
      onContinue();
    } });
    $2[33] = onContinue;
    $2[34] = setValues;
    $2[35] = t16;
  } else {
    t16 = $2[35];
  }
  let t17;
  if ($2[36] === Symbol.for("react.memo_cache_sentinel")) {
    t17 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { size: "small", iconKey: pagesCollectionTemplate.icon });
    $2[36] = t17;
  } else {
    t17 = $2[36];
  }
  let t18;
  if ($2[37] !== onContinue || $2[38] !== setValues) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsx(TemplateButton, { title: "Pages", subtitle: "A collection of pages with images, authors and complex content", icon: t17, onClick: () => {
      setValues(pagesCollectionTemplate);
      onContinue();
    } });
    $2[37] = onContinue;
    $2[38] = setValues;
    $2[39] = t18;
  } else {
    t18 = $2[39];
  }
  let t19;
  if ($2[40] !== t12 || $2[41] !== t14 || $2[42] !== t16 || $2[43] !== t18) {
    t19 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "my-2", children: [
      t10,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4", children: [
        t12,
        t14,
        t16,
        t18
      ] })
    ] });
    $2[40] = t12;
    $2[41] = t14;
    $2[42] = t16;
    $2[43] = t18;
    $2[44] = t19;
  } else {
    t19 = $2[44];
  }
  let t20;
  if ($2[45] !== onContinue || $2[46] !== parentCollection) {
    t20 = !parentCollection && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "caption", color: "secondary", className: "mb-2", children: " Create a collection from a file (csv, json, xls, xslx...)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ImportFileUpload, { onDataAdded: (data, propertiesOrder) => onContinue(data, propertiesOrder) })
    ] });
    $2[45] = onContinue;
    $2[46] = parentCollection;
    $2[47] = t20;
  } else {
    t20 = $2[47];
  }
  let t21;
  if ($2[48] !== onContinue) {
    t21 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { variant: "text", onClick: () => onContinue(), className: "my-2", children: "Continue from scratch" }) });
    $2[48] = onContinue;
    $2[49] = t21;
  } else {
    t21 = $2[49];
  }
  let t22;
  if ($2[50] !== t19 || $2[51] !== t20 || $2[52] !== t21 || $2[53] !== t4 || $2[54] !== t9) {
    t22 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-auto my-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$1, { maxWidth: "4xl", className: "flex flex-col gap-4 p-8 m-auto", children: [
      t3,
      t4,
      t9,
      t19,
      t20,
      t21
    ] }) });
    $2[50] = t19;
    $2[51] = t20;
    $2[52] = t21;
    $2[53] = t4;
    $2[54] = t9;
    $2[55] = t22;
  } else {
    t22 = $2[55];
  }
  return t22;
}
function TemplateButton(t0) {
  const $2 = c_1(10);
  const {
    title,
    subtitle,
    icon,
    onClick
  } = t0;
  let t1;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = cls$3("my-2 rounded-md border mx-0 p-6 px-4 focus:outline-none transition ease-in-out duration-150 flex flex-row gap-4 items-center", "text-surface-700 dark:text-surface-accent-300", "hover:border-primary-dark hover:text-primary-dark dark:hover:text-primary focus:ring-primary hover:ring-1 hover:ring-primary", "border-surface-400 dark:border-surface-600 ");
    $2[0] = t1;
  } else {
    t1 = $2[0];
  }
  let t2;
  if ($2[1] !== title) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col items-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "subtitle1", children: title }) });
    $2[1] = title;
    $2[2] = t2;
  } else {
    t2 = $2[2];
  }
  let t3;
  if ($2[3] !== icon || $2[4] !== onClick || $2[5] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Card$2, { onClick, className: t1, children: [
      icon,
      t2
    ] });
    $2[3] = icon;
    $2[4] = onClick;
    $2[5] = t2;
    $2[6] = t3;
  } else {
    t3 = $2[6];
  }
  let t4;
  if ($2[7] !== subtitle || $2[8] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$3, { title: subtitle, asChild: true, children: t3 });
    $2[7] = subtitle;
    $2[8] = t3;
    $2[9] = t4;
  } else {
    t4 = $2[9];
  }
  return t4;
}
function CollectionEditorImportMapping(t0) {
  const $2 = c_1(33);
  const {
    importConfig,
    propertyConfigs,
    collectionEditable
  } = t0;
  const {
    setFieldValue,
    setFieldTouched,
    values
  } = useFormex();
  const [selectedProperty, setSelectedProperty] = useState$3(void 0);
  let t1;
  if ($2[0] !== values.propertiesOrder) {
    t1 = values.propertiesOrder ? {
      "": values.propertiesOrder
    } : {};
    $2[0] = values.propertiesOrder;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  const currentPropertiesOrderRef = React__default.useRef(t1);
  const propertyKey = selectedProperty ? selectedProperty.id : void 0;
  const property = selectedProperty || void 0;
  let t2;
  if ($2[2] !== importConfig || $2[3] !== setFieldTouched || $2[4] !== setFieldValue || $2[5] !== values) {
    t2 = (t32) => {
      const {
        id,
        property: property_0,
        previousId,
        namespace
      } = t32;
      const fullId = id ? getFullId(id, namespace) : void 0;
      const propertyPath = fullId ? idToPropertiesPath(fullId) : void 0;
      const getCurrentPropertiesOrder = (namespace_0) => {
        if (!namespace_0) {
          return currentPropertiesOrderRef.current[""];
        }
        return currentPropertiesOrderRef.current[namespace_0] ?? getIn(values, namespaceToPropertiesOrderPath(namespace_0));
      };
      const updatePropertiesOrder = (newPropertiesOrder, namespace_1) => {
        const propertiesOrderPath = namespaceToPropertiesOrderPath(namespace_1);
        setFieldValue(propertiesOrderPath, newPropertiesOrder, false);
        currentPropertiesOrderRef.current[namespace_1 ?? ""] = newPropertiesOrder;
      };
      if (previousId && previousId !== id) {
        const previousFullId = getFullId(previousId, namespace);
        const previousPropertyPath = idToPropertiesPath(previousFullId);
        const currentPropertiesOrder = getCurrentPropertiesOrder(namespace);
        const newPropertiesOrder_0 = currentPropertiesOrder.map((p) => p === previousId ? id : p).filter(_temp$2$1);
        updatePropertiesOrder(newPropertiesOrder_0, namespace);
        const newHeadersMapping = {
          ...importConfig.headersMapping
        };
        Object.keys(newHeadersMapping).forEach((key2) => {
          if (newHeadersMapping[key2] === previousId) {
            newHeadersMapping[key2] = id ?? "";
          }
        });
        importConfig.setHeadersMapping(newHeadersMapping);
        setFieldValue(previousPropertyPath, void 0, false);
        setFieldTouched(previousPropertyPath, false, false);
      }
      if (propertyPath) {
        setFieldValue(propertyPath, property_0, false);
        setFieldTouched(propertyPath, true, false);
      }
    };
    $2[2] = importConfig;
    $2[3] = setFieldTouched;
    $2[4] = setFieldValue;
    $2[5] = values;
    $2[6] = t2;
  } else {
    t2 = $2[6];
  }
  const onPropertyChanged = t2;
  let t3;
  if ($2[7] !== importConfig.importData || $2[8] !== setFieldTouched || $2[9] !== setFieldValue) {
    t3 = async (t42) => {
      const {
        id: id_0,
        importKey,
        property: property_1,
        namespace: namespace_2
      } = t42;
      const fullId_0 = id_0 ? getFullId(id_0, namespace_2) : void 0;
      const propertyPath_0 = fullId_0 ? idToPropertiesPath(fullId_0) : void 0;
      const propertyData = importConfig.importData.map((d) => getIn(d, importKey));
      const inferredNewProperty = {
        ...buildPropertyFromData(propertyData, property_1, getInferenceType),
        editable: true
      };
      if (propertyPath_0) {
        {
          setFieldValue(propertyPath_0, inferredNewProperty, false);
        }
        setFieldTouched(propertyPath_0, true, false);
      }
    };
    $2[7] = importConfig.importData;
    $2[8] = setFieldTouched;
    $2[9] = setFieldValue;
    $2[10] = t3;
  } else {
    t3 = $2[10];
  }
  const onPropertyTypeChanged = t3;
  let t4;
  if ($2[11] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "h6", className: "my-4 ml-3.5", children: "Data property mapping" });
    $2[11] = t4;
  } else {
    t4 = $2[11];
  }
  const t5 = values.properties;
  let t6;
  if ($2[12] !== onPropertyTypeChanged || $2[13] !== propertyConfigs || $2[14] !== setFieldValue) {
    t6 = (t72) => {
      const {
        property: property_2,
        propertyKey: propertyKey_0,
        importKey: importKey_0,
        isIdColumn
      } = t72;
      if (isIdColumn) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { children: " This column will be used as ID" });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ImportNewPropertyFieldPreview, { property: property_2, propertyKey: propertyKey_0, onPropertyNameChanged: (propertyKey_1, value) => setFieldValue(`properties.${propertyKey_1}.name`, value, false), onEditClick: () => {
        if (!propertyKey_0 || !property_2) {
          return;
        }
        setSelectedProperty({
          ...property_2,
          id: propertyKey_0,
          editable: true
        });
      }, propertyTypeView: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertySelect, { property: property_2, disabled: false, onPropertyChanged: (props) => onPropertyTypeChanged({
        ...props,
        importKey: importKey_0
      }), propertyKey: propertyKey_0, propertyConfigs }) });
    };
    $2[12] = onPropertyTypeChanged;
    $2[13] = propertyConfigs;
    $2[14] = setFieldValue;
    $2[15] = t6;
  } else {
    t6 = $2[15];
  }
  let t7;
  if ($2[16] !== importConfig || $2[17] !== t5 || $2[18] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$1, { maxWidth: "6xl", className: "flex flex-col gap-4 p-8 m-auto", children: [
      t4,
      /* @__PURE__ */ jsxRuntimeExports.jsx(DataNewPropertiesMapping, { importConfig, destinationProperties: t5, buildPropertyView: t6 })
    ] });
    $2[16] = importConfig;
    $2[17] = t5;
    $2[18] = t6;
    $2[19] = t7;
  } else {
    t7 = $2[19];
  }
  const t8 = selectedProperty !== void 0;
  let t10;
  let t9;
  if ($2[20] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = () => {
      setSelectedProperty(void 0);
    };
    t10 = () => {
      setSelectedProperty(void 0);
    };
    $2[20] = t10;
    $2[21] = t9;
  } else {
    t10 = $2[20];
    t9 = $2[21];
  }
  let t11;
  if ($2[22] !== collectionEditable || $2[23] !== onPropertyChanged || $2[24] !== property || $2[25] !== propertyConfigs || $2[26] !== propertyKey || $2[27] !== t8) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyFormDialog, { open: t8, propertyKey, property, inArray: false, autoUpdateId: false, onPropertyChanged, allowDataInference: false, collectionEditable, onOkClicked: t9, onCancel: t10, autoOpenTypeSelect: false, existingProperty: false, propertyConfigs });
    $2[22] = collectionEditable;
    $2[23] = onPropertyChanged;
    $2[24] = property;
    $2[25] = propertyConfigs;
    $2[26] = propertyKey;
    $2[27] = t8;
    $2[28] = t11;
  } else {
    t11 = $2[28];
  }
  let t12;
  if ($2[29] === Symbol.for("react.memo_cache_sentinel")) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
      height: "52px"
    } });
    $2[29] = t12;
  } else {
    t12 = $2[29];
  }
  let t13;
  if ($2[30] !== t11 || $2[31] !== t7) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "overflow-auto my-auto", children: [
      t7,
      t11,
      t12
    ] });
    $2[30] = t11;
    $2[31] = t7;
    $2[32] = t13;
  } else {
    t13 = $2[32];
  }
  return t13;
}
function _temp$2$1(p_0) {
  return p_0 !== void 0;
}
function PropertySelect(t0) {
  const $2 = c_1(24);
  const {
    property,
    onPropertyChanged,
    propertyKey,
    propertyConfigs,
    disabled
  } = t0;
  let t1;
  if ($2[0] !== property) {
    t1 = property ? getFieldId$1(property) : null;
    $2[0] = property;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  const fieldId = t1;
  let t2;
  if ($2[2] !== property || $2[3] !== propertyConfigs) {
    t2 = property ? getFieldConfig2(property, propertyConfigs) : null;
    $2[2] = property;
    $2[3] = propertyConfigs;
    $2[4] = t2;
  } else {
    t2 = $2[4];
  }
  const widget = t2;
  const [selectOpen, setSelectOpen] = useState$3(false);
  const t3 = property && widget ? `${widget?.name} - ${property.dataType}` : void 0;
  const t4 = selectOpen ? false : void 0;
  const t5 = !widget;
  const t6 = fieldId ?? "";
  let t7;
  if ($2[5] !== widget) {
    t7 = (value) => {
      if (!widget) {
        return null;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyConfigBadge2, { propertyConfig: widget });
    };
    $2[5] = widget;
    $2[6] = t7;
  } else {
    t7 = $2[6];
  }
  let t8;
  if ($2[7] !== onPropertyChanged || $2[8] !== property || $2[9] !== propertyConfigs || $2[10] !== propertyKey) {
    t8 = (newSelectedWidgetId) => {
      const newProperty = updatePropertyFromWidget(property, newSelectedWidgetId, propertyConfigs);
      if (!propertyKey) {
        return;
      }
      onPropertyChanged({
        id: propertyKey,
        property: newProperty,
        previousId: propertyKey,
        namespace: void 0
      });
    };
    $2[7] = onPropertyChanged;
    $2[8] = property;
    $2[9] = propertyConfigs;
    $2[10] = propertyKey;
    $2[11] = t8;
  } else {
    t8 = $2[11];
  }
  let t9;
  if ($2[12] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = Object.entries(supportedFields).map(_temp2$1$1);
    $2[12] = t9;
  } else {
    t9 = $2[12];
  }
  let t10;
  if ($2[13] !== disabled || $2[14] !== selectOpen || $2[15] !== t5 || $2[16] !== t6 || $2[17] !== t7 || $2[18] !== t8) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1, { open: selectOpen, onOpenChange: setSelectOpen, invisible: true, size: "large", className: "w-full", disabled, error: t5, fullWidth: true, value: t6, placeholder: "Select a property widget", position: "item-aligned", renderValue: t7, onValueChange: t8, children: t9 });
    $2[13] = disabled;
    $2[14] = selectOpen;
    $2[15] = t5;
    $2[16] = t6;
    $2[17] = t7;
    $2[18] = t8;
    $2[19] = t10;
  } else {
    t10 = $2[19];
  }
  let t11;
  if ($2[20] !== t10 || $2[21] !== t3 || $2[22] !== t4) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$3, { title: t3, open: t4, children: t10 });
    $2[20] = t10;
    $2[21] = t3;
    $2[22] = t4;
    $2[23] = t11;
  } else {
    t11 = $2[23];
  }
  return t11;
}
function _temp2$1$1(t0) {
  const [key2, widget_0] = t0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PropertySelectItem, { value: key2, optionDisabled: false, propertyConfig: widget_0, existing: false }, key2);
}
function PropertySelectItem(t0) {
  const $2 = c_1(19);
  const {
    value,
    optionDisabled,
    propertyConfig,
    existing
  } = t0;
  const t1 = optionDisabled ? "w-full" : "";
  let t2;
  if ($2[0] !== t1) {
    t2 = cls$3("flex flex-row items-center text-base min-h-[48px]", t1);
    $2[0] = t1;
    $2[1] = t2;
  } else {
    t2 = $2[1];
  }
  let t3;
  if ($2[2] !== propertyConfig) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mr-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyConfigBadge2, { propertyConfig }) });
    $2[2] = propertyConfig;
    $2[3] = t3;
  } else {
    t3 = $2[3];
  }
  let t4;
  if ($2[4] !== propertyConfig.name) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: propertyConfig.name });
    $2[4] = propertyConfig.name;
    $2[5] = t4;
  } else {
    t4 = $2[5];
  }
  const t5 = existing && optionDisabled ? "You can only switch to widgets that use the same data type" : propertyConfig.description;
  let t6;
  if ($2[6] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "caption", color: "disabled", className: "max-w-sm", children: t5 });
    $2[6] = t5;
    $2[7] = t6;
  } else {
    t6 = $2[7];
  }
  let t7;
  if ($2[8] !== t4 || $2[9] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      t4,
      t6
    ] });
    $2[8] = t4;
    $2[9] = t6;
    $2[10] = t7;
  } else {
    t7 = $2[10];
  }
  let t8;
  if ($2[11] !== t2 || $2[12] !== t3 || $2[13] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t2, children: [
      t3,
      t7
    ] });
    $2[11] = t2;
    $2[12] = t3;
    $2[13] = t7;
    $2[14] = t8;
  } else {
    t8 = $2[14];
  }
  let t9;
  if ($2[15] !== optionDisabled || $2[16] !== t8 || $2[17] !== value) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem$1, { value, disabled: optionDisabled, className: "flex flex-row items-center", children: t8 });
    $2[15] = optionDisabled;
    $2[16] = t8;
    $2[17] = value;
    $2[18] = t9;
  } else {
    t9 = $2[18];
  }
  return t9;
}
function CollectionEditorImportDataPreview(t0) {
  const $2 = c_1(18);
  const {
    importConfig,
    properties,
    propertiesOrder
  } = t0;
  const [loading, setLoading] = useState$3(false);
  let t1;
  if ($2[0] !== importConfig || $2[1] !== properties) {
    t1 = async function loadEntities2() {
      const mappedData = importConfig.importData.map((d) => convertDataToEntity(d, importConfig.idColumn, importConfig.headersMapping, properties, "TEMP_PATH", importConfig.defaultValues));
      importConfig.setEntities(mappedData);
    };
    $2[0] = importConfig;
    $2[1] = properties;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  const loadEntities = t1;
  let t2;
  if ($2[3] !== loadEntities) {
    t2 = () => {
      loadEntities().finally(() => setLoading(false));
    };
    $2[3] = loadEntities;
    $2[4] = t2;
  } else {
    t2 = $2[4];
  }
  let t3;
  if ($2[5] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = [];
    $2[5] = t3;
  } else {
    t3 = $2[5];
  }
  useEffect$4(t2, t3);
  const selectionController = useSelectionController$1();
  if (loading) {
    let t42;
    if ($2[6] === Symbol.for("react.memo_cache_sentinel")) {
      t42 = /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCenter$2, {});
      $2[6] = t42;
    } else {
      t42 = $2[6];
    }
    return t42;
  }
  let t4;
  if ($2[7] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "subtitle2", children: "Imported data preview" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "caption", children: "Entities with the same id will be overwritten" })
    ] });
    $2[7] = t4;
  } else {
    t4 = $2[7];
  }
  let t5;
  if ($2[8] !== importConfig.entities) {
    t5 = {
      data: importConfig.entities,
      dataLoading: false,
      noMoreToLoad: false
    };
    $2[8] = importConfig.entities;
    $2[9] = t5;
  } else {
    t5 = $2[9];
  }
  let t6;
  if ($2[10] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-12" });
    $2[10] = t6;
  } else {
    t6 = $2[10];
  }
  let t7;
  if ($2[11] !== propertiesOrder) {
    t7 = propertiesOrder.map(_temp$1$1);
    $2[11] = propertiesOrder;
    $2[12] = t7;
  } else {
    t7 = $2[12];
  }
  let t8;
  if ($2[13] !== properties || $2[14] !== selectionController || $2[15] !== t5 || $2[16] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(EntityCollectionTable$1, { title: t4, tableController: t5, endAdornment: t6, filterable: false, sortable: false, selectionController, displayedColumnIds: t7, properties, enablePopupIcon: false });
    $2[13] = properties;
    $2[14] = selectionController;
    $2[15] = t5;
    $2[16] = t7;
    $2[17] = t8;
  } else {
    t8 = $2[17];
  }
  return t8;
}
function _temp$1$1(p) {
  return {
    key: p,
    disabled: false
  };
}
function cleanPropertiesFromImport(properties, parentSlug = "") {
  const result = Object.keys(properties).reduce((acc, key2) => {
    const property = properties[key2];
    const slug = slugify2(key2);
    const fullSlug = parentSlug ? `${parentSlug}.${slug}` : slug;
    if (property.dataType === "map" && property.properties) {
      const slugifiedResult = cleanPropertiesFromImport(property.properties, fullSlug);
      return {
        headersMapping: {
          ...acc.headersMapping,
          [key2]: fullSlug
        },
        properties: {
          ...acc.properties,
          [slug]: {
            ...property,
            properties: slugifiedResult.properties,
            propertiesOrder: Object.keys(slugifiedResult.properties)
          }
        }
      };
    }
    const updatedProperties = {
      ...acc.properties,
      [slug]: property
    };
    const headersMapping = {
      ...acc.headersMapping,
      [key2]: fullSlug
    };
    return {
      headersMapping,
      properties: updatedProperties
    };
  }, {
    headersMapping: {},
    properties: {}
  });
  const firstKey = Object.keys(result.headersMapping)?.[0];
  let idColumn;
  if (firstKey?.includes("id") || firstKey?.includes("key")) {
    idColumn = firstKey;
  }
  return {
    ...result,
    idColumn
  };
}
function CollectionEditorDialog(props) {
  const $2 = c_1(24);
  const open = props.open;
  const [formDirty, setFormDirty] = React$4.useState(false);
  const [unsavedChangesDialogOpen, setUnsavedChangesDialogOpen] = React$4.useState(false);
  let t0;
  if ($2[0] !== formDirty || $2[1] !== props) {
    t0 = () => {
      if (!formDirty) {
        props.handleClose(void 0);
      } else {
        setUnsavedChangesDialogOpen(true);
      }
    };
    $2[0] = formDirty;
    $2[1] = props;
    $2[2] = t0;
  } else {
    t0 = $2[2];
  }
  const handleCancel = t0;
  let t1;
  let t2;
  if ($2[3] !== open) {
    t1 = () => {
      if (!open) {
        setFormDirty(false);
        setUnsavedChangesDialogOpen(false);
      }
    };
    t2 = [open];
    $2[3] = open;
    $2[4] = t1;
    $2[5] = t2;
  } else {
    t1 = $2[4];
    t2 = $2[5];
  }
  useEffect$4(t1, t2);
  let t3;
  if ($2[6] !== handleCancel) {
    t3 = (open_0) => !open_0 ? handleCancel() : void 0;
    $2[6] = handleCancel;
    $2[7] = t3;
  } else {
    t3 = $2[7];
  }
  let t4;
  if ($2[8] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle$2, { hidden: true, children: "Collection editor" });
    $2[8] = t4;
  } else {
    t4 = $2[8];
  }
  let t5;
  if ($2[9] !== handleCancel || $2[10] !== open || $2[11] !== props) {
    t5 = open && /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionEditor, { ...props, handleCancel, setFormDirty });
    $2[9] = handleCancel;
    $2[10] = open;
    $2[11] = props;
    $2[12] = t5;
  } else {
    t5 = $2[12];
  }
  let t6;
  if ($2[13] !== props) {
    t6 = () => props.handleClose(void 0);
    $2[13] = props;
    $2[14] = t6;
  } else {
    t6 = $2[14];
  }
  let t7;
  if ($2[15] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = () => setUnsavedChangesDialogOpen(false);
    $2[15] = t7;
  } else {
    t7 = $2[15];
  }
  let t8;
  if ($2[16] !== t6 || $2[17] !== unsavedChangesDialogOpen) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(UnsavedChangesDialog, { open: unsavedChangesDialogOpen, handleOk: t6, handleCancel: t7, body: "There are unsaved changes in this collection" });
    $2[16] = t6;
    $2[17] = unsavedChangesDialogOpen;
    $2[18] = t8;
  } else {
    t8 = $2[18];
  }
  let t9;
  if ($2[19] !== open || $2[20] !== t3 || $2[21] !== t5 || $2[22] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog$2, { open, fullWidth: true, fullHeight: true, scrollable: false, maxWidth: "7xl", onOpenChange: t3, children: [
      t4,
      t5,
      t8
    ] });
    $2[19] = open;
    $2[20] = t3;
    $2[21] = t5;
    $2[22] = t8;
    $2[23] = t9;
  } else {
    t9 = $2[23];
  }
  return t9;
}
function CollectionEditor(props) {
  const {
    propertyConfigs
  } = useCustomizationController$3();
  const navigation = useNavigationController$3();
  const authController = useAuthController$2();
  const {
    topLevelNavigation,
    collections
  } = navigation;
  const initialValuesProp = props.initialValues;
  const includeTemplates = !initialValuesProp?.path && (props.parentCollectionIds ?? []).length === 0;
  const collectionsInThisLevel = (props.parentCollection ? props.parentCollection.subcollections : collections) ?? [];
  const existingPaths = collectionsInThisLevel.map((col) => col.path.trim().toLowerCase());
  const existingIds = collectionsInThisLevel.map((col_0) => col_0.id?.trim().toLowerCase()).filter(Boolean);
  const [collection2, setCollection] = React$4.useState();
  const [initialLoadingCompleted, setInitialLoadingCompleted] = React$4.useState(false);
  useEffect$4(() => {
    try {
      if (navigation.initialised) {
        if (props.editedCollectionId) {
          setCollection(navigation.getCollectionFromPaths([...props.parentCollectionIds ?? [], props.editedCollectionId]));
        } else {
          setCollection(void 0);
        }
        setInitialLoadingCompleted(true);
      }
    } catch (e) {
      console.error(e);
    }
  }, [props.editedCollectionId, props.parentCollectionIds, navigation.initialised, navigation.getCollectionFromPaths]);
  if (!topLevelNavigation) {
    throw Error("Internal: Navigation not ready in collection editor");
  }
  const {
    groups
  } = topLevelNavigation;
  const initialCollection = collection2 ? {
    ...collection2,
    id: collection2.id ?? collection2.path ?? randomString$1(16)
  } : void 0;
  const initialValues = initialCollection ? applyPropertyConfigs(initialCollection, propertyConfigs) : {
    id: initialValuesProp?.path ?? randomString$1(16),
    path: initialValuesProp?.path ?? "",
    name: initialValuesProp?.name ?? "",
    group: initialValuesProp?.group ?? "",
    properties: {},
    propertiesOrder: [],
    icon: coolIconKeys2[Math.floor(Math.random() * coolIconKeys2.length)],
    ownerId: authController.user?.uid ?? ""
  };
  if (!initialLoadingCompleted) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCenter$2, {});
  }
  if (!props.isNewCollection && (!navigation.initialised || !initialLoadingCompleted)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCenter$2, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionEditorInternal, { ...props, initialValues, existingPaths, existingIds, includeTemplates, collection: collection2, setCollection, groups, propertyConfigs });
}
function CollectionEditorInternal({
  isNewCollection,
  configController,
  editedCollectionId,
  parentCollectionIds,
  fullPath,
  collectionInference,
  handleClose,
  reservedGroups,
  extraView,
  handleCancel,
  setFormDirty,
  pathSuggestions,
  getUser,
  parentCollection,
  getData,
  existingPaths,
  existingIds,
  includeTemplates,
  collection: collection2,
  setCollection,
  initialValues,
  propertyConfigs,
  groups,
  existingEntities
}) {
  const importConfig = useImportConfig();
  const navigation = useNavigationController$3();
  const snackbarController = useSnackbarController$2();
  const propertyErrorsRef = useRef$3({});
  const initialView = isNewCollection ? includeTemplates ? "welcome" : "details" : "properties";
  const [currentView, setCurrentView] = useState$3(initialView);
  const [error, setError] = React$4.useState();
  const saveCollection = (updatedCollection) => {
    const id = updatedCollection.id || updatedCollection.path;
    return configController.saveCollection({
      id,
      collectionData: updatedCollection,
      previousId: editedCollectionId,
      parentCollectionIds
    }).then(() => {
      setError(void 0);
      return true;
    }).catch((e) => {
      setError(e);
      console.error(e);
      snackbarController.open({
        type: "error",
        message: "Error persisting collection: " + (e.message ?? "Details in the console")
      });
      return false;
    });
  };
  const setNextMode = () => {
    if (currentView === "details") {
      if (importConfig.inUse) {
        setCurrentView("import_data_saving");
      } else if (extraView) {
        setCurrentView("extra_view");
      } else {
        setCurrentView("properties");
      }
    } else if (currentView === "welcome") {
      setCurrentView("details");
    } else if (currentView === "import_data_mapping") {
      setCurrentView("import_data_preview");
    } else if (currentView === "import_data_preview") {
      setCurrentView("details");
    } else if (currentView === "extra_view") {
      setCurrentView("properties");
    } else {
      setCurrentView("details");
    }
  };
  const doCollectionInference = (collection_0) => {
    if (!collectionInference) return void 0;
    return collectionInference?.(collection_0.path, collection_0.collectionGroup ?? false, parentPaths ?? []);
  };
  const inferCollectionFromData = async (newCollection) => {
    try {
      if (!doCollectionInference) {
        setCollection(newCollection);
        return Promise.resolve(newCollection);
      }
      setCurrentView("loading");
      const inferredCollection = await doCollectionInference?.(newCollection);
      if (!inferredCollection) {
        setCollection(newCollection);
        return Promise.resolve(newCollection);
      }
      const values = {
        ...newCollection ?? {}
      };
      if (Object.keys(inferredCollection.properties ?? {}).length > 0) {
        values.properties = inferredCollection.properties;
        values.propertiesOrder = inferredCollection.propertiesOrder;
      }
      if (!values.propertiesOrder) {
        values.propertiesOrder = Object.keys(values.properties);
        return values;
      }
      setCollection(values);
      console.debug("Inferred collection", {
        newCollection: newCollection ?? {},
        values
      });
      return values;
    } catch (e_0) {
      console.error(e_0);
      snackbarController.open({
        type: "error",
        message: "Error inferring collection: " + (e_0.message ?? "Details in the console")
      });
      return newCollection;
    }
  };
  const onSubmit = (newCollectionState, formexController) => {
    console.debug("Submitting collection", newCollectionState);
    try {
      if (!isNewCollection) {
        saveCollection(newCollectionState).then(() => {
          formexController.resetForm();
          handleClose(newCollectionState);
        });
        return;
      }
      if (currentView === "welcome") {
        setNextMode();
        formexController.resetForm({
          values: newCollectionState
        });
      } else if (currentView === "details") {
        if (extraView || importConfig.inUse) {
          formexController.resetForm({
            values: newCollectionState
          });
          setNextMode();
        } else if (isNewCollection) {
          inferCollectionFromData(newCollectionState).then((values_0) => {
            formexController.resetForm({
              values: values_0 ?? newCollectionState,
              touched: {
                path: true,
                name: true
              }
            });
          }).finally(() => {
            setNextMode();
          });
        } else {
          formexController.resetForm({
            values: newCollectionState
          });
          setNextMode();
        }
      } else if (currentView === "extra_view") {
        setNextMode();
        formexController.resetForm({
          values: newCollectionState
        });
      } else if (currentView === "import_data_mapping") {
        setNextMode();
      } else if (currentView === "import_data_preview") {
        setNextMode();
      } else if (currentView === "properties") {
        saveCollection(newCollectionState).then(() => {
          formexController.resetForm({
            values: initialValues
          });
          setNextMode();
          handleClose(newCollectionState);
        });
      } else {
        setNextMode();
        formexController.resetForm({
          values: newCollectionState
        });
      }
    } catch (e_1) {
      snackbarController.open({
        type: "error",
        message: "Error persisting collection: " + (e_1.message ?? "Details in the console")
      });
      console.error(e_1);
      formexController.resetForm({
        values: newCollectionState
      });
    }
  };
  const validation = (col) => {
    let errors = {};
    const schema = (currentView === "properties" || currentView === "subcollections" || currentView === "details") && YupSchema;
    if (schema) {
      try {
        schema.validateSync(col, {
          abortEarly: false
        });
      } catch (e_2) {
        e_2.inner.forEach((err) => {
          errors[err.path] = err.message;
        });
      }
    }
    if (currentView === "properties") {
      errors = {
        ...errors,
        ...propertyErrorsRef.current
      };
    }
    if (currentView === "details") {
      const pathError = validatePath(col.path, isNewCollection, existingPaths, col.id);
      if (pathError) {
        errors.path = pathError;
      }
      const idError = validateId(col.id, isNewCollection, existingPaths, existingIds);
      if (idError) {
        errors.id = idError;
      }
    }
    return errors;
  };
  const formController = useCreateFormex({
    initialValues,
    onSubmit,
    validation,
    debugId: "COLLECTION_EDITOR"
  });
  const {
    values: values_1,
    setFieldValue,
    isSubmitting,
    dirty,
    submitCount
  } = formController;
  const path = values_1.path;
  const updatedFullPath = fullPath?.includes("/") ? fullPath?.split("/").slice(0, -1).join("/") + "/" + path : path;
  const pathError_0 = validatePath(path, isNewCollection, existingPaths, values_1.id);
  const parentPaths = !pathError_0 && parentCollectionIds ? navigation.convertIdsToPaths(parentCollectionIds) : void 0;
  const resolvedPath = !pathError_0 ? navigation.resolveAliasesFrom(updatedFullPath) : void 0;
  const getDataWithPath = resolvedPath && getData ? async () => {
    const data = await getData(resolvedPath, parentPaths ?? []);
    if (existingEntities) {
      const existingData = existingEntities.map((e_3) => e_3.values);
      data.push(...existingData);
    }
    return data;
  } : void 0;
  useEffect$4(() => {
    setFormDirty(dirty);
  }, [dirty]);
  function onImportDataSet(data_0, propertiesOrder) {
    importConfig.setInUse(true);
    buildEntityPropertiesFromData(data_0, getInferenceType).then((properties) => {
      const res = cleanPropertiesFromImport(properties);
      importConfig.setIdColumn(res.idColumn);
      importConfig.setImportData(data_0);
      importConfig.setHeadersMapping(res.headersMapping);
      const filteredHeadingsOrder = (propertiesOrder ?? []).filter((key2) => res.headersMapping[key2]) ?? Object.keys(res.properties);
      importConfig.setHeadingsOrder(filteredHeadingsOrder);
      importConfig.setOriginProperties(res.properties);
      const mappedHeadings = (propertiesOrder ?? []).map((key_0) => res.headersMapping[key_0]).filter(Boolean) ?? Object.keys(res.properties);
      setFieldValue("properties", res.properties);
      setFieldValue("propertiesOrder", mappedHeadings);
    });
  }
  const validValues = Boolean(values_1.name) && Boolean(values_1.id);
  const onImportMappingComplete = () => {
    const updatedProperties = {
      ...values_1.properties
    };
    if (importConfig.idColumn) delete updatedProperties[importConfig.idColumn];
    setFieldValue("properties", updatedProperties);
    setNextMode();
  };
  const editable = collection2?.editable === void 0 || collection2?.editable === true;
  const collectionEditable = editable || isNewCollection;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent$2, { fullHeight: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Formex, { value: formController, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    !isNewCollection && /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs2, { value: currentView, innerClassName: cls$3(defaultBorderMixin$1, "justify-end bg-surface-50 dark:bg-surface-950 border-b"), onValueChange: (v2) => setCurrentView(v2), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Tab2, { value: "details", children: "Details" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Tab2, { value: "properties", children: "Properties" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Tab2, { value: "subcollections", children: "Additional views" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { noValidate: true, onSubmit: formController.handleSubmit, className: cls$3(isNewCollection ? "h-full" : "h-[calc(100%-48px)]", "flex-grow flex flex-col relative"), children: [
      currentView === "loading" && /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCenter$2, {}),
      currentView === "extra_view" && path && extraView?.View && /* @__PURE__ */ jsxRuntimeExports.jsx(extraView.View, { path }),
      currentView === "welcome" && /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionEditorWelcomeView, { path, onContinue: (importData, propertiesOrder_0) => {
        if (importData) {
          onImportDataSet(importData, propertiesOrder_0);
          setCurrentView("import_data_mapping");
        } else {
          setCurrentView("details");
        }
      }, existingCollectionPaths: existingPaths, parentCollection, pathSuggestions }),
      currentView === "import_data_mapping" && importConfig && /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionEditorImportMapping, { importConfig, collectionEditable, propertyConfigs }),
      currentView === "import_data_preview" && importConfig && /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionEditorImportDataPreview, { importConfig, properties: values_1.properties, propertiesOrder: values_1.propertiesOrder }),
      currentView === "import_data_saving" && importConfig && /* @__PURE__ */ jsxRuntimeExports.jsx(ImportSaveInProgress, { importConfig, collection: values_1, path, onImportSuccess: async (importedCollection) => {
        snackbarController.open({
          type: "info",
          message: "Data imported successfully"
        });
        await saveCollection(values_1);
        handleClose(importedCollection);
      } }),
      currentView === "details" && /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionDetailsForm, { existingPaths, existingIds, groups, parentCollectionIds, parentCollection, isNewCollection }),
      currentView === "subcollections" && collection2 && /* @__PURE__ */ jsxRuntimeExports.jsx(SubcollectionsEditTab, { parentCollection, configController, getUser, collectionInference, parentCollectionIds, collection: collection2 }),
      currentView === "properties" && /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionPropertiesEditorForm, { showErrors: submitCount > 0, isNewCollection, reservedGroups, onPropertyError: (propertyKey, namespace, error_0) => {
        const current = removeUndefined$1({
          ...propertyErrorsRef.current,
          [getFullIdPath(propertyKey, namespace)]: removeUndefined$1(error_0, true)
        }, true);
        propertyErrorsRef.current = current;
        formController.validate();
      }, getUser, getData: getDataWithPath, doCollectionInference, propertyConfigs, collectionEditable, extraIcon: extraView?.icon && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$3, { color: "primary", onClick: () => setCurrentView("extra_view"), children: extraView.icon }) }),
      currentView !== "welcome" && /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions$1, { position: "absolute", children: [
        error && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView$1, { error }),
        isNewCollection && includeTemplates && currentView === "import_data_mapping" && /* @__PURE__ */ jsxRuntimeExports.jsxs(Button$3, { variant: "text", type: "button", onClick: () => {
          importConfig.setInUse(false);
          return setCurrentView("welcome");
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBackIcon2, {}),
          "Back"
        ] }),
        isNewCollection && includeTemplates && currentView === "import_data_preview" && /* @__PURE__ */ jsxRuntimeExports.jsxs(Button$3, { variant: "text", type: "button", onClick: () => {
          setCurrentView("import_data_mapping");
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBackIcon2, {}),
          "Back"
        ] }),
        isNewCollection && includeTemplates && currentView === "details" && /* @__PURE__ */ jsxRuntimeExports.jsxs(Button$3, { variant: "text", type: "button", onClick: () => setCurrentView("welcome"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBackIcon2, {}),
          "Back"
        ] }),
        isNewCollection && currentView === "properties" && /* @__PURE__ */ jsxRuntimeExports.jsxs(Button$3, { variant: "text", type: "button", onClick: () => setCurrentView("details"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBackIcon2, {}),
          "Back"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { variant: "text", onClick: () => {
          handleCancel();
        }, children: "Cancel" }),
        isNewCollection && currentView === "import_data_mapping" && /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { variant: "filled", color: "primary", onClick: onImportMappingComplete, children: "Next" }),
        isNewCollection && currentView === "import_data_preview" && /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { variant: "filled", color: "primary", onClick: () => {
          setNextMode();
        }, children: "Next" }),
        isNewCollection && (currentView === "details" || currentView === "properties") && /* @__PURE__ */ jsxRuntimeExports.jsxs(LoadingButton$1, { variant: "filled", color: "primary", type: "submit", loading: isSubmitting, disabled: isSubmitting || currentView === "details" && !validValues, startIcon: currentView === "properties" ? /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon$1, {}) : void 0, children: [
          currentView === "details" && "Next",
          currentView === "properties" && "Create collection"
        ] }),
        !isNewCollection && /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingButton$1, { variant: "filled", color: "primary", type: "submit", loading: isSubmitting, children: "Update collection" })
      ] })
    ] })
  ] }) }) });
}
function applyPropertyConfigs(collection2, propertyConfigs) {
  const {
    properties,
    ...rest
  } = collection2;
  const propertiesResult = {};
  if (properties) {
    Object.keys(properties).forEach((key2) => {
      propertiesResult[key2] = applyPropertiesConfig(properties[key2], propertyConfigs);
    });
  }
  return {
    ...rest,
    properties: propertiesResult
  };
}
function applyPropertiesConfig(property, propertyConfigs) {
  let internalProperty = property;
  if (propertyConfigs && typeof internalProperty === "object" && internalProperty.propertyConfig) {
    const propertyConfig = propertyConfigs[internalProperty.propertyConfig];
    if (propertyConfig && isPropertyBuilder$1(propertyConfig.property)) {
      internalProperty = propertyConfig.property;
    } else {
      if (propertyConfig) {
        internalProperty = mergeDeep2(propertyConfig.property, internalProperty);
      }
      if (!isPropertyBuilder$1(internalProperty) && internalProperty.dataType === "map" && internalProperty.properties) {
        const properties = {};
        Object.keys(internalProperty.properties).forEach((key2) => {
          properties[key2] = applyPropertiesConfig(internalProperty.properties[key2], propertyConfigs);
        });
        internalProperty = {
          ...internalProperty,
          properties
        };
      }
    }
  }
  return internalProperty;
}
const validatePath = (value, isNewCollection, existingPaths, idValue) => {
  let error;
  if (!value) {
    error = "You must specify a path in the database for this collection";
  }
  if (isNewCollection && existingPaths?.includes(value.trim().toLowerCase()) && !idValue) error = "There is already a collection with the specified path. If you want to have multiple collections referring to the same database path, make sure the have different ids";
  const subpaths = removeInitialAndTrailingSlashes$1(value).split("/");
  if (subpaths.length % 2 === 0) {
    error = `Collection paths must have an odd number of segments: ${value}`;
  }
  return error;
};
const validateId = (value, isNewCollection, existingPaths, existingIds) => {
  if (!value) return void 0;
  let error;
  if (isNewCollection && existingPaths?.includes(value.trim().toLowerCase())) error = "There is already a collection that uses this value as a path";
  if (isNewCollection && existingIds?.includes(value.trim().toLowerCase())) error = "There is already a collection which uses this id";
  return error;
};
const ConfigControllerContext = React__default.createContext({});
const CollectionEditorContext = React__default.createContext({});
const ConfigControllerProvider = React__default.memo(function ConfigControllerProvider2(t0) {
  const $2 = c_1(68);
  const {
    children,
    collectionConfigController,
    configPermissions,
    reservedGroups,
    collectionInference,
    extraView,
    getPathSuggestions,
    getUser,
    getData,
    onAnalyticsEvent,
    components
  } = t0;
  const navigation = useNavigationController$3();
  const navigate = useNavigate();
  const snackbarController = useSnackbarController$2();
  const {
    propertyConfigs
  } = useCustomizationController$3();
  const [currentDialog, setCurrentDialog] = React__default.useState();
  const [currentPropertyDialog, setCurrentPropertyDialog] = React__default.useState();
  const defaultConfigPermissions = _temp$c;
  let t1;
  if ($2[0] !== onAnalyticsEvent) {
    t1 = (t26) => {
      const {
        id,
        fullPath,
        parentCollectionIds,
        parentCollection,
        existingEntities
      } = t26;
      console.debug("Edit collection", id, fullPath, parentCollectionIds, parentCollection);
      onAnalyticsEvent?.("edit_collection", {
        id,
        fullPath
      });
      setCurrentDialog({
        editedCollectionId: id,
        fullPath,
        parentCollectionIds,
        isNewCollection: false,
        parentCollection,
        redirect: false,
        existingEntities
      });
    };
    $2[0] = onAnalyticsEvent;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  const editCollection = t1;
  let t2;
  if ($2[2] !== onAnalyticsEvent) {
    t2 = (t32) => {
      const {
        propertyKey,
        property,
        editedCollectionId,
        currentPropertiesOrder,
        parentCollectionIds: parentCollectionIds_0,
        collection: collection2,
        existingEntities: existingEntities_0
      } = t32;
      console.debug("Edit property", propertyKey, property, editedCollectionId, currentPropertiesOrder, parentCollectionIds_0, collection2);
      onAnalyticsEvent?.("edit_property", {
        propertyKey,
        editedCollectionId
      });
      const namespace = propertyKey && propertyKey.includes(".") ? propertyKey.substring(0, propertyKey.lastIndexOf(".")) : void 0;
      const propertyKeyWithoutNamespace = propertyKey && propertyKey.includes(".") ? propertyKey.substring(propertyKey.lastIndexOf(".") + 1) : propertyKey;
      setCurrentPropertyDialog({
        propertyKey: propertyKeyWithoutNamespace,
        property,
        namespace,
        currentPropertiesOrder,
        editedCollectionId,
        parentCollectionIds: parentCollectionIds_0,
        collectionEditable: collection2?.editable ?? false,
        existingEntities: existingEntities_0
      });
    };
    $2[2] = onAnalyticsEvent;
    $2[3] = t2;
  } else {
    t2 = $2[3];
  }
  const editProperty = t2;
  let t3;
  if ($2[4] !== onAnalyticsEvent) {
    t3 = (t42) => {
      const {
        parentCollectionIds: parentCollectionIds_1,
        parentCollection: parentCollection_0,
        initialValues,
        redirect,
        sourceClick
      } = t42;
      console.debug("Create collection", {
        parentCollectionIds: parentCollectionIds_1,
        parentCollection: parentCollection_0,
        initialValues,
        redirect,
        sourceClick
      });
      onAnalyticsEvent?.("create_collection", {
        parentCollectionIds: parentCollectionIds_1,
        parentCollection: parentCollection_0,
        initialValues,
        redirect,
        sourceClick
      });
      setCurrentDialog({
        isNewCollection: true,
        parentCollectionIds: parentCollectionIds_1,
        parentCollection: parentCollection_0,
        initialValues,
        redirect
      });
    };
    $2[4] = onAnalyticsEvent;
    $2[5] = t3;
  } else {
    t3 = $2[5];
  }
  const createCollection = t3;
  const t4 = configPermissions ?? defaultConfigPermissions;
  let t5;
  if ($2[6] !== components || $2[7] !== createCollection || $2[8] !== editCollection || $2[9] !== editProperty || $2[10] !== getPathSuggestions || $2[11] !== t4) {
    t5 = {
      editCollection,
      createCollection,
      editProperty,
      configPermissions: t4,
      getPathSuggestions,
      components
    };
    $2[6] = components;
    $2[7] = createCollection;
    $2[8] = editCollection;
    $2[9] = editProperty;
    $2[10] = getPathSuggestions;
    $2[11] = t4;
    $2[12] = t5;
  } else {
    t5 = $2[12];
  }
  const t6 = Boolean(currentDialog);
  let t7;
  if ($2[13] !== currentDialog || $2[14] !== navigate || $2[15] !== navigation) {
    t7 = (collection_0) => {
      if (currentDialog?.redirect) {
        if (collection_0 && currentDialog?.isNewCollection && !currentDialog.parentCollectionIds.length) {
          const url = navigation.buildUrlCollectionPath(collection_0.id ?? collection_0.path);
          navigate(url);
        }
      }
      setCurrentDialog(void 0);
    };
    $2[13] = currentDialog;
    $2[14] = navigate;
    $2[15] = navigation;
    $2[16] = t7;
  } else {
    t7 = $2[16];
  }
  let t8;
  if ($2[17] !== collectionConfigController || $2[18] !== collectionInference || $2[19] !== currentDialog || $2[20] !== extraView || $2[21] !== getData || $2[22] !== getPathSuggestions || $2[23] !== getUser || $2[24] !== reservedGroups || $2[25] !== t6 || $2[26] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionEditorDialog, { open: t6, configController: collectionConfigController, isNewCollection: false, collectionInference, ...currentDialog, getData, reservedGroups, extraView, pathSuggestions: getPathSuggestions, getUser, handleClose: t7 });
    $2[17] = collectionConfigController;
    $2[18] = collectionInference;
    $2[19] = currentDialog;
    $2[20] = extraView;
    $2[21] = getData;
    $2[22] = getPathSuggestions;
    $2[23] = getUser;
    $2[24] = reservedGroups;
    $2[25] = t6;
    $2[26] = t7;
    $2[27] = t8;
  } else {
    t8 = $2[27];
  }
  const t9 = Boolean(currentPropertyDialog);
  const t10 = Boolean(currentPropertyDialog?.propertyKey);
  const t11 = !currentPropertyDialog ? false : !currentPropertyDialog?.propertyKey;
  const t12 = !currentPropertyDialog ? false : !currentPropertyDialog?.propertyKey;
  const t13 = currentPropertyDialog?.collectionEditable ?? false;
  let t14;
  if ($2[28] !== currentPropertyDialog || $2[29] !== getData || $2[30] !== navigation) {
    t14 = getData && currentPropertyDialog?.editedCollectionId ? () => {
      console.debug("get data for property", currentPropertyDialog?.editedCollectionId);
      const resolvedPath = navigation.resolveAliasesFrom(currentPropertyDialog.editedCollectionId);
      return getData(resolvedPath, []);
    } : void 0;
    $2[28] = currentPropertyDialog;
    $2[29] = getData;
    $2[30] = navigation;
    $2[31] = t14;
  } else {
    t14 = $2[31];
  }
  let t15;
  if ($2[32] !== collectionConfigController || $2[33] !== currentPropertyDialog || $2[34] !== snackbarController) {
    t15 = (t162) => {
      const {
        id: id_0,
        property: property_0
      } = t162;
      if (!currentPropertyDialog) {
        return;
      }
      if (!id_0) {
        return;
      }
      const newProperty = !currentPropertyDialog.propertyKey;
      return collectionConfigController.saveProperty({
        path: currentPropertyDialog?.editedCollectionId,
        property: property_0,
        propertyKey: id_0,
        newPropertiesOrder: newProperty && currentPropertyDialog.currentPropertiesOrder ? [...currentPropertyDialog.currentPropertiesOrder, id_0] : void 0,
        namespace: currentPropertyDialog.namespace,
        parentCollectionIds: currentPropertyDialog.parentCollectionIds
      }).catch((e) => {
        console.error(e);
        snackbarController.open({
          type: "error",
          message: "Error persisting property: " + (e.message ?? "Details in the console")
        });
        return false;
      });
    };
    $2[32] = collectionConfigController;
    $2[33] = currentPropertyDialog;
    $2[34] = snackbarController;
    $2[35] = t15;
  } else {
    t15 = $2[35];
  }
  let t16;
  if ($2[36] !== collectionConfigController || $2[37] !== currentPropertyDialog?.currentPropertiesOrder || $2[38] !== currentPropertyDialog?.editedCollectionId || $2[39] !== currentPropertyDialog?.namespace || $2[40] !== currentPropertyDialog?.parentCollectionIds || $2[41] !== currentPropertyDialog?.propertyKey || $2[42] !== snackbarController) {
    t16 = () => {
      if (!currentPropertyDialog?.propertyKey) {
        return;
      }
      const newPropertiesOrder = currentPropertyDialog?.currentPropertiesOrder?.filter((p) => p !== currentPropertyDialog?.propertyKey);
      return collectionConfigController.deleteProperty({
        path: currentPropertyDialog?.editedCollectionId,
        propertyKey: currentPropertyDialog?.propertyKey,
        namespace: currentPropertyDialog?.namespace,
        newPropertiesOrder,
        parentCollectionIds: currentPropertyDialog?.parentCollectionIds
      }).then(() => {
        setCurrentPropertyDialog(void 0);
      }).catch((e_0) => {
        console.error(e_0);
        snackbarController.open({
          type: "error",
          message: "Error deleting property: " + (e_0.message ?? "Details in the console")
        });
        return false;
      });
    };
    $2[36] = collectionConfigController;
    $2[37] = currentPropertyDialog?.currentPropertiesOrder;
    $2[38] = currentPropertyDialog?.editedCollectionId;
    $2[39] = currentPropertyDialog?.namespace;
    $2[40] = currentPropertyDialog?.parentCollectionIds;
    $2[41] = currentPropertyDialog?.propertyKey;
    $2[42] = snackbarController;
    $2[43] = t16;
  } else {
    t16 = $2[43];
  }
  let t17;
  let t18;
  let t19;
  if ($2[44] === Symbol.for("react.memo_cache_sentinel")) {
    t17 = () => {
      setCurrentPropertyDialog(void 0);
    };
    t18 = () => {
      setCurrentPropertyDialog(void 0);
    };
    t19 = {};
    $2[44] = t17;
    $2[45] = t18;
    $2[46] = t19;
  } else {
    t17 = $2[44];
    t18 = $2[45];
    t19 = $2[46];
  }
  let t20;
  if ($2[47] === Symbol.for("react.memo_cache_sentinel")) {
    t20 = [];
    $2[47] = t20;
  } else {
    t20 = $2[47];
  }
  const t21 = currentPropertyDialog?.property;
  const t22 = currentPropertyDialog?.propertyKey;
  let t23;
  if ($2[48] !== propertyConfigs || $2[49] !== t10 || $2[50] !== t11 || $2[51] !== t12 || $2[52] !== t13 || $2[53] !== t14 || $2[54] !== t15 || $2[55] !== t16 || $2[56] !== t21 || $2[57] !== t22 || $2[58] !== t9) {
    t23 = /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyFormDialog, { open: t9, includeIdAndName: true, existingProperty: t10, autoUpdateId: t11, autoOpenTypeSelect: t12, inArray: false, collectionEditable: t13, getData: t14, onPropertyChanged: t15, onPropertyChangedImmediate: false, onDelete: t16, onError: _temp2$8, onOkClicked: t17, onCancel: t18, initialErrors: t19, forceShowErrors: false, existingPropertyKeys: t20, allowDataInference: true, propertyConfigs, property: t21, propertyKey: t22 });
    $2[48] = propertyConfigs;
    $2[49] = t10;
    $2[50] = t11;
    $2[51] = t12;
    $2[52] = t13;
    $2[53] = t14;
    $2[54] = t15;
    $2[55] = t16;
    $2[56] = t21;
    $2[57] = t22;
    $2[58] = t9;
    $2[59] = t23;
  } else {
    t23 = $2[59];
  }
  let t24;
  if ($2[60] !== children || $2[61] !== t23 || $2[62] !== t5 || $2[63] !== t8) {
    t24 = /* @__PURE__ */ jsxRuntimeExports.jsxs(CollectionEditorContext.Provider, { value: t5, children: [
      children,
      t8,
      t23
    ] });
    $2[60] = children;
    $2[61] = t23;
    $2[62] = t5;
    $2[63] = t8;
    $2[64] = t24;
  } else {
    t24 = $2[64];
  }
  let t25;
  if ($2[65] !== collectionConfigController || $2[66] !== t24) {
    t25 = /* @__PURE__ */ jsxRuntimeExports.jsx(ConfigControllerContext.Provider, { value: collectionConfigController, children: t24 });
    $2[65] = collectionConfigController;
    $2[66] = t24;
    $2[67] = t25;
  } else {
    t25 = $2[67];
  }
  return t25;
}, equal);
function _temp$c() {
  return {
    createCollections: true,
    editCollections: true,
    deleteCollections: true
  };
}
function _temp2$8() {
}
function EditorCollectionAction(t0) {
  const $2 = c_1(24);
  const {
    path: fullPath,
    parentCollectionIds,
    collection: collection2,
    tableController
  } = t0;
  const authController = useAuthController$2();
  const navigationController = useNavigationController$3();
  const collectionEditorController = useCollectionEditorController();
  let t1;
  if ($2[0] !== navigationController || $2[1] !== parentCollectionIds) {
    t1 = navigationController.getCollectionFromIds(parentCollectionIds);
    $2[0] = navigationController;
    $2[1] = parentCollectionIds;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  const parentCollection = t1;
  let t2;
  if ($2[3] !== authController || $2[4] !== collection2 || $2[5] !== collectionEditorController) {
    t2 = collectionEditorController.configPermissions ? collectionEditorController.configPermissions({
      user: authController.user,
      collection: collection2
    }).editCollections : true;
    $2[3] = authController;
    $2[4] = collection2;
    $2[5] = collectionEditorController;
    $2[6] = t2;
  } else {
    t2 = $2[6];
  }
  const canEditCollection = t2;
  const t3 = canEditCollection ? "Edit collection" : "You don't have permissions to edit this collection";
  const t4 = !canEditCollection;
  let t5;
  if ($2[7] !== canEditCollection || $2[8] !== collection2 || $2[9] !== collectionEditorController || $2[10] !== fullPath || $2[11] !== parentCollection || $2[12] !== parentCollectionIds || $2[13] !== tableController?.data) {
    t5 = canEditCollection ? () => collectionEditorController?.editCollection({
      id: collection2.id,
      fullPath,
      parentCollectionIds,
      parentCollection,
      existingEntities: tableController?.data ?? []
    }) : void 0;
    $2[7] = canEditCollection;
    $2[8] = collection2;
    $2[9] = collectionEditorController;
    $2[10] = fullPath;
    $2[11] = parentCollection;
    $2[12] = parentCollectionIds;
    $2[13] = tableController?.data;
    $2[14] = t5;
  } else {
    t5 = $2[14];
  }
  let t6;
  if ($2[15] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsIcon2, {});
    $2[15] = t6;
  } else {
    t6 = $2[15];
  }
  let t7;
  if ($2[16] !== t4 || $2[17] !== t5) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$3, { color: "primary", disabled: t4, onClick: t5, children: t6 });
    $2[16] = t4;
    $2[17] = t5;
    $2[18] = t7;
  } else {
    t7 = $2[18];
  }
  let t8;
  if ($2[19] !== t3 || $2[20] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$3, { asChild: true, title: t3, children: t7 });
    $2[19] = t3;
    $2[20] = t7;
    $2[21] = t8;
  } else {
    t8 = $2[21];
  }
  const editorButton = t8;
  let t9;
  if ($2[22] !== editorButton) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: editorButton });
    $2[22] = editorButton;
    $2[23] = t9;
  } else {
    t9 = $2[23];
  }
  return t9;
}
const useCollectionsConfigController = () => {
  return useContext$3(ConfigControllerContext);
};
function HomePageEditorCollectionAction(t0) {
  const $2 = c_1(28);
  const {
    collection: collection2
  } = t0;
  const snackbarController = useSnackbarController$2();
  const authController = useAuthController$2();
  const configController = useCollectionsConfigController();
  const collectionEditorController = useCollectionEditorController();
  let t1;
  if ($2[0] !== authController.user || $2[1] !== collection2 || $2[2] !== collectionEditorController) {
    t1 = collectionEditorController.configPermissions({
      user: authController.user,
      collection: collection2
    });
    $2[0] = authController.user;
    $2[1] = collection2;
    $2[2] = collectionEditorController;
    $2[3] = t1;
  } else {
    t1 = $2[3];
  }
  const permissions = t1;
  let t2;
  if ($2[4] !== collection2 || $2[5] !== collectionEditorController) {
    t2 = () => {
      collectionEditorController?.editCollection({
        id: collection2.id,
        parentCollectionIds: []
      });
    };
    $2[4] = collection2;
    $2[5] = collectionEditorController;
    $2[6] = t2;
  } else {
    t2 = $2[6];
  }
  const onEditCollectionClicked = t2;
  const [deleteRequested, setDeleteRequested] = useState$3(false);
  let t3;
  if ($2[7] !== collection2 || $2[8] !== configController || $2[9] !== snackbarController) {
    t3 = () => {
      configController?.deleteCollection({
        id: collection2.id
      }).then(() => {
        setDeleteRequested(false);
        snackbarController.open({
          message: "Collection deleted",
          type: "success"
        });
      });
    };
    $2[7] = collection2;
    $2[8] = configController;
    $2[9] = snackbarController;
    $2[10] = t3;
  } else {
    t3 = $2[10];
  }
  const deleteCollection = t3;
  let t4;
  if ($2[11] !== permissions.deleteCollections) {
    t4 = permissions.deleteCollections && /* @__PURE__ */ jsxRuntimeExports.jsx(Menu$3, { trigger: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$3, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MoreVertIcon$1, { size: "small" }) }), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem$3, { dense: true, onClick: (event) => {
      event.preventDefault();
      event.stopPropagation();
      setDeleteRequested(true);
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteIcon2, {}),
      "Delete"
    ] }) });
    $2[11] = permissions.deleteCollections;
    $2[12] = t4;
  } else {
    t4 = $2[12];
  }
  let t5;
  if ($2[13] !== onEditCollectionClicked || $2[14] !== permissions.editCollections) {
    t5 = permissions.editCollections && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$3, { onClick: (event_0) => {
      onEditCollectionClicked();
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsIcon2, { size: "small" }) });
    $2[13] = onEditCollectionClicked;
    $2[14] = permissions.editCollections;
    $2[15] = t5;
  } else {
    t5 = $2[15];
  }
  let t6;
  if ($2[16] !== t4 || $2[17] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      t4,
      t5
    ] });
    $2[16] = t4;
    $2[17] = t5;
    $2[18] = t6;
  } else {
    t6 = $2[18];
  }
  let t7;
  let t8;
  if ($2[19] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = () => setDeleteRequested(false);
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "Delete this collection?" });
    $2[19] = t7;
    $2[20] = t8;
  } else {
    t7 = $2[19];
    t8 = $2[20];
  }
  let t9;
  if ($2[21] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      " This will ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: "not delete any data" }),
      ", only the collection in the CMS"
    ] });
    $2[21] = t9;
  } else {
    t9 = $2[21];
  }
  let t10;
  if ($2[22] !== deleteCollection || $2[23] !== deleteRequested) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(ConfirmationDialog2, { open: deleteRequested, onAccept: deleteCollection, onCancel: t7, title: t8, body: t9 });
    $2[22] = deleteCollection;
    $2[23] = deleteRequested;
    $2[24] = t10;
  } else {
    t10 = $2[24];
  }
  let t11;
  if ($2[25] !== t10 || $2[26] !== t6) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t6,
      t10
    ] });
    $2[25] = t10;
    $2[26] = t6;
    $2[27] = t11;
  } else {
    t11 = $2[27];
  }
  return t11;
}
function CollectionViewHeaderAction(t0) {
  const $2 = c_1(11);
  const {
    propertyKey,
    onHover,
    property,
    parentCollectionIds,
    collection: collection2,
    tableController
  } = t0;
  const collectionEditorController = useCollectionEditorController();
  const t1 = onHover ? "bg-white dark:bg-surface-950" : "hidden";
  let t2;
  if ($2[0] !== collection2 || $2[1] !== collectionEditorController || $2[2] !== parentCollectionIds || $2[3] !== property || $2[4] !== propertyKey || $2[5] !== tableController.data) {
    t2 = () => {
      collectionEditorController.editProperty({
        propertyKey,
        property,
        editedCollectionId: collection2.id,
        parentCollectionIds,
        collection: collection2,
        existingEntities: tableController.data ?? []
      });
    };
    $2[0] = collection2;
    $2[1] = collectionEditorController;
    $2[2] = parentCollectionIds;
    $2[3] = property;
    $2[4] = propertyKey;
    $2[5] = tableController.data;
    $2[6] = t2;
  } else {
    t2 = $2[6];
  }
  let t3;
  if ($2[7] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsIcon2, { size: "small" });
    $2[7] = t3;
  } else {
    t3 = $2[7];
  }
  let t4;
  if ($2[8] !== t1 || $2[9] !== t2) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$3, { asChild: true, title: "Edit", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$3, { className: t1, onClick: t2, size: "small", children: t3 }) });
    $2[8] = t1;
    $2[9] = t2;
    $2[10] = t4;
  } else {
    t4 = $2[10];
  }
  return t4;
}
function PropertyAddColumnComponent(t0) {
  const $2 = c_1(11);
  const {
    parentCollectionIds,
    collection: collection2,
    tableController
  } = t0;
  const authController = useAuthController$2();
  const collectionEditorController = useCollectionEditorController();
  const canEditCollection = collectionEditorController.configPermissions ? collectionEditorController.configPermissions({
    user: authController.user,
    collection: collection2
  }).editCollections : true;
  const t1 = canEditCollection ? "Add new property" : "You don't have permission to add new properties";
  let t2;
  if ($2[0] !== collection2 || $2[1] !== collectionEditorController || $2[2] !== parentCollectionIds || $2[3] !== tableController.data) {
    t2 = () => {
      collectionEditorController.editProperty({
        editedCollectionId: collection2.id,
        parentCollectionIds,
        currentPropertiesOrder: getDefaultPropertiesOrder2(collection2),
        collection: collection2,
        existingEntities: tableController.data
      });
    };
    $2[0] = collection2;
    $2[1] = collectionEditorController;
    $2[2] = parentCollectionIds;
    $2[3] = tableController.data;
    $2[4] = t2;
  } else {
    t2 = $2[4];
  }
  let t3;
  if ($2[5] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon$1, { color: "inherit" });
    $2[5] = t3;
  } else {
    t3 = $2[5];
  }
  let t4;
  if ($2[6] !== t2) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-0.5 w-20 h-full flex items-center justify-center cursor-pointer bg-surface-100 bg-opacity-40 hover:bg-surface-100 dark:bg-surface-950 dark:bg-opacity-40 dark:hover:bg-surface-950", onClick: t2, children: t3 });
    $2[6] = t2;
    $2[7] = t4;
  } else {
    t4 = $2[7];
  }
  let t5;
  if ($2[8] !== t1 || $2[9] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$3, { asChild: true, title: t1, children: t4 });
    $2[8] = t1;
    $2[9] = t4;
    $2[10] = t5;
  } else {
    t5 = $2[10];
  }
  return t5;
}
function NewCollectionButton() {
  const $2 = c_1(5);
  const collectionEditorController = useCollectionEditorController();
  let t0;
  if ($2[0] !== collectionEditorController) {
    t0 = () => collectionEditorController.createCollection({
      parentCollectionIds: [],
      redirect: true,
      sourceClick: "new_collection_button"
    });
    $2[0] = collectionEditorController;
    $2[1] = t0;
  } else {
    t0 = $2[1];
  }
  let t1;
  if ($2[2] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon$1, {});
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  let t2;
  if ($2[3] !== t0) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-surface-50 dark:bg-surface-900 min-w-fit rounded", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button$3, { className: "min-w-fit", variant: "outlined", onClick: t0, children: [
      t1,
      "New collection"
    ] }) });
    $2[3] = t0;
    $2[4] = t2;
  } else {
    t2 = $2[4];
  }
  return t2;
}
function EditorCollectionActionStart(t0) {
  const $2 = c_1(26);
  const {
    parentCollectionIds,
    collection: collection2,
    tableController
  } = t0;
  const authController = useAuthController$2();
  const collectionEditorController = useCollectionEditorController();
  const configController = useCollectionsConfigController();
  const snackbarController = useSnackbarController$2();
  let t1;
  if ($2[0] !== authController || $2[1] !== collection2 || $2[2] !== collectionEditorController) {
    t1 = collectionEditorController.configPermissions ? collectionEditorController.configPermissions({
      user: authController.user,
      collection: collection2
    }).editCollections : true;
    $2[0] = authController;
    $2[1] = collection2;
    $2[2] = collectionEditorController;
    $2[3] = t1;
  } else {
    t1 = $2[3];
  }
  const canEditCollection = t1;
  let saveDefaultFilterButton = null;
  if (!equal(getObjectOrNull(tableController.filterValues), getObjectOrNull(collection2.initialFilter)) || !equal(getObjectOrNull(tableController.sortBy), getObjectOrNull(collection2.initialSort))) {
    const t22 = tableController.sortBy || tableController.filterValues ? "Save default filter and sort" : "Clear default filter and sort";
    let t32;
    if ($2[4] !== collection2 || $2[5] !== configController || $2[6] !== parentCollectionIds || $2[7] !== snackbarController || $2[8] !== tableController.filterValues || $2[9] !== tableController.sortBy) {
      t32 = () => configController?.saveCollection({
        id: collection2.id,
        parentCollectionIds,
        collectionData: mergeDeep2(collection2, {
          initialFilter: tableController.filterValues ?? null,
          initialSort: tableController.sortBy ?? null
        })
      }).then(() => {
        snackbarController.open({
          type: "success",
          message: "Default config saved"
        });
      });
      $2[4] = collection2;
      $2[5] = configController;
      $2[6] = parentCollectionIds;
      $2[7] = snackbarController;
      $2[8] = tableController.filterValues;
      $2[9] = tableController.sortBy;
      $2[10] = t32;
    } else {
      t32 = $2[10];
    }
    let t4;
    if ($2[11] === Symbol.for("react.memo_cache_sentinel")) {
      t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(SaveIcon2, {});
      $2[11] = t4;
    } else {
      t4 = $2[11];
    }
    let t5;
    if ($2[12] !== t32) {
      t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { color: "primary", size: "small", variant: "outlined", onClick: t32, children: t4 });
      $2[12] = t32;
      $2[13] = t5;
    } else {
      t5 = $2[13];
    }
    let t6;
    if ($2[14] !== t22 || $2[15] !== t5) {
      t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$3, { asChild: true, title: t22, children: t5 });
      $2[14] = t22;
      $2[15] = t5;
      $2[16] = t6;
    } else {
      t6 = $2[16];
    }
    let t7;
    if ($2[17] !== collection2.initialFilter || $2[18] !== collection2.initialSort || $2[19] !== tableController) {
      t7 = (collection2.initialFilter || collection2.initialSort) && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$3, { title: "Reset to default filter and sort", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { color: "primary", size: "small", variant: "text", onClick: () => {
        tableController.clearFilter?.();
        if (collection2?.initialFilter) {
          tableController.setFilterValues?.(collection2?.initialFilter);
        }
        if (collection2?.initialSort) {
          tableController.setSortBy?.(collection2?.initialSort);
        }
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(UndoIcon2, {}) }) });
      $2[17] = collection2.initialFilter;
      $2[18] = collection2.initialSort;
      $2[19] = tableController;
      $2[20] = t7;
    } else {
      t7 = $2[20];
    }
    let t8;
    if ($2[21] !== t6 || $2[22] !== t7) {
      t8 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        t6,
        t7
      ] });
      $2[21] = t6;
      $2[22] = t7;
      $2[23] = t8;
    } else {
      t8 = $2[23];
    }
    saveDefaultFilterButton = t8;
  }
  const t2 = canEditCollection && saveDefaultFilterButton;
  let t3;
  if ($2[24] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: t2 });
    $2[24] = t2;
    $2[25] = t3;
  } else {
    t3 = $2[25];
  }
  return t3;
}
function getObjectOrNull(o) {
  if (o && Object.keys(o).length === 0) return o;
  return o ?? null;
}
function NewCollectionCard(t0) {
  const $2 = c_1(17);
  const {
    group,
    context
  } = t0;
  if (!context.navigation.topLevelNavigation) {
    throw Error("Navigation not ready in FireCMSHomePage");
  }
  const authController = useAuthController$2();
  const collectionEditorController = useCollectionEditorController();
  let t1;
  if ($2[0] !== authController || $2[1] !== collectionEditorController) {
    t1 = collectionEditorController.configPermissions ? collectionEditorController.configPermissions({
      user: authController.user
    }).createCollections : true;
    $2[0] = authController;
    $2[1] = collectionEditorController;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  const canCreateCollections = t1;
  let t2;
  if ($2[3] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = cls$3("h-full p-4 min-h-[124px]");
    $2[3] = t2;
  } else {
    t2 = $2[3];
  }
  let t3;
  if ($2[4] !== canCreateCollections || $2[5] !== collectionEditorController || $2[6] !== group) {
    t3 = collectionEditorController && canCreateCollections ? () => collectionEditorController.createCollection({
      initialValues: group ? {
        group
      } : void 0,
      parentCollectionIds: [],
      redirect: true,
      sourceClick: "new_collection_card"
    }) : void 0;
    $2[4] = canCreateCollections;
    $2[5] = collectionEditorController;
    $2[6] = group;
    $2[7] = t3;
  } else {
    t3 = $2[7];
  }
  let t4;
  if ($2[8] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon$1, { color: "primary", size: "large" });
    $2[8] = t4;
  } else {
    t4 = $2[8];
  }
  let t5;
  if ($2[9] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { color: "primary", variant: "caption", className: "font-medium", children: "Add new collection".toUpperCase() });
    $2[9] = t5;
  } else {
    t5 = $2[9];
  }
  let t6;
  if ($2[10] !== canCreateCollections) {
    t6 = !canCreateCollections && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "caption", children: "You don't have permissions to create collections" });
    $2[10] = canCreateCollections;
    $2[11] = t6;
  } else {
    t6 = $2[11];
  }
  let t7;
  if ($2[12] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center h-full w-full flex-grow flex-col", children: [
      t4,
      t5,
      t6
    ] });
    $2[12] = t6;
    $2[13] = t7;
  } else {
    t7 = $2[13];
  }
  let t8;
  if ($2[14] !== t3 || $2[15] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(Card$2, { className: t2, onClick: t3, children: t7 });
    $2[14] = t3;
    $2[15] = t7;
    $2[16] = t8;
  } else {
    t8 = $2[16];
  }
  return t8;
}
function useCollectionEditorPlugin(t0) {
  const $2 = c_1(16);
  const {
    collectionConfigController,
    configPermissions,
    reservedGroups,
    extraView,
    getPathSuggestions,
    getUser,
    collectionInference,
    getData,
    onAnalyticsEvent,
    components
  } = t0;
  let t1;
  if ($2[0] !== collectionConfigController || $2[1] !== collectionInference || $2[2] !== components || $2[3] !== configPermissions || $2[4] !== extraView || $2[5] !== getData || $2[6] !== getPathSuggestions || $2[7] !== getUser || $2[8] !== onAnalyticsEvent || $2[9] !== reservedGroups) {
    t1 = {
      Component: ConfigControllerProvider,
      props: {
        collectionConfigController,
        configPermissions,
        collectionInference,
        reservedGroups,
        extraView,
        getPathSuggestions,
        getUser,
        getData,
        onAnalyticsEvent,
        components
      }
    };
    $2[0] = collectionConfigController;
    $2[1] = collectionInference;
    $2[2] = components;
    $2[3] = configPermissions;
    $2[4] = extraView;
    $2[5] = getData;
    $2[6] = getPathSuggestions;
    $2[7] = getUser;
    $2[8] = onAnalyticsEvent;
    $2[9] = reservedGroups;
    $2[10] = t1;
  } else {
    t1 = $2[10];
  }
  let t2;
  let t3;
  if ($2[11] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = {
      additionalActions: /* @__PURE__ */ jsxRuntimeExports.jsx(NewCollectionButton, {}),
      additionalChildrenStart: /* @__PURE__ */ jsxRuntimeExports.jsx(IntroWidget$1, {}),
      CollectionActions: HomePageEditorCollectionAction,
      AdditionalCards: NewCollectionCard
    };
    t3 = {
      CollectionActionsStart: EditorCollectionActionStart,
      CollectionActions: EditorCollectionAction,
      HeaderAction: CollectionViewHeaderAction,
      AddColumnComponent: PropertyAddColumnComponent
    };
    $2[11] = t2;
    $2[12] = t3;
  } else {
    t2 = $2[11];
    t3 = $2[12];
  }
  let t4;
  if ($2[13] !== collectionConfigController.loading || $2[14] !== t1) {
    t4 = {
      key: "collection_editor",
      loading: collectionConfigController.loading,
      provider: t1,
      homePage: t2,
      collectionView: t3
    };
    $2[13] = collectionConfigController.loading;
    $2[14] = t1;
    $2[15] = t4;
  } else {
    t4 = $2[15];
  }
  return t4;
}
function IntroWidget$1(t0) {
  const $2 = c_1(11);
  const navigation = useNavigationController$3();
  if (!navigation.topLevelNavigation) {
    throw Error("Navigation not ready in FireCMSHomePage");
  }
  const authController = useAuthController$2();
  const collectionEditorController = useCollectionEditorController();
  let t1;
  if ($2[0] !== authController || $2[1] !== collectionEditorController) {
    t1 = collectionEditorController.configPermissions ? collectionEditorController.configPermissions({
      user: authController.user
    }).createCollections : true;
    $2[0] = authController;
    $2[1] = collectionEditorController;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  const canCreateCollections = t1;
  if (!navigation.initialised || (navigation.collections ?? []).length > 0) {
    return null;
  }
  let t2;
  let t3;
  if ($2[3] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { variant: "subtitle2", className: "uppercase", children: "No collections found" });
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { children: "Start building collections in FireCMS easily. Map them to your existing database data, import from files, or use our templates." });
    $2[3] = t2;
    $2[4] = t3;
  } else {
    t2 = $2[3];
    t3 = $2[4];
  }
  let t4;
  if ($2[5] !== canCreateCollections || $2[6] !== collectionEditorController) {
    t4 = canCreateCollections && /* @__PURE__ */ jsxRuntimeExports.jsxs(Button$3, { onClick: collectionEditorController && canCreateCollections ? () => collectionEditorController.createCollection({
      parentCollectionIds: [],
      redirect: true,
      sourceClick: "new_collection_card"
    }) : void 0, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon$1, {}),
      "Create your first collection"
    ] });
    $2[5] = canCreateCollections;
    $2[6] = collectionEditorController;
    $2[7] = t4;
  } else {
    t4 = $2[7];
  }
  let t5;
  if ($2[8] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$3, { color: "secondary", children: "You can also define collections programmatically." });
    $2[8] = t5;
  } else {
    t5 = $2[8];
  }
  let t6;
  if ($2[9] !== t4) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper$2, { className: "my-4 px-4 py-6 flex flex-col  bg-white dark:bg-surface-accent-800 gap-2", children: [
      t2,
      t3,
      t4,
      t5
    ] });
    $2[9] = t4;
    $2[10] = t6;
  } else {
    t6 = $2[10];
  }
  return t6;
}
const mergeCollections = (baseCollections, backendCollections, modifyCollection) => {
  const markAsEditable = (c2) => {
    makePropertiesEditable2(c2.properties);
    c2.subcollections?.forEach(markAsEditable);
  };
  const storedCollections = backendCollections ?? [];
  storedCollections.forEach(markAsEditable);
  console.debug("Collections specified in code:", baseCollections);
  console.debug("Collections stored in the backend", storedCollections);
  const result = joinCollectionLists2(baseCollections, storedCollections, [], modifyCollection);
  console.debug("Collections after joining:", result);
  return result;
};
function MissingReferenceWidget(t0) {
  const $2 = c_1(12);
  const {
    path: pathProp
  } = t0;
  const navigation = useNavigationController$3();
  const path = getLastSegment2(pathProp);
  let t1;
  if ($2[0] !== navigation || $2[1] !== pathProp) {
    t1 = navigation.getParentCollectionIds(pathProp);
    $2[0] = navigation;
    $2[1] = pathProp;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  const parentCollectionIds = t1;
  const collectionEditor = useCollectionEditorController();
  const t2 = "No collection for path: " + path;
  let t3;
  if ($2[3] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView$1, { error: t2 });
    $2[3] = t2;
    $2[4] = t3;
  } else {
    t3 = $2[4];
  }
  let t4;
  if ($2[5] !== collectionEditor || $2[6] !== parentCollectionIds || $2[7] !== path) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button$3, { className: "mx-2", variant: "outlined", size: "small", onClick: () => {
      collectionEditor.createCollection({
        initialValues: {
          path,
          name: unslugify$2(path)
        },
        parentCollectionIds,
        redirect: false,
        sourceClick: "missing_reference"
      });
    }, children: "Create" });
    $2[5] = collectionEditor;
    $2[6] = parentCollectionIds;
    $2[7] = path;
    $2[8] = t4;
  } else {
    t4 = $2[8];
  }
  let t5;
  if ($2[9] !== t3 || $2[10] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-1 flex flex-col items-center", children: [
      t3,
      t4
    ] });
    $2[9] = t3;
    $2[10] = t4;
    $2[11] = t5;
  } else {
    t5 = $2[11];
  }
  return t5;
}
function getLastSegment2(path) {
  const segments = path.split("/");
  return segments[segments.length - 1];
}
const React$3 = await importShared("react");
const { useMemo: useMemo$3, useEffect: useEffect$3, useCallback: useCallback$3 } = React$3;
const { getFirestore: getFirestore$2, onSnapshot: onSnapshot$2, collection: collection$2, doc: doc$2, deleteDoc: deleteDoc$1, runTransaction, getDocs: getDocs$1, query: query$2, limit: limit$1, collectionGroup, Timestamp: Timestamp$1, DocumentReference } = await importShared("@firebase/firestore");
const { applyPermissionsFunctionIfEmpty: applyPermissionsFunctionIfEmpty2, removeFunctions: removeFunctions2, removeUndefined: removeUndefined2, removeInitialAndTrailingSlashes: removeInitialAndTrailingSlashes2, unslugify: unslugify$1, GeoPoint: GeoPoint2 } = await importShared("@firecms/core");
const { docsToCollectionTree: docsToCollectionTree2, buildCollectionId: buildCollectionId2, prepareCollectionForPersistence: prepareCollectionForPersistence2, setUndefinedToDelete: setUndefinedToDelete2 } = await importShared("@firecms/firebase");
function useFirestoreCollectionsConfigController({
  firebaseApp,
  configPath = "__FIRECMS/config/collections",
  permissions,
  propertyConfigs
}) {
  const propertyConfigsMap = useMemo$3(() => {
    const map = {};
    propertyConfigs?.forEach((field) => {
      map[field.key] = field;
    });
    return map;
  }, [propertyConfigs]);
  const [collectionsLoading, setCollectionsLoading] = React$3.useState(true);
  const [persistedCollections, setPersistedCollections] = React$3.useState();
  const [collectionsError, setCollectionsError] = React$3.useState();
  useEffect$3(() => {
    if (!firebaseApp || !configPath) return;
    const firestore = getFirestore$2(firebaseApp);
    return onSnapshot$2(collection$2(firestore, configPath), {
      next: (snapshot) => {
        setCollectionsError(void 0);
        try {
          const newCollections = docsToCollectionTree2(snapshot.docs);
          setPersistedCollections(newCollections);
        } catch (e) {
          console.error(e);
          setCollectionsError(e);
        }
        setCollectionsLoading(false);
      },
      error: (e_0) => {
        setCollectionsLoading(false);
        setCollectionsError(e_0);
      }
    });
  }, [configPath, firebaseApp]);
  const deleteCollection = useCallback$3(({
    id,
    parentCollectionIds
  }) => {
    if (!firebaseApp || !configPath) throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    const firestore_0 = getFirestore$2(firebaseApp);
    const collectionPath = buildCollectionId2(id, parentCollectionIds);
    console.debug("!!Deleting collection", collectionPath);
    const ref2 = doc$2(firestore_0, configPath, collectionPath);
    return deleteDoc$1(ref2);
  }, [configPath, firebaseApp]);
  const saveCollection = useCallback$3(({
    id: id_0,
    collectionData,
    previousId,
    parentCollectionIds: parentCollectionIds_0
  }) => {
    if (!firebaseApp || !configPath) throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    const firestore_1 = getFirestore$2(firebaseApp);
    if (!id_0) throw Error("Trying to save a collection with no id");
    if (!collectionData.path) throw Error("Trying to save a collection with no path");
    if (!collectionData.name) throw Error("Trying to save a collection with no name");
    const cleanedCollection = prepareCollectionForPersistence2(collectionData, propertyConfigsMap);
    const strippedPath = buildCollectionId2(id_0, parentCollectionIds_0);
    const previousStrippedId = previousId ? buildCollectionId2(previousId, parentCollectionIds_0) : void 0;
    const ref_0 = doc$2(firestore_1, configPath, strippedPath);
    console.debug("Saving collection", {
      id: id_0,
      collectionData,
      previousId,
      parentCollectionIds: parentCollectionIds_0,
      cleanedCollection
    });
    return runTransaction(firestore_1, async (transaction) => {
      transaction.set(ref_0, cleanedCollection, {
        merge: true
      });
      if (previousStrippedId && previousStrippedId !== strippedPath) {
        const previousRef = doc$2(firestore_1, configPath, previousStrippedId);
        transaction.delete(previousRef);
      }
    });
  }, [configPath, firebaseApp, propertyConfigsMap]);
  const updateCollection = useCallback$3(({
    id: id_1,
    collectionData: collectionData_0,
    previousId: previousId_0,
    parentCollectionIds: parentCollectionIds_1
  }) => {
    if (!firebaseApp || !configPath) throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    const firestore_2 = getFirestore$2(firebaseApp);
    const cleanedCollection_0 = prepareCollectionForPersistence2(collectionData_0, propertyConfigsMap);
    const strippedPath_0 = buildCollectionId2(id_1, parentCollectionIds_1);
    const previousStrippedPath = previousId_0 ? buildCollectionId2(previousId_0, parentCollectionIds_1) : void 0;
    const ref_1 = doc$2(firestore_2, configPath, strippedPath_0);
    console.debug("Updating collection", {
      id: id_1,
      collectionData: collectionData_0,
      previousId: previousId_0,
      parentCollectionIds: parentCollectionIds_1,
      cleanedCollection: cleanedCollection_0
    });
    return runTransaction(firestore_2, async (transaction_0) => {
      transaction_0.set(ref_1, cleanedCollection_0, {
        merge: true
      });
      if (previousStrippedPath && previousStrippedPath !== strippedPath_0) {
        const previousRef_0 = doc$2(firestore_2, configPath, previousStrippedPath);
        transaction_0.delete(previousRef_0);
      }
    });
  }, [configPath, firebaseApp, propertyConfigsMap]);
  const collections = persistedCollections !== void 0 ? applyPermissionsFunctionIfEmpty2(persistedCollections, permissions) : void 0;
  const getCollection = useCallback$3((id_2) => {
    if (!collections) throw Error("Collections not initialised");
    const collection2 = collections.find((c2) => c2.id === id_2);
    if (!collection2) throw Error(`Collection with id ${id_2} not found`);
    return collection2;
  }, [collections]);
  const saveProperty = useCallback$3(({
    path,
    propertyKey,
    property,
    newPropertiesOrder,
    parentCollectionIds: parentCollectionIds_2,
    namespace
  }) => {
    if (!firebaseApp || !configPath) throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    const firestore_3 = getFirestore$2(firebaseApp);
    const collectionPath_0 = buildCollectionId2(path, parentCollectionIds_2);
    const ref_2 = doc$2(firestore_3, configPath, collectionPath_0);
    return runTransaction(firestore_3, async (transaction_1) => {
      const data = {
        [namespaceToPropertiesPath(namespace) + "." + propertyKey]: setUndefinedToDelete2(removeFunctions2(removeUndefined2(property)))
      };
      if (newPropertiesOrder) {
        data.propertiesOrder = newPropertiesOrder;
      }
      console.debug("Saving property", {
        path,
        propertyKey,
        property,
        collectionPath: collectionPath_0,
        namespace,
        data
      });
      transaction_1.update(ref_2, data);
    });
  }, [configPath, firebaseApp]);
  const deleteProperty = useCallback$3(({
    path: path_0,
    propertyKey: propertyKey_0,
    newPropertiesOrder: newPropertiesOrder_0,
    parentCollectionIds: parentCollectionIds_3,
    namespace: namespace_0
  }) => {
    if (!firebaseApp || !configPath) throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    const firestore_4 = getFirestore$2(firebaseApp);
    const collectionPath_1 = buildCollectionId2(path_0, parentCollectionIds_3);
    const ref_3 = doc$2(firestore_4, configPath, collectionPath_1);
    return runTransaction(firestore_4, async (transaction_2) => {
      const data_0 = setUndefinedToDelete2({
        [namespaceToPropertiesPath(namespace_0) + "." + propertyKey_0]: void 0
      });
      if (newPropertiesOrder_0) {
        data_0.propertiesOrder = newPropertiesOrder_0;
      }
      console.debug("Deleting property", {
        path: path_0,
        propertyKey: propertyKey_0,
        collectionPath: collectionPath_1,
        namespace: namespace_0,
        data: data_0
      });
      transaction_2.update(ref_3, data_0);
    });
  }, [configPath, firebaseApp]);
  return {
    loading: collectionsLoading,
    collections,
    getCollection,
    saveCollection,
    updateCollection,
    deleteCollection,
    saveProperty,
    deleteProperty
  };
}
async function getDocuments(firestore, collectionPath, isCollectionGroup = false, parentPathSegments, limitCount = 200) {
  if (parentPathSegments && (parentPathSegments ?? [])?.length > 0) {
    const [thisSubPath, ...restSubpaths] = parentPathSegments;
    const childLimit = 5;
    const childDocs = await getDocs$1(query$2(collection$2(firestore, thisSubPath), limit$1(limitCount)));
    return Promise.all(childDocs.docs.map((doc2) => getDocuments(firestore, doc2.ref.path + "/" + collectionPath, isCollectionGroup, restSubpaths, Math.max(Math.ceil(limitCount / 5), childLimit)))).then((res2) => res2.flat());
  }
  const q = query$2(isCollectionGroup ? collectionGroup(firestore, collectionPath) : collection$2(firestore, collectionPath), limit$1(limitCount));
  const res = await getDocs$1(q);
  console.debug("Got documents", isCollectionGroup, q, res.docs);
  return res.docs;
}
async function getInferredEntityCollection(firestore, collectionPath, isCollectionGroup, parentPathSegments) {
  console.debug("Building schema for collection", collectionPath, parentPathSegments);
  const cleanPath = removeInitialAndTrailingSlashes2(collectionPath);
  const docs = await getDocuments(firestore, cleanPath, isCollectionGroup, parentPathSegments);
  const data = docs.map((doc2) => doc2.data()).filter(Boolean);
  return getInferredEntityCollectionFromData(collectionPath, data);
}
async function getInferredEntityCollectionFromData(collectionPath, data) {
  const cleanPath = removeInitialAndTrailingSlashes2(collectionPath);
  const properties = await buildEntityPropertiesFromData(data, getType);
  const propertiesOrder = buildPropertiesOrder(properties);
  const lastPathSegment = cleanPath.includes("/") ? cleanPath.split("/").slice(-1)[0] : cleanPath;
  return {
    path: cleanPath,
    name: unslugify$1(lastPathSegment),
    properties,
    propertiesOrder
  };
}
async function getPropertiesFromData(data) {
  return buildEntityPropertiesFromData(data, getType);
}
function getType(value) {
  if (typeof value === "number") return "number";
  else if (typeof value === "string") return "string";
  else if (typeof value === "boolean") return "boolean";
  else if (Array.isArray(value)) return "array";
  else if (value instanceof Timestamp$1) return "date";
  else if (value instanceof GeoPoint2) return "geopoint";
  else if (value instanceof DocumentReference) return "reference";
  return "map";
}
const buildCollectionInference = (dataFirebaseApp) => {
  if (!dataFirebaseApp) return void 0;
  return (path, collectionGroup2, parentPathSegments) => {
    const firestore = getFirestore$2(dataFirebaseApp);
    return getInferredEntityCollection(firestore, path, collectionGroup2, parentPathSegments);
  };
};
const React$2 = await importShared("react");
const { useState: useState$2, useRef: useRef$2, useMemo: useMemo$2, useEffect: useEffect$2, useCallback: useCallback$2, useContext: useContext$2, useDeferredValue: useDeferredValue$1 } = React$2;
const { isPropertyBuilder: isPropertyBuilder2, getValueInPath: getValueInPath2, getFieldId: getFieldId2, useCustomizationController: useCustomizationController$2, useAuthController: useAuthController$1, useSnackbarController: useSnackbarController$1, resolveCollection: resolveCollection$1, useDataSource: useDataSource2, useNavigationController: useNavigationController$2, useClearRestoreValue: useClearRestoreValue2, getIconForProperty: getIconForProperty2, LabelWithIconAndTooltip: LabelWithIconAndTooltip2, PropertyIdCopyTooltip: PropertyIdCopyTooltip2, FieldHelperText: FieldHelperText2, MarkdownEditorFieldBinding: MarkdownEditorFieldBinding2, singular: singular2, stripCollectionPath: stripCollectionPath2 } = await importShared("@firecms/core");
const { Typography: Typography$2, Button: Button$2, TextField: TextField$2, cls: cls$2, fieldBackgroundMixin: fieldBackgroundMixin2, fieldBackgroundDisabledMixin: fieldBackgroundDisabledMixin2, fieldBackgroundHoverMixin: fieldBackgroundHoverMixin2, InputLabel: InputLabel2, TextareaAutosize: TextareaAutosize$1, Tooltip: Tooltip$2, Menu: Menu$2, IconButton: IconButton$2, CircularProgress: CircularProgress$1, AutoAwesomeIcon: AutoAwesomeIcon$1, MenuItem: MenuItem$2, SendIcon: SendIcon$1, useAutoComplete: useAutoComplete2, defaultBorderMixin: defaultBorderMixin2, AutoFixHighIcon: AutoFixHighIcon$1, focusedDisabled: focusedDisabled2, Autocomplete: Autocomplete2, AutocompleteItem: AutocompleteItem2, CloseIcon: CloseIcon$2 } = await importShared("@firecms/ui");
function flatMapEntityValues(values, path = "") {
  if (!values) return {};
  return Object.entries(values).flatMap(([key2, value]) => {
    const currentPath = path ? `${path}.${key2}` : key2;
    if (typeof value === "object") {
      return flatMapEntityValues(value, currentPath);
    } else {
      return {
        [currentPath]: value
      };
    }
  }).reduce((acc, curr) => ({
    ...acc,
    ...curr
  }), {});
}
const DEFAULT_SERVER = "https://api-drplyi3b6q-ey.a.run.app";
async function enhanceDataAPIStream(props) {
  const flatValues = flatMapEntityValues(props.values);
  const properties = props.properties;
  const inputEntity = {
    entityId: props.entityId,
    values: flatValues
  };
  const request = {
    inputEntity,
    properties,
    entityName: props.entityName,
    entityDescription: props.entityDescription,
    propertyKey: props.propertyKey,
    propertyInstructions: props.propertyInstructions,
    instructions: props.instructions
  };
  console.debug("enhanceDataAPIStream", request);
  return fetch((props.host ?? DEFAULT_SERVER) + "/data/enhance_stream/", {
    // mode: "no-cors",
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Basic ${props.firebaseToken}`,
      "x-de-api-key": `Basic ${props.apiKey}`
      // "x-de-version": version
    },
    body: JSON.stringify(request)
  }).then(async (res) => {
    if (!res.ok) {
      console.error("enhanceDataAPIStream error", res);
      throw await res.json();
    }
    const reader = res.body?.getReader();
    if (!reader) {
      throw new Error("No reader");
    }
    for await (const chunk of readChunks(reader)) {
      const str = new TextDecoder().decode(chunk);
      try {
        str.split("&$# ").forEach((s) => {
          if (s && s.length > 0) {
            const data = JSON.parse(s.trim());
            if (data.type === "suggestion_delta") props.onUpdateDelta(data.data.propertyKey, data.data.partialValue);
            else if (data.type === "suggestion") props.onUpdate(data.data);
            else if (data.type === "result") props.onEnd(data.data);
          }
        });
      } catch (e) {
        console.error("str", str);
        console.error("Error parsing stream", e);
        props.onError(e);
      }
    }
  });
}
function readChunks(reader) {
  return {
    async *[Symbol.asyncIterator]() {
      let readResult = await reader.read();
      while (!readResult.done) {
        yield readResult.value;
        readResult = await reader.read();
      }
    }
  };
}
async function fetchEntityPromptSuggestion(props) {
  return fetch((props.host ?? DEFAULT_SERVER) + "/data/prompt_autocomplete/", {
    // mode: "no-cors",
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Basic ${props.firebaseToken}`,
      "x-de-api-key": `Basic ${props.apiKey}`
    },
    body: JSON.stringify({
      entityName: props.entityName,
      input: props.input ?? null
    })
  }).then(async (res) => {
    const data = await res.json();
    if (!res.ok) {
      console.error("fetchEntityPromptSuggestion", data);
      throw Error(data.message);
    }
    return {
      prompts: data.data.prompts.map((e) => ({
        prompt: e,
        type: "sample"
      }))
    };
  });
}
async function autocompleteStream(props) {
  let result = "";
  return fetch((props.host ?? DEFAULT_SERVER) + "/data/autocomplete/", {
    // mode: "no-cors",
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Basic ${props.firebaseToken}`
      // "x-de-version": version
    },
    body: JSON.stringify({
      textBefore: props.textBefore,
      textAfter: props.textAfter
    })
  }).then(async (res) => {
    if (!res.ok) {
      console.error("enhanceDataAPIStream error", res);
      throw await res.json();
    }
    const reader = res.body?.getReader();
    if (!reader) {
      throw new Error("No reader");
    }
    for await (const chunk of readChunks(reader)) {
      const str = new TextDecoder().decode(chunk);
      result += str;
      console.debug("Autocomplete update:", str);
      props.onUpdate(str);
    }
  }).then(() => {
    console.debug("Autocomplete result:", result);
    return result;
  });
}
function getAppendableSuggestion(suggestion, value) {
  const suggestionIncludesValue = typeof suggestion === "string" && typeof value === "string" && suggestion.toLowerCase().trim().startsWith(value.toLowerCase().trim());
  return typeof value === "string" && suggestionIncludesValue ? suggestion.substr(suggestion.toLowerCase().trim().indexOf(value.toLowerCase().trim()) + value.trim().length) : void 0;
}
function getSimplifiedProperties(properties, values, path = "") {
  if (!properties) return {};
  return Object.entries(properties).map(([key2, property]) => {
    if (isPropertyBuilder2(property)) return {};
    const fullKey = path ? `${path}.${key2}` : key2;
    const valueInPath = getValueInPath2(values, fullKey);
    return getSimplifiedProperty(property, fullKey, valueInPath);
  }).reduce((a, b) => ({
    ...a,
    ...b
  }), {});
}
function getSimpleProperty(property) {
  const fieldId = getFieldId2(property);
  if (!fieldId) {
    console.error("No fieldId found for property", property);
    throw new Error("Field id not found");
  }
  return {
    name: property.name,
    description: property.description,
    dataType: property.dataType,
    fieldConfigId: fieldId,
    enumValues: "enumValues" in property && property.enumValues ? getSimpleEnumValues(property.enumValues) : void 0,
    disabled: Boolean(property.disabled || property.readOnly)
  };
}
function getSimplifiedProperty(property, path, value) {
  if (isPropertyBuilder2(property)) return {};
  if (property.dataType === "array") {
    if (property.of && !isPropertyBuilder2(property.of)) {
      const arrayParentProperty = {
        name: property.name,
        description: property.description,
        dataType: property.dataType,
        fieldConfigId: "repeat",
        disabled: Boolean(property.disabled || property.readOnly),
        of: getSimpleProperty(property.of)
      };
      const result = {
        [path]: arrayParentProperty
      };
      return result;
    } else if (property.oneOf) {
      const arrayParentProperty = {
        name: property.name,
        description: property.description,
        dataType: property.dataType,
        fieldConfigId: "block",
        disabled: Boolean(property.disabled || property.readOnly),
        oneOf: {
          typeField: property.oneOf.typeField,
          valueField: property.oneOf.valueField,
          properties: Object.entries(property.oneOf.properties).map(([key2, prop]) => ({
            [key2]: getSimpleProperty(prop)
          })).reduce((a, b) => ({
            ...a,
            ...b
          }), {})
        }
      };
      if (!Array.isArray(value)) {
        return {
          [path]: arrayParentProperty
        };
      }
      return value.map((v2, i) => {
        const typeKey = property.oneOf.typeField ?? "type";
        const oneOfType = v2[typeKey];
        const valueKey = property.oneOf.valueField ?? "value";
        const oneOfValue = v2[valueKey];
        const childProperty = property.oneOf.properties[oneOfType];
        if (childProperty === void 0) {
          console.error(`No property found for type ${oneOfType}`, property.oneOf.properties);
          return {};
        }
        const simplifiedProperty = getSimplifiedProperty(childProperty, `${path}.${i}.${valueKey}`, oneOfValue);
        return {
          [`${path}.${i}.${typeKey}`]: oneOfType,
          ...simplifiedProperty
        };
      }).reduce((a, b) => ({
        ...a,
        ...b
      }), {
        [path]: arrayParentProperty
      });
    }
  } else if (property.dataType === "map") {
    if (property.properties) {
      const mapProperties = Object.entries(property.properties).map(([key2, childProperty]) => {
        const childValue = value?.[key2];
        return getSimplifiedProperty(childProperty, key2, childValue);
      }).map((o) => attachPathToKeys(o, path)).reduce((a, b) => ({
        ...a,
        ...b
      }), {});
      if (Object.keys(mapProperties).length === 0) return {};
      const mapParentProperty = {
        name: property.name,
        description: property.description,
        dataType: property.dataType,
        fieldConfigId: "group",
        disabled: Boolean(property.disabled || property.readOnly)
      };
      return {
        [path]: mapParentProperty,
        ...mapProperties
      };
    }
  } else {
    const fieldId = getFieldId2(property);
    if (!fieldId) {
      console.warn(`No fieldId found for property ${path} with dataType ${property.dataType}`);
      return {};
    }
    return {
      [path]: getSimpleProperty(property)
    };
  }
  return {};
}
function attachPathToKeys(obj, path = "") {
  return Object.entries(obj).map(([key2, value]) => {
    const fullKey = path ? `${path}.${key2}` : key2;
    return {
      [fullKey]: value
    };
  }).reduce((a, b) => ({
    ...a,
    ...b
  }), {});
}
function getSimpleEnumValues(enumValues) {
  if (Array.isArray(enumValues)) return enumValues.map((v2) => String(v2.id));
  if (typeof enumValues === "object") return Object.keys(enumValues);
  throw Error("getSimpleEnumValues: Invalid enumValues");
}
function DefaultSubscriptionMessage(t0) {
  const $2 = c_1(5);
  const {
    projectId
  } = t0;
  let t1;
  let t2;
  let t3;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$2, { variant: "h6", children: "Subscription required" });
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$2, { children: "You have finished your free usage quota." });
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$2, { children: "You need an active subscription in order to continue using the plugin" });
    $2[0] = t1;
    $2[1] = t2;
    $2[2] = t3;
  } else {
    t1 = $2[0];
    t2 = $2[1];
    t3 = $2[2];
  }
  const t4 = `https://app.firecms.co/subscriptions?projectId=${projectId}`;
  let t5;
  if ($2[3] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-1 p-1", children: [
      t1,
      t2,
      t3,
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { href: t4, color: "primary", component: "a", rel: "noopener noreferrer", target: "_blank", children: "Create a subscription" })
    ] });
    $2[3] = t4;
    $2[4] = t5;
  } else {
    t5 = $2[4];
  }
  return t5;
}
function useEditorAIController({
  getAuthToken
}) {
  const autocomplete = async (textBefore, textAfter, onUpdate) => {
    if (!getAuthToken) {
      throw new Error("Firebase token is required");
    }
    const firebaseToken = await getAuthToken();
    return autocompleteStream({
      firebaseToken,
      textBefore,
      textAfter,
      onUpdate
    });
  };
  return {
    autocomplete
  };
}
const DataEnhancementControllerContext = React$2.createContext({});
const useDataEnhancementController = () => {
  return useContext$2(DataEnhancementControllerContext);
};
function getPropertyFromKey(properties, propertyKey) {
  if (propertyKey in properties) {
    return properties[propertyKey];
  } else {
    const split = propertyKey.split(".");
    if (split.length === 1) {
      return void 0;
    }
    const parentKey = split.slice(0, split.length - 1).join(".");
    return getPropertyFromKey(properties, parentKey);
  }
}
function DataEnhancementControllerProvider({
  apiKey,
  getConfigForPath,
  children,
  host,
  path,
  collection: collection2,
  formContext,
  interceptUsage,
  SubscriptionMessage: SubscriptionMessageProp = DefaultSubscriptionMessage
}) {
  const [enabled, setEnabled] = useState$2(false);
  const [suggestions, setSuggestions] = useState$2({});
  const [loadingSuggestions, setLoadingSuggestions] = useState$2([]);
  const customizationController = useCustomizationController$2();
  const enhancingInProgress = useRef$2(false);
  const authController = useAuthController$1();
  const snackbarController = useSnackbarController$1();
  const resolvedCollection = resolveCollection$1({
    collection: collection2,
    path,
    entityId: formContext?.entityId,
    values: formContext?.values,
    propertyConfigs: customizationController.propertyConfigs
  });
  const properties = useMemo$2(() => getSimplifiedProperties(resolvedCollection.properties, formContext?.values), [formContext?.values]);
  const valuesRef = React$2.useRef(formContext?.values ?? {});
  useEffect$2(() => {
    if (!enhancingInProgress.current) valuesRef.current = formContext?.values ?? {};
  }, [formContext?.values]);
  const allowReferenceDataSelection = false;
  const updateConfig = useCallback$2(async () => {
    if (!getConfigForPath) return;
    const config2 = getConfigForPath({
      path,
      collection: collection2
    });
    if (config2) {
      setEnabled(true);
    }
  }, [collection2, getConfigForPath, path]);
  useEffect$2(() => {
    if (!getConfigForPath) {
      setEnabled(true);
    } else {
      updateConfig();
    }
  }, [getConfigForPath, updateConfig]);
  const dataSource = useDataSource2(collection2);
  const navigationController = useNavigationController$2();
  const clearSuggestion = useCallback$2((propertyKey) => {
    setSuggestions((prev) => {
      const {
        [propertyKey]: _2,
        ...rest
      } = prev;
      return rest;
    });
  }, []);
  const appendValueDelta = (propertyKey_0, delta) => {
    const property = getPropertyFromKey(properties, propertyKey_0);
    if (delta === null || property?.disabled) {
      return;
    }
    const value = getValueInPath2(valuesRef.current, propertyKey_0);
    const currentValue = value ? value + "" : "";
    const updatedValue = currentValue + delta;
    valuesRef.current = {
      ...valuesRef.current,
      [propertyKey_0]: updatedValue
    };
    formContext?.setFieldValue(propertyKey_0, updatedValue, false);
    setSuggestions((prev_0) => ({
      ...prev_0,
      [propertyKey_0]: (prev_0[propertyKey_0] ?? "") + delta
    }));
  };
  const updateSuggestedValues = (currentValues, updatedValues, replaceValues) => {
    setLoadingSuggestions((prev_1) => {
      return prev_1.filter((p) => !Object.keys(updatedValues).includes(p));
    });
    Object.entries(updatedValues).forEach(([propertyKey_1, suggestion]) => {
      const value_0 = getValueInPath2(currentValues, propertyKey_1);
      const property_0 = getPropertyFromKey(properties, propertyKey_1);
      if (!property_0 || suggestion === null || property_0.disabled) {
        return;
      }
      if (typeof suggestion === "number") {
        formContext?.setFieldValue(propertyKey_1, suggestion);
        return;
      }
      if (replaceValues) {
        formContext?.setFieldValue(propertyKey_1, suggestion);
        return;
      }
      const appendableValue = getAppendableSuggestion(suggestion, value_0);
      const currentValue_0 = value_0 ? value_0 + "" : "";
      if (appendableValue) {
        formContext?.setFieldValue(propertyKey_1, suggestion);
      } else {
        const multiline = property_0?.fieldConfigId === "multiline" || property_0?.fieldConfigId === "markdown";
        const trimmedValue = currentValue_0.trimEnd();
        if (multiline && (trimmedValue.endsWith(".") || trimmedValue.endsWith("?") || trimmedValue.endsWith("!") || trimmedValue.endsWith(":"))) {
          formContext?.setFieldValue(propertyKey_1, trimmedValue + "\n\n" + suggestion.trimStart());
        } else {
          formContext?.setFieldValue(propertyKey_1, trimmedValue + (trimmedValue.length > 0 ? " " : "") + suggestion);
        }
      }
    });
    setSuggestions((prev_2) => ({
      ...prev_2,
      ...Object.keys(updatedValues).reduce((acc, key2) => {
        const value_1 = getValueInPath2(formContext?.values, key2);
        const suggestion_0 = updatedValues[key2];
        return {
          ...acc,
          [key2]: getAppendableSuggestion(suggestion_0, value_1) ?? suggestion_0
        };
      }, {})
    }));
  };
  function displayNeededSubscriptionSnackbar(projectId) {
    snackbarController.open({
      type: "warning",
      message: /* @__PURE__ */ jsxRuntimeExports.jsx(SubscriptionMessageProp, { projectId }),
      autoHideDuration: 4e3
    });
  }
  const editorAIController = useEditorAIController({
    getAuthToken: authController.getAuthToken
  });
  const enhance = async (props) => {
    if (interceptUsage) {
      interceptUsage();
      return null;
    }
    if (!authController.user) {
      snackbarController.open({
        type: "warning",
        message: "You need to be logged in to enhance data"
      });
      return Promise.reject(new Error("Not logged in"));
    }
    const resolvedPath = navigationController.resolveAliasesFrom(path);
    const firebaseToken = await authController.getAuthToken();
    if (props.propertyKey) {
      clearSuggestion(props.propertyKey);
    } else {
      clearAllSuggestions();
    }
    setLoadingSuggestions((prev_3) => [...prev_3, ...props.propertyKey ? [props.propertyKey] : Object.keys(properties)]);
    enhancingInProgress.current = true;
    const currentValues_0 = valuesRef.current ?? {};
    return new Promise((resolve, reject) => {
      function onError(e) {
        setLoadingSuggestions([]);
        if (e.code === "payment-required") {
          const projectId_0 = e.data.projectId;
          displayNeededSubscriptionSnackbar(projectId_0);
        } else {
          console.error("Enhance error", e);
        }
        reject(e);
        enhancingInProgress.current = false;
      }
      try {
        enhanceDataAPIStream({
          ...props,
          host,
          apiKey,
          properties,
          path: resolvedPath,
          entityName: collection2.singularName ?? collection2.name,
          entityDescription: collection2.description,
          dataSource,
          firebaseToken,
          onUpdate: (suggestions_0) => {
            console.debug("de onUpdate", suggestions_0);
            updateSuggestedValues(currentValues_0, suggestions_0, props.replaceValues ?? false);
          },
          onUpdateDelta: (propertyKey_2, partialValue) => {
            appendValueDelta(propertyKey_2, partialValue);
          },
          onError,
          onEnd: (result) => {
            console.debug("de onEnd", result);
            if (result.errors) {
              result.errors.forEach((error) => {
                snackbarController.open({
                  type: "warning",
                  message: error
                });
              });
            }
            if (Object.keys(result.suggestions).length === 0) {
              snackbarController.open({
                type: "info",
                autoHideDuration: 1800,
                message: "No fields were updated"
              });
            }
            setLoadingSuggestions([]);
            resolve(result);
            enhancingInProgress.current = false;
          }
        }).catch(onError);
      } catch (e_0) {
        onError(e_0);
      }
    });
  };
  const clearAllSuggestions = useCallback$2(() => {
    setSuggestions({});
  }, []);
  const getSamplePrompts = useCallback$2(async (entityName, input) => {
    const firebaseToken_0 = await authController.getAuthToken();
    return fetchEntityPromptSuggestion({
      host,
      entityName,
      firebaseToken: firebaseToken_0,
      apiKey,
      input
    });
  }, [apiKey, authController.getAuthToken]);
  const dataEnhancementController = {
    enabled,
    suggestions,
    clearSuggestion,
    enhance,
    allowReferenceDataSelection,
    clearAllSuggestions,
    getSamplePrompts,
    loadingSuggestions,
    interceptUsage,
    editorAIController
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DataEnhancementControllerContext.Provider, { value: dataEnhancementController, children });
}
const SUPPORTED_FIELDS_ENHANCEMENT = [
  "text_field",
  "number_input",
  "multiline",
  "markdown",
  "email",
  "select"
  // "multi_select",
];
function AdvancedTextField({
  value,
  setValue,
  label,
  inputType,
  multiline = false,
  highlight,
  disabled,
  error,
  size = "large",
  className
}) {
  const inputRef = useRef$2(null);
  const ref2 = useRef$2(null);
  const [internalValue, setInternalValue] = React$2.useState(value ? value.toString() : "");
  useEffect$2(() => {
    setInternalValue(value ? value.toString() : "");
  }, [value]);
  const onScroll = useCallback$2((e) => {
    if (!ref2.current) return;
    ref2.current.scrollTop = e.target.scrollTop;
    ref2.current.scrollLeft = e.target.scrollLeft;
  }, []);
  const [focused, setFocused] = React$2.useState(document.activeElement === inputRef.current);
  const hasValue = internalValue !== void 0 && internalValue !== null && internalValue !== "";
  const endsWithHighlight = !!highlight && (value === highlight || String(value).endsWith(highlight));
  const originalValue = endsWithHighlight ? String(value).substring(0, String(value).length - highlight.length) : internalValue;
  const onChange = useCallback$2((event) => {
    const stringValue = event.target.value;
    if (inputType === "number") {
      if (stringValue === "-" || stringValue.startsWith(".") || stringValue.endsWith(".")) {
        setInternalValue(stringValue);
      } else {
        const numberValue = stringValue ? parseFloat(stringValue) : void 0;
        if (numberValue && isNaN(numberValue)) {
          setValue(null);
          setInternalValue("");
        } else if (numberValue !== void 0 && numberValue !== null) {
          setValue(numberValue);
          setInternalValue(numberValue.toString());
        } else {
          setValue(null);
          setInternalValue("");
        }
      }
    } else {
      setValue(stringValue);
      setInternalValue(stringValue);
    }
  }, [inputType, setValue]);
  useCallback$2((e_0) => {
    e_0.target.blur();
    e_0.stopPropagation();
    setTimeout(() => {
      e_0.target.focus();
    }, 0);
  }, []);
  if (disabled) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$2, { label, disabled: true, value: internalValue });
  }
  const additional = {
    onKeyPress: (e_1) => {
      if (!multiline && e_1.key === "Enter") {
        e_1.preventDefault();
      }
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cls$2("rounded-md relative max-w-full", fieldBackgroundMixin2, disabled ? fieldBackgroundDisabledMixin2 : fieldBackgroundHoverMixin2, error ? "border border-red-500 dark:border-red-600" : "", {
    "min-h-[32px]": size === "small",
    "min-h-[48px]": size === "medium",
    "min-h-[64px]": size === "large"
  }, className), children: [
    label && /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel2, { className: cls$2("absolute pointer-events-none", !error ? focused ? "text-primary" : "text-text-secondary dark:text-text-secondary-dark" : "text-red-500 dark:text-red-600", disabled ? "opacity-50" : "", size === "large" ? "top-1" : "-top-px"), shrink: hasValue || focused, children: label }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: ref2, className: cls$2("inset-0 whitespace-pre-wrap overflow-x-auto select-none pb-2 px-3", {
      "pt-8": size === "large",
      "pt-4": size === "medium" || size === "small"
    }), children: [
      addLineBreaks(originalValue, !endsWithHighlight && multiline),
      endsWithHighlight && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dark:bg-surface-accent-700 bg-surface-accent-300 p-px -m-px rounded-sm", children: addLineBreaks(highlight, multiline) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TextareaAutosize$1, { className: cls$2({
      "min-h-[32px]": size === "small",
      "min-h-[48px]": size === "medium",
      "min-h-[64px]": size === "large"
    }, "rounded-md resize-none w-full outline-none text-base bg-transparent ", disabled && "border border-transparent outline-none opacity-50 text-surface-600 dark:text-surface-500", "absolute top-0 right-0 left-0 max-w-full bg-transparent text-transparent caret-surface-800 dark:caret-surface-200", "pt-8 pb-2 px-3", label ? size === "large" ? "pt-8 pb-2" : "pt-4 pb-2" : "py-2"), ignoreBoxSizing: true, ref: inputRef, onFocus: () => setFocused(true), onBlur: () => setFocused(false), value: internalValue, sizeRef: ref2, onChange, onScroll, ...additional })
  ] });
}
function addLineBreaks(value, addLastBreak = false) {
  if (typeof value === "number" || value === void 0) return value;
  if (typeof value !== "string") {
    console.error("addLineBreaks: value is not a string", value);
    return "";
  }
  const lines = value.split("\n");
  if (lines.length === 1) return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "break-words", children: value ?? "" });
  return lines.map((p, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs(React$2.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "break-words", children: p ?? "" }),
    (lines.length - 1 !== i || addLastBreak) && /* @__PURE__ */ jsxRuntimeExports.jsx("br", {})
  ] }, i));
}
const EnhanceTextFieldBinding = React$2.memo(function EnhanceTextFieldBinding2(t0) {
  const $2 = c_1(32);
  const {
    propertyKey,
    value,
    setValue,
    error,
    showError,
    disabled,
    property,
    includeDescription,
    highlight,
    size
  } = t0;
  let multiline = false;
  if (property.dataType === "string") {
    multiline = (property.multiline || property.markdown) ?? false;
  }
  let t1;
  if ($2[0] !== property || $2[1] !== setValue || $2[2] !== value) {
    t1 = {
      property,
      value,
      setValue
    };
    $2[0] = property;
    $2[1] = setValue;
    $2[2] = value;
    $2[3] = t1;
  } else {
    t1 = $2[3];
  }
  useClearRestoreValue2(t1);
  const internalValue = value ?? (property.dataType === "string" ? "" : value === 0 ? 0 : "");
  const t2 = property.dataType === "number" ? "number" : "text";
  let t3;
  if ($2[4] !== property) {
    t3 = getIconForProperty2(property);
    $2[4] = property;
    $2[5] = t3;
  } else {
    t3 = $2[5];
  }
  const t4 = (property.name ?? "") + (property.validation?.required ? " *" : "");
  let t5;
  if ($2[6] !== propertyKey || $2[7] !== t3 || $2[8] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(LabelWithIconAndTooltip2, { propertyKey, icon: t3, title: t4 });
    $2[6] = propertyKey;
    $2[7] = t3;
    $2[8] = t4;
    $2[9] = t5;
  } else {
    t5 = $2[9];
  }
  let t6;
  if ($2[10] !== disabled || $2[11] !== highlight || $2[12] !== internalValue || $2[13] !== multiline || $2[14] !== setValue || $2[15] !== showError || $2[16] !== size || $2[17] !== t2 || $2[18] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(AdvancedTextField, { inputType: t2, label: t5, value: internalValue, multiline, highlight, setValue, disabled, error: showError, size });
    $2[10] = disabled;
    $2[11] = highlight;
    $2[12] = internalValue;
    $2[13] = multiline;
    $2[14] = setValue;
    $2[15] = showError;
    $2[16] = size;
    $2[17] = t2;
    $2[18] = t5;
    $2[19] = t6;
  } else {
    t6 = $2[19];
  }
  let t7;
  if ($2[20] !== propertyKey || $2[21] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyIdCopyTooltip2, { propertyKey, children: t6 });
    $2[20] = propertyKey;
    $2[21] = t6;
    $2[22] = t7;
  } else {
    t7 = $2[22];
  }
  let t8;
  if ($2[23] !== disabled || $2[24] !== error || $2[25] !== includeDescription || $2[26] !== property || $2[27] !== showError) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldHelperText2, { includeDescription, showError, error, disabled, property });
    $2[23] = disabled;
    $2[24] = error;
    $2[25] = includeDescription;
    $2[26] = property;
    $2[27] = showError;
    $2[28] = t8;
  } else {
    t8 = $2[28];
  }
  let t9;
  if ($2[29] !== t7 || $2[30] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t7,
      t8
    ] });
    $2[29] = t7;
    $2[30] = t8;
    $2[31] = t9;
  } else {
    t9 = $2[31];
  }
  return t9;
}, (prevProps, nextProps) => {
  return prevProps.value === nextProps.value && prevProps.error === nextProps.error && prevProps.showError === nextProps.showError && prevProps.disabled === nextProps.disabled && equal(prevProps.property, nextProps.property) && prevProps.highlight === nextProps.highlight;
});
function countStringCharacters$1(values, properties) {
  let count = 0;
  for (const key2 in values) {
    const value = values[key2];
    const property = properties[key2];
    if (property && !property.disabled) {
      if (property.dataType === "string" || property.dataType === "number") {
        count += String(value).length;
      } else if (property.dataType === "array" && Array.isArray(value) && property.of?.dataType === "string") {
        count += value.reduce((acc, curr) => acc + (curr?.length ?? 0), 0);
      } else if (property.dataType === "map" && property.properties && typeof value === "object") {
        count += countStringCharacters$1(value, property.properties);
      }
    }
  }
  return count;
}
function fieldBuilder(params) {
  const {
    fieldConfigId,
    property
  } = params;
  if (property.disabled || property.readOnly || property.Field) {
    return null;
  }
  const wrappedComponent = React$2.useMemo(() => function FieldWrapper(props) {
    const {
      enabled,
      suggestions,
      enhance,
      loadingSuggestions,
      interceptUsage,
      editorAIController
    } = useDataEnhancementController();
    const loading = loadingSuggestions?.includes(props.propertyKey);
    const suggestedValue = suggestions?.[props.propertyKey];
    const filledCharacters = countStringCharacters$1(props.context.values, props.context.collection?.properties ?? {});
    const enoughData = filledCharacters > 5;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FieldInner, { loading, props, suggestedValue, enabled, enoughData, Field: params.Field, enhance, editorAIController, interceptUsage });
  }, []);
  if (SUPPORTED_FIELDS_ENHANCEMENT.includes(fieldConfigId)) {
    return wrappedComponent;
  }
  return null;
}
const FieldInner = React$2.memo(function FieldInner2(t0) {
  const $2 = c_1(46);
  const {
    loading,
    props,
    suggestedValue,
    enabled,
    enoughData,
    Field: Field2,
    enhance,
    interceptUsage,
    editorAIController
  } = t0;
  const [dataLoading, setDataLoading] = useState$2(false);
  const [tooltipOpen, setTooltipOpen] = React$2.useState(false);
  const [menuOpen, setMenuOpen] = React$2.useState(false);
  const [propertyInstructions, setPropertyInstructions] = useState$2();
  if (!enabled) {
    let t12;
    if ($2[0] !== Field2 || $2[1] !== props) {
      t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(Field2, { ...props });
      $2[0] = Field2;
      $2[1] = props;
      $2[2] = t12;
    } else {
      t12 = $2[2];
    }
    return t12;
  }
  const showEnhanceIcon = !props.disabled && (!props.value || props.property.dataType === "string" && (props.property.multiline || props.property.markdown));
  const indexOfSuggestion = props.value && typeof props.value === "string" && typeof suggestedValue === "string" && props.value.endsWith(suggestedValue) ? props.value.indexOf(suggestedValue) + 1 : void 0;
  let t1;
  if ($2[3] !== indexOfSuggestion || $2[4] !== suggestedValue) {
    t1 = indexOfSuggestion && typeof suggestedValue === "string" ? {
      from: indexOfSuggestion,
      to: suggestedValue.length + indexOfSuggestion
    } : void 0;
    $2[3] = indexOfSuggestion;
    $2[4] = suggestedValue;
    $2[5] = t1;
  } else {
    t1 = $2[5];
  }
  const highlightRange = t1;
  let fieldBinding;
  if (props.property.dataType === "string" && props.property.markdown) {
    const t22 = props;
    let t32;
    if ($2[6] !== editorAIController || $2[7] !== interceptUsage) {
      t32 = {
        aiController: editorAIController,
        onDisabledAutocompleteClick: interceptUsage
      };
      $2[6] = editorAIController;
      $2[7] = interceptUsage;
      $2[8] = t32;
    } else {
      t32 = $2[8];
    }
    let t42;
    if ($2[9] !== highlightRange || $2[10] !== t32) {
      t42 = {
        highlight: highlightRange,
        editorProps: t32
      };
      $2[9] = highlightRange;
      $2[10] = t32;
      $2[11] = t42;
    } else {
      t42 = $2[11];
    }
    let t5;
    if ($2[12] !== t22 || $2[13] !== t42) {
      t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(MarkdownEditorFieldBinding2, { ...t22, customProps: t42 });
      $2[12] = t22;
      $2[13] = t42;
      $2[14] = t5;
    } else {
      t5 = $2[14];
    }
    fieldBinding = t5;
  } else {
    if (props.property.dataType === "string" && !props.property.enumValues) {
      const t22 = props;
      const t32 = suggestedValue;
      let t42;
      if ($2[15] !== t22 || $2[16] !== t32) {
        t42 = /* @__PURE__ */ jsxRuntimeExports.jsx(EnhanceTextFieldBinding, { ...t22, highlight: t32 });
        $2[15] = t22;
        $2[16] = t32;
        $2[17] = t42;
      } else {
        t42 = $2[17];
      }
      fieldBinding = t42;
    } else {
      let t22;
      if ($2[18] !== Field2 || $2[19] !== props) {
        t22 = /* @__PURE__ */ jsxRuntimeExports.jsx(Field2, { ...props });
        $2[18] = Field2;
        $2[19] = props;
        $2[20] = t22;
      } else {
        t22 = $2[20];
      }
      fieldBinding = t22;
    }
  }
  let t2;
  if ($2[21] !== enhance || $2[22] !== enoughData || $2[23] !== interceptUsage || $2[24] !== props.context || $2[25] !== props.propertyKey) {
    t2 = (instructions) => {
      if (interceptUsage) {
        interceptUsage();
        return;
      }
      if (!props.context.entityId) {
        return;
      }
      if (!enoughData) {
        return;
      }
      setMenuOpen(false);
      setDataLoading(true);
      return enhance({
        entityId: props.context.entityId,
        propertyKey: props.propertyKey,
        propertyInstructions: instructions,
        values: props.context.values,
        replaceValues: false
      }).finally(() => setDataLoading(false));
    };
    $2[21] = enhance;
    $2[22] = enoughData;
    $2[23] = interceptUsage;
    $2[24] = props.context;
    $2[25] = props.propertyKey;
    $2[26] = t2;
  } else {
    t2 = $2[26];
  }
  const enhanceData = t2;
  const allowInstructions = props.property.dataType === "string" && !props.property.enumValues;
  let t3;
  if ($2[27] !== allowInstructions || $2[28] !== dataLoading || $2[29] !== enhance || $2[30] !== enhanceData || $2[31] !== enoughData || $2[32] !== loading || $2[33] !== menuOpen || $2[34] !== propertyInstructions || $2[35] !== props.context || $2[36] !== props.property.dataType || $2[37] !== props.property.markdown || $2[38] !== props.property.name || $2[39] !== props.propertyKey || $2[40] !== showEnhanceIcon || $2[41] !== tooltipOpen) {
    t3 = showEnhanceIcon && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls$2("dark:bg-surface-700 bg-surface-100 rounded-full absolute right-2 ", props.property.dataType === "string" && props.property.markdown ? "top-0" : "-top-4"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$2, { open: tooltipOpen, onOpenChange: setTooltipOpen, side: "left", asChild: false, title: enoughData ? `Autofill ${props.property.name ?? "this field"}` : `You need to input some data in the form before enhancing ${props.property.name ?? "this field"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Menu$2, { open: menuOpen, onOpenChange: setMenuOpen, trigger: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$2, { size: "small", "aria-label": "Enhance field", disabled: dataLoading || loading, className: enoughData ? "text-surface-900 dark:text-white" : "text-surface-400 dark:text-surface-600", onClick: () => {
      if (!props.context.entityId) {
        return;
      }
      if (!enoughData) {
        return;
      }
      setTooltipOpen(false);
      setDataLoading(true);
      return enhance({
        entityId: props.context.entityId,
        propertyKey: props.propertyKey,
        values: props.context.values,
        replaceValues: false
      }).finally(() => setDataLoading(false));
    }, children: dataLoading || loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress$1, { size: "small" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(AutoAwesomeIcon$1, { size: "small" }) }), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem$2, { onClick: () => enhanceData(), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AutoAwesomeIcon$1, { size: "small" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography$2, { variant: "body2", children: [
            " ",
            `Autofill ${props.property.name ?? "this field"}`
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$2, { variant: "caption", children: "based on the rest of the entity" })
        ] })
      ] }),
      allowInstructions && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$2, { label: "Ask AI to write", size: "small", className: "w-[400px] max-w-full", value: propertyInstructions ?? "", onKeyDown: (e) => {
        if (e.key === "Enter") {
          enhanceData(propertyInstructions);
        }
      }, placeholder: "Instructions", onChange: (e_0) => setPropertyInstructions(e_0.target.value), endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$2, { size: "small", onClick: () => enhanceData(propertyInstructions), disabled: !propertyInstructions, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SendIcon$1, { size: "small" }) }) }) })
    ] }) }) });
    $2[27] = allowInstructions;
    $2[28] = dataLoading;
    $2[29] = enhance;
    $2[30] = enhanceData;
    $2[31] = enoughData;
    $2[32] = loading;
    $2[33] = menuOpen;
    $2[34] = propertyInstructions;
    $2[35] = props.context;
    $2[36] = props.property.dataType;
    $2[37] = props.property.markdown;
    $2[38] = props.property.name;
    $2[39] = props.propertyKey;
    $2[40] = showEnhanceIcon;
    $2[41] = tooltipOpen;
    $2[42] = t3;
  } else {
    t3 = $2[42];
  }
  let t4;
  if ($2[43] !== fieldBinding || $2[44] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
      fieldBinding,
      t3
    ] });
    $2[43] = fieldBinding;
    $2[44] = t3;
    $2[45] = t4;
  } else {
    t4 = $2[45];
  }
  return t4;
}, (prevProps, nextProps) => {
  return prevProps.loading === nextProps.loading && prevProps.suggestedValue === nextProps.suggestedValue && prevProps.enabled === nextProps.enabled && prevProps.props.value === nextProps.props.value && prevProps.props.error === nextProps.props.error && prevProps.props.showError === nextProps.props.showError && prevProps.props.disabled === nextProps.props.disabled && equal(prevProps.props.property, nextProps.props.property) && prevProps.Field === nextProps.Field && prevProps.enoughData === nextProps.enoughData;
});
function countStringCharacters(values, properties) {
  let count = 0;
  for (const key2 in values) {
    const value = values[key2];
    const property = properties[key2];
    if (property && !property.disabled) {
      if (property.dataType === "string" || property.dataType === "number") {
        count += value ? String(value).length : 0;
      } else if (property.dataType === "array" && Array.isArray(value) && property.of?.dataType === "string") {
        count += value.reduce((acc, curr) => acc + (curr?.length ?? 0), 0);
      } else if (property.dataType === "map" && property.properties && typeof value === "object") {
        count += countStringCharacters(value, property.properties);
      }
    }
  }
  return count;
}
const DEFAULT_HEIGHT = 52;
function FormEnhanceAction({
  entityId,
  path,
  status,
  collection: collection2,
  formContext
}) {
  const inputRef = React$2.useRef(null);
  const [internalStatus, setInternalStatus] = React$2.useState(status);
  const storageKey = createLocalStorageKey(path, internalStatus);
  const [loading, setLoading] = React$2.useState(false);
  const dataEnhancementController = useDataEnhancementController();
  const [samplePrompts, setSamplePrompts] = React$2.useState(void 0);
  const [instructions, setInstructions] = React$2.useState("");
  const [height, setHeight] = React$2.useState(DEFAULT_HEIGHT);
  const {
    inputFocused,
    autoCompleteOpen,
    setAutoCompleteOpen
  } = useAutoComplete2({
    ref: inputRef
  });
  const placeholder = useMemo$2(() => getPlaceholder(collection2.singularName ?? collection2.name, samplePrompts), [samplePrompts]);
  const {
    suggestions,
    getSamplePrompts
  } = dataEnhancementController;
  const loadingPrompts = useRef$2(false);
  const updateSuggestedPrompts = useCallback$2(async function updateSuggestedPrompts2(instructions_0) {
    if (loadingPrompts.current) return;
    loadingPrompts.current = true;
    const prompts = internalStatus === "new" ? (await getSamplePrompts(collection2.singularName ?? collection2.name, instructions_0)).prompts : getPromptsForExistingEntities(collection2.properties);
    const recentPromptsFromStorage = getRecentPromptsFromStorage(storageKey);
    const recentPrompts = recentPromptsFromStorage.map((prompt) => prompt.prompt);
    setSamplePrompts([...recentPromptsFromStorage, ...prompts.filter((p) => !recentPrompts.includes(p.prompt))].slice(0, 5));
    loadingPrompts.current = false;
  }, [collection2.name, collection2.singularName, getSamplePrompts, internalStatus]);
  const deferredValues = useDeferredValue$1(formContext?.values);
  const enoughData = countStringCharacters(deferredValues, collection2.properties) > 20;
  useEffect$2(() => {
    if (!samplePrompts) {
      setSamplePrompts(getRecentPromptsFromStorage(storageKey));
      updateSuggestedPrompts().then();
    }
  }, [samplePrompts, storageKey, updateSuggestedPrompts, instructions, internalStatus]);
  useEffect$2(() => {
    updateSuggestedPrompts().then();
  }, [internalStatus]);
  const enhance = (prompt_0) => {
    if (!entityId || !formContext?.values) return;
    setLoading(true);
    setAutoCompleteOpen(false);
    if (prompt_0) {
      addRecentPrompt(storageKey, prompt_0);
      setSamplePrompts([{
        prompt: prompt_0,
        type: "recent"
      }, ...(samplePrompts ?? []).slice(0, 5)]);
    }
    return dataEnhancementController.enhance({
      entityId,
      values: formContext.values,
      instructions: prompt_0,
      replaceValues: true
    }).finally(() => {
      setLoading(false);
    });
  };
  if (!dataEnhancementController?.enabled) return null;
  Object.values(suggestions).filter(Boolean).length > 0;
  (samplePrompts ?? []).length > 0 && instructions.length === 0;
  const noIdSet = !formContext?.entityId;
  function submit() {
    setAutoCompleteOpen(false);
    enhance(instructions);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative w-full", style: {
    height
  }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute flex flex-col items-center w-full font-medium text-sm", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cls$2(defaultBorderMixin2, "border-b", "flex w-full items-center gap-2 pr-4 pl-6", inputFocused ? "text-primary" : "text-surface-700 dark:text-surface-200"), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AutoFixHighIcon$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextareaAutosize$1,
      {
        className: cls$2("flex-grow w-full resize-none w-full outline-none py-5 mx-2 bg-transparent", focusedDisabled2),
        ref: inputRef,
        value: instructions,
        autoFocus: status === "new",
        disabled: loading || noIdSet,
        onResize: (state) => {
          setHeight(state.outerHeightStyle);
        },
        placeholder: noIdSet ? "Please set an ID first" : placeholder?.prompt,
        onClick: () => {
          if (!autoCompleteOpen) setAutoCompleteOpen(true);
        },
        onKeyDown: (e) => {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            submit();
          }
          if (e.key === "Escape" && autoCompleteOpen) {
            setAutoCompleteOpen(false);
            e.preventDefault();
          }
        },
        onChange: (e_0) => {
          if (noIdSet) return;
          setInstructions(e_0.target.value);
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Autocomplete2, { open: autoCompleteOpen, setOpen: setAutoCompleteOpen, children: samplePrompts?.map((samplePrompt, index2) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(AutocompleteItem2, { onClick: () => {
        setInstructions(samplePrompt.prompt);
        enhance(samplePrompt.prompt);
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow", children: samplePrompt.prompt }),
        samplePrompt.type === "recent" && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$2, { onClick: (e_1) => {
          e_1.preventDefault();
          e_1.stopPropagation();
          removeRecentPrompt(storageKey, samplePrompt.prompt);
          setSamplePrompts((samplePrompts ?? []).filter((p_0) => p_0.prompt !== samplePrompt.prompt));
        }, size: "small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon$2, { size: "small" }) })
      ] }, index2 + "_" + samplePrompt.prompt);
    }) }),
    !loading && instructions && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$2, { size: "small", onClick: () => {
      setInstructions("");
      inputRef.current?.focus();
    }, color: inputFocused || !instructions ? "primary" : void 0, disabled: loading, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon$2, { size: "small" }) }),
    (loading || instructions) && /* @__PURE__ */ jsxRuntimeExports.jsxs(IconButton$2, { onClick: () => enhance(instructions), size: "large", color: inputFocused || !instructions ? "primary" : void 0, className: cls$2(!instructions ? "!bg-surface-accent-50 dark:!bg-surface-accent-800" : ""), disabled: loading, children: [
      loading && /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress$1, { size: "small" }),
      !loading && instructions && /* @__PURE__ */ jsxRuntimeExports.jsx(SendIcon$1, { color: "primary" })
    ] }),
    !loading && !instructions && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$2, { asChild: true, title: !enoughData ? "You need to input some data in the form before enhancing this entity, or use the prompt to give specific instructions" : "Try to fill the missing fields. You can use the prompt to give specific instructions", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button$2, { variant: "outlined", size: "small", onClick: () => enhance(), disabled: !enoughData || loading, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AutoFixHighIcon$1, { color: "primary" }),
      "Autofill"
    ] }) })
  ] }) }) });
}
function getPromptsForExistingEntities(properties) {
  const multilineProperties = Object.values(properties).filter((p) => {
    if (isPropertyBuilder2(p)) {
      return false;
    }
    return p.dataType === "string" && (p.markdown || p.multiline);
  });
  const multilinePrompt = multilineProperties.length > 0 ? multilineProperties[Math.floor(Math.random() * multilineProperties.length)] : void 0;
  const prompts = ["Fill the missing fields", "Translate the missing content"];
  if (multilinePrompt) {
    prompts.push(`Add 2 paragraphs to '${multilinePrompt.name}'`);
  }
  return prompts.map((p) => ({
    prompt: p,
    type: "sample"
  }));
}
function getPlaceholder(name, prompts) {
  const samplePrompts = (prompts ?? []).length > 0 ? prompts : ["e.g. I want to generate a new document about...", "e.g. Add a paragraph to the description", `e.g. Generate a new ${singular2(name)} related to...`].map((p) => ({
    prompt: p,
    type: "sample"
  }));
  return samplePrompts[Math.floor(Math.random() * samplePrompts.length)];
}
const createLocalStorageKey = (path, status) => {
  const statusString = status === "new" ? "new" : "existing";
  return `data_enhancement::${statusString}::${stripCollectionPath2(path)}`;
};
const getRecentPromptsFromStorage = (storageKey) => {
  const item = localStorage.getItem(storageKey);
  return item ? JSON.parse(item).map((e) => ({
    prompt: e,
    type: "recent"
  })) : [];
};
const addRecentPrompt = (storageKey, prompt) => {
  if (!prompt || prompt.trim().length === 0) {
    return;
  }
  const recentPrompts = getRecentPromptsFromStorage(storageKey);
  localStorage.setItem(storageKey, JSON.stringify([prompt, ...recentPrompts.map((e) => e.prompt).filter((e) => e !== prompt).slice(0, 5)]));
};
const removeRecentPrompt = (storageKey, prompt) => {
  localStorage.setItem(storageKey, JSON.stringify(getRecentPromptsFromStorage(storageKey).map((e) => e.prompt).filter((e) => e !== prompt)));
};
const DEFAULT_API_KEY = "fcms-U9jdDii0xXWSDC34asfrf54lbkFJBfKfRWcEDEwdc4V5wDWEDF";
function useDataEnhancementPlugin(props) {
  const apiKey = props?.apiKey ?? DEFAULT_API_KEY;
  const getConfigForPath = props?.getConfigForPath;
  const authController = useAuthController$1();
  const fieldBuilderEnabled = useCallback$2((params) => {
    if (!getConfigForPath) return true;
    if (!params.path || !params.collection) return false;
    return getConfigForPath({
      path: params.path,
      collection: params.collection,
      user: authController.user
    });
  }, [getConfigForPath, authController.user?.uid]);
  return {
    key: "data_enhancement",
    form: {
      Actions: FormEnhanceAction,
      provider: {
        Component: DataEnhancementControllerProvider,
        props: {
          apiKey,
          getConfigForPath,
          interceptUsage: props?.interceptUsage,
          SubscriptionMessage: props?.SubscriptionMessage,
          host: props?.host
        }
      },
      fieldBuilder,
      fieldBuilderEnabled
    },
    homePage: {
      // CollectionActions: EnhanceCollectionIcon,
      extraProps: {
        getConfigForPath
      }
    }
    // loading: configController.loading,
  };
}
function _defineProperty$1(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function ownKeys$1(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source2 = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$1(Object(source2), true).forEach(function(key2) {
        _defineProperty$1(target, key2, source2[key2]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys$1(Object(source2)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
      });
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source2, excluded) {
  if (source2 == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source2);
  var key2, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key2 = sourceKeys[i];
    if (excluded.indexOf(key2) >= 0) continue;
    target[key2] = source2[key2];
  }
  return target;
}
function _objectWithoutProperties(source2, excluded) {
  if (source2 == null) return {};
  var target = _objectWithoutPropertiesLoose(source2, excluded);
  var key2, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source2);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key2 = sourceSymbolKeys[i];
      if (excluded.indexOf(key2) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source2, key2)) continue;
      target[key2] = source2[key2];
    }
  }
  return target;
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e2 = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e2;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _defineProperty(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source2 = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source2), true).forEach(function(key2) {
        _defineProperty(target, key2, source2[key2]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys(Object(source2)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
      });
    }
  }
  return target;
}
function compose$1() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  return function(x) {
    return fns.reduceRight(function(y, f) {
      return f(y);
    }, x);
  };
}
function curry$1(fn) {
  return function curried() {
    var _this = this;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return args.length >= fn.length ? fn.apply(this, args) : function() {
      for (var _len3 = arguments.length, nextArgs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        nextArgs[_key3] = arguments[_key3];
      }
      return curried.apply(_this, [].concat(args, nextArgs));
    };
  };
}
function isObject$1(value) {
  return {}.toString.call(value).includes("Object");
}
function isEmpty(obj) {
  return !Object.keys(obj).length;
}
function isFunction(value) {
  return typeof value === "function";
}
function hasOwnProperty(object, property) {
  return Object.prototype.hasOwnProperty.call(object, property);
}
function validateChanges(initial, changes) {
  if (!isObject$1(changes)) errorHandler$1("changeType");
  if (Object.keys(changes).some(function(field) {
    return !hasOwnProperty(initial, field);
  })) errorHandler$1("changeField");
  return changes;
}
function validateSelector(selector) {
  if (!isFunction(selector)) errorHandler$1("selectorType");
}
function validateHandler(handler) {
  if (!(isFunction(handler) || isObject$1(handler))) errorHandler$1("handlerType");
  if (isObject$1(handler) && Object.values(handler).some(function(_handler) {
    return !isFunction(_handler);
  })) errorHandler$1("handlersType");
}
function validateInitial(initial) {
  if (!initial) errorHandler$1("initialIsRequired");
  if (!isObject$1(initial)) errorHandler$1("initialType");
  if (isEmpty(initial)) errorHandler$1("initialContent");
}
function throwError$1(errorMessages2, type) {
  throw new Error(errorMessages2[type] || errorMessages2["default"]);
}
var errorMessages$1 = {
  initialIsRequired: "initial state is required",
  initialType: "initial state should be an object",
  initialContent: "initial state shouldn't be an empty object",
  handlerType: "handler should be an object or a function",
  handlersType: "all handlers should be a functions",
  selectorType: "selector should be a function",
  changeType: "provided value of changes should be an object",
  changeField: 'it seams you want to change a field in the state which is not specified in the "initial" state',
  "default": "an unknown error accured in `state-local` package"
};
var errorHandler$1 = curry$1(throwError$1)(errorMessages$1);
var validators$1 = {
  changes: validateChanges,
  selector: validateSelector,
  handler: validateHandler,
  initial: validateInitial
};
function create(initial) {
  var handler = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  validators$1.initial(initial);
  validators$1.handler(handler);
  var state = {
    current: initial
  };
  var didUpdate = curry$1(didStateUpdate)(state, handler);
  var update = curry$1(updateState)(state);
  var validate = curry$1(validators$1.changes)(initial);
  var getChanges = curry$1(extractChanges)(state);
  function getState2() {
    var selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function(state2) {
      return state2;
    };
    validators$1.selector(selector);
    return selector(state.current);
  }
  function setState2(causedChanges) {
    compose$1(didUpdate, update, validate, getChanges)(causedChanges);
  }
  return [getState2, setState2];
}
function extractChanges(state, causedChanges) {
  return isFunction(causedChanges) ? causedChanges(state.current) : causedChanges;
}
function updateState(state, changes) {
  state.current = _objectSpread2(_objectSpread2({}, state.current), changes);
  return changes;
}
function didStateUpdate(state, handler, changes) {
  isFunction(handler) ? handler(state.current) : Object.keys(changes).forEach(function(field) {
    var _handler$field;
    return (_handler$field = handler[field]) === null || _handler$field === void 0 ? void 0 : _handler$field.call(handler, state.current[field]);
  });
  return changes;
}
var index = {
  create
};
var config$1 = {
  paths: {
    vs: "https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs"
  }
};
function curry(fn) {
  return function curried() {
    var _this = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return args.length >= fn.length ? fn.apply(this, args) : function() {
      for (var _len2 = arguments.length, nextArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        nextArgs[_key2] = arguments[_key2];
      }
      return curried.apply(_this, [].concat(args, nextArgs));
    };
  };
}
function isObject2(value) {
  return {}.toString.call(value).includes("Object");
}
function validateConfig(config2) {
  if (!config2) errorHandler("configIsRequired");
  if (!isObject2(config2)) errorHandler("configType");
  if (config2.urls) {
    informAboutDeprecation();
    return {
      paths: {
        vs: config2.urls.monacoBase
      }
    };
  }
  return config2;
}
function informAboutDeprecation() {
  console.warn(errorMessages.deprecation);
}
function throwError(errorMessages2, type) {
  throw new Error(errorMessages2[type] || errorMessages2["default"]);
}
var errorMessages = {
  configIsRequired: "the configuration object is required",
  configType: "the configuration object should be an object",
  "default": "an unknown error accured in `@monaco-editor/loader` package",
  deprecation: "Deprecation warning!\n    You are using deprecated way of configuration.\n\n    Instead of using\n      monaco.config({ urls: { monacoBase: '...' } })\n    use\n      monaco.config({ paths: { vs: '...' } })\n\n    For more please check the link https://github.com/suren-atoyan/monaco-loader#config\n  "
};
var errorHandler = curry(throwError)(errorMessages);
var validators = {
  config: validateConfig
};
var compose = function compose2() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  return function(x) {
    return fns.reduceRight(function(y, f) {
      return f(y);
    }, x);
  };
};
function merge(target, source2) {
  Object.keys(source2).forEach(function(key2) {
    if (source2[key2] instanceof Object) {
      if (target[key2]) {
        Object.assign(source2[key2], merge(target[key2], source2[key2]));
      }
    }
  });
  return _objectSpread2$1(_objectSpread2$1({}, target), source2);
}
var CANCELATION_MESSAGE = {
  type: "cancelation",
  msg: "operation is manually canceled"
};
function makeCancelable(promise) {
  var hasCanceled_ = false;
  var wrappedPromise = new Promise(function(resolve, reject) {
    promise.then(function(val) {
      return hasCanceled_ ? reject(CANCELATION_MESSAGE) : resolve(val);
    });
    promise["catch"](reject);
  });
  return wrappedPromise.cancel = function() {
    return hasCanceled_ = true;
  }, wrappedPromise;
}
var _state$create = index.create({
  config: config$1,
  isInitialized: false,
  resolve: null,
  reject: null,
  monaco: null
}), _state$create2 = _slicedToArray(_state$create, 2), getState = _state$create2[0], setState = _state$create2[1];
function config(globalConfig) {
  var _validators$config = validators.config(globalConfig), monaco = _validators$config.monaco, config2 = _objectWithoutProperties(_validators$config, ["monaco"]);
  setState(function(state) {
    return {
      config: merge(state.config, config2),
      monaco
    };
  });
}
function init() {
  var state = getState(function(_ref) {
    var monaco = _ref.monaco, isInitialized = _ref.isInitialized, resolve = _ref.resolve;
    return {
      monaco,
      isInitialized,
      resolve
    };
  });
  if (!state.isInitialized) {
    setState({
      isInitialized: true
    });
    if (state.monaco) {
      state.resolve(state.monaco);
      return makeCancelable(wrapperPromise);
    }
    if (window.monaco && window.monaco.editor) {
      storeMonacoInstance(window.monaco);
      state.resolve(window.monaco);
      return makeCancelable(wrapperPromise);
    }
    compose(injectScripts, getMonacoLoaderScript)(configureLoader);
  }
  return makeCancelable(wrapperPromise);
}
function injectScripts(script) {
  return document.body.appendChild(script);
}
function createScript(src) {
  var script = document.createElement("script");
  return src && (script.src = src), script;
}
function getMonacoLoaderScript(configureLoader2) {
  var state = getState(function(_ref2) {
    var config2 = _ref2.config, reject = _ref2.reject;
    return {
      config: config2,
      reject
    };
  });
  var loaderScript = createScript("".concat(state.config.paths.vs, "/loader.js"));
  loaderScript.onload = function() {
    return configureLoader2();
  };
  loaderScript.onerror = state.reject;
  return loaderScript;
}
function configureLoader() {
  var state = getState(function(_ref3) {
    var config2 = _ref3.config, resolve = _ref3.resolve, reject = _ref3.reject;
    return {
      config: config2,
      resolve,
      reject
    };
  });
  var require2 = window.require;
  require2.config(state.config);
  require2(["vs/editor/editor.main"], function(monaco) {
    storeMonacoInstance(monaco);
    state.resolve(monaco);
  }, function(error) {
    state.reject(error);
  });
}
function storeMonacoInstance(monaco) {
  if (!getState().monaco) {
    setState({
      monaco
    });
  }
}
function __getMonacoInstance() {
  return getState(function(_ref4) {
    var monaco = _ref4.monaco;
    return monaco;
  });
}
var wrapperPromise = new Promise(function(resolve, reject) {
  return setState({
    resolve,
    reject
  });
});
var loader = {
  config,
  init,
  __getMonacoInstance
};
const { memo: Te } = await importShared("react");
const ke = await importShared("react");
const { useState: re, useRef: S, useCallback: oe, useEffect: ne } = ke;
const { memo: ye } = await importShared("react");
const K = await importShared("react");
var le = { wrapper: { display: "flex", position: "relative", textAlign: "initial" }, fullWidth: { width: "100%" }, hide: { display: "none" } }, v = le;
const me = await importShared("react");
var ae = { container: { display: "flex", height: "100%", width: "100%", justifyContent: "center", alignItems: "center" } }, Y = ae;
function Me({ children: e }) {
  return me.createElement("div", { style: Y.container }, e);
}
var Z = Me;
var $$1 = Z;
function Ee({ width: e, height: r, isEditorReady: n, loading: t, _ref: a, className: m, wrapperProps: E }) {
  return K.createElement("section", { style: { ...v.wrapper, width: e, height: r }, ...E }, !n && K.createElement($$1, null, t), K.createElement("div", { ref: a, style: { ...v.fullWidth, ...!n && v.hide }, className: m }));
}
var ee = Ee;
var H = ye(ee);
const { useEffect: xe } = await importShared("react");
function Ce(e) {
  xe(e, []);
}
var k = Ce;
const { useEffect: ge, useRef: Re } = await importShared("react");
function he(e, r, n = true) {
  let t = Re(true);
  ge(t.current || !n ? () => {
    t.current = false;
  } : e, r);
}
var l = he;
function D() {
}
function h(e, r, n, t) {
  return De(e, t) || be(e, r, n, t);
}
function De(e, r) {
  return e.editor.getModel(te(e, r));
}
function be(e, r, n, t) {
  return e.editor.createModel(r, n, t ? te(e, t) : void 0);
}
function te(e, r) {
  return e.Uri.parse(r);
}
function Oe({ original: e, modified: r, language: n, originalLanguage: t, modifiedLanguage: a, originalModelPath: m, modifiedModelPath: E, keepCurrentOriginalModel: g = false, keepCurrentModifiedModel: N = false, theme: x = "light", loading: P = "Loading...", options: y = {}, height: V = "100%", width: z = "100%", className: F, wrapperProps: j = {}, beforeMount: A = D, onMount: q = D }) {
  let [M, O] = re(false), [T, s] = re(true), u = S(null), c2 = S(null), w = S(null), d = S(q), o = S(A), b = S(false);
  k(() => {
    let i = loader.init();
    return i.then((f) => (c2.current = f) && s(false)).catch((f) => f?.type !== "cancelation" && console.error("Monaco initialization: error:", f)), () => u.current ? I() : i.cancel();
  }), l(() => {
    if (u.current && c2.current) {
      let i = u.current.getOriginalEditor(), f = h(c2.current, e || "", t || n || "text", m || "");
      f !== i.getModel() && i.setModel(f);
    }
  }, [m], M), l(() => {
    if (u.current && c2.current) {
      let i = u.current.getModifiedEditor(), f = h(c2.current, r || "", a || n || "text", E || "");
      f !== i.getModel() && i.setModel(f);
    }
  }, [E], M), l(() => {
    let i = u.current.getModifiedEditor();
    i.getOption(c2.current.editor.EditorOption.readOnly) ? i.setValue(r || "") : r !== i.getValue() && (i.executeEdits("", [{ range: i.getModel().getFullModelRange(), text: r || "", forceMoveMarkers: true }]), i.pushUndoStop());
  }, [r], M), l(() => {
    u.current?.getModel()?.original.setValue(e || "");
  }, [e], M), l(() => {
    let { original: i, modified: f } = u.current.getModel();
    c2.current.editor.setModelLanguage(i, t || n || "text"), c2.current.editor.setModelLanguage(f, a || n || "text");
  }, [n, t, a], M), l(() => {
    c2.current?.editor.setTheme(x);
  }, [x], M), l(() => {
    u.current?.updateOptions(y);
  }, [y], M);
  let L = oe(() => {
    if (!c2.current) return;
    o.current(c2.current);
    let i = h(c2.current, e || "", t || n || "text", m || ""), f = h(c2.current, r || "", a || n || "text", E || "");
    u.current?.setModel({ original: i, modified: f });
  }, [n, r, a, e, t, m, E]), U = oe(() => {
    !b.current && w.current && (u.current = c2.current.editor.createDiffEditor(w.current, { automaticLayout: true, ...y }), L(), c2.current?.editor.setTheme(x), O(true), b.current = true);
  }, [y, x, L]);
  ne(() => {
    M && d.current(u.current, c2.current);
  }, [M]), ne(() => {
    !T && !M && U();
  }, [T, M, U]);
  function I() {
    let i = u.current?.getModel();
    g || i?.original?.dispose(), N || i?.modified?.dispose(), u.current?.dispose();
  }
  return ke.createElement(H, { width: z, height: V, isEditorReady: M, loading: P, _ref: w, className: F, wrapperProps: j });
}
var ie = Oe;
Te(ie);
await importShared("react");
const { memo: ze } = await importShared("react");
const We = await importShared("react");
const { useState: ue, useEffect: W, useRef: C, useCallback: _e } = We;
const { useEffect: Ue, useRef: ve } = await importShared("react");
function He(e) {
  let r = ve();
  return Ue(() => {
    r.current = e;
  }, [e]), r.current;
}
var se = He;
var _ = /* @__PURE__ */ new Map();
function Ve({ defaultValue: e, defaultLanguage: r, defaultPath: n, value: t, language: a, path: m, theme: E = "light", line: g, loading: N = "Loading...", options: x = {}, overrideServices: P = {}, saveViewState: y = true, keepCurrentModel: V = false, width: z = "100%", height: F = "100%", className: j, wrapperProps: A = {}, beforeMount: q = D, onMount: M = D, onChange: O, onValidate: T = D }) {
  let [s, u] = ue(false), [c2, w] = ue(true), d = C(null), o = C(null), b = C(null), L = C(M), U = C(q), I = C(), i = C(t), f = se(m), Q = C(false), B = C(false);
  k(() => {
    let p = loader.init();
    return p.then((R) => (d.current = R) && w(false)).catch((R) => R?.type !== "cancelation" && console.error("Monaco initialization: error:", R)), () => o.current ? pe() : p.cancel();
  }), l(() => {
    let p = h(d.current, e || t || "", r || a || "", m || n || "");
    p !== o.current?.getModel() && (y && _.set(f, o.current?.saveViewState()), o.current?.setModel(p), y && o.current?.restoreViewState(_.get(m)));
  }, [m], s), l(() => {
    o.current?.updateOptions(x);
  }, [x], s), l(() => {
    !o.current || t === void 0 || (o.current.getOption(d.current.editor.EditorOption.readOnly) ? o.current.setValue(t) : t !== o.current.getValue() && (B.current = true, o.current.executeEdits("", [{ range: o.current.getModel().getFullModelRange(), text: t, forceMoveMarkers: true }]), o.current.pushUndoStop(), B.current = false));
  }, [t], s), l(() => {
    let p = o.current?.getModel();
    p && a && d.current?.editor.setModelLanguage(p, a);
  }, [a], s), l(() => {
    g !== void 0 && o.current?.revealLine(g);
  }, [g], s), l(() => {
    d.current?.editor.setTheme(E);
  }, [E], s);
  let X = _e(() => {
    if (!(!b.current || !d.current) && !Q.current) {
      U.current(d.current);
      let p = m || n, R = h(d.current, t || e || "", r || a || "", p || "");
      o.current = d.current?.editor.create(b.current, { model: R, automaticLayout: true, ...x }, P), y && o.current.restoreViewState(_.get(p)), d.current.editor.setTheme(E), g !== void 0 && o.current.revealLine(g), u(true), Q.current = true;
    }
  }, [e, r, n, t, a, m, x, P, y, E, g]);
  W(() => {
    s && L.current(o.current, d.current);
  }, [s]), W(() => {
    !c2 && !s && X();
  }, [c2, s, X]), i.current = t, W(() => {
    s && O && (I.current?.dispose(), I.current = o.current?.onDidChangeModelContent((p) => {
      B.current || O(o.current.getValue(), p);
    }));
  }, [s, O]), W(() => {
    if (s) {
      let p = d.current.editor.onDidChangeMarkers((R) => {
        let G = o.current.getModel()?.uri;
        if (G && R.find((J) => J.path === G.path)) {
          let J = d.current.editor.getModelMarkers({ resource: G });
          T?.(J);
        }
      });
      return () => {
        p?.dispose();
      };
    }
    return () => {
    };
  }, [s, T]);
  function pe() {
    I.current?.dispose(), V ? y && _.set(m, o.current.saveViewState()) : o.current.getModel()?.dispose(), o.current.dispose();
  }
  return We.createElement(H, { width: z, height: F, isEditorReady: s, loading: N, _ref: b, className: j, wrapperProps: A });
}
var fe = Ve;
var de = ze(fe);
var Ft = de;
const React$1 = await importShared("react");
const { useState: useState$1, useEffect: useEffect$1, useCallback: useCallback$1, useContext: useContext$1, useRef: useRef$1, useMemo: useMemo$1 } = React$1;
const { useModeController: useModeController2, useNavigationController: useNavigationController$1, useCustomizationController: useCustomizationController$1, resolveCollection: resolveCollection2, useSelectionController: useSelectionController2, EntityCollectionTable: EntityCollectionTable2, EntityCollectionRowActions: EntityCollectionRowActions2, copyEntityAction: copyEntityAction2, deleteEntityAction: deleteEntityAction2, editEntityAction: editEntityAction2, CircularProgressCenter: CircularProgressCenter$1, randomString: randomString2, useApp: useApp$1 } = await importShared("@firecms/core");
const firestoreLibrary = await importShared("@firebase/firestore");
const { getFirestore: getFirestore$1, doc: doc$1, collection: collection$1, setDoc: setDoc$1, onSnapshot: onSnapshot$1, query: query$1, orderBy: orderBy$1, limit, Timestamp } = await importShared("@firebase/firestore");
const { Typography: Typography$1, useDebounceValue: useDebounceValue2, Button: Button$1, cls: cls$1, Paper: Paper$1, Skeleton: Skeleton2, Tooltip: Tooltip$1, IconButton: IconButton$1, LoopIcon: LoopIcon2, CheckIcon: CheckIcon2, ContentCopyIcon: ContentCopyIcon2, ThumbDownOffAltIcon: ThumbDownOffAltIcon2, Dialog: Dialog$1, DialogTitle: DialogTitle$1, DialogContent: DialogContent$1, TextField: TextField$1, DialogActions: DialogActions2, CloseIcon: CloseIcon$1, Label: Label$1, Menu: Menu$1, Avatar: Avatar2, PersonIcon: PersonIcon2, AutoFixHighIcon: AutoFixHighIcon2, MenuItem: MenuItem$1, Alert: Alert$1, Card: Card$1, Checkbox: Checkbox$1, TextareaAutosize: TextareaAutosize2, SendIcon: SendIcon2, ManageSearchIcon: ManageSearchIcon2 } = await importShared("@firecms/ui");
const { firestoreToCMSModel: firestoreToCMSModel2, cmsToFirestoreModel: cmsToFirestoreModel2 } = await importShared("@firecms/firebase");
async function streamDataTalkCommand(firebaseAccessToken, command, apiEndpoint, sessionId, messages, onDelta) {
  return new Promise(async (resolve, reject) => {
    try {
      const response = await fetch(apiEndpoint + "/datatalk/command", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${firebaseAccessToken}`
        },
        body: JSON.stringify({
          sessionId,
          command,
          history: messages
        })
      });
      if (!response.ok) {
        const data = await response.json();
        console.error("Error streaming data talk command", data);
        reject(new ApiError$1(data.message, data.code));
        return;
      }
      if (response.body) {
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer2 = "";
        let result = "";
        const processChunk = (chunk) => {
          if (chunk.done) {
            console.debug("Stream completed", { result });
            resolve(result);
            return;
          }
          const text = decoder.decode(chunk.value, { stream: true });
          buffer2 += text;
          const parts = buffer2.split("&$# ").filter((part) => part.length > 0);
          if (!text.endsWith("&$# ")) {
            buffer2 = parts.pop() || "";
          } else {
            buffer2 = "";
          }
          parts.forEach((part) => {
            try {
              const message = JSON.parse(part);
              if (message.type === "delta") {
                result += message.data.delta;
                onDelta(message.data.delta);
              } else if (message.type === "result") {
                console.debug("Result received:", message.data);
                resolve(message.data.text);
              }
            } catch (error) {
              console.error("Error parsing message part:", part, error);
            }
          });
          reader.read().then(processChunk);
        };
        reader.read().then(processChunk);
      }
    } catch (error) {
      console.error("Error streaming data talk command", error);
      reject(error);
    }
  });
}
function getDataTalkSamplePrompts(firebaseAccessToken, apiEndpoint, messages) {
  return fetch(apiEndpoint + "/datatalk/sample_prompts", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${firebaseAccessToken}`
    },
    body: JSON.stringify({
      history: []
    })
  }).then((response) => {
    if (!response.ok) {
      return response.json().then((data) => {
        throw new ApiError$1(data.message, data.code);
      });
    }
    return response.json();
  }).then((data) => data.data);
}
let ApiError$1 = class ApiError extends Error {
  code;
  constructor(message, code) {
    super(message);
    this.code = code;
  }
};
const DataTalkConfigContext = React$1.createContext({});
function useBuildDataTalkConfig({
  enabled,
  firebaseApp,
  userSessionsPath,
  getAuthToken,
  apiEndpoint
}) {
  const [loading, setLoading] = useState$1(true);
  const [sessions, setSessions] = useState$1([]);
  const [samplePrompts, setSamplePrompts] = useState$1([]);
  useEffect$1(() => {
    if (!enabled) return;
    getAuthToken().then((firebaseToken) => {
      getDataTalkSamplePrompts(firebaseToken, apiEndpoint).then(setSamplePrompts);
    });
  }, []);
  const createSessionId = useCallback$1(async () => {
    if (!firebaseApp) throw Error("useBuildDataTalkConfig Firebase not initialised");
    const firestore = getFirestore$1(firebaseApp);
    if (!firestore || !userSessionsPath) throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    return doc$1(collection$1(firestore, userSessionsPath)).id;
  }, [firebaseApp, userSessionsPath]);
  const saveSession = useCallback$1(async (session) => {
    if (!firebaseApp) throw Error("useBuildDataTalkConfig Firebase not initialised");
    const firestore = getFirestore$1(firebaseApp);
    if (!firestore || !userSessionsPath) throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    const {
      id,
      ...sessionData
    } = session;
    const sessionDoc = doc$1(firestore, userSessionsPath, id);
    return setDoc$1(sessionDoc, sessionData);
  }, [firebaseApp, userSessionsPath]);
  const getSession = useCallback$1(async (sessionId) => {
    return sessions.find((s) => s.id === sessionId);
  }, [sessions]);
  useEffect$1(() => {
    if (!enabled) return;
    if (!firebaseApp) throw Error("useBuildDataTalkConfig Firebase not initialised");
    const firestore = getFirestore$1(firebaseApp);
    if (!firestore || !userSessionsPath) return;
    return onSnapshot$1(
      query$1(
        collection$1(firestore, userSessionsPath).withConverter(timestampToDateConverter),
        orderBy$1("created_at", "desc"),
        limit(50)
      ),
      {
        next: (snapshot) => {
          const updatedSessions = snapshot.docs.map((doc2) => {
            return {
              id: doc2.id,
              ...doc2.data()
            };
          });
          setSessions(updatedSessions);
          setLoading(false);
        },
        error: (e) => {
          console.error(e);
        }
      }
    );
  }, [firebaseApp, userSessionsPath]);
  return {
    loading,
    sessions,
    saveSession,
    getSession,
    createSessionId,
    rootPromptsSuggestions: samplePrompts
  };
}
const useDataTalk = () => useContext$1(DataTalkConfigContext);
function DataTalkProvider({
  config: config2,
  children
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DataTalkConfigContext.Provider, { value: config2, children });
}
const timestampToDateConverter = {
  toFirestore(data) {
    return data;
  },
  fromFirestore(snapshot, options) {
    const data = snapshot.data(options);
    return convertTimestamps(data);
  }
};
function convertTimestamps(data) {
  if (data instanceof Timestamp) {
    return data.toDate();
  } else if (Array.isArray(data)) {
    return data.map((item) => convertTimestamps(item));
  } else if (data !== null && typeof data === "object") {
    for (const key2 in data) {
      data[key2] = convertTimestamps(data[key2]);
    }
    return data;
  }
  return data;
}
const md = new MarkdownIt({ html: true });
function parseMarkdown(text) {
  const elements = [];
  const lines = text.split(/\r?\n/);
  let buffer2 = [];
  let inCodeBlock = false;
  for (const line2 of lines) {
    if (line2.trim().startsWith("```javascript") || line2.startsWith("```") && !inCodeBlock) {
      if (buffer2.length) {
        elements.push({
          type: "html",
          content: md.render(buffer2.join("\n"))
        });
        buffer2 = [];
      }
      inCodeBlock = true;
      continue;
    } else if (line2.trim().startsWith("```") && inCodeBlock) {
      elements.push({
        type: "code",
        content: buffer2.join("\n")
      });
      buffer2 = [];
      inCodeBlock = false;
      continue;
    }
    buffer2.push(line2);
  }
  if (buffer2.length) {
    elements.push({
      type: inCodeBlock ? "code" : "html",
      content: inCodeBlock ? buffer2.join("\n") : md.render(buffer2.join("\n"))
    });
  }
  return elements;
}
function AutoHeightEditor({
  value,
  onChange,
  maxWidth,
  loading,
  ...props
}) {
  const editorRef = useRef$1(null);
  function handleEditorDidMount(editor, monaco) {
    editorRef.current = editor;
  }
  const { mode } = useModeController2();
  const lines = (value ?? "").split("\n").length;
  const height = Math.max(lines * 18, 72) + 4;
  useEffect$1(() => {
    if (editorRef.current && maxWidth) {
      editorRef.current.layout({
        width: maxWidth,
        height
      });
    }
  }, [maxWidth, height]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Ft,
    {
      height: height + "px",
      theme: mode === "dark" ? "vs-dark" : "light",
      className: "rounded-lg flex-1 border dark:border-surface-800",
      defaultLanguage: "javascript",
      value,
      onChange,
      onMount: handleEditorDidMount,
      options: {
        scrollBeyondLastLine: false,
        minimap: { enabled: false },
        readOnly: loading,
        // automaticLayout: true,
        scrollbar: {
          vertical: "hidden",
          alwaysConsumeMouseWheel: false
        }
      },
      ...props
    }
  );
}
function extractStringLiterals(code) {
  const regex = /["']([^"']+)["']/g;
  let match;
  const literals = [];
  while ((match = regex.exec(code)) !== null) {
    literals.push(match[1]);
  }
  return literals;
}
function TableResults({
  querySnapshot,
  priorityKeys,
  collections
}) {
  const navigation = useNavigationController$1();
  const customizationController = useCustomizationController$1();
  async function inferProperties() {
    if (querySnapshot.docs.length === 0) {
      return;
    }
    const pathAndId = querySnapshot.docs[0].ref.path;
    const resultsPath = pathAndId.split("/").slice(0, -1).join("/");
    let foundProperties = null;
    let foundPropertiesOrder;
    const entities = querySnapshot.docs.map((doc2) => ({
      id: doc2.id,
      path: doc2.ref.path,
      values: firestoreToCMSModel2(doc2.data())
    }));
    setPath(resultsPath);
    if (resultsPath) {
      const collection22 = navigation.getCollection(resultsPath, true);
      setCollection(collection22);
      if (collection22) {
        foundPropertiesOrder = collection22.propertiesOrder;
      }
    }
    const docs = querySnapshot.docs.map((doc2) => doc2.data());
    foundProperties = await getPropertiesFromData(docs);
    foundPropertiesOrder = buildPropertiesOrder(foundProperties, foundPropertiesOrder, priorityKeys);
    setQueryResults(entities);
    setProperties(foundProperties);
    setPropertiesOrder(foundPropertiesOrder);
  }
  useEffect$1(() => {
    inferProperties();
  }, []);
  const [queryResults, setQueryResults] = useState$1(null);
  const [properties, setProperties] = useState$1(null);
  const [propertiesOrder, setPropertiesOrder] = useState$1(null);
  const [path, setPath] = useState$1(null);
  const [collection2, setCollection] = useState$1();
  const resolvedCollection = useMemo$1(() => {
    return collection2 && path ? resolveCollection2({
      collection: collection2,
      path,
      propertyConfigs: customizationController.propertyConfigs
    }) : void 0;
  }, [collection2, path]);
  const selectionController = useSelectionController2();
  const displayedColumnIds = (propertiesOrder ?? Object.keys(properties ?? {})).map((key2) => ({
    key: key2,
    disabled: false
  }));
  const onValueChange = ({
    value,
    propertyKey,
    onValueUpdated,
    setError,
    data: entity
  }) => {
    const updatedValues = setIn({ ...entity.values }, propertyKey, value);
    const firestore = getFirestore$1();
    const firebaseValues = cmsToFirestoreModel2(updatedValues, firestore);
    const documentReference = doc$1(firestore, entity.path);
    return setDoc$1(documentReference, firebaseValues, { merge: true }).then((res) => {
      onValueUpdated();
    }).catch((error) => {
      console.error("Error updating document", error);
      setError(error);
    });
  };
  if (!queryResults || !properties) return null;
  const getActionsForEntity = ({
    entity,
    customEntityActions
  }) => {
    const actions = [editEntityAction2];
    actions.push(copyEntityAction2);
    actions.push(deleteEntityAction2);
    if (customEntityActions)
      actions.push(...customEntityActions);
    return actions;
  };
  const tableRowActionsBuilder = ({
    entity,
    size,
    width,
    frozen
  }) => {
    const actions = getActionsForEntity({
      entity,
      customEntityActions: resolvedCollection?.entityActions
    });
    const path2 = entity.path.split("/").slice(0, -1).join("/");
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      EntityCollectionRowActions2,
      {
        entity,
        width,
        frozen,
        selectionEnabled: false,
        size,
        collection: resolvedCollection ?? void 0,
        fullPath: path2,
        actions,
        hideId: resolvedCollection?.hideIdFromCollection
      }
    );
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    EntityCollectionTable2,
    {
      inlineEditing: true,
      defaultSize: "s",
      selectionController,
      onValueChange,
      filterable: false,
      actionsStart: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Typography$1,
        {
          variant: "caption",
          children: [
            (queryResults ?? []).length,
            " results"
          ]
        }
      ),
      actions: /* @__PURE__ */ jsxRuntimeExports.jsx(
        BasicExportAction,
        {
          data: queryResults,
          properties,
          propertiesOrder: propertiesOrder ?? void 0
        }
      ),
      enablePopupIcon: false,
      sortable: false,
      tableRowActionsBuilder,
      tableController: {
        data: queryResults,
        dataLoading: false,
        noMoreToLoad: true
      },
      displayedColumnIds,
      properties
    }
  );
}
window.firestoreLibrary = firestoreLibrary;
function ExecutionErrorView(props) {
  const message = props.executionError.message;
  const urlRegex = /https?:\/\/[^\s]+/g;
  const htmlContent = message.replace(urlRegex, (url) => {
    return `<a href="${url}" target="_blank" class="underline">LINK</a><br/>`;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full text-sm bg-red-100 dark:bg-red-800 p-4 rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx("code", { className: "text-red-700 dark:text-red-300 break-all", dangerouslySetInnerHTML: { __html: htmlContent } }) });
}
function CodeBlock({
  initialCode,
  maxWidth,
  loading,
  sourceLoading,
  onCodeModified,
  autoRunCode,
  onCodeRun,
  collections
}) {
  const textAreaRef = React$1.useRef(null);
  const [code, setCode] = useState$1(initialCode);
  const [loadingQuery, setLoadingQuery] = useState$1(false);
  const [querySnapshot, setQuerySnapshot] = useState$1(null);
  const [codePriorityKeys, setCodePriorityKeys] = useState$1();
  const [executionResult, setExecutionResult] = useState$1();
  const [codeHasBeenRun, setCodeHasBeenRun] = useState$1(false);
  const [consoleOutput, setConsoleOutput] = useState$1("");
  const [executionError, setExecutionError] = useState$1(null);
  const mounted = React$1.useRef(false);
  const deferredCode = useDebounceValue2(code, 500);
  useEffect$1(() => {
    if (onCodeModified) {
      onCodeModified(deferredCode ?? "");
    }
  }, [deferredCode]);
  useEffect$1(() => {
    setCode(initialCode);
    if (autoRunCode && !mounted.current && initialCode && !sourceLoading) {
      executeQuery();
    }
    mounted.current = true;
  }, [sourceLoading, initialCode, autoRunCode]);
  const handleCodeChange = (value) => {
    setCode(value);
  };
  async function displayQuerySnapshotData(querySnapshot2, priorityKeys) {
    if (querySnapshot2.empty) {
      setQuerySnapshot(null);
      setExecutionResult("No documents found");
      return;
    }
    setQuerySnapshot(querySnapshot2);
    setCodePriorityKeys(priorityKeys);
  }
  const executeQuery = async () => {
    if (!code) {
      return;
    }
    originalConsoleLog("Executing code", code);
    setCodeHasBeenRun(true);
    setLoadingQuery(true);
    setExecutionError(null);
    try {
      pipeConsoleLog((...args) => {
        setConsoleOutput((prev) => prev + Array.from(args).join(" ") + "\n");
      });
      const encodedJs = encodeURIComponent(code);
      const dataUri = "data:text/javascript;charset=utf-8," + buildAuxScript() + encodedJs;
      const promise = import(
        /* @vite-ignore */
        dataUri
      );
      promise.then((module) => {
        originalConsoleLog("Module loaded", module);
        setConsoleOutput("");
        if (!module.default) {
          setExecutionError(new Error("No default export found. Make sure your code is exporting a default function."));
          setLoadingQuery(false);
          return;
        }
        module.default().then(async (codeOutput) => {
          originalConsoleLog("Code loaded", codeOutput, typeof codeOutput);
          let codeResult;
          if (codeOutput instanceof Promise) {
            codeResult = await codeOutput;
          } else if (typeof codeOutput === "function") {
            codeResult = await codeOutput();
          } else {
            codeResult = codeOutput;
          }
          if (codeResult instanceof firestoreLibrary.QuerySnapshot) {
            const priorityKeys = extractStringLiterals(code);
            return displayQuerySnapshotData(codeResult, priorityKeys);
          } else if (codeResult instanceof firestoreLibrary.DocumentReference) {
            return setExecutionResult("Document added successfully with reference: " + codeResult.path);
          } else if (codeResult instanceof firestoreLibrary.DocumentSnapshot) {
            const res = JSON.stringify(codeResult.data(), null, 2);
            originalConsoleLog("Document data", res);
            return setExecutionResult(res);
          } else if (typeof codeOutput === "undefined") {
            return setExecutionResult("Code executed successfully");
          } else {
            return setExecutionResult(codeResult);
          }
        }).catch((error) => {
          setExecutionError(error);
          originalConsoleError("Error executing query:", error);
        }).finally(() => {
          setLoadingQuery(false);
          onCodeRun?.();
          resetConsolePipe();
        });
      }).catch((error) => {
        setExecutionError(error);
        originalConsoleError("Error loading module:", error);
        setLoadingQuery(false);
        resetConsolePipe();
      });
    } catch (error) {
      setLoadingQuery(false);
      setExecutionError(error);
      console.error("Error executing query:", error);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "flex flex-col my-4 gap-2",
      style: {
        maxWidth: maxWidth ? maxWidth + "px" : void 0
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "flex flex-row w-full gap-4",
            ref: textAreaRef,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                AutoHeightEditor,
                {
                  value: code,
                  loading,
                  maxWidth: maxWidth ? maxWidth - 96 : void 0,
                  onChange: handleCodeChange
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$1,
                {
                  size: "small",
                  variant: codeHasBeenRun ? "outlined" : "filled",
                  onClick: executeQuery,
                  disabled: !code,
                  children: "Run Code"
                }
              )
            ]
          }
        ),
        executionError && /* @__PURE__ */ jsxRuntimeExports.jsx(ExecutionErrorView, { executionError }),
        (querySnapshot || loadingQuery || consoleOutput || executionResult) && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              marginLeft: querySnapshot ? "-64px" : void 0,
              width: querySnapshot ? "calc(100% + 64px)" : void 0
            },
            className: cls$1("w-full rounded-lg shadow-sm overflow-hidden transition-all", {
              "h-[480px]": querySnapshot,
              "h-[92px]": !querySnapshot && loadingQuery
            }),
            children: [
              loadingQuery && /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCenter$1, {}),
              querySnapshot && /* @__PURE__ */ jsxRuntimeExports.jsx(
                TableResults,
                {
                  querySnapshot,
                  priorityKeys: codePriorityKeys,
                  collections
                }
              ),
              (consoleOutput || executionResult) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper$1, { className: "w-full p-4 min-h-[92px] font-mono text-xs overflow-auto rounded-lg", children: [
                consoleOutput && /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "text-sm font-mono text-surface-700 dark:text-surface-200", children: consoleOutput }),
                executionResult && /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "text-xs font-mono text-surface-700 dark:text-surface-200", children: typeof executionResult === "string" ? executionResult : JSON.stringify(executionResult, null, 2) })
              ] })
            ]
          }
        )
      ]
    }
  );
}
const originalConsoleDebug = console.debug;
const originalConsoleLog = console.log;
const originalConsoleError = console.error;
const originalConsoleWarn = console.warn;
const originalConsoleInfo = console.info;
function resetConsolePipe() {
  console.debug = originalConsoleDebug;
  console.log = originalConsoleLog;
  console.error = originalConsoleError;
  console.warn = originalConsoleWarn;
  console.info = originalConsoleInfo;
}
function pipeConsoleLog(onConsoleLog) {
  console.debug = function(message) {
    onConsoleLog(message);
    originalConsoleDebug(message);
  };
  console.log = function(message) {
    onConsoleLog(message);
    originalConsoleLog(message);
  };
  console.error = function(message) {
    onConsoleLog(message);
    originalConsoleError(message);
  };
  console.warn = function(message) {
    onConsoleLog(message);
    originalConsoleWarn(message);
  };
  console.info = function(message) {
    onConsoleLog(message);
    originalConsoleInfo(message);
  };
}
function buildAuxScript() {
  return `${Object.keys(firestoreLibrary).map((key2) => `const ${key2} = window.firestoreLibrary.${key2};`).join("\n")}
`;
}
function SystemMessage({
  text,
  loading,
  containerWidth,
  autoRunCode,
  collections,
  onRegenerate,
  canRegenerate,
  onFeedback,
  onUpdatedMessage
}) {
  const [parsedElements, setParsedElements] = useState$1();
  useEffect$1(() => {
    if (text) {
      const markdownElements = parseMarkdown(text);
      setParsedElements(markdownElements);
    }
  }, [text]);
  const onUpdatedElements = (elements) => {
    const markdown = elements.map((element) => {
      if (element.type === "html") {
        return element.content;
      } else if (element.type === "code") {
        return "```javascript\n" + element.content + "\n```";
      }
      throw new Error("Unknown element type");
    }).join("\n");
    onUpdatedMessage?.(markdown);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    parsedElements && parsedElements.map((element, index2) => {
      if (element.type === "html") {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "max-w-full prose dark:prose-invert prose-headings:font-title text-base text-surface-700 dark:text-surface-200",
            dangerouslySetInnerHTML: { __html: element.content }
          },
          index2
        );
      } else if (element.type === "code") {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CodeBlock,
          {
            loading,
            autoRunCode,
            initialCode: element.content,
            collections,
            onCodeModified: (updatedCode) => {
              const updatedElements = [...parsedElements];
              updatedElements[index2] = {
                type: "code",
                content: updatedCode
              };
              setParsedElements(updatedElements);
              onUpdatedElements(updatedElements);
            },
            maxWidth: containerWidth ? containerWidth - 90 : void 0
          },
          index2
        );
      } else {
        console.error("Unknown element type", element);
        return null;
      }
    }),
    loading && /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton2, { className: "max-w-4xl mt-1 mb-4" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 flex flex-row gap-1", children: [
      canRegenerate && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tooltip$1,
        {
          title: "Regenerate",
          asChild: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { size: "smallest", disabled: loading, onClick: onRegenerate, children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoopIcon2, { size: "smallest" }) })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tooltip$1,
        {
          title: "Copy",
          asChild: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(MessageCopyIcon, { text: text ?? "", disabled: loading })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        BadMessageIcon,
        {
          disabled: loading,
          onFeedback
        }
      )
    ] })
  ] });
}
function MessageCopyIcon({
  text,
  disabled
}) {
  const [copied, setCopied] = useState$1(false);
  useEffect$1(() => {
    if (copied) {
      const timeout = setTimeout(() => {
        setCopied(false);
      }, 2e3);
      return () => clearTimeout(timeout);
    }
    return void 0;
  }, [copied]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    IconButton$1,
    {
      size: "smallest",
      disabled,
      onClick: () => {
        setCopied(true);
        navigator.clipboard.writeText(text);
      },
      children: copied ? /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon2, { size: "smallest" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ContentCopyIcon2, { size: "smallest" })
    }
  );
}
function BadMessageIcon({
  disabled,
  onFeedback
}) {
  const [dialogOpen, setDialogOpen] = useState$1(false);
  const [selected, setSelected] = useState$1(null);
  const [feedbackText, setFeedbackText] = useState$1("");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Tooltip$1,
      {
        title: dialogOpen ? void 0 : "Bad response",
        asChild: true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton$1,
          {
            size: "smallest",
            disabled,
            onClick: () => {
              setDialogOpen(true);
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThumbDownOffAltIcon2, { size: "smallest" })
          }
        )
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Dialog$1,
      {
        maxWidth: "xl",
        open: dialogOpen,
        onOpenChange: setDialogOpen,
        onOpenAutoFocus: (e) => {
          e.preventDefault();
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle$1, { variant: "h6", children: "What was wrong with the response?" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent$1, { className: "flex flex-col gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row gap-2 flex-wrap", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                FeedbackLabel,
                {
                  title: "Not helpful",
                  value: "not_helpful",
                  selected,
                  setSelected
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                FeedbackLabel,
                {
                  title: "Not factually correct",
                  value: "not_factually_correct",
                  selected,
                  setSelected
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                FeedbackLabel,
                {
                  title: "Incorrect code",
                  value: "incorrect_code",
                  selected,
                  setSelected
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                FeedbackLabel,
                {
                  title: "Unsafe or problematic",
                  value: "unsafe_or_problematic",
                  selected,
                  setSelected
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                FeedbackLabel,
                {
                  title: "Other",
                  value: "other",
                  selected,
                  setSelected
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField$1,
              {
                size: "small",
                value: feedbackText,
                onChange: (e) => setFeedbackText(e.target.value),
                placeholder: "Feel free to add specific details"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              variant: "outlined",
              onClick: () => {
                setDialogOpen(false);
                onFeedback?.(selected, feedbackText);
              },
              children: "Submit"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton$1,
            {
              className: "absolute top-4 right-4",
              onClick: () => setDialogOpen(false),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon$1, {})
            }
          )
        ]
      }
    )
  ] });
}
function FeedbackLabel({
  setSelected,
  title,
  value,
  selected
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Label$1,
    {
      border: true,
      className: value === selected ? "bg-surface-300 dark:bg-surface-700 hover:bg-surface-300 hover:dark:bg-surface-700" : "",
      onClick: () => {
        setSelected(value);
      },
      children: title
    }
  );
}
function MessageLayout({
  message,
  autoRunCode,
  onRemove,
  collections,
  onRegenerate,
  canRegenerate,
  onFeedback,
  onUpdatedMessage
}) {
  const ref2 = useRef$1(null);
  const onUpdatedMessageInternal = (updatedText) => {
    if (!message) return;
    if (onUpdatedMessage) onUpdatedMessage({
      ...message,
      text: updatedText
    });
  };
  const [containerWidth, setContainerWidth] = useState$1(null);
  useEffect$1(() => {
    const resizeObserver = new ResizeObserver((entries) => {
      if (ref2.current) {
        const rect = ref2.current?.getBoundingClientRect();
        setContainerWidth(rect.width);
      }
    });
    if (ref2.current) {
      resizeObserver.observe(ref2.current);
    }
    return () => resizeObserver.disconnect();
  }, [ref2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref: ref2,
      className: "flex flex-col gap-2 bg-white dark:bg-surface-800 dark:bg-opacity-20 rounded-lg p-4 shadow-sm",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start gap-3 justify-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Menu$1, { trigger: /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar2, { className: "w-10 h-10 shrink-0", children: message?.user === "USER" ? /* @__PURE__ */ jsxRuntimeExports.jsx(PersonIcon2, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(AutoFixHighIcon2, {}) }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem$1, { dense: true, onClick: onRemove, children: "Remove" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-3 flex-1 text-surface-700 dark:text-surface-200", children: message ? message.user === "USER" ? /* @__PURE__ */ jsxRuntimeExports.jsx(UserMessage, { text: message.text }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          SystemMessage,
          {
            text: message.text,
            loading: message.loading,
            autoRunCode,
            collections,
            canRegenerate,
            containerWidth: containerWidth ?? void 0,
            onRegenerate,
            onUpdatedMessage: onUpdatedMessageInternal,
            onFeedback
          }
        ) : null })
      ] })
    }
  );
}
function UserMessage({ text }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: text.split("\n").map((line2, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: line2 }, index2)) });
}
function IntroComponent({ onPromptSuggestionClick }) {
  const dataTalk = useDataTalk();
  const promptSuggestions = (dataTalk.rootPromptsSuggestions ?? []).length > 0 ? dataTalk.rootPromptsSuggestions : [
    "What can you do?",
    "What collections are available?",
    "Show me all products under 50 euros",
    "Create a new book with data for El Quijote.",
    "Show me the 10 cars with the most horsepower."
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "my-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "h3", gutterBottom: true, className: "font-mono ml-4 my-2", children: "Welcome to DATATALK" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Alert$1, { children: "DATATALK is FREE during the beta period." }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { paragraph: true, className: "ml-4 my-2", children: "DataTalk is a conversational interface to your data. You can ask questions, run commands and explore your data in a natural way." }),
    promptSuggestions && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { paragraph: true, className: "ml-4 my-2 mb-6", children: "Here are some examples of things you can ask:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-1 sm:gap-2 md:gap-4 overflow-auto no-scrollbar", children: promptSuggestions.map((prompt, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(PromptSuggestion, { onClick: onPromptSuggestionClick, prompt }, index2)) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "caption", color: "secondary", paragraph: true, className: "ml-4 my-2", children: "Note that these sample prompts are generic and may not work with your specific data." }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "caption", color: "secondary", paragraph: true, className: "ml-4 my-2", children: "You can't add additional imports or dependencies to the code snippets." })
  ] });
}
function PromptSuggestion({
  prompt,
  onClick
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Card$1,
    {
      className: "px-4 pt-12 pb-4 border-none w-[220px] min-w-[140px] font-semibold flex items-end",
      onClick: () => onClick(prompt),
      children: prompt
    }
  );
}
function DataTalkSession({
  session,
  initialPrompt,
  apiEndpoint,
  onAnalyticsEvent,
  getAuthToken,
  collections,
  onMessagesChange,
  autoRunCode,
  setAutoRunCode
}) {
  const [textInput, setTextInput] = useState$1("");
  const [messages, setMessages] = useState$1(session.messages || []);
  const [messageLoading, setMessageLoading] = useState$1(false);
  useEffect$1(() => {
    scrollToBottom();
  }, []);
  const [isUserScrolledUp, setIsUserScrolledUp] = useState$1(false);
  const messagesEndRef = useRef$1(null);
  const scrollContainerRef = useRef$1(null);
  const scrollToBottom = () => {
    setTimeout(() => {
      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    }, 100);
  };
  const handleScroll = () => {
    if (!scrollContainerRef.current) return;
    const {
      scrollTop,
      scrollHeight,
      clientHeight
    } = scrollContainerRef.current;
    if (scrollHeight - scrollTop > clientHeight + 50) {
      setIsUserScrolledUp(true);
    } else {
      setIsUserScrolledUp(false);
    }
  };
  useEffect$1(() => {
    const observer = new IntersectionObserver((entries, observer2) => {
      if (entries[0].isIntersecting && !isUserScrolledUp) {
        scrollToBottom();
      }
    }, {
      root: scrollContainerRef.current
    });
    if (messagesEndRef.current) {
      observer.observe(messagesEndRef.current);
    }
    const resizeObserver = new ResizeObserver(() => {
      if (!isUserScrolledUp) {
        scrollToBottom();
      }
    });
    if (scrollContainerRef.current) {
      resizeObserver.observe(scrollContainerRef.current);
    }
    return () => {
      observer.disconnect();
      if (scrollContainerRef.current) {
        resizeObserver.unobserve(scrollContainerRef.current);
      }
    };
  }, [isUserScrolledUp]);
  useEffect$1(() => {
    if (initialPrompt && messages.length === 0) {
      submit(initialPrompt);
    }
  }, []);
  const submit = async (messageText, baseMessages = messages) => {
    if (!messageText) return;
    if (onAnalyticsEvent) {
      onAnalyticsEvent("message_sent", { message: messageText });
    }
    const userMessageId = randomString2(20);
    const systemMessageId = randomString2(20);
    const newMessages = [
      ...baseMessages,
      {
        id: userMessageId,
        text: messageText,
        user: "USER",
        date: /* @__PURE__ */ new Date()
      }
    ];
    onMessagesChange?.(newMessages);
    setMessages([
      ...newMessages,
      {
        id: systemMessageId,
        loading: true,
        text: "",
        user: "SYSTEM",
        date: /* @__PURE__ */ new Date()
      }
    ]);
    setTextInput("");
    const firebaseToken = await getAuthToken();
    let currentMessageResponse = "";
    setMessageLoading(true);
    streamDataTalkCommand(
      firebaseToken,
      messageText,
      apiEndpoint,
      session.id,
      baseMessages,
      (newDelta) => {
        currentMessageResponse += newDelta;
        setMessages([
          ...newMessages,
          {
            id: systemMessageId,
            loading: true,
            text: currentMessageResponse,
            user: "SYSTEM",
            date: /* @__PURE__ */ new Date()
          }
        ]);
      }
    ).then((newMessage) => {
      const updatedMessages = [
        ...newMessages,
        {
          id: systemMessageId,
          loading: false,
          text: newMessage,
          user: "SYSTEM",
          date: /* @__PURE__ */ new Date()
        }
      ];
      setMessages(updatedMessages);
      onMessagesChange?.(updatedMessages);
    }).catch((e) => {
      console.error("Error processing command", e);
      const updatedMessages = [
        ...newMessages,
        {
          id: systemMessageId,
          loading: false,
          text: "There was an error processing your command: " + e.message,
          user: "SYSTEM",
          date: /* @__PURE__ */ new Date()
        }
      ];
      setMessages(updatedMessages);
      onMessagesChange?.(updatedMessages);
    }).finally(() => {
      setMessageLoading(false);
    });
  };
  const handleKeyDown = (event) => {
    if (event.key === "Enter" && !event.shiftKey) {
      event.preventDefault();
      submit(textInput);
    }
  };
  const onRegenerate = (message, index2) => {
    if (onAnalyticsEvent) {
      onAnalyticsEvent("regenerate", { message });
    }
    const newMessages = [...messages];
    newMessages.splice(index2);
    const lastUserMessage = newMessages.filter((m) => m.user === "USER").pop();
    newMessages.splice(index2 - 1);
    if (lastUserMessage) {
      submit(lastUserMessage.text, newMessages);
    }
  };
  const saveFeedback = (message, reason, feedbackMessage, index2) => {
    if (onAnalyticsEvent) {
      onAnalyticsEvent("bad_response", {
        reason,
        feedbackMessage
      });
    }
    const newMessages = [...messages];
    const messageToUpdate = newMessages[index2];
    if (messageToUpdate) {
      messageToUpdate.negative_feedback = {
        reason,
        message: feedbackMessage
      };
      setMessages(newMessages);
      onMessagesChange?.(newMessages);
    }
  };
  const updateMessage = (message, index2) => {
    const newMessages = [...messages];
    newMessages[index2] = message;
    setMessages(newMessages);
    onMessagesChange?.(newMessages);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "h-full w-full flex flex-col bg-surface-50 dark:bg-surface-900", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "h-full overflow-auto",
        onScroll: handleScroll,
        ref: scrollContainerRef,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 md:px-6 py-8 flex-1 flex flex-col gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Tooltip$1,
              {
                asChild: true,
                delayDuration: 500,
                title: "Run snippets of code generated by DataTalk automatically.\nCaution: This can be risky since scripts may modify your data in ways you don't expect",
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Label$1,
                  {
                    className: "self-end border cursor-pointer rounded-md p-2 flex items-center gap-2 [&:has(:checked)]:bg-surface-100 dark:[&:has(:checked)]:bg-surface-800 w-fit ",
                    htmlFor: "autoRunCode",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Checkbox$1,
                        {
                          id: "autoRunCode",
                          checked: autoRunCode,
                          size: "small",
                          onCheckedChange: setAutoRunCode
                        }
                      ),
                      "Run code automatically"
                    ]
                  }
                )
              }
            ),
            (messages ?? []).length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(IntroComponent, { onPromptSuggestionClick: (prompt) => submit(prompt) }),
            messages.map((message, index2) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                MessageLayout,
                {
                  onRemove: () => {
                    const newMessages = [...messages];
                    newMessages.splice(index2, 1);
                    setMessages(newMessages);
                  },
                  onFeedback: (reason, feedbackMessage) => {
                    saveFeedback(message, reason, feedbackMessage, index2);
                  },
                  onUpdatedMessage: (message2) => {
                    updateMessage(message2, index2);
                  },
                  collections,
                  message,
                  canRegenerate: index2 === messages.length - 1 && message.user === "SYSTEM",
                  onRegenerate: () => onRegenerate(message, index2),
                  autoRunCode
                },
                message.date.toISOString() + index2
              );
            })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: messagesEndRef })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container sticky bottom-0 right-0 left-0 mx-auto px-4 md:px-6 pb-8 pt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "form",
      {
        noValidate: true,
        onSubmit: (e) => {
          e.preventDefault();
          if (!messageLoading && textInput)
            submit(textInput);
        },
        autoComplete: "off",
        className: "relative bg-white dark:bg-surface-800 rounded-lg shadow-sm flex items-center gap-2 ",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextareaAutosize2,
            {
              value: textInput,
              autoFocus: true,
              onKeyDown: handleKeyDown,
              onChange: (e) => setTextInput(e.target.value),
              className: "flex-1 resize-none rounded-lg p-4 border-none focus:ring-0 dark:bg-surface-800 dark:text-surface-200 pr-[80px]",
              placeholder: "Type your message..."
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              className: "absolute right-0 top-0 m-1.5",
              variant: "text",
              type: "submit",
              disabled: !textInput || messageLoading,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(SendIcon2, { color: "primary" })
            }
          )
        ]
      }
    ) })
  ] });
}
function DataTalkRoutes({
  apiEndpoint,
  onAnalyticsEvent,
  getAuthToken,
  collections
}) {
  const dataTalkConfig = useDataTalk();
  if (dataTalkConfig.loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCenter$1, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Route,
      {
        path: "/",
        element: /* @__PURE__ */ jsxRuntimeExports.jsx(CreateSessionAdnRedirect, { dataTalkConfig })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Route,
      {
        path: "/:sessionId",
        element: /* @__PURE__ */ jsxRuntimeExports.jsx(
          DataTalkSessionRoute,
          {
            dataTalkConfig,
            onAnalyticsEvent,
            apiEndpoint,
            getAuthToken,
            collections
          }
        )
      }
    )
  ] });
}
function CreateSessionAdnRedirect({ dataTalkConfig }) {
  const location = useLocation();
  const navigate = useNavigate();
  const params = new URLSearchParams(location.search);
  const initialPrompt = params.get("prompt");
  useEffect$1(() => {
    dataTalkConfig.createSessionId().then((sessionId) => {
      if (initialPrompt) {
        navigate(`${location.pathname}/${sessionId}?prompt=${initialPrompt}`, { replace: true });
      } else {
        navigate(`${location.pathname}/${sessionId}`, { replace: true });
      }
    });
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCenter$1, {});
}
function DataTalkSessionRoute({
  dataTalkConfig,
  onAnalyticsEvent,
  apiEndpoint,
  getAuthToken,
  collections
}) {
  const [autoRunCode, setAutoRunCode] = useState$1(false);
  const { sessionId } = useParams();
  if (!sessionId) throw Error("Session id not found");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DataTalkRouteInner,
    {
      sessionId,
      dataTalkConfig,
      apiEndpoint,
      getAuthToken,
      onAnalyticsEvent,
      collections,
      autoRunCode,
      setAutoRunCode
    },
    sessionId
  );
}
function DataTalkRouteInner({
  sessionId,
  dataTalkConfig,
  apiEndpoint,
  getAuthToken,
  onAnalyticsEvent,
  collections,
  autoRunCode,
  setAutoRunCode
}) {
  const location = useLocation();
  const params = new URLSearchParams(location.search);
  const initialPrompt = params.get("prompt");
  const [session, setSession] = React$1.useState(void 0);
  const [loading, setLoading] = React$1.useState(true);
  useEffect$1(() => {
    setLoading(true);
    dataTalkConfig.getSession(sessionId).then((session2) => {
      setSession(session2);
      setLoading(false);
    });
  }, [sessionId]);
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCenter$1, {});
  }
  const usedSession = session ?? {
    id: sessionId,
    created_at: /* @__PURE__ */ new Date(),
    messages: []
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DataTalkSession,
    {
      apiEndpoint,
      getAuthToken,
      onAnalyticsEvent,
      collections,
      session: usedSession,
      autoRunCode,
      setAutoRunCode,
      initialPrompt: initialPrompt ?? void 0,
      onMessagesChange: (messages) => {
        const newSession = {
          ...usedSession,
          messages
        };
        setSession(newSession);
        dataTalkConfig.saveSession(newSession);
      }
    }
  );
}
function DataTalkDrawer() {
  const {
    drawerHovered,
    drawerOpen,
    openDrawer,
    closeDrawer
  } = useApp$1();
  const navigation = useNavigationController$1();
  const { sessions } = useDataTalk();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-grow overflow-scroll no-scrollbar my-8", children: [
    !drawerOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center p-4 h-full cursor-pointer", onClick: openDrawer, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ManageSearchIcon2, {}) }),
    sessions?.map((session, index2) => {
      const firstMessage = session.messages[0];
      const charsLimit = 30;
      const firstChars = firstMessage?.text.slice(0, charsLimit) ?? "DataTalk session started";
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        NavLink,
        {
          style: {
            width: !drawerOpen ? "72px" : "280px",
            transition: drawerOpen ? "width 150ms ease-in" : void 0
          },
          className: ({ isActive }) => cls$1(
            "transition-opacity flex flex-col justify-between p-4",
            !drawerOpen ? "opacity-0" : "opacity-1",
            "rounded-r-lg truncate",
            "hover:bg-surface-accent-300 hover:bg-opacity-60 dark:hover:bg-surface-700 dark:hover:bg-opacity-60 text-surface-800 dark:text-surface-200 hover:text-surface-900 hover:dark:text-white",
            "mr-8",
            "font-medium text-sm",
            isActive ? "bg-surface-accent-200 bg-opacity-60 dark:bg-surface-800 dark:bg-opacity-30" : ""
          ),
          to: navigation.homeUrl + "/datatalk/" + session.id,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Typography$1,
              {
                variant: "label",
                className: "whitespace-nowrap",
                children: [
                  firstChars,
                  (firstMessage?.text ?? "").length > charsLimit ? "..." : ""
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Typography$1,
              {
                variant: "caption",
                color: "secondary",
                className: "whitespace-nowrap",
                children: session.created_at.toLocaleString()
              }
            )
          ]
        },
        index2
      );
    })
  ] }) });
}
const React = await importShared("react");
const { useState, useRef, useEffect, useCallback, useContext, useDeferredValue, useMemo } = React;
const { getFirestore, onSnapshot, doc, setDoc, getDoc, collection, query, where, getDocs, orderBy, deleteDoc, addDoc, updateDoc } = await importShared("@firebase/firestore");
const { ReCaptchaV3Provider, ReCaptchaEnterpriseProvider } = await importShared("@firebase/app-check");
const { getStorage, getDownloadURL, uploadBytes, ref } = await importShared("@firebase/storage");
const { getAuth, signInWithCustomToken, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut, OAuthCredential } = await importShared("@firebase/auth");
const { useApp: useApp2, IconForView: IconForView2, useNavigationController: useNavigationController2, useAuthController: useAuthController2, DrawerLogo: DrawerLogo2, DrawerNavigationItem: DrawerNavigationItem2, useSnackbarController: useSnackbarController2, useBrowserTitleAndIcon: useBrowserTitleAndIcon2, FireCMSLogo: FireCMSLogo2, ErrorView: ErrorView2, useCustomizationController: useCustomizationController2, NavigationGroup: NavigationGroup2, SmallNavigationCard: SmallNavigationCard2, DefaultHomePage: DefaultHomePage2, unslugify: unslugify2, useBuildModeController: useBuildModeController2, Scaffold: Scaffold2, AppBar: AppBar2, SnackbarProvider: SnackbarProvider2, useBuildLocalConfigurationPersistence: useBuildLocalConfigurationPersistence2, useBuildNavigationController: useBuildNavigationController2, ModeControllerProvider: ModeControllerProvider2, FireCMS: FireCMS2, CircularProgressCenter: CircularProgressCenter2, Drawer: Drawer2, NavigationRoutes: NavigationRoutes2, SideDialogs: SideDialogs2 } = await importShared("@firecms/core");
const { cls: cls2, MenuItem: MenuItem2, MoreVertIcon: MoreVertIcon2, Tooltip: Tooltip2, IconButton: IconButton2, Menu: Menu2, Typography: Typography2, Button: Button2, AddIcon: AddIcon2, Paper: Paper2, BuildIcon: BuildIcon2, LoadingButton: LoadingButton2, Chip: Chip2, BooleanSwitchWithLabel: BooleanSwitchWithLabel2, Label: Label2, RadioGroupItem: RadioGroupItem2, RadioGroup: RadioGroup2, TextField: TextField2, Container: Container2, FileUpload: FileUpload2, BooleanSwitch: BooleanSwitch2, Checkbox: Checkbox2, Select: Select2, SelectItem: SelectItem2, Alert: Alert2, RocketLaunchIcon: RocketLaunchIcon2, DialogTitle: DialogTitle2, DialogContent: DialogContent2, CloseIcon: CloseIcon2, Dialog: Dialog2, CircularProgress: CircularProgress2, AutoAwesomeIcon: AutoAwesomeIcon2, Card: Card2, SearchIcon: SearchIcon2, Collapse: Collapse2, CenteredView: CenteredView2, ErrorIcon: ErrorIcon2 } = await importShared("@firecms/ui");
const { useInitialiseFirebase: useInitialiseFirebase2, useAppCheck: useAppCheck2, useFirebaseAuthController: useFirebaseAuthController2, useFirestoreDelegate: useFirestoreDelegate2, useFirebaseStorageSource: useFirebaseStorageSource2, getFirestoreDataInPath: getFirestoreDataInPath2 } = await importShared("@firecms/firebase");
const RESERVED_GROUPS = ["Admin"];
function resolveCollectionConfigPermissions({
  user,
  userManagement,
  collection: collection2
}) {
  const baseConfigPermissions = {
    createCollections: false,
    editCollections: false,
    deleteCollections: false
  };
  const fireCMSUser = user && userManagement.users.find((u) => u.uid === user.uid);
  const userRoles = fireCMSUser ? getUserRoles(userManagement.roles, fireCMSUser) : void 0;
  if (!fireCMSUser || !userRoles) {
    return baseConfigPermissions;
  }
  return userRoles.map((role) => ({
    createCollections: role.isAdmin || role.config?.createCollections === true,
    editCollections: role.isAdmin || role.config?.editCollections === true || role.config?.editCollections === "own" && collection2?.ownerId === fireCMSUser?.uid,
    deleteCollections: role.isAdmin || role.config?.deleteCollections === true || role.config?.deleteCollections === "own" && collection2?.ownerId === fireCMSUser?.uid
  })).reduce(mergeConfigPermissions, baseConfigPermissions);
}
const mergeConfigPermissions = (permA, permB) => {
  return {
    createCollections: permA.createCollections || permB.createCollections,
    editCollections: permA.editCollections || permB.editCollections,
    deleteCollections: permA.deleteCollections || permB.deleteCollections
  };
};
const areRolesEqual = (rolesA, rolesB) => {
  return rolesA.length === rolesB.length && rolesA.every((role) => rolesB.includes(role));
};
const ADMIN_VIEWS_CONFIG = [{
  path: "users",
  name: "CMS Users",
  group: "Admin",
  icon: "face"
}, {
  path: "roles",
  name: "Roles",
  group: "Admin",
  icon: "gpp_good"
}, {
  path: "settings",
  name: "Project settings",
  group: "Admin",
  icon: "settings"
}];
function cacheDelegatedLoginToken(projectId, delegatedToken) {
  if (!delegatedToken) {
    return;
  }
  const data = parseJwt(delegatedToken);
  const expiry = new Date(data.exp * 1e3);
  localStorage.setItem(`auth_token::${projectId}`, JSON.stringify({
    token: delegatedToken,
    expiry
  }));
}
function getDelegatedLoginTokenFromCache(projectId) {
  const entry = localStorage.getItem(`auth_token::${projectId}`);
  if (entry) {
    const data = JSON.parse(entry);
    data.expiry = new Date(data.expiry);
    if (data.expiry > /* @__PURE__ */ new Date()) {
      return data.token;
    }
  }
  return void 0;
}
function clearDelegatedLoginTokensCache() {
  for (let i = 0; i < localStorage.length; i++) {
    const key2 = localStorage.key(i);
    if (key2?.startsWith("auth_token::")) {
      localStorage.removeItem(key2);
    }
  }
}
function parseJwt(token2) {
  if (!token2) {
    throw new Error("No JWT token");
  }
  const base64Url = token2.split(".")[1];
  const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
  const jsonPayload = decodeURIComponent(window.atob(base64).split("").map(function(c2) {
    return "%" + ("00" + c2.charCodeAt(0).toString(16)).slice(-2);
  }).join(""));
  return JSON.parse(jsonPayload);
}
function darkenColor(hexColor, darkenBy = 10) {
  if (!/^#([0-9A-Fa-f]{3}){1,2}$/.test(hexColor)) {
    throw new Error("Invalid color format");
  }
  let color = hexColor.substring(1).split("");
  if (color.length === 3) {
    color = [color[0], color[0], color[1], color[1], color[2], color[2]];
  }
  let r = parseInt(color[0] + color[1], 16);
  let g = parseInt(color[2] + color[3], 16);
  let b = parseInt(color[4] + color[5], 16);
  r = Math.floor(r * (1 - darkenBy / 100));
  g = Math.floor(g * (1 - darkenBy / 100));
  b = Math.floor(b * (1 - darkenBy / 100));
  return "#" + (r < 16 ? "0" : "") + r.toString(16) + (g < 16 ? "0" : "") + g.toString(16) + (b < 16 ? "0" : "") + b.toString(16);
}
function hexToRgbaWithOpacity(hexColor, opacity = 10) {
  if (!/^#([0-9A-Fa-f]{3}){1,2}$/.test(hexColor)) {
    throw new Error("Invalid color format");
  }
  let color = hexColor.substring(1).split("");
  if (color.length === 3) {
    color = [color[0], color[0], color[1], color[1], color[2], color[2]];
  }
  const r = parseInt(color[0] + color[1], 16);
  const g = parseInt(color[2] + color[3], 16);
  const b = parseInt(color[4] + color[5], 16);
  const alpha = opacity / 100;
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}
const getFirebaseApps = async () => {
  const app = await __vitePreload(() => import("../index.esm-Bmz15k22.js"), true ? [] : void 0);
  return app.getApps();
};
const getFirebaseApp = async () => {
  const app = await __vitePreload(() => import("../index.esm-Bmz15k22.js"), true ? [] : void 0);
  return app.getApp();
};
const DEFAULT_PRIMARY_COLOR = "#0070F4";
const DEFAULT_SECONDARY_COLOR = "#FF5B79";
function useBuildProjectConfig({
  backendFirebaseApp,
  projectId
}) {
  const [primaryColor, setPrimaryColor] = useState(DEFAULT_PRIMARY_COLOR);
  const [secondaryColor, setSecondaryColor] = useState(DEFAULT_SECONDARY_COLOR);
  const projectPath = `projects/${projectId}`;
  const configPath = projectId ? projectPath : void 0;
  const [clientProjectName, setClientProjectName] = useState();
  const [subscriptionPlan, setSubscriptionPlan] = useState();
  const [subscriptionData, setSubscriptionData] = useState();
  const [clientConfigLoading, setClientConfigLoading] = useState(false);
  const [clientFirebaseConfig, setClientFirebaseConfig] = useState();
  const [clientFirebaseMissing, setClientFirebaseMissing] = useState();
  const [serviceAccountMissing, setServiceAccountMissing] = useState();
  const [clientConfigError, setClientConfigError] = useState();
  const [localTextSearchEnabled, setLocalTextSearchEnabled] = useState(false);
  const [blocked, setBlocked] = useState(false);
  const [appCheck, setAppCheck] = useState();
  const [serializedAppCheck, setSerializedAppCheck] = useState(null);
  const [customizationRevision, setCustomizationRevision] = useState();
  const [creationType, setCreationType] = useState();
  const loadedProjectIdRef = useRef(projectId);
  const [logo, setLogo] = React.useState();
  useEffect(() => {
    if (!backendFirebaseApp) throw Error("useBuildProjectConfig Firebase not initialised");
    const firestore = getFirestore(backendFirebaseApp);
    if (!firestore || !configPath) return;
    return onSnapshot(doc(firestore, configPath), {
      next: (snapshot) => {
        setLogo(snapshot.get("logo"));
      },
      error: (e) => {
        console.error(e);
      }
    });
  }, [configPath]);
  useEffect(() => {
    if (primaryColor) {
      document.documentElement.style.setProperty("--fcms-primary", primaryColor);
      document.documentElement.style.setProperty("--fcms-primary-bg", hexToRgbaWithOpacity(primaryColor, 10));
    } else {
      document.documentElement.style.setProperty("--fcms-primary", darkenColor(DEFAULT_PRIMARY_COLOR, 10));
      document.documentElement.style.setProperty("--fcms-primary-bg", hexToRgbaWithOpacity(DEFAULT_PRIMARY_COLOR, 10));
    }
    if (secondaryColor) {
      document.documentElement.style.setProperty("--fcms-secondary", secondaryColor);
    } else {
      document.documentElement.style.setProperty("--fcms-secondary", DEFAULT_SECONDARY_COLOR);
    }
  }, [primaryColor, secondaryColor]);
  const uploadLogo = useCallback(async (file) => {
    if (!backendFirebaseApp) throw Error("useBuildProjectConfig Firebase not initialised");
    const firestore_0 = getFirestore(backendFirebaseApp);
    if (!firestore_0 || !configPath) throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    const storage = getStorage(backendFirebaseApp);
    if (!storage) throw Error("useFirestoreConfigurationPersistence Storage not initialised");
    const fileRef = await uploadFile(storage, {
      file,
      path: `${configPath}/images`
    });
    const url = await getDownloadURL(fileRef);
    setDoc(doc(firestore_0, configPath), {
      logo: url
    }, {
      merge: true
    });
  }, [configPath]);
  const updateProjectName = useCallback(async (name) => {
    if (!backendFirebaseApp) throw Error("useBuildProjectConfig Firebase not initialised");
    const firestore_1 = getFirestore(backendFirebaseApp);
    if (!firestore_1 || !configPath) throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    return setDoc(doc(firestore_1, configPath), {
      name
    }, {
      merge: true
    });
  }, [configPath]);
  const updateLocalTextSearchEnabled = useCallback(async (allowed) => {
    if (!backendFirebaseApp) throw Error("useBuildProjectConfig Firebase not initialised");
    const firestore_2 = getFirestore(backendFirebaseApp);
    if (!firestore_2 || !configPath) throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    return setDoc(doc(firestore_2, configPath), {
      local_text_search_enabled: allowed
    }, {
      merge: true
    });
  }, [configPath]);
  useEffect(() => {
    if (!projectId || !backendFirebaseApp) {
      setClientConfigLoading(false);
      return;
    }
    if (loadedProjectIdRef.current !== projectId) {
      setClientConfigLoading(true);
      setClientFirebaseConfig(void 0);
      loadedProjectIdRef.current = void 0;
    }
    const firestore_3 = getFirestore(backendFirebaseApp);
    return onSnapshot(doc(firestore_3, projectPath), {
      next: (snapshot_0) => {
        console.debug("Project config snapshot:", {
          data: snapshot_0.data()
        });
        setClientProjectName(snapshot_0.get("name"));
        const plan = snapshot_0.get("subscription_plan") ?? "free";
        setSubscriptionPlan(plan);
        setSubscriptionData(snapshot_0.get("subscription_data"));
        setLocalTextSearchEnabled(snapshot_0.get("local_text_search_enabled") ?? false);
        if (plan === "free") {
          setPrimaryColor(DEFAULT_PRIMARY_COLOR);
          setSecondaryColor(DEFAULT_SECONDARY_COLOR);
        } else {
          setPrimaryColor(snapshot_0.get("primary_color") ?? DEFAULT_PRIMARY_COLOR);
          setSecondaryColor(snapshot_0.get("secondary_color") ?? DEFAULT_SECONDARY_COLOR);
        }
        const currentCustomizationRevision = snapshot_0.get("current_app_config_revision");
        setCustomizationRevision(currentCustomizationRevision);
        setCreationType(snapshot_0.get("creation_type"));
        setBlocked(snapshot_0.get("blocked"));
        const updatedSerializedAppCheck = snapshot_0.get("app_check");
        if (updatedSerializedAppCheck) {
          if (plan === "free") {
            console.warn("AppCheck is not supported in the free plan. Ignoring configuration. Please upgrade to PLUS in order to use this feature");
            setAppCheck(void 0);
            setSerializedAppCheck(null);
          } else {
            const appCheckOptions = updatedSerializedAppCheck ? deserializeAppCheckOptions(updatedSerializedAppCheck) : void 0;
            setAppCheck(appCheckOptions);
            setSerializedAppCheck(updatedSerializedAppCheck);
          }
        }
        const firebaseConfig = snapshot_0.get("firebase_config");
        loadedProjectIdRef.current = projectId;
        if (firebaseConfig === "loading") {
          setClientConfigLoading(true);
          setClientFirebaseConfig(void 0);
          setClientFirebaseMissing(false);
        } else if (typeof firebaseConfig === "object") {
          setClientFirebaseConfig(firebaseConfig);
          setClientConfigLoading(false);
          setClientFirebaseMissing(false);
        } else if (firebaseConfig === void 0) {
          setClientConfigLoading(false);
          setClientFirebaseMissing(true);
        }
        setClientConfigError(void 0);
        setServiceAccountMissing(!snapshot_0.get("service_account"));
      },
      error: (e_0) => {
        console.error(e_0);
        setClientConfigError(e_0);
        setClientConfigLoading(false);
      }
    });
  }, [backendFirebaseApp, projectId]);
  const usersLimit = subscriptionPlan === "free" ? 3 : void 0;
  const canEditRoles = subscriptionPlan !== "free";
  const canModifyTheme = subscriptionPlan !== "free";
  const canExport = subscriptionPlan !== "free";
  const canUseLocalTextSearch = subscriptionPlan !== "free";
  const canUseCustomDatabase = subscriptionPlan !== "free";
  const canUseDataEnhancement = subscriptionPlan !== "free";
  const updatePrimaryColor = useCallback(async (color) => {
    if (!backendFirebaseApp) throw Error("useBuildProjectConfig Firebase not initialised");
    const firestore_4 = getFirestore(backendFirebaseApp);
    if (!firestore_4 || !configPath) throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    setPrimaryColor(color);
    if (canModifyTheme) setDoc(doc(firestore_4, configPath), {
      primary_color: color
    }, {
      merge: true
    });
  }, [configPath, canModifyTheme]);
  const updateSecondaryColor = useCallback(async (color_0) => {
    if (!backendFirebaseApp) throw Error("useBuildProjectConfig Firebase not initialised");
    const firestore_5 = getFirestore(backendFirebaseApp);
    if (!firestore_5 || !configPath) throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    setSecondaryColor(color_0);
    if (canModifyTheme) setDoc(doc(firestore_5, configPath), {
      secondary_color: color_0
    }, {
      merge: true
    });
  }, [configPath, canModifyTheme]);
  const updateAppCheck = useCallback(async (appCheck_0) => {
    if (!backendFirebaseApp) throw Error("useBuildProjectConfig Firebase not initialised");
    const firestore_6 = getFirestore(backendFirebaseApp);
    if (!firestore_6 || !configPath) throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    setDoc(doc(firestore_6, configPath), {
      app_check: appCheck_0
    }, {
      merge: true
    });
  }, [configPath]);
  return {
    projectId,
    logo: canModifyTheme ? logo : void 0,
    uploadLogo,
    updateProjectName,
    projectName: clientProjectName,
    subscriptionPlan: loadedProjectIdRef.current !== projectId ? void 0 : subscriptionPlan,
    subscriptionData: loadedProjectIdRef.current !== projectId ? void 0 : subscriptionData,
    customizationRevision: loadedProjectIdRef.current !== projectId ? void 0 : customizationRevision,
    configLoading: loadedProjectIdRef.current !== projectId || clientConfigLoading,
    configError: loadedProjectIdRef.current !== projectId ? void 0 : clientConfigError,
    clientFirebaseConfig: loadedProjectIdRef.current !== projectId ? void 0 : clientFirebaseConfig,
    clientFirebaseMissing: loadedProjectIdRef.current !== projectId ? void 0 : clientFirebaseMissing,
    serviceAccountMissing: loadedProjectIdRef.current !== projectId ? void 0 : serviceAccountMissing,
    usersLimit,
    canEditRoles,
    canModifyTheme,
    canExport,
    canUseLocalTextSearch,
    canUseCustomDatabase,
    canUseDataEnhancement,
    localTextSearchEnabled,
    updateLocalTextSearchEnabled,
    primaryColor,
    secondaryColor,
    updatePrimaryColor,
    updateSecondaryColor,
    blocked,
    updateAppCheck,
    appCheck,
    serializedAppCheck
  };
}
const uploadFile = (storage, {
  file,
  fileName,
  path,
  metadata
}) => {
  const usedFilename = fileName ?? file.name;
  console.debug("Uploading file", usedFilename, file, path, metadata);
  return uploadBytes(ref(storage, `${path}/${usedFilename}`), file, metadata).then((snapshot) => snapshot.ref);
};
const deserializeAppCheckOptions = (appCheck) => {
  if (appCheck.provider === "recaptcha_v3") {
    return {
      provider: new ReCaptchaV3Provider(appCheck.siteKey),
      isTokenAutoRefreshEnabled: appCheck.isTokenAutoRefreshEnabled,
      debugToken: appCheck.debugToken,
      forceRefresh: appCheck.forceRefresh
    };
  } else if (appCheck.provider === "recaptcha_enterprise") {
    return {
      provider: new ReCaptchaEnterpriseProvider(appCheck.siteKey),
      isTokenAutoRefreshEnabled: appCheck.isTokenAutoRefreshEnabled,
      debugToken: appCheck.debugToken,
      forceRefresh: appCheck.forceRefresh
    };
  }
  throw Error("Invalid app check type");
};
const ProjectConfigContext = React.createContext({});
const useProjectConfig = () => {
  return useContext(ProjectConfigContext);
};
function ProjectConfigProvider(t0) {
  const $2 = c_1(3);
  const {
    children,
    config: config2
  } = t0;
  let t1;
  if ($2[0] !== children || $2[1] !== config2) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(ProjectConfigContext.Provider, { value: config2, children });
    $2[0] = children;
    $2[1] = config2;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  return t1;
}
function useDelegatedLogin({
  projectsApi,
  firebaseApp,
  projectId,
  onUserChanged
}) {
  const [loginSuccessful, setLoginSuccessful] = useState(false);
  const [delegatedLoginLoading, setDelegatedLoginLoading] = useState(false);
  const [delegatedLoginError, setDelegatedLoginError] = useState(void 0);
  const checkLogin = useCallback(async (skipCache = false) => {
    console.debug("Checking delegated login", {
      skipCache,
      projectId
    });
    if (firebaseApp && projectId) {
      setDelegatedLoginError(void 0);
      setDelegatedLoginLoading(true);
      setLoginSuccessful(false);
      try {
        let usedCachedToken = false;
        let delegatedToken = !skipCache && getDelegatedLoginTokenFromCache(projectId);
        if (!delegatedToken) {
          try {
            console.debug("Delegating login", projectId);
            delegatedToken = await projectsApi.doDelegatedLogin(projectId);
          } catch (e_0) {
            console.error("Error delegating login", JSON.stringify(e_0));
            setDelegatedLoginError(e_0);
          }
        } else {
          console.debug("Using cached token", projectId);
          usedCachedToken = true;
        }
        if (!delegatedToken) {
          return;
        }
        const auth = getAuth(firebaseApp);
        signInWithCustomToken(auth, delegatedToken).then(async (userCredential) => {
          console.debug("Delegated user signed in", userCredential);
          onUserChanged?.(userCredential.user);
          setLoginSuccessful(true);
          try {
            cacheDelegatedLoginToken(projectId, delegatedToken);
          } catch (e_1) {
            console.error("Error caching token", e_1);
          }
        }).catch(async (error) => {
          if (usedCachedToken) {
            return await checkLogin(true);
          } else {
            console.error("Error signing in with delegated token", error);
            setLoginSuccessful(false);
            setDelegatedLoginError(error);
          }
        }).finally(() => setDelegatedLoginLoading(false));
      } catch (e) {
        setLoginSuccessful(false);
        setDelegatedLoginError(e);
        setDelegatedLoginLoading(false);
      }
    }
  }, [firebaseApp, projectId]);
  useEffect(() => {
    checkLogin();
  }, [checkLogin]);
  return {
    loginSuccessful,
    delegatedLoginLoading,
    delegatedLoginError
  };
}
const FireCMSBackendContext = React.createContext({});
function FireCMSBackEndProvider(t0) {
  const $2 = c_1(6);
  let backend;
  let children;
  if ($2[0] !== t0) {
    ({
      children,
      ...backend
    } = t0);
    $2[0] = t0;
    $2[1] = backend;
    $2[2] = children;
  } else {
    backend = $2[1];
    children = $2[2];
  }
  let t1;
  if ($2[3] !== backend || $2[4] !== children) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(FireCMSBackendContext.Provider, { value: backend, children });
    $2[3] = backend;
    $2[4] = children;
    $2[5] = t1;
  } else {
    t1 = $2[5];
  }
  return t1;
}
function useFireCMSBackend() {
  return React.useContext(FireCMSBackendContext);
}
async function convertDocToSubscription(doc2) {
  const [price, product] = await Promise.all([fetchPrice(doc2.data().price), fetchProduct(doc2.data().product)]);
  if (!price) {
    console.warn("Price not found for subscription", doc2.id);
    return void 0;
  }
  return {
    id: doc2.id,
    ...doc2.data(),
    price,
    product
  };
}
function fetchPrice(ref2) {
  return getDoc(ref2).then((priceDoc) => {
    if (!priceDoc.exists()) {
      return void 0;
    }
    return {
      id: priceDoc.id,
      ...priceDoc.data() ?? {}
    };
  });
}
function fetchProduct(ref2) {
  return getDoc(ref2).then((priceDoc) => {
    if (!priceDoc.exists()) {
      return void 0;
    }
    return {
      id: priceDoc.id,
      ...priceDoc.data() ?? {}
    };
  });
}
const SUBSCRIPTIONS_COLLECTION$1 = "subscriptions";
const PRODUCTS_COLLECTION = "products";
const CUSTOMERS_COLLECTION$1 = "customers";
function useSubscriptionsForUserController() {
  const $2 = c_1(22);
  const {
    backendFirebaseApp: firebaseApp,
    projectsApi
  } = useFireCMSBackend();
  const {
    backendUid: userId
  } = useFireCMSBackend();
  const firestoreRef = useRef();
  const [products, setProducts] = useState();
  const [productsLoading, setProductsLoading] = useState(true);
  const [productsLoadingError, setProductsLoadingError] = useState();
  let t0;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [];
    $2[0] = t0;
  } else {
    t0 = $2[0];
  }
  const [activeSubscriptions, setActiveSubscriptions] = useState(t0);
  const [activeSubscriptionsLoading, setActiveSubscriptionsLoading] = useState(true);
  const [activeSubscriptionsLoadingError, setActiveSubscriptionsLoadingError] = useState();
  let t1;
  let t2;
  if ($2[1] !== firebaseApp) {
    t1 = () => {
      if (!firebaseApp) {
        return;
      }
      firestoreRef.current = getFirestore(firebaseApp);
    };
    t2 = [firebaseApp];
    $2[1] = firebaseApp;
    $2[2] = t1;
    $2[3] = t2;
  } else {
    t1 = $2[2];
    t2 = $2[3];
  }
  useEffect(t1, t2);
  let t3;
  let t4;
  if ($2[4] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = () => {
      const firestore = firestoreRef.current;
      if (!firestore) {
        return;
      }
      const productsRef = collection(firestore, PRODUCTS_COLLECTION);
      return onSnapshot(query(productsRef, where("active", "==", true)), {
        next: async (querySnapshot) => {
          const updatedProducts = await Promise.all(querySnapshot.docs.map(async (productDoc) => {
            const pricesRef = collection(firestore, PRODUCTS_COLLECTION, productDoc.id, "prices");
            return getDocs(query(pricesRef, where("active", "==", true))).then(async (pricesQuery) => {
              const prices = pricesQuery.docs.map(_temp$a);
              prices.sort(_temp2$3);
              return {
                id: productDoc.id,
                ...productDoc.data(),
                prices
              };
            });
          }));
          setProductsLoadingError(void 0);
          setProducts(updatedProducts);
          setProductsLoading(false);
        },
        error: (error) => {
          setProductsLoadingError(error);
        }
      });
    };
    t4 = [firestoreRef];
    $2[4] = t3;
    $2[5] = t4;
  } else {
    t3 = $2[4];
    t4 = $2[5];
  }
  useEffect(t3, t4);
  let t5;
  let t6;
  if ($2[6] !== userId) {
    t5 = () => {
      const firestore_0 = firestoreRef.current;
      if (!firestore_0 || !userId) {
        return;
      }
      const subscriptionsRef = collection(firestore_0, CUSTOMERS_COLLECTION$1, userId, SUBSCRIPTIONS_COLLECTION$1);
      return onSnapshot(query(subscriptionsRef, where("ended_at", "==", null)), {
        next: async (snapshot) => {
          const updatedSubscriptions = (await Promise.all(snapshot.docs.map(convertDocToSubscription))).filter(Boolean);
          setActiveSubscriptionsLoading(false);
          setActiveSubscriptionsLoadingError(void 0);
          setActiveSubscriptions(updatedSubscriptions);
        },
        error: (error_0) => {
          setActiveSubscriptionsLoadingError(error_0);
        }
      });
    };
    t6 = [firestoreRef, userId];
    $2[6] = userId;
    $2[7] = t5;
    $2[8] = t6;
  } else {
    t5 = $2[7];
    t6 = $2[8];
  }
  useEffect(t5, t6);
  let t7;
  if ($2[9] !== projectsApi) {
    t7 = async (props) => {
      const {
        productPrice,
        onCheckoutSessionReady
      } = props;
      console.debug("Subscribing to product", props);
      const productPriceId = productPrice.id;
      const productPriceType = productPrice.type;
      try {
        const sessionUrl = await projectsApi.createStripeNewSubscriptionLink({
          ...props,
          productPriceId,
          productPriceType
        });
        onCheckoutSessionReady(sessionUrl, void 0);
      } catch (t82) {
        const e = t82;
        console.error("Error subscribing to product", productPriceId, e);
        onCheckoutSessionReady(void 0, e);
      }
    };
    $2[9] = projectsApi;
    $2[10] = t7;
  } else {
    t7 = $2[10];
  }
  const subscribe = t7;
  let t8;
  if ($2[11] !== activeSubscriptions) {
    t8 = (projectId_0) => activeSubscriptions?.filter((subscription) => subscription.metadata.projectId === projectId_0);
    $2[11] = activeSubscriptions;
    $2[12] = t8;
  } else {
    t8 = $2[12];
  }
  const getSubscriptionsForProject = t8;
  let t9;
  if ($2[13] !== activeSubscriptions || $2[14] !== activeSubscriptionsLoading || $2[15] !== activeSubscriptionsLoadingError || $2[16] !== getSubscriptionsForProject || $2[17] !== products || $2[18] !== productsLoading || $2[19] !== productsLoadingError || $2[20] !== subscribe) {
    t9 = {
      products,
      subscribe,
      getSubscriptionsForProject,
      activeSubscriptions,
      productsLoading,
      productsLoadingError,
      activeSubscriptionsLoading,
      activeSubscriptionsLoadingError
    };
    $2[13] = activeSubscriptions;
    $2[14] = activeSubscriptionsLoading;
    $2[15] = activeSubscriptionsLoadingError;
    $2[16] = getSubscriptionsForProject;
    $2[17] = products;
    $2[18] = productsLoading;
    $2[19] = productsLoadingError;
    $2[20] = subscribe;
    $2[21] = t9;
  } else {
    t9 = $2[21];
  }
  return t9;
}
function _temp2$3(a, b) {
  return (b.default ? 1 : 0) - (a.default ? 1 : 0);
}
function _temp$a(priceDoc) {
  return {
    ...priceDoc.data(),
    id: priceDoc.id
  };
}
class ApiError2 extends Error {
  code;
  projectId;
  data;
  constructor(message, code, projectId, data) {
    super(message);
    this.code = code;
    this.projectId = projectId;
    this.data = data;
  }
}
async function handleApiResponse(res, projectId) {
  const jsonResponse = await res.json();
  if (res.ok) {
    return jsonResponse.data;
  } else {
    if (res.status === 409)
      throw new ApiError2(jsonResponse.message ?? jsonResponse.error ?? "This already exists.", jsonResponse.code ?? "already-exists", projectId);
    throw new ApiError2(jsonResponse.message ?? jsonResponse.error, jsonResponse.code, projectId, jsonResponse.data);
  }
}
const rootCollectionsCache = {};
function buildProjectsApi(host, getBackendAuthToken) {
  async function createNewFireCMSProject(projectId, googleAccessToken, serviceAccount, creationType) {
    const firebaseAccessToken = await getBackendAuthToken();
    return fetch(host + "/projects", {
      method: "POST",
      headers: buildHeaders({
        firebaseAccessToken,
        googleAccessToken,
        serviceAccount
      }),
      body: JSON.stringify({
        projectId,
        creationType,
        serviceAccount: serviceAccount ?? null
      })
    }).then(async (res) => {
      return handleApiResponse(res, projectId).then((_2) => true);
    });
  }
  async function createFirebaseWebapp(projectId) {
    const firebaseAccessToken = await getBackendAuthToken();
    return fetch(host + `/projects/${projectId}/firebase_webapp`, {
      method: "POST",
      headers: buildHeaders({
        firebaseAccessToken
      }),
      body: JSON.stringify({
        projectId
      })
    }).then(async (res) => {
      return handleApiResponse(res, projectId).then((_2) => true);
    });
  }
  async function addSecurityRules(projectId, googleAccessToken, serviceAccount) {
    const firebaseAccessToken = await getBackendAuthToken();
    return fetch(host + `/projects/${projectId}/firestore_security_rules`, {
      method: "PATCH",
      headers: buildHeaders({
        firebaseAccessToken,
        googleAccessToken,
        serviceAccount
      })
    }).then(async (res) => {
      return handleApiResponse(res, projectId).then((_2) => true);
    });
  }
  async function createNewUser(projectId, user) {
    const firebaseAccessToken = await getBackendAuthToken();
    const persistedUserData = {
      ...user,
      roles: user.roles.map((r) => r.id),
      updated_on: /* @__PURE__ */ new Date()
    };
    return fetch(host + "/projects/" + projectId + "/users", {
      method: "POST",
      headers: buildHeaders({
        firebaseAccessToken
      }),
      body: JSON.stringify(persistedUserData)
    }).then((res) => {
      return handleApiResponse(res, projectId);
    });
  }
  async function updateUser(projectId, uid, user) {
    const firebaseAccessToken = await getBackendAuthToken();
    const persistedUserData = {
      ...user,
      roles: user.roles.map((r) => r.id),
      updated_on: /* @__PURE__ */ new Date()
    };
    console.log("Updating user", persistedUserData);
    return fetch(host + "/projects/" + projectId + "/users/" + uid, {
      method: "PATCH",
      headers: buildHeaders({
        firebaseAccessToken
      }),
      body: JSON.stringify(persistedUserData)
    }).then((res) => {
      return handleApiResponse(res, projectId);
    });
  }
  async function deleteUser(projectId, uid) {
    const firebaseAccessToken = await getBackendAuthToken();
    return fetch(host + "/projects/" + projectId + "/users/" + uid, {
      method: "DELETE",
      headers: buildHeaders({
        firebaseAccessToken
      })
    }).then((res) => {
      return handleApiResponse(res, projectId);
    });
  }
  async function getRootCollections(projectId, googleAccessToken, serviceAccount, retries = 10) {
    if (rootCollectionsCache[projectId]) {
      return rootCollectionsCache[projectId];
    }
    const firebaseAccessToken = await getBackendAuthToken();
    async function retry() {
      await new Promise((resolve) => setTimeout(resolve, 5e3));
      console.debug("Retrying getRootCollections", retries);
      return getRootCollections(projectId, googleAccessToken, serviceAccount, retries - 1);
    }
    return fetch(host + "/projects/" + projectId + "/firestore_root_collections", {
      method: "GET",
      headers: buildHeaders({
        firebaseAccessToken,
        googleAccessToken,
        serviceAccount
      })
    }).then(async (res) => {
      if (res.status >= 300) {
        return await retry();
      }
      const result = await handleApiResponse(res, projectId);
      rootCollectionsCache[projectId] = result;
      return result;
    }).catch(async (error) => {
      if (retries > 0) {
        return await retry();
      } else {
        throw error;
      }
    });
  }
  async function createServiceAccount(googleAccessToken, projectId) {
    const firebaseAccessToken = await getBackendAuthToken();
    return fetch(host + "/projects/" + projectId + "/service_accounts", {
      method: "POST",
      headers: buildHeaders({
        firebaseAccessToken,
        googleAccessToken
      })
    }).then(async (res) => {
      if (res.status === 409)
        throw Error("The service account already exists for this project.");
      const data = await res.json();
      return data.user;
    });
  }
  async function doDelegatedLogin(projectId) {
    const firebaseAccessToken = await getBackendAuthToken();
    return fetch(host + "/projects/" + projectId + "/delegated_login", {
      method: "POST",
      headers: buildHeaders({
        firebaseAccessToken
      }),
      body: JSON.stringify({
        projectId
      })
    }).then(async (res) => {
      const data = await res.json();
      if (!res.ok) {
        throw new ApiError2(data.message, data.code, projectId, data.data);
      }
      return data.data;
    });
  }
  async function getStripePortalLink() {
    const firebaseAccessToken = await getBackendAuthToken();
    return fetch(`${host}/customer/stripe_portal_link?return_url=${encodeURIComponent(window.location.href)}`, {
      method: "GET",
      headers: buildHeaders({
        firebaseAccessToken
      })
    }).then(async (res) => {
      const data = await res.json();
      return data.url;
    });
  }
  async function getStripeCancelLinkForSubscription(subscriptionId) {
    const firebaseAccessToken = await getBackendAuthToken();
    return fetch(`${host}/customer/stripe_portal_link/cancel_subscription?return_url=${encodeURIComponent(window.location.href)}&subscription_id=${subscriptionId}`, {
      method: "GET",
      headers: buildHeaders({
        firebaseAccessToken
      })
    }).then(async (res) => {
      const data = await res.json();
      return data.url;
    });
  }
  async function getStripeUpdateLinkForSubscription(subscriptionId) {
    const firebaseAccessToken = await getBackendAuthToken();
    return fetch(`${host}/customer/stripe_portal_link/update_subscription?return_url=${encodeURIComponent(window.location.href)}&subscription_id=${subscriptionId}`, {
      method: "GET",
      headers: buildHeaders({
        firebaseAccessToken
      })
    }).then(async (res) => {
      const data = await res.json();
      return data.url;
    });
  }
  async function getStripeUpdateLinkForPaymentMethod(subscriptionId) {
    const firebaseAccessToken = await getBackendAuthToken();
    return fetch(`${host}/customer/stripe_portal_link/update_payment_method?return_url=${encodeURIComponent(window.location.href)}&subscription_id=${subscriptionId}`, {
      method: "GET",
      headers: buildHeaders({
        firebaseAccessToken
      })
    }).then(async (res) => {
      const data = await res.json();
      return data.url;
    });
  }
  async function createStripeNewSubscriptionLink(props) {
    const firebaseAccessToken = await getBackendAuthToken();
    return fetch(`${host}/customer/create-checkout-session?return_url=${encodeURIComponent(window.location.href)}`, {
      method: "POST",
      headers: buildHeaders({
        firebaseAccessToken
      }),
      body: JSON.stringify(props)
    }).then(async (res) => {
      const data = await res.json();
      if (!res.ok) {
        throw new Error(data?.error ?? "Error creating checkout session");
      }
      console.log("createStripeNewSubscriptionLink result", data);
      return data.url;
    });
  }
  async function getRemoteConfigUrl(projectId, revisionId) {
    return `${host}/projects/${projectId}/app_config/${revisionId}/${await getBackendAuthToken()}/remoteEntry.js`;
  }
  return {
    createNewFireCMSProject,
    createFirebaseWebapp,
    addSecurityRules,
    createServiceAccount,
    createNewUser,
    updateUser,
    deleteUser,
    getRootCollections,
    doDelegatedLogin,
    createStripeNewSubscriptionLink,
    getStripePortalLink,
    getStripeUpdateLinkForSubscription,
    getStripeCancelLinkForSubscription,
    getStripeUpdateLinkForPaymentMethod,
    host,
    getRemoteConfigUrl
  };
}
function buildHeaders({
  firebaseAccessToken,
  googleAccessToken,
  serviceAccount
}) {
  const headers = {
    "Content-Type": "application/json"
  };
  if (firebaseAccessToken) {
    headers.Authorization = `Bearer ${firebaseAccessToken}`;
  }
  if (googleAccessToken) {
    headers["x-admin-authorization"] = `Bearer ${googleAccessToken}`;
  }
  if (serviceAccount) {
    headers["x-admin-service-account"] = `Bearer ${btoa(JSON.stringify(serviceAccount))}`;
  }
  return headers;
}
const AUTH_SCOPES = ["https://www.googleapis.com/auth/cloud-platform"];
function useBuildFireCMSBackend({
  backendApiHost,
  backendFirebaseApp,
  onUserChange
}) {
  const [loggedUser, setLoggedUser] = useState(void 0);
  const [authLoading, setAuthLoading] = useState(true);
  const [googleCredential, setGoogleCredential] = useState(loadCredentialFromStorage());
  const [authProviderError, setAuthProviderError] = useState();
  const [permissionsNotGrantedError, setPermissionsNotGrantedError] = useState(false);
  const [availableProjectIds, setAvailableProjectIds] = useState();
  const [availableProjectsLoading, setAvailableProjectsLoading] = useState(true);
  const [availableProjectsLoaded, setAvailableProjectsLoaded] = useState(false);
  const [availableProjectsError, setAvailableProjectsError] = useState();
  const [projects, setProjects] = useState();
  const firestoreRef = useRef();
  const updateFirebaseUser = useCallback((firebaseUser) => {
    onUserChange?.(firebaseUser);
    setLoggedUser(firebaseUser);
  }, []);
  useEffect(() => {
    if (availableProjectsLoaded && availableProjectIds) {
      Promise.all(availableProjectIds.map((projectId) => getProject(projectId))).then((projectsRes) => {
        setProjects(projectsRes.filter(Boolean));
      });
    }
  }, [availableProjectIds, availableProjectsLoaded]);
  useEffect(() => {
    if (!backendFirebaseApp) return;
    firestoreRef.current = getFirestore(backendFirebaseApp);
  }, [backendFirebaseApp]);
  useEffect(() => {
    if (!backendFirebaseApp) return;
    const auth = getAuth(backendFirebaseApp);
    updateFirebaseUser(auth.currentUser);
    return onAuthStateChanged(auth, (firebaseUser_0) => {
      setAuthLoading(false);
      updateFirebaseUser(firebaseUser_0);
    }, (error) => setAuthProviderError(error));
  }, [backendFirebaseApp, updateFirebaseUser]);
  useEffect(() => {
    const firestore = firestoreRef.current;
    if (!firestore) {
      return;
    }
    if (!loggedUser) {
      setAvailableProjectIds(void 0);
      setAvailableProjectsLoading(false);
      setAvailableProjectsLoaded(false);
      return;
    }
    return onSnapshot(doc(firestore, "users", loggedUser.uid), {
      next: (snapshot) => {
        const projectIds = snapshot.get("projects") ?? [];
        setAvailableProjectsError(void 0);
        setAvailableProjectIds(projectIds);
        setAvailableProjectsLoaded(true);
        setAvailableProjectsLoading(false);
      },
      error: (e) => {
        setAvailableProjectsError(e);
        setAvailableProjectsLoading(false);
      }
    });
  }, [loggedUser]);
  const googleLogin = useCallback((includeGoogleAdminScopes) => {
    if (!backendFirebaseApp) throw Error("useBuildFireCMSBackend googleLogin error");
    const provider = new GoogleAuthProvider();
    provider.setCustomParameters({
      access_type: "offline"
    });
    if (includeGoogleAdminScopes) AUTH_SCOPES.forEach((scope) => provider.addScope(scope));
    const auth_0 = getAuth(backendFirebaseApp);
    return signInWithPopup(auth_0, provider).then((credential) => {
      if (includeGoogleAdminScopes) {
        const userInfo = JSON.parse(credential._tokenResponse.rawUserInfo);
        const grantedScopes = userInfo.granted_scopes.split(" ");
        if (includeGoogleAdminScopes && !grantedScopes.includes(AUTH_SCOPES[0])) {
          setPermissionsNotGrantedError(true);
        } else {
          const credentialFromResult = GoogleAuthProvider.credentialFromResult(credential);
          setGoogleCredential(credentialFromResult);
          saveCredentialInStorage(credentialFromResult);
          setPermissionsNotGrantedError(false);
        }
      }
      return credential.user;
    }).catch((e_0) => {
      setAuthProviderError(e_0);
      return null;
    });
  }, [backendFirebaseApp]);
  const onSignOut = useCallback(() => {
    const auth_1 = getAuth(backendFirebaseApp);
    clearDelegatedLoginTokensCache();
    signOut(auth_1).then((_2) => {
      setLoggedUser(null);
      setGoogleCredential(null);
      setAuthProviderError(null);
      saveCredentialInStorage(null);
    });
  }, [backendFirebaseApp]);
  const getBackendAuthToken = useCallback(() => {
    if (!loggedUser) throw Error("Trying to get Firebase token ");
    return loggedUser.getIdToken();
  }, [loggedUser]);
  const getProject = useCallback((projectId_0) => {
    const firestore_0 = firestoreRef.current;
    if (!firestore_0) throw Error("useFireCMSProjectsRepository error");
    return getDoc(doc(firestore_0, "projects", projectId_0)).then((doc2) => doc2.exists() ? {
      projectId: doc2.id,
      ...doc2.data()
    } : null).catch((error_0) => {
      console.error("Error getting project:", error_0);
      return null;
    });
  }, []);
  const projectsApi = buildProjectsApi(backendApiHost, getBackendAuthToken);
  return {
    backendApiHost,
    user: loggedUser ?? null,
    signOut: onSignOut,
    googleLogin,
    getBackendAuthToken,
    googleCredential,
    availableProjectIds,
    availableProjectsLoaded,
    availableProjectsLoading,
    availableProjectsError,
    permissionsNotGrantedError,
    authLoading,
    authProviderError,
    backendFirebaseApp,
    backendUid: loggedUser?.uid,
    projectsApi,
    getProject,
    projects
  };
}
function saveCredentialInStorage(credential) {
  if (!credential) {
    localStorage.removeItem("googleCredential");
    return;
  }
  const credentialString = JSON.stringify({
    created_on: /* @__PURE__ */ new Date(),
    credential: credential.toJSON()
  });
  localStorage.setItem("googleCredential", credentialString);
}
function loadCredentialFromStorage() {
  try {
    const credentialString = localStorage.getItem("googleCredential");
    if (!credentialString) return null;
    const credentialJSON = JSON.parse(credentialString);
    const credential = OAuthCredential.fromJSON(credentialJSON.credential);
    const createdOn = new Date(credentialJSON.created_on);
    const now = /* @__PURE__ */ new Date();
    const diff = now.getTime() - createdOn.getTime();
    if (diff > 1e3 * 60 * 60) {
      console.debug("Google credential expired credential expired");
      saveCredentialInStorage(null);
      return null;
    }
    return credential;
  } catch (e) {
    console.error(e);
    return null;
  }
}
function useBuildCloudUserManagement({
  backendFirebaseApp,
  projectId,
  projectsApi,
  usersLimit,
  canEditRoles,
  fireCMSBackend
}) {
  const configPath = projectId ? `projects/${projectId}` : void 0;
  const firestoreRef = useRef();
  const [rolesLoading, setRolesLoading] = React.useState(true);
  const [usersLoading, setUsersLoading] = React.useState(true);
  const [roles, setRoles] = React.useState([]);
  const [usersWithRoleIds, setUsersWithRoleIds] = React.useState([]);
  const users = usersWithRoleIds.map((u) => ({
    ...u,
    roles: roles.filter((r) => u.roles.includes(r.id))
  }));
  const [rolesError, setRolesError] = React.useState();
  const [usersError, setUsersError] = React.useState();
  useEffect(() => {
    if (!backendFirebaseApp) return;
    firestoreRef.current = getFirestore(backendFirebaseApp);
  }, [backendFirebaseApp]);
  useEffect(() => {
    const firestore = firestoreRef.current;
    if (!firestore || !configPath) return;
    return onSnapshot(collection(firestore, configPath, "roles"), {
      next: (snapshot) => {
        setRolesError(void 0);
        try {
          const newRoles = docsToRoles(snapshot.docs);
          setRoles(newRoles);
        } catch (e) {
          setRolesError(e);
        }
        setRolesLoading(false);
      },
      error: (e_0) => {
        setRolesError(e_0);
        setRolesLoading(false);
      }
    });
  }, [configPath]);
  useEffect(() => {
    const firestore_0 = firestoreRef.current;
    if (!firestore_0 || !configPath) return;
    return onSnapshot(query(collection(firestore_0, configPath, "users"), orderBy("created_on", "asc")), {
      next: (snapshot_0) => {
        setUsersError(void 0);
        try {
          const newUsers = docsToUsers(snapshot_0.docs);
          setUsersWithRoleIds(newUsers);
        } catch (e_1) {
          setUsersError(e_1);
        }
        setUsersLoading(false);
      },
      error: (e_2) => {
        setUsersError(e_2);
        setUsersLoading(false);
      }
    });
  }, [configPath]);
  const saveUser = useCallback(async (user) => {
    const firestore_1 = firestoreRef.current;
    if (!firestore_1 || !configPath) throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    console.debug("Persisting", user);
    const {
      uid,
      ...userData
    } = user;
    if (uid) {
      return projectsApi.updateUser(projectId, uid, user);
    } else {
      return projectsApi.createNewUser(projectId, user);
    }
  }, [configPath, projectId]);
  const saveRole = useCallback((role) => {
    const firestore_2 = firestoreRef.current;
    if (!firestore_2 || !configPath) throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    console.debug("Persisting", role);
    const {
      id,
      ...roleData
    } = role;
    const ref2 = doc(firestore_2, configPath, "roles", id);
    return setDoc(ref2, roleData, {
      merge: true
    });
  }, [configPath]);
  const removeUser = useCallback(async (user_0) => {
    const firestore_3 = firestoreRef.current;
    if (!firestore_3 || !configPath) throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    console.debug("Deleting", user_0);
    const {
      uid: uid_0
    } = user_0;
    return projectsApi.deleteUser(projectId, uid_0);
  }, [configPath]);
  const deleteRole = useCallback((role_0) => {
    const firestore_4 = firestoreRef.current;
    if (!firestore_4 || !configPath) throw Error("useFirestoreConfigurationPersistence Firestore not initialised");
    console.debug("Deleting", role_0);
    const {
      id: id_0
    } = role_0;
    const ref_0 = doc(firestore_4, configPath, "roles", id_0);
    return deleteDoc(ref_0);
  }, [configPath]);
  const loggedInUser = users.find((u_0) => u_0.email.toLowerCase() === fireCMSBackend.user?.email?.toLowerCase());
  const collectionPermissions = useCallback(({
    collection: collection2
  }) => resolveUserRolePermissions({
    collection: collection2,
    user: loggedInUser ?? null
  }), [loggedInUser?.uid]);
  const userIds = users.map((u_1) => u_1.uid);
  const defineRolesFor = useCallback((user_1) => {
    if (!users) throw Error("Users not loaded");
    const mgmtUser = users.find((u_2) => u_2.email?.toLowerCase() === user_1?.email?.toLowerCase());
    return mgmtUser?.roles;
  }, [userIds]);
  const isAdmin = loggedInUser?.roles.some((r_0) => r_0.id === "admin");
  const allowedUsers = users.slice(0, usersLimit);
  return {
    allowDefaultRolesCreation: false,
    includeCollectionConfigPermissions: true,
    loading: rolesLoading || usersLoading,
    roles,
    users,
    allowedUsers,
    saveUser,
    saveRole,
    defineRolesFor,
    deleteUser: removeUser,
    deleteRole,
    usersLimit,
    isAdmin,
    canEditRoles: canEditRoles === void 0 ? true : canEditRoles,
    collectionPermissions
  };
}
const docsToUsers = (docs) => {
  return docs.map((doc2) => ({
    uid: doc2.id,
    ...doc2.data(),
    created_on: doc2.data()?.created_on?.toDate(),
    updated_on: doc2.data()?.updated_on?.toDate()
  }));
};
const docsToRoles = (docs) => {
  return docs.map((doc2) => ({
    id: doc2.id,
    ...doc2.data()
  }));
};
const useDataTalkMode = () => {
  const location = useLocation();
  const res = matchRoutes([{
    path: "/p/:projectId/datatalk/*"
  }], location);
  if (!res) {
    return false;
  }
  return res.length > 0;
};
const CUSTOMERS_COLLECTION = "customers";
const LICENSES_COLLECTION = "licenses";
const SUBSCRIPTIONS_COLLECTION = "subscriptions";
function convertDocToLicense(doc2) {
  const data = doc2.data();
  return {
    id: doc2.id,
    ...data,
    created_at: data?.created_at.toDate()
  };
}
function useLicensesForUserController() {
  const {
    backendFirebaseApp: firebaseApp
  } = useFireCMSBackend();
  const {
    backendUid: userId
  } = useFireCMSBackend();
  const firestoreRef = useRef();
  const [licenses, setLicenses] = useState([]);
  const [licenseLoading, setLicensesLoading] = useState(true);
  const [licenseLoadingError, setLicensesLoadingError] = useState();
  useEffect(() => {
    if (!firebaseApp) return;
    firestoreRef.current = getFirestore(firebaseApp);
  }, [firebaseApp]);
  useEffect(() => {
    const firestore = firestoreRef.current;
    if (!firestore || !userId) return;
    const licensesRef = collection(firestore, LICENSES_COLLECTION);
    return onSnapshot(query(licensesRef, where("created_by", "==", userId), where("archived", "==", false)), {
      next: async (snapshot) => {
        const updatedSubscriptions = snapshot.docs.map(convertDocToLicense).filter(Boolean);
        setLicensesLoading(false);
        setLicensesLoadingError(void 0);
        setLicenses(updatedSubscriptions);
      },
      error: (error) => {
        setLicensesLoadingError(error);
      }
    });
  }, [firestoreRef, userId]);
  const createLicense = async (license) => {
    const firestore_0 = firestoreRef.current;
    if (!firestore_0 || !userId) throw new Error("Firestore not initialized");
    const licensesRef_0 = collection(firestore_0, LICENSES_COLLECTION);
    return addDoc(licensesRef_0, license).then((ref2) => {
      return {
        id: ref2.id,
        ...license
      };
    });
  };
  const updateLicense = async (id, license_0) => {
    const firestore_1 = firestoreRef.current;
    if (!firestore_1 || !userId) throw new Error("Firestore not initialized");
    const licensesRef_1 = doc(firestore_1, LICENSES_COLLECTION, id);
    return updateDoc(licensesRef_1, license_0).then(() => {
      return license_0;
    });
  };
  const listenSubscriptionsForLicense = useCallback((licenseId, onSubscriptionsUpdate, onError) => {
    const firestore_2 = firestoreRef.current;
    if (!firestore_2 || !userId) throw new Error("Firestore not initialized");
    const subsRef = query(collection(firestore_2, CUSTOMERS_COLLECTION, userId, SUBSCRIPTIONS_COLLECTION), where("metadata.licenseId", "==", licenseId));
    return onSnapshot(subsRef, {
      next: async (snapshot_0) => {
        const updatedSubscriptions_0 = (await Promise.all(snapshot_0.docs.map(convertDocToSubscription))).filter(Boolean);
        onSubscriptionsUpdate(updatedSubscriptions_0);
      },
      error: (error_0) => {
        console.error("Error listening to subscriptions", error_0);
        onError(error_0);
      }
    });
  }, []);
  return {
    licenses,
    licenseLoading,
    licenseLoadingError,
    createLicense,
    updateLicense,
    listenSubscriptionsForLicense
  };
}
function AdminDrawerMenu(t0) {
  const $2 = c_1(15);
  const {
    menuOpen,
    setMenuOpen
  } = t0;
  const {
    drawerHovered,
    drawerOpen
  } = useApp2();
  const navigate = useNavigate();
  const tooltipsOpen = drawerHovered && !drawerOpen && !menuOpen;
  let t1;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(MoreVertIcon2, {});
    $2[0] = t1;
  } else {
    t1 = $2[0];
  }
  let t2;
  if ($2[1] !== tooltipsOpen) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip2, { title: "Admin", open: tooltipsOpen, side: "right", sideOffset: 28, children: t1 });
    $2[1] = tooltipsOpen;
    $2[2] = t2;
  } else {
    t2 = $2[2];
  }
  let t3;
  if ($2[3] !== drawerOpen) {
    t3 = drawerOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls2(drawerOpen ? "opacity-100" : "opacity-0 hidden", "mx-4 font-inherit text-inherit"), children: "ADMIN" });
    $2[3] = drawerOpen;
    $2[4] = t3;
  } else {
    t3 = $2[4];
  }
  let t4;
  if ($2[5] !== t2 || $2[6] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs(IconButton2, { shape: "square", className: "m-4 text-surface-900 dark:text-white w-fit", children: [
      t2,
      t3
    ] });
    $2[5] = t2;
    $2[6] = t3;
    $2[7] = t4;
  } else {
    t4 = $2[7];
  }
  let t5;
  if ($2[8] !== navigate) {
    t5 = ADMIN_VIEWS_CONFIG.map((view, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem2, { onClick: (event) => {
      event.preventDefault();
      navigate(view.path);
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IconForView2, { collectionOrView: view }),
      view.name
    ] }, `navigation_${index2}`));
    $2[8] = navigate;
    $2[9] = t5;
  } else {
    t5 = $2[9];
  }
  let t6;
  if ($2[10] !== menuOpen || $2[11] !== setMenuOpen || $2[12] !== t4 || $2[13] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(Menu2, { open: menuOpen, onOpenChange: setMenuOpen, trigger: t4, children: t5 });
    $2[10] = menuOpen;
    $2[11] = setMenuOpen;
    $2[12] = t4;
    $2[13] = t5;
    $2[14] = t6;
  } else {
    t6 = $2[14];
  }
  return t6;
}
function FireCMSCloudDrawer() {
  const {
    logo
  } = useApp2();
  const {
    drawerHovered,
    drawerOpen,
    closeDrawer
  } = useApp2();
  const navigation = useNavigationController2();
  const collectionEditorController = useCollectionEditorController();
  const {
    user
  } = useAuthController2();
  const [adminMenuOpen, setAdminMenuOpen] = React.useState(false);
  const tooltipsOpen = drawerHovered && !drawerOpen && !adminMenuOpen;
  if (!navigation.topLevelNavigation) throw Error("Navigation not ready in Drawer");
  const {
    navigationEntries,
    groups
  } = navigation.topLevelNavigation;
  const buildGroupHeader = useCallback((group) => {
    if (!drawerOpen) return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full" });
    const reservedGroup = group && RESERVED_GROUPS.includes(group);
    const canCreateCollections = collectionEditorController.configPermissions({
      user
    }).createCollections && !reservedGroup;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pl-6 pr-4 pt-2 pb-2 flex flex-row items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "caption", color: "secondary", className: "flex-grow font-medium", children: group ? group.toUpperCase() : "Views".toUpperCase() }),
      canCreateCollections && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip2, { asChild: true, title: group ? `Create new collection in ${group}` : "Create new collection", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button2, { size: "small", variant: "text", onClick: () => {
        collectionEditorController?.createCollection({
          initialValues: {
            group
          },
          parentCollectionIds: [],
          redirect: true,
          sourceClick: "drawer_new_collection"
        });
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon2, { size: "small" }) }) })
    ] });
  }, [collectionEditorController, drawerOpen]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerLogo2, { logo }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4 flex-grow overflow-scroll no-scrollbar", style: {
      maskImage: "linear-gradient(to bottom, transparent 0, black 20px, black calc(100% - 20px), transparent 100%)"
    }, children: groups.map((group_0) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-surface-50 dark:bg-surface-800 dark:bg-opacity-30 my-4 rounded-lg rounded-lg ml-3 mr-1", children: [
      buildGroupHeader(group_0),
      Object.values(navigationEntries).filter((e) => e.group === group_0).map((view, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerNavigationItem2, { adminMenuOpen, icon: /* @__PURE__ */ jsxRuntimeExports.jsx(IconForView2, { collectionOrView: view.collection ?? view.view }), tooltipsOpen, drawerOpen, url: view.url, name: view.name }, `navigation_${index2}`))
    ] }, `group_${group_0}`)) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AdminDrawerMenu, { menuOpen: adminMenuOpen, setMenuOpen: setAdminMenuOpen })
  ] });
}
function FireCMSDataEnhancementSubscriptionMessage(t0) {
  const $2 = c_1(4);
  const {
    projectId
  } = t0;
  let t1;
  let t2;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "h6", children: "Subscription required" });
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { children: "Please upgrade plans to use this feature in this project" });
    $2[0] = t1;
    $2[1] = t2;
  } else {
    t1 = $2[0];
    t2 = $2[1];
  }
  const t3 = `/p/${projectId}/settings`;
  let t4;
  if ($2[2] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-1 p-1", children: [
      t1,
      t2,
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button2, { color: "primary", component: "a", rel: "noopener noreferrer", target: "_blank", onClick: _temp$9, href: t3, children: "Upgrade plan" })
    ] });
    $2[2] = t3;
    $2[3] = t4;
  } else {
    t4 = $2[3];
  }
  return t4;
}
function _temp$9(e) {
  return e.stopPropagation();
}
function SecurityRulesInstructions(t0) {
  const $2 = c_1(4);
  let t1;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "h4", children: "Security rules" });
    $2[0] = t1;
  } else {
    t1 = $2[0];
  }
  let t2;
  if ($2[1] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { children: [
      "FireCMS uses Firebase security rules to restrict access to data. When creating a new user through FireCMS, the custom claim ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { className: "inline-block bg-white dark:bg-surface-950 px-1 rounded-md", component: "pre", children: "fireCMSUser" }),
      " is added to the user in the client project. By adding the following security rules to your project, you ensure FireCMS users can access data through FireCMS."
    ] });
    $2[1] = t2;
  } else {
    t2 = $2[1];
  }
  let t3;
  if ($2[2] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(Paper2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { component: "pre", className: "m-0 p-4 text-sm font-mono", children: `match /{document=**} {
    allow read, write: if request.auth.token.fireCMSUser;
}` }) });
    $2[2] = t3;
  } else {
    t3 = $2[2];
  }
  let t4;
  if ($2[3] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t1,
      t2,
      t3,
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { variant: "caption", children: [
        "This rules restrict access to data to FireCMS users only, but does ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "not" }),
        " enforce the permissions at the database level."
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "caption", children: "The permissions are enforced in the frontend though, which will work fine for most users. If you need to enforce the permissions at the database level, you can modify these security rules yourself to suit your needs. The roles assigned to a user are set as a custom claim in the Firebase auth token, so you can use them in your security rules." })
    ] });
    $2[3] = t4;
  } else {
    t4 = $2[3];
  }
  return t4;
}
function CloudErrorView(t0) {
  const $2 = c_1(25);
  const {
    error,
    fireCMSBackend,
    onFixed,
    onRetry
  } = t0;
  const {
    code,
    message,
    projectId
  } = error;
  if (code === "service-account-missing" && projectId && fireCMSBackend) {
    let t12;
    if ($2[0] !== fireCMSBackend || $2[1] !== onFixed || $2[2] !== projectId) {
      t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(CloudMissingServiceAccountErrorView, { projectId, fireCMSBackend, onFixed });
      $2[0] = fireCMSBackend;
      $2[1] = onFixed;
      $2[2] = projectId;
      $2[3] = t12;
    } else {
      t12 = $2[3];
    }
    return t12;
  } else {
    if (code === "user-has-to-accept-googles-terms-of-service" && projectId) {
      let t12;
      if ($2[4] !== onFixed || $2[5] !== projectId) {
        t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(CloudNeedsToAcceptTermsErrorView, { projectId, onFixed });
        $2[4] = onFixed;
        $2[5] = projectId;
        $2[6] = t12;
      } else {
        t12 = $2[6];
      }
      return t12;
    } else {
      if (code === "user-has-no-previous-firebase-projects" && projectId) {
        let t12;
        if ($2[7] !== onFixed || $2[8] !== projectId) {
          t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(CloudNoPreviousFirebaseProjectsErrorView, { projectId, onFixed });
          $2[7] = onFixed;
          $2[8] = projectId;
          $2[9] = t12;
        } else {
          t12 = $2[9];
        }
        return t12;
      } else {
        if (code === "firecms-user-not-found") {
          let t12;
          if ($2[10] === Symbol.for("react.memo_cache_sentinel")) {
            t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { children: "The user trying to log in is not registered in the client project." });
            $2[10] = t12;
          } else {
            t12 = $2[10];
          }
          let t22;
          if ($2[11] === Symbol.for("react.memo_cache_sentinel")) {
            t22 = /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "mailto:hello@firecms.co?subject=FireCMS%20login%20error", rel: "noopener noreferrer", target: "_blank", children: "hello@firecms.co " });
            $2[11] = t22;
          } else {
            t22 = $2[11];
          }
          let t32;
          if ($2[12] === Symbol.for("react.memo_cache_sentinel")) {
            t32 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-2 py-4", children: [
              t12,
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { children: [
                "Make sure the user exists in the client project and try again. If the problem persists, reach us at ",
                t22,
                ", or in our ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("a", { rel: "noopener noreferrer", target: "_blank", href: "https://discord.gg/fxy7xsQm3m", children: "Discord channel" }),
                "."
              ] })
            ] });
            $2[12] = t32;
          } else {
            t32 = $2[12];
          }
          return t32;
        } else {
          if (code === "service-account-missing-permissions") {
            const t12 = error.data?.missingPermissions;
            let t22;
            if ($2[13] !== t12) {
              t22 = /* @__PURE__ */ jsxRuntimeExports.jsx(ServiceAccountMissingPermissions, { missingPermissions: t12 });
              $2[13] = t12;
              $2[14] = t22;
            } else {
              t22 = $2[14];
            }
            return t22;
          }
        }
      }
    }
  }
  let t1;
  if ($2[15] !== message) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { className: "text-red-300", children: message });
    $2[15] = message;
    $2[16] = t1;
  } else {
    t1 = $2[16];
  }
  let t2;
  if ($2[17] !== error.data) {
    t2 = error.data && /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "text-xs text-gray-500 p-4", children: JSON.stringify(error.data, null, 2) });
    $2[17] = error.data;
    $2[18] = t2;
  } else {
    t2 = $2[18];
  }
  let t3;
  if ($2[19] !== onRetry) {
    t3 = onRetry && /* @__PURE__ */ jsxRuntimeExports.jsx(Button2, { variant: "outlined", color: "error", onClick: () => onRetry(), children: "Retry" });
    $2[19] = onRetry;
    $2[20] = t3;
  } else {
    t3 = $2[20];
  }
  let t4;
  if ($2[21] !== t1 || $2[22] !== t2 || $2[23] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-2 py-4", children: [
      t1,
      t2,
      t3
    ] });
    $2[21] = t1;
    $2[22] = t2;
    $2[23] = t3;
    $2[24] = t4;
  } else {
    t4 = $2[24];
  }
  return t4;
}
function CloudMissingServiceAccountErrorView(t0) {
  const $2 = c_1(21);
  const {
    fireCMSBackend,
    projectId,
    onFixed
  } = t0;
  const {
    projectsApi
  } = useFireCMSBackend();
  const snackbarController = useSnackbarController2();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [pendingLogin, setPendingLogin] = useState(false);
  let t1;
  if ($2[0] !== fireCMSBackend.googleCredential || $2[1] !== projectId || $2[2] !== projectsApi) {
    t1 = async () => {
      if (!fireCMSBackend.googleCredential?.accessToken) {
        throw new Error("SassMissingServiceAccountErrorView: No access token found");
      }
      setIsSubmitting(true);
      return projectsApi.createServiceAccount(fireCMSBackend.googleCredential.accessToken, projectId).finally(() => setIsSubmitting(false));
    };
    $2[0] = fireCMSBackend.googleCredential;
    $2[1] = projectId;
    $2[2] = projectsApi;
    $2[3] = t1;
  } else {
    t1 = $2[3];
  }
  const doCreateServiceAccount = t1;
  let t2;
  if ($2[4] !== doCreateServiceAccount || $2[5] !== fireCMSBackend.googleCredential?.accessToken || $2[6] !== onFixed || $2[7] !== pendingLogin || $2[8] !== snackbarController) {
    t2 = () => {
      if (pendingLogin && fireCMSBackend.googleCredential?.accessToken) {
        doCreateServiceAccount().then(() => {
          snackbarController.open({
            type: "success",
            message: "Service account created successfully"
          });
          if (onFixed) {
            onFixed();
          }
        }).catch((e) => {
          snackbarController.open({
            type: "error",
            message: "Service account creation error: " + e.message
          });
        });
        setPendingLogin(false);
      }
    };
    $2[4] = doCreateServiceAccount;
    $2[5] = fireCMSBackend.googleCredential?.accessToken;
    $2[6] = onFixed;
    $2[7] = pendingLogin;
    $2[8] = snackbarController;
    $2[9] = t2;
  } else {
    t2 = $2[9];
  }
  const t3 = fireCMSBackend.googleCredential?.accessToken;
  let t4;
  if ($2[10] !== pendingLogin || $2[11] !== t3) {
    t4 = [pendingLogin, t3];
    $2[10] = pendingLogin;
    $2[11] = t3;
    $2[12] = t4;
  } else {
    t4 = $2[12];
  }
  useEffect(t2, t4);
  let t5;
  if ($2[13] !== doCreateServiceAccount || $2[14] !== fireCMSBackend) {
    t5 = async () => {
      const accessToken = fireCMSBackend.googleCredential?.accessToken;
      if (!accessToken) {
        setPendingLogin(true);
        fireCMSBackend.googleLogin(true);
      } else {
        await doCreateServiceAccount();
      }
    };
    $2[13] = doCreateServiceAccount;
    $2[14] = fireCMSBackend;
    $2[15] = t5;
  } else {
    t5 = $2[15];
  }
  const onClick = t5;
  let t6;
  if ($2[16] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { color: "error", children: "Service account missing" });
    $2[16] = t6;
  } else {
    t6 = $2[16];
  }
  let t7;
  if ($2[17] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(BuildIcon2, {});
    $2[17] = t7;
  } else {
    t7 = $2[17];
  }
  let t8;
  if ($2[18] !== isSubmitting || $2[19] !== onClick) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-2 py-4", children: [
      t6,
      /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingButton2, { variant: "outlined", color: "error", onClick, loading: isSubmitting, startIcon: t7, children: "Fix" })
    ] });
    $2[18] = isSubmitting;
    $2[19] = onClick;
    $2[20] = t8;
  } else {
    t8 = $2[20];
  }
  return t8;
}
function CloudNeedsToAcceptTermsErrorView(t0) {
  const $2 = c_1(10);
  const {
    projectId,
    onFixed
  } = t0;
  let t1;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { color: "error", children: "You need to accept Google's terms of service before you can use this service." });
    $2[0] = t1;
  } else {
    t1 = $2[0];
  }
  const t2 = "https://console.cloud.google.com/welcome?project=" + projectId;
  const t3 = `https://console.cloud.google.com/welcome?project=${projectId}`;
  let t4;
  if ($2[1] !== t2 || $2[2] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { color: "error", children: [
      "You can do so by visiting the following link:",
      /* @__PURE__ */ jsxRuntimeExports.jsx("a", { rel: "noopener noreferrer", target: "_blank", href: t2, children: t3 })
    ] });
    $2[1] = t2;
    $2[2] = t3;
    $2[3] = t4;
  } else {
    t4 = $2[3];
  }
  let t5;
  if ($2[4] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(BuildIcon2, {});
    $2[4] = t5;
  } else {
    t5 = $2[4];
  }
  let t6;
  if ($2[5] !== onFixed) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button2, { variant: "outlined", color: "error", onClick: onFixed, startIcon: t5, children: "I have accepted the terms" });
    $2[5] = onFixed;
    $2[6] = t6;
  } else {
    t6 = $2[6];
  }
  let t7;
  if ($2[7] !== t4 || $2[8] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-2 py-4", children: [
      t1,
      t4,
      t6
    ] });
    $2[7] = t4;
    $2[8] = t6;
    $2[9] = t7;
  } else {
    t7 = $2[9];
  }
  return t7;
}
function CloudNoPreviousFirebaseProjectsErrorView(t0) {
  const $2 = c_1(5);
  const {
    onFixed
  } = t0;
  let t1;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { color: "error", children: "You need to accept Firebase's terms of service before you can use this service." });
    $2[0] = t1;
  } else {
    t1 = $2[0];
  }
  let t2;
  if ($2[1] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { color: "error", children: [
      "You can do so by visiting the following link:",
      /* @__PURE__ */ jsxRuntimeExports.jsx("a", { rel: "noopener noreferrer", target: "_blank", href: "https://console.firebase.google.com/", children: "https://console.firebase.google.com/" })
    ] });
    $2[1] = t2;
  } else {
    t2 = $2[1];
  }
  let t3;
  if ($2[2] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(BuildIcon2, {});
    $2[2] = t3;
  } else {
    t3 = $2[2];
  }
  let t4;
  if ($2[3] !== onFixed) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-2 py-4", children: [
      t1,
      t2,
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button2, { variant: "outlined", color: "error", onClick: onFixed, startIcon: t3, children: "I have accepted the terms" })
    ] });
    $2[3] = onFixed;
    $2[4] = t4;
  } else {
    t4 = $2[4];
  }
  return t4;
}
function ServiceAccountMissingPermissions(props) {
  const $2 = c_1(5);
  let t0;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { color: "error", children: "Missing permissions" });
    $2[0] = t0;
  } else {
    t0 = $2[0];
  }
  let t1;
  if ($2[1] !== props.missingPermissions) {
    t1 = props.missingPermissions && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "body2", children: "This service account is missing the following permissions:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "caption", component: "ul", children: props.missingPermissions.map(_temp$8) })
    ] });
    $2[1] = props.missingPermissions;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  let t2;
  if ($2[3] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-2 py-4", children: [
      t0,
      t1
    ] });
    $2[3] = t1;
    $2[4] = t2;
  } else {
    t2 = $2[4];
  }
  return t2;
}
function _temp$8(permission) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: permission }) }, permission);
}
function getPriceString(price) {
  if (price.billing_scheme === "tiered") {
    const firstFlatPrice = price.tiers.find((p) => p.flat_amount);
    if (firstFlatPrice) return "Starting at " + formatPrice(firstFlatPrice.flat_amount, price.currency);
    else return "Billing in " + price.currency;
  }
  return formatPrice(price.unit_amount, price.currency) + " user/" + price.interval;
}
function formatPrice(price, currency) {
  if (currency === "usd") {
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency
    }).format(price / 100);
  }
  return new Intl.NumberFormat("es-ES", {
    style: "currency",
    currency
  }).format(price / 100);
}
function getSubscriptionStatusText(status) {
  if (status === "active") return "Active";
  if (status === "trialing") return "Trialing";
  if (status === "past_due") return "Past due";
  if (status === "canceled") return "Canceled";
  if (status === "unpaid") return "Unpaid";
  if (status === "incomplete") return "Incomplete";
  if (status === "incomplete_expired") return "Incomplete expired";
  return "Unknown";
}
function getSubscriptionPlanName(subscriptionPlan) {
  switch (subscriptionPlan) {
    case "free":
      return "Free";
    case "cloud_plus":
      return "Plus";
    case "pro":
      return "Pro";
  }
}
function PlanChip(t0) {
  const $2 = c_1(3);
  const {
    subscriptionPlan
  } = t0;
  const planName = getSubscriptionPlanName(subscriptionPlan);
  const color = subscriptionPlan === "free" ? "grayLighter" : "blueDark";
  const t1 = planName + " plan";
  let t2;
  if ($2[0] !== color || $2[1] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Chip2, { className: "uppercase font-medium", colorScheme: color, size: "small", children: t1 });
    $2[0] = color;
    $2[1] = t1;
    $2[2] = t2;
  } else {
    t2 = $2[2];
  }
  return t2;
}
function CurrentSubscriptionView$1(t0) {
  const $2 = c_1(39);
  const {
    subscription
  } = t0;
  const {
    projectsApi
  } = useFireCMSBackend();
  let t1;
  if ($2[0] !== subscription.status) {
    t1 = getSubscriptionStatusText(subscription.status);
    $2[0] = subscription.status;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  const statusText = t1;
  const [stripePortalUrl, setStripePortalUrl] = useState(void 0);
  let t2;
  if ($2[2] !== projectsApi || $2[3] !== stripePortalUrl || $2[4] !== subscription.id) {
    t2 = () => {
      if (!stripePortalUrl) {
        projectsApi.getStripeCancelLinkForSubscription(subscription.id).then(setStripePortalUrl);
      }
    };
    $2[2] = projectsApi;
    $2[3] = stripePortalUrl;
    $2[4] = subscription.id;
    $2[5] = t2;
  } else {
    t2 = $2[5];
  }
  let t3;
  if ($2[6] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = [];
    $2[6] = t3;
  } else {
    t3 = $2[6];
  }
  useEffect(t2, t3);
  let t4;
  if ($2[7] !== subscription.product.name) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { className: "flex-grow", variant: "h6", children: subscription.product.name });
    $2[7] = subscription.product.name;
    $2[8] = t4;
  } else {
    t4 = $2[8];
  }
  const t5 = statusText === "Active" ? "greenDark" : "orangeDark";
  let t6;
  if ($2[9] !== statusText || $2[10] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(Chip2, { size: "small", colorScheme: t5, children: statusText });
    $2[9] = statusText;
    $2[10] = t5;
    $2[11] = t6;
  } else {
    t6 = $2[11];
  }
  let t7;
  if ($2[12] !== t4 || $2[13] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
      t4,
      t6
    ] });
    $2[12] = t4;
    $2[13] = t6;
    $2[14] = t7;
  } else {
    t7 = $2[14];
  }
  let t8;
  if ($2[15] !== subscription.metadata.projectId) {
    t8 = subscription.metadata.projectId && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { children: [
      "Project: ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: subscription.metadata.projectId })
    ] });
    $2[15] = subscription.metadata.projectId;
    $2[16] = t8;
  } else {
    t8 = $2[16];
  }
  let t9;
  if ($2[17] !== subscription.metadata.licenseId) {
    t9 = subscription.metadata.licenseId && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { children: [
      "License: ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: subscription.metadata.licenseId })
    ] });
    $2[17] = subscription.metadata.licenseId;
    $2[18] = t9;
  } else {
    t9 = $2[18];
  }
  let t10;
  if ($2[19] !== subscription.price) {
    t10 = subscription.price && /* @__PURE__ */ jsxRuntimeExports.jsx(Chip2, { size: "small", children: getPriceString(subscription.price) });
    $2[19] = subscription.price;
    $2[20] = t10;
  } else {
    t10 = $2[20];
  }
  let t11;
  if ($2[21] !== subscription.cancel_at) {
    t11 = subscription.cancel_at && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { variant: "caption", className: "text-secondary", children: [
      "This subscription was ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: "cancelled" }),
      " and will be active until ",
      subscription.cancel_at.toDate().toLocaleDateString()
    ] });
    $2[21] = subscription.cancel_at;
    $2[22] = t11;
  } else {
    t11 = $2[22];
  }
  let t12;
  if ($2[23] !== t10 || $2[24] !== t11 || $2[25] !== t8 || $2[26] !== t9) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-grow flex flex-col items-start gap-2", children: [
      t8,
      t9,
      t10,
      t11
    ] });
    $2[23] = t10;
    $2[24] = t11;
    $2[25] = t8;
    $2[26] = t9;
    $2[27] = t12;
  } else {
    t12 = $2[27];
  }
  const t13 = " " + subscription.canceled_at ? void 0 : "text-text-secondary dark:text-text-secondary-dark";
  const t14 = subscription.canceled_at ? "Renew" : "Manage";
  let t15;
  if ($2[28] !== stripePortalUrl || $2[29] !== t13 || $2[30] !== t14) {
    t15 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button2, { component: "a", variant: "text", className: t13, size: "small", href: stripePortalUrl, target: "_blank", rel: "noreferrer", children: t14 });
    $2[28] = stripePortalUrl;
    $2[29] = t13;
    $2[30] = t14;
    $2[31] = t15;
  } else {
    t15 = $2[31];
  }
  let t16;
  if ($2[32] !== t12 || $2[33] !== t15) {
    t16 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex mt-2 items-center", children: [
      t12,
      t15
    ] });
    $2[32] = t12;
    $2[33] = t15;
    $2[34] = t16;
  } else {
    t16 = $2[34];
  }
  let t17;
  if ($2[35] !== subscription.id || $2[36] !== t16 || $2[37] !== t7) {
    t17 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper2, { className: "mt-2 mb-2 p-4 -mx-2", children: [
      t7,
      t16
    ] }, subscription.id);
    $2[35] = subscription.id;
    $2[36] = t16;
    $2[37] = t7;
    $2[38] = t17;
  } else {
    t17 = $2[38];
  }
  return t17;
}
function ActiveSubscriptions(t0) {
  const $2 = c_1(6);
  const {
    activeSubscriptions
  } = t0;
  let t1;
  let t2;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = cls2("my-8");
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { className: "my-4 mt-8 font-medium uppercase", children: "Active Subscriptions" });
    $2[0] = t1;
    $2[1] = t2;
  } else {
    t1 = $2[0];
    t2 = $2[1];
  }
  let t3;
  if ($2[2] !== activeSubscriptions) {
    t3 = activeSubscriptions.map(_temp$7);
    $2[2] = activeSubscriptions;
    $2[3] = t3;
  } else {
    t3 = $2[3];
  }
  let t4;
  if ($2[4] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t1, children: [
      t2,
      t3
    ] });
    $2[4] = t3;
    $2[5] = t4;
  } else {
    t4 = $2[5];
  }
  return t4;
}
function _temp$7(subscription) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CurrentSubscriptionView$1, { subscription }, subscription.id);
}
function AppCheckSettingsView() {
  const $2 = c_1(40);
  const projectConfig = useProjectConfig();
  const isInFreePlan = projectConfig.subscriptionPlan === "free";
  const snackbarController = useSnackbarController2();
  const [enabled, setEnabled] = useState(Boolean(projectConfig.appCheck));
  const [provider, setProvider] = useState(projectConfig.serializedAppCheck?.provider ?? null);
  const [siteKey, setSiteKey] = useState(projectConfig.serializedAppCheck?.siteKey ?? null);
  let t0;
  if ($2[0] !== enabled || $2[1] !== projectConfig || $2[2] !== provider || $2[3] !== siteKey || $2[4] !== snackbarController) {
    t0 = () => {
      console.log("Saving app check", enabled, provider, siteKey);
      if (enabled && provider && siteKey) {
        try {
          projectConfig.updateAppCheck({
            provider,
            siteKey
          });
          snackbarController.open({
            message: "AppCheck updated",
            type: "success"
          });
        } catch (t110) {
          snackbarController.open({
            message: "Error updating AppCheck",
            type: "error"
          });
        }
      } else {
        projectConfig.updateAppCheck(null);
      }
    };
    $2[0] = enabled;
    $2[1] = projectConfig;
    $2[2] = provider;
    $2[3] = siteKey;
    $2[4] = snackbarController;
    $2[5] = t0;
  } else {
    t0 = $2[5];
  }
  const saveAppCheck = t0;
  let t1;
  if ($2[6] !== saveAppCheck) {
    t1 = (e_0) => {
      e_0.preventDefault();
      saveAppCheck();
    };
    $2[6] = saveAppCheck;
    $2[7] = t1;
  } else {
    t1 = $2[7];
  }
  let t2;
  if ($2[8] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "h4", children: "AppCheck" });
    $2[8] = t2;
  } else {
    t2 = $2[8];
  }
  let t3;
  if ($2[9] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = ["free"];
    $2[9] = t3;
  } else {
    t3 = $2[9];
  }
  let t4;
  if ($2[10] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(SubscriptionPlanWidget, { showForPlans: t3, message: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      "Upgrade to ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: "PLUS" }),
      " to enable AppCheck"
    ] }) });
    $2[10] = t4;
  } else {
    t4 = $2[10];
  }
  let t5;
  if ($2[11] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { children: [
      "You can enable AppCheck to protect your Firebase services from abuse. Check how to configure it in the ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://firebase.google.com/docs/app-check", children: "Firebase documentation" }),
      ". When you have a provider set, you can enable it here. You will need to provide a secret in your Firebase project settings, and a site key in the FireCMS config."
    ] });
    $2[11] = t5;
  } else {
    t5 = $2[11];
  }
  let t6;
  if ($2[12] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { children: [
      "Remember to add the domain ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: window.location.origin }),
      " to your provider allowed domains"
    ] });
    $2[12] = t6;
  } else {
    t6 = $2[12];
  }
  let t7;
  if ($2[13] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = (value) => {
      setEnabled(value);
    };
    $2[13] = t7;
  } else {
    t7 = $2[13];
  }
  let t8;
  if ($2[14] !== enabled || $2[15] !== isInFreePlan) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanSwitchWithLabel2, { value: enabled, position: "start", size: "small", disabled: isInFreePlan, label: "Enable AppCheck", onValueChange: t7 });
    $2[14] = enabled;
    $2[15] = isInFreePlan;
    $2[16] = t8;
  } else {
    t8 = $2[16];
  }
  const t9 = !enabled;
  const t10 = provider ?? void 0;
  let t11;
  if ($2[17] === Symbol.for("react.memo_cache_sentinel")) {
    t11 = (value_0) => {
      setProvider(value_0);
    };
    $2[17] = t11;
  } else {
    t11 = $2[17];
  }
  let t12;
  if ($2[18] === Symbol.for("react.memo_cache_sentinel")) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Label2, { className: "flex items-center gap-2", htmlFor: "recaptcha_v3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupItem2, { id: "recaptcha_v3", value: "recaptcha_v3" }),
      "ReCaptcha V3"
    ] });
    $2[18] = t12;
  } else {
    t12 = $2[18];
  }
  let t13;
  if ($2[19] === Symbol.for("react.memo_cache_sentinel")) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Label2, { className: "flex items-center gap-2", htmlFor: "recaptcha_enterprise", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupItem2, { id: "recaptcha_enterprise", value: "recaptcha_enterprise" }),
      "ReCaptcha Enterprise"
    ] });
    $2[19] = t13;
  } else {
    t13 = $2[19];
  }
  let t14;
  if ($2[20] !== t10 || $2[21] !== t9) {
    t14 = /* @__PURE__ */ jsxRuntimeExports.jsxs(RadioGroup2, { disabled: t9, className: "grow shrink-0", value: t10, onValueChange: t11, children: [
      t12,
      t13
    ] });
    $2[20] = t10;
    $2[21] = t9;
    $2[22] = t14;
  } else {
    t14 = $2[22];
  }
  const t15 = siteKey ?? "";
  let t16;
  if ($2[23] === Symbol.for("react.memo_cache_sentinel")) {
    t16 = (e_1) => setSiteKey(e_1.target.value);
    $2[23] = t16;
  } else {
    t16 = $2[23];
  }
  const t17 = !enabled;
  let t18;
  if ($2[24] !== t15 || $2[25] !== t17) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsx(TextField2, { label: "Site key", className: "w-full", value: t15, onChange: t16, disabled: t17 });
    $2[24] = t15;
    $2[25] = t17;
    $2[26] = t18;
  } else {
    t18 = $2[26];
  }
  let t19;
  if ($2[27] !== t14 || $2[28] !== t18) {
    t19 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row gap-4", children: [
      t14,
      t18
    ] });
    $2[27] = t14;
    $2[28] = t18;
    $2[29] = t19;
  } else {
    t19 = $2[29];
  }
  let t20;
  if ($2[30] !== isInFreePlan) {
    t20 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button2, { variant: "outlined", disabled: isInFreePlan, type: "submit", children: "Update AppCheck" });
    $2[30] = isInFreePlan;
    $2[31] = t20;
  } else {
    t20 = $2[31];
  }
  let t21;
  if ($2[32] === Symbol.for("react.memo_cache_sentinel")) {
    t21 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "caption", children: "You might need to refresh the page to see the changes, after saving." });
    $2[32] = t21;
  } else {
    t21 = $2[32];
  }
  let t22;
  if ($2[33] !== t19 || $2[34] !== t20) {
    t22 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper2, { className: "p-4 flex flex-col gap-4", children: [
      t19,
      t20,
      t21
    ] });
    $2[33] = t19;
    $2[34] = t20;
    $2[35] = t22;
  } else {
    t22 = $2[35];
  }
  let t23;
  if ($2[36] !== t1 || $2[37] !== t22 || $2[38] !== t8) {
    t23 = /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { className: "flex flex-col gap-4", onSubmit: t1, children: [
      t2,
      t4,
      t5,
      t6,
      t8,
      t22
    ] });
    $2[36] = t1;
    $2[37] = t22;
    $2[38] = t8;
    $2[39] = t23;
  } else {
    t23 = $2[39];
  }
  return t23;
}
function ProjectSettings() {
  const $2 = c_1(17);
  const {
    backendUid
  } = useFireCMSBackend();
  const projectConfig = useProjectConfig();
  useBrowserTitleAndIcon2("Project settings");
  if (!backendUid) {
    throw new Error("No backendUid in ProjectSettings");
  }
  let t0;
  if ($2[0] !== backendUid) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(ProjectSubscriptionPlans, { uid: backendUid });
    $2[0] = backendUid;
    $2[1] = t0;
  } else {
    t0 = $2[1];
  }
  let t1;
  let t2;
  if ($2[2] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "h4", className: "mt-4 mb-2", children: "Settings" });
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(ProjectNameTextField, {});
    $2[2] = t1;
    $2[3] = t2;
  } else {
    t1 = $2[2];
    t2 = $2[3];
  }
  let t3;
  if ($2[4] !== projectConfig) {
    t3 = (v2) => projectConfig.updateLocalTextSearchEnabled(v2);
    $2[4] = projectConfig;
    $2[5] = t3;
  } else {
    t3 = $2[5];
  }
  let t4;
  if ($2[6] !== projectConfig.localTextSearchEnabled || $2[7] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanSwitchWithLabel2, { position: "start", label: "Enable local text search", onValueChange: t3, value: projectConfig.localTextSearchEnabled }) });
    $2[6] = projectConfig.localTextSearchEnabled;
    $2[7] = t3;
    $2[8] = t4;
  } else {
    t4 = $2[8];
  }
  let t5;
  if ($2[9] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeColors, {});
    $2[9] = t5;
  } else {
    t5 = $2[9];
  }
  let t6;
  if ($2[10] !== t4) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2", children: [
      t1,
      t2,
      t4,
      t5
    ] });
    $2[10] = t4;
    $2[11] = t6;
  } else {
    t6 = $2[11];
  }
  let t7;
  let t8;
  if ($2[12] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SecurityRulesInstructions, {}) });
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(AppCheckSettingsView, {});
    $2[12] = t7;
    $2[13] = t8;
  } else {
    t7 = $2[12];
    t8 = $2[13];
  }
  let t9;
  if ($2[14] !== t0 || $2[15] !== t6) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Container2, { maxWidth: "6xl", className: "w-full flex flex-col gap-16 px-4 py-16", children: [
      t0,
      t6,
      t7,
      t8
    ] });
    $2[14] = t0;
    $2[15] = t6;
    $2[16] = t9;
  } else {
    t9 = $2[16];
  }
  return t9;
}
function ProjectNameTextField() {
  const $2 = c_1(12);
  const projectConfig = useProjectConfig();
  const [name, setName] = useState(projectConfig.projectName ?? "");
  const deferredName = useDeferredValue(name);
  let t0;
  if ($2[0] !== deferredName || $2[1] !== projectConfig) {
    t0 = () => {
      if (deferredName) {
        projectConfig.updateProjectName(deferredName);
      }
    };
    $2[0] = deferredName;
    $2[1] = projectConfig;
    $2[2] = t0;
  } else {
    t0 = $2[2];
  }
  let t1;
  if ($2[3] !== deferredName) {
    t1 = [deferredName];
    $2[3] = deferredName;
    $2[4] = t1;
  } else {
    t1 = $2[4];
  }
  useEffect(t0, t1);
  let t2;
  if ($2[5] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = (e) => setName(e.target.value);
    $2[5] = t2;
  } else {
    t2 = $2[5];
  }
  let t3;
  if ($2[6] !== name || $2[7] !== projectConfig) {
    t3 = () => {
      if (name) {
        projectConfig.updateProjectName(name);
      }
    };
    $2[6] = name;
    $2[7] = projectConfig;
    $2[8] = t3;
  } else {
    t3 = $2[8];
  }
  let t4;
  if ($2[9] !== name || $2[10] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(TextField2, { value: name, label: "Project name", onChange: t2, onBlur: t3 });
    $2[9] = name;
    $2[10] = t3;
    $2[11] = t4;
  } else {
    t4 = $2[11];
  }
  return t4;
}
function LogoUploadField(t0) {
  const $2 = c_1(18);
  const {
    onNoSubscriptionPlan
  } = t0;
  const {
    logo,
    canModifyTheme,
    uploadLogo
  } = useProjectConfig();
  const snackbarContext = useSnackbarController2();
  let t1;
  if ($2[0] !== canModifyTheme || $2[1] !== onNoSubscriptionPlan || $2[2] !== uploadLogo) {
    t1 = async (acceptedFiles) => {
      if (!canModifyTheme) {
        onNoSubscriptionPlan();
        return;
      }
      if (!acceptedFiles.length) {
        return;
      }
      uploadLogo(acceptedFiles[0]);
    };
    $2[0] = canModifyTheme;
    $2[1] = onNoSubscriptionPlan;
    $2[2] = uploadLogo;
    $2[3] = t1;
  } else {
    t1 = $2[3];
  }
  const onFilesAdded = t1;
  let t2;
  if ($2[4] !== canModifyTheme || $2[5] !== onNoSubscriptionPlan || $2[6] !== snackbarContext) {
    t2 = (fileRejections, event) => {
      if (!canModifyTheme) {
        onNoSubscriptionPlan();
      } else {
        for (const fileRejection of fileRejections) {
          for (const error of fileRejection.errors) {
            snackbarContext.open({
              type: "error",
              message: `Error uploading file: ${error.message}`
            });
          }
        }
      }
    };
    $2[4] = canModifyTheme;
    $2[5] = onNoSubscriptionPlan;
    $2[6] = snackbarContext;
    $2[7] = t2;
  } else {
    t2 = $2[7];
  }
  const onFilesRejected = t2;
  let t3;
  if ($2[8] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = {
      "*/image": []
    };
    $2[8] = t3;
  } else {
    t3 = $2[8];
  }
  let t4;
  if ($2[9] !== logo) {
    t4 = logo && /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "w-40 h-40 p-4", src: logo });
    $2[9] = logo;
    $2[10] = t4;
  } else {
    t4 = $2[10];
  }
  let t5;
  if ($2[11] !== logo) {
    t5 = !logo && /* @__PURE__ */ jsxRuntimeExports.jsx(FireCMSLogo2, { className: "w-40 h-40 p-4" });
    $2[11] = logo;
    $2[12] = t5;
  } else {
    t5 = $2[12];
  }
  let t6;
  if ($2[13] !== onFilesAdded || $2[14] !== onFilesRejected || $2[15] !== t4 || $2[16] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs(FileUpload2, { size: "large", accept: t3, maxSize: 2097152, onFilesAdded, onFilesRejected, uploadDescription: "Drag and drop your logo here", children: [
      t4,
      t5
    ] });
    $2[13] = onFilesAdded;
    $2[14] = onFilesRejected;
    $2[15] = t4;
    $2[16] = t5;
    $2[17] = t6;
  } else {
    t6 = $2[17];
  }
  return t6;
}
function SampleComponents() {
  const $2 = c_1(5);
  const [checked, setChecked] = useState(true);
  let t0;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "label", children: "Sample theme components" });
    $2[0] = t0;
  } else {
    t0 = $2[0];
  }
  let t1;
  let t2;
  if ($2[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button2, { children: " Button " });
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button2, { variant: "outlined", children: " Button " });
    $2[1] = t1;
    $2[2] = t2;
  } else {
    t1 = $2[1];
    t2 = $2[2];
  }
  let t3;
  if ($2[3] !== checked) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 mt-4 flex flex-col items-center gap-2", children: [
      t0,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row gap-4 items-center justify-center", children: [
        t1,
        t2,
        /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanSwitch2, { value: checked, onValueChange: setChecked }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox2, { checked, onCheckedChange: setChecked }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox2, { color: "secondary", checked, onCheckedChange: setChecked })
      ] })
    ] });
    $2[3] = checked;
    $2[4] = t3;
  } else {
    t3 = $2[4];
  }
  return t3;
}
function ThemeColors() {
  const $2 = c_1(29);
  const [showUpgradeBanner, setShowUpgradeBanner] = useState(false);
  const projectConfig = useProjectConfig();
  let t0;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "h4", className: "mt-4 mb-2", children: "Theme" });
    $2[0] = t0;
  } else {
    t0 = $2[0];
  }
  let t1;
  if ($2[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12 md:col-span-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LogoUploadField, { onNoSubscriptionPlan: () => setShowUpgradeBanner(true) }) });
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  let t2;
  if ($2[2] !== projectConfig) {
    t2 = (e) => {
      setShowUpgradeBanner(true);
      return projectConfig.updatePrimaryColor(e.target.value);
    };
    $2[2] = projectConfig;
    $2[3] = t2;
  } else {
    t2 = $2[3];
  }
  let t3;
  if ($2[4] !== projectConfig.primaryColor || $2[5] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "color", value: projectConfig.primaryColor, onChange: t2 });
    $2[4] = projectConfig.primaryColor;
    $2[5] = t2;
    $2[6] = t3;
  } else {
    t3 = $2[6];
  }
  let t4;
  if ($2[7] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "subtitle2", children: "Primary color" });
    $2[7] = t4;
  } else {
    t4 = $2[7];
  }
  let t5;
  if ($2[8] !== t3) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row gap-2", children: [
      t3,
      t4
    ] });
    $2[8] = t3;
    $2[9] = t5;
  } else {
    t5 = $2[9];
  }
  let t6;
  if ($2[10] !== projectConfig) {
    t6 = (e_0) => {
      setShowUpgradeBanner(true);
      return projectConfig.updateSecondaryColor(e_0.target.value);
    };
    $2[10] = projectConfig;
    $2[11] = t6;
  } else {
    t6 = $2[11];
  }
  let t7;
  if ($2[12] !== projectConfig.secondaryColor || $2[13] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "color", value: projectConfig.secondaryColor, onChange: t6 });
    $2[12] = projectConfig.secondaryColor;
    $2[13] = t6;
    $2[14] = t7;
  } else {
    t7 = $2[14];
  }
  let t8;
  if ($2[15] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "subtitle2", children: "Secondary color" });
    $2[15] = t8;
  } else {
    t8 = $2[15];
  }
  let t9;
  if ($2[16] !== t7) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row gap-2", children: [
      t7,
      t8
    ] });
    $2[16] = t7;
    $2[17] = t9;
  } else {
    t9 = $2[17];
  }
  let t10;
  if ($2[18] !== t5 || $2[19] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row gap-4 justify-center mt-4", children: [
      t5,
      t9
    ] });
    $2[18] = t5;
    $2[19] = t9;
    $2[20] = t10;
  } else {
    t10 = $2[20];
  }
  let t11;
  if ($2[21] === Symbol.for("react.memo_cache_sentinel")) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx(SampleComponents, {});
    $2[21] = t11;
  } else {
    t11 = $2[21];
  }
  let t12;
  if ($2[22] !== t10) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-12 gap-4", children: [
      t1,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12 md:col-span-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper2, { className: "flex flex-col gap-2 p-4", children: [
        t10,
        t11
      ] }) })
    ] });
    $2[22] = t10;
    $2[23] = t12;
  } else {
    t12 = $2[23];
  }
  let t13;
  if ($2[24] !== showUpgradeBanner) {
    t13 = showUpgradeBanner && /* @__PURE__ */ jsxRuntimeExports.jsx(SubscriptionPlanWidget, { showForPlans: ["free"], includeTooManyUsersAlert: true, message: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      "Upgrade to ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: "PLUS" }),
      " to customise the logo and colors"
    ] }) });
    $2[24] = showUpgradeBanner;
    $2[25] = t13;
  } else {
    t13 = $2[25];
  }
  let t14;
  if ($2[26] !== t12 || $2[27] !== t13) {
    t14 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2 mt-4 mb-2", children: [
      t0,
      t12,
      t13
    ] });
    $2[26] = t12;
    $2[27] = t13;
    $2[28] = t14;
  } else {
    t14 = $2[28];
  }
  return t14;
}
function SubscriptionPriceSelect(t0) {
  const $2 = c_1(6);
  const {
    productPrices,
    setSelectedPrice,
    largePriceLabel,
    selectedPrice,
    fullWidth: t1
  } = t0;
  const fullWidth = t1 === void 0 ? true : t1;
  let t2;
  if ($2[0] !== fullWidth || $2[1] !== largePriceLabel || $2[2] !== productPrices || $2[3] !== selectedPrice?.id || $2[4] !== setSelectedPrice) {
    t2 = (productPrices ?? [])?.length > 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Select2, { size: "medium", invisible: true, padding: false, fullWidth: false, onChange: (e) => {
      setSelectedPrice((productPrices ?? []).find((price) => price.id === e.target.value));
    }, className: fullWidth ? "w-full" : "w-fit", position: "item-aligned", renderValue: (value) => {
      const price_1 = (productPrices ?? []).find((price_0) => price_0.id === value);
      if (!price_1) {
        return null;
      }
      if (largePriceLabel) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-4 mb-4 text-2xl font-bold text-primary text-center my-8", children: getPriceString(price_1) });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Chip2, { children: price_1 ? getPriceString(price_1) : "" });
    }, value: selectedPrice?.id ?? "", children: productPrices && productPrices.map(_temp$6) }) }) : productPrices ? largePriceLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-4 mb-4 text-2xl font-bold text-primary text-center my-8", children: getPriceString(productPrices[0]) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Chip2, { size: "medium", children: getPriceString(productPrices[0]) }) : null;
    $2[0] = fullWidth;
    $2[1] = largePriceLabel;
    $2[2] = productPrices;
    $2[3] = selectedPrice?.id;
    $2[4] = setSelectedPrice;
    $2[5] = t2;
  } else {
    t2 = $2[5];
  }
  return t2;
}
function _temp$6(price_2) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem2, { value: price_2.id, children: getPriceString(price_2) }, price_2.id);
}
function ProductUpgradeSmallView(t0) {
  const $2 = c_1(29);
  const {
    product,
    includePriceSelect: t1,
    includePriceLabel: t2,
    largePriceLabel: t3,
    subscribe,
    projectId
  } = t0;
  const includePriceSelect = t1 === void 0 ? true : t1;
  const includePriceLabel = t2 === void 0 ? true : t2;
  const largePriceLabel = t3 === void 0 ? false : t3;
  const [error, setError] = useState();
  const [selectedPrice, setSelectedPrice] = useState();
  const productPrices = product.prices;
  let t4;
  let t5;
  if ($2[0] !== productPrices) {
    t4 = () => {
      if (productPrices.length > 0) {
        setSelectedPrice(productPrices[0]);
      }
    };
    t5 = [productPrices];
    $2[0] = productPrices;
    $2[1] = t4;
    $2[2] = t5;
  } else {
    t4 = $2[1];
    t5 = $2[2];
  }
  useEffect(t4, t5);
  if (product.metadata.type !== "pro" && product.metadata.type !== "cloud_plus") {
    throw new Error("Error: Unmapped product type in ProductView");
  }
  let t6;
  if ($2[3] !== product.metadata.type) {
    t6 = getSubscriptionPlanName(product.metadata.type);
    $2[3] = product.metadata.type;
    $2[4] = t6;
  } else {
    t6 = $2[4];
  }
  const planName = t6;
  let t7;
  if ($2[5] !== largePriceLabel || $2[6] !== productPrices || $2[7] !== selectedPrice) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(SubscriptionPriceSelect, { productPrices, selectedPrice, setSelectedPrice, largePriceLabel });
    $2[5] = largePriceLabel;
    $2[6] = productPrices;
    $2[7] = selectedPrice;
    $2[8] = t7;
  } else {
    t7 = $2[8];
  }
  const priceSelect = t7;
  const [linkLoading, setLinkLoading] = useState(false);
  let t8;
  if ($2[9] !== product.metadata.type || $2[10] !== projectId || $2[11] !== selectedPrice || $2[12] !== subscribe) {
    t8 = () => {
      if (!projectId || selectedPrice === void 0) {
        return;
      }
      setLinkLoading(true);
      return subscribe({
        projectId,
        productPrice: selectedPrice,
        onCheckoutSessionReady: (url, error_0) => {
          if (!url && !error_0) {
            return;
          }
          if (error_0) {
            setError(error_0);
          }
          if (url) {
            if (typeof window !== "undefined") {
              window.location.assign(url);
            }
          }
          setLinkLoading(false);
        },
        type: product.metadata.type
      });
    };
    $2[9] = product.metadata.type;
    $2[10] = projectId;
    $2[11] = selectedPrice;
    $2[12] = subscribe;
    $2[13] = t8;
  } else {
    t8 = $2[13];
  }
  const doSubscribe = t8;
  let t9;
  if ($2[14] !== includePriceLabel || $2[15] !== includePriceSelect || $2[16] !== priceSelect) {
    t9 = includePriceSelect && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      includePriceLabel && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "my-2 flex items-center gap-2", children: [
        "You can upgrade your project for ",
        priceSelect
      ] }),
      !includePriceLabel && priceSelect
    ] });
    $2[14] = includePriceLabel;
    $2[15] = includePriceSelect;
    $2[16] = priceSelect;
    $2[17] = t9;
  } else {
    t9 = $2[17];
  }
  let t10;
  if ($2[18] === Symbol.for("react.memo_cache_sentinel")) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(RocketLaunchIcon2, {});
    $2[18] = t10;
  } else {
    t10 = $2[18];
  }
  let t11;
  if ($2[19] !== doSubscribe || $2[20] !== linkLoading || $2[21] !== planName) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs(LoadingButton2, { variant: "filled", loading: linkLoading, onClick: doSubscribe, startIcon: t10, children: [
      "Upgrade to ",
      planName
    ] });
    $2[19] = doSubscribe;
    $2[20] = linkLoading;
    $2[21] = planName;
    $2[22] = t11;
  } else {
    t11 = $2[22];
  }
  let t12;
  if ($2[23] !== error) {
    t12 = error && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert2, { color: "error", className: "my-4", children: error.message });
    $2[23] = error;
    $2[24] = t12;
  } else {
    t12 = $2[24];
  }
  let t13;
  if ($2[25] !== t11 || $2[26] !== t12 || $2[27] !== t9) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t9,
      t11,
      t12
    ] });
    $2[25] = t11;
    $2[26] = t12;
    $2[27] = t9;
    $2[28] = t13;
  } else {
    t13 = $2[28];
  }
  return t13;
}
function UpgradeToPlusButton(t0) {
  const $2 = c_1(10);
  const {
    includePriceSelect,
    includePriceLabel,
    largePriceLabel
  } = t0;
  const {
    subscriptionPlan,
    projectId
  } = useProjectConfig();
  if (!subscriptionPlan) {
    throw new Error("No subscription plan");
  }
  const {
    products,
    subscribe
  } = useSubscriptionsForUserController();
  let t1;
  if ($2[0] !== products) {
    t1 = products?.find(_temp$5);
    $2[0] = products;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  const plusProduct = t1;
  if (!plusProduct) {
    let t22;
    if ($2[2] === Symbol.for("react.memo_cache_sentinel")) {
      t22 = /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingButton2, { variant: "filled", loading: true, startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(RocketLaunchIcon2, {}), children: "Upgrade to PLUS" });
      $2[2] = t22;
    } else {
      t22 = $2[2];
    }
    return t22;
  }
  let t2;
  if ($2[3] !== includePriceLabel || $2[4] !== includePriceSelect || $2[5] !== largePriceLabel || $2[6] !== plusProduct || $2[7] !== projectId || $2[8] !== subscribe) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(ProductUpgradeSmallView, { includePriceSelect, includePriceLabel, largePriceLabel, product: plusProduct, projectId, subscribe });
    $2[3] = includePriceLabel;
    $2[4] = includePriceSelect;
    $2[5] = largePriceLabel;
    $2[6] = plusProduct;
    $2[7] = projectId;
    $2[8] = subscribe;
    $2[9] = t2;
  } else {
    t2 = $2[9];
  }
  return t2;
}
function _temp$5(p) {
  return p.metadata?.type === "cloud_plus";
}
function PlansComparisonDialog(t0) {
  const $2 = c_1(11);
  const {
    open,
    onClose
  } = t0;
  useNavigationController2();
  useNavigate();
  let t1;
  if ($2[0] !== onClose) {
    t1 = (open_0) => !open_0 ? onClose() : void 0;
    $2[0] = onClose;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  let t2;
  if ($2[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle2, { hidden: true, children: "Plans comparison" });
    $2[2] = t2;
  } else {
    t2 = $2[2];
  }
  let t3;
  if ($2[3] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent2, { fullHeight: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PlansComparison, {}) });
    $2[3] = t3;
  } else {
    t3 = $2[3];
  }
  let t4;
  if ($2[4] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon2, {});
    $2[4] = t4;
  } else {
    t4 = $2[4];
  }
  let t5;
  if ($2[5] !== onClose) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton2, { className: "absolute top-4 right-4", onClick: onClose, children: t4 });
    $2[5] = onClose;
    $2[6] = t5;
  } else {
    t5 = $2[6];
  }
  let t6;
  if ($2[7] !== open || $2[8] !== t1 || $2[9] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog2, { fullScreen: true, open, onOpenChange: t1, children: [
      t2,
      t3,
      t5
    ] });
    $2[7] = open;
    $2[8] = t1;
    $2[9] = t5;
    $2[10] = t6;
  } else {
    t6 = $2[10];
  }
  return t6;
}
function PlansComparison() {
  const $2 = c_1(11);
  let t0;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl md:text-4xl font-bold text-center text-surface-800 dark:text-surface-200 uppercase my-3", children: "Free" });
    $2[0] = t0;
  } else {
    t0 = $2[0];
  }
  let t1;
  if ($2[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grow", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-lg mb-4 text-center font-semibold", children: "Try FireCMS and upgrade to a paid plan when you need more features." }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "Unlimited projects" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "Unlimited collections" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "All available form fields" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "Schema editor and data inference" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "Advanced data import and export" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "Default roles" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "3 users" })
      ] })
    ] });
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  let t2;
  if ($2[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "h-full max-w-sm p-6 border border-solid border-surface-200 rounded-lg shadow dark:border-surface-700 flex flex-col", children: [
      t0,
      t1,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center mt-4 text-surface-600 dark:text-surface-400 w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-2xl font-bold ", children: "0 user/month" }) })
    ] });
    $2[2] = t2;
  } else {
    t2 = $2[2];
  }
  const freeTier = t2;
  let t3;
  if ($2[3] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl md:text-4xl font-bold text-center dark:text-primary text-primary uppercase my-3", children: "Plus" });
    $2[3] = t3;
  } else {
    t3 = $2[3];
  }
  let t4;
  if ($2[4] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grow", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-lg mb-4 text-center font-semibold", children: "Perfect for startups" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "Everything in the free tier" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "Local text search" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "Secondary databases" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "Unlimited users and roles" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "Unlimited data export" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "Theme and logo customization" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "Custom user roles" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "GPT-4 content generation" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "AppCheck" })
      ] })
    ] });
    $2[4] = t4;
  } else {
    t4 = $2[4];
  }
  let t5;
  if ($2[5] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "h-full max-w-sm p-6 rounded-lg flex flex-col outline-none ring-2 ring-primary ring-opacity-75 ring-offset-2 ring-offset-transparent", children: [
      t3,
      t4,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-4 items-center justify-center mt-8", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Chip2, { colorScheme: "yellowLight", className: "font-semibold", children: "ONE MONTH FREE TRIAL" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(UpgradeToPlusButton, { includePriceSelect: true, includePriceLabel: false, largePriceLabel: true })
      ] })
    ] });
    $2[5] = t5;
  } else {
    t5 = $2[5];
  }
  const plusTier = t5;
  let t6;
  if ($2[6] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl md:text-4xl font-bold text-center text-surface-800 dark:text-surface-200 uppercase my-3", children: "Pro" });
    $2[6] = t6;
  } else {
    t6 = $2[6];
  }
  let t7;
  if ($2[7] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grow", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-lg mb-4 text-center font-semibold", children: "Perfect for startups, companies or agencies." }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "Everything in PLUS" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "Self-hosted" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "Custom authentication and access control" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "Access to all the plugins" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "SAML SSO" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "Custom domain" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "Full CMS components customization" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "Priority support" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "ml-8 list-disc", children: "Roadmap prioritization" })
      ] })
    ] });
    $2[7] = t7;
  } else {
    t7 = $2[7];
  }
  let t8;
  if ($2[8] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center mt-4 text-surface-600 dark:text-surface-400 w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-2xl font-bold ", children: "Starting at 49.99" }) });
    $2[8] = t8;
  } else {
    t8 = $2[8];
  }
  let t9;
  if ($2[9] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "h-full max-w-sm p-6 border border-solid border-surface-200 rounded-lg shadow dark:border-surface-700 flex flex-col", children: [
      t6,
      t7,
      t8,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center mt-4 text-primary w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button2, { component: "a", size: "large", variant: "outlined", href: "https://firecms.co/pro", rel: "noopener noreferrer", target: "_blank", children: "More info" }) })
    ] });
    $2[9] = t9;
  } else {
    t9 = $2[9];
  }
  const proTier = t9;
  let t10;
  if ($2[10] === Symbol.for("react.memo_cache_sentinel")) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-auto my-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container2, { className: "flex flex-col gap-4 p-8 m-auto", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl md:text-4xl font-bold my-4 text-center", children: "Full no-code/low-code solution" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "FireCMS Cloud" }),
        " offers a complete, end-to-end solution for businesses that require the highest level of support and security. With dedicated hosting, advanced features, and expert support, you will have everything you need to take your project to the next level."
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center lg:grid lg:grid-cols-3 gap-4 mt-2 w-full mx-auto", children: [
        freeTier,
        plusTier,
        proTier
      ] })
    ] }) });
    $2[10] = t10;
  } else {
    t10 = $2[10];
  }
  return t10;
}
function StripeDisclaimer() {
  const $2 = c_1(1);
  let t0;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { variant: "caption", className: "mt-4", children: [
      "You will be redirected to ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: "Stripe" }),
      " to manage the subscription. You will be charged every month per the maximum concurrent of users. You can cancel your subscription at any time, and enjoy the benefits until the end of the current billing period."
    ] });
    $2[0] = t0;
  } else {
    t0 = $2[0];
  }
  return t0;
}
function ProjectSubscriptionPlans(t0) {
  const $2 = c_1(53);
  const {
    subscriptionPlan,
    projectId
  } = useProjectConfig();
  if (!subscriptionPlan) {
    throw new Error("No subscription plan");
  }
  useBrowserTitleAndIcon2("Plans");
  const {
    products,
    subscribe,
    getSubscriptionsForProject
  } = useSubscriptionsForUserController();
  let loading;
  let plusProduct;
  let t1;
  if ($2[0] !== getSubscriptionsForProject || $2[1] !== products || $2[2] !== projectId) {
    const projectSubscriptions = getSubscriptionsForProject(projectId);
    loading = projectSubscriptions === void 0 || products === void 0;
    let t25;
    if ($2[6] !== products) {
      t25 = products ?? [];
      $2[6] = products;
      $2[7] = t25;
    } else {
      t25 = $2[7];
    }
    let t32;
    if ($2[8] !== t25) {
      const cloudProducts = t25.filter(_temp$4);
      t32 = cloudProducts.find(_temp2$2);
      $2[8] = t25;
      $2[9] = t32;
    } else {
      t32 = $2[9];
    }
    plusProduct = t32;
    t1 = projectSubscriptions.find(_temp3$1);
    $2[0] = getSubscriptionsForProject;
    $2[1] = products;
    $2[2] = projectId;
    $2[3] = loading;
    $2[4] = plusProduct;
    $2[5] = t1;
  } else {
    loading = $2[3];
    plusProduct = $2[4];
    t1 = $2[5];
  }
  const plusSubscription = t1;
  let t2;
  if ($2[10] !== loading) {
    t2 = loading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute w-full h-full flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress2, {}) });
    $2[10] = loading;
    $2[11] = t2;
  } else {
    t2 = $2[11];
  }
  const t3 = loading ? "collapse" : "";
  let t4;
  if ($2[12] !== t3) {
    t4 = cls2("grid grid-cols-12 gap-4 items-center", t3);
    $2[12] = t3;
    $2[13] = t4;
  } else {
    t4 = $2[13];
  }
  let t5;
  if ($2[14] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "h4", className: "mt-4 mb-2", children: "Subscription Plan" });
    $2[14] = t5;
  } else {
    t5 = $2[14];
  }
  let t6;
  if ($2[15] !== subscriptionPlan) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { variant: "subtitle1", className: "my-2", children: [
      "This project is on the ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(PlanChip, { subscriptionPlan })
    ] });
    $2[15] = subscriptionPlan;
    $2[16] = t6;
  } else {
    t6 = $2[16];
  }
  let t7;
  if ($2[17] !== plusProduct || $2[18] !== projectId || $2[19] !== subscribe || $2[20] !== subscriptionPlan) {
    t7 = subscriptionPlan !== "cloud_plus" && plusProduct && /* @__PURE__ */ jsxRuntimeExports.jsx(ProductUpgradeSmallView, { product: plusProduct, projectId, subscribe });
    $2[17] = plusProduct;
    $2[18] = projectId;
    $2[19] = subscribe;
    $2[20] = subscriptionPlan;
    $2[21] = t7;
  } else {
    t7 = $2[21];
  }
  let t8;
  if ($2[22] !== plusSubscription || $2[23] !== subscriptionPlan) {
    t8 = subscriptionPlan === "cloud_plus" && plusSubscription && /* @__PURE__ */ jsxRuntimeExports.jsx(CurrentSubscriptionView, { subscription: plusSubscription });
    $2[22] = plusSubscription;
    $2[23] = subscriptionPlan;
    $2[24] = t8;
  } else {
    t8 = $2[24];
  }
  let t9;
  if ($2[25] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(StripeDisclaimer, {});
    $2[25] = t9;
  } else {
    t9 = $2[25];
  }
  let t10;
  if ($2[26] !== t6 || $2[27] !== t7 || $2[28] !== t8) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-12 md:col-span-7 flex flex-col gap-2", children: [
      t5,
      t6,
      t7,
      t8,
      t9
    ] });
    $2[26] = t6;
    $2[27] = t7;
    $2[28] = t8;
    $2[29] = t10;
  } else {
    t10 = $2[29];
  }
  let t11;
  if ($2[30] === Symbol.for("react.memo_cache_sentinel")) {
    t11 = cls2("col-span-12 md:col-span-5");
    $2[30] = t11;
  } else {
    t11 = $2[30];
  }
  let t12;
  if ($2[31] !== subscriptionPlan) {
    t12 = subscriptionPlan === "free" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      "Upgrade to the ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: "PLUS" }),
      " plan to enable the following features:"
    ] });
    $2[31] = subscriptionPlan;
    $2[32] = t12;
  } else {
    t12 = $2[32];
  }
  let t13;
  if ($2[33] !== subscriptionPlan) {
    t13 = subscriptionPlan === "cloud_plus" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      "By being on the ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: "PLUS" }),
      " plan you are enjoying the following features:"
    ] });
    $2[33] = subscriptionPlan;
    $2[34] = t13;
  } else {
    t13 = $2[34];
  }
  let t14;
  if ($2[35] === Symbol.for("react.memo_cache_sentinel")) {
    t14 = /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex gap-4 items-center py-0.5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AutoAwesomeIcon2, { size: "small" }),
      "Local text search"
    ] });
    $2[35] = t14;
  } else {
    t14 = $2[35];
  }
  let t15;
  if ($2[36] === Symbol.for("react.memo_cache_sentinel")) {
    t15 = /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex gap-4 items-center py-0.5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AutoAwesomeIcon2, { size: "small" }),
      "Unlimited users and roles"
    ] });
    $2[36] = t15;
  } else {
    t15 = $2[36];
  }
  let t16;
  if ($2[37] === Symbol.for("react.memo_cache_sentinel")) {
    t16 = /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex gap-4 items-center py-0.5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AutoAwesomeIcon2, { size: "small" }),
      "Theme and logo customization"
    ] });
    $2[37] = t16;
  } else {
    t16 = $2[37];
  }
  let t17;
  if ($2[38] === Symbol.for("react.memo_cache_sentinel")) {
    t17 = /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex gap-4 items-center py-0.5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AutoAwesomeIcon2, { size: "small" }),
      "Custom form fields and custom views"
    ] });
    $2[38] = t17;
  } else {
    t17 = $2[38];
  }
  let t18;
  if ($2[39] === Symbol.for("react.memo_cache_sentinel")) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex gap-4 items-center py-0.5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AutoAwesomeIcon2, { size: "small" }),
      "Secondary databases"
    ] });
    $2[39] = t18;
  } else {
    t18 = $2[39];
  }
  let t19;
  if ($2[40] === Symbol.for("react.memo_cache_sentinel")) {
    t19 = /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex gap-4 items-center py-0.5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AutoAwesomeIcon2, { size: "small" }),
      "GPT-4 content generation"
    ] });
    $2[40] = t19;
  } else {
    t19 = $2[40];
  }
  let t20;
  if ($2[41] === Symbol.for("react.memo_cache_sentinel")) {
    t20 = /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex gap-4 items-center py-0.5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AutoAwesomeIcon2, { size: "small" }),
      "Unlimited data export"
    ] });
    $2[41] = t20;
  } else {
    t20 = $2[41];
  }
  let t21;
  if ($2[42] === Symbol.for("react.memo_cache_sentinel")) {
    t21 = /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "px-2 text-base", children: [
      t14,
      t15,
      t16,
      t17,
      t18,
      t19,
      t20,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex gap-4 items-center py-0.5", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AutoAwesomeIcon2, { size: "small" }),
        "AppCheck"
      ] })
    ] });
    $2[42] = t21;
  } else {
    t21 = $2[42];
  }
  let t22;
  if ($2[43] !== t12 || $2[44] !== t13) {
    t22 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t11, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card2, { className: "p-6 bg-amber-200 dark:bg-amber-700 border-amber-300 dark:border-amber-800 flex flex-col gap-4", children: [
      t12,
      t13,
      t21
    ] }) });
    $2[43] = t12;
    $2[44] = t13;
    $2[45] = t22;
  } else {
    t22 = $2[45];
  }
  let t23;
  if ($2[46] !== t10 || $2[47] !== t22 || $2[48] !== t4) {
    t23 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t4, children: [
      t10,
      t22
    ] });
    $2[46] = t10;
    $2[47] = t22;
    $2[48] = t4;
    $2[49] = t23;
  } else {
    t23 = $2[49];
  }
  let t24;
  if ($2[50] !== t2 || $2[51] !== t23) {
    t24 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
      t2,
      t23
    ] });
    $2[50] = t2;
    $2[51] = t23;
    $2[52] = t24;
  } else {
    t24 = $2[52];
  }
  return t24;
}
function _temp3$1(s) {
  return s.product.metadata?.type === "cloud_plus";
}
function _temp2$2(p_0) {
  return p_0.metadata?.type === "cloud_plus";
}
function _temp$4(p) {
  return p.metadata?.type === "cloud_plus" || p.metadata?.type === "pro";
}
function CurrentSubscriptionView(t0) {
  const $2 = c_1(32);
  const {
    subscription
  } = t0;
  const {
    projectsApi
  } = useFireCMSBackend();
  let t1;
  if ($2[0] !== subscription.status) {
    t1 = getSubscriptionStatusText(subscription.status);
    $2[0] = subscription.status;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  const statusText = t1;
  const [cancelLinkUrl, setCancelLinkUrl] = useState(void 0);
  let t2;
  if ($2[2] !== cancelLinkUrl || $2[3] !== projectsApi || $2[4] !== subscription.canceled_at || $2[5] !== subscription.id) {
    t2 = () => {
      if (!cancelLinkUrl && !subscription.canceled_at) {
        projectsApi.getStripeCancelLinkForSubscription(subscription.id).then(setCancelLinkUrl);
      }
    };
    $2[2] = cancelLinkUrl;
    $2[3] = projectsApi;
    $2[4] = subscription.canceled_at;
    $2[5] = subscription.id;
    $2[6] = t2;
  } else {
    t2 = $2[6];
  }
  let t3;
  if ($2[7] !== subscription.canceled_at) {
    t3 = [subscription.canceled_at];
    $2[7] = subscription.canceled_at;
    $2[8] = t3;
  } else {
    t3 = $2[8];
  }
  useEffect(t2, t3);
  const t4 = subscription.id;
  const t5 = statusText === "Active" ? "greenDark" : "orangeDark";
  let t6;
  if ($2[9] !== statusText || $2[10] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      "The subscription is ",
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Chip2, { className: "inline", size: "small", colorScheme: t5, children: [
        statusText,
        " "
      ] }),
      "."
    ] });
    $2[9] = statusText;
    $2[10] = t5;
    $2[11] = t6;
  } else {
    t6 = $2[11];
  }
  let t7;
  if ($2[12] !== subscription.current_period_end) {
    t7 = subscription.current_period_end && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      " The next payment is on ",
      subscription.current_period_end.toDate().toLocaleDateString(),
      ". "
    ] });
    $2[12] = subscription.current_period_end;
    $2[13] = t7;
  } else {
    t7 = $2[13];
  }
  let t8;
  if ($2[14] !== subscription.price) {
    t8 = getPriceString(subscription.price);
    $2[14] = subscription.price;
    $2[15] = t8;
  } else {
    t8 = $2[15];
  }
  let t9;
  if ($2[16] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      "The current price is ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Chip2, { size: "small", children: t8 }),
      "per user."
    ] });
    $2[16] = t8;
    $2[17] = t9;
  } else {
    t9 = $2[17];
  }
  let t10;
  if ($2[18] !== subscription.cancel_at) {
    t10 = subscription.cancel_at && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      " This subscription was ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: "cancelled" }),
      " and will be active until ",
      subscription.cancel_at.toDate().toLocaleDateString(),
      ". "
    ] });
    $2[18] = subscription.cancel_at;
    $2[19] = t10;
  } else {
    t10 = $2[19];
  }
  let t11;
  if ($2[20] !== cancelLinkUrl || $2[21] !== subscription.canceled_at) {
    t11 = !subscription.canceled_at && /* @__PURE__ */ jsxRuntimeExports.jsx("a", { className: " " + subscription.canceled_at ? void 0 : "text-text-secondary dark:text-text-secondary-dark", href: cancelLinkUrl, target: "_blank", rel: "noreferrer", children: " Manage subscription" });
    $2[20] = cancelLinkUrl;
    $2[21] = subscription.canceled_at;
    $2[22] = t11;
  } else {
    t11 = $2[22];
  }
  let t12;
  if ($2[23] !== t10 || $2[24] !== t11 || $2[25] !== t6 || $2[26] !== t7 || $2[27] !== t9) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      t6,
      t7,
      t9,
      t10,
      t11
    ] });
    $2[23] = t10;
    $2[24] = t11;
    $2[25] = t6;
    $2[26] = t7;
    $2[27] = t9;
    $2[28] = t12;
  } else {
    t12 = $2[28];
  }
  let t13;
  if ($2[29] !== subscription.id || $2[30] !== t12) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2 mb-2", children: t12 }, t4);
    $2[29] = subscription.id;
    $2[30] = t12;
    $2[31] = t13;
  } else {
    t13 = $2[31];
  }
  return t13;
}
function PastDueAlert(t0) {
  const $2 = c_1(9);
  const {
    subscription
  } = t0;
  const projectsApi = useFireCMSBackend().projectsApi;
  const [url, setUrl] = React.useState(null);
  let t1;
  if ($2[0] !== projectsApi || $2[1] !== subscription.id) {
    t1 = () => {
      projectsApi.getStripeUpdateLinkForPaymentMethod(subscription.id).then(setUrl).catch(console.error);
    };
    $2[0] = projectsApi;
    $2[1] = subscription.id;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  let t2;
  if ($2[3] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = [];
    $2[3] = t2;
  } else {
    t2 = $2[3];
  }
  useEffect(t1, t2);
  let t3;
  if ($2[4] !== url) {
    t3 = url ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button2, { component: "a", href: url, target: "_blank", rel: "noopener noreferrer", className: "dark:!text-white dark:border-white dark:hover:bg-white dark:hover:!text-primary min-w-content", variant: "outlined", children: "Update" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress2, { size: "small" });
    $2[4] = url;
    $2[5] = t3;
  } else {
    t3 = $2[5];
  }
  let t4;
  if ($2[6] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Your subscription is past due. Please update your payment method to avoid service disruption" });
    $2[6] = t4;
  } else {
    t4 = $2[6];
  }
  let t5;
  if ($2[7] !== t3) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Alert2, { color: "error", className: "my-4", action: t3, children: t4 });
    $2[7] = t3;
    $2[8] = t5;
  } else {
    t5 = $2[8];
  }
  return t5;
}
function SubscriptionPlanWidget(t0) {
  const $2 = c_1(34);
  const {
    message,
    showForPlans,
    includeCTA: t1,
    includeTooManyUsersAlert: t2
  } = t0;
  const includeCTA = t1 === void 0 ? true : t1;
  const includeTooManyUsersAlert = t2 === void 0 ? false : t2;
  const {
    projectId,
    subscriptionPlan,
    subscriptionData
  } = useProjectConfig();
  const {
    users,
    usersLimit
  } = useUserManagement();
  const tooManyUsers = usersLimit !== void 0 && users && users.length > usersLimit;
  const subscriptionsController = useSubscriptionsForUserController();
  const [dialogOpen, setDialogOpen] = React.useState(false);
  if (subscriptionData?.subscription_status === "past_due") {
    let t32;
    if ($2[0] !== subscriptionsController.activeSubscriptions) {
      t32 = subscriptionsController.activeSubscriptions ?? [];
      $2[0] = subscriptionsController.activeSubscriptions;
      $2[1] = t32;
    } else {
      t32 = $2[1];
    }
    let t42;
    if ($2[2] !== projectId || $2[3] !== t32) {
      let t53;
      if ($2[5] !== projectId) {
        t53 = (s) => s.status === "past_due" && s.metadata.projectId === projectId;
        $2[5] = projectId;
        $2[6] = t53;
      } else {
        t53 = $2[6];
      }
      t42 = t32.filter(t53);
      $2[2] = projectId;
      $2[3] = t32;
      $2[4] = t42;
    } else {
      t42 = $2[4];
    }
    const pastDueSubscriptions = t42;
    if (pastDueSubscriptions.length === 0) {
      return null;
    }
    const t52 = pastDueSubscriptions[0];
    let t62;
    if ($2[7] !== t52) {
      t62 = /* @__PURE__ */ jsxRuntimeExports.jsx(PastDueAlert, { subscription: t52 });
      $2[7] = t52;
      $2[8] = t62;
    } else {
      t62 = $2[8];
    }
    return t62;
  }
  if (!subscriptionPlan) {
    return null;
  }
  if (showForPlans && !showForPlans.includes(subscriptionPlan)) {
    return null;
  }
  let t3;
  if ($2[9] !== includeCTA) {
    t3 = includeCTA && /* @__PURE__ */ jsxRuntimeExports.jsx(Button2, { className: "dark:!text-white dark:border-white dark:hover:bg-white dark:hover:!text-primary min-w-content", variant: "outlined", onClick: () => setDialogOpen(true), children: "More info" });
    $2[9] = includeCTA;
    $2[10] = t3;
  } else {
    t3 = $2[10];
  }
  let t4;
  if ($2[11] !== subscriptionPlan) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(PlanChip, { subscriptionPlan });
    $2[11] = subscriptionPlan;
    $2[12] = t4;
  } else {
    t4 = $2[12];
  }
  const t5 = !message && "Try out all the PLUS features for free!";
  let t6;
  if ($2[13] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2", children: t5 });
    $2[13] = t5;
    $2[14] = t6;
  } else {
    t6 = $2[14];
  }
  let t7;
  if ($2[15] !== t4 || $2[16] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      "This project is currently in the ",
      t4,
      t6
    ] });
    $2[15] = t4;
    $2[16] = t6;
    $2[17] = t7;
  } else {
    t7 = $2[17];
  }
  let t8;
  if ($2[18] !== message) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "caption", children: message });
    $2[18] = message;
    $2[19] = t8;
  } else {
    t8 = $2[19];
  }
  let t9;
  if ($2[20] !== t3 || $2[21] !== t7 || $2[22] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert2, { color: "info", action: t3, children: [
      t7,
      t8
    ] });
    $2[20] = t3;
    $2[21] = t7;
    $2[22] = t8;
    $2[23] = t9;
  } else {
    t9 = $2[23];
  }
  let t10;
  if ($2[24] !== includeTooManyUsersAlert || $2[25] !== tooManyUsers) {
    t10 = includeTooManyUsersAlert && tooManyUsers && /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert2, { color: "error", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "You have registered more users than you plan allows" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "caption", children: "Some users will not be able to access FireCMS Cloud" })
    ] });
    $2[24] = includeTooManyUsersAlert;
    $2[25] = tooManyUsers;
    $2[26] = t10;
  } else {
    t10 = $2[26];
  }
  let t11;
  if ($2[27] === Symbol.for("react.memo_cache_sentinel")) {
    t11 = () => setDialogOpen(false);
    $2[27] = t11;
  } else {
    t11 = $2[27];
  }
  let t12;
  if ($2[28] !== dialogOpen) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(PlansComparisonDialog, { open: dialogOpen, onClose: t11 });
    $2[28] = dialogOpen;
    $2[29] = t12;
  } else {
    t12 = $2[29];
  }
  let t13;
  if ($2[30] !== t10 || $2[31] !== t12 || $2[32] !== t9) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "my-2 flex flex-col gap-2", children: [
      t9,
      t10,
      t12
    ] });
    $2[30] = t10;
    $2[31] = t12;
    $2[32] = t9;
    $2[33] = t13;
  } else {
    t13 = $2[33];
  }
  return t13;
}
const googleIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 64 64", width: 32, height: 32, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "95yY7w43Oj6n2vH63j6HJb", x1: "29.401", x2: "29.401", y1: "4.064", y2: "106.734", gradientTransform: "matrix(1 0 0 -1 0 66)", gradientUnits: "userSpaceOnUse", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0", stopColor: "#ff5840" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: ".007", stopColor: "#ff5840" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: ".989", stopColor: "#fa528c" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", stopColor: "#fa528c" })
  ] }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "url(#95yY7w43Oj6n2vH63j6HJb)", d: "M47.46,15.5l-1.37,1.48c-1.34,1.44-3.5,1.67-5.15,0.6c-2.71-1.75-6.43-3.13-11-2.37 c-4.94,0.83-9.17,3.85-11.64, 7.97l-8.03-6.08C14.99,9.82,23.2,5,32.5,5c5,0,9.94,1.56,14.27,4.46 C48.81,10.83,49.13,13.71,47.46,15.5z" }),
  /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "95yY7w43Oj6n2vH63j6HJc", x1: "12.148", x2: "12.148", y1: ".872", y2: "47.812", gradientTransform: "matrix(1 0 0 -1 0 66)", gradientUnits: "userSpaceOnUse", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0", stopColor: "#feaa53" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: ".612", stopColor: "#ffcd49" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", stopColor: "#ffde44" })
  ] }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "url(#95yY7w43Oj6n2vH63j6HJc)", d: "M16.01,30.91c-0.09,2.47,0.37,4.83,1.27,6.96l-8.21,6.05c-1.35-2.51-2.3-5.28-2.75-8.22 c-1.06-6.88,0.54-13.38, 3.95-18.6l8.03,6.08C16.93,25.47,16.1,28.11,16.01,30.91z" }),
  /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "95yY7w43Oj6n2vH63j6HJd", x1: "29.76", x2: "29.76", y1: "32.149", y2: "-6.939", gradientTransform: "matrix(1 0 0 -1 0 66)", gradientUnits: "userSpaceOnUse", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0", stopColor: "#42d778" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: ".428", stopColor: "#3dca76" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", stopColor: "#34b171" })
  ] }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "url(#95yY7w43Oj6n2vH63j6HJd)", d: "M50.45,51.28c-4.55,4.07-10.61,6.57-17.36,6.71C22.91,58.2,13.66,52.53,9.07,43.92l8.21-6.05 C19.78,43.81, 25.67,48,32.5,48c3.94,0,7.52-1.28,10.33-3.44L50.45,51.28z" }),
  /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "95yY7w43Oj6n2vH63j6HJe", x1: "46", x2: "46", y1: "3.638", y2: "35.593", gradientTransform: "matrix(1 0 0 -1 0 66)", gradientUnits: "userSpaceOnUse", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0", stopColor: "#155cde" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: ".278", stopColor: "#1f7fe5" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: ".569", stopColor: "#279ceb" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: ".82", stopColor: "#2cafef" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", stopColor: "#2eb5f0" })
  ] }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "url(#95yY7w43Oj6n2vH63j6HJe)", d: "M59,31.97c0.01,7.73-3.26,14.58-8.55,19.31l-7.62-6.72c2.1-1.61,3.77-3.71,4.84-6.15\n        c0.29-0.66-0.2-1.41-0.92-1.41H37c-2.21,0-4-1.79-4-4v-2c0-2.21,1.79-4,4-4h17C56.75,27,59,29.22,59,31.97z" })
] }) });
function GoogleLoginButton(t0) {
  const $2 = c_1(9);
  const {
    onClick,
    disabled
  } = t0;
  const t1 = disabled ? "" : "hover:text-white hover:dark:text-white";
  let t2;
  if ($2[0] !== t1) {
    t2 = cls2("w-full bg-white text-surface-900 dark:text-surface-900", t1);
    $2[0] = t1;
    $2[1] = t2;
  } else {
    t2 = $2[1];
  }
  let t3;
  if ($2[2] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = {
      height: "40px",
      borderRadius: "4px",
      fontSize: "14px"
    };
    $2[2] = t3;
  } else {
    t3 = $2[2];
  }
  let t4;
  if ($2[3] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = cls2("flex items-center justify-items-center ");
    $2[3] = t4;
  } else {
    t4 = $2[3];
  }
  let t5;
  if ($2[4] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t4, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col items-center justify-center w-4.5 h-4.5", children: googleIcon() }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls2("flex-grow pl-6 text-left"), children: "Sign in with Google" })
    ] });
    $2[4] = t5;
  } else {
    t5 = $2[4];
  }
  let t6;
  if ($2[5] !== disabled || $2[6] !== onClick || $2[7] !== t2) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-4 w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button2, { className: t2, style: t3, variant: "filled", disabled, onClick, children: t5 }) });
    $2[5] = disabled;
    $2[6] = onClick;
    $2[7] = t2;
    $2[8] = t6;
  } else {
    t6 = $2[8];
  }
  return t6;
}
function FireCMSCloudLoginView(t0) {
  const $2 = c_1(32);
  const {
    fireCMSBackend,
    includeGoogleAdminScopes,
    includeLogo,
    includeGoogleDisclosure,
    includeTermsAndNewsLetter
  } = t0;
  const [termsAccepted, setTermsAccepted] = useState(false);
  const [subscribeToNewsletter, setSubscribeToNewsletter] = useState(false);
  let t1;
  if ($2[0] !== fireCMSBackend.authProviderError) {
    t1 = function buildErrorView2() {
      let errorView;
      const ignoredCodes = ["auth/popup-closed-by-user", "auth/cancelled-popup-request"];
      if (fireCMSBackend.authProviderError && !ignoredCodes.includes(fireCMSBackend.authProviderError.code)) {
        errorView = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView2, { error: fireCMSBackend.authProviderError }) });
      }
      return errorView;
    };
    $2[0] = fireCMSBackend.authProviderError;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  const buildErrorView = t1;
  let t2;
  if ($2[2] !== includeLogo) {
    t2 = includeLogo && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-4", style: {
      width: "260px",
      height: "260px"
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FireCMSLogo2, {}) });
    $2[2] = includeLogo;
    $2[3] = t2;
  } else {
    t2 = $2[3];
  }
  let t3;
  if ($2[4] !== includeLogo) {
    t3 = includeLogo && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { variant: "h4", color: "primary", className: "mb-4", children: [
      "FireCMS ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "h4", component: "span", className: "text-blue-500", children: "CLOUD" })
    ] });
    $2[4] = includeLogo;
    $2[5] = t3;
  } else {
    t3 = $2[5];
  }
  let t4;
  if ($2[6] !== buildErrorView) {
    t4 = buildErrorView();
    $2[6] = buildErrorView;
    $2[7] = t4;
  } else {
    t4 = $2[7];
  }
  let t5;
  if ($2[8] !== includeTermsAndNewsLetter || $2[9] !== subscribeToNewsletter || $2[10] !== termsAccepted) {
    t5 = includeTermsAndNewsLetter && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanSwitchWithLabel2, { size: "small", invisible: true, value: subscribeToNewsletter, onValueChange: setSubscribeToNewsletter, position: "start", label: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "caption", color: "primary", children: "Join our newsletter. No spam, only important updates!" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanSwitchWithLabel2, { size: "small", invisible: true, value: termsAccepted, onValueChange: setTermsAccepted, position: "start", label: /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { variant: "caption", color: "primary", children: [
        "By signing in you agree to our ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("a", { target: "_blank", rel: "noopener noreferrer", href: "https://firecms.co/policy/terms_conditions", children: "Terms and Conditions" }),
        " and our ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("a", { target: "_blank", rel: "noopener noreferrer", href: "https://firecms.co/policy/privacy_policy", children: "Privacy policy" })
      ] }) })
    ] });
    $2[8] = includeTermsAndNewsLetter;
    $2[9] = subscribeToNewsletter;
    $2[10] = termsAccepted;
    $2[11] = t5;
  } else {
    t5 = $2[11];
  }
  const t6 = !termsAccepted && includeTermsAndNewsLetter;
  let t7;
  if ($2[12] !== fireCMSBackend || $2[13] !== includeGoogleAdminScopes || $2[14] !== subscribeToNewsletter) {
    t7 = () => {
      fireCMSBackend.googleLogin(includeGoogleAdminScopes).then((user) => {
        if (subscribeToNewsletter && user?.email) {
          subscribeNewsletter(user.email);
        }
      });
    };
    $2[12] = fireCMSBackend;
    $2[13] = includeGoogleAdminScopes;
    $2[14] = subscribeToNewsletter;
    $2[15] = t7;
  } else {
    t7 = $2[15];
  }
  let t8;
  if ($2[16] !== t6 || $2[17] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(GoogleLoginButton, { disabled: t6, onClick: t7 });
    $2[16] = t6;
    $2[17] = t7;
    $2[18] = t8;
  } else {
    t8 = $2[18];
  }
  let t9;
  if ($2[19] !== fireCMSBackend.permissionsNotGrantedError || $2[20] !== includeGoogleAdminScopes) {
    t9 = includeGoogleAdminScopes && fireCMSBackend.permissionsNotGrantedError && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView2, { error: "You need to grant additional permissions in order to manage your Google Cloud projects" });
    $2[19] = fireCMSBackend.permissionsNotGrantedError;
    $2[20] = includeGoogleAdminScopes;
    $2[21] = t9;
  } else {
    t9 = $2[21];
  }
  let t10;
  if ($2[22] !== includeGoogleDisclosure) {
    t10 = includeGoogleDisclosure && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { variant: "caption", children: [
      "FireCMS Cloud use and transfer to any other app of information received from Google APIs will adhere to ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("a", { target: "_blank", rel: "noopener noreferrer", href: "https://developers.google.com/terms/api-services-user-data-policy#additional_requirements_for_specific_api_scopes", children: "Google API Services User Data Policy" }),
      ", including the Limited Use requirements."
    ] });
    $2[22] = includeGoogleDisclosure;
    $2[23] = t10;
  } else {
    t10 = $2[23];
  }
  let t11;
  if ($2[24] !== t10 || $2[25] !== t2 || $2[26] !== t3 || $2[27] !== t4 || $2[28] !== t5 || $2[29] !== t8 || $2[30] !== t9) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center min-w-full p-2", children: [
      t2,
      t3,
      t4,
      t5,
      t8,
      t9,
      t10
    ] });
    $2[24] = t10;
    $2[25] = t2;
    $2[26] = t3;
    $2[27] = t4;
    $2[28] = t5;
    $2[29] = t8;
    $2[30] = t9;
    $2[31] = t11;
  } else {
    t11 = $2[31];
  }
  return t11;
}
const subscribeNewsletter = (email) => {
  const url = "https://api-drplyi3b6q-ey.a.run.app/notifications/newsletter";
  fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      email_address: email,
      source: "saas"
    })
  }).then((res) => {
  });
};
function FireCMSCloudHomePage() {
  const $2 = c_1(10);
  const navigation = useNavigationController2();
  const {
    plugins
  } = useCustomizationController2();
  let pluginActions;
  if ($2[0] !== plugins) {
    pluginActions = [];
    if (plugins) {
      pluginActions.push(...plugins.map(_temp$3).filter(Boolean));
    }
    $2[0] = plugins;
    $2[1] = pluginActions;
  } else {
    pluginActions = $2[1];
  }
  const showSubscriptionWidget = (navigation.collections ?? []).length > 0;
  let t0;
  if ($2[2] !== pluginActions) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      " ",
      pluginActions,
      " "
    ] });
    $2[2] = pluginActions;
    $2[3] = t0;
  } else {
    t0 = $2[3];
  }
  let t1;
  if ($2[4] !== showSubscriptionWidget) {
    t1 = showSubscriptionWidget ? /* @__PURE__ */ jsxRuntimeExports.jsx(SubscriptionPlanWidget, { showForPlans: ["free"], includeTooManyUsersAlert: true }) : void 0;
    $2[4] = showSubscriptionWidget;
    $2[5] = t1;
  } else {
    t1 = $2[5];
  }
  let t2;
  if ($2[6] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(NavigationGroup2, { group: "ADMIN", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-12 gap-2", children: ADMIN_VIEWS_CONFIG.map(_temp2$1) }) });
    $2[6] = t2;
  } else {
    t2 = $2[6];
  }
  let t3;
  if ($2[7] !== t0 || $2[8] !== t1) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultHomePage2, { additionalActions: t0, additionalChildrenStart: t1, additionalChildrenEnd: t2 });
    $2[7] = t0;
    $2[8] = t1;
    $2[9] = t3;
  } else {
    t3 = $2[9];
  }
  return t3;
}
function _temp2$1(view) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-12 sm:col-span-6 lg:col-span-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SmallNavigationCard2, { name: view.name, url: view.path, icon: /* @__PURE__ */ jsxRuntimeExports.jsx(IconForView2, { collectionOrView: view, className: "text-surface-400 dark:text-surface-600" }) }) }, `nav_${view.path}`);
}
function _temp$3(plugin, i) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, { children: plugin.homePage?.additionalActions ?? null }, plugin.key);
}
function TextSearchInfoDialog(t0) {
  const $2 = c_1(47);
  const {
    open,
    closeDialog,
    collection: collection2,
    collectionConfigController,
    parentCollectionIds,
    hasOwnTextSearchImplementation
  } = t0;
  const snackbarController = useSnackbarController2();
  const projectConfig = useProjectConfig();
  const [enablingLocalSearch, setEnablingLocalSearch] = useState(false);
  const [enablingForCollection, setEnablingForCollection] = useState(false);
  let t1;
  if ($2[0] !== collection2.id || $2[1] !== collectionConfigController || $2[2] !== parentCollectionIds) {
    t1 = function enableTextSearchForCollection2() {
      return collectionConfigController.updateCollection({
        id: collection2.id,
        parentCollectionIds,
        collectionData: {
          id: collection2.id,
          textSearchEnabled: true
        }
      });
    };
    $2[0] = collection2.id;
    $2[1] = collectionConfigController;
    $2[2] = parentCollectionIds;
    $2[3] = t1;
  } else {
    t1 = $2[3];
  }
  const enableTextSearchForCollection = t1;
  let t2;
  if ($2[4] !== closeDialog) {
    t2 = (open_0) => !open_0 ? closeDialog() : void 0;
    $2[4] = closeDialog;
    $2[5] = t2;
  } else {
    t2 = $2[5];
  }
  let t3;
  if ($2[6] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogTitle2, { variant: "h5", className: "flex flex-row gap-4 items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SearchIcon2, {}),
      "Enable text search"
    ] });
    $2[6] = t3;
  } else {
    t3 = $2[6];
  }
  let t4;
  if ($2[7] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(SubscriptionPlanWidget, { includeCTA: false, showForPlans: ["free"], message: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "Upgrade to PLUS to use text search" }) });
    $2[7] = t4;
  } else {
    t4 = $2[7];
  }
  let t5;
  if ($2[8] !== hasOwnTextSearchImplementation) {
    t5 = !hasOwnTextSearchImplementation && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2 mb-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Alert2, { color: "warning", children: "Local text search is not recommended for large collections." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "caption", className: "mt-4", children: "Note that enabling local text search will need to fetch all documents from your collection and store them in the browser. This can be inefficient for large collections. It can also incur in additional costs." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "caption", children: "For larger collections, you are encouraged to use an external search engine such as Algolia or Elastic Search, and assign a search delegate to your config." })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { children: "Local text search is the simplest way to enable text search in your collection. It loads all documents in the collection in the browser and performs the search locally. This is the recommended option for small collections." })
    ] });
    $2[8] = hasOwnTextSearchImplementation;
    $2[9] = t5;
  } else {
    t5 = $2[9];
  }
  let t6;
  if ($2[10] !== hasOwnTextSearchImplementation) {
    t6 = hasOwnTextSearchImplementation && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { children: "You have implemented your own text search controller. You enable text search for your collection." }) });
    $2[10] = hasOwnTextSearchImplementation;
    $2[11] = t6;
  } else {
    t6 = $2[11];
  }
  let t7;
  if ($2[12] !== closeDialog || $2[13] !== collection2.textSearchEnabled || $2[14] !== enableTextSearchForCollection || $2[15] !== enablingForCollection || $2[16] !== hasOwnTextSearchImplementation || $2[17] !== projectConfig.canUseLocalTextSearch || $2[18] !== projectConfig.localTextSearchEnabled || $2[19] !== snackbarController) {
    t7 = (hasOwnTextSearchImplementation || projectConfig.localTextSearchEnabled) && !collection2.textSearchEnabled && projectConfig.canUseLocalTextSearch && /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingButton2, { variant: "outlined", loading: enablingForCollection, size: "large", onClick: () => {
      setEnablingForCollection(true);
      enableTextSearchForCollection().then(() => {
        snackbarController.open({
          message: "Local text search enabled",
          type: "success"
        });
        closeDialog();
      }).finally(() => setEnablingForCollection(false));
    }, disabled: !projectConfig.canUseLocalTextSearch, children: "Enable for this collection" });
    $2[12] = closeDialog;
    $2[13] = collection2.textSearchEnabled;
    $2[14] = enableTextSearchForCollection;
    $2[15] = enablingForCollection;
    $2[16] = hasOwnTextSearchImplementation;
    $2[17] = projectConfig.canUseLocalTextSearch;
    $2[18] = projectConfig.localTextSearchEnabled;
    $2[19] = snackbarController;
    $2[20] = t7;
  } else {
    t7 = $2[20];
  }
  let t8;
  if ($2[21] !== closeDialog || $2[22] !== collection2.textSearchEnabled || $2[23] !== enableTextSearchForCollection || $2[24] !== enablingLocalSearch || $2[25] !== hasOwnTextSearchImplementation || $2[26] !== projectConfig || $2[27] !== snackbarController) {
    t8 = !hasOwnTextSearchImplementation && !projectConfig.localTextSearchEnabled && /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingButton2, { variant: "outlined", loading: enablingLocalSearch, size: "large", onClick: () => {
      setEnablingLocalSearch(true);
      projectConfig.updateLocalTextSearchEnabled(true).then(async () => {
        if (!collection2.textSearchEnabled) {
          await enableTextSearchForCollection();
        }
        snackbarController.open({
          message: "Local text search enabled",
          type: "success"
        });
        closeDialog();
      }).finally(() => setEnablingLocalSearch(false));
    }, disabled: !projectConfig.canUseLocalTextSearch, children: "Enable for project" });
    $2[21] = closeDialog;
    $2[22] = collection2.textSearchEnabled;
    $2[23] = enableTextSearchForCollection;
    $2[24] = enablingLocalSearch;
    $2[25] = hasOwnTextSearchImplementation;
    $2[26] = projectConfig;
    $2[27] = snackbarController;
    $2[28] = t8;
  } else {
    t8 = $2[28];
  }
  let t9;
  if ($2[29] !== projectConfig.canUseLocalTextSearch) {
    t9 = !projectConfig.canUseLocalTextSearch && /* @__PURE__ */ jsxRuntimeExports.jsx(UpgradeToPlusButton, { includePriceSelect: true, largePriceLabel: false, includePriceLabel: false });
    $2[29] = projectConfig.canUseLocalTextSearch;
    $2[30] = t9;
  } else {
    t9 = $2[30];
  }
  let t10;
  if ($2[31] !== t7 || $2[32] !== t8 || $2[33] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-end justify-end gap-4", children: [
      t7,
      t8,
      t9
    ] });
    $2[31] = t7;
    $2[32] = t8;
    $2[33] = t9;
    $2[34] = t10;
  } else {
    t10 = $2[34];
  }
  let t11;
  if ($2[35] !== t10 || $2[36] !== t5 || $2[37] !== t6) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent2, { className: "flex flex-col gap-4", children: [
      t4,
      t5,
      t6,
      t10
    ] });
    $2[35] = t10;
    $2[36] = t5;
    $2[37] = t6;
    $2[38] = t11;
  } else {
    t11 = $2[38];
  }
  let t12;
  if ($2[39] === Symbol.for("react.memo_cache_sentinel")) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon2, {});
    $2[39] = t12;
  } else {
    t12 = $2[39];
  }
  let t13;
  if ($2[40] !== closeDialog) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton2, { className: "absolute top-4 right-4", onClick: closeDialog, children: t12 });
    $2[40] = closeDialog;
    $2[41] = t13;
  } else {
    t13 = $2[41];
  }
  let t14;
  if ($2[42] !== open || $2[43] !== t11 || $2[44] !== t13 || $2[45] !== t2) {
    t14 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog2, { maxWidth: "2xl", open, onOpenChange: t2, children: [
      t3,
      t11,
      t13
    ] });
    $2[42] = open;
    $2[43] = t11;
    $2[44] = t13;
    $2[45] = t2;
    $2[46] = t14;
  } else {
    t14 = $2[46];
  }
  return t14;
}
function RootCollectionSuggestions(t0) {
  const $2 = c_1(36);
  const {
    introMode
  } = t0;
  const authController = useAuthController2();
  const navigationController = useNavigationController2();
  const collectionEditorController = useCollectionEditorController();
  let t1;
  if ($2[0] !== authController || $2[1] !== collectionEditorController) {
    t1 = collectionEditorController.configPermissions ? collectionEditorController.configPermissions({
      user: authController.user
    }).createCollections : true;
    $2[0] = authController;
    $2[1] = collectionEditorController;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  const canCreateCollections = t1;
  const [rootPathSuggestions, setRootPathSuggestions] = React.useState(void 0);
  let t2;
  if ($2[3] !== collectionEditorController || $2[4] !== navigationController) {
    t2 = () => {
      collectionEditorController.getPathSuggestions?.("").then((result) => {
        const existingPaths = (navigationController.collections ?? []).map(_temp$2);
        setRootPathSuggestions(result.filter((path) => !existingPaths.includes(path)));
      });
    };
    $2[3] = collectionEditorController;
    $2[4] = navigationController;
    $2[5] = t2;
  } else {
    t2 = $2[5];
  }
  let t3;
  if ($2[6] !== collectionEditorController.getPathSuggestions) {
    t3 = [collectionEditorController.getPathSuggestions];
    $2[6] = collectionEditorController.getPathSuggestions;
    $2[7] = t3;
  } else {
    t3 = $2[7];
  }
  useEffect(t2, t3);
  if (!collectionEditorController.getPathSuggestions) {
    return null;
  }
  const showSuggestions = (rootPathSuggestions ?? []).length > 3 || (navigationController.collections ?? []).length === 0 && (rootPathSuggestions ?? []).length > 0;
  const forceShowSuggestions = introMode === "existing_project";
  const t4 = forceShowSuggestions || showSuggestions;
  let t5;
  if ($2[8] !== introMode) {
    t5 = !introMode && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { variant: "body2", color: "secondary", children: [
      "Create a collection ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: "automatically" }),
      " from your data:"
    ] });
    $2[8] = introMode;
    $2[9] = t5;
  } else {
    t5 = $2[9];
  }
  let t6;
  if ($2[10] !== introMode) {
    t6 = introMode === "existing_project" && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { children: [
      "You will see your ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: "database collections" }),
      " here, a few seconds after project creation"
    ] });
    $2[10] = introMode;
    $2[11] = t6;
  } else {
    t6 = $2[11];
  }
  let t7;
  if ($2[12] !== rootPathSuggestions) {
    t7 = rootPathSuggestions ?? [];
    $2[12] = rootPathSuggestions;
    $2[13] = t7;
  } else {
    t7 = $2[13];
  }
  let t8;
  if ($2[14] !== canCreateCollections || $2[15] !== collectionEditorController || $2[16] !== t7) {
    let t92;
    if ($2[18] !== canCreateCollections || $2[19] !== collectionEditorController) {
      t92 = (path_0) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Chip2, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon2, { size: "small" }), colorScheme: "cyanLighter", onClick: collectionEditorController && canCreateCollections ? () => collectionEditorController.createCollection({
        initialValues: {
          path: path_0,
          name: unslugify2(path_0)
        },
        parentCollectionIds: [],
        redirect: true,
        sourceClick: "root_collection_suggestion"
      }) : void 0, size: "small", children: path_0 }) }, path_0);
      $2[18] = canCreateCollections;
      $2[19] = collectionEditorController;
      $2[20] = t92;
    } else {
      t92 = $2[20];
    }
    t8 = t7.map(t92);
    $2[14] = canCreateCollections;
    $2[15] = collectionEditorController;
    $2[16] = t7;
    $2[17] = t8;
  } else {
    t8 = $2[17];
  }
  let t9;
  if ($2[21] !== rootPathSuggestions) {
    t9 = rootPathSuggestions === void 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress2, { size: "small" });
    $2[21] = rootPathSuggestions;
    $2[22] = t9;
  } else {
    t9 = $2[22];
  }
  let t10;
  if ($2[23] !== rootPathSuggestions?.length) {
    t10 = rootPathSuggestions?.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "caption", children: "No suggestions" });
    $2[23] = rootPathSuggestions?.length;
    $2[24] = t10;
  } else {
    t10 = $2[24];
  }
  let t11;
  if ($2[25] !== t10 || $2[26] !== t8 || $2[27] !== t9) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row gap-1 overflow-scroll no-scrollbar ", children: [
      t8,
      t9,
      t10
    ] });
    $2[25] = t10;
    $2[26] = t8;
    $2[27] = t9;
    $2[28] = t11;
  } else {
    t11 = $2[28];
  }
  let t12;
  if ($2[29] !== t11 || $2[30] !== t5 || $2[31] !== t6) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-1 p-2 my-4", children: [
      t5,
      t6,
      t11
    ] });
    $2[29] = t11;
    $2[30] = t5;
    $2[31] = t6;
    $2[32] = t12;
  } else {
    t12 = $2[32];
  }
  let t13;
  if ($2[33] !== t12 || $2[34] !== t4) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsx(Collapse2, { in: t4, children: t12 });
    $2[33] = t12;
    $2[34] = t4;
    $2[35] = t13;
  } else {
    t13 = $2[35];
  }
  return t13;
}
function _temp$2(c2) {
  return c2.path;
}
function DataTalkSuggestions(t0) {
  const $2 = c_1(9);
  const {
    suggestions
  } = t0;
  const navigate = useNavigate();
  const navigation = useNavigationController2();
  const t1 = (suggestions ?? []).length > 0;
  let t2;
  if ($2[0] !== navigate || $2[1] !== navigation || $2[2] !== suggestions) {
    t2 = suggestions && suggestions.map((suggestion, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Label2, { className: "flex-1", border: true, onClick: () => navigate(navigation.homeUrl + "/datatalk?prompt=" + suggestion), children: suggestion }, index2));
    $2[0] = navigate;
    $2[1] = navigation;
    $2[2] = suggestions;
    $2[3] = t2;
  } else {
    t2 = $2[3];
  }
  let t3;
  if ($2[4] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-row gap-2 my-4", children: t2 });
    $2[4] = t2;
    $2[5] = t3;
  } else {
    t3 = $2[5];
  }
  let t4;
  if ($2[6] !== t1 || $2[7] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(Collapse2, { in: t1, children: t3 });
    $2[6] = t1;
    $2[7] = t3;
    $2[8] = t4;
  } else {
    t4 = $2[8];
  }
  return t4;
}
function useSaasPlugin(t0) {
  const $2 = c_1(29);
  const {
    projectConfig,
    collectionConfigController,
    appConfig,
    dataTalkSuggestions,
    introMode
  } = t0;
  const hasOwnTextSearchImplementation = Boolean(appConfig?.textSearchControllerBuilder);
  let t1;
  if ($2[0] !== introMode) {
    t1 = introMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(IntroWidget, { introMode }) : void 0;
    $2[0] = introMode;
    $2[1] = t1;
  } else {
    t1 = $2[1];
  }
  let t2;
  if ($2[2] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: t1 });
    $2[2] = t1;
    $2[3] = t2;
  } else {
    t2 = $2[3];
  }
  const additionalChildrenStart = t2;
  let t3;
  if ($2[4] !== dataTalkSuggestions || $2[5] !== introMode) {
    t3 = !introMode && /* @__PURE__ */ jsxRuntimeExports.jsx(DataTalkSuggestions, { suggestions: dataTalkSuggestions });
    $2[4] = dataTalkSuggestions;
    $2[5] = introMode;
    $2[6] = t3;
  } else {
    t3 = $2[6];
  }
  let t4;
  if ($2[7] !== introMode) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(RootCollectionSuggestions, { introMode });
    $2[7] = introMode;
    $2[8] = t4;
  } else {
    t4 = $2[8];
  }
  let t5;
  if ($2[9] !== t3 || $2[10] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t3,
      t4
    ] });
    $2[9] = t3;
    $2[10] = t4;
    $2[11] = t5;
  } else {
    t5 = $2[11];
  }
  const additionalChildrenEnd = t5;
  let t6;
  if ($2[12] !== additionalChildrenEnd || $2[13] !== additionalChildrenStart) {
    t6 = {
      additionalChildrenStart,
      additionalChildrenEnd
    };
    $2[12] = additionalChildrenEnd;
    $2[13] = additionalChildrenStart;
    $2[14] = t6;
  } else {
    t6 = $2[14];
  }
  let t7;
  if ($2[15] !== projectConfig.canUseLocalTextSearch || $2[16] !== projectConfig.localTextSearchEnabled) {
    t7 = (t82) => {
      const {
        collection: collection2
      } = t82;
      return !(projectConfig.canUseLocalTextSearch && projectConfig.localTextSearchEnabled && collection2.textSearchEnabled);
    };
    $2[15] = projectConfig.canUseLocalTextSearch;
    $2[16] = projectConfig.localTextSearchEnabled;
    $2[17] = t7;
  } else {
    t7 = $2[17];
  }
  let t8;
  if ($2[18] !== collectionConfigController || $2[19] !== hasOwnTextSearchImplementation || $2[20] !== projectConfig.canUseLocalTextSearch || $2[21] !== projectConfig.localTextSearchEnabled) {
    t8 = (t92) => {
      const {
        context: context_1,
        path: path_1,
        collection: collection_1,
        parentCollectionIds: parentCollectionIds_0
      } = t92;
      const canSearch = projectConfig.canUseLocalTextSearch && projectConfig.localTextSearchEnabled && collection_1.textSearchEnabled;
      if (!canSearch) {
        if (parentCollectionIds_0 === void 0) {
          console.warn("Enabling text search: Parent collection ids are undefined");
        } else {
          context_1.dialogsController.open({
            key: "text_search_info",
            Component: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(TextSearchInfoDialog, { ...props, hasOwnTextSearchImplementation, collectionConfigController, parentCollectionIds: parentCollectionIds_0, path: path_1, collection: collection_1 })
          });
        }
      }
      return Promise.resolve(false);
    };
    $2[18] = collectionConfigController;
    $2[19] = hasOwnTextSearchImplementation;
    $2[20] = projectConfig.canUseLocalTextSearch;
    $2[21] = projectConfig.localTextSearchEnabled;
    $2[22] = t8;
  } else {
    t8 = $2[22];
  }
  let t9;
  if ($2[23] !== t7 || $2[24] !== t8) {
    t9 = {
      blockSearch: t7,
      showTextSearchBar: _temp$1,
      onTextSearchClick: t8
    };
    $2[23] = t7;
    $2[24] = t8;
    $2[25] = t9;
  } else {
    t9 = $2[25];
  }
  let t10;
  if ($2[26] !== t6 || $2[27] !== t9) {
    t10 = {
      key: "saas",
      homePage: t6,
      collectionView: t9
    };
    $2[26] = t6;
    $2[27] = t9;
    $2[28] = t10;
  } else {
    t10 = $2[28];
  }
  return t10;
}
function _temp$1(t0) {
  const {
    collection: collection_0
  } = t0;
  if (collection_0.textSearchEnabled === false) {
    return false;
  }
  return true;
}
function IntroWidget(t0) {
  const $2 = c_1(6);
  const navigation = useNavigationController2();
  if (!navigation.topLevelNavigation) {
    throw Error("Navigation not ready in FireCMSHomePage");
  }
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "h4", className: "mb-4", children: "Welcome" });
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { paragraph: true, children: "Your admin panel is ready " });
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { paragraph: true, children: "FireCMS can be used as a standalone admin panel but it shines when you add your own custom functionality. Including your own custom components, fields, actions, views, and more." });
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { className: "inline", children: "Get started with:" });
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-2 select-all font-mono bg-surface-100 text-surface-800 dark:bg-surface-800 dark:text-white p-2 px-3  border-surface-200 border-solid w-fit text-md font-bold inline-flex rounded-md", children: "yarn create firecms-app" });
    $2[0] = t1;
    $2[1] = t2;
    $2[2] = t3;
    $2[3] = t4;
    $2[4] = t5;
  } else {
    t1 = $2[0];
    t2 = $2[1];
    t3 = $2[2];
    t4 = $2[3];
    t5 = $2[4];
  }
  let t6;
  if ($2[5] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-8 flex flex-col p-2", children: [
      t1,
      t2,
      t3,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        t4,
        t5,
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { className: "inline ml-2", children: [
          "More info in the ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://firecms.co/docs/customization_quickstart", rel: "noopener noreferrer", target: "_blank", children: "docs" })
        ] })
      ] })
    ] });
    $2[5] = t6;
  } else {
    t6 = $2[5];
  }
  return t6;
}
function FireCMSCloudDataTalkDrawer() {
  const $2 = c_1(8);
  const {
    logo
  } = useApp2();
  const [adminMenuOpen, setAdminMenuOpen] = React.useState(false);
  let t0;
  if ($2[0] !== logo) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerLogo2, { logo });
    $2[0] = logo;
    $2[1] = t0;
  } else {
    t0 = $2[1];
  }
  let t1;
  if ($2[2] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(DataTalkDrawer, {});
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  let t2;
  if ($2[3] !== adminMenuOpen) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(AdminDrawerMenu, { menuOpen: adminMenuOpen, setMenuOpen: setAdminMenuOpen });
    $2[3] = adminMenuOpen;
    $2[4] = t2;
  } else {
    t2 = $2[4];
  }
  let t3;
  if ($2[5] !== t0 || $2[6] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t0,
      t1,
      t2
    ] });
    $2[5] = t0;
    $2[6] = t2;
    $2[7] = t3;
  } else {
    t3 = $2[7];
  }
  return t3;
}
function PaywallDatabaseIdField() {
  const $2 = c_1(7);
  const ref2 = React.useRef(null);
  const projectConfig = useProjectConfig();
  let t0;
  let t1;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "subtitle2", className: "text-white", children: "Subscription required" });
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { className: "text-white", children: "Please upgrade plans to use alternate databases" });
    $2[0] = t0;
    $2[1] = t1;
  } else {
    t0 = $2[0];
    t1 = $2[1];
  }
  const t2 = `/p/${projectConfig.projectId}/settings`;
  let t3;
  if ($2[2] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2 p-2 text-white", children: [
      t0,
      t1,
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button2, { className: "hover:text-white", color: "primary", component: "a", rel: "noopener noreferrer", target: "_blank", onClick: _temp, href: t2, children: "Upgrade plan" })
    ] });
    $2[2] = t2;
    $2[3] = t3;
  } else {
    t3 = $2[3];
  }
  let t4;
  if ($2[4] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(TextField2, { inputRef: ref2, size: "small", inputClassName: "text-end", className: "bg-transparent dark:bg-transparent", disabled: true, placeholder: "(default)" });
    $2[4] = t4;
  } else {
    t4 = $2[4];
  }
  let t5;
  if ($2[5] !== t3) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip2, { side: "top", asChild: false, delayDuration: 500, sideOffset: 8, title: t3, children: t4 }) });
    $2[5] = t3;
    $2[6] = t5;
  } else {
    t5 = $2[6];
  }
  return t5;
}
function _temp(e) {
  return e.preventDefault();
}
const DOCS_LIMIT = 200;
function FireCMSCloudApp(t0) {
  const $2 = c_1(27);
  const {
    projectId,
    appConfig,
    backendApiHost: t1,
    onAnalyticsEvent,
    basePath,
    baseCollectionPath
  } = t0;
  const backendApiHost = t1 === void 0 ? "https://api-drplyi3b6q-ey.a.run.app" : t1;
  const modeController = useBuildModeController2();
  const t2 = backendApiHost + "/config";
  let t3;
  if ($2[0] !== t2) {
    t3 = {
      name: "firecms-backend",
      fromUrl: t2
    };
    $2[0] = t2;
    $2[1] = t3;
  } else {
    t3 = $2[1];
  }
  const {
    firebaseApp: backendFirebaseApp,
    firebaseConfigLoading: backendConfigLoading,
    configError,
    firebaseConfigError: backendFirebaseConfigError
  } = useInitialiseFirebase2(t3);
  let t4;
  if ($2[2] !== backendApiHost || $2[3] !== backendFirebaseApp) {
    t4 = {
      backendApiHost,
      backendFirebaseApp
    };
    $2[2] = backendApiHost;
    $2[3] = backendFirebaseApp;
    $2[4] = t4;
  } else {
    t4 = $2[4];
  }
  const fireCMSBackend = useBuildFireCMSBackend(t4);
  let component;
  if (backendConfigLoading || !backendFirebaseApp) {
    let t52;
    if ($2[5] !== projectId) {
      t52 = /* @__PURE__ */ jsxRuntimeExports.jsx(FullLoadingView, { projectId, text: "Backend loading" });
      $2[5] = projectId;
      $2[6] = t52;
    } else {
      t52 = $2[6];
    }
    component = t52;
  } else {
    if (backendFirebaseConfigError) {
      let t52;
      if ($2[7] !== backendFirebaseConfigError) {
        t52 = /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView2, { error: backendFirebaseConfigError });
        $2[7] = backendFirebaseConfigError;
        $2[8] = t52;
      } else {
        t52 = $2[8];
      }
      component = t52;
    } else {
      if (configError) {
        let t52;
        if ($2[9] !== configError) {
          t52 = /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView2, { error: configError });
          $2[9] = configError;
          $2[10] = t52;
        } else {
          t52 = $2[10];
        }
        component = t52;
      } else {
        if (fireCMSBackend.authLoading) {
          let t52;
          if ($2[11] !== projectId) {
            t52 = /* @__PURE__ */ jsxRuntimeExports.jsx(FullLoadingView, { projectId, text: "Auth loading" });
            $2[11] = projectId;
            $2[12] = t52;
          } else {
            t52 = $2[12];
          }
          component = t52;
        } else {
          if (!fireCMSBackend.user) {
            let t52;
            if ($2[13] !== fireCMSBackend) {
              t52 = /* @__PURE__ */ jsxRuntimeExports.jsx(CenteredView2, { maxWidth: "lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FireCMSCloudLoginView, { fireCMSBackend, includeLogo: true, includeGoogleAdminScopes: false, includeTermsAndNewsLetter: false, includeGoogleDisclosure: false }) });
              $2[13] = fireCMSBackend;
              $2[14] = t52;
            } else {
              t52 = $2[14];
            }
            component = t52;
          } else {
            let t52;
            if ($2[15] !== appConfig || $2[16] !== baseCollectionPath || $2[17] !== basePath || $2[18] !== fireCMSBackend || $2[19] !== modeController || $2[20] !== onAnalyticsEvent || $2[21] !== projectId) {
              t52 = /* @__PURE__ */ jsxRuntimeExports.jsx(FireCMSClient, { fireCMSBackend, projectId, modeController, appConfig, basePath, baseCollectionPath, onAnalyticsEvent });
              $2[15] = appConfig;
              $2[16] = baseCollectionPath;
              $2[17] = basePath;
              $2[18] = fireCMSBackend;
              $2[19] = modeController;
              $2[20] = onAnalyticsEvent;
              $2[21] = projectId;
              $2[22] = t52;
            } else {
              t52 = $2[22];
            }
            component = t52;
          }
        }
      }
    }
  }
  let t5;
  if ($2[23] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = {
      v7_relativeSplatPath: true,
      v7_startTransition: true
    };
    $2[23] = t5;
  } else {
    t5 = $2[23];
  }
  let t6;
  if ($2[24] !== basePath || $2[25] !== component) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { basename: basePath, future: t5, children: component });
    $2[24] = basePath;
    $2[25] = component;
    $2[26] = t6;
  } else {
    t6 = $2[26];
  }
  return t6;
}
function FullLoadingView(props) {
  const $2 = c_1(12);
  const t0 = "project_scaffold_" + props.projectId;
  const t1 = props.projectConfig?.logo;
  let t2;
  if ($2[0] !== props.FireCMSAppBarComponent || $2[1] !== props.projectConfig?.projectName) {
    t2 = props.FireCMSAppBarComponent && /* @__PURE__ */ jsxRuntimeExports.jsx(props.FireCMSAppBarComponent, { title: props.projectConfig?.projectName ?? "" });
    $2[0] = props.FireCMSAppBarComponent;
    $2[1] = props.projectConfig?.projectName;
    $2[2] = t2;
  } else {
    t2 = $2[2];
  }
  let t3;
  if ($2[3] !== t1 || $2[4] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(AppBar2, { logo: t1, children: t2 });
    $2[3] = t1;
    $2[4] = t2;
    $2[5] = t3;
  } else {
    t3 = $2[5];
  }
  let t4;
  if ($2[6] !== props.text) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCenter2, { text: props.text });
    $2[6] = props.text;
    $2[7] = t4;
  } else {
    t4 = $2[7];
  }
  let t5;
  if ($2[8] !== t0 || $2[9] !== t3 || $2[10] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Scaffold2, { children: [
      t3,
      t4
    ] }, t0);
    $2[8] = t0;
    $2[9] = t3;
    $2[10] = t4;
    $2[11] = t5;
  } else {
    t5 = $2[11];
  }
  return t5;
}
const FireCMSClient = function FireCMSClient2(t0) {
  const $2 = c_1(22);
  let fireCMSBackend;
  let projectId;
  let props;
  if ($2[0] !== t0) {
    ({
      projectId,
      fireCMSBackend,
      ...props
    } = t0);
    $2[0] = t0;
    $2[1] = fireCMSBackend;
    $2[2] = projectId;
    $2[3] = props;
  } else {
    fireCMSBackend = $2[1];
    projectId = $2[2];
    props = $2[3];
  }
  let t1;
  if ($2[4] !== fireCMSBackend.backendFirebaseApp || $2[5] !== projectId) {
    t1 = {
      projectId,
      backendFirebaseApp: fireCMSBackend.backendFirebaseApp
    };
    $2[4] = fireCMSBackend.backendFirebaseApp;
    $2[5] = projectId;
    $2[6] = t1;
  } else {
    t1 = $2[6];
  }
  const projectConfig = useBuildProjectConfig(t1);
  let t2;
  if ($2[7] !== fireCMSBackend || $2[8] !== projectConfig.canEditRoles || $2[9] !== projectConfig.usersLimit || $2[10] !== projectId) {
    t2 = {
      backendFirebaseApp: fireCMSBackend.backendFirebaseApp,
      projectId,
      projectsApi: fireCMSBackend.projectsApi,
      usersLimit: projectConfig.usersLimit,
      canEditRoles: projectConfig.canEditRoles,
      fireCMSBackend
    };
    $2[7] = fireCMSBackend;
    $2[8] = projectConfig.canEditRoles;
    $2[9] = projectConfig.usersLimit;
    $2[10] = projectId;
    $2[11] = t2;
  } else {
    t2 = $2[11];
  }
  const userManagement = useBuildCloudUserManagement(t2);
  if (userManagement.loading || !projectConfig.clientFirebaseConfig && !projectConfig.configError) {
    let t32;
    if ($2[12] !== projectConfig || $2[13] !== projectId || $2[14] !== props.FireCMSAppBarComponent) {
      t32 = /* @__PURE__ */ jsxRuntimeExports.jsx(FullLoadingView, { projectId, projectConfig, FireCMSAppBarComponent: props.FireCMSAppBarComponent, text: "Client loading" });
      $2[12] = projectConfig;
      $2[13] = projectId;
      $2[14] = props.FireCMSAppBarComponent;
      $2[15] = t32;
    } else {
      t32 = $2[15];
    }
    return t32;
  }
  let t3;
  if ($2[16] !== fireCMSBackend || $2[17] !== projectConfig || $2[18] !== projectId || $2[19] !== props || $2[20] !== userManagement) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(FireCMSClientWithController, { projectId, projectConfig, fireCMSBackend, customizationLoading: false, userManagement, ...props });
    $2[16] = fireCMSBackend;
    $2[17] = projectConfig;
    $2[18] = projectId;
    $2[19] = props;
    $2[20] = userManagement;
    $2[21] = t3;
  } else {
    t3 = $2[21];
  }
  return t3;
};
function ErrorDelegatingLoginView(t0) {
  const $2 = c_1(12);
  const {
    configError,
    onLogout,
    fireCMSBackend
  } = t0;
  let t1;
  if ($2[0] !== configError || $2[1] !== fireCMSBackend) {
    t1 = "code" in configError ? /* @__PURE__ */ jsxRuntimeExports.jsx(CloudErrorView, { error: configError, fireCMSBackend }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { children: configError.message }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { children: [
        "This error may be caused when a user has been deleted from the client project. Make sure a user exists in the client project with the same email as the one trying to log in. If the problem persists, reach us at ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "mailto:hello@firecms.co?subject=FireCMS%20login%20error", rel: "noopener noreferrer", target: "_blank", children: " hello@firecms.co " }),
        ", or in our ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("a", { rel: "noopener noreferrer", target: "_blank", href: "https://discord.gg/fxy7xsQm3m", children: "Discord channel" }),
        "."
      ] })
    ] });
    $2[0] = configError;
    $2[1] = fireCMSBackend;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  const errorBody = t1;
  let t2;
  if ($2[3] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorIcon2, { color: "error" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "h4", children: "Error logging in" })
    ] });
    $2[3] = t2;
  } else {
    t2 = $2[3];
  }
  let t3;
  if ($2[4] !== errorBody) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: errorBody });
    $2[4] = errorBody;
    $2[5] = t3;
  } else {
    t3 = $2[5];
  }
  let t4;
  if ($2[6] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Some login errors may be caused by the user not being registered in the client project. Make sure a user exists in the client project with the same email as the one trying to log in." });
    $2[6] = t4;
  } else {
    t4 = $2[6];
  }
  let t5;
  if ($2[7] !== onLogout) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button2, { variant: "outlined", onClick: onLogout, children: "Sign out" });
    $2[7] = onLogout;
    $2[8] = t5;
  } else {
    t5 = $2[8];
  }
  let t6;
  if ($2[9] !== t3 || $2[10] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs(CenteredView2, { maxWidth: "2xl", className: "flex flex-col gap-4", children: [
      t2,
      t3,
      t4,
      t5
    ] });
    $2[9] = t3;
    $2[10] = t5;
    $2[11] = t6;
  } else {
    t6 = $2[11];
  }
  return t6;
}
function NoAccessErrorView(props) {
  const $2 = c_1(11);
  let t0;
  if ($2[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4 items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorIcon2, { color: "error" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "h4", children: "Error accessing project" })
    ] });
    $2[0] = t0;
  } else {
    t0 = $2[0];
  }
  let t1;
  if ($2[1] !== props.configError.message) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { children: props.configError.message });
    $2[1] = props.configError.message;
    $2[2] = t1;
  } else {
    t1 = $2[2];
  }
  let t2;
  if ($2[3] !== props.projectId) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { children: [
      "This error may be caused when trying to access with a user that is not registered in the project ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: props.projectId }),
      ". You can ask the project owner to add you to the project."
    ] });
    $2[3] = props.projectId;
    $2[4] = t2;
  } else {
    t2 = $2[4];
  }
  let t3;
  if ($2[5] !== props.onLogout) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button2, { variant: "outlined", onClick: props.onLogout, children: "Sign out" });
    $2[5] = props.onLogout;
    $2[6] = t3;
  } else {
    t3 = $2[6];
  }
  let t4;
  if ($2[7] !== t1 || $2[8] !== t2 || $2[9] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs(CenteredView2, { maxWidth: "2xl", className: "flex flex-col gap-4", children: [
      t0,
      t1,
      t2,
      t3
    ] });
    $2[7] = t1;
    $2[8] = t2;
    $2[9] = t3;
    $2[10] = t4;
  } else {
    t4 = $2[10];
  }
  return t4;
}
function FireCMSClientWithController({
  projectConfig,
  userManagement,
  projectId,
  fireCMSBackend,
  appConfig,
  customizationLoading,
  ...props
}) {
  const [notValidUser, setNotValidUser] = useState();
  const {
    firebaseApp: clientFirebaseApp,
    firebaseConfigLoading,
    configError: firebaseConfigError
  } = useInitialiseFirebase2({
    onFirebaseInit: appConfig?.onFirebaseInit,
    firebaseConfig: projectConfig.clientFirebaseConfig
  });
  const appCheckResult = useAppCheck2({
    firebaseApp: clientFirebaseApp,
    options: appConfig?.appCheck ?? projectConfig.appCheck
  });
  const authController = useFirebaseAuthController2({
    firebaseApp: clientFirebaseApp,
    onSignOut: fireCMSBackend.signOut,
    defineRolesFor: userManagement.defineRolesFor
  });
  const fireCMSUser_0 = useMemo(() => {
    if (userManagement.loading || authController.authLoading) return;
    const user = authController.user;
    if (!user) return;
    return userManagement.allowedUsers.find((fireCMSUser) => fireCMSUser.email.toLowerCase() === user?.email?.toLowerCase());
  }, [authController.authLoading, authController.user, userManagement.loading, userManagement.users]);
  const {
    delegatedLoginLoading,
    delegatedLoginError
  } = useDelegatedLogin({
    projectsApi: fireCMSBackend.projectsApi,
    firebaseApp: clientFirebaseApp,
    projectId,
    onUserChanged: (user_0) => {
      authController.setUser(user_0 ?? null);
      authController.setUserRoles(fireCMSUser_0?.roles ?? []);
    },
    onAnalyticsEvent: props.onAnalyticsEvent
  });
  const permissions = useCallback(({
    collection: collection2,
    user: user_1
  }) => {
    return resolveUserRolePermissions({
      collection: collection2,
      user: user_1
    });
  }, []);
  const configController = useFirestoreCollectionsConfigController({
    firebaseApp: fireCMSBackend.backendFirebaseApp,
    configPath: `projects/${projectId}/collections`,
    permissions,
    propertyConfigs: appConfig?.propertyConfigs
  });
  let loadingOrErrorComponent;
  if (userManagement.loading) {
    loadingOrErrorComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCenter2, { text: "Project loading" });
  } else if (appCheckResult.loading) {
    loadingOrErrorComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCenter2, { text: "AppCheck loading" });
  } else if (delegatedLoginError) {
    console.error("Delegated login error", delegatedLoginError);
    loadingOrErrorComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorDelegatingLoginView, { configError: delegatedLoginError, fireCMSBackend, onLogout: fireCMSBackend.signOut });
  } else if (notValidUser) {
    console.warn("No user was found with email " + notValidUser.email);
    loadingOrErrorComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(NoAccessError, { authController, projectId });
  } else if (projectConfig.configError) {
    loadingOrErrorComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(NoAccessErrorView, { configError: projectConfig.configError, projectId, onLogout: fireCMSBackend.signOut });
  } else if (customizationLoading) {
    loadingOrErrorComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCenter2, { text: "Project customization loading" });
  } else if (firebaseConfigLoading) {
    loadingOrErrorComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCenter2, { text: "Client config loading" });
  } else if (firebaseConfigError) {
    loadingOrErrorComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(CenteredView2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView2, { error: firebaseConfigError ?? "Error fetching client Firebase config" }) });
  } else if (delegatedLoginLoading) {
    loadingOrErrorComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCenter2, { text: "Logging in to " + projectId });
  } else if (!authController.user) {
    loadingOrErrorComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCenter2, { text: "Auth loading" });
  } else if (!fireCMSUser_0) {
    loadingOrErrorComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(NoAccessError, { authController, userManagement, projectId });
  } else if (projectConfig.blocked) {
    loadingOrErrorComponent = /* @__PURE__ */ jsxRuntimeExports.jsxs(CenteredView2, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "h4", children: "Project blocked" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography2, { variant: "body1", children: "This project has been blocked by the FireCMS team." }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography2, { variant: "body1", children: [
        "Please contact ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "mailto:hello@firecms.co", children: "hello@firecms.co" }),
        " for more information"
      ] })
    ] });
  }
  if (loadingOrErrorComponent) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Scaffold2, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AppBar2, { logo: projectConfig?.logo ?? props.logo, children: props.FireCMSAppBarComponent && /* @__PURE__ */ jsxRuntimeExports.jsx(props.FireCMSAppBarComponent, { title: projectConfig.projectName ?? "", ...appConfig?.fireCMSAppBarComponentProps }) }),
      loadingOrErrorComponent
    ] }, "project_scaffold_" + projectConfig.projectId);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarProvider2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FireCMSAppAuthenticated, { fireCMSUser: fireCMSUser_0, fireCMSBackend, appConfig, authController, projectConfig, collectionConfigController: configController, firebaseApp: clientFirebaseApp, userManagement, ...props }) });
}
function NoAccessError(t0) {
  const $2 = c_1(8);
  const {
    authController,
    userManagement,
    projectId
  } = t0;
  let error = "You can request permission to the owner.";
  if (authController.user?.email && (userManagement?.users ?? []).map(_temp2).includes(authController.user?.email)) {
    error = "You can request permission to the owner. The user is registered in the project, but it is out of the free plan.";
  }
  const t1 = "You don't have access to the project " + projectId;
  let t2;
  if ($2[0] !== error || $2[1] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView2, { title: t1, error });
    $2[0] = error;
    $2[1] = t1;
    $2[2] = t2;
  } else {
    t2 = $2[2];
  }
  let t3;
  if ($2[3] !== authController.signOut) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button2, { variant: "text", onClick: authController.signOut, children: "Sign out" });
    $2[3] = authController.signOut;
    $2[4] = t3;
  } else {
    t3 = $2[4];
  }
  let t4;
  if ($2[5] !== t2 || $2[6] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs(CenteredView2, { maxWidth: "lg", className: "gap-4", children: [
      t2,
      t3
    ] });
    $2[5] = t2;
    $2[6] = t3;
    $2[7] = t4;
  } else {
    t4 = $2[7];
  }
  return t4;
}
function _temp2(user) {
  return user.email;
}
function usePathSuggestions(fireCMSBackend, projectConfig, navigationController) {
  const $2 = c_1(14);
  const {
    collections
  } = navigationController;
  let t0;
  if ($2[0] !== collections) {
    t0 = collections ?? [];
    $2[0] = collections;
    $2[1] = t0;
  } else {
    t0 = $2[1];
  }
  let t1;
  if ($2[2] !== t0) {
    t1 = t0.map(_temp3);
    $2[2] = t0;
    $2[3] = t1;
  } else {
    t1 = $2[3];
  }
  const existingPaths = t1;
  const [rootPathSuggestions, setRootPathSuggestions] = React.useState();
  let t2;
  if ($2[4] !== existingPaths || $2[5] !== fireCMSBackend.googleCredential?.accessToken || $2[6] !== fireCMSBackend.projectsApi || $2[7] !== projectConfig.projectId) {
    t2 = () => {
      const googleAccessToken = fireCMSBackend.googleCredential?.accessToken;
      fireCMSBackend.projectsApi.getRootCollections(projectConfig.projectId, googleAccessToken).then((paths) => {
        setRootPathSuggestions(paths.filter((p) => !existingPaths.includes(p.trim().toLowerCase())));
      });
    };
    $2[4] = existingPaths;
    $2[5] = fireCMSBackend.googleCredential?.accessToken;
    $2[6] = fireCMSBackend.projectsApi;
    $2[7] = projectConfig.projectId;
    $2[8] = t2;
  } else {
    t2 = $2[8];
  }
  let t3;
  if ($2[9] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = [];
    $2[9] = t3;
  } else {
    t3 = $2[9];
  }
  useEffect(t2, t3);
  let t4;
  if ($2[10] !== rootPathSuggestions) {
    t4 = (path) => {
      if (!path && rootPathSuggestions) {
        return Promise.resolve(rootPathSuggestions);
      }
      return Promise.resolve([]);
    };
    $2[10] = rootPathSuggestions;
    $2[11] = t4;
  } else {
    t4 = $2[11];
  }
  const getPathSuggestions = t4;
  let t5;
  if ($2[12] !== getPathSuggestions) {
    t5 = {
      getPathSuggestions
    };
    $2[12] = getPathSuggestions;
    $2[13] = t5;
  } else {
    t5 = $2[13];
  }
  return t5;
}
function _temp3(col) {
  return col.path.trim().toLowerCase();
}
function FireCMSAppAuthenticated({
  fireCMSUser,
  firebaseApp,
  projectConfig,
  userManagement,
  collectionConfigController,
  appConfig,
  authController,
  modeController,
  fireCMSBackend,
  FireCMSAppBarComponent,
  onAnalyticsEvent,
  basePath,
  baseCollectionPath,
  logo
}) {
  if (!authController.user) {
    throw Error("You can only use FireCMSAppAuthenticated with an authenticated user");
  }
  const snackbarController = useSnackbarController2();
  const includeDataTalk = userManagement.isAdmin ?? false;
  const dataTalkPath = useDataTalkMode();
  const dataTalkMode = includeDataTalk && dataTalkPath;
  const dataTalkEndpoint = fireCMSBackend.backendApiHost + "/projects/" + projectConfig.projectId;
  const canUseDataEnhancement = projectConfig.canUseDataEnhancement;
  const adminRoutes = useMemo(() => buildAdminRoutes(userManagement.usersLimit, includeDataTalk, fireCMSBackend, projectConfig, dataTalkEndpoint, onAnalyticsEvent), [includeDataTalk, userManagement.usersLimit, onAnalyticsEvent]);
  const configPermissions = useCallback(({
    user,
    collection: collection2
  }) => resolveCollectionConfigPermissions({
    user: fireCMSUser,
    userManagement,
    collection: collection2
  }), [userManagement, fireCMSUser]);
  const propertyConfigsMap = useMemo(() => {
    const map = {};
    appConfig?.propertyConfigs?.forEach((field) => {
      map[field.key] = field;
    });
    return map;
  }, [appConfig?.propertyConfigs]);
  const exportPlugin = useExportPlugin({
    exportAllowed: useCallback(({
      collectionEntitiesCount
    }) => {
      return projectConfig.canExport || collectionEntitiesCount <= DOCS_LIMIT;
    }, [projectConfig.canExport]),
    onAnalyticsEvent,
    notAllowedView: /* @__PURE__ */ jsxRuntimeExports.jsx(SubscriptionPlanWidget, { showForPlans: ["free"], message: `Upgrade to export more than ${DOCS_LIMIT} entities` })
  });
  const importPlugin = useImportPlugin({
    onAnalyticsEvent
  });
  const dataEnhancementPlugin = useDataEnhancementPlugin({
    SubscriptionMessage: FireCMSDataEnhancementSubscriptionMessage,
    host: fireCMSBackend.backendApiHost,
    interceptUsage: canUseDataEnhancement ? void 0 : () => {
      snackbarController.open({
        type: "warning",
        message: /* @__PURE__ */ jsxRuntimeExports.jsx(FireCMSDataEnhancementSubscriptionMessage, { projectId: projectConfig.projectId }),
        autoHideDuration: 4e3
      });
    }
  });
  useBrowserTitleAndIcon2(projectConfig.projectName ?? "", projectConfig.logo ?? logo);
  const userConfigPersistence = useBuildLocalConfigurationPersistence2();
  const firestoreDelegate = useFirestoreDelegate2({
    firebaseApp,
    textSearchControllerBuilder: appConfig?.textSearchControllerBuilder,
    firestoreIndexesBuilder: appConfig?.firestoreIndexesBuilder,
    localTextSearchEnabled: projectConfig.canUseLocalTextSearch && projectConfig.localTextSearchEnabled
  });
  const storageSource = useFirebaseStorageSource2({
    firebaseApp
  });
  const navigationController = useBuildNavigationController2({
    basePath,
    baseCollectionPath,
    authController,
    collections: appConfig?.collections,
    views: appConfig?.views,
    userConfigPersistence,
    dataSourceDelegate: firestoreDelegate,
    injectCollections: useCallback((collections) => mergeCollections(collections, collectionConfigController.collections ?? [], appConfig?.modifyCollection), [collectionConfigController.collections])
  });
  const introMode = navigationController.initialised && // navigationController.collections !== undefined &&
  (navigationController.collections ?? []).length === 0;
  const dataTalkConfig = useBuildDataTalkConfig({
    enabled: includeDataTalk,
    firebaseApp: fireCMSBackend.backendFirebaseApp,
    userSessionsPath: `projects/${projectConfig.projectId}/users/${fireCMSBackend.user?.uid}/datatalk_sessions`,
    getAuthToken: fireCMSBackend.getBackendAuthToken,
    apiEndpoint: dataTalkEndpoint
  });
  const saasPlugin = useSaasPlugin({
    projectConfig,
    firestoreDelegate,
    collectionConfigController,
    appConfig,
    dataTalkSuggestions: dataTalkConfig.rootPromptsSuggestions,
    introMode: introMode ? projectConfig.creationType === "new" ? "new_project" : "existing_project" : void 0
  });
  const {
    getPathSuggestions
  } = usePathSuggestions(fireCMSBackend, projectConfig, navigationController);
  const collectionEditorPlugin = useCollectionEditorPlugin({
    collectionConfigController,
    configPermissions,
    reservedGroups: RESERVED_GROUPS,
    getPathSuggestions,
    getUser: (uid) => {
      return userManagement.users.find((u) => u.uid === uid) ?? null;
    },
    collectionInference: buildCollectionInference(firebaseApp),
    getData: (path, parentPaths) => getFirestoreDataInPath2(firebaseApp, path, parentPaths, 400),
    onAnalyticsEvent,
    components: {
      DatabaseField: projectConfig.canUseCustomDatabase ? void 0 : PaywallDatabaseIdField
    }
  });
  const plugins = [saasPlugin, exportPlugin, importPlugin, collectionEditorPlugin, dataEnhancementPlugin];
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FireCMSBackEndProvider, { ...fireCMSBackend, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProjectConfigProvider, { config: projectConfig, children: /* @__PURE__ */ jsxRuntimeExports.jsx(UserManagementProvider, { userManagement, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ModeControllerProvider2, { value: modeController, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FireCMS2, { navigationController, dateTimeFormat: appConfig?.dateTimeFormat, entityViews: appConfig?.entityViews, locale: appConfig?.locale, propertyConfigs: propertyConfigsMap, authController, userConfigPersistence, dataSourceDelegate: firestoreDelegate, storageSource, entityLinkBuilder: ({
    entity
  }) => `https://console.firebase.google.com/project/${firebaseApp.options.projectId}/firestore/data/${entity.path}/${entity.id}`, onAnalyticsEvent, plugins, components: {
    missingReference: MissingReferenceWidget
  }, children: ({
    context,
    loading
  }) => {
    let component;
    if (loading) {
      component = /* @__PURE__ */ jsxRuntimeExports.jsxs(Scaffold2, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AppBar2, { logo: projectConfig.logo ?? logo, children: FireCMSAppBarComponent && /* @__PURE__ */ jsxRuntimeExports.jsx(FireCMSAppBarComponent, { title: projectConfig.projectName ?? "", ...appConfig?.fireCMSAppBarComponentProps }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCenter2, { text: "Almost there" })
      ] }, "project_scaffold_" + projectConfig.projectId);
    } else {
      component = /* @__PURE__ */ jsxRuntimeExports.jsxs(Scaffold2, { logo: projectConfig.logo ?? logo, autoOpenDrawer: appConfig?.autoOpenDrawer, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AppBar2, { children: FireCMSAppBarComponent && /* @__PURE__ */ jsxRuntimeExports.jsx(FireCMSAppBarComponent, { title: projectConfig.projectName ?? "", ...appConfig?.fireCMSAppBarComponentProps }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Drawer2, { children: dataTalkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(FireCMSCloudDataTalkDrawer, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(FireCMSCloudDrawer, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(NavigationRoutes2, { homePage: appConfig?.HomePage ? /* @__PURE__ */ jsxRuntimeExports.jsx(appConfig.HomePage, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(FireCMSCloudHomePage, {}), children: adminRoutes }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(SideDialogs2, {})
      ] }, "project_scaffold_" + projectConfig.projectId);
    }
    if (includeDataTalk) {
      component = /* @__PURE__ */ jsxRuntimeExports.jsx(DataTalkProvider, { config: dataTalkConfig, children: component }, "datatalk_provider_" + projectConfig.projectId);
    }
    return component;
  } }) }) }) }) });
}
function buildAdminRoutes(usersLimit, includeDataTalk, fireCMSBackend, projectConfig, dataTalkEndpoint, onAnalyticsEvent) {
  const views = [{
    path: "users",
    name: "CMS Users",
    group: "Admin",
    icon: "face",
    hideFromNavigation: true,
    view: /* @__PURE__ */ jsxRuntimeExports.jsx(UsersView, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SubscriptionPlanWidget, { showForPlans: ["free"], includeTooManyUsersAlert: true, message: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      "Upgrade to PLUS to remove the ",
      /* @__PURE__ */ jsxRuntimeExports.jsxs("b", { children: [
        usersLimit,
        " users limit"
      ] })
    ] }) }) })
  }, {
    path: "roles",
    name: "Roles",
    group: "Admin",
    icon: "gpp_good",
    hideFromNavigation: true,
    view: /* @__PURE__ */ jsxRuntimeExports.jsx(RolesView, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SubscriptionPlanWidget, { showForPlans: ["free"], includeTooManyUsersAlert: true, message: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      "Upgrade to PLUS to be able to customise ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: "roles" })
    ] }) }) })
  }, {
    path: "settings",
    name: "Project settings",
    group: "Admin",
    icon: "settings",
    hideFromNavigation: true,
    view: /* @__PURE__ */ jsxRuntimeExports.jsx(ProjectSettings, {})
  }];
  if (includeDataTalk) {
    views.push({
      path: "datatalk/*",
      name: "DataTalk",
      group: "Admin",
      icon: "settings",
      hideFromNavigation: true,
      view: /* @__PURE__ */ jsxRuntimeExports.jsx(DataTalkRoutes, { onAnalyticsEvent: (event, params) => {
        onAnalyticsEvent?.("datatalk:" + event, params);
      }, apiEndpoint: dataTalkEndpoint, getAuthToken: fireCMSBackend.getBackendAuthToken })
    });
  }
  return views.map(({
    path,
    name,
    view
  }) => /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path, element: view }, "navigation_admin_" + path));
}
export {
  ADMIN_VIEWS_CONFIG,
  AbcIcon,
  AcUnitIcon,
  AccessAlarmIcon,
  AccessAlarmsIcon,
  AccessTimeFilledIcon,
  AccessTimeIcon,
  AccessibilityIcon,
  AccessibilityNewIcon,
  AccessibleForwardIcon,
  AccessibleIcon,
  AccountBalanceIcon,
  AccountBalanceWalletIcon,
  AccountBoxIcon,
  AccountCircleIcon,
  AccountTreeIcon,
  ActiveSubscriptions,
  AdUnitsIcon,
  AdbIcon,
  AddAPhotoIcon,
  AddAlarmIcon,
  AddAlertIcon,
  AddBoxIcon,
  AddBusinessIcon,
  AddCardIcon,
  AddChartIcon,
  AddCircleIcon,
  AddCircleOutlineIcon,
  AddCommentIcon,
  AddHomeIcon,
  AddHomeWorkIcon,
  AddIcCallIcon,
  AddIcon,
  AddLinkIcon,
  AddLocationAltIcon,
  AddLocationIcon,
  AddModeratorIcon,
  AddPhotoAlternateIcon,
  AddReactionIcon,
  AddRoadIcon,
  AddShoppingCartIcon,
  AddTaskIcon,
  AddToDriveIcon,
  AddToHomeScreenIcon,
  AddToPhotosIcon,
  AddToQueueIcon,
  AdfScannerIcon,
  AdjustIcon,
  AdminPanelSettingsIcon,
  AdobeIcon,
  AdsClickIcon,
  AgricultureIcon,
  AirIcon,
  AirlineSeatFlatAngledIcon,
  AirlineSeatFlatIcon,
  AirlineSeatIndividualSuiteIcon,
  AirlineSeatLegroomExtraIcon,
  AirlineSeatLegroomNormalIcon,
  AirlineSeatLegroomReducedIcon,
  AirlineSeatReclineExtraIcon,
  AirlineSeatReclineNormalIcon,
  AirlineStopsIcon,
  AirlinesIcon,
  AirplaneTicketIcon,
  AirplanemodeActiveIcon,
  AirplanemodeInactiveIcon,
  AirplanemodeOffIcon,
  AirplanemodeOnIcon,
  AirplayIcon,
  AirportShuttleIcon,
  AlarmAddIcon,
  AlarmIcon,
  AlarmOffIcon,
  AlarmOnIcon,
  AlbumIcon,
  Alert,
  AlignHorizontalCenterIcon,
  AlignHorizontalLeftIcon,
  AlignHorizontalRightIcon,
  AlignVerticalBottomIcon,
  AlignVerticalCenterIcon,
  AlignVerticalTopIcon,
  AllInboxIcon,
  AllInclusiveIcon,
  AllOutIcon,
  AltRouteIcon,
  AlternateEmailIcon,
  AmpStoriesIcon,
  AnalyticsIcon,
  AnchorIcon,
  AndroidIcon,
  AnimationIcon,
  AnnouncementIcon,
  AodIcon,
  ApartmentIcon,
  ApiError2 as ApiError,
  ApiIcon,
  AppBar,
  AppBlockingIcon,
  AppContext,
  AppRegistrationIcon,
  AppSettingsAltIcon,
  AppShortcutIcon,
  AppleIcon,
  ApprovalIcon,
  AppsIcon,
  AppsOutageIcon,
  ArchitectureIcon,
  ArchiveIcon,
  AreaChartIcon,
  ArrayContainer,
  ArrayContainerItem,
  ArrayCustomShapedFieldBinding,
  ArrayEnumPreview,
  ArrayItemOptions,
  ArrayOfMapsPreview,
  ArrayOfReferencesFieldBinding,
  ArrayOfReferencesPreview,
  ArrayOfStorageComponentsPreview,
  ArrayOfStringsPreview,
  ArrayOneOfPreview,
  ArrayPropertyEnumPreview,
  ArrayPropertyPreview,
  ArrowBackIcon,
  ArrowBackIosIcon,
  ArrowBackIosNewIcon,
  ArrowCircleDownIcon,
  ArrowCircleLeftIcon,
  ArrowCircleRightIcon,
  ArrowCircleUpIcon,
  ArrowDownwardIcon,
  ArrowDropDownCircleIcon,
  ArrowDropDownIcon,
  ArrowDropUpIcon,
  ArrowForwardIcon,
  ArrowForwardIosIcon,
  ArrowLeftIcon,
  ArrowOutwardIcon,
  ArrowRightAltIcon,
  ArrowRightIcon,
  ArrowUpwardIcon,
  ArtTrackIcon,
  ArticleIcon,
  AspectRatioIcon,
  AssessmentIcon,
  AssignmentIcon,
  AssignmentIndIcon,
  AssignmentLateIcon,
  AssignmentReturnIcon,
  AssignmentReturnedIcon,
  AssignmentTurnedInIcon,
  AssistWalkerIcon,
  AssistantDirectionIcon,
  AssistantIcon,
  AssistantPhotoIcon,
  AssuredWorkloadIcon,
  AsyncPreviewComponent,
  AtmIcon,
  AttachEmailIcon,
  AttachFileIcon,
  AttachMoneyIcon,
  AttachmentIcon,
  AttractionsIcon,
  AttributionIcon,
  AudioFileIcon,
  AudiotrackIcon,
  AuthControllerContext,
  AutoAwesomeIcon,
  AutoAwesomeMosaicIcon,
  AutoAwesomeMotionIcon,
  AutoDeleteIcon,
  AutoFixHighIcon,
  AutoFixNormalIcon,
  AutoFixOffIcon,
  AutoGraphIcon,
  AutoModeIcon,
  AutoStoriesIcon,
  Autocomplete,
  AutocompleteItem,
  AutofpsSelectIcon,
  AutorenewIcon,
  AvTimerIcon,
  Avatar,
  BabyChangingStationIcon,
  BackHandIcon,
  BackpackIcon,
  BackspaceIcon,
  BackupIcon,
  BackupTableIcon,
  Badge,
  BadgeIcon,
  BakeryDiningIcon,
  BalanceIcon,
  BalconyIcon,
  BallotIcon,
  BarChartIcon,
  BatchPredictionIcon,
  BathroomIcon,
  BathtubIcon,
  Battery0BarIcon,
  Battery1BarIcon,
  Battery2BarIcon,
  Battery3BarIcon,
  Battery4BarIcon,
  Battery5BarIcon,
  Battery6BarIcon,
  BatteryAlertIcon,
  BatteryChargingFullIcon,
  BatteryFullIcon,
  BatterySaverIcon,
  BatteryStdIcon,
  BatteryUnknownIcon,
  BeachAccessIcon,
  BedIcon,
  BedroomBabyIcon,
  BedroomChildIcon,
  BedroomParentIcon,
  BedtimeIcon,
  BedtimeOffIcon,
  BeenhereIcon,
  BentoIcon,
  BikeScooterIcon,
  BiotechIcon,
  BlenderIcon,
  BlindIcon,
  BlindsClosedIcon,
  BlindsIcon,
  BlockFieldBinding,
  BlockIcon,
  BloodtypeIcon,
  BluetoothAudioIcon,
  BluetoothConnectedIcon,
  BluetoothDisabledIcon,
  BluetoothDriveIcon,
  BluetoothIcon,
  BluetoothSearchingIcon,
  BlurCircularIcon,
  BlurLinearIcon,
  BlurOffIcon,
  BlurOnIcon,
  BoltIcon,
  BookIcon,
  BookOnlineIcon,
  BookmarkAddIcon,
  BookmarkAddedIcon,
  BookmarkBorderIcon,
  BookmarkIcon,
  BookmarkOutlineIcon,
  BookmarkRemoveIcon,
  BookmarksIcon,
  BooleanPreview,
  BooleanSwitch,
  BooleanSwitchWithLabel,
  BorderAllIcon,
  BorderBottomIcon,
  BorderClearIcon,
  BorderColorIcon,
  BorderHorizontalIcon,
  BorderInnerIcon,
  BorderLeftIcon,
  BorderOuterIcon,
  BorderRightIcon,
  BorderStyleIcon,
  BorderTopIcon,
  BorderVerticalIcon,
  BoyIcon,
  BrandingWatermarkIcon,
  BreakfastDiningIcon,
  Brightness1Icon,
  Brightness2Icon,
  Brightness3Icon,
  Brightness4Icon,
  Brightness5Icon,
  Brightness6Icon,
  Brightness7Icon,
  BrightnessAutoIcon,
  BrightnessHighIcon,
  BrightnessLowIcon,
  BrightnessMediumIcon,
  BroadcastOnHomeIcon,
  BroadcastOnPersonalIcon,
  BrokenImageIcon,
  BrowseGalleryIcon,
  BrowserNotSupportedIcon,
  BrowserUpdatedIcon,
  BrunchDiningIcon,
  BrushIcon,
  BubbleChartIcon,
  BugReportIcon,
  BuildCircleIcon,
  BuildIcon,
  BungalowIcon,
  BurstModeIcon,
  BusAlertIcon,
  BusinessCenterIcon,
  BusinessIcon,
  Button,
  CHIP_COLORS,
  COLLECTION_PATH_SEPARATOR,
  CabinIcon,
  CableIcon,
  CachedIcon,
  CakeIcon,
  CalculateIcon,
  CalendarMonthIcon,
  CalendarTodayIcon,
  CalendarViewDayIcon,
  CalendarViewMonthIcon,
  CalendarViewWeekIcon,
  CallEndIcon,
  CallIcon,
  CallMadeIcon,
  CallMergeIcon,
  CallMissedIcon,
  CallMissedOutgoingIcon,
  CallReceivedIcon,
  CallSplitIcon,
  CallToActionIcon,
  CameraAltIcon,
  CameraEnhanceIcon,
  CameraFrontIcon,
  CameraIcon,
  CameraIndoorIcon,
  CameraOutdoorIcon,
  CameraRearIcon,
  CameraRollIcon,
  CameraswitchIcon,
  CampaignIcon,
  CancelIcon,
  CancelPresentationIcon,
  CancelScheduleSendIcon,
  CandlestickChartIcon,
  CarCrashIcon,
  CarRentalIcon,
  CarRepairIcon,
  Card,
  CardGiftcardIcon,
  CardMembershipIcon,
  CardTravelIcon,
  CarpenterIcon,
  CasesIcon,
  CasinoIcon,
  CastConnectedIcon,
  CastForEducationIcon,
  CastIcon,
  CastleIcon,
  CatchingPokemonIcon,
  CategoryIcon,
  CelebrationIcon,
  CellTowerIcon,
  CellWifiIcon,
  CenterFocusStrongIcon,
  CenterFocusWeakIcon,
  CenteredView,
  ChairAltIcon,
  ChairIcon,
  ChaletIcon,
  ChangeCircleIcon,
  ChangeHistoryIcon,
  ChargingStationIcon,
  ChatBubbleIcon,
  ChatBubbleOutlineIcon,
  ChatIcon,
  CheckBoxIcon,
  CheckBoxOutlineBlankIcon,
  CheckCircleIcon,
  CheckCircleOutlineIcon,
  CheckIcon,
  Checkbox,
  ChecklistIcon,
  ChecklistRtlIcon,
  CheckroomIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
  ChildCareIcon,
  ChildFriendlyIcon,
  Chip,
  ChromeReaderModeIcon,
  ChurchIcon,
  CircleIcon,
  CircleNotificationsIcon,
  CircularProgress,
  CircularProgressCenter,
  ClassIcon,
  CleanHandsIcon,
  CleaningServicesIcon,
  ClearAllIcon,
  ClearIcon,
  CloseFullscreenIcon,
  CloseIcon,
  ClosedCaptionDisabledIcon,
  ClosedCaptionIcon,
  ClosedCaptionOffIcon,
  CloudCircleIcon,
  CloudDoneIcon,
  CloudDownloadIcon,
  CloudErrorView,
  CloudIcon,
  CloudOffIcon,
  CloudQueueIcon,
  CloudSyncIcon,
  CloudUploadIcon,
  Co2Icon,
  CoPresentIcon,
  CodeIcon,
  CodeOffIcon,
  CoffeeIcon,
  CoffeeMakerIcon,
  Collapse,
  CollectionsBookmarkIcon,
  CollectionsIcon,
  ColorLensIcon,
  ColorizeIcon,
  CommentBankIcon,
  CommentIcon,
  CommentsDisabledIcon,
  CommitIcon,
  CommuteIcon,
  CompareArrowsIcon,
  CompareIcon,
  CompassCalibrationIcon,
  CompostIcon,
  CompressIcon,
  ComputerIcon,
  ConfirmationDialog,
  ConfirmationNumIcon,
  ConfirmationNumberIcon,
  ConnectWithoutContactIcon,
  ConnectedTvIcon,
  ConnectingAirportsIcon,
  ConstructionIcon,
  ContactEmergencyIcon,
  ContactMailIcon,
  ContactPageIcon,
  ContactPhoneIcon,
  ContactSupportIcon,
  ContactlessIcon,
  ContactsIcon,
  Container,
  ContentCopyIcon,
  ContentCutIcon,
  ContentPasteGoIcon,
  ContentPasteIcon,
  ContentPasteOffIcon,
  ContentPasteSearchIcon,
  ContrastIcon,
  ControlCameraIcon,
  ControlPointDuplicateIcon,
  ControlPointIcon,
  CookieIcon,
  CopyAllIcon,
  CopyIcon,
  CopyrightIcon,
  CoronavirusIcon,
  CorporateFareIcon,
  CottageIcon,
  CountertopsIcon,
  CreateIcon,
  CreateNewFolderIcon,
  CreditCardIcon,
  CreditCardOffIcon,
  CreditScoreIcon,
  CribIcon,
  CrisisAlertIcon,
  Crop169Icon,
  Crop32Icon,
  Crop54Icon,
  Crop75Icon,
  CropDinIcon,
  CropFreeIcon,
  CropIcon,
  CropLandscapeIcon,
  CropOriginalIcon,
  CropPortraitIcon,
  CropRotateIcon,
  CropSquareIcon,
  CrueltyFreeIcon,
  CssIcon,
  CurrencyBitcoinIcon,
  CurrencyExchangeIcon,
  CurrencyFrancIcon,
  CurrencyLiraIcon,
  CurrencyPoundIcon,
  CurrencyRubleIcon,
  CurrencyRupeeIcon,
  CurrencyYenIcon,
  CurrencyYuanIcon,
  CurrentSubscriptionView$1 as CurrentSubscriptionView,
  CurtainsClosedIcon,
  CurtainsIcon,
  CutIcon,
  CycloneIcon,
  DEFAULT_FIELD_CONFIGS,
  DRAWER_WIDTH,
  DangerousIcon,
  DarkModeIcon,
  DashboardCustomizeIcon,
  DashboardIcon,
  DataArrayIcon,
  DataExplorationIcon,
  DataObjectIcon,
  DataSaverOffIcon,
  DataSaverOnIcon,
  DataThresholdingIcon,
  DataUsageIcon,
  DatasetIcon,
  DatasetLinkedIcon,
  DatePreview,
  DateRangeIcon,
  DateTimeField,
  DateTimeFieldBinding,
  DeblurIcon,
  DebouncedTextField,
  DeckIcon,
  DefaultAppBar,
  DefaultDrawer,
  DefaultHomePage,
  DehazeIcon,
  DeleteForeverIcon,
  DeleteIcon,
  DeleteOutlineIcon,
  DeleteSweepIcon,
  DeliveryDiningIcon,
  DensityLargeIcon,
  DensityMediumIcon,
  DensitySmallIcon,
  DepartureBoardIcon,
  DescriptionIcon,
  DeselectIcon,
  DesignServicesIcon,
  DeskIcon,
  DesktopAccessDisabledIcon,
  DesktopMacIcon,
  DesktopWindowsIcon,
  DetailsIcon,
  DeveloperBoardIcon,
  DeveloperBoardOffIcon,
  DeveloperModeIcon,
  DeviceHubIcon,
  DeviceThermostatIcon,
  DeviceUnknownIcon,
  DevicesFoldIcon,
  DevicesIcon,
  DevicesOtherIcon,
  DialerSipIcon,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  DialpadIcon,
  DiamondIcon,
  DifferenceIcon,
  DiningIcon,
  DinnerDiningIcon,
  DirectionsBikeIcon,
  DirectionsBoatFilledIcon,
  DirectionsBoatIcon,
  DirectionsBusFilledIcon,
  DirectionsBusIcon,
  DirectionsCarFilledIcon,
  DirectionsCarIcon,
  DirectionsFerryIcon,
  DirectionsIcon,
  DirectionsOffIcon,
  DirectionsRailwayFilledIcon,
  DirectionsRailwayIcon,
  DirectionsRunIcon,
  DirectionsSubwayFilledIcon,
  DirectionsSubwayIcon,
  DirectionsTrainIcon,
  DirectionsTransitFilledIcon,
  DirectionsTransitIcon,
  DirectionsWalkIcon,
  DirtyLensIcon,
  DisabledByDefaultIcon,
  DisabledVisibleIcon,
  DiscFullIcon,
  DiscordIcon,
  DiscountIcon,
  DisplaySettingsIcon,
  Diversity1Icon,
  Diversity2Icon,
  Diversity3Icon,
  DndForwardslashIcon,
  DnsIcon,
  DoDisturbAltIcon,
  DoDisturbIcon,
  DoDisturbOffIcon,
  DoDisturbOnIcon,
  DoNotDisturbAltIcon,
  DoNotDisturbIcon,
  DoNotDisturbOffIcon,
  DoNotDisturbOnIcon,
  DoNotDisturbOnTotalSilenceIcon,
  DoNotStepIcon,
  DoNotTouchIcon,
  DockIcon,
  DocumentScannerIcon,
  DomainAddIcon,
  DomainDisabledIcon,
  DomainIcon,
  DomainVerificationIcon,
  DoneAllIcon,
  DoneIcon,
  DoneOutlineIcon,
  DonutLargeIcon,
  DonutSmallIcon,
  DoorBackIcon,
  DoorFrontIcon,
  DoorSlidingIcon,
  DoorbellIcon,
  DoubleArrowIcon,
  DownhillSkiingIcon,
  DownloadDoneIcon,
  DownloadForOfflineIcon,
  DownloadIcon,
  DownloadingIcon,
  DraftsIcon,
  DragHandleIcon,
  DragIndicatorIcon,
  DrawIcon,
  Drawer,
  DrawerLogo,
  DrawerNavigationItem,
  DriveEtaIcon,
  DriveFileMoveIcon,
  DriveFileMoveRtlIcon,
  DriveFileRenameOutlineIcon,
  DriveFolderUploadIcon,
  DryCleaningIcon,
  DryIcon,
  DuoIcon,
  DvrIcon,
  DynamicFeedIcon,
  DynamicFormIcon,
  EMobiledataIcon,
  EarbudsBatteryIcon,
  EarbudsIcon,
  EastIcon,
  EcoIcon,
  EdgesensorHighIcon,
  EdgesensorLowIcon,
  EditAttributesIcon,
  EditCalendarIcon,
  EditIcon,
  EditLocationAltIcon,
  EditLocationIcon,
  EditNoteIcon,
  EditNotificationsIcon,
  EditOffIcon,
  EditRoadIcon,
  EggAltIcon,
  EggIcon,
  EjectIcon,
  ElderlyIcon,
  ElderlyWomanIcon,
  ElectricBikeIcon,
  ElectricBoltIcon,
  ElectricCarIcon,
  ElectricMeterIcon,
  ElectricMopedIcon,
  ElectricRickshawIcon,
  ElectricScooterIcon,
  ElectricalServicesIcon,
  ElevatorIcon,
  EmailIcon,
  EmergencyIcon,
  EmergencyRecordingIcon,
  EmergencyShareIcon,
  EmojiEmotionsIcon,
  EmojiEventsIcon,
  EmojiFlagsIcon,
  EmojiFoodBeverageIcon,
  EmojiNatureIcon,
  EmojiObjectsIcon,
  EmojiPeopleIcon,
  EmojiSymbolsIcon,
  EmojiTransportationIcon,
  EmptyValue,
  EnergySavingsLeafIcon,
  EngineeringIcon,
  EnhancePhotoTranslateIcon,
  EnhancedEncryptionIcon,
  EntityCollectionRowActions,
  EntityCollectionTable,
  EntityCollectionView,
  EntityCollectionViewActions,
  EntityReference,
  EntityView,
  EnumValuesChip,
  EqualizerIcon,
  ErrorBoundary,
  ErrorIcon,
  ErrorOutlineIcon,
  ErrorView,
  EscalatorIcon,
  EscalatorWarningIcon,
  EuroIcon,
  EuroSymbolIcon,
  EvStationIcon,
  EventAvailableIcon,
  EventBusyIcon,
  EventIcon,
  EventNoteIcon,
  EventRepeatIcon,
  EventSeatIcon,
  ExitToAppIcon,
  ExpandCircleDownIcon,
  ExpandIcon,
  ExpandLessIcon,
  ExpandMoreIcon,
  ExpandablePanel,
  ExplicitIcon,
  ExploreIcon,
  ExploreOffIcon,
  ExposureIcon,
  ExposureMinus1Icon,
  ExposureMinus2Icon,
  ExposureNeg1Icon,
  ExposureNeg2Icon,
  ExposurePlus1Icon,
  ExposurePlus2Icon,
  ExposureZeroIcon,
  ExtensionIcon,
  ExtensionOffIcon,
  Face2Icon,
  Face3Icon,
  Face4Icon,
  Face5Icon,
  Face6Icon,
  FaceIcon,
  FaceRetouchingNaturalIcon,
  FaceRetouchingOffIcon,
  FaceUnlockIcon,
  FacebookIcon,
  FactCheckIcon,
  FactoryIcon,
  FamilyRestroomIcon,
  FastForwardIcon,
  FastRewindIcon,
  FastfoodIcon,
  FavoriteBorderIcon,
  FavoriteIcon,
  FavoriteOutlineIcon,
  FaxIcon,
  FeaturedPlayListIcon,
  FeaturedVideoIcon,
  FeedIcon,
  FeedbackIcon,
  FemaleIcon,
  FenceIcon,
  FestivalIcon,
  FiberDvrIcon,
  FiberManualRecordIcon,
  FiberNewIcon,
  FiberPinIcon,
  FiberSmartRecordIcon,
  FieldCaption,
  FieldHelperText,
  FileCopyIcon,
  FileDownloadDoneIcon,
  FileDownloadIcon,
  FileDownloadOffIcon,
  FileOpenIcon,
  FilePresentIcon,
  FileUpload,
  FileUploadIcon,
  Filter1Icon,
  Filter2Icon,
  Filter3Icon,
  Filter4Icon,
  Filter5Icon,
  Filter6Icon,
  Filter7Icon,
  Filter8Icon,
  Filter9Icon,
  Filter9PlusIcon,
  FilterAltIcon,
  FilterAltOffIcon,
  FilterBAndWIcon,
  FilterCenterFocusIcon,
  FilterDramaIcon,
  FilterFramesIcon,
  FilterHdrIcon,
  FilterIcon,
  FilterListIcon,
  FilterListOffIcon,
  FilterNoneIcon,
  FilterTiltShiftIcon,
  FilterVintageIcon,
  FindInPageIcon,
  FindReplaceIcon,
  FingerprintIcon,
  FireCMS,
  FireCMSBackEndProvider,
  FireCMSBackendContext,
  FireCMSClient,
  FireCMSClientWithController,
  FireCMSCloudApp,
  FireCMSCloudDrawer,
  FireCMSCloudLoginView,
  FireCMSDataEnhancementSubscriptionMessage,
  FireCMSFirebaseApp,
  FireCMSLogo,
  FireExtinguisherIcon,
  FireHydrantAltIcon,
  FireTruckIcon,
  FirebaseLoginView,
  FireplaceIcon,
  FirstPageIcon,
  FitScreenIcon,
  FitbitIcon,
  FitnessCenterIcon,
  FlagCircleIcon,
  FlagIcon,
  FlakyIcon,
  FlareIcon,
  FlashAutoIcon,
  FlashOffIcon,
  FlashOnIcon,
  FlashlightOffIcon,
  FlashlightOnIcon,
  FlatwareIcon,
  FlightClassIcon,
  FlightIcon,
  FlightLandIcon,
  FlightTakeoffIcon,
  FlipCameraAndroidIcon,
  FlipCameraIosIcon,
  FlipIcon,
  FlipToBackIcon,
  FlipToFrontIcon,
  FloodIcon,
  FlourescentIcon,
  FluorescentIcon,
  FlutterDashIcon,
  FmdBadIcon,
  FmdGoodIcon,
  FolderCopyIcon,
  FolderDeleteIcon,
  FolderIcon,
  FolderOffIcon,
  FolderOpenIcon,
  FolderSharedIcon,
  FolderSpecialIcon,
  FolderZipIcon,
  FollowTheSignsIcon,
  FontDownloadIcon,
  FontDownloadOffIcon,
  FoodBankIcon,
  ForestIcon,
  ForkLeftIcon,
  ForkRightIcon,
  FormatAlignCenterIcon,
  FormatAlignJustifyIcon,
  FormatAlignLeftIcon,
  FormatAlignRightIcon,
  FormatBoldIcon,
  FormatClearIcon,
  FormatColorFillIcon,
  FormatColorResetIcon,
  FormatColorTextIcon,
  FormatIndentDecreaseIcon,
  FormatIndentIncreaseIcon,
  FormatItalicIcon,
  FormatLineSpacingIcon,
  FormatListBulletedIcon,
  FormatListNumberedIcon,
  FormatListNumberedRtlIcon,
  FormatOverlineIcon,
  FormatPaintIcon,
  FormatQuoteIcon,
  FormatShapesIcon,
  FormatSizeIcon,
  FormatStrikethroughIcon,
  FormatTextdirectionLToRIcon,
  FormatTextdirectionRToLIcon,
  FormatUnderlineIcon,
  FormatUnderlinedIcon,
  FortIcon,
  ForumIcon,
  Forward10Icon,
  Forward30Icon,
  Forward5Icon,
  ForwardIcon,
  ForwardToInboxIcon,
  FoundationIcon,
  FreeBreakfastIcon,
  FreeCancellationIcon,
  FrontHandIcon,
  FullscreenExitIcon,
  FullscreenIcon,
  FunctionsIcon,
  GMobiledataIcon,
  GTranslateIcon,
  GamepadIcon,
  GamesIcon,
  GarageIcon,
  GasMeterIcon,
  GavelIcon,
  GeneratingTokensIcon,
  GeoPoint,
  GestureIcon,
  GetAppIcon,
  GifBoxIcon,
  GifIcon,
  GirlIcon,
  GitHubIcon,
  GiteIcon,
  GolfCourseIcon,
  GoogleLoginButton,
  GppBadIcon,
  GppGoodIcon,
  GppMaybeIcon,
  GpsFixedIcon,
  GpsNotFixedIcon,
  GpsOffIcon,
  GradeIcon,
  GradientIcon,
  GradingIcon,
  GrainIcon,
  GraphicEqIcon,
  GrassIcon,
  Grid3x3Icon,
  Grid4x4Icon,
  GridGoldenratioIcon,
  GridOffIcon,
  GridOnIcon,
  GridViewIcon,
  GroupAddIcon,
  GroupIcon,
  GroupOffIcon,
  GroupRemoveIcon,
  GroupWorkIcon,
  Groups2Icon,
  Groups3Icon,
  GroupsIcon,
  HMobiledataIcon,
  HPlusMobiledataIcon,
  HailIcon,
  HandleIcon,
  HandshakeIcon,
  HandymanIcon,
  HardwareIcon,
  HdIcon,
  HdrAutoIcon,
  HdrAutoSelectIcon,
  HdrEnhancedSelectIcon,
  HdrOffIcon,
  HdrOffSelectIcon,
  HdrOnIcon,
  HdrOnSelectIcon,
  HdrPlusIcon,
  HdrStrongIcon,
  HdrWeakIcon,
  HeadphonesBatteryIcon,
  HeadphonesIcon,
  HeadsetIcon,
  HeadsetMicIcon,
  HeadsetOffIcon,
  HealingIcon,
  HealthAndSafetyIcon,
  HearingDisabledIcon,
  HearingIcon,
  HeartBrokenIcon,
  HeatPumpIcon,
  HeightIcon,
  HelpCenterIcon,
  HelpIcon,
  HelpOutlineIcon,
  HevcIcon,
  HexagonIcon,
  HideImageIcon,
  HideSourceIcon,
  HighQualityIcon,
  HighlightAltIcon,
  HighlightIcon,
  HighlightOffIcon,
  HighlightRemoveIcon,
  HikingIcon,
  HistoryEduIcon,
  HistoryIcon,
  HistoryToggleOffIcon,
  HiveIcon,
  HlsIcon,
  HlsOffIcon,
  HolidayVillageIcon,
  HomeIcon,
  HomeMaxIcon,
  HomeMiniIcon,
  HomeRepairServiceIcon,
  HomeWorkIcon,
  HorizontalDistributeIcon,
  HorizontalRuleIcon,
  HorizontalSplitIcon,
  HotTubIcon,
  HotelClassIcon,
  HotelIcon,
  HourglassBottomIcon,
  HourglassDisabledIcon,
  HourglassEmptyIcon,
  HourglassFullIcon,
  HourglassTopIcon,
  HouseIcon,
  HouseSidingIcon,
  HouseboatIcon,
  HowToRegIcon,
  HowToVoteIcon,
  HtmlIcon,
  HttpIcon,
  HttpsIcon,
  HubIcon,
  HvacIcon,
  IceSkatingIcon,
  IcecreamIcon,
  Icon,
  IconButton,
  IconForView,
  ImageAspectRatioIcon,
  ImageIcon,
  ImageNotSupportedIcon,
  ImagePreview,
  ImageSearchIcon,
  ImagesearchRollerIcon,
  ImportContactsIcon,
  ImportExportIcon,
  ImportantDevicesIcon,
  InboxIcon,
  IncompleteCircleIcon,
  IndeterminateCheckBoxIcon,
  InfoIcon,
  InfoLabel,
  InfoOutlineIcon,
  InputIcon,
  InputLabel,
  InsertChartIcon,
  InsertChartOutlinedIcon,
  InsertCommentIcon,
  InsertDriveFileIcon,
  InsertEmoticonIcon,
  InsertInvitationIcon,
  InsertLinkIcon,
  InsertPageBreakIcon,
  InsertPhotoIcon,
  InsightsIcon,
  InstallDesktopIcon,
  InstallMobileIcon,
  IntegrationInstructionsIcon,
  InterestsIcon,
  InterpreterModeIcon,
  Inventory2Icon,
  InventoryIcon,
  InvertColorsIcon,
  InvertColorsOffIcon,
  InvertColorsOnIcon,
  IosShareIcon,
  IronIcon,
  IsoIcon,
  JavascriptIcon,
  JoinFullIcon,
  JoinInnerIcon,
  JoinLeftIcon,
  JoinRightIcon,
  KayakingIcon,
  KebabDiningIcon,
  KeyIcon,
  KeyOffIcon,
  KeyValueFieldBinding,
  KeyValuePreview,
  KeyboardAltIcon,
  KeyboardArrowDownIcon,
  KeyboardArrowLeftIcon,
  KeyboardArrowRightIcon,
  KeyboardArrowUpIcon,
  KeyboardBackspaceIcon,
  KeyboardCapslockIcon,
  KeyboardCommandKeyIcon,
  KeyboardControlIcon,
  KeyboardControlKeyIcon,
  KeyboardDoubleArrowDownIcon,
  KeyboardDoubleArrowLeftIcon,
  KeyboardDoubleArrowRightIcon,
  KeyboardDoubleArrowUpIcon,
  KeyboardHideIcon,
  KeyboardIcon,
  KeyboardOptionKeyIcon,
  KeyboardReturnIcon,
  KeyboardTabIcon,
  KeyboardVoiceIcon,
  KingBedIcon,
  KitchenIcon,
  KitesurfingIcon,
  Label,
  LabelIcon,
  LabelImportantIcon,
  LabelImportantOutlineIcon,
  LabelOffIcon,
  LabelOutlineIcon,
  LabelWithIcon,
  LabelWithIconAndTooltip,
  LanIcon,
  LandscapeIcon,
  LandslideIcon,
  LanguageIcon,
  LaptopChromebookIcon,
  LaptopIcon,
  LaptopMacIcon,
  LaptopWindowsIcon,
  LastPageIcon,
  LaunchIcon,
  LayersClearIcon,
  LayersIcon,
  LeaderboardIcon,
  LeakAddIcon,
  LeakRemoveIcon,
  LeaveBagsAtHomeIcon,
  LegendToggleIcon,
  LensBlurIcon,
  LensIcon,
  LibraryAddCheckIcon,
  LibraryAddIcon,
  LibraryBooksIcon,
  LibraryMusicIcon,
  LightIcon,
  LightModeIcon,
  LightbulbCircleIcon,
  LightbulbIcon,
  LightbulbOutlineIcon,
  LineAxisIcon,
  LineStyleIcon,
  LineWeightIcon,
  LinearScaleIcon,
  LinkIcon,
  LinkOffIcon,
  LinkedCameraIcon,
  LiquorIcon,
  ListAltIcon,
  ListIcon,
  LiveHelpIcon,
  LiveTvIcon,
  LivingIcon,
  LoadingButton,
  LocalActivityIcon,
  LocalAirportIcon,
  LocalAtmIcon,
  LocalAttractionIcon,
  LocalBarIcon,
  LocalCafeIcon,
  LocalCarWashIcon,
  LocalConvenienceStoreIcon,
  LocalDiningIcon,
  LocalDrinkIcon,
  LocalFireDepartmentIcon,
  LocalFloristIcon,
  LocalGasStationIcon,
  LocalGroceryStoreIcon,
  LocalHospitalIcon,
  LocalHotelIcon,
  LocalLaundryServiceIcon,
  LocalLibraryIcon,
  LocalMallIcon,
  LocalMoviesIcon,
  LocalOfferIcon,
  LocalParkingIcon,
  LocalPharmacyIcon,
  LocalPhoneIcon,
  LocalPizzaIcon,
  LocalPlayIcon,
  LocalPoliceIcon,
  LocalPostOfficeIcon,
  LocalPrintshopIcon,
  LocalRestaurantIcon,
  LocalSeeIcon,
  LocalShippingIcon,
  LocalTaxiIcon,
  LocationCityIcon,
  LocationDisabledIcon,
  LocationHistoryIcon,
  LocationOffIcon,
  LocationOnIcon,
  LocationSearchingIcon,
  LockClockIcon,
  LockIcon,
  LockOpenIcon,
  LockOutlineIcon,
  LockPersonIcon,
  LockResetIcon,
  LoginButton,
  LoginIcon,
  LogoDevIcon,
  LogoutIcon,
  Looks3Icon,
  Looks4Icon,
  Looks5Icon,
  Looks6Icon,
  LooksIcon,
  LooksOneIcon,
  LooksTwoIcon,
  LoopIcon,
  LoupeIcon,
  LowPriorityIcon,
  LoyaltyIcon,
  LteMobiledataIcon,
  LtePlusMobiledataIcon,
  LuggageIcon,
  LunchDiningIcon,
  LyricsIcon,
  MacroOffIcon,
  MailIcon,
  MailLockIcon,
  MailOutlineIcon,
  MaleIcon,
  Man2Icon,
  Man3Icon,
  Man4Icon,
  ManIcon,
  ManageAccountsIcon,
  ManageHistoryIcon,
  ManageSearchIcon,
  MapFieldBinding,
  MapIcon,
  MapPropertyPreview,
  MapsHomeWorkIcon,
  MapsUgcIcon,
  MarginIcon,
  MarkAsUnreadIcon,
  MarkChatReadIcon,
  MarkChatUnreadIcon,
  MarkEmailReadIcon,
  MarkEmailUnreadIcon,
  MarkUnreadChatAltIcon,
  Markdown,
  MarkdownEditorFieldBinding,
  MarkunreadIcon,
  MarkunreadMailboxIcon,
  MasksIcon,
  MaximizeIcon,
  MediaBluetoothOffIcon,
  MediaBluetoothOnIcon,
  MediationIcon,
  MedicalInformationIcon,
  MedicalServicesIcon,
  MedicationIcon,
  MedicationLiquidIcon,
  MeetingRoomIcon,
  MemoryIcon,
  Menu,
  MenuBookIcon,
  MenuIcon,
  MenuItem,
  MenuOpenIcon,
  Menubar,
  MenubarCheckboxItem,
  MenubarContent,
  MenubarItem,
  MenubarItemIndicator,
  MenubarMenu,
  MenubarPortal,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarSeparator,
  MenubarShortcut,
  MenubarSub,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarSubTriggerIndicator,
  MenubarTrigger,
  MergeIcon,
  MergeTypeIcon,
  MessageIcon,
  MessengerIcon,
  MessengerOutlineIcon,
  MicExternalOffIcon,
  MicExternalOnIcon,
  MicIcon,
  MicNoneIcon,
  MicOffIcon,
  MicrowaveIcon,
  MilitaryTechIcon,
  MinimizeIcon,
  MinorCrashIcon,
  MiscellaneousServicesIcon,
  MissedVideoCallIcon,
  MmsIcon,
  MobileFriendlyIcon,
  MobileOffIcon,
  MobileScreenShareIcon,
  MobiledataOffIcon,
  ModeCommentIcon,
  ModeControllerContext,
  ModeControllerProvider,
  ModeEditIcon,
  ModeEditOutlineIcon,
  ModeFanOffIcon,
  ModeIcon,
  ModeNightIcon,
  ModeOfTravelIcon,
  ModeStandbyIcon,
  ModelTrainingIcon,
  MonetizationOnIcon,
  MoneyIcon,
  MoneyOffCsredIcon,
  MoneyOffIcon,
  MonitorHeartIcon,
  MonitorIcon,
  MonitorWeightIcon,
  MonochromePhotosIcon,
  MoodBadIcon,
  MoodIcon,
  MopedIcon,
  MoreHorizIcon,
  MoreIcon,
  MoreTimeIcon,
  MoreVertIcon,
  MosqueIcon,
  MotionPhotosAutoIcon,
  MotionPhotosOffIcon,
  MotionPhotosOnIcon,
  MotionPhotosPauseIcon,
  MotionPhotosPausedIcon,
  MotorcycleIcon,
  MouseIcon,
  MoveDownIcon,
  MoveToInboxIcon,
  MoveUpIcon,
  MovieCreationIcon,
  MovieFilterIcon,
  MovieIcon,
  MovingIcon,
  MpIcon,
  MultiSelect,
  MultiSelectContext,
  MultiSelectFieldBinding,
  MultiSelectItem,
  MultilineChartIcon,
  MultipleStopIcon,
  MultitrackAudioIcon,
  MuseumIcon,
  MusicNoteIcon,
  MusicOffIcon,
  MusicVideoIcon,
  MyLibraryAddIcon,
  MyLibraryBooksIcon,
  MyLibraryMusicIcon,
  MyLocationIcon,
  NatIcon,
  NatureIcon,
  NaturePeopleIcon,
  NavigateBeforeIcon,
  NavigateNextIcon,
  NavigationCard,
  NavigationCardBinding,
  NavigationGroup,
  NavigationIcon,
  NavigationRoutes,
  NearMeDisabledIcon,
  NearMeIcon,
  NearbyErrorIcon,
  NearbyOffIcon,
  NestCamWiredStandIcon,
  NetworkCellIcon,
  NetworkCheckIcon,
  NetworkLockedIcon,
  NetworkPingIcon,
  NetworkWifi1BarIcon,
  NetworkWifi2BarIcon,
  NetworkWifi3BarIcon,
  NetworkWifiIcon,
  NewLabelIcon,
  NewReleasesIcon,
  NewspaperIcon,
  NextPlanIcon,
  NextWeekIcon,
  NfcIcon,
  NightShelterIcon,
  NightlifeIcon,
  NightlightIcon,
  NightlightRoundIcon,
  NightsStayIcon,
  NoAccountsIcon,
  NoAdultContentIcon,
  NoBackpackIcon,
  NoCellIcon,
  NoCrashIcon,
  NoDrinksIcon,
  NoEncryptionGmailerrorredIcon,
  NoEncryptionIcon,
  NoFlashIcon,
  NoFoodIcon,
  NoLuggageIcon,
  NoMealsIcon,
  NoMeetingRoomIcon,
  NoPhotographyIcon,
  NoSimIcon,
  NoStrollerIcon,
  NoTransferIcon,
  NoiseAwareIcon,
  NoiseControlOffIcon,
  NordicWalkingIcon,
  NorthEastIcon,
  NorthIcon,
  NorthWestIcon,
  NotAccessibleIcon,
  NotFoundPage,
  NotInterestedIcon,
  NotListedLocationIcon,
  NotStartedIcon,
  NoteAddIcon,
  NoteAltIcon,
  NoteIcon,
  NotesIcon,
  NotificationAddIcon,
  NotificationImportantIcon,
  NotificationsActiveIcon,
  NotificationsIcon,
  NotificationsNoneIcon,
  NotificationsOffIcon,
  NotificationsOnIcon,
  NotificationsPausedIcon,
  NowWallpaperIcon,
  NowWidgetsIcon,
  NumberPropertyPreview,
  NumbersIcon,
  OfflineBoltIcon,
  OfflinePinIcon,
  OfflineShareIcon,
  OilBarrelIcon,
  OnDeviceTrainingIcon,
  OndemandVideoIcon,
  OnlinePredictionIcon,
  OpacityIcon,
  OpenInBrowserIcon,
  OpenInFullIcon,
  OpenInNewIcon,
  OpenInNewOffIcon,
  OpenWithIcon,
  OtherHousesIcon,
  OutbondIcon,
  OutboundIcon,
  OutboxIcon,
  OutdoorGrillIcon,
  OutletIcon,
  OutlinedFlagIcon,
  OutputIcon,
  PaddingIcon,
  PagesIcon,
  PageviewIcon,
  PaidIcon,
  PaletteIcon,
  PanToolAltIcon,
  PanToolIcon,
  PanoramaFisheyeIcon,
  PanoramaHorizontalIcon,
  PanoramaHorizontalSelectIcon,
  PanoramaIcon,
  PanoramaPhotosphereIcon,
  PanoramaPhotosphereSelectIcon,
  PanoramaVerticalIcon,
  PanoramaVerticalSelectIcon,
  PanoramaWideAngleIcon,
  PanoramaWideAngleSelectIcon,
  Paper,
  ParaglidingIcon,
  ParkIcon,
  PartyModeIcon,
  PasswordIcon,
  PasteIcon,
  PatternIcon,
  PauseCircleFilledIcon,
  PauseCircleIcon,
  PauseCircleOutlineIcon,
  PauseIcon,
  PausePresentationIcon,
  PaymentIcon,
  PaymentsIcon,
  PaypalIcon,
  PedalBikeIcon,
  PendingActionsIcon,
  PendingIcon,
  PentagonIcon,
  PeopleAltIcon,
  PeopleIcon,
  PeopleOutlineIcon,
  PercentIcon,
  PermCameraMicIcon,
  PermContactCalIcon,
  PermContactCalendarIcon,
  PermDataSettingIcon,
  PermDeviceInfoIcon,
  PermDeviceInformationIcon,
  PermIdentityIcon,
  PermMediaIcon,
  PermPhoneMsgIcon,
  PermScanWifiIcon,
  Person2Icon,
  Person3Icon,
  Person4Icon,
  PersonAddAlt1Icon,
  PersonAddAltIcon,
  PersonAddDisabledIcon,
  PersonAddIcon,
  PersonIcon,
  PersonOffIcon,
  PersonOutlineIcon,
  PersonPinCircleIcon,
  PersonPinIcon,
  PersonRemoveAlt1Icon,
  PersonRemoveIcon,
  PersonSearchIcon,
  PersonalInjuryIcon,
  PersonalVideoIcon,
  PestControlIcon,
  PestControlRodentIcon,
  PetsIcon,
  PhishingIcon,
  PhoneAndroidIcon,
  PhoneBluetoothSpeakerIcon,
  PhoneCallbackIcon,
  PhoneDisabledIcon,
  PhoneEnabledIcon,
  PhoneForwardedIcon,
  PhoneIcon,
  PhoneInTalkIcon,
  PhoneIphoneIcon,
  PhoneLockedIcon,
  PhoneMissedIcon,
  PhonePausedIcon,
  PhonelinkEraseIcon,
  PhonelinkIcon,
  PhonelinkLockIcon,
  PhonelinkOffIcon,
  PhonelinkRingIcon,
  PhonelinkSetupIcon,
  PhotoAlbumIcon,
  PhotoCameraBackIcon,
  PhotoCameraFrontIcon,
  PhotoCameraIcon,
  PhotoFilterIcon,
  PhotoIcon,
  PhotoLibraryIcon,
  PhotoSizeSelectActualIcon,
  PhotoSizeSelectLargeIcon,
  PhotoSizeSelectSmallIcon,
  PhpIcon,
  PianoIcon,
  PianoOffIcon,
  PictureAsPdfIcon,
  PictureInPictureAltIcon,
  PictureInPictureIcon,
  PieChartIcon,
  PieChartOutlineIcon,
  PinDropIcon,
  PinEndIcon,
  PinIcon,
  PinInvokeIcon,
  PinchIcon,
  PivotTableChartIcon,
  PixIcon,
  PlaceIcon,
  PlagiarismIcon,
  PlanChip,
  PlansComparison,
  PlansComparisonDialog,
  PlayArrowIcon,
  PlayCircleFillIcon,
  PlayCircleFilledIcon,
  PlayCircleIcon,
  PlayCircleOutlineIcon,
  PlayDisabledIcon,
  PlayForWorkIcon,
  PlayLessonIcon,
  PlaylistAddCheckCircleIcon,
  PlaylistAddCheckIcon,
  PlaylistAddCircleIcon,
  PlaylistAddIcon,
  PlaylistPlayIcon,
  PlaylistRemoveIcon,
  PlumbingIcon,
  PlusOneIcon,
  PodcastsIcon,
  PointOfSaleIcon,
  PolicyIcon,
  PollIcon,
  PolylineIcon,
  PolymerIcon,
  PoolIcon,
  Popover,
  PortableWifiOffIcon,
  PortraitIcon,
  PostAddIcon,
  PowerIcon,
  PowerInputIcon,
  PowerOffIcon,
  PowerSettingsNewIcon,
  PrecisionManufacturingIcon,
  PregnantWomanIcon,
  PresentToAllIcon,
  PreviewIcon,
  PriceChangeIcon,
  PriceCheckIcon,
  PrintDisabledIcon,
  PrintIcon,
  PriorityHighIcon,
  PrivacyTipIcon,
  PrivateConnectivityIcon,
  ProductUpgradeSmallView,
  ProductionQuantityLimitsIcon,
  ProjectConfigContext,
  ProjectConfigProvider,
  ProjectSettings,
  ProjectSubscriptionPlans,
  PropaneIcon,
  PropaneTankIcon,
  PropertyConfigBadge,
  PropertyFieldBinding,
  PropertyIdCopyTooltip,
  PropertyIdCopyTooltipContent,
  PropertyPreview,
  PropertyTableCell,
  PsychologyAltIcon,
  PsychologyIcon,
  PublicIcon,
  PublicOffIcon,
  PublishIcon,
  PublishedWithChangesIcon,
  PunchClockIcon,
  PushPinIcon,
  QrCode2Icon,
  QrCodeIcon,
  QrCodeScannerIcon,
  QueryBuilderIcon,
  QueryStatsIcon,
  QuestionAnswerIcon,
  QuestionMarkIcon,
  QueueIcon,
  QueueMusicIcon,
  QueuePlayNextIcon,
  QuickContactsDialerIcon,
  QuickContactsMailIcon,
  QuickreplyIcon,
  QuizIcon,
  QuoraIcon,
  RECAPTCHA_CONTAINER_ID,
  RESERVED_GROUPS,
  RMobiledataIcon,
  RadarIcon,
  RadioButtonCheckedIcon,
  RadioButtonOffIcon,
  RadioButtonOnIcon,
  RadioButtonUncheckedIcon,
  RadioGroup,
  RadioGroupItem,
  RadioIcon,
  RailwayAlertIcon,
  RamenDiningIcon,
  RampLeftIcon,
  RampRightIcon,
  RateReviewIcon,
  RawOffIcon,
  RawOnIcon,
  ReadMoreIcon,
  ReadOnlyFieldBinding,
  RealEstateAgentIcon,
  ReceiptIcon,
  ReceiptLongIcon,
  RecentActorsIcon,
  RecommendIcon,
  RecordVoiceOverIcon,
  RectangleIcon,
  RecyclingIcon,
  RedditIcon,
  RedeemIcon,
  RedoIcon,
  ReduceCapacityIcon,
  ReferenceFieldBinding,
  ReferencePreview,
  ReferenceSelectionTable,
  ReferenceWidget,
  RefreshIcon,
  RememberMeIcon,
  RemoveCircleIcon,
  RemoveCircleOutlineIcon,
  RemoveDoneIcon,
  RemoveFromQueueIcon,
  RemoveIcon,
  RemoveModeratorIcon,
  RemoveRedEyeIcon,
  RemoveRoadIcon,
  RemoveShoppingCartIcon,
  ReorderIcon,
  RepartitionIcon,
  RepeatFieldBinding,
  RepeatIcon,
  RepeatOnIcon,
  RepeatOneIcon,
  RepeatOneOnIcon,
  Replay10Icon,
  Replay30Icon,
  Replay5Icon,
  ReplayCircleFilledIcon,
  ReplayIcon,
  ReplyAllIcon,
  ReplyIcon,
  ReportGmailerrorredIcon,
  ReportIcon,
  ReportOffIcon,
  ReportProblemIcon,
  RequestPageIcon,
  RequestQuoteIcon,
  ResetTvIcon,
  RestartAltIcon,
  RestaurantIcon,
  RestaurantMenuIcon,
  RestoreFromTrashIcon,
  RestoreIcon,
  RestorePageIcon,
  ReviewsIcon,
  RiceBowlIcon,
  RingVolumeIcon,
  RocketIcon,
  RocketLaunchIcon,
  RollerShadesClosedIcon,
  RollerShadesIcon,
  RollerSkatingIcon,
  RoofingIcon,
  RoomIcon,
  RoomPreferencesIcon,
  RoomServiceIcon,
  Rotate90DegreesCcwIcon,
  Rotate90DegreesCwIcon,
  RotateLeftIcon,
  RotateRightIcon,
  RoundaboutLeftIcon,
  RoundaboutRightIcon,
  RoundedCornerIcon,
  RouteIcon,
  RouterIcon,
  RowingIcon,
  RssFeedIcon,
  RsvpIcon,
  RttIcon,
  RuleFolderIcon,
  RuleIcon,
  RunCircleIcon,
  RunningWithErrorsIcon,
  RvHookupIcon,
  SafetyCheckIcon,
  SafetyDividerIcon,
  SailingIcon,
  SanitizerIcon,
  SatelliteAltIcon,
  SatelliteIcon,
  SaveAltIcon,
  SaveAsIcon,
  SaveIcon,
  SavedSearchIcon,
  SavingsIcon,
  Scaffold,
  ScaleIcon,
  ScannerIcon,
  ScatterPlotIcon,
  ScheduleIcon,
  ScheduleSendIcon,
  SchemaIcon,
  SchoolIcon,
  ScienceIcon,
  ScoreIcon,
  ScoreboardIcon,
  ScreenLockLandscapeIcon,
  ScreenLockPortraitIcon,
  ScreenLockRotationIcon,
  ScreenRotationAltIcon,
  ScreenRotationIcon,
  ScreenSearchDesktopIcon,
  ScreenShareIcon,
  ScreenshotIcon,
  ScreenshotMonitorIcon,
  ScubaDivingIcon,
  SdCardAlertIcon,
  SdCardIcon,
  SdIcon,
  SdStorageIcon,
  SearchBar,
  SearchIcon,
  SearchIconsView,
  SearchOffIcon,
  SecurityIcon,
  SecurityRulesInstructions,
  SecurityUpdateGoodIcon,
  SecurityUpdateIcon,
  SecurityUpdateWarningIcon,
  SegmentIcon,
  Select,
  SelectAllIcon,
  SelectFieldBinding,
  SelectGroup,
  SelectItem,
  SelectableTable,
  SelectableTableContext,
  SelfImprovementIcon,
  SellIcon,
  SendAndArchiveIcon,
  SendIcon,
  SendTimeExtensionIcon,
  SendToMobileIcon,
  SensorDoorIcon,
  SensorOccupiedIcon,
  SensorWindowIcon,
  SensorsIcon,
  SensorsOffIcon,
  SentimentDissatisfiedIcon,
  SentimentNeutralIcon,
  SentimentSatisfiedAltIcon,
  SentimentSatisfiedIcon,
  SentimentVeryDissatisfiedIcon,
  SentimentVerySatisfiedIcon,
  Separator,
  SetMealIcon,
  SettingsAccessibilityIcon,
  SettingsApplicationsIcon,
  SettingsBackupRestoreIcon,
  SettingsBluetoothIcon,
  SettingsBrightnessIcon,
  SettingsCellIcon,
  SettingsDisplayIcon,
  SettingsEthernetIcon,
  SettingsIcon,
  SettingsInputAntennaIcon,
  SettingsInputComponentIcon,
  SettingsInputCompositeIcon,
  SettingsInputHdmiIcon,
  SettingsInputSvideoIcon,
  SettingsOverscanIcon,
  SettingsPhoneIcon,
  SettingsPowerIcon,
  SettingsRemoteIcon,
  SettingsSuggestIcon,
  SettingsSystemDaydreamIcon,
  SettingsVoiceIcon,
  SevereColdIcon,
  ShapeLineIcon,
  ShareArrivalTimeIcon,
  ShareIcon,
  ShareLocationIcon,
  Sheet,
  ShieldIcon,
  ShieldMoonIcon,
  Shop2Icon,
  ShopIcon,
  ShopTwoIcon,
  ShopifyIcon,
  ShoppingBagIcon,
  ShoppingBasketIcon,
  ShoppingCartCheckoutIcon,
  ShoppingCartIcon,
  ShortTextIcon,
  ShortcutIcon,
  ShowChartIcon,
  ShowerIcon,
  ShuffleIcon,
  ShuffleOnIcon,
  ShutterSpeedIcon,
  SickIcon,
  SideDialogs,
  SignLanguageIcon,
  SignalCellular0BarIcon,
  SignalCellular4BarIcon,
  SignalCellularAlt1BarIcon,
  SignalCellularAlt2BarIcon,
  SignalCellularAltIcon,
  SignalCellularConnectedNoInternet0BarIcon,
  SignalCellularConnectedNoInternet4BarIcon,
  SignalCellularNoSimIcon,
  SignalCellularNodataIcon,
  SignalCellularNullIcon,
  SignalCellularOffIcon,
  SignalWifi0BarIcon,
  SignalWifi4BarIcon,
  SignalWifi4BarLockIcon,
  SignalWifiBadIcon,
  SignalWifiConnectedNoInternet4Icon,
  SignalWifiOffIcon,
  SignalWifiStatusbar4BarIcon,
  SignalWifiStatusbarConnectedNoInternet4Icon,
  SignalWifiStatusbarNullIcon,
  SignpostIcon,
  SimCardAlertIcon,
  SimCardDownloadIcon,
  SimCardIcon,
  SingleBedIcon,
  SipIcon,
  SkateboardingIcon,
  Skeleton,
  SkeletonPropertyComponent,
  SkipNextIcon,
  SkipPreviousIcon,
  SleddingIcon,
  Slider,
  SlideshowIcon,
  SlowMotionVideoIcon,
  SmallNavigationCard,
  SmartButtonIcon,
  SmartDisplayIcon,
  SmartScreenIcon,
  SmartToyIcon,
  SmartphoneIcon,
  SmokeFreeIcon,
  SmokingRoomsIcon,
  SmsFailedIcon,
  SmsIcon,
  SnackbarProvider,
  SnapchatIcon,
  SnippetFolderIcon,
  SnoozeIcon,
  SnowboardingIcon,
  SnowmobileIcon,
  SnowshoeingIcon,
  SoapIcon,
  SocialDistanceIcon,
  SolarPowerIcon,
  SortByAlphaIcon,
  SortIcon,
  SosIcon,
  SoupKitchenIcon,
  SourceIcon,
  SouthAmericaIcon,
  SouthEastIcon,
  SouthIcon,
  SouthWestIcon,
  SpaIcon,
  SpaceBarIcon,
  SpaceDashboardIcon,
  SpatialAudioIcon,
  SpatialAudioOffIcon,
  SpatialTrackingIcon,
  SpeakerGroupIcon,
  SpeakerIcon,
  SpeakerNotesIcon,
  SpeakerNotesOffIcon,
  SpeakerPhoneIcon,
  SpeedIcon,
  SpellcheckIcon,
  SplitscreenIcon,
  SpokeIcon,
  SportsBarIcon,
  SportsBaseballIcon,
  SportsBasketballIcon,
  SportsCricketIcon,
  SportsEsportsIcon,
  SportsFootballIcon,
  SportsGolfIcon,
  SportsGymnasticsIcon,
  SportsHandballIcon,
  SportsHockeyIcon,
  SportsIcon,
  SportsKabaddiIcon,
  SportsMartialArtsIcon,
  SportsMmaIcon,
  SportsMotorsportsIcon,
  SportsRugbyIcon,
  SportsScoreIcon,
  SportsSoccerIcon,
  SportsTennisIcon,
  SportsVolleyballIcon,
  SquareFootIcon,
  SquareIcon,
  SsidChartIcon,
  StackedBarChartIcon,
  StackedLineChartIcon,
  StadiumIcon,
  StairsIcon,
  StarBorderIcon,
  StarBorderPurple500Icon,
  StarHalfIcon,
  StarIcon,
  StarOutlineIcon,
  StarPurple500Icon,
  StarRateIcon,
  StarsIcon,
  StartIcon,
  StayCurrentLandscapeIcon,
  StayCurrentPortraitIcon,
  StayPrimaryLandscapeIcon,
  StayPrimaryPortraitIcon,
  StickyNote2Icon,
  StopCircleIcon,
  StopIcon,
  StopScreenShareIcon,
  StorageIcon,
  StorageThumbnail,
  StorageThumbnailInternal,
  StorageUploadFieldBinding,
  StoreIcon,
  StoreMallDirectoryIcon,
  StorefrontIcon,
  StormIcon,
  StraightIcon,
  StraightenIcon,
  StreamIcon,
  StreetviewIcon,
  StrikethroughSIcon,
  StringPropertyPreview,
  StripeDisclaimer,
  StrollerIcon,
  StyleIcon,
  SubdirectoryArrowLeftIcon,
  SubdirectoryArrowRightIcon,
  SubjectIcon,
  SubscriptIcon,
  SubscriptionPlanWidget,
  SubscriptionPriceSelect,
  SubscriptionsIcon,
  SubtitlesIcon,
  SubtitlesOffIcon,
  SubwayIcon,
  SummarizeIcon,
  SuperscriptIcon,
  SupervisedUserCircleIcon,
  SupervisorAccountIcon,
  SupportAgentIcon,
  SupportIcon,
  SurfingIcon,
  SurroundSoundIcon,
  SwapCallsIcon,
  SwapHorizIcon,
  SwapHorizontalCircleIcon,
  SwapVertCircleIcon,
  SwapVertIcon,
  SwapVerticalCircleIcon,
  SwipeDownAltIcon,
  SwipeDownIcon,
  SwipeIcon,
  SwipeLeftAltIcon,
  SwipeLeftIcon,
  SwipeRightAltIcon,
  SwipeRightIcon,
  SwipeUpAltIcon,
  SwipeUpIcon,
  SwipeVerticalIcon,
  SwitchAccessShortcutAddIcon,
  SwitchAccessShortcutIcon,
  SwitchAccountIcon,
  SwitchCameraIcon,
  SwitchFieldBinding,
  SwitchLeftIcon,
  SwitchRightIcon,
  SwitchVideoIcon,
  SynagogueIcon,
  SyncAltIcon,
  SyncDisabledIcon,
  SyncIcon,
  SyncLockIcon,
  SyncProblemIcon,
  SystemSecurityUpdateGoodIcon,
  SystemSecurityUpdateIcon,
  SystemSecurityUpdateWarningIcon,
  SystemUpdateAltIcon,
  SystemUpdateIcon,
  SystemUpdateTvIcon,
  Tab,
  TabIcon,
  TabUnselectedIcon,
  Table,
  TableBarIcon,
  TableBody,
  TableCell,
  TableChartIcon,
  TableHeader,
  TableRestaurantIcon,
  TableRow,
  TableRowsIcon,
  TableViewIcon,
  TabletAndroidIcon,
  TabletIcon,
  TabletMacIcon,
  Tabs,
  TagFacesIcon,
  TagIcon,
  TakeoutDiningIcon,
  TapAndPlayIcon,
  TapasIcon,
  TaskAltIcon,
  TaskIcon,
  TaxiAlertIcon,
  TelegramIcon,
  TempleBuddhistIcon,
  TempleHinduIcon,
  TerminalIcon,
  TerrainIcon,
  TextDecreaseIcon,
  TextField,
  TextFieldBinding,
  TextFieldsIcon,
  TextFormatIcon,
  TextIncreaseIcon,
  TextRotateUpIcon,
  TextRotateVerticalIcon,
  TextRotationAngledownIcon,
  TextRotationAngleupIcon,
  TextRotationDownIcon,
  TextRotationNoneIcon,
  TextSnippetIcon,
  TextareaAutosize,
  TextsmsIcon,
  TextureIcon,
  TheaterComedyIcon,
  TheatersIcon,
  ThermostatAutoIcon,
  ThermostatIcon,
  ThumbDownAltIcon,
  ThumbDownIcon,
  ThumbDownOffAltIcon,
  ThumbUpAltIcon,
  ThumbUpIcon,
  ThumbUpOffAltIcon,
  ThumbsUpDownIcon,
  ThunderstormIcon,
  TiktokIcon,
  TimeToLeaveIcon,
  TimelapseIcon,
  TimelineIcon,
  Timer10Icon,
  Timer10SelectIcon,
  Timer3Icon,
  Timer3SelectIcon,
  TimerIcon,
  TimerOffIcon,
  TipsAndUpdatesIcon,
  TireRepairIcon,
  TitleIcon,
  TocIcon,
  TodayIcon,
  ToggleOffIcon,
  ToggleOnIcon,
  TokenIcon,
  TollIcon,
  TonalityIcon,
  Tooltip,
  TopicIcon,
  TornadoIcon,
  TouchAppIcon,
  TourIcon,
  ToysIcon,
  TrackChangesIcon,
  TrafficIcon,
  TrainIcon,
  TramIcon,
  TranscribeIcon,
  TransferWithinAStationIcon,
  TransformIcon,
  TransgenderIcon,
  TransitEnterexitIcon,
  TranslateIcon,
  TravelExploreIcon,
  TrendingDownIcon,
  TrendingFlatIcon,
  TrendingNeutralIcon,
  TrendingUpIcon,
  TripOriginIcon,
  TroubleshootIcon,
  TryIcon,
  TsunamiIcon,
  TtyIcon,
  TuneIcon,
  TungstenIcon,
  TurnLeftIcon,
  TurnRightIcon,
  TurnSharpLeftIcon,
  TurnSharpRightIcon,
  TurnSlightLeftIcon,
  TurnSlightRightIcon,
  TurnedInIcon,
  TurnedInNotIcon,
  TvIcon,
  TvOffIcon,
  TwoWheelerIcon,
  TypeSpecimenIcon,
  Typography,
  UTurnLeftIcon,
  UTurnRightIcon,
  UmbrellaIcon,
  UnarchiveIcon,
  UndoIcon,
  UnfoldLessDoubleIcon,
  UnfoldLessIcon,
  UnfoldMoreDoubleIcon,
  UnfoldMoreIcon,
  UnpublishedIcon,
  UnsubscribeIcon,
  UpcomingIcon,
  UpdateDisabledIcon,
  UpdateIcon,
  UpgradeIcon,
  UploadFileIcon,
  UploadIcon,
  UrlComponentPreview,
  UsbIcon,
  UsbOffIcon,
  VaccinesIcon,
  VapeFreeIcon,
  VapingRoomsIcon,
  Vector,
  VerifiedIcon,
  VerifiedUserIcon,
  VerticalAlignBottomIcon,
  VerticalAlignCenterIcon,
  VerticalAlignTopIcon,
  VerticalDistributeIcon,
  VerticalShadesClosedIcon,
  VerticalShadesIcon,
  VerticalSplitIcon,
  VibrationIcon,
  VideoCallIcon,
  VideoCameraBackIcon,
  VideoCameraFrontIcon,
  VideoChatIcon,
  VideoCollectionIcon,
  VideoFileIcon,
  VideoLabelIcon,
  VideoLibraryIcon,
  VideoSettingsIcon,
  VideoStableIcon,
  VideocamIcon,
  VideocamOffIcon,
  VideogameAssetIcon,
  VideogameAssetOffIcon,
  ViewAgendaIcon,
  ViewArrayIcon,
  ViewCarouselIcon,
  ViewColumnIcon,
  ViewComfortableIcon,
  ViewComfyAltIcon,
  ViewComfyIcon,
  ViewCompactAltIcon,
  ViewCompactIcon,
  ViewCozyIcon,
  ViewDayIcon,
  ViewHeadlineIcon,
  ViewInArIcon,
  ViewKanbanIcon,
  ViewListIcon,
  ViewModuleIcon,
  ViewQuiltIcon,
  ViewSidebarIcon,
  ViewStreamIcon,
  ViewTimelineIcon,
  ViewWeekIcon,
  VignetteIcon,
  VillaIcon,
  VirtualTable,
  VisibilityIcon,
  VisibilityOffIcon,
  VoiceChatIcon,
  VoiceOverOffIcon,
  VoicemailIcon,
  VolcanoIcon,
  VolumeDownIcon,
  VolumeMuteIcon,
  VolumeOffIcon,
  VolumeUpIcon,
  VolunteerActivismIcon,
  VpnKeyIcon,
  VpnKeyOffIcon,
  VpnLockIcon,
  VrpanoIcon,
  WalletGiftcardIcon,
  WalletIcon,
  WalletMembershipIcon,
  WalletTravelIcon,
  WallpaperIcon,
  WarehouseIcon,
  WarningAmberIcon,
  WarningIcon,
  WashIcon,
  WatchIcon,
  WatchLaterIcon,
  WatchOffIcon,
  WaterDamageIcon,
  WaterDropIcon,
  WaterIcon,
  WaterfallChartIcon,
  WavesIcon,
  WavingHandIcon,
  WbAutoIcon,
  WbCloudyIcon,
  WbIncandescentIcon,
  WbIridescentIcon,
  WbShadeIcon,
  WbSunnyIcon,
  WbTwilightIcon,
  WcIcon,
  WebAssetIcon,
  WebAssetOffIcon,
  WebIcon,
  WebStoriesIcon,
  WebhookIcon,
  WechatIcon,
  WeekendIcon,
  WestIcon,
  WhatshotIcon,
  WheelchairPickupIcon,
  WhereToVoteIcon,
  WidgetsIcon,
  WidthFullIcon,
  WidthNormalIcon,
  WidthWideIcon,
  Wifi1BarIcon,
  Wifi2BarIcon,
  WifiCalling3Icon,
  WifiCallingIcon,
  WifiChannelIcon,
  WifiFindIcon,
  WifiIcon,
  WifiLockIcon,
  WifiOffIcon,
  WifiPasswordIcon,
  WifiProtectedSetupIcon,
  WifiTetheringErrorIcon,
  WifiTetheringErrorRoundedIcon,
  WifiTetheringIcon,
  WifiTetheringOffIcon,
  WindPowerIcon,
  WindowIcon,
  WineBarIcon,
  Woman2Icon,
  WomanIcon,
  WooCommerceIcon,
  WordpressIcon,
  WorkHistoryIcon,
  WorkIcon,
  WorkOffIcon,
  WorkOutlineIcon,
  WorkspacePremiumIcon,
  WorkspacesIcon,
  WrapTextIcon,
  WrongLocationIcon,
  WysiwygIcon,
  YardIcon,
  YoutubeSearchedForIcon,
  ZoomInIcon,
  ZoomInMapIcon,
  ZoomOutIcon,
  ZoomOutMapIcon,
  _10kIcon,
  _10mpIcon,
  _11mpIcon,
  _123Icon,
  _12mpIcon,
  _13mpIcon,
  _14mpIcon,
  _15mpIcon,
  _16mpIcon,
  _17mpIcon,
  _18UpRatingIcon,
  _18mpIcon,
  _19mpIcon,
  _1kIcon,
  _1kPlusIcon,
  _1xMobiledataIcon,
  _20mpIcon,
  _21mpIcon,
  _22mpIcon,
  _23mpIcon,
  _24mpIcon,
  _2kIcon,
  _2kPlusIcon,
  _2mpIcon,
  _30fpsIcon,
  _30fpsSelectIcon,
  _360Icon,
  _3dRotationIcon,
  _3gMobiledataIcon,
  _3kIcon,
  _3kPlusIcon,
  _3mpIcon,
  _3pIcon,
  _4gMobiledataIcon,
  _4gPlusMobiledataIcon,
  _4kIcon,
  _4kPlusIcon,
  _4mpIcon,
  _5gIcon,
  _5kIcon,
  _5kPlusIcon,
  _5mpIcon,
  _60fpsIcon,
  _60fpsSelectIcon,
  _6FtApartIcon,
  _6kIcon,
  _6kPlusIcon,
  _6mpIcon,
  _7kIcon,
  _7kPlusIcon,
  _7mpIcon,
  _8kIcon,
  _8kPlusIcon,
  _8mpIcon,
  _9kIcon,
  _9kPlusIcon,
  _9mpIcon,
  addInitialSlash,
  applyPermissionsFunctionIfEmpty,
  archiveEntityAction,
  areRolesEqual,
  buildAdditionalFieldDelegate,
  buildAlgoliaSearchController,
  buildCollection,
  buildCollectionId,
  buildEntityCallbacks,
  buildEnumLabel,
  buildEnumValueConfig,
  buildEnumValues,
  buildExternalSearchController,
  buildFieldConfig,
  buildIdColumn,
  buildPineconeSearchController,
  buildProjectsApi,
  buildProperties,
  buildPropertiesOrBuilder,
  buildProperty,
  cacheDelegatedLoginToken,
  canCreateEntity,
  canDeleteEntity,
  canEditEntity,
  cardClickableMixin,
  cardMixin,
  cardSelectedMixin,
  clearDelegatedLoginTokensCache,
  cls,
  cmsToFirestoreModel,
  cmsToRTDBModel,
  cn,
  coolIconKeys,
  copyEntityAction,
  darkenColor,
  debounce,
  defaultBorderMixin,
  defaultDateFormat,
  deleteEntityAction,
  deleteEntityWithCallbacks,
  docToCollection,
  docsToCollectionTree,
  editEntityAction,
  enumToObjectEntries,
  fieldBackgroundDisabledMixin,
  fieldBackgroundHoverMixin,
  fieldBackgroundInvisibleMixin,
  fieldBackgroundMixin,
  firestoreToCMSModel,
  flattenObject,
  focusedClasses,
  focusedDisabled,
  focusedInvisibleMixin,
  formatPrice,
  fullPathToCollectionSegments,
  getArrayResolvedProperties,
  getArrayValuesCount,
  getBracketNotation,
  getCollectionByPathOrId,
  getCollectionPathsCombinations,
  getColorForProperty,
  getColorScheme,
  getColorSchemeForKey,
  getColorSchemeForSeed,
  getColumnKeysForProperty,
  getDefaultFieldConfig,
  getDefaultFieldId,
  getDefaultPropertiesOrder,
  getDefaultValueFor,
  getDefaultValueForDataType,
  getDefaultValuesFor,
  getDelegatedLoginTokenFromCache,
  getEntityImagePreviewPropertyKey,
  getEntityPreviewKeys,
  getEntityTitlePropertyKey,
  getFieldConfig,
  getFieldId,
  getFirebaseApp,
  getFirebaseApps,
  getFirestoreDataInPath,
  getFormFieldKeys,
  getHashValue,
  getIcon,
  getIconForProperty,
  getIconForWidget,
  getIdIcon,
  getLabelOrConfigFrom,
  getLastSegment,
  getPriceString,
  getPropertiesWithPropertiesOrder,
  getPropertyInPath,
  getRandomId,
  getReferenceFrom,
  getResolvedPropertyInPath,
  getSidePanelKey,
  getSubscriptionPlanName,
  getSubscriptionStatusText,
  getValueInPath,
  hexToRgbaWithOpacity,
  hydrateRegExp,
  iconKeys,
  iconSynonyms,
  iconsSearch,
  isDefaultFieldConfigId,
  isEmptyObject,
  isEnumValueDisabled,
  isHidden,
  isObject,
  isPropertyBuilder,
  isReadOnly,
  isReferenceProperty,
  isValidRegExp,
  joinCollectionLists,
  keyToIconComponent,
  localSearchControllerBuilder,
  makePropertiesEditable,
  makePropertiesNonEditable,
  mergeCollection,
  mergeDeep,
  openWebsiteAction,
  paperMixin,
  performAlgoliaTextSearch,
  performPineconeTextSearch,
  pick,
  plural,
  prepareCollectionForPersistence,
  printChanged,
  propertiesToColumns,
  randomColor,
  randomString,
  removeFunctions,
  removeInPath,
  removeInitialAndTrailingSlashes,
  removeInitialSlash,
  removeNulls,
  removePropsIfExisting,
  removeTrailingSlash,
  removeUndefined,
  renderSkeletonCaptionText,
  renderSkeletonIcon,
  renderSkeletonImageThumbnail,
  renderSkeletonText,
  resolveArrayProperty,
  resolveCollection,
  resolveCollectionConfigPermissions,
  resolveCollectionPathIds,
  resolveDefaultSelectedView,
  resolveEntityView,
  resolveEnumValues,
  resolveNavigationFrom,
  resolvePermissions,
  resolveProperties,
  resolveProperty,
  resolvePropertyEnum,
  resolveStorageFilenameString,
  resolveStoragePathString,
  sanitizeData,
  saveEntityWithCallbacks,
  segmentsToStrippedPath,
  serializeRegExp,
  setUndefinedToDelete,
  singular,
  slugify,
  sortProperties,
  stripCollectionPath,
  toKebabCase,
  toSnakeCase,
  traverseValueProperty,
  traverseValuesProperties,
  unslugify,
  updateDateAutoValues,
  useApp,
  useAppCheck,
  useAuthController,
  useAutoComplete,
  useBrowserTitleAndIcon,
  useBuildCloudUserManagement,
  useBuildFireCMSBackend,
  useBuildLocalConfigurationPersistence,
  useBuildModeController,
  useBuildNavigationController,
  useBuildProjectConfig,
  useClearRestoreValue,
  useClipboard,
  useCollectionFetch,
  useColumnIds,
  useCustomizationController,
  useDataSource,
  useDataSourceEntityCollectionTableController,
  useDataTalkMode,
  useDebounceValue,
  useDebouncedCallback,
  useDebouncedData,
  useDelegatedLogin,
  useDialogsController,
  useEntityFetch,
  useFireCMSBackend,
  useFireCMSContext,
  useFirebaseAuthController,
  useFirebaseRTDBDelegate,
  useFirebaseStorageSource,
  useFirestoreDelegate,
  useIconStyles,
  useInitialiseFirebase,
  useInjectStyles,
  useLargeLayout,
  useLicensesForUserController,
  useModeController,
  useNavigationController,
  useOutsideAlerter,
  useProjectConfig,
  useRecaptcha,
  useReferenceDialog,
  useResolvedNavigationFrom,
  useSelectableTableController,
  useSelectionController,
  useSideDialogContext,
  useSideDialogsController,
  useSideEntityController,
  useSnackbarController,
  useStorageSource,
  useSubscriptionsForUserController,
  useTableSearchHelper,
  useTraceUpdate,
  useValidateAuthenticator
};
