import { importShared } from "../__federation_fn_import-Ca_-J8Zi.js";
import { j as jsxRuntimeExports } from "../jsx-runtime-BcIfvQoK.js";
import { c as c_1, e as equal } from "../index-zKQ-pyZr.js";
import { u as useComposedRefs, a as useLayoutEffect2, P as Primitive, d as dispatchDiscreteCustomEvent, S as Slot, b as Portal$5, c as composeRefs, _ as _extends, e as Slottable, M as MarkdownIt, f as useDropzone } from "../index-CY1eqRJM.js";
import { b as __assign, _ as __rest, c as __spreadArray } from "../tslib.es6-FslYWQzr.js";
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler?.(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler?.(event);
    }
  };
}
const React$G = await importShared("react");
function createContext2(rootComponentName, defaultContext) {
  const Context = React$G.createContext(defaultContext);
  const Provider2 = (props) => {
    const { children, ...context } = props;
    const value = React$G.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
  };
  Provider2.displayName = rootComponentName + "Provider";
  function useContext2(consumerName) {
    const context = React$G.useContext(Context);
    if (context) return context;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider2, useContext2];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = React$G.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider2 = (props) => {
      const { scope, children, ...context } = props;
      const Context = scope?.[scopeName]?.[index2] || BaseContext;
      const value = React$G.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext2(consumerName, scope) {
      const Context = scope?.[scopeName]?.[index2] || BaseContext;
      const context = React$G.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider2, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React$G.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = scope?.[scopeName] || scopeContexts;
      return React$G.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React$G.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
const React$F = await importShared("react");
function useCallbackRef$1(callback) {
  const callbackRef = React$F.useRef(callback);
  React$F.useEffect(() => {
    callbackRef.current = callback;
  });
  return React$F.useMemo(() => (...args) => callbackRef.current?.(...args), []);
}
const React$E = await importShared("react");
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  }
}) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef$1(onChange);
  const setValue = React$E.useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value2 !== prop) handleChange(value2);
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, handleChange]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const uncontrolledState = React$E.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = React$E.useRef(value);
  const handleChange = useCallbackRef$1(onChange);
  React$E.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef, handleChange]);
  return uncontrolledState;
}
const React2$1 = await importShared("react");
const React$D = await importShared("react");
function useStateMachine(initialState, machine) {
  return React$D.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React2$1.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React2$1.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = React2$1.useState();
  const stylesRef = React2$1.useRef({});
  const prevPresentRef = React2$1.useRef(present);
  const prevAnimationNameRef = React2$1.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React2$1.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles2 = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles2);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || styles2?.display === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React2$1.useCallback((node2) => {
      if (node2) stylesRef.current = getComputedStyle(node2);
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles2) {
  return styles2?.animationName || "none";
}
function getElementRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
const React$C = await importShared("react");
var useReactId = React$C["useId".toString()] || (() => void 0);
var count$1 = 0;
function useId(deterministicId) {
  const [id, setId] = React$C.useState(useReactId());
  useLayoutEffect2(() => {
    setId((reactId) => reactId ?? String(count$1++));
  }, [deterministicId]);
  return id ? `radix-${id}` : "";
}
const React$B = await importShared("react");
var COLLAPSIBLE_NAME = "Collapsible";
var [createCollapsibleContext, createCollapsibleScope] = createContextScope(COLLAPSIBLE_NAME);
var [CollapsibleProvider, useCollapsibleContext] = createCollapsibleContext(COLLAPSIBLE_NAME);
var Collapsible = React$B.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeCollapsible,
      open: openProp,
      defaultOpen,
      disabled,
      onOpenChange,
      ...collapsibleProps
    } = props;
    const [open = false, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      CollapsibleProvider,
      {
        scope: __scopeCollapsible,
        disabled,
        contentId: useId(),
        open,
        onOpenToggle: React$B.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            "data-state": getState$4(open),
            "data-disabled": disabled ? "" : void 0,
            ...collapsibleProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Collapsible.displayName = COLLAPSIBLE_NAME;
var TRIGGER_NAME$7 = "CollapsibleTrigger";
var CollapsibleTrigger = React$B.forwardRef(
  (props, forwardedRef) => {
    const { __scopeCollapsible, ...triggerProps } = props;
    const context = useCollapsibleContext(TRIGGER_NAME$7, __scopeCollapsible);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-controls": context.contentId,
        "aria-expanded": context.open || false,
        "data-state": getState$4(context.open),
        "data-disabled": context.disabled ? "" : void 0,
        disabled: context.disabled,
        ...triggerProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
CollapsibleTrigger.displayName = TRIGGER_NAME$7;
var CONTENT_NAME$9 = "CollapsibleContent";
var CollapsibleContent = React$B.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...contentProps } = props;
    const context = useCollapsibleContext(CONTENT_NAME$9, props.__scopeCollapsible);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: ({ present }) => /* @__PURE__ */ jsxRuntimeExports.jsx(CollapsibleContentImpl, { ...contentProps, ref: forwardedRef, present }) });
  }
);
CollapsibleContent.displayName = CONTENT_NAME$9;
var CollapsibleContentImpl = React$B.forwardRef((props, forwardedRef) => {
  const { __scopeCollapsible, present, children, ...contentProps } = props;
  const context = useCollapsibleContext(CONTENT_NAME$9, __scopeCollapsible);
  const [isPresent, setIsPresent] = React$B.useState(present);
  const ref = React$B.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const heightRef = React$B.useRef(0);
  const height = heightRef.current;
  const widthRef = React$B.useRef(0);
  const width = widthRef.current;
  const isOpen = context.open || isPresent;
  const isMountAnimationPreventedRef = React$B.useRef(isOpen);
  const originalStylesRef = React$B.useRef(void 0);
  React$B.useEffect(() => {
    const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
    return () => cancelAnimationFrame(rAF);
  }, []);
  useLayoutEffect2(() => {
    const node = ref.current;
    if (node) {
      originalStylesRef.current = originalStylesRef.current || {
        transitionDuration: node.style.transitionDuration,
        animationName: node.style.animationName
      };
      node.style.transitionDuration = "0s";
      node.style.animationName = "none";
      const rect = node.getBoundingClientRect();
      heightRef.current = rect.height;
      widthRef.current = rect.width;
      if (!isMountAnimationPreventedRef.current) {
        node.style.transitionDuration = originalStylesRef.current.transitionDuration;
        node.style.animationName = originalStylesRef.current.animationName;
      }
      setIsPresent(present);
    }
  }, [context.open, present]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "data-state": getState$4(context.open),
      "data-disabled": context.disabled ? "" : void 0,
      id: context.contentId,
      hidden: !isOpen,
      ...contentProps,
      ref: composedRefs,
      style: {
        [`--radix-collapsible-content-height`]: height ? `${height}px` : void 0,
        [`--radix-collapsible-content-width`]: width ? `${width}px` : void 0,
        ...props.style
      },
      children: isOpen && children
    }
  );
});
function getState$4(open) {
  return open ? "open" : "closed";
}
var Root$8 = Collapsible;
var Trigger$6 = CollapsibleTrigger;
var Content$2 = CollapsibleContent;
function r(e) {
  var t2, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t2 = 0; t2 < o; t2++) e[t2] && (f = r(e[t2])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t2, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t2 = r(e)) && (n && (n += " "), n += t2);
  return n;
}
const CLASS_PART_SEPARATOR = "-";
const createClassGroupUtils = (config) => {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  const getClassGroupId = (className) => {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
};
const getGroupRecursive = (classParts, classPartObject) => {
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return classPartObject.validators.find(({
    validator
  }) => validator(classRest))?.classGroupId;
};
const arbitraryPropertyRegex = /^\[(.+)\]$/;
const getGroupIdForArbitraryProperty = (className) => {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
};
const createClassMap = (config) => {
  const {
    theme,
    prefix
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
};
const processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
};
const getPart = (classPartObject, path) => {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
};
const isThemeGetter = (func) => func.isThemeGetter;
const getPrefixedClassGroupEntries = (classGroupEntries, prefix) => {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(([classGroupId, classGroup]) => {
    const prefixedClassGroup = classGroup.map((classDefinition) => {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
};
const createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  const update = (key, value) => {
    cache.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  };
  return {
    get(key) {
      let value = cache.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (cache.has(key)) {
        cache.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
};
const IMPORTANT_MODIFIER = "!";
const createParseClassName = (config) => {
  const {
    separator,
    experimentalParseClassName
  } = config;
  const isSeparatorSingleCharacter = separator.length === 1;
  const firstSeparatorCharacter = separator[0];
  const separatorLength = separator.length;
  const parseClassName = (className) => {
    const modifiers = [];
    let bracketDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index2 = 0; index2 < className.length; index2++) {
      let currentCharacter = className[index2];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index2, index2 + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index2));
          modifierStart = index2 + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index2;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
  if (experimentalParseClassName) {
    return (className) => experimentalParseClassName({
      className,
      parseClassName
    });
  }
  return parseClassName;
};
const sortModifiers = (modifiers) => {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  const sortedModifiers = [];
  let unsortedModifiers = [];
  modifiers.forEach((modifier) => {
    const isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push(...unsortedModifiers.sort());
  return sortedModifiers;
};
const createConfigUtils = (config) => ({
  cache: createLruCache(config.cacheSize),
  parseClassName: createParseClassName(config),
  ...createClassGroupUtils(config)
});
const SPLIT_CLASSES_REGEX = /\s+/;
const mergeClassList = (classList, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index2 = classNames.length - 1; index2 >= 0; index2 -= 1) {
    const originalClassName = classNames[index2];
    const {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.includes(classId)) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i = 0; i < conflictGroups.length; ++i) {
      const group = conflictGroups[i];
      classGroupsInConflict.push(modifierId + group);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
function twJoin() {
  let index2 = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index2 < arguments.length) {
    if (argument = arguments[index2++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
const toValue = (mix) => {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k2 = 0; k2 < mix.length; k2++) {
    if (mix[k2]) {
      if (resolvedValue = toValue(mix[k2])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
const fromTheme = (key) => {
  const themeGetter = (theme) => theme[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
const arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
const fractionRegex = /^\d+\/\d+$/;
const stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
const shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
const isLength = (value) => isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
const isArbitraryLength = (value) => getIsArbitraryValue(value, "length", isLengthOnly);
const isNumber = (value) => Boolean(value) && !Number.isNaN(Number(value));
const isArbitraryNumber = (value) => getIsArbitraryValue(value, "number", isNumber);
const isInteger = (value) => Boolean(value) && Number.isInteger(Number(value));
const isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
const isArbitraryValue = (value) => arbitraryValueRegex.test(value);
const isTshirtSize = (value) => tshirtUnitRegex.test(value);
const sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
const isArbitrarySize = (value) => getIsArbitraryValue(value, sizeLabels, isNever);
const isArbitraryPosition = (value) => getIsArbitraryValue(value, "position", isNever);
const imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
const isArbitraryImage = (value) => getIsArbitraryValue(value, imageLabels, isImage);
const isArbitraryShadow = (value) => getIsArbitraryValue(value, "", isShadow);
const isAny = () => true;
const getIsArbitraryValue = (value, label, testValue) => {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return typeof label === "string" ? result[1] === label : label.has(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
const isLengthOnly = (value) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
);
const isNever = () => false;
const isShadow = (value) => shadowRegex.test(value);
const isImage = (value) => imageRegex.test(value);
const getDefaultConfig = () => {
  const colors = fromTheme("colors");
  const spacing = fromTheme("spacing");
  const blur = fromTheme("blur");
  const brightness = fromTheme("brightness");
  const borderColor = fromTheme("borderColor");
  const borderRadius = fromTheme("borderRadius");
  const borderSpacing = fromTheme("borderSpacing");
  const borderWidth = fromTheme("borderWidth");
  const contrast = fromTheme("contrast");
  const grayscale = fromTheme("grayscale");
  const hueRotate = fromTheme("hueRotate");
  const invert = fromTheme("invert");
  const gap = fromTheme("gap");
  const gradientColorStops = fromTheme("gradientColorStops");
  const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  const inset = fromTheme("inset");
  const margin = fromTheme("margin");
  const opacity = fromTheme("opacity");
  const padding = fromTheme("padding");
  const saturate = fromTheme("saturate");
  const scale = fromTheme("scale");
  const sepia = fromTheme("sepia");
  const skew = fromTheme("skew");
  const space = fromTheme("space");
  const translate = fromTheme("translate");
  const getOverscroll = () => ["auto", "contain", "none"];
  const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
  const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
  const getNumberWithAutoAndArbitrary = () => ["auto", isNumber, isArbitraryValue];
  const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
  const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
  const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
  const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [isAny],
      spacing: [isLength, isArbitraryLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumberAndArbitrary(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmptyAndArbitrary(),
      contrast: getNumberAndArbitrary(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumberAndArbitrary(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumberAndArbitrary(),
      scale: getNumberAndArbitrary(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...getPositions(), isArbitraryValue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger, isArbitraryValue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...getAlign()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...getAlign(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...getAlign(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...getLineStyles(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength, isArbitraryLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isLength, isArbitraryValue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...getPositions(), isArbitraryPosition]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...getLineStyles(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [borderColor]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...getLineStyles()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isLength, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmptyAndArbitrary()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...getBlendModes(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
};
const twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
const React$A = await importShared("react");
function usePrevious(value) {
  const ref = React$A.useRef({ value, previous: value });
  return React$A.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}
const React$z = await importShared("react");
function useSize(element) {
  const [size2, setSize] = React$z.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size2;
}
const React$y = await importShared("react");
var CHECKBOX_NAME = "Checkbox";
var [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);
var [CheckboxProvider, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME);
var Checkbox$1 = React$y.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeCheckbox,
      name,
      checked: checkedProp,
      defaultChecked,
      required,
      disabled,
      value = "on",
      onCheckedChange,
      form,
      ...checkboxProps
    } = props;
    const [button, setButton] = React$y.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = React$y.useRef(false);
    const isFormControl = button ? form || !!button.closest("form") : true;
    const [checked = false, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked,
      onChange: onCheckedChange
    });
    const initialCheckedStateRef = React$y.useRef(checked);
    React$y.useEffect(() => {
      const form2 = button?.form;
      if (form2) {
        const reset = () => setChecked(initialCheckedStateRef.current);
        form2.addEventListener("reset", reset);
        return () => form2.removeEventListener("reset", reset);
      }
    }, [button, setChecked]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(CheckboxProvider, { scope: __scopeCheckbox, state: checked, disabled, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          role: "checkbox",
          "aria-checked": isIndeterminate$1(checked) ? "mixed" : checked,
          "aria-required": required,
          "data-state": getState$3(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...checkboxProps,
          ref: composedRefs,
          onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
            if (event.key === "Enter") event.preventDefault();
          }),
          onClick: composeEventHandlers(props.onClick, (event) => {
            setChecked((prevChecked) => isIndeterminate$1(prevChecked) ? true : !prevChecked);
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        BubbleInput$2,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name,
          value,
          checked,
          required,
          disabled,
          form,
          style: { transform: "translateX(-100%)" },
          defaultChecked: isIndeterminate$1(defaultChecked) ? false : defaultChecked
        }
      )
    ] });
  }
);
Checkbox$1.displayName = CHECKBOX_NAME;
var INDICATOR_NAME$3 = "CheckboxIndicator";
var CheckboxIndicator = React$y.forwardRef(
  (props, forwardedRef) => {
    const { __scopeCheckbox, forceMount, ...indicatorProps } = props;
    const context = useCheckboxContext(INDICATOR_NAME$3, __scopeCheckbox);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || isIndeterminate$1(context.state) || context.state === true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-state": getState$3(context.state),
        "data-disabled": context.disabled ? "" : void 0,
        ...indicatorProps,
        ref: forwardedRef,
        style: { pointerEvents: "none", ...props.style }
      }
    ) });
  }
);
CheckboxIndicator.displayName = INDICATOR_NAME$3;
var BubbleInput$2 = (props) => {
  const { control, checked, bubbles = true, defaultChecked, ...inputProps } = props;
  const ref = React$y.useRef(null);
  const prevChecked = usePrevious(checked);
  const controlSize = useSize(control);
  React$y.useEffect(() => {
    const input = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      input.indeterminate = isIndeterminate$1(checked);
      setChecked.call(input, isIndeterminate$1(checked) ? false : checked);
      input.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  const defaultCheckedRef = React$y.useRef(isIndeterminate$1(checked) ? false : checked);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "checkbox",
      "aria-hidden": true,
      defaultChecked: defaultChecked ?? defaultCheckedRef.current,
      ...inputProps,
      tabIndex: -1,
      ref,
      style: {
        ...props.style,
        ...controlSize,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }
  );
};
function isIndeterminate$1(checked) {
  return checked === "indeterminate";
}
function getState$3(checked) {
  return isIndeterminate$1(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
var Root$7 = Checkbox$1;
var Indicator$1 = CheckboxIndicator;
const React$x = await importShared("react");
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
  const onEscapeKeyDown = useCallbackRef$1(onEscapeKeyDownProp);
  React$x.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
const React$w = await importShared("react");
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React$w.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React$w.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = React$w.useContext(DismissableLayerContext);
    const [node, setNode] = React$w.useState(null);
    const ownerDocument = node?.ownerDocument ?? globalThis?.document;
    const [, force] = React$w.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown?.(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React$w.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React$w.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    React$w.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React$w.forwardRef((props, forwardedRef) => {
  const context = React$w.useContext(DismissableLayerContext);
  const ref = React$w.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React$w.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis?.document) {
  const handlePointerDownOutside = useCallbackRef$1(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React$w.useRef(false);
  const handleClickRef = React$w.useRef(() => {
  });
  React$w.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis?.document) {
  const handleFocusOutside = useCallbackRef$1(onFocusOutside);
  const isFocusInsideReactTreeRef = React$w.useRef(false);
  React$w.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
const React$v = await importShared("react");
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS$1 = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React$v.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React$v.useState(null);
  const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React$v.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React$v.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React$v.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React$v.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS$1);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst$2(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS$1);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React$v.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst$2(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope?.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      stack = arrayRemove(stack, focusScope);
      stack[0]?.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}
const React$u = await importShared("react");
var count = 0;
function useFocusGuards() {
  React$u.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count++;
    return () => {
      if (count === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
const { useState: useState$1 } = await importShared("react");
function useCallbackRef(initialValue, callback) {
  var ref = useState$1(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
const React$t = await importShared("react");
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React$t.useLayoutEffect : React$t.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a2) {
  return a2;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
const React$s = await importShared("react");
var SideCar$2 = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React$s.createElement(Target, __assign({}, rest));
};
SideCar$2.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$2;
}
var effectCar$1 = createSidecarMedium();
const React$r = await importShared("react");
var nothing$1 = function() {
  return;
};
var RemoveScroll$1 = React$r.forwardRef(function(props, parentRef) {
  var ref = React$r.useRef(null);
  var _a = React$r.useState({
    onScrollCapture: nothing$1,
    onWheelCapture: nothing$1,
    onTouchMoveCapture: nothing$1
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container2 = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React$r.createElement(
    React$r.Fragment,
    null,
    enabled && React$r.createElement(SideCar2, { sideCar: effectCar$1, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React$r.cloneElement(React$r.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React$r.createElement(Container2, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll$1.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll$1.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
const React$q = await importShared("react");
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles2, isDynamic) {
    React$q.useEffect(function() {
      sheet.add(styles2);
      return function() {
        sheet.remove();
      };
    }, [styles2 && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet2 = function(_a) {
    var styles2 = _a.styles, dynamic = _a.dynamic;
    useStyle(styles2, dynamic);
    return null;
  };
  return Sheet2;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
const React$p = await importShared("react");
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React$p.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React$p.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React$p.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported$1 = false;
if (typeof window !== "undefined") {
  try {
    var options$1 = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported$1 = true;
        return true;
      }
    });
    window.addEventListener("test", options$1, options$1);
    window.removeEventListener("test", options$1, options$1);
  } catch (err) {
    passiveSupported$1 = false;
  }
}
var nonPassive$1 = passiveSupported$1 ? { passive: false } : false;
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles2 = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles2[overflow] !== "hidden" && // contains scroll inside self
    !(styles2.overflowY === styles2.overflowX && !alwaysContainsScroll(node) && styles2[overflow] === "visible")
  );
};
var elementCouldBeVScrolled$1 = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled$1 = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled$1 = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled$1(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables$1(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables$1 = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables$1 = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled$1 = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled$1(node) : elementCouldBeHScrolled$1(node);
};
var getScrollVariables$1 = function(axis, node) {
  return axis === "v" ? getVScrollVariables$1(node) : getHScrollVariables$1(node);
};
var getDirectionFactor$1 = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll$1 = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor$1(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables$1(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled$1(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || !noOverscroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || !noOverscroll)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
const React$o = await importShared("react");
var getTouchXY$1 = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY$1 = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef$1 = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare$1 = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle$1 = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter$1 = 0;
var lockStack$1 = [];
function RemoveScrollSideCar$1(props) {
  var shouldPreventQueue = React$o.useRef([]);
  var touchStartRef = React$o.useRef([0, 0]);
  var activeAxis = React$o.useRef();
  var id = React$o.useState(idCounter$1++)[0];
  var Style2 = React$o.useState(styleSingleton)[0];
  var lastProps = React$o.useRef(props);
  React$o.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React$o.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef$1), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React$o.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY$1(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled$1(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled$1(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll$1(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React$o.useCallback(function(_event) {
    var event = _event;
    if (!lockStack$1.length || lockStack$1[lockStack$1.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY$1(event) : getTouchXY$1(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare$1(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef$1).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React$o.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React$o.useCallback(function(event) {
    touchStartRef.current = getTouchXY$1(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React$o.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY$1(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React$o.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY$1(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React$o.useEffect(function() {
    lockStack$1.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive$1);
    document.addEventListener("touchmove", shouldPrevent, nonPassive$1);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive$1);
    return function() {
      lockStack$1 = lockStack$1.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive$1);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive$1);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive$1);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React$o.createElement(
    React$o.Fragment,
    null,
    inert ? React$o.createElement(Style2, { styles: generateStyle$1(id) }) : null,
    removeScrollBar ? React$o.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
const SideCar$1 = exportSidecar(effectCar$1, RemoveScrollSideCar$1);
const React$n = await importShared("react");
var ReactRemoveScroll$1 = React$n.forwardRef(function(props, ref) {
  return React$n.createElement(RemoveScroll$1, __assign({}, props, { ref, sideCar: SideCar$1 }));
});
ReactRemoveScroll$1.classNames = RemoveScroll$1.classNames;
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
const React$m = await importShared("react");
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog$1 = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = React$m.useRef(null);
  const contentRef = React$m.useRef(null);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId(),
      titleId: useId(),
      descriptionId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React$m.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog$1.displayName = DIALOG_NAME;
var TRIGGER_NAME$6 = "DialogTrigger";
var DialogTrigger = React$m.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME$6, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState$2(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME$6;
var PORTAL_NAME$6 = "DialogPortal";
var [PortalProvider$3, usePortalContext$3] = createDialogContext(PORTAL_NAME$6, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME$6, __scopeDialog);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$3, { scope: __scopeDialog, forceMount, children: React$m.Children.map(children, (child) => /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$5, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME$6;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = React$m.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$3(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var DialogOverlayImpl = React$m.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll$1, { as: Slot, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-state": getState$2(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME$8 = "DialogContent";
var DialogContent$1 = React$m.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$3(CONTENT_NAME$8, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME$8, props.__scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent$1.displayName = CONTENT_NAME$8;
var DialogContentModal = React$m.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME$8, props.__scopeDialog);
    const contentRef = React$m.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    React$m.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          event.preventDefault();
          context.triggerRef.current?.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = React$m.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME$8, props.__scopeDialog);
    const hasInteractedOutsideRef = React$m.useRef(false);
    const hasPointerDownOutsideRef = React$m.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          props.onCloseAutoFocus?.(event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          props.onInteractOutside?.(event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = context.triggerRef.current?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = React$m.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME$8, __scopeDialog);
    const contentRef = React$m.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState$2(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TitleWarning, { titleId: context.titleId }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME = "DialogTitle";
var DialogTitle$1 = React$m.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle$1.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription";
var DialogDescription = React$m.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME;
var CLOSE_NAME$1 = "DialogClose";
var DialogClose = React$m.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME$1;
function getState$2(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME$8,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React$m.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React$m.useEffect(() => {
    const describedById = contentRef.current?.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root$6 = Dialog$1;
var Portal$4 = DialogPortal;
var Overlay = DialogOverlay;
var Content$1 = DialogContent$1;
var Title = DialogTitle$1;
const React$l = await importShared("react");
var NAME$3 = "VisuallyHidden";
var VisuallyHidden = React$l.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: {
          // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal",
          ...props.style
        }
      }
    );
  }
);
VisuallyHidden.displayName = NAME$3;
var Root$5 = VisuallyHidden;
const React$k = await importShared("react");
var NAME$2 = "Label";
var Label$2 = React$k.forwardRef((props, forwardedRef) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.label,
    {
      ...props,
      ref: forwardedRef,
      onMouseDown: (event) => {
        const target = event.target;
        if (target.closest("button, input, select, textarea")) return;
        props.onMouseDown?.(event);
        if (!event.defaultPrevented && event.detail > 1) event.preventDefault();
      }
    }
  );
});
Label$2.displayName = NAME$2;
var Root$4 = Label$2;
const React$j = await importShared("react");
function createCollection(name) {
  const PROVIDER_NAME2 = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope2] = createContextScope(PROVIDER_NAME2);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME2,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = React$j.useRef(null);
    const itemMap = React$j.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME2;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlot = React$j.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlot = React$j.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = React$j.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      React$j.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection2(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = React$j.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a2, b) => orderedNodes.indexOf(a2.ref.current) - orderedNodes.indexOf(b.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection2,
    createCollectionScope2
  ];
}
const React$i = await importShared("react");
var DirectionContext = React$i.createContext(void 0);
function useDirection(localDir) {
  const globalDir = React$i.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v) => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp$1(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp$1(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b) => a2.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b) => a2[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$1(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$1(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const hide$1 = hide$2;
const arrow$2 = arrow$3;
const limitShift$1 = limitShift$2;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
const React$h = await importShared("react");
const { useLayoutEffect: useLayoutEffect$1, useEffect: useEffect$1 } = await importShared("react");
const ReactDOM$2 = await importShared("react-dom");
var index = typeof document !== "undefined" ? useLayoutEffect$1 : useEffect$1;
function deepEqual(a2, b) {
  if (a2 === b) {
    return true;
  }
  if (typeof a2 !== typeof b) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a2 && b && typeof a2 === "object") {
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a2[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual(a2[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React$h.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React$h.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React$h.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React$h.useState(null);
  const [_floating, _setFloating] = React$h.useState(null);
  const setReference = React$h.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React$h.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React$h.useRef(null);
  const floatingRef = React$h.useRef(null);
  const dataRef = React$h.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React$h.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM$2.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React$h.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React$h.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React$h.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React$h.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React$h.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
const hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
});
const arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
const React$g = await importShared("react");
var NAME$1 = "Arrow";
var Arrow$1 = React$g.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow$1.displayName = NAME$1;
var Root$3 = Arrow$1;
const React$f = await importShared("react");
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React$f.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME$2 = "PopperAnchor";
var PopperAnchor = React$f.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME$2, __scopePopper);
    const ref = React$f.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React$f.useEffect(() => {
      context.onAnchorChange(virtualRef?.current || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME$2;
var CONTENT_NAME$7 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$7);
var PopperContent = React$f.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME$7, __scopePopper);
    const [content, setContent] = React$f.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow$12, setArrow] = React$f.useState(null);
    const arrowSize = useSize(arrow$12);
    const arrowWidth = arrowSize?.width ?? 0;
    const arrowHeight = arrowSize?.height ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip({ ...detectOverflowOptions }),
        size({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow$12 && arrow({ element: arrow$12, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef$1(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced?.();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = middlewareData.arrow?.x;
    const arrowY = middlewareData.arrow?.y;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const [contentZIndex, setContentZIndex] = React$f.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            middlewareData.transformOrigin?.x,
            middlewareData.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...middlewareData.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME$7;
var ARROW_NAME$6 = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React$f.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME$6, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$3,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME$6;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
    let x = "";
    let y = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x, y } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2$5 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow = PopperArrow;
const React$e = await importShared("react");
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var GROUP_NAME$4 = "RovingFocusGroup";
var [Collection$4, useCollection$4, createCollectionScope$4] = createCollection(GROUP_NAME$4);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
  GROUP_NAME$4,
  [createCollectionScope$4]
);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME$4);
var RovingFocusGroup = React$e.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$4.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$4.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
  }
);
RovingFocusGroup.displayName = GROUP_NAME$4;
var RovingFocusGroupImpl = React$e.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref = React$e.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const direction = useDirection(dir);
  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId,
    onChange: onCurrentTabStopIdChange
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = React$e.useState(false);
  const handleEntryFocus = useCallbackRef$1(onEntryFocus);
  const getItems = useCollection$4(__scopeRovingFocusGroup);
  const isClickFocusRef = React$e.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = React$e.useState(0);
  React$e.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: React$e.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: React$e.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: React$e.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: React$e.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation,
          ...groupProps,
          ref: composedRefs,
          style: { outline: "none", ...props.style },
          onMouseDown: composeEventHandlers(props.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers(props.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item) => item.ref.current);
                focusFirst$1(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))
        }
      )
    }
  );
});
var ITEM_NAME$5 = "RovingFocusGroupItem";
var RovingFocusGroupItem = React$e.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      focusable = true,
      active = false,
      tabStopId,
      ...itemProps
    } = props;
    const autoId = useId();
    const id = tabStopId || autoId;
    const context = useRovingFocusContext(ITEM_NAME$5, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id;
    const getItems = useCollection$4(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove } = context;
    React$e.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Collection$4.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id,
        focusable,
        active,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.span,
          {
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context.orientation,
            ...itemProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!focusable) event.preventDefault();
              else context.onItemFocus(id);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id)),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget) return;
              const focusIntent = getFocusIntent(event, context.orientation, context.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;
                event.preventDefault();
                const items = getItems().filter((item) => item.focusable);
                let candidateNodes = items.map((item) => item.ref.current);
                if (focusIntent === "last") candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev") candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context.loop ? wrapArray$3(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst$1(candidateNodes));
              }
            })
          }
        )
      }
    );
  }
);
RovingFocusGroupItem.displayName = ITEM_NAME$5;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl") return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key)) return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key)) return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst$1(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray$3(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
var Root$2 = RovingFocusGroup;
var Item$1 = RovingFocusGroupItem;
const React$d = await importShared("react");
var SELECTION_KEYS$1 = ["Enter", " "];
var FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
var LAST_KEYS = ["ArrowUp", "PageDown", "End"];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS$1, "ArrowRight"],
  rtl: [...SELECTION_KEYS$1, "ArrowLeft"]
};
var SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
var MENU_NAME$1 = "Menu";
var [Collection$3, useCollection$3, createCollectionScope$3] = createCollection(MENU_NAME$1);
var [createMenuContext, createMenuScope] = createContextScope(MENU_NAME$1, [
  createCollectionScope$3,
  createPopperScope,
  createRovingFocusGroupScope
]);
var usePopperScope$3 = createPopperScope();
var useRovingFocusGroupScope$3 = createRovingFocusGroupScope();
var [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME$1);
var [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME$1);
var Menu$2 = (props) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
  const popperScope = usePopperScope$3(__scopeMenu);
  const [content, setContent] = React$d.useState(null);
  const isUsingKeyboardRef = React$d.useRef(false);
  const handleOpenChange = useCallbackRef$1(onOpenChange);
  const direction = useDirection(dir);
  React$d.useEffect(() => {
    const handleKeyDown = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, { capture: true, once: true });
      document.addEventListener("pointermove", handlePointer, { capture: true, once: true });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown, { capture: true });
      document.removeEventListener("pointerdown", handlePointer, { capture: true });
      document.removeEventListener("pointermove", handlePointer, { capture: true });
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuRootProvider,
        {
          scope: __scopeMenu,
          onClose: React$d.useCallback(() => handleOpenChange(false), [handleOpenChange]),
          isUsingKeyboardRef,
          dir: direction,
          modal,
          children
        }
      )
    }
  ) });
};
Menu$2.displayName = MENU_NAME$1;
var ANCHOR_NAME$1 = "MenuAnchor";
var MenuAnchor = React$d.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...anchorProps } = props;
    const popperScope = usePopperScope$3(__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
MenuAnchor.displayName = ANCHOR_NAME$1;
var PORTAL_NAME$5 = "MenuPortal";
var [PortalProvider$2, usePortalContext$2] = createMenuContext(PORTAL_NAME$5, {
  forceMount: void 0
});
var MenuPortal = (props) => {
  const { __scopeMenu, forceMount, children, container } = props;
  const context = useMenuContext(PORTAL_NAME$5, __scopeMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$2, { scope: __scopeMenu, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$5, { asChild: true, container, children }) }) });
};
MenuPortal.displayName = PORTAL_NAME$5;
var CONTENT_NAME$6 = "MenuContent";
var [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME$6);
var MenuContent = React$d.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$2(CONTENT_NAME$6, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useMenuContext(CONTENT_NAME$6, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$6, props.__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Slot, { scope: props.__scopeMenu, children: rootContext.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRootContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRootContentNonModal, { ...contentProps, ref: forwardedRef }) }) }) });
  }
);
var MenuRootContentModal = React$d.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(CONTENT_NAME$6, props.__scopeMenu);
    const ref = React$d.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React$d.useEffect(() => {
      const content = ref.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: context.open,
        disableOutsideScroll: true,
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        ),
        onDismiss: () => context.onOpenChange(false)
      }
    );
  }
);
var MenuRootContentNonModal = React$d.forwardRef((props, forwardedRef) => {
  const context = useMenuContext(CONTENT_NAME$6, props.__scopeMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuContentImpl,
    {
      ...props,
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      disableOutsideScroll: false,
      onDismiss: () => context.onOpenChange(false)
    }
  );
});
var MenuContentImpl = React$d.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeMenu,
      loop = false,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEntryFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      disableOutsideScroll,
      ...contentProps
    } = props;
    const context = useMenuContext(CONTENT_NAME$6, __scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$6, __scopeMenu);
    const popperScope = usePopperScope$3(__scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope$3(__scopeMenu);
    const getItems = useCollection$3(__scopeMenu);
    const [currentItemId, setCurrentItemId] = React$d.useState(null);
    const contentRef = React$d.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);
    const timerRef = React$d.useRef(0);
    const searchRef = React$d.useRef("");
    const pointerGraceTimerRef = React$d.useRef(0);
    const pointerGraceIntentRef = React$d.useRef(null);
    const pointerDirRef = React$d.useRef("right");
    const lastPointerXRef = React$d.useRef(0);
    const ScrollLockWrapper = disableOutsideScroll ? ReactRemoveScroll$1 : React$d.Fragment;
    const scrollLockWrapperProps = disableOutsideScroll ? { as: Slot, allowPinchZoom: true } : void 0;
    const handleTypeaheadSearch = (key) => {
      const search = searchRef.current + key;
      const items = getItems().filter((item) => !item.disabled);
      const currentItem = document.activeElement;
      const currentMatch = items.find((item) => item.ref.current === currentItem)?.textValue;
      const values = items.map((item) => item.textValue);
      const nextMatch = getNextMatch(values, search, currentMatch);
      const newItem = items.find((item) => item.textValue === nextMatch)?.ref.current;
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
      if (newItem) {
        setTimeout(() => newItem.focus());
      }
    };
    React$d.useEffect(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    useFocusGuards();
    const isPointerMovingToSubmenu = React$d.useCallback((event) => {
      const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;
      return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentProvider,
      {
        scope: __scopeMenu,
        searchRef,
        onItemEnter: React$d.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        onItemLeave: React$d.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) return;
            contentRef.current?.focus();
            setCurrentItemId(null);
          },
          [isPointerMovingToSubmenu]
        ),
        onTriggerLeave: React$d.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        pointerGraceTimerRef,
        onPointerGraceIntentChange: React$d.useCallback((intent) => {
          pointerGraceIntentRef.current = intent;
        }, []),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollLockWrapper, { ...scrollLockWrapperProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope,
          {
            asChild: true,
            trapped: trapFocus,
            onMountAutoFocus: composeEventHandlers(onOpenAutoFocus, (event) => {
              event.preventDefault();
              contentRef.current?.focus({ preventScroll: true });
            }),
            onUnmountAutoFocus: onCloseAutoFocus,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside,
                onInteractOutside,
                onDismiss,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Root$2,
                  {
                    asChild: true,
                    ...rovingFocusGroupScope,
                    dir: rootContext.dir,
                    orientation: "vertical",
                    loop,
                    currentTabStopId: currentItemId,
                    onCurrentTabStopIdChange: setCurrentItemId,
                    onEntryFocus: composeEventHandlers(onEntryFocus, (event) => {
                      if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();
                    }),
                    preventScrollOnEntryFocus: true,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Content,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": getOpenState(context.open),
                        "data-radix-menu-content": "",
                        dir: rootContext.dir,
                        ...popperScope,
                        ...contentProps,
                        ref: composedRefs,
                        style: { outline: "none", ...contentProps.style },
                        onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                          const target = event.target;
                          const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
                          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                          const isCharacterKey = event.key.length === 1;
                          if (isKeyDownInside) {
                            if (event.key === "Tab") event.preventDefault();
                            if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);
                          }
                          const content = contentRef.current;
                          if (event.target !== content) return;
                          if (!FIRST_LAST_KEYS.includes(event.key)) return;
                          event.preventDefault();
                          const items = getItems().filter((item) => !item.disabled);
                          const candidateNodes = items.map((item) => item.ref.current);
                          if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();
                          focusFirst(candidateNodes);
                        }),
                        onBlur: composeEventHandlers(props.onBlur, (event) => {
                          if (!event.currentTarget.contains(event.target)) {
                            window.clearTimeout(timerRef.current);
                            searchRef.current = "";
                          }
                        }),
                        onPointerMove: composeEventHandlers(
                          props.onPointerMove,
                          whenMouse((event) => {
                            const target = event.target;
                            const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
                            if (event.currentTarget.contains(target) && pointerXHasChanged) {
                              const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
                              pointerDirRef.current = newDir;
                              lastPointerXRef.current = event.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
MenuContent.displayName = CONTENT_NAME$6;
var GROUP_NAME$3 = "MenuGroup";
var MenuGroup = React$d.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...groupProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { role: "group", ...groupProps, ref: forwardedRef });
  }
);
MenuGroup.displayName = GROUP_NAME$3;
var LABEL_NAME$3 = "MenuLabel";
var MenuLabel = React$d.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...labelProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...labelProps, ref: forwardedRef });
  }
);
MenuLabel.displayName = LABEL_NAME$3;
var ITEM_NAME$4 = "MenuItem";
var ITEM_SELECT = "menu.itemSelect";
var MenuItem$1 = React$d.forwardRef(
  (props, forwardedRef) => {
    const { disabled = false, onSelect, ...itemProps } = props;
    const ref = React$d.useRef(null);
    const rootContext = useMenuRootContext(ITEM_NAME$4, props.__scopeMenu);
    const contentContext = useMenuContentContext(ITEM_NAME$4, props.__scopeMenu);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const isPointerDownRef = React$d.useRef(false);
    const handleSelect = () => {
      const menuItem = ref.current;
      if (!disabled && menuItem) {
        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });
        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), { once: true });
        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);
        if (itemSelectEvent.defaultPrevented) {
          isPointerDownRef.current = false;
        } else {
          rootContext.onClose();
        }
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItemImpl,
      {
        ...itemProps,
        ref: composedRefs,
        disabled,
        onClick: composeEventHandlers(props.onClick, handleSelect),
        onPointerDown: (event) => {
          props.onPointerDown?.(event);
          isPointerDownRef.current = true;
        },
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          if (!isPointerDownRef.current) event.currentTarget?.click();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (disabled || isTypingAhead && event.key === " ") return;
          if (SELECTION_KEYS$1.includes(event.key)) {
            event.currentTarget.click();
            event.preventDefault();
          }
        })
      }
    );
  }
);
MenuItem$1.displayName = ITEM_NAME$4;
var MenuItemImpl = React$d.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
    const contentContext = useMenuContentContext(ITEM_NAME$4, __scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope$3(__scopeMenu);
    const ref = React$d.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const [isFocused, setIsFocused] = React$d.useState(false);
    const [textContent, setTextContent] = React$d.useState("");
    React$d.useEffect(() => {
      const menuItem = ref.current;
      if (menuItem) {
        setTextContent((menuItem.textContent ?? "").trim());
      }
    }, [itemProps.children]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Collection$3.ItemSlot,
      {
        scope: __scopeMenu,
        disabled,
        textValue: textValue ?? textContent,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Item$1, { asChild: true, ...rovingFocusGroupScope, focusable: !disabled, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            role: "menuitem",
            "data-highlighted": isFocused ? "" : void 0,
            "aria-disabled": disabled || void 0,
            "data-disabled": disabled ? "" : void 0,
            ...itemProps,
            ref: composedRefs,
            onPointerMove: composeEventHandlers(
              props.onPointerMove,
              whenMouse((event) => {
                if (disabled) {
                  contentContext.onItemLeave(event);
                } else {
                  contentContext.onItemEnter(event);
                  if (!event.defaultPrevented) {
                    const item = event.currentTarget;
                    item.focus({ preventScroll: true });
                  }
                }
              })
            ),
            onPointerLeave: composeEventHandlers(
              props.onPointerLeave,
              whenMouse((event) => contentContext.onItemLeave(event))
            ),
            onFocus: composeEventHandlers(props.onFocus, () => setIsFocused(true)),
            onBlur: composeEventHandlers(props.onBlur, () => setIsFocused(false))
          }
        ) })
      }
    );
  }
);
var CHECKBOX_ITEM_NAME$2 = "MenuCheckboxItem";
var MenuCheckboxItem = React$d.forwardRef(
  (props, forwardedRef) => {
    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItem$1,
      {
        role: "menuitemcheckbox",
        "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
        ...checkboxItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          checkboxItemProps.onSelect,
          () => onCheckedChange?.(isIndeterminate(checked) ? true : !checked),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME$2;
var RADIO_GROUP_NAME$3 = "MenuRadioGroup";
var [RadioGroupProvider$1, useRadioGroupContext$1] = createMenuContext(
  RADIO_GROUP_NAME$3,
  { value: void 0, onValueChange: () => {
  } }
);
var MenuRadioGroup = React$d.forwardRef(
  (props, forwardedRef) => {
    const { value, onValueChange, ...groupProps } = props;
    const handleValueChange = useCallbackRef$1(onValueChange);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupProvider$1, { scope: props.__scopeMenu, value, onValueChange: handleValueChange, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuGroup, { ...groupProps, ref: forwardedRef }) });
  }
);
MenuRadioGroup.displayName = RADIO_GROUP_NAME$3;
var RADIO_ITEM_NAME$2 = "MenuRadioItem";
var MenuRadioItem = React$d.forwardRef(
  (props, forwardedRef) => {
    const { value, ...radioItemProps } = props;
    const context = useRadioGroupContext$1(RADIO_ITEM_NAME$2, props.__scopeMenu);
    const checked = value === context.value;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItem$1,
      {
        role: "menuitemradio",
        "aria-checked": checked,
        ...radioItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          radioItemProps.onSelect,
          () => context.onValueChange?.(value),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuRadioItem.displayName = RADIO_ITEM_NAME$2;
var ITEM_INDICATOR_NAME$1 = "MenuItemIndicator";
var [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(
  ITEM_INDICATOR_NAME$1,
  { checked: false }
);
var MenuItemIndicator = React$d.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME$1, __scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Presence,
      {
        present: forceMount || isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.span,
          {
            ...itemIndicatorProps,
            ref: forwardedRef,
            "data-state": getCheckedState(indicatorContext.checked)
          }
        )
      }
    );
  }
);
MenuItemIndicator.displayName = ITEM_INDICATOR_NAME$1;
var SEPARATOR_NAME$3 = "MenuSeparator";
var MenuSeparator = React$d.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...separatorProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...separatorProps,
        ref: forwardedRef
      }
    );
  }
);
MenuSeparator.displayName = SEPARATOR_NAME$3;
var ARROW_NAME$5 = "MenuArrow";
var MenuArrow = React$d.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...arrowProps } = props;
    const popperScope = usePopperScope$3(__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
MenuArrow.displayName = ARROW_NAME$5;
var SUB_NAME$1 = "MenuSub";
var [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME$1);
var MenuSub = (props) => {
  const { __scopeMenu, children, open = false, onOpenChange } = props;
  const parentMenuContext = useMenuContext(SUB_NAME$1, __scopeMenu);
  const popperScope = usePopperScope$3(__scopeMenu);
  const [trigger, setTrigger] = React$d.useState(null);
  const [content, setContent] = React$d.useState(null);
  const handleOpenChange = useCallbackRef$1(onOpenChange);
  React$d.useEffect(() => {
    if (parentMenuContext.open === false) handleOpenChange(false);
    return () => handleOpenChange(false);
  }, [parentMenuContext.open, handleOpenChange]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuSubProvider,
        {
          scope: __scopeMenu,
          contentId: useId(),
          triggerId: useId(),
          trigger,
          onTriggerChange: setTrigger,
          children
        }
      )
    }
  ) });
};
MenuSub.displayName = SUB_NAME$1;
var SUB_TRIGGER_NAME$2 = "MenuSubTrigger";
var MenuSubTrigger = React$d.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(SUB_TRIGGER_NAME$2, props.__scopeMenu);
    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME$2, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_TRIGGER_NAME$2, props.__scopeMenu);
    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME$2, props.__scopeMenu);
    const openTimerRef = React$d.useRef(null);
    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
    const scope = { __scopeMenu: props.__scopeMenu };
    const clearOpenTimer = React$d.useCallback(() => {
      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);
      openTimerRef.current = null;
    }, []);
    React$d.useEffect(() => clearOpenTimer, [clearOpenTimer]);
    React$d.useEffect(() => {
      const pointerGraceTimer = pointerGraceTimerRef.current;
      return () => {
        window.clearTimeout(pointerGraceTimer);
        onPointerGraceIntentChange(null);
      };
    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuAnchor, { asChild: true, ...scope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItemImpl,
      {
        id: subContext.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": subContext.contentId,
        "data-state": getOpenState(context.open),
        ...props,
        ref: composeRefs(forwardedRef, subContext.onTriggerChange),
        onClick: (event) => {
          props.onClick?.(event);
          if (props.disabled || event.defaultPrevented) return;
          event.currentTarget.focus();
          if (!context.open) context.onOpenChange(true);
        },
        onPointerMove: composeEventHandlers(
          props.onPointerMove,
          whenMouse((event) => {
            contentContext.onItemEnter(event);
            if (event.defaultPrevented) return;
            if (!props.disabled && !context.open && !openTimerRef.current) {
              contentContext.onPointerGraceIntentChange(null);
              openTimerRef.current = window.setTimeout(() => {
                context.onOpenChange(true);
                clearOpenTimer();
              }, 100);
            }
          })
        ),
        onPointerLeave: composeEventHandlers(
          props.onPointerLeave,
          whenMouse((event) => {
            clearOpenTimer();
            const contentRect = context.content?.getBoundingClientRect();
            if (contentRect) {
              const side = context.content?.dataset.side;
              const rightSide = side === "right";
              const bleed = rightSide ? -5 : 5;
              const contentNearEdge = contentRect[rightSide ? "left" : "right"];
              const contentFarEdge = contentRect[rightSide ? "right" : "left"];
              contentContext.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: event.clientX + bleed, y: event.clientY },
                  { x: contentNearEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.bottom },
                  { x: contentNearEdge, y: contentRect.bottom }
                ],
                side
              });
              window.clearTimeout(pointerGraceTimerRef.current);
              pointerGraceTimerRef.current = window.setTimeout(
                () => contentContext.onPointerGraceIntentChange(null),
                300
              );
            } else {
              contentContext.onTriggerLeave(event);
              if (event.defaultPrevented) return;
              contentContext.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (props.disabled || isTypingAhead && event.key === " ") return;
          if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
            context.onOpenChange(true);
            context.content?.focus();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
MenuSubTrigger.displayName = SUB_TRIGGER_NAME$2;
var SUB_CONTENT_NAME$2 = "MenuSubContent";
var MenuSubContent = React$d.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$2(CONTENT_NAME$6, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...subContentProps } = props;
    const context = useMenuContext(CONTENT_NAME$6, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$6, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_CONTENT_NAME$2, props.__scopeMenu);
    const ref = React$d.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Slot, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentImpl,
      {
        id: subContext.contentId,
        "aria-labelledby": subContext.triggerId,
        ...subContentProps,
        ref: composedRefs,
        align: "start",
        side: rootContext.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        trapFocus: false,
        onOpenAutoFocus: (event) => {
          if (rootContext.isUsingKeyboardRef.current) ref.current?.focus();
          event.preventDefault();
        },
        onCloseAutoFocus: (event) => event.preventDefault(),
        onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
          if (event.target !== subContext.trigger) context.onOpenChange(false);
        }),
        onEscapeKeyDown: composeEventHandlers(props.onEscapeKeyDown, (event) => {
          rootContext.onClose();
          event.preventDefault();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isKeyDownInside = event.currentTarget.contains(event.target);
          const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
          if (isKeyDownInside && isCloseKey) {
            context.onOpenChange(false);
            subContext.trigger?.focus();
            event.preventDefault();
          }
        })
      }
    ) }) }) });
  }
);
MenuSubContent.displayName = SUB_CONTENT_NAME$2;
function getOpenState(open) {
  return open ? "open" : "closed";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray$2(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray$2(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function isPointInPolygon$1(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area) return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon$1(cursorPos, area);
}
function whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
var Root3$2 = Menu$2;
var Anchor2 = MenuAnchor;
var Portal$3 = MenuPortal;
var Content2$5 = MenuContent;
var Group$1 = MenuGroup;
var Label$1 = MenuLabel;
var Item2$2 = MenuItem$1;
var CheckboxItem = MenuCheckboxItem;
var RadioGroup$2 = MenuRadioGroup;
var RadioItem = MenuRadioItem;
var ItemIndicator = MenuItemIndicator;
var Separator$2 = MenuSeparator;
var Arrow2$1 = MenuArrow;
var Sub = MenuSub;
var SubTrigger = MenuSubTrigger;
var SubContent = MenuSubContent;
const React$c = await importShared("react");
var DROPDOWN_MENU_NAME = "DropdownMenu";
var [createDropdownMenuContext, createDropdownMenuScope] = createContextScope(
  DROPDOWN_MENU_NAME,
  [createMenuScope]
);
var useMenuScope$1 = createMenuScope();
var [DropdownMenuProvider, useDropdownMenuContext] = createDropdownMenuContext(DROPDOWN_MENU_NAME);
var DropdownMenu = (props) => {
  const {
    __scopeDropdownMenu,
    children,
    dir,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const menuScope = useMenuScope$1(__scopeDropdownMenu);
  const triggerRef = React$c.useRef(null);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DropdownMenuProvider,
    {
      scope: __scopeDropdownMenu,
      triggerId: useId(),
      triggerRef,
      contentId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React$c.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root3$2, { ...menuScope, open, onOpenChange: setOpen, dir, modal, children })
    }
  );
};
DropdownMenu.displayName = DROPDOWN_MENU_NAME;
var TRIGGER_NAME$5 = "DropdownMenuTrigger";
var DropdownMenuTrigger = React$c.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;
    const context = useDropdownMenuContext(TRIGGER_NAME$5, __scopeDropdownMenu);
    const menuScope = useMenuScope$1(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor2, { asChild: true, ...menuScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        id: context.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": context.open ? context.contentId : void 0,
        "data-state": context.open ? "open" : "closed",
        "data-disabled": disabled ? "" : void 0,
        disabled,
        ...triggerProps,
        ref: composeRefs(forwardedRef, context.triggerRef),
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          if (!disabled && event.button === 0 && event.ctrlKey === false) {
            context.onOpenToggle();
            if (!context.open) event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (disabled) return;
          if (["Enter", " "].includes(event.key)) context.onOpenToggle();
          if (event.key === "ArrowDown") context.onOpenChange(true);
          if (["Enter", " ", "ArrowDown"].includes(event.key)) event.preventDefault();
        })
      }
    ) });
  }
);
DropdownMenuTrigger.displayName = TRIGGER_NAME$5;
var PORTAL_NAME$4 = "DropdownMenuPortal";
var DropdownMenuPortal = (props) => {
  const { __scopeDropdownMenu, ...portalProps } = props;
  const menuScope = useMenuScope$1(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { ...menuScope, ...portalProps });
};
DropdownMenuPortal.displayName = PORTAL_NAME$4;
var CONTENT_NAME$5 = "DropdownMenuContent";
var DropdownMenuContent = React$c.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...contentProps } = props;
    const context = useDropdownMenuContext(CONTENT_NAME$5, __scopeDropdownMenu);
    const menuScope = useMenuScope$1(__scopeDropdownMenu);
    const hasInteractedOutsideRef = React$c.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content2$5,
      {
        id: context.contentId,
        "aria-labelledby": context.triggerId,
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onInteractOutside: composeEventHandlers(props.onInteractOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (!context.modal || isRightClick) hasInteractedOutsideRef.current = true;
        }),
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
DropdownMenuContent.displayName = CONTENT_NAME$5;
var GROUP_NAME$2 = "DropdownMenuGroup";
var DropdownMenuGroup = React$c.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...groupProps } = props;
    const menuScope = useMenuScope$1(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Group$1, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
DropdownMenuGroup.displayName = GROUP_NAME$2;
var LABEL_NAME$2 = "DropdownMenuLabel";
var DropdownMenuLabel = React$c.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...labelProps } = props;
    const menuScope = useMenuScope$1(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
DropdownMenuLabel.displayName = LABEL_NAME$2;
var ITEM_NAME$3 = "DropdownMenuItem";
var DropdownMenuItem = React$c.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...itemProps } = props;
    const menuScope = useMenuScope$1(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Item2$2, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
DropdownMenuItem.displayName = ITEM_NAME$3;
var CHECKBOX_ITEM_NAME$1 = "DropdownMenuCheckboxItem";
var DropdownMenuCheckboxItem = React$c.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...checkboxItemProps } = props;
  const menuScope = useMenuScope$1(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
DropdownMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME$1;
var RADIO_GROUP_NAME$2 = "DropdownMenuRadioGroup";
var DropdownMenuRadioGroup = React$c.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioGroupProps } = props;
  const menuScope = useMenuScope$1(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroup$2, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
DropdownMenuRadioGroup.displayName = RADIO_GROUP_NAME$2;
var RADIO_ITEM_NAME$1 = "DropdownMenuRadioItem";
var DropdownMenuRadioItem = React$c.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioItemProps } = props;
  const menuScope = useMenuScope$1(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
DropdownMenuRadioItem.displayName = RADIO_ITEM_NAME$1;
var INDICATOR_NAME$2 = "DropdownMenuItemIndicator";
var DropdownMenuItemIndicator = React$c.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope$1(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
DropdownMenuItemIndicator.displayName = INDICATOR_NAME$2;
var SEPARATOR_NAME$2 = "DropdownMenuSeparator";
var DropdownMenuSeparator = React$c.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...separatorProps } = props;
  const menuScope = useMenuScope$1(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Separator$2, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
DropdownMenuSeparator.displayName = SEPARATOR_NAME$2;
var ARROW_NAME$4 = "DropdownMenuArrow";
var DropdownMenuArrow = React$c.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...arrowProps } = props;
    const menuScope = useMenuScope$1(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow2$1, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
DropdownMenuArrow.displayName = ARROW_NAME$4;
var SUB_TRIGGER_NAME$1 = "DropdownMenuSubTrigger";
var DropdownMenuSubTrigger = React$c.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subTriggerProps } = props;
  const menuScope = useMenuScope$1(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SubTrigger, { ...menuScope, ...subTriggerProps, ref: forwardedRef });
});
DropdownMenuSubTrigger.displayName = SUB_TRIGGER_NAME$1;
var SUB_CONTENT_NAME$1 = "DropdownMenuSubContent";
var DropdownMenuSubContent = React$c.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subContentProps } = props;
  const menuScope = useMenuScope$1(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SubContent,
    {
      ...menuScope,
      ...subContentProps,
      ref: forwardedRef,
      style: {
        ...props.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
DropdownMenuSubContent.displayName = SUB_CONTENT_NAME$1;
var Root2$4 = DropdownMenu;
var Trigger$5 = DropdownMenuTrigger;
var Portal2$1 = DropdownMenuPortal;
var Content2$4 = DropdownMenuContent;
var Item2$1 = DropdownMenuItem;
const React$b = await importShared("react");
var MENUBAR_NAME = "Menubar";
var [Collection$2, useCollection$2, createCollectionScope$2] = createCollection(MENUBAR_NAME);
var [createMenubarContext, createMenubarScope] = createContextScope(MENUBAR_NAME, [
  createCollectionScope$2,
  createRovingFocusGroupScope
]);
var useMenuScope = createMenuScope();
var useRovingFocusGroupScope$2 = createRovingFocusGroupScope();
var [MenubarContextProvider, useMenubarContext] = createMenubarContext(MENUBAR_NAME);
var Menubar$1 = React$b.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeMenubar,
      value: valueProp,
      onValueChange,
      defaultValue,
      loop = true,
      dir,
      ...menubarProps
    } = props;
    const direction = useDirection(dir);
    const rovingFocusGroupScope = useRovingFocusGroupScope$2(__scopeMenubar);
    const [value = "", setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue
    });
    const [currentTabStopId, setCurrentTabStopId] = React$b.useState(null);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenubarContextProvider,
      {
        scope: __scopeMenubar,
        value,
        onMenuOpen: React$b.useCallback(
          (value2) => {
            setValue(value2);
            setCurrentTabStopId(value2);
          },
          [setValue]
        ),
        onMenuClose: React$b.useCallback(() => setValue(""), [setValue]),
        onMenuToggle: React$b.useCallback(
          (value2) => {
            setValue((prevValue) => Boolean(prevValue) ? "" : value2);
            setCurrentTabStopId(value2);
          },
          [setValue]
        ),
        dir: direction,
        loop,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Provider, { scope: __scopeMenubar, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Slot, { scope: __scopeMenubar, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$2,
          {
            asChild: true,
            ...rovingFocusGroupScope,
            orientation: "horizontal",
            loop,
            dir: direction,
            currentTabStopId,
            onCurrentTabStopIdChange: setCurrentTabStopId,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { role: "menubar", ...menubarProps, ref: forwardedRef })
          }
        ) }) })
      }
    );
  }
);
Menubar$1.displayName = MENUBAR_NAME;
var MENU_NAME = "MenubarMenu";
var [MenubarMenuProvider, useMenubarMenuContext] = createMenubarContext(MENU_NAME);
var MenubarMenu$1 = (props) => {
  const { __scopeMenubar, value: valueProp, ...menuProps } = props;
  const autoValue = useId();
  const value = valueProp || autoValue || "LEGACY_REACT_AUTO_VALUE";
  const context = useMenubarContext(MENU_NAME, __scopeMenubar);
  const menuScope = useMenuScope(__scopeMenubar);
  const triggerRef = React$b.useRef(null);
  const wasKeyboardTriggerOpenRef = React$b.useRef(false);
  const open = context.value === value;
  React$b.useEffect(() => {
    if (!open) wasKeyboardTriggerOpenRef.current = false;
  }, [open]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenubarMenuProvider,
    {
      scope: __scopeMenubar,
      value,
      triggerId: useId(),
      triggerRef,
      contentId: useId(),
      wasKeyboardTriggerOpenRef,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Root3$2,
        {
          ...menuScope,
          open,
          onOpenChange: (open2) => {
            if (!open2) context.onMenuClose();
          },
          modal: false,
          dir: context.dir,
          ...menuProps
        }
      )
    }
  );
};
MenubarMenu$1.displayName = MENU_NAME;
var TRIGGER_NAME$4 = "MenubarTrigger";
var MenubarTrigger$1 = React$b.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, disabled = false, ...triggerProps } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope$2(__scopeMenubar);
    const menuScope = useMenuScope(__scopeMenubar);
    const context = useMenubarContext(TRIGGER_NAME$4, __scopeMenubar);
    const menuContext = useMenubarMenuContext(TRIGGER_NAME$4, __scopeMenubar);
    const ref = React$b.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, menuContext.triggerRef);
    const [isFocused, setIsFocused] = React$b.useState(false);
    const open = context.value === menuContext.value;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.ItemSlot, { scope: __scopeMenubar, value: menuContext.value, disabled, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item$1,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        tabStopId: menuContext.value,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor2, { asChild: true, ...menuScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.button,
          {
            type: "button",
            role: "menuitem",
            id: menuContext.triggerId,
            "aria-haspopup": "menu",
            "aria-expanded": open,
            "aria-controls": open ? menuContext.contentId : void 0,
            "data-highlighted": isFocused ? "" : void 0,
            "data-state": open ? "open" : "closed",
            "data-disabled": disabled ? "" : void 0,
            disabled,
            ...triggerProps,
            ref: composedRefs,
            onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
              if (!disabled && event.button === 0 && event.ctrlKey === false) {
                context.onMenuOpen(menuContext.value);
                if (!open) event.preventDefault();
              }
            }),
            onPointerEnter: composeEventHandlers(props.onPointerEnter, () => {
              const menubarOpen = Boolean(context.value);
              if (menubarOpen && !open) {
                context.onMenuOpen(menuContext.value);
                ref.current?.focus();
              }
            }),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if (disabled) return;
              if (["Enter", " "].includes(event.key)) context.onMenuToggle(menuContext.value);
              if (event.key === "ArrowDown") context.onMenuOpen(menuContext.value);
              if (["Enter", " ", "ArrowDown"].includes(event.key)) {
                menuContext.wasKeyboardTriggerOpenRef.current = true;
                event.preventDefault();
              }
            }),
            onFocus: composeEventHandlers(props.onFocus, () => setIsFocused(true)),
            onBlur: composeEventHandlers(props.onBlur, () => setIsFocused(false))
          }
        ) })
      }
    ) });
  }
);
MenubarTrigger$1.displayName = TRIGGER_NAME$4;
var PORTAL_NAME$3 = "MenubarPortal";
var MenubarPortal$1 = (props) => {
  const { __scopeMenubar, ...portalProps } = props;
  const menuScope = useMenuScope(__scopeMenubar);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { ...menuScope, ...portalProps });
};
MenubarPortal$1.displayName = PORTAL_NAME$3;
var CONTENT_NAME$4 = "MenubarContent";
var MenubarContent$1 = React$b.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, align = "start", ...contentProps } = props;
    const menuScope = useMenuScope(__scopeMenubar);
    const context = useMenubarContext(CONTENT_NAME$4, __scopeMenubar);
    const menuContext = useMenubarMenuContext(CONTENT_NAME$4, __scopeMenubar);
    const getItems = useCollection$2(__scopeMenubar);
    const hasInteractedOutsideRef = React$b.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content2$5,
      {
        id: menuContext.contentId,
        "aria-labelledby": menuContext.triggerId,
        "data-radix-menubar-content": "",
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        align,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          const menubarOpen = Boolean(context.value);
          if (!menubarOpen && !hasInteractedOutsideRef.current) {
            menuContext.triggerRef.current?.focus();
          }
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
          const target = event.target;
          const isMenubarTrigger = getItems().some((item) => item.ref.current?.contains(target));
          if (isMenubarTrigger) event.preventDefault();
        }),
        onInteractOutside: composeEventHandlers(props.onInteractOutside, () => {
          hasInteractedOutsideRef.current = true;
        }),
        onEntryFocus: (event) => {
          if (!menuContext.wasKeyboardTriggerOpenRef.current) event.preventDefault();
        },
        onKeyDown: composeEventHandlers(
          props.onKeyDown,
          (event) => {
            if (["ArrowRight", "ArrowLeft"].includes(event.key)) {
              const target = event.target;
              const targetIsSubTrigger = target.hasAttribute("data-radix-menubar-subtrigger");
              const isKeyDownInsideSubMenu = target.closest("[data-radix-menubar-content]") !== event.currentTarget;
              const prevMenuKey = context.dir === "rtl" ? "ArrowRight" : "ArrowLeft";
              const isPrevKey = prevMenuKey === event.key;
              const isNextKey = !isPrevKey;
              if (isNextKey && targetIsSubTrigger) return;
              if (isKeyDownInsideSubMenu && isPrevKey) return;
              const items = getItems().filter((item) => !item.disabled);
              let candidateValues = items.map((item) => item.value);
              if (isPrevKey) candidateValues.reverse();
              const currentIndex = candidateValues.indexOf(menuContext.value);
              candidateValues = context.loop ? wrapArray$1(candidateValues, currentIndex + 1) : candidateValues.slice(currentIndex + 1);
              const [nextValue] = candidateValues;
              if (nextValue) context.onMenuOpen(nextValue);
            }
          },
          { checkForDefaultPrevented: false }
        ),
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
            "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
            "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
MenubarContent$1.displayName = CONTENT_NAME$4;
var GROUP_NAME$1 = "MenubarGroup";
var MenubarGroup = React$b.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...groupProps } = props;
    const menuScope = useMenuScope(__scopeMenubar);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Group$1, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
MenubarGroup.displayName = GROUP_NAME$1;
var LABEL_NAME$1 = "MenubarLabel";
var MenubarLabel = React$b.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...labelProps } = props;
    const menuScope = useMenuScope(__scopeMenubar);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
MenubarLabel.displayName = LABEL_NAME$1;
var ITEM_NAME$2 = "MenubarItem";
var MenubarItem$1 = React$b.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...itemProps } = props;
    const menuScope = useMenuScope(__scopeMenubar);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Item2$2, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
MenubarItem$1.displayName = ITEM_NAME$2;
var CHECKBOX_ITEM_NAME = "MenubarCheckboxItem";
var MenubarCheckboxItem$1 = React$b.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...checkboxItemProps } = props;
    const menuScope = useMenuScope(__scopeMenubar);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
  }
);
MenubarCheckboxItem$1.displayName = CHECKBOX_ITEM_NAME;
var RADIO_GROUP_NAME$1 = "MenubarRadioGroup";
var MenubarRadioGroup$1 = React$b.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...radioGroupProps } = props;
    const menuScope = useMenuScope(__scopeMenubar);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroup$2, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
  }
);
MenubarRadioGroup$1.displayName = RADIO_GROUP_NAME$1;
var RADIO_ITEM_NAME = "MenubarRadioItem";
var MenubarRadioItem$1 = React$b.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...radioItemProps } = props;
    const menuScope = useMenuScope(__scopeMenubar);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
  }
);
MenubarRadioItem$1.displayName = RADIO_ITEM_NAME;
var INDICATOR_NAME$1 = "MenubarItemIndicator";
var MenubarItemIndicator$1 = React$b.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope(__scopeMenubar);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
MenubarItemIndicator$1.displayName = INDICATOR_NAME$1;
var SEPARATOR_NAME$1 = "MenubarSeparator";
var MenubarSeparator$1 = React$b.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...separatorProps } = props;
    const menuScope = useMenuScope(__scopeMenubar);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Separator$2, { ...menuScope, ...separatorProps, ref: forwardedRef });
  }
);
MenubarSeparator$1.displayName = SEPARATOR_NAME$1;
var ARROW_NAME$3 = "MenubarArrow";
var MenubarArrow = React$b.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...arrowProps } = props;
    const menuScope = useMenuScope(__scopeMenubar);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow2$1, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
MenubarArrow.displayName = ARROW_NAME$3;
var SUB_NAME = "MenubarSub";
var MenubarSub$1 = (props) => {
  const { __scopeMenubar, children, open: openProp, onOpenChange, defaultOpen } = props;
  const menuScope = useMenuScope(__scopeMenubar);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Sub, { ...menuScope, open, onOpenChange: setOpen, children });
};
MenubarSub$1.displayName = SUB_NAME;
var SUB_TRIGGER_NAME = "MenubarSubTrigger";
var MenubarSubTrigger$1 = React$b.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...subTriggerProps } = props;
    const menuScope = useMenuScope(__scopeMenubar);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SubTrigger,
      {
        "data-radix-menubar-subtrigger": "",
        ...menuScope,
        ...subTriggerProps,
        ref: forwardedRef
      }
    );
  }
);
MenubarSubTrigger$1.displayName = SUB_TRIGGER_NAME;
var SUB_CONTENT_NAME = "MenubarSubContent";
var MenubarSubContent$1 = React$b.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...subContentProps } = props;
    const menuScope = useMenuScope(__scopeMenubar);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SubContent,
      {
        ...menuScope,
        "data-radix-menubar-content": "",
        ...subContentProps,
        ref: forwardedRef,
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
            "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
            "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
MenubarSubContent$1.displayName = SUB_CONTENT_NAME;
function wrapArray$1(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
var Root3$1 = Menubar$1;
var Menu$1 = MenubarMenu$1;
var Trigger$4 = MenubarTrigger$1;
var Portal2 = MenubarPortal$1;
var Content2$3 = MenubarContent$1;
var Item3 = MenubarItem$1;
var CheckboxItem2 = MenubarCheckboxItem$1;
var RadioGroup2 = MenubarRadioGroup$1;
var RadioItem2 = MenubarRadioItem$1;
var ItemIndicator2 = MenubarItemIndicator$1;
var Separator2 = MenubarSeparator$1;
var Sub2 = MenubarSub$1;
var SubTrigger2 = MenubarSubTrigger$1;
var SubContent2 = MenubarSubContent$1;
const React$a = await importShared("react");
var POPOVER_NAME = "Popover";
var [createPopoverContext, createPopoverScope] = createContextScope(POPOVER_NAME, [
  createPopperScope
]);
var usePopperScope$2 = createPopperScope();
var [PopoverProvider, usePopoverContext] = createPopoverContext(POPOVER_NAME);
var Popover$1 = (props) => {
  const {
    __scopePopover,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = false
  } = props;
  const popperScope = usePopperScope$2(__scopePopover);
  const triggerRef = React$a.useRef(null);
  const [hasCustomAnchor, setHasCustomAnchor] = React$a.useState(false);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    PopoverProvider,
    {
      scope: __scopePopover,
      contentId: useId(),
      triggerRef,
      open,
      onOpenChange: setOpen,
      onOpenToggle: React$a.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      hasCustomAnchor,
      onCustomAnchorAdd: React$a.useCallback(() => setHasCustomAnchor(true), []),
      onCustomAnchorRemove: React$a.useCallback(() => setHasCustomAnchor(false), []),
      modal,
      children
    }
  ) });
};
Popover$1.displayName = POPOVER_NAME;
var ANCHOR_NAME = "PopoverAnchor";
var PopoverAnchor = React$a.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...anchorProps } = props;
    const context = usePopoverContext(ANCHOR_NAME, __scopePopover);
    const popperScope = usePopperScope$2(__scopePopover);
    const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
    React$a.useEffect(() => {
      onCustomAnchorAdd();
      return () => onCustomAnchorRemove();
    }, [onCustomAnchorAdd, onCustomAnchorRemove]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
PopoverAnchor.displayName = ANCHOR_NAME;
var TRIGGER_NAME$3 = "PopoverTrigger";
var PopoverTrigger = React$a.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...triggerProps } = props;
    const context = usePopoverContext(TRIGGER_NAME$3, __scopePopover);
    const popperScope = usePopperScope$2(__scopePopover);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    const trigger = /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState$1(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
    return context.hasCustomAnchor ? trigger : /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: trigger });
  }
);
PopoverTrigger.displayName = TRIGGER_NAME$3;
var PORTAL_NAME$2 = "PopoverPortal";
var [PortalProvider$1, usePortalContext$1] = createPopoverContext(PORTAL_NAME$2, {
  forceMount: void 0
});
var PopoverPortal = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context = usePopoverContext(PORTAL_NAME$2, __scopePopover);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$1, { scope: __scopePopover, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$5, { asChild: true, container, children }) }) });
};
PopoverPortal.displayName = PORTAL_NAME$2;
var CONTENT_NAME$3 = "PopoverContent";
var PopoverContent = React$a.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$1(CONTENT_NAME$3, props.__scopePopover);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = usePopoverContext(CONTENT_NAME$3, props.__scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
PopoverContent.displayName = CONTENT_NAME$3;
var PopoverContentModal = React$a.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME$3, props.__scopePopover);
    const contentRef = React$a.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const isRightClickOutsideRef = React$a.useRef(false);
    React$a.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll$1, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      PopoverContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          event.preventDefault();
          if (!isRightClickOutsideRef.current) context.triggerRef.current?.focus();
        }),
        onPointerDownOutside: composeEventHandlers(
          props.onPointerDownOutside,
          (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            isRightClickOutsideRef.current = isRightClick;
          },
          { checkForDefaultPrevented: false }
        ),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
var PopoverContentNonModal = React$a.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME$3, props.__scopePopover);
    const hasInteractedOutsideRef = React$a.useRef(false);
    const hasPointerDownOutsideRef = React$a.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      PopoverContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          props.onCloseAutoFocus?.(event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          props.onInteractOutside?.(event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = context.triggerRef.current?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var PopoverContentImpl = React$a.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopover,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      ...contentProps
    } = props;
    const context = usePopoverContext(CONTENT_NAME$3, __scopePopover);
    const popperScope = usePopperScope$2(__scopePopover);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      FocusScope,
      {
        asChild: true,
        loop: true,
        trapped: trapFocus,
        onMountAutoFocus: onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          DismissableLayer,
          {
            asChild: true,
            disableOutsidePointerEvents,
            onInteractOutside,
            onEscapeKeyDown,
            onPointerDownOutside,
            onFocusOutside,
            onDismiss: () => context.onOpenChange(false),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Content,
              {
                "data-state": getState$1(context.open),
                role: "dialog",
                id: context.contentId,
                ...popperScope,
                ...contentProps,
                ref: forwardedRef,
                style: {
                  ...contentProps.style,
                  // re-namespace exposed content custom properties
                  ...{
                    "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                    "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                    "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                    "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                    "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                  }
                }
              }
            )
          }
        )
      }
    );
  }
);
var CLOSE_NAME = "PopoverClose";
var PopoverClose = React$a.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...closeProps } = props;
    const context = usePopoverContext(CLOSE_NAME, __scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
PopoverClose.displayName = CLOSE_NAME;
var ARROW_NAME$2 = "PopoverArrow";
var PopoverArrow = React$a.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...arrowProps } = props;
    const popperScope = usePopperScope$2(__scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
PopoverArrow.displayName = ARROW_NAME$2;
function getState$1(open) {
  return open ? "open" : "closed";
}
var Root2$3 = Popover$1;
var Trigger$3 = PopoverTrigger;
var Portal$2 = PopoverPortal;
var Content2$2 = PopoverContent;
var Arrow2 = PopoverArrow;
var U$1 = 1, Y = 0.9, a = 0.8, H = 0.17, p = 0.1, u = 0.999, J$1 = 0.9999;
var k = 0.99, m = /[\\\/_+.#"@\[\(\{&]/, B$1 = /[\\\/_+.#"@\[\(\{&]/g, K = /[\s-]/, X = /[\s-]/g;
function G(c, f, P, C, h, A2, O2) {
  if (A2 === f.length) return h === c.length ? U$1 : k;
  var T = `${h},${A2}`;
  if (O2[T] !== void 0) return O2[T];
  for (var L2 = C.charAt(A2), E = P.indexOf(L2, h), S2 = 0, _2, N, R, M; E >= 0; ) _2 = G(c, f, P, C, E + 1, A2 + 1, O2), _2 > S2 && (E === h ? _2 *= U$1 : m.test(c.charAt(E - 1)) ? (_2 *= a, R = c.slice(h, E - 1).match(B$1), R && h > 0 && (_2 *= Math.pow(u, R.length))) : K.test(c.charAt(E - 1)) ? (_2 *= Y, M = c.slice(h, E - 1).match(X), M && h > 0 && (_2 *= Math.pow(u, M.length))) : (_2 *= H, h > 0 && (_2 *= Math.pow(u, E - h))), c.charAt(E) !== f.charAt(A2) && (_2 *= J$1)), (_2 < p && P.charAt(E - 1) === C.charAt(A2 + 1) || C.charAt(A2 + 1) === C.charAt(A2) && P.charAt(E - 1) !== C.charAt(A2)) && (N = G(c, f, P, C, E + 1, A2 + 2, O2), N * p > _2 && (_2 = N * p)), _2 > S2 && (S2 = _2), E = P.indexOf(L2, E + 1);
  return O2[T] = S2, S2;
}
function D$1(c) {
  return c.toLowerCase().replace(X, " ");
}
function W$1(c, f) {
  return G(c, f, D$1(c), D$1(f), 0, 0, {});
}
function $e42e1063c40fb3ef$export$b9ecd428b558ff10(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
  };
}
const { useCallback: $3vqmr$useCallback } = await importShared("react");
function $6ed0406888f73fc4$var$setRef(ref, value) {
  if (typeof ref === "function") ref(value);
  else if (ref !== null && ref !== void 0) ref.current = value;
}
function $6ed0406888f73fc4$export$43e446d32b3d21af(...refs) {
  return (node) => refs.forEach(
    (ref) => $6ed0406888f73fc4$var$setRef(ref, node)
  );
}
function $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...refs) {
  return $3vqmr$useCallback($6ed0406888f73fc4$export$43e446d32b3d21af(...refs), refs);
}
const { createContext: $3bkAK$createContext, useMemo: $3bkAK$useMemo, createElement: $3bkAK$createElement, useContext: $3bkAK$useContext } = await importShared("react");
function $c512c27ab02ef895$export$50c7b4e9d9f19c1(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext) {
    const BaseContext = /* @__PURE__ */ $3bkAK$createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [
      ...defaultContexts,
      defaultContext
    ];
    function Provider2(props) {
      const { scope, children, ...context } = props;
      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const value = $3bkAK$useMemo(
        () => context,
        Object.values(context)
      );
      return /* @__PURE__ */ $3bkAK$createElement(Context.Provider, {
        value
      }, children);
    }
    function useContext(consumerName, scope) {
      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const context = $3bkAK$useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider2.displayName = rootComponentName + "Provider";
    return [
      Provider2,
      useContext
    ];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return /* @__PURE__ */ $3bkAK$createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope === null || scope === void 0 ? void 0 : scope[scopeName]) || scopeContexts;
      return $3bkAK$useMemo(
        () => ({
          [`__scope${scopeName}`]: {
            ...scope,
            [scopeName]: contexts
          }
        }),
        [
          scope,
          contexts
        ]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [
    $c512c27ab02ef895$export$fd42f52fd3ae1109,
    $c512c27ab02ef895$var$composeContextScopes(createScope, ...createContextScopeDeps)
  ];
}
function $c512c27ab02ef895$var$composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope1 = () => {
    const scopeHooks = scopes.map(
      (createScope) => ({
        useScope: createScope(),
        scopeName: createScope.scopeName
      })
    );
    return function useComposedScopes(overrideScopes) {
      const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return {
          ...nextScopes,
          ...currentScope
        };
      }, {});
      return $3bkAK$useMemo(
        () => ({
          [`__scope${baseScope.scopeName}`]: nextScopes1
        }),
        [
          nextScopes1
        ]
      );
    };
  };
  createScope1.scopeName = baseScope.scopeName;
  return createScope1;
}
const { useLayoutEffect: $dxlwH$useLayoutEffect } = await importShared("react");
const $9f79659886946c16$export$e5c5a5f917a5871c = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? $dxlwH$useLayoutEffect : () => {
};
const $2AODx$react = await importShared("react");
const $1746a345f3d73bb7$var$useReactId = $2AODx$react["useId".toString()] || (() => void 0);
let $1746a345f3d73bb7$var$count = 0;
function $1746a345f3d73bb7$export$f680877a34711e37(deterministicId) {
  const [id, setId] = $2AODx$react.useState($1746a345f3d73bb7$var$useReactId());
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (!deterministicId) setId(
      (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count++)
    );
  }, [
    deterministicId
  ]);
  return deterministicId || (id ? `radix-${id}` : "");
}
const { useRef: $lwiWj$useRef, useEffect: $lwiWj$useEffect, useMemo: $lwiWj$useMemo } = await importShared("react");
function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback) {
  const callbackRef = $lwiWj$useRef(callback);
  $lwiWj$useEffect(() => {
    callbackRef.current = callback;
  });
  return $lwiWj$useMemo(
    () => (...args) => {
      var _callbackRef$current;
      return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
    },
    []
  );
}
const { useCallback: $bnPw9$useCallback, useState: $bnPw9$useState, useRef: $bnPw9$useRef, useEffect: $bnPw9$useEffect } = await importShared("react");
function $71cd76cc60e0454e$export$6f32135080cb4c3({ prop, defaultProp, onChange = () => {
} }) {
  const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value1 = isControlled ? prop : uncontrolledProp;
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  const setValue = $bnPw9$useCallback((nextValue) => {
    if (isControlled) {
      const setter = nextValue;
      const value = typeof nextValue === "function" ? setter(prop) : nextValue;
      if (value !== prop) handleChange(value);
    } else setUncontrolledProp(nextValue);
  }, [
    isControlled,
    prop,
    setUncontrolledProp,
    handleChange
  ]);
  return [
    value1,
    setValue
  ];
}
function $71cd76cc60e0454e$var$useUncontrolledState({ defaultProp, onChange }) {
  const uncontrolledState = $bnPw9$useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = $bnPw9$useRef(value);
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  $bnPw9$useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [
    value,
    prevValueRef,
    handleChange
  ]);
  return uncontrolledState;
}
const { forwardRef: $9IrjX$forwardRef, Children: $9IrjX$Children, isValidElement: $9IrjX$isValidElement, createElement: $9IrjX$createElement, cloneElement: $9IrjX$cloneElement, Fragment: $9IrjX$Fragment } = await importShared("react");
const $5e63c961fc1ce211$export$8c6ed5c666ac1360 = /* @__PURE__ */ $9IrjX$forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = $9IrjX$Children.toArray(children);
  const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if ($9IrjX$Children.count(newElement) > 1) return $9IrjX$Children.only(null);
        return /* @__PURE__ */ $9IrjX$isValidElement(newElement) ? newElement.props.children : null;
      } else return child;
    });
    return /* @__PURE__ */ $9IrjX$createElement($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
      ref: forwardedRef
    }), /* @__PURE__ */ $9IrjX$isValidElement(newElement) ? /* @__PURE__ */ $9IrjX$cloneElement(newElement, void 0, newChildren) : null);
  }
  return /* @__PURE__ */ $9IrjX$createElement($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
    ref: forwardedRef
  }), children);
});
$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = "Slot";
const $5e63c961fc1ce211$var$SlotClone = /* @__PURE__ */ $9IrjX$forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (/* @__PURE__ */ $9IrjX$isValidElement(children)) return /* @__PURE__ */ $9IrjX$cloneElement(children, {
    ...$5e63c961fc1ce211$var$mergeProps(slotProps, children.props),
    ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, children.ref)
  });
  return $9IrjX$Children.count(children) > 1 ? $9IrjX$Children.only(null) : null;
});
$5e63c961fc1ce211$var$SlotClone.displayName = "SlotClone";
const $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children }) => {
  return /* @__PURE__ */ $9IrjX$createElement($9IrjX$Fragment, null, children);
};
function $5e63c961fc1ce211$var$isSlottable(child) {
  return /* @__PURE__ */ $9IrjX$isValidElement(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;
}
function $5e63c961fc1ce211$var$mergeProps(slotProps, childProps) {
  const overrideProps = {
    ...childProps
  };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) overrideProps[propName] = (...args) => {
      childPropValue === null || childPropValue === void 0 || childPropValue(...args);
      slotPropValue === null || slotPropValue === void 0 || slotPropValue(...args);
    };
    else if (propName === "style") overrideProps[propName] = {
      ...slotPropValue,
      ...childPropValue
    };
    else if (propName === "className") overrideProps[propName] = [
      slotPropValue,
      childPropValue
    ].filter(Boolean).join(" ");
  }
  return {
    ...slotProps,
    ...overrideProps
  };
}
const { forwardRef: $4q5Fq$forwardRef, useEffect: $4q5Fq$useEffect, createElement: $4q5Fq$createElement } = await importShared("react");
const { flushSync: $4q5Fq$flushSync } = await importShared("react-dom");
const $8927f6f2acc4f386$var$NODES = [
  "a",
  "button",
  "div",
  "h2",
  "h3",
  "img",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
const $8927f6f2acc4f386$export$250ffa63cdc0d034 = $8927f6f2acc4f386$var$NODES.reduce((primitive, node) => {
  const Node2 = /* @__PURE__ */ $4q5Fq$forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac1360 : node;
    $4q5Fq$useEffect(() => {
      window[Symbol.for("radix-ui")] = true;
    }, []);
    return /* @__PURE__ */ $4q5Fq$createElement(Comp, _extends({}, primitiveProps, {
      ref: forwardedRef
    }));
  });
  Node2.displayName = `Primitive.${node}`;
  return {
    ...primitive,
    [node]: Node2
  };
}, {});
function $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event) {
  if (target) $4q5Fq$flushSync(
    () => target.dispatchEvent(event)
  );
}
const { useEffect: $hPSQ5$useEffect } = await importShared("react");
function $addc16e1bbe58fd0$export$3a72a57244d6e765(onEscapeKeyDownProp) {
  const onEscapeKeyDown = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEscapeKeyDownProp);
  $hPSQ5$useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") onEscapeKeyDown(event);
    };
    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [
    onEscapeKeyDown
  ]);
}
const { createContext: $kqwpH$createContext, forwardRef: $kqwpH$forwardRef, useContext: $kqwpH$useContext, useState: $kqwpH$useState, useEffect: $kqwpH$useEffect, createElement: $kqwpH$createElement, useRef: $kqwpH$useRef } = await importShared("react");
const $5cb92bef7577960e$var$CONTEXT_UPDATE = "dismissableLayer.update";
const $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
const $5cb92bef7577960e$var$FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
let $5cb92bef7577960e$var$originalBodyPointerEvents;
const $5cb92bef7577960e$var$DismissableLayerContext = /* @__PURE__ */ $kqwpH$createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
const $5cb92bef7577960e$export$177fb62ff3ec1f22 = /* @__PURE__ */ $kqwpH$forwardRef((props, forwardedRef) => {
  const { disableOutsidePointerEvents = false, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, ...layerProps } = props;
  const context = $kqwpH$useContext($5cb92bef7577960e$var$DismissableLayerContext);
  const [node1, setNode] = $kqwpH$useState(null);
  const [, force] = $kqwpH$useState({});
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setNode(node)
  );
  const layers = Array.from(context.layers);
  const [highestLayerWithOutsidePointerEventsDisabled] = [
    ...context.layersWithOutsidePointerEventsDisabled
  ].slice(-1);
  const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
  const index2 = node1 ? layers.indexOf(node1) : -1;
  const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
  const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
  const pointerDownOutside = $5cb92bef7577960e$var$usePointerDownOutside((event) => {
    const target = event.target;
    const isPointerDownOnBranch = [
      ...context.branches
    ].some(
      (branch) => branch.contains(target)
    );
    if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
    onPointerDownOutside === null || onPointerDownOutside === void 0 || onPointerDownOutside(event);
    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
    if (!event.defaultPrevented) onDismiss === null || onDismiss === void 0 || onDismiss();
  });
  const focusOutside = $5cb92bef7577960e$var$useFocusOutside((event) => {
    const target = event.target;
    const isFocusInBranch = [
      ...context.branches
    ].some(
      (branch) => branch.contains(target)
    );
    if (isFocusInBranch) return;
    onFocusOutside === null || onFocusOutside === void 0 || onFocusOutside(event);
    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
    if (!event.defaultPrevented) onDismiss === null || onDismiss === void 0 || onDismiss();
  });
  $addc16e1bbe58fd0$export$3a72a57244d6e765((event) => {
    const isHighestLayer = index2 === context.layers.size - 1;
    if (!isHighestLayer) return;
    onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  });
  $kqwpH$useEffect(() => {
    if (!node1) return;
    if (disableOutsidePointerEvents) {
      if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
        $5cb92bef7577960e$var$originalBodyPointerEvents = document.body.style.pointerEvents;
        document.body.style.pointerEvents = "none";
      }
      context.layersWithOutsidePointerEventsDisabled.add(node1);
    }
    context.layers.add(node1);
    $5cb92bef7577960e$var$dispatchUpdate();
    return () => {
      if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) document.body.style.pointerEvents = $5cb92bef7577960e$var$originalBodyPointerEvents;
    };
  }, [
    node1,
    disableOutsidePointerEvents,
    context
  ]);
  $kqwpH$useEffect(() => {
    return () => {
      if (!node1) return;
      context.layers.delete(node1);
      context.layersWithOutsidePointerEventsDisabled.delete(node1);
      $5cb92bef7577960e$var$dispatchUpdate();
    };
  }, [
    node1,
    context
  ]);
  $kqwpH$useEffect(() => {
    const handleUpdate = () => force({});
    document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
    return () => document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
  }, []);
  return /* @__PURE__ */ $kqwpH$createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, layerProps, {
    ref: composedRefs,
    style: {
      pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
      ...props.style
    },
    onFocusCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusCapture, focusOutside.onFocusCapture),
    onBlurCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlurCapture, focusOutside.onBlurCapture),
    onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)
  }));
});
function $5cb92bef7577960e$var$usePointerDownOutside(onPointerDownOutside) {
  const handlePointerDownOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPointerDownOutside);
  const isPointerInsideReactTreeRef = $kqwpH$useRef(false);
  const handleClickRef = $kqwpH$useRef(() => {
  });
  $kqwpH$useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent = function() {
          $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, {
            discrete: true
          });
        };
        const eventDetail = {
          originalEvent: event
        };
        if (event.pointerType === "touch") {
          document.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;
          document.addEventListener("click", handleClickRef.current, {
            once: true
          });
        } else handleAndDispatchPointerDownOutsideEvent();
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      document.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      document.removeEventListener("pointerdown", handlePointerDown);
      document.removeEventListener("click", handleClickRef.current);
    };
  }, [
    handlePointerDownOutside
  ]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function $5cb92bef7577960e$var$useFocusOutside(onFocusOutside) {
  const handleFocusOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onFocusOutside);
  const isFocusInsideReactTreeRef = $kqwpH$useRef(false);
  $kqwpH$useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = {
          originalEvent: event
        };
        $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    document.addEventListener("focusin", handleFocus);
    return () => document.removeEventListener("focusin", handleFocus);
  }, [
    handleFocusOutside
  ]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function $5cb92bef7577960e$var$dispatchUpdate() {
  const event = new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function $5cb92bef7577960e$var$handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, {
    bubbles: false,
    cancelable: true,
    detail
  });
  if (handler) target.addEventListener(name, handler, {
    once: true
  });
  if (discrete) $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event);
  else target.dispatchEvent(event);
}
const { forwardRef: $45QHv$forwardRef, useState: $45QHv$useState, useRef: $45QHv$useRef, useEffect: $45QHv$useEffect, useCallback: $45QHv$useCallback, createElement: $45QHv$createElement } = await importShared("react");
const $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
const $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
const $d3863c46a17e8a28$var$EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
const $d3863c46a17e8a28$export$20e40289641fbbb6 = /* @__PURE__ */ $45QHv$forwardRef((props, forwardedRef) => {
  const { loop = false, trapped = false, onMountAutoFocus: onMountAutoFocusProp, onUnmountAutoFocus: onUnmountAutoFocusProp, ...scopeProps } = props;
  const [container1, setContainer] = $45QHv$useState(null);
  const onMountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onMountAutoFocusProp);
  const onUnmountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onUnmountAutoFocusProp);
  const lastFocusedElementRef = $45QHv$useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setContainer(node)
  );
  const focusScope = $45QHv$useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  $45QHv$useEffect(() => {
    if (trapped) {
      let handleFocusIn = function(event) {
        if (focusScope.paused || !container1) return;
        const target = event.target;
        if (container1.contains(target)) lastFocusedElementRef.current = target;
        else $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
          select: true
        });
      }, handleFocusOut = function(event) {
        if (focusScope.paused || !container1) return;
        if (!container1.contains(event.relatedTarget)) $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
          select: true
        });
      };
      document.addEventListener("focusin", handleFocusIn);
      document.addEventListener("focusout", handleFocusOut);
      return () => {
        document.removeEventListener("focusin", handleFocusIn);
        document.removeEventListener("focusout", handleFocusOut);
      };
    }
  }, [
    trapped,
    container1,
    focusScope.paused
  ]);
  $45QHv$useEffect(() => {
    if (container1) {
      $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container1.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
        container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container1.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {
            select: true
          });
          if (document.activeElement === previouslyFocusedElement) $d3863c46a17e8a28$var$focus(container1);
        }
      }
      return () => {
        container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
          container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container1.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {
            select: true
          });
          container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [
    container1,
    onMountAutoFocus,
    onUnmountAutoFocus,
    focusScope
  ]);
  const handleKeyDown = $45QHv$useCallback((event) => {
    if (!loop && !trapped) return;
    if (focusScope.paused) return;
    const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
    const focusedElement = document.activeElement;
    if (isTabKey && focusedElement) {
      const container = event.currentTarget;
      const [first, last] = $d3863c46a17e8a28$var$getTabbableEdges(container);
      const hasTabbableElementsInside = first && last;
      if (!hasTabbableElementsInside) {
        if (focusedElement === container) event.preventDefault();
      } else {
        if (!event.shiftKey && focusedElement === last) {
          event.preventDefault();
          if (loop) $d3863c46a17e8a28$var$focus(first, {
            select: true
          });
        } else if (event.shiftKey && focusedElement === first) {
          event.preventDefault();
          if (loop) $d3863c46a17e8a28$var$focus(last, {
            select: true
          });
        }
      }
    }
  }, [
    loop,
    trapped,
    focusScope.paused
  ]);
  return /* @__PURE__ */ $45QHv$createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    tabIndex: -1
  }, scopeProps, {
    ref: composedRefs,
    onKeyDown: handleKeyDown
  }));
});
function $d3863c46a17e8a28$var$focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    $d3863c46a17e8a28$var$focus(candidate, {
      select
    });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function $d3863c46a17e8a28$var$getTabbableEdges(container) {
  const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container);
  const first = $d3863c46a17e8a28$var$findVisible(candidates, container);
  const last = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container);
  return [
    first,
    last
  ];
}
function $d3863c46a17e8a28$var$getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function $d3863c46a17e8a28$var$findVisible(elements, container) {
  for (const element of elements) {
    if (!$d3863c46a17e8a28$var$isHidden(element, {
      upTo: container
    })) return element;
  }
}
function $d3863c46a17e8a28$var$isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function $d3863c46a17e8a28$var$isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function $d3863c46a17e8a28$var$focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({
      preventScroll: true
    });
    if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element) && select) element.select();
  }
}
const $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();
function $d3863c46a17e8a28$var$createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();
      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _stack$;
      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
      (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();
    }
  };
}
function $d3863c46a17e8a28$var$arrayRemove(array, item) {
  const updatedArray = [
    ...array
  ];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) updatedArray.splice(index2, 1);
  return updatedArray;
}
function $d3863c46a17e8a28$var$removeLinks(items) {
  return items.filter(
    (item) => item.tagName !== "A"
  );
}
const { forwardRef: $7SXl2$forwardRef, createElement: $7SXl2$createElement } = await importShared("react");
const $7SXl2$reactdom = await importShared("react-dom");
const $f1701beae083dbae$export$602eac185826482c = /* @__PURE__ */ $7SXl2$forwardRef((props, forwardedRef) => {
  var _globalThis$document;
  const { container = globalThis === null || globalThis === void 0 ? void 0 : (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.body, ...portalProps } = props;
  return container ? /* @__PURE__ */ $7SXl2$reactdom.createPortal(/* @__PURE__ */ $7SXl2$createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, portalProps, {
    ref: forwardedRef
  })), container) : null;
});
const { Children: $iqq3r$Children, cloneElement: $iqq3r$cloneElement, useState: $iqq3r$useState, useRef: $iqq3r$useRef, useEffect: $iqq3r$useEffect, useCallback: $iqq3r$useCallback, useReducer: $iqq3r$useReducer } = await importShared("react");
const { flushSync: $iqq3r$flushSync } = await importShared("react-dom");
function $fe963b355347cc68$export$3e6543de14f8614f(initialState, machine) {
  return $iqq3r$useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState !== null && nextState !== void 0 ? nextState : state;
  }, initialState);
}
const $921a889cee6df7e8$export$99c2b779aa4e8b8b = (props) => {
  const { present, children } = props;
  const presence = $921a889cee6df7e8$var$usePresence(present);
  const child = typeof children === "function" ? children({
    present: presence.isPresent
  }) : $iqq3r$Children.only(children);
  const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(presence.ref, child.ref);
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? /* @__PURE__ */ $iqq3r$cloneElement(child, {
    ref
  }) : null;
};
$921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName = "Presence";
function $921a889cee6df7e8$var$usePresence(present) {
  const [node1, setNode] = $iqq3r$useState();
  const stylesRef = $iqq3r$useRef({});
  const prevPresentRef = $iqq3r$useRef(present);
  const prevAnimationNameRef = $iqq3r$useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = $fe963b355347cc68$export$3e6543de14f8614f(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  $iqq3r$useEffect(() => {
    const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [
    state
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    const styles2 = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(styles2);
      if (present) send("MOUNT");
      else if (currentAnimationName === "none" || (styles2 === null || styles2 === void 0 ? void 0 : styles2.display) === "none")
        send("UNMOUNT");
      else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) send("ANIMATION_OUT");
        else send("UNMOUNT");
      }
      prevPresentRef.current = present;
    }
  }, [
    present,
    send
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (node1) {
      const handleAnimationEnd = (event) => {
        const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node1 && isCurrentAnimation)
          $iqq3r$flushSync(
            () => send("ANIMATION_END")
          );
      };
      const handleAnimationStart = (event) => {
        if (event.target === node1)
          prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
      };
      node1.addEventListener("animationstart", handleAnimationStart);
      node1.addEventListener("animationcancel", handleAnimationEnd);
      node1.addEventListener("animationend", handleAnimationEnd);
      return () => {
        node1.removeEventListener("animationstart", handleAnimationStart);
        node1.removeEventListener("animationcancel", handleAnimationEnd);
        node1.removeEventListener("animationend", handleAnimationEnd);
      };
    } else
      send("ANIMATION_END");
  }, [
    node1,
    send
  ]);
  return {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(state),
    ref: $iqq3r$useCallback((node) => {
      if (node) stylesRef.current = getComputedStyle(node);
      setNode(node);
    }, [])
  };
}
function $921a889cee6df7e8$var$getAnimationName(styles2) {
  return (styles2 === null || styles2 === void 0 ? void 0 : styles2.animationName) || "none";
}
const { useEffect: $1wErz$useEffect } = await importShared("react");
let $3db38b7d1fb3fe6a$var$count = 0;
function $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c() {
  $1wErz$useEffect(() => {
    var _edgeGuards$, _edgeGuards$2;
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", (_edgeGuards$ = edgeGuards[0]) !== null && _edgeGuards$ !== void 0 ? _edgeGuards$ : $3db38b7d1fb3fe6a$var$createFocusGuard());
    document.body.insertAdjacentElement("beforeend", (_edgeGuards$2 = edgeGuards[1]) !== null && _edgeGuards$2 !== void 0 ? _edgeGuards$2 : $3db38b7d1fb3fe6a$var$createFocusGuard());
    $3db38b7d1fb3fe6a$var$count++;
    return () => {
      if ($3db38b7d1fb3fe6a$var$count === 1) document.querySelectorAll("[data-radix-focus-guard]").forEach(
        (node) => node.remove()
      );
      $3db38b7d1fb3fe6a$var$count--;
    };
  }, []);
}
function $3db38b7d1fb3fe6a$var$createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
  return element;
}
var effectCar = createSidecarMedium();
const React$9 = await importShared("react");
var nothing = function() {
  return;
};
var RemoveScroll = React$9.forwardRef(function(props, parentRef) {
  var ref = React$9.useRef(null);
  var _a = React$9.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container2 = _b === void 0 ? "div" : _b, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React$9.createElement(
    React$9.Fragment,
    null,
    enabled && React$9.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }),
    forwardProps ? React$9.cloneElement(React$9.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React$9.createElement(Container2, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var elementCouldBeVScrolled = function(node) {
  var styles2 = window.getComputedStyle(node);
  return styles2.overflowY !== "hidden" && // not-not-scrollable
  !(styles2.overflowY === styles2.overflowX && styles2.overflowY === "visible");
};
var elementCouldBeHScrolled = function(node) {
  var styles2 = window.getComputedStyle(node);
  return styles2.overflowX !== "hidden" && // not-not-scrollable
  !(styles2.overflowY === styles2.overflowX && styles2.overflowX === "visible");
};
var locationCouldBeScrolled = function(axis, node) {
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), s = _a[1], d = _a[2];
      if (s > d) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== document.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    target = target.parentNode;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (availableScroll === 0 || !noOverscroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (availableScrollTop === 0 || !noOverscroll)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
const React$8 = await importShared("react");
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React$8.useRef([]);
  var touchStartRef = React$8.useRef([0, 0]);
  var activeAxis = React$8.useRef();
  var id = React$8.useState(idCounter++)[0];
  var Style2 = React$8.useState(function() {
    return styleSingleton();
  })[0];
  var lastProps = React$8.useRef(props);
  React$8.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React$8.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React$8.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React$8.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && e.target === event.target && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      event.preventDefault();
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        event.preventDefault();
      }
    }
  }, []);
  var shouldCancel = React$8.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React$8.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React$8.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React$8.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React$8.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React$8.createElement(
    React$8.Fragment,
    null,
    inert ? React$8.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React$8.createElement(RemoveScrollBar, { gapMode: "margin" }) : null
  );
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
const React$7 = await importShared("react");
var ReactRemoveScroll = React$7.forwardRef(function(props, ref) {
  return React$7.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
const { useRef: $67UHm$useRef, createElement: $67UHm$createElement, useCallback: $67UHm$useCallback, forwardRef: $67UHm$forwardRef, Children: $67UHm$Children, useEffect: $67UHm$useEffect, Fragment: $67UHm$Fragment } = await importShared("react");
const $5d3850c4d0b4e6c7$var$DIALOG_NAME = "Dialog";
const [$5d3850c4d0b4e6c7$var$createDialogContext, $5d3850c4d0b4e6c7$export$cc702773b8ea3e41] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($5d3850c4d0b4e6c7$var$DIALOG_NAME);
const [$5d3850c4d0b4e6c7$var$DialogProvider, $5d3850c4d0b4e6c7$var$useDialogContext] = $5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$DIALOG_NAME);
const $5d3850c4d0b4e6c7$export$3ddf2d174ce01153 = (props) => {
  const { __scopeDialog, children, open: openProp, defaultOpen, onOpenChange, modal = true } = props;
  const triggerRef = $67UHm$useRef(null);
  const contentRef = $67UHm$useRef(null);
  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ $67UHm$createElement($5d3850c4d0b4e6c7$var$DialogProvider, {
    scope: __scopeDialog,
    triggerRef,
    contentRef,
    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
    titleId: $1746a345f3d73bb7$export$f680877a34711e37(),
    descriptionId: $1746a345f3d73bb7$export$f680877a34711e37(),
    open,
    onOpenChange: setOpen,
    onOpenToggle: $67UHm$useCallback(
      () => setOpen(
        (prevOpen) => !prevOpen
      ),
      [
        setOpen
      ]
    ),
    modal
  }, children);
};
const $5d3850c4d0b4e6c7$var$PORTAL_NAME = "DialogPortal";
const [$5d3850c4d0b4e6c7$var$PortalProvider, $5d3850c4d0b4e6c7$var$usePortalContext] = $5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$PORTAL_NAME, {
  forceMount: void 0
});
const $5d3850c4d0b4e6c7$export$dad7c95542bacce0 = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$PORTAL_NAME, __scopeDialog);
  return /* @__PURE__ */ $67UHm$createElement($5d3850c4d0b4e6c7$var$PortalProvider, {
    scope: __scopeDialog,
    forceMount
  }, $67UHm$Children.map(
    children,
    (child) => /* @__PURE__ */ $67UHm$createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
      present: forceMount || context.open
    }, /* @__PURE__ */ $67UHm$createElement($f1701beae083dbae$export$602eac185826482c, {
      asChild: true,
      container
    }, child))
  ));
};
const $5d3850c4d0b4e6c7$var$OVERLAY_NAME = "DialogOverlay";
const $5d3850c4d0b4e6c7$export$bd1d06c79be19e17 = /* @__PURE__ */ $67UHm$forwardRef((props, forwardedRef) => {
  const portalContext = $5d3850c4d0b4e6c7$var$usePortalContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, props.__scopeDialog);
  const { forceMount = portalContext.forceMount, ...overlayProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, props.__scopeDialog);
  return context.modal ? /* @__PURE__ */ $67UHm$createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, /* @__PURE__ */ $67UHm$createElement($5d3850c4d0b4e6c7$var$DialogOverlayImpl, _extends({}, overlayProps, {
    ref: forwardedRef
  }))) : null;
});
const $5d3850c4d0b4e6c7$var$DialogOverlayImpl = /* @__PURE__ */ $67UHm$forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...overlayProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, __scopeDialog);
  return (
    // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
    // ie. when `Overlay` and `Content` are siblings
    /* @__PURE__ */ $67UHm$createElement(ReactRemoveScroll, {
      as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
      allowPinchZoom: true,
      shards: [
        context.contentRef
      ]
    }, /* @__PURE__ */ $67UHm$createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
      "data-state": $5d3850c4d0b4e6c7$var$getState(context.open)
    }, overlayProps, {
      ref: forwardedRef,
      style: {
        pointerEvents: "auto",
        ...overlayProps.style
      }
    })))
  );
});
const $5d3850c4d0b4e6c7$var$CONTENT_NAME = "DialogContent";
const $5d3850c4d0b4e6c7$export$b6d9565de1e068cf = /* @__PURE__ */ $67UHm$forwardRef((props, forwardedRef) => {
  const portalContext = $5d3850c4d0b4e6c7$var$usePortalContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
  return /* @__PURE__ */ $67UHm$createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, context.modal ? /* @__PURE__ */ $67UHm$createElement($5d3850c4d0b4e6c7$var$DialogContentModal, _extends({}, contentProps, {
    ref: forwardedRef
  })) : /* @__PURE__ */ $67UHm$createElement($5d3850c4d0b4e6c7$var$DialogContentNonModal, _extends({}, contentProps, {
    ref: forwardedRef
  })));
});
/* @__PURE__ */ Object.assign($5d3850c4d0b4e6c7$export$b6d9565de1e068cf, {
  displayName: $5d3850c4d0b4e6c7$var$CONTENT_NAME
});
const $5d3850c4d0b4e6c7$var$DialogContentModal = /* @__PURE__ */ $67UHm$forwardRef((props, forwardedRef) => {
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
  const contentRef = $67UHm$useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.contentRef, contentRef);
  $67UHm$useEffect(() => {
    const content = contentRef.current;
    if (content) return hideOthers(content);
  }, []);
  return /* @__PURE__ */ $67UHm$createElement($5d3850c4d0b4e6c7$var$DialogContentImpl, _extends({}, props, {
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {
      var _context$triggerRef$c;
      event.preventDefault();
      (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
    }),
    onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      if (isRightClick) event.preventDefault();
    }),
    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocusOutside,
      (event) => event.preventDefault()
    )
  }));
});
const $5d3850c4d0b4e6c7$var$DialogContentNonModal = /* @__PURE__ */ $67UHm$forwardRef((props, forwardedRef) => {
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
  const hasInteractedOutsideRef = $67UHm$useRef(false);
  return /* @__PURE__ */ $67UHm$createElement($5d3850c4d0b4e6c7$var$DialogContentImpl, _extends({}, props, {
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: (event) => {
      var _props$onCloseAutoFoc;
      (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);
      if (!event.defaultPrevented) {
        var _context$triggerRef$c2;
        if (!hasInteractedOutsideRef.current) (_context$triggerRef$c2 = context.triggerRef.current) === null || _context$triggerRef$c2 === void 0 || _context$triggerRef$c2.focus();
        event.preventDefault();
      }
      hasInteractedOutsideRef.current = false;
    },
    onInteractOutside: (event) => {
      var _props$onInteractOuts, _context$triggerRef$c3;
      (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);
      if (!event.defaultPrevented) hasInteractedOutsideRef.current = true;
      const target = event.target;
      const targetIsTrigger = (_context$triggerRef$c3 = context.triggerRef.current) === null || _context$triggerRef$c3 === void 0 ? void 0 : _context$triggerRef$c3.contains(target);
      if (targetIsTrigger) event.preventDefault();
    }
  }));
});
const $5d3850c4d0b4e6c7$var$DialogContentImpl = /* @__PURE__ */ $67UHm$forwardRef((props, forwardedRef) => {
  const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, __scopeDialog);
  const contentRef = $67UHm$useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef);
  $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
  return /* @__PURE__ */ $67UHm$createElement($67UHm$Fragment, null, /* @__PURE__ */ $67UHm$createElement($d3863c46a17e8a28$export$20e40289641fbbb6, {
    asChild: true,
    loop: true,
    trapped: trapFocus,
    onMountAutoFocus: onOpenAutoFocus,
    onUnmountAutoFocus: onCloseAutoFocus
  }, /* @__PURE__ */ $67UHm$createElement($5cb92bef7577960e$export$177fb62ff3ec1f22, _extends({
    role: "dialog",
    id: context.contentId,
    "aria-describedby": context.descriptionId,
    "aria-labelledby": context.titleId,
    "data-state": $5d3850c4d0b4e6c7$var$getState(context.open)
  }, contentProps, {
    ref: composedRefs,
    onDismiss: () => context.onOpenChange(false)
  }))), false);
});
const $5d3850c4d0b4e6c7$var$TITLE_NAME = "DialogTitle";
const $5d3850c4d0b4e6c7$export$16f7638e4a34b909 = /* @__PURE__ */ $67UHm$forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...titleProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$TITLE_NAME, __scopeDialog);
  return /* @__PURE__ */ $67UHm$createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.h2, _extends({
    id: context.titleId
  }, titleProps, {
    ref: forwardedRef
  }));
});
/* @__PURE__ */ Object.assign($5d3850c4d0b4e6c7$export$16f7638e4a34b909, {
  displayName: $5d3850c4d0b4e6c7$var$TITLE_NAME
});
const $5d3850c4d0b4e6c7$var$DESCRIPTION_NAME = "DialogDescription";
const $5d3850c4d0b4e6c7$export$94e94c2ec2c954d5 = /* @__PURE__ */ $67UHm$forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...descriptionProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$DESCRIPTION_NAME, __scopeDialog);
  return /* @__PURE__ */ $67UHm$createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.p, _extends({
    id: context.descriptionId
  }, descriptionProps, {
    ref: forwardedRef
  }));
});
/* @__PURE__ */ Object.assign($5d3850c4d0b4e6c7$export$94e94c2ec2c954d5, {
  displayName: $5d3850c4d0b4e6c7$var$DESCRIPTION_NAME
});
const $5d3850c4d0b4e6c7$var$CLOSE_NAME = "DialogClose";
const $5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac = /* @__PURE__ */ $67UHm$forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...closeProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CLOSE_NAME, __scopeDialog);
  return /* @__PURE__ */ $67UHm$createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    type: "button"
  }, closeProps, {
    ref: forwardedRef,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onClick,
      () => context.onOpenChange(false)
    )
  }));
});
/* @__PURE__ */ Object.assign($5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac, {
  displayName: $5d3850c4d0b4e6c7$var$CLOSE_NAME
});
function $5d3850c4d0b4e6c7$var$getState(open) {
  return open ? "open" : "closed";
}
const $5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9 = $5d3850c4d0b4e6c7$export$3ddf2d174ce01153;
const $5d3850c4d0b4e6c7$export$602eac185826482c = $5d3850c4d0b4e6c7$export$dad7c95542bacce0;
const $5d3850c4d0b4e6c7$export$c6fdb837b070b4ff = $5d3850c4d0b4e6c7$export$bd1d06c79be19e17;
const $5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2 = $5d3850c4d0b4e6c7$export$b6d9565de1e068cf;
const t = await importShared("react");
var fe = '[cmdk-list-sizer=""]', O = '[cmdk-group=""]', U = '[cmdk-group-items=""]', me = '[cmdk-group-heading=""]', W = '[cmdk-item=""]', ae = `${W}:not([aria-disabled="true"])`, B = "cmdk-item-select", S = "data-value", pe = (r2, c) => W$1(r2, c), se = t.createContext(void 0), A = () => t.useContext(se), ie = t.createContext(void 0), J = () => t.useContext(ie), ce = t.createContext(void 0), le = t.forwardRef((r2, c) => {
  let n = t.useRef(null), o = w(() => {
    var e, s, a2;
    return { search: "", value: (a2 = (s = r2.value) != null ? s : (e = r2.defaultValue) == null ? void 0 : e.toLowerCase()) != null ? a2 : "", filtered: { count: 0, items: /* @__PURE__ */ new Map(), groups: /* @__PURE__ */ new Set() } };
  }), l = w(() => /* @__PURE__ */ new Set()), d = w(() => /* @__PURE__ */ new Map()), f = w(() => /* @__PURE__ */ new Map()), g = w(() => /* @__PURE__ */ new Set()), u2 = ue(r2), { label: b, children: p2, value: R, onValueChange: T, filter: I, shouldFilter: C, vimBindings: F = true, ...P } = r2, Q = t.useId(), K2 = t.useId(), V = t.useId(), E = Le();
  D(() => {
    if (R !== void 0) {
      let e = R.trim().toLowerCase();
      o.current.value = e, E(6, Y2), m2.emit();
    }
  }, [R]);
  let m2 = t.useMemo(() => ({ subscribe: (e) => (g.current.add(e), () => g.current.delete(e)), snapshot: () => o.current, setState: (e, s, a2) => {
    var i, v, h;
    if (!Object.is(o.current[e], s)) {
      if (o.current[e] = s, e === "search") $(), N(), E(1, j);
      else if (e === "value") if (((i = u2.current) == null ? void 0 : i.value) !== void 0) {
        let x = s != null ? s : "";
        (h = (v = u2.current).onValueChange) == null || h.call(v, x);
        return;
      } else a2 || E(5, Y2);
      m2.emit();
    }
  }, emit: () => {
    g.current.forEach((e) => e());
  } }), []), M = t.useMemo(() => ({ value: (e, s) => {
    s !== f.current.get(e) && (f.current.set(e, s), o.current.filtered.items.set(e, X2(s)), E(2, () => {
      N(), m2.emit();
    }));
  }, item: (e, s) => (l.current.add(e), s && (d.current.has(s) ? d.current.get(s).add(e) : d.current.set(s, /* @__PURE__ */ new Set([e]))), E(3, () => {
    $(), N(), o.current.value || j(), m2.emit();
  }), () => {
    f.current.delete(e), l.current.delete(e), o.current.filtered.items.delete(e);
    let a2 = k2();
    E(4, () => {
      $(), (a2 == null ? void 0 : a2.getAttribute("id")) === e && j(), m2.emit();
    });
  }), group: (e) => (d.current.has(e) || d.current.set(e, /* @__PURE__ */ new Set()), () => {
    f.current.delete(e), d.current.delete(e);
  }), filter: () => u2.current.shouldFilter, label: b || r2["aria-label"], commandRef: n, listId: Q, inputId: V, labelId: K2 }), []);
  function X2(e) {
    var a2, i;
    let s = (i = (a2 = u2.current) == null ? void 0 : a2.filter) != null ? i : pe;
    return e ? s(e, o.current.search) : 0;
  }
  function N() {
    if (!n.current || !o.current.search || u2.current.shouldFilter === false) return;
    let e = o.current.filtered.items, s = [];
    o.current.filtered.groups.forEach((i) => {
      let v = d.current.get(i), h = 0;
      v.forEach((x) => {
        let G2 = e.get(x);
        h = Math.max(G2, h);
      }), s.push([i, h]);
    });
    let a2 = n.current.querySelector(fe);
    H2().sort((i, v) => {
      var G2, re;
      let h = i.getAttribute(S), x = v.getAttribute(S);
      return ((G2 = e.get(x)) != null ? G2 : 0) - ((re = e.get(h)) != null ? re : 0);
    }).forEach((i) => {
      let v = i.closest(U);
      v ? v.appendChild(i.parentElement === v ? i : i.closest(`${U} > *`)) : a2.appendChild(i.parentElement === a2 ? i : i.closest(`${U} > *`));
    }), s.sort((i, v) => v[1] - i[1]).forEach((i) => {
      let v = n.current.querySelector(`${O}[${S}="${i[0]}"]`);
      v == null || v.parentElement.appendChild(v);
    });
  }
  function j() {
    let e = H2().find((a2) => !a2.ariaDisabled), s = e == null ? void 0 : e.getAttribute(S);
    m2.setState("value", s || void 0);
  }
  function $() {
    if (!o.current.search || u2.current.shouldFilter === false) {
      o.current.filtered.count = l.current.size;
      return;
    }
    o.current.filtered.groups = /* @__PURE__ */ new Set();
    let e = 0;
    for (let s of l.current) {
      let a2 = f.current.get(s), i = X2(a2);
      o.current.filtered.items.set(s, i), i > 0 && e++;
    }
    for (let [s, a2] of d.current) for (let i of a2) if (o.current.filtered.items.get(i) > 0) {
      o.current.filtered.groups.add(s);
      break;
    }
    o.current.filtered.count = e;
  }
  function Y2() {
    var s, a2, i;
    let e = k2();
    e && (((s = e.parentElement) == null ? void 0 : s.firstChild) === e && ((i = (a2 = e.closest(O)) == null ? void 0 : a2.querySelector(me)) == null || i.scrollIntoView({ block: "nearest" })), e.scrollIntoView({ block: "nearest" }));
  }
  function k2() {
    var e;
    return (e = n.current) == null ? void 0 : e.querySelector(`${W}[aria-selected="true"]`);
  }
  function H2() {
    return Array.from(n.current.querySelectorAll(ae));
  }
  function q(e) {
    let a2 = H2()[e];
    a2 && m2.setState("value", a2.getAttribute(S));
  }
  function z(e) {
    var h;
    let s = k2(), a2 = H2(), i = a2.findIndex((x) => x === s), v = a2[i + e];
    (h = u2.current) != null && h.loop && (v = i + e < 0 ? a2[a2.length - 1] : i + e === a2.length ? a2[0] : a2[i + e]), v && m2.setState("value", v.getAttribute(S));
  }
  function Z(e) {
    let s = k2(), a2 = s == null ? void 0 : s.closest(O), i;
    for (; a2 && !i; ) a2 = e > 0 ? ye(a2, O) : xe(a2, O), i = a2 == null ? void 0 : a2.querySelector(ae);
    i ? m2.setState("value", i.getAttribute(S)) : z(e);
  }
  let ee = () => q(H2().length - 1), te = (e) => {
    e.preventDefault(), e.metaKey ? ee() : e.altKey ? Z(1) : z(1);
  }, ne = (e) => {
    e.preventDefault(), e.metaKey ? q(0) : e.altKey ? Z(-1) : z(-1);
  };
  return t.createElement("div", { ref: _([n, c]), ...P, "cmdk-root": "", onKeyDown: (e) => {
    var s;
    if ((s = P.onKeyDown) == null || s.call(P, e), !e.defaultPrevented) switch (e.key) {
      case "n":
      case "j": {
        F && e.ctrlKey && te(e);
        break;
      }
      case "ArrowDown": {
        te(e);
        break;
      }
      case "p":
      case "k": {
        F && e.ctrlKey && ne(e);
        break;
      }
      case "ArrowUp": {
        ne(e);
        break;
      }
      case "Home": {
        e.preventDefault(), q(0);
        break;
      }
      case "End": {
        e.preventDefault(), ee();
        break;
      }
      case "Enter":
        if (!e.nativeEvent.isComposing) {
          e.preventDefault();
          let a2 = k2();
          if (a2) {
            let i = new Event(B);
            a2.dispatchEvent(i);
          }
        }
    }
  } }, t.createElement("label", { "cmdk-label": "", htmlFor: M.inputId, id: M.labelId, style: Te }, b), t.createElement(ie.Provider, { value: m2 }, t.createElement(se.Provider, { value: M }, p2)));
}), ve = t.forwardRef((r2, c) => {
  var V, E;
  let n = t.useId(), o = t.useRef(null), l = t.useContext(ce), d = A(), f = ue(r2), g = (E = (V = f.current) == null ? void 0 : V.forceMount) != null ? E : l == null ? void 0 : l.forceMount;
  D(() => d.item(n, l == null ? void 0 : l.id), []);
  let u2 = de(n, o, [r2.value, r2.children, o]), b = J(), p2 = L((m2) => m2.value && m2.value === u2.current), R = L((m2) => g || d.filter() === false ? true : m2.search ? m2.filtered.items.get(n) > 0 : true);
  t.useEffect(() => {
    let m2 = o.current;
    if (!(!m2 || r2.disabled)) return m2.addEventListener(B, T), () => m2.removeEventListener(B, T);
  }, [R, r2.onSelect, r2.disabled]);
  function T() {
    var m2, M;
    I(), (M = (m2 = f.current).onSelect) == null || M.call(m2, u2.current);
  }
  function I() {
    b.setState("value", u2.current, true);
  }
  if (!R) return null;
  let { disabled: C, value: F, onSelect: P, forceMount: Q, ...K2 } = r2;
  return t.createElement("div", { ref: _([o, c]), ...K2, id: n, "cmdk-item": "", role: "option", "aria-disabled": C || void 0, "aria-selected": p2 || void 0, "data-disabled": C || void 0, "data-selected": p2 || void 0, onPointerMove: C ? void 0 : I, onClick: C ? void 0 : T }, r2.children);
}), ge = t.forwardRef((r2, c) => {
  let { heading: n, children: o, forceMount: l, ...d } = r2, f = t.useId(), g = t.useRef(null), u2 = t.useRef(null), b = t.useId(), p2 = A(), R = L((C) => l || p2.filter() === false ? true : C.search ? C.filtered.groups.has(f) : true);
  D(() => p2.group(f), []), de(f, g, [r2.value, r2.heading, u2]);
  let T = t.useMemo(() => ({ id: f, forceMount: l }), [l]), I = t.createElement(ce.Provider, { value: T }, o);
  return t.createElement("div", { ref: _([g, c]), ...d, "cmdk-group": "", role: "presentation", hidden: R ? void 0 : true }, n && t.createElement("div", { ref: u2, "cmdk-group-heading": "", "aria-hidden": true, id: b }, n), t.createElement("div", { "cmdk-group-items": "", role: "group", "aria-labelledby": n ? b : void 0 }, I));
}), Re = t.forwardRef((r2, c) => {
  let { alwaysRender: n, ...o } = r2, l = t.useRef(null), d = L((f) => !f.search);
  return !n && !d ? null : t.createElement("div", { ref: _([l, c]), ...o, "cmdk-separator": "", role: "separator" });
}), be = t.forwardRef((r2, c) => {
  let { onValueChange: n, ...o } = r2, l = r2.value != null, d = J(), f = L((p2) => p2.search), g = L((p2) => p2.value), u2 = A(), b = t.useMemo(() => {
    var R;
    let p2 = (R = u2.commandRef.current) == null ? void 0 : R.querySelector(`${W}[${S}="${g}"]`);
    return p2 == null ? void 0 : p2.getAttribute("id");
  }, [g, u2.commandRef]);
  return t.useEffect(() => {
    r2.value != null && d.setState("search", r2.value);
  }, [r2.value]), t.createElement("input", { ref: c, ...o, "cmdk-input": "", autoComplete: "off", autoCorrect: "off", spellCheck: false, "aria-autocomplete": "list", role: "combobox", "aria-expanded": true, "aria-controls": u2.listId, "aria-labelledby": u2.labelId, "aria-activedescendant": b, id: u2.inputId, type: "text", value: l ? r2.value : f, onChange: (p2) => {
    l || d.setState("search", p2.target.value), n == null || n(p2.target.value);
  } });
}), he = t.forwardRef((r2, c) => {
  let { children: n, ...o } = r2, l = t.useRef(null), d = t.useRef(null), f = A();
  return t.useEffect(() => {
    if (d.current && l.current) {
      let g = d.current, u2 = l.current, b, p2 = new ResizeObserver(() => {
        b = requestAnimationFrame(() => {
          let R = g.offsetHeight;
          u2.style.setProperty("--cmdk-list-height", R.toFixed(1) + "px");
        });
      });
      return p2.observe(g), () => {
        cancelAnimationFrame(b), p2.unobserve(g);
      };
    }
  }, []), t.createElement("div", { ref: _([l, c]), ...o, "cmdk-list": "", role: "listbox", "aria-label": "Suggestions", id: f.listId, "aria-labelledby": f.inputId }, t.createElement("div", { ref: d, "cmdk-list-sizer": "" }, n));
}), Ee = t.forwardRef((r2, c) => {
  let { open: n, onOpenChange: o, overlayClassName: l, contentClassName: d, container: f, ...g } = r2;
  return t.createElement($5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9, { open: n, onOpenChange: o }, t.createElement($5d3850c4d0b4e6c7$export$602eac185826482c, { container: f }, t.createElement($5d3850c4d0b4e6c7$export$c6fdb837b070b4ff, { "cmdk-overlay": "", className: l }), t.createElement($5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2, { "aria-label": r2.label, "cmdk-dialog": "", className: d }, t.createElement(le, { ref: c, ...g }))));
}), Se = t.forwardRef((r2, c) => {
  let n = t.useRef(true), o = L((l) => l.filtered.count === 0);
  return t.useEffect(() => {
    n.current = false;
  }, []), n.current || !o ? null : t.createElement("div", { ref: c, ...r2, "cmdk-empty": "", role: "presentation" });
}), Ce = t.forwardRef((r2, c) => {
  let { progress: n, children: o, ...l } = r2;
  return t.createElement("div", { ref: c, ...l, "cmdk-loading": "", role: "progressbar", "aria-valuenow": n, "aria-valuemin": 0, "aria-valuemax": 100, "aria-label": "Loading..." }, t.createElement("div", { "aria-hidden": true }, o));
}), we = Object.assign(le, { List: he, Item: ve, Input: be, Group: ge, Separator: Re, Dialog: Ee, Empty: Se, Loading: Ce });
function ye(r2, c) {
  let n = r2.nextElementSibling;
  for (; n; ) {
    if (n.matches(c)) return n;
    n = n.nextElementSibling;
  }
}
function xe(r2, c) {
  let n = r2.previousElementSibling;
  for (; n; ) {
    if (n.matches(c)) return n;
    n = n.previousElementSibling;
  }
}
function ue(r2) {
  let c = t.useRef(r2);
  return D(() => {
    c.current = r2;
  }), c;
}
var D = typeof window == "undefined" ? t.useEffect : t.useLayoutEffect;
function w(r2) {
  let c = t.useRef();
  return c.current === void 0 && (c.current = r2()), c;
}
function _(r2) {
  return (c) => {
    r2.forEach((n) => {
      typeof n == "function" ? n(c) : n != null && (n.current = c);
    });
  };
}
function L(r2) {
  let c = J(), n = () => r2(c.snapshot());
  return t.useSyncExternalStore(c.subscribe, n, n);
}
function de(r2, c, n) {
  let o = t.useRef(), l = A();
  return D(() => {
    var f;
    let d = (() => {
      var g;
      for (let u2 of n) {
        if (typeof u2 == "string") return u2.trim().toLowerCase();
        if (typeof u2 == "object" && "current" in u2) return u2.current ? (g = u2.current.textContent) == null ? void 0 : g.trim().toLowerCase() : o.current;
      }
    })();
    l.value(r2, d), (f = c.current) == null || f.setAttribute(S, d), o.current = d;
  }), o;
}
var Le = () => {
  let [r2, c] = t.useState(), n = w(() => /* @__PURE__ */ new Map());
  return D(() => {
    n.current.forEach((o) => o()), n.current = /* @__PURE__ */ new Map();
  }, [r2]), (o, l) => {
    n.current.set(o, l), c({});
  };
}, Te = { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0" };
const React$6 = await importShared("react");
var NAME = "Separator";
var DEFAULT_ORIENTATION = "horizontal";
var ORIENTATIONS = ["horizontal", "vertical"];
var Separator$1 = React$6.forwardRef((props, forwardedRef) => {
  const { decorative, orientation: orientationProp = DEFAULT_ORIENTATION, ...domProps } = props;
  const orientation = isValidOrientation(orientationProp) ? orientationProp : DEFAULT_ORIENTATION;
  const ariaOrientation = orientation === "vertical" ? orientation : void 0;
  const semanticProps = decorative ? { role: "none" } : { "aria-orientation": ariaOrientation, role: "separator" };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "data-orientation": orientation,
      ...semanticProps,
      ...domProps,
      ref: forwardedRef
    }
  );
});
Separator$1.displayName = NAME;
function isValidOrientation(orientation) {
  return ORIENTATIONS.includes(orientation);
}
var Root$1 = Separator$1;
const React2 = await importShared("react");
const React$5 = await importShared("react");
var RADIO_NAME = "Radio";
var [createRadioContext, createRadioScope] = createContextScope(RADIO_NAME);
var [RadioProvider, useRadioContext] = createRadioContext(RADIO_NAME);
var Radio = React$5.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRadio,
      name,
      checked = false,
      required,
      disabled,
      value = "on",
      onCheck,
      form,
      ...radioProps
    } = props;
    const [button, setButton] = React$5.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = React$5.useRef(false);
    const isFormControl = button ? form || !!button.closest("form") : true;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(RadioProvider, { scope: __scopeRadio, checked, disabled, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          role: "radio",
          "aria-checked": checked,
          "data-state": getState(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...radioProps,
          ref: composedRefs,
          onClick: composeEventHandlers(props.onClick, (event) => {
            if (!checked) onCheck?.();
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        BubbleInput$1,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name,
          value,
          checked,
          required,
          disabled,
          form,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Radio.displayName = RADIO_NAME;
var INDICATOR_NAME = "RadioIndicator";
var RadioIndicator = React$5.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadio, forceMount, ...indicatorProps } = props;
    const context = useRadioContext(INDICATOR_NAME, __scopeRadio);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-state": getState(context.checked),
        "data-disabled": context.disabled ? "" : void 0,
        ...indicatorProps,
        ref: forwardedRef
      }
    ) });
  }
);
RadioIndicator.displayName = INDICATOR_NAME;
var BubbleInput$1 = (props) => {
  const { control, checked, bubbles = true, ...inputProps } = props;
  const ref = React$5.useRef(null);
  const prevChecked = usePrevious(checked);
  const controlSize = useSize(control);
  React$5.useEffect(() => {
    const input = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      setChecked.call(input, checked);
      input.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "radio",
      "aria-hidden": true,
      defaultChecked: checked,
      ...inputProps,
      tabIndex: -1,
      ref,
      style: {
        ...props.style,
        ...controlSize,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }
  );
};
function getState(checked) {
  return checked ? "checked" : "unchecked";
}
var ARROW_KEYS$1 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var RADIO_GROUP_NAME = "RadioGroup";
var [createRadioGroupContext, createRadioGroupScope] = createContextScope(RADIO_GROUP_NAME, [
  createRovingFocusGroupScope,
  createRadioScope
]);
var useRovingFocusGroupScope$1 = createRovingFocusGroupScope();
var useRadioScope = createRadioScope();
var [RadioGroupProvider, useRadioGroupContext] = createRadioGroupContext(RADIO_GROUP_NAME);
var RadioGroup$1 = React2.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRadioGroup,
      name,
      defaultValue,
      value: valueProp,
      required = false,
      disabled = false,
      orientation,
      dir,
      loop = true,
      onValueChange,
      ...groupProps
    } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope$1(__scopeRadioGroup);
    const direction = useDirection(dir);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      defaultProp: defaultValue,
      onChange: onValueChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      RadioGroupProvider,
      {
        scope: __scopeRadioGroup,
        name,
        required,
        disabled,
        value,
        onValueChange: setValue,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$2,
          {
            asChild: true,
            ...rovingFocusGroupScope,
            orientation,
            dir: direction,
            loop,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                role: "radiogroup",
                "aria-required": required,
                "aria-orientation": orientation,
                "data-disabled": disabled ? "" : void 0,
                dir: direction,
                ...groupProps,
                ref: forwardedRef
              }
            )
          }
        )
      }
    );
  }
);
RadioGroup$1.displayName = RADIO_GROUP_NAME;
var ITEM_NAME$1 = "RadioGroupItem";
var RadioGroupItem$1 = React2.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadioGroup, disabled, ...itemProps } = props;
    const context = useRadioGroupContext(ITEM_NAME$1, __scopeRadioGroup);
    const isDisabled = context.disabled || disabled;
    const rovingFocusGroupScope = useRovingFocusGroupScope$1(__scopeRadioGroup);
    const radioScope = useRadioScope(__scopeRadioGroup);
    const ref = React2.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const checked = context.value === itemProps.value;
    const isArrowKeyPressedRef = React2.useRef(false);
    React2.useEffect(() => {
      const handleKeyDown = (event) => {
        if (ARROW_KEYS$1.includes(event.key)) {
          isArrowKeyPressedRef.current = true;
        }
      };
      const handleKeyUp = () => isArrowKeyPressedRef.current = false;
      document.addEventListener("keydown", handleKeyDown);
      document.addEventListener("keyup", handleKeyUp);
      return () => {
        document.removeEventListener("keydown", handleKeyDown);
        document.removeEventListener("keyup", handleKeyUp);
      };
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item$1,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !isDisabled,
        active: checked,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Radio,
          {
            disabled: isDisabled,
            required: context.required,
            checked,
            ...radioScope,
            ...itemProps,
            name: context.name,
            ref: composedRefs,
            onCheck: () => context.onValueChange(itemProps.value),
            onKeyDown: composeEventHandlers((event) => {
              if (event.key === "Enter") event.preventDefault();
            }),
            onFocus: composeEventHandlers(itemProps.onFocus, () => {
              if (isArrowKeyPressedRef.current) ref.current?.click();
            })
          }
        )
      }
    );
  }
);
RadioGroupItem$1.displayName = ITEM_NAME$1;
var INDICATOR_NAME2 = "RadioGroupIndicator";
var RadioGroupIndicator = React2.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadioGroup, ...indicatorProps } = props;
    const radioScope = useRadioScope(__scopeRadioGroup);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioIndicator, { ...radioScope, ...indicatorProps, ref: forwardedRef });
  }
);
RadioGroupIndicator.displayName = INDICATOR_NAME2;
var Root2$2 = RadioGroup$1;
var Item2 = RadioGroupItem$1;
var Indicator = RadioGroupIndicator;
function clamp(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
const React$4 = await importShared("react");
const ReactDOM$1 = await importShared("react-dom");
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS = [" ", "Enter"];
var SELECT_NAME = "Select";
var [Collection$1, useCollection$1, createCollectionScope$1] = createCollection(SELECT_NAME);
var [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
  createCollectionScope$1,
  createPopperScope
]);
var usePopperScope$1 = createPopperScope();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select$1 = (props) => {
  const {
    __scopeSelect,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue,
    onValueChange,
    dir,
    name,
    autoComplete,
    disabled,
    required,
    form
  } = props;
  const popperScope = usePopperScope$1(__scopeSelect);
  const [trigger, setTrigger] = React$4.useState(null);
  const [valueNode, setValueNode] = React$4.useState(null);
  const [valueNodeHasChildren, setValueNodeHasChildren] = React$4.useState(false);
  const direction = useDirection(dir);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange
  });
  const triggerPointerDownPosRef = React$4.useRef(null);
  const isFormControl = trigger ? form || !!trigger.closest("form") : true;
  const [nativeOptionsSet, setNativeOptionsSet] = React$4.useState(/* @__PURE__ */ new Set());
  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    SelectProvider,
    {
      required,
      scope: __scopeSelect,
      trigger,
      onTriggerChange: setTrigger,
      valueNode,
      onValueNodeChange: setValueNode,
      valueNodeHasChildren,
      onValueNodeHasChildrenChange: setValueNodeHasChildren,
      contentId: useId(),
      value,
      onValueChange: setValue,
      open,
      onOpenChange: setOpen,
      dir: direction,
      triggerPointerDownPosRef,
      disabled,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Provider, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectNativeOptionsProvider,
          {
            scope: props.__scopeSelect,
            onNativeOptionAdd: React$4.useCallback((option) => {
              setNativeOptionsSet((prev) => new Set(prev).add(option));
            }, []),
            onNativeOptionRemove: React$4.useCallback((option) => {
              setNativeOptionsSet((prev) => {
                const optionsSet = new Set(prev);
                optionsSet.delete(option);
                return optionsSet;
              });
            }, []),
            children
          }
        ) }),
        isFormControl ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          BubbleSelect,
          {
            "aria-hidden": true,
            required,
            tabIndex: -1,
            name,
            autoComplete,
            value,
            onChange: (event) => setValue(event.target.value),
            disabled,
            form,
            children: [
              value === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "" }) : null,
              Array.from(nativeOptionsSet)
            ]
          },
          nativeSelectKey
        ) : null
      ]
    }
  ) });
};
Select$1.displayName = SELECT_NAME;
var TRIGGER_NAME$2 = "SelectTrigger";
var SelectTrigger = React$4.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, disabled = false, ...triggerProps } = props;
    const popperScope = usePopperScope$1(__scopeSelect);
    const context = useSelectContext(TRIGGER_NAME$2, __scopeSelect);
    const isDisabled = context.disabled || disabled;
    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);
    const getItems = useCollection$1(__scopeSelect);
    const pointerTypeRef = React$4.useRef("touch");
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.value === context.value);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem !== void 0) {
        context.onValueChange(nextItem.value);
      }
    });
    const handleOpen = (pointerEvent) => {
      if (!isDisabled) {
        context.onOpenChange(true);
        resetTypeahead();
      }
      if (pointerEvent) {
        context.triggerPointerDownPosRef.current = {
          x: Math.round(pointerEvent.pageX),
          y: Math.round(pointerEvent.pageY)
        };
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": context.contentId,
        "aria-expanded": context.open,
        "aria-required": context.required,
        "aria-autocomplete": "none",
        dir: context.dir,
        "data-state": context.open ? "open" : "closed",
        disabled: isDisabled,
        "data-disabled": isDisabled ? "" : void 0,
        "data-placeholder": shouldShowPlaceholder(context.value) ? "" : void 0,
        ...triggerProps,
        ref: composedRefs,
        onClick: composeEventHandlers(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
          if (pointerTypeRef.current !== "mouse") {
            handleOpen(event);
          }
        }),
        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {
          pointerTypeRef.current = event.pointerType;
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
          }
          if (event.button === 0 && event.ctrlKey === false && event.pointerType === "mouse") {
            handleOpen(event);
            event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== "";
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === " ") return;
          if (OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
SelectTrigger.displayName = TRIGGER_NAME$2;
var VALUE_NAME = "SelectValue";
var SelectValue = React$4.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, children, placeholder = "", ...valueProps } = props;
    const context = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context;
    const hasChildren = children !== void 0;
    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);
    useLayoutEffect2(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [onValueNodeHasChildrenChange, hasChildren]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...valueProps,
        ref: composedRefs,
        style: { pointerEvents: "none" },
        children: shouldShowPlaceholder(context.value) ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: placeholder }) : children
      }
    );
  }
);
SelectValue.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = React$4.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, children, ...iconProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "▼" });
  }
);
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME$1 = "SelectPortal";
var SelectPortal = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$5, { asChild: true, ...props });
};
SelectPortal.displayName = PORTAL_NAME$1;
var CONTENT_NAME$2 = "SelectContent";
var SelectContent = React$4.forwardRef(
  (props, forwardedRef) => {
    const context = useSelectContext(CONTENT_NAME$2, props.__scopeSelect);
    const [fragment, setFragment] = React$4.useState();
    useLayoutEffect2(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context.open) {
      const frag = fragment;
      return frag ? ReactDOM$1.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentProvider, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Slot, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: props.children }) }) }),
        frag
      ) : null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentImpl, { ...props, ref: forwardedRef });
  }
);
SelectContent.displayName = CONTENT_NAME$2;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME$2);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var SelectContentImpl = React$4.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      position = "item-aligned",
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      //
      // PopperContent props
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions,
      //
      ...contentProps
    } = props;
    const context = useSelectContext(CONTENT_NAME$2, __scopeSelect);
    const [content, setContent] = React$4.useState(null);
    const [viewport, setViewport] = React$4.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [selectedItem, setSelectedItem] = React$4.useState(null);
    const [selectedItemText, setSelectedItemText] = React$4.useState(
      null
    );
    const getItems = useCollection$1(__scopeSelect);
    const [isPositioned, setIsPositioned] = React$4.useState(false);
    const firstValidItemFoundRef = React$4.useRef(false);
    React$4.useEffect(() => {
      if (content) return hideOthers(content);
    }, [content]);
    useFocusGuards();
    const focusFirst2 = React$4.useCallback(
      (candidates) => {
        const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
          candidate?.scrollIntoView({ block: "nearest" });
          if (candidate === firstItem && viewport) viewport.scrollTop = 0;
          if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;
          candidate?.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
        }
      },
      [getItems, viewport]
    );
    const focusSelectedItem = React$4.useCallback(
      () => focusFirst2([selectedItem, content]),
      [focusFirst2, selectedItem, content]
    );
    React$4.useEffect(() => {
      if (isPositioned) {
        focusSelectedItem();
      }
    }, [isPositioned, focusSelectedItem]);
    const { onOpenChange, triggerPointerDownPosRef } = context;
    React$4.useEffect(() => {
      if (content) {
        let pointerMoveDelta = { x: 0, y: 0 };
        const handlePointerMove = (event) => {
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - (triggerPointerDownPosRef.current?.x ?? 0)),
            y: Math.abs(Math.round(event.pageY) - (triggerPointerDownPosRef.current?.y ?? 0))
          };
        };
        const handlePointerUp = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
            event.preventDefault();
          } else {
            if (!content.contains(event.target)) {
              onOpenChange(false);
            }
          }
          document.removeEventListener("pointermove", handlePointerMove);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener("pointermove", handlePointerMove);
          document.addEventListener("pointerup", handlePointerUp, { capture: true, once: true });
        }
        return () => {
          document.removeEventListener("pointermove", handlePointerMove);
          document.removeEventListener("pointerup", handlePointerUp, { capture: true });
        };
      }
    }, [content, onOpenChange, triggerPointerDownPosRef]);
    React$4.useEffect(() => {
      const close = () => onOpenChange(false);
      window.addEventListener("blur", close);
      window.addEventListener("resize", close);
      return () => {
        window.removeEventListener("blur", close);
        window.removeEventListener("resize", close);
      };
    }, [onOpenChange]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem) {
        setTimeout(() => nextItem.ref.current.focus());
      }
    });
    const itemRefCallback = React$4.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node);
          if (isFirstValidItem) firstValidItemFoundRef.current = true;
        }
      },
      [context.value]
    );
    const handleItemLeave = React$4.useCallback(() => content?.focus(), [content]);
    const itemTextRefCallback = React$4.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItemText(node);
        }
      },
      [context.value]
    );
    const SelectPosition = position === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === SelectPopperPosition ? {
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } : {};
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectContentProvider,
      {
        scope: __scopeSelect,
        content,
        viewport,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position,
        isPositioned,
        searchRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll$1, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope,
          {
            asChild: true,
            trapped: context.open,
            onMountAutoFocus: (event) => {
              event.preventDefault();
            },
            onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {
              context.trigger?.focus({ preventScroll: true });
              event.preventDefault();
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents: true,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside: (event) => event.preventDefault(),
                onDismiss: () => context.onOpenChange(false),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SelectPosition,
                  {
                    role: "listbox",
                    id: context.contentId,
                    "data-state": context.open ? "open" : "closed",
                    dir: context.dir,
                    onContextMenu: (event) => event.preventDefault(),
                    ...contentProps,
                    ...popperContentProps,
                    onPlaced: () => setIsPositioned(true),
                    ref: composedRefs,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...contentProps.style
                    },
                    onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                      if (event.key === "Tab") event.preventDefault();
                      if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                        const items = getItems().filter((item) => !item.disabled);
                        let candidateNodes = items.map((item) => item.ref.current);
                        if (["ArrowUp", "End"].includes(event.key)) {
                          candidateNodes = candidateNodes.slice().reverse();
                        }
                        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                          const currentElement = event.target;
                          const currentIndex = candidateNodes.indexOf(currentElement);
                          candidateNodes = candidateNodes.slice(currentIndex + 1);
                        }
                        setTimeout(() => focusFirst2(candidateNodes));
                        event.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = React$4.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onPlaced, ...popperProps } = props;
  const context = useSelectContext(CONTENT_NAME$2, __scopeSelect);
  const contentContext = useSelectContentContext(CONTENT_NAME$2, __scopeSelect);
  const [contentWrapper, setContentWrapper] = React$4.useState(null);
  const [content, setContent] = React$4.useState(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
  const getItems = useCollection$1(__scopeSelect);
  const shouldExpandOnScrollRef = React$4.useRef(false);
  const shouldRepositionRef = React$4.useRef(true);
  const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
  const position = React$4.useCallback(() => {
    if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {
      const triggerRect = context.trigger.getBoundingClientRect();
      const contentRect = content.getBoundingClientRect();
      const valueNodeRect = context.valueNode.getBoundingClientRect();
      const itemTextRect = selectedItemText.getBoundingClientRect();
      if (context.dir !== "rtl") {
        const itemTextOffset = itemTextRect.left - contentRect.left;
        const left = valueNodeRect.left - itemTextOffset;
        const leftDelta = triggerRect.left - left;
        const minContentWidth = triggerRect.width + leftDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const rightEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedLeft = clamp(left, [
          CONTENT_MARGIN,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(CONTENT_MARGIN, rightEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.left = clampedLeft + "px";
      } else {
        const itemTextOffset = contentRect.right - itemTextRect.right;
        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
        const rightDelta = window.innerWidth - triggerRect.right - right;
        const minContentWidth = triggerRect.width + rightDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const leftEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedRight = clamp(right, [
          CONTENT_MARGIN,
          Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.right = clampedRight + "px";
      }
      const items = getItems();
      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
      const itemsHeight = viewport.scrollHeight;
      const contentStyles = window.getComputedStyle(content);
      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
      const viewportStyles = window.getComputedStyle(viewport);
      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
      if (willAlignWithoutTopOverflow) {
        const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;
        contentWrapper.style.bottom = "0px";
        const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;
        const clampedTriggerMiddleToBottomEdge = Math.max(
          triggerMiddleToBottomEdge,
          selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
        );
        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
        contentWrapper.style.height = height + "px";
      } else {
        const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;
        contentWrapper.style.top = "0px";
        const clampedTopEdgeToTriggerMiddle = Math.max(
          topEdgeToTriggerMiddle,
          contentBorderTopWidth + viewport.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
        );
        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
        contentWrapper.style.height = height + "px";
        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
      }
      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
      contentWrapper.style.minHeight = minContentHeight + "px";
      contentWrapper.style.maxHeight = availableHeight + "px";
      onPlaced?.();
      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
    }
  }, [
    getItems,
    context.trigger,
    context.valueNode,
    contentWrapper,
    content,
    viewport,
    selectedItem,
    selectedItemText,
    context.dir,
    onPlaced
  ]);
  useLayoutEffect2(() => position(), [position]);
  const [contentZIndex, setContentZIndex] = React$4.useState();
  useLayoutEffect2(() => {
    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [content]);
  const handleScrollButtonChange = React$4.useCallback(
    (node) => {
      if (node && shouldRepositionRef.current === true) {
        position();
        focusSelectedItem?.();
        shouldRepositionRef.current = false;
      }
    },
    [position, focusSelectedItem]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectViewportProvider,
    {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          ref: setContentWrapper,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: contentZIndex
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.div,
            {
              ...popperProps,
              ref: composedRefs,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...popperProps.style
              }
            }
          )
        }
      )
    }
  );
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = React$4.forwardRef((props, forwardedRef) => {
  const {
    __scopeSelect,
    align = "start",
    collisionPadding = CONTENT_MARGIN,
    ...popperProps
  } = props;
  const popperScope = usePopperScope$1(__scopeSelect);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content,
    {
      ...popperScope,
      ...popperProps,
      ref: forwardedRef,
      align,
      collisionPadding,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...popperProps.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME$2, {});
var VIEWPORT_NAME = "SelectViewport";
var SelectViewport = React$4.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, nonce, ...viewportProps } = props;
    const contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect);
    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = React$4.useRef(0);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Slot, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...viewportProps,
          ref: composedRefs,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...viewportProps.style
          },
          onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {
            const viewport = event.currentTarget;
            const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
            if (shouldExpandOnScrollRef?.current && contentWrapper) {
              const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
              if (scrolledBy > 0) {
                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                const cssHeight = parseFloat(contentWrapper.style.height);
                const prevHeight = Math.max(cssMinHeight, cssHeight);
                if (prevHeight < availableHeight) {
                  const nextHeight = prevHeight + scrolledBy;
                  const clampedNextHeight = Math.min(availableHeight, nextHeight);
                  const heightDiff = nextHeight - clampedNextHeight;
                  contentWrapper.style.height = clampedNextHeight + "px";
                  if (contentWrapper.style.bottom === "0px") {
                    viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                    contentWrapper.style.justifyContent = "flex-end";
                  }
                }
              }
            }
            prevScrollTopRef.current = viewport.scrollTop;
          })
        }
      ) })
    ] });
  }
);
SelectViewport.displayName = VIEWPORT_NAME;
var GROUP_NAME = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME);
var SelectGroup$1 = React$4.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props;
    const groupId = useId();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
  }
);
SelectGroup$1.displayName = GROUP_NAME;
var LABEL_NAME = "SelectLabel";
var SelectLabel = React$4.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props;
    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
  }
);
SelectLabel.displayName = LABEL_NAME;
var ITEM_NAME = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME);
var SelectItem$1 = React$4.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      value,
      disabled = false,
      textValue: textValueProp,
      ...itemProps
    } = props;
    const context = useSelectContext(ITEM_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect);
    const isSelected = context.value === value;
    const [textValue, setTextValue] = React$4.useState(textValueProp ?? "");
    const [isFocused, setIsFocused] = React$4.useState(false);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => contentContext.itemRefCallback?.(node, value, disabled)
    );
    const textId = useId();
    const pointerTypeRef = React$4.useRef("touch");
    const handleSelect = () => {
      if (!disabled) {
        context.onValueChange(value);
        context.onOpenChange(false);
      }
    };
    if (value === "") {
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectItemContextProvider,
      {
        scope: __scopeSelect,
        value,
        disabled,
        textId,
        isSelected,
        onItemTextChange: React$4.useCallback((node) => {
          setTextValue((prevTextValue) => prevTextValue || (node?.textContent ?? "").trim());
        }, []),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Collection$1.ItemSlot,
          {
            scope: __scopeSelect,
            value,
            disabled,
            textValue,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                role: "option",
                "aria-labelledby": textId,
                "data-highlighted": isFocused ? "" : void 0,
                "aria-selected": isSelected && isFocused,
                "data-state": isSelected ? "checked" : "unchecked",
                "aria-disabled": disabled || void 0,
                "data-disabled": disabled ? "" : void 0,
                tabIndex: disabled ? void 0 : -1,
                ...itemProps,
                ref: composedRefs,
                onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),
                onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),
                onClick: composeEventHandlers(itemProps.onClick, () => {
                  if (pointerTypeRef.current !== "mouse") handleSelect();
                }),
                onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {
                  if (pointerTypeRef.current === "mouse") handleSelect();
                }),
                onPointerDown: composeEventHandlers(itemProps.onPointerDown, (event) => {
                  pointerTypeRef.current = event.pointerType;
                }),
                onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {
                  pointerTypeRef.current = event.pointerType;
                  if (disabled) {
                    contentContext.onItemLeave?.();
                  } else if (pointerTypeRef.current === "mouse") {
                    event.currentTarget.focus({ preventScroll: true });
                  }
                }),
                onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {
                  if (event.currentTarget === document.activeElement) {
                    contentContext.onItemLeave?.();
                  }
                }),
                onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {
                  const isTypingAhead = contentContext.searchRef?.current !== "";
                  if (isTypingAhead && event.key === " ") return;
                  if (SELECTION_KEYS.includes(event.key)) handleSelect();
                  if (event.key === " ") event.preventDefault();
                })
              }
            )
          }
        )
      }
    );
  }
);
SelectItem$1.displayName = ITEM_NAME;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = React$4.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, ...itemTextProps } = props;
    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = React$4.useState(null);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => setItemTextNode(node),
      itemContext.onItemTextChange,
      (node) => contentContext.itemTextRefCallback?.(node, itemContext.value, itemContext.disabled)
    );
    const textContent = itemTextNode?.textContent;
    const nativeOption = React$4.useMemo(
      () => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
      [itemContext.disabled, itemContext.value, textContent]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    useLayoutEffect2(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
      itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? ReactDOM$1.createPortal(itemTextProps.children, context.valueNode) : null
    ] });
  }
);
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME = "SelectItemIndicator";
var SelectItemIndicator = React$4.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);
    return itemContext.isSelected ? /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
  }
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton = React$4.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const [canScrollUp, setCanScrollUp] = React$4.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const canScrollUp2 = viewport.scrollTop > 0;
        setCanScrollUp(canScrollUp2);
      };
      const viewport = contentContext.viewport;
      handleScroll2();
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollUp ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton = React$4.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const [canScrollDown, setCanScrollDown] = React$4.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const maxScroll = viewport.scrollHeight - viewport.clientHeight;
        const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;
        setCanScrollDown(canScrollDown2);
      };
      const viewport = contentContext.viewport;
      handleScroll2();
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollDown ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = React$4.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
  const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
  const autoScrollTimerRef = React$4.useRef(null);
  const getItems = useCollection$1(__scopeSelect);
  const clearAutoScrollTimer = React$4.useCallback(() => {
    if (autoScrollTimerRef.current !== null) {
      window.clearInterval(autoScrollTimerRef.current);
      autoScrollTimerRef.current = null;
    }
  }, []);
  React$4.useEffect(() => {
    return () => clearAutoScrollTimer();
  }, [clearAutoScrollTimer]);
  useLayoutEffect2(() => {
    const activeItem = getItems().find((item) => item.ref.current === document.activeElement);
    activeItem?.ref.current?.scrollIntoView({ block: "nearest" });
  }, [getItems]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "aria-hidden": true,
      ...scrollIndicatorProps,
      ref: forwardedRef,
      style: { flexShrink: 0, ...scrollIndicatorProps.style },
      onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
        contentContext.onItemLeave?.();
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      })
    }
  );
});
var SEPARATOR_NAME = "SelectSeparator";
var SelectSeparator = React$4.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...separatorProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
  }
);
SelectSeparator.displayName = SEPARATOR_NAME;
var ARROW_NAME$1 = "SelectArrow";
var SelectArrow = React$4.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...arrowProps } = props;
    const popperScope = usePopperScope$1(__scopeSelect);
    const context = useSelectContext(ARROW_NAME$1, __scopeSelect);
    const contentContext = useSelectContentContext(ARROW_NAME$1, __scopeSelect);
    return context.open && contentContext.position === "popper" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
  }
);
SelectArrow.displayName = ARROW_NAME$1;
function shouldShowPlaceholder(value) {
  return value === "" || value === void 0;
}
var BubbleSelect = React$4.forwardRef(
  (props, forwardedRef) => {
    const { value, ...selectProps } = props;
    const ref = React$4.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const prevValue = usePrevious(value);
    React$4.useEffect(() => {
      const select = ref.current;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        selectProto,
        "value"
      );
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("change", { bubbles: true });
        setValue.call(select, value);
        select.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("select", { ...selectProps, ref: composedRefs, defaultValue: value }) });
  }
);
BubbleSelect.displayName = "BubbleSelect";
function useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = useCallbackRef$1(onSearchChange);
  const searchRef = React$4.useRef("");
  const timerRef = React$4.useRef(0);
  const handleTypeaheadSearch = React$4.useCallback(
    (key) => {
      const search = searchRef.current + key;
      handleSearchChange(search);
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
    },
    [handleSearchChange]
  );
  const resetTypeahead = React$4.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  React$4.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [searchRef, handleTypeaheadSearch, resetTypeahead];
}
function findNextItem(items, search, currentItem) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
  let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v) => v !== currentItem);
  const nextItem = wrappedItems.find(
    (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextItem !== currentItem ? nextItem : void 0;
}
function wrapArray(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
var Root2$1 = Select$1;
var Trigger$2 = SelectTrigger;
var Value = SelectValue;
var Icon$1 = SelectIcon;
var Portal$1 = SelectPortal;
var Content2$1 = SelectContent;
var Viewport = SelectViewport;
var Group = SelectGroup$1;
var Item = SelectItem$1;
var ItemText = SelectItemText;
const React$3 = await importShared("react");
var PAGE_KEYS = ["PageUp", "PageDown"];
var ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var BACK_KEYS = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
};
var SLIDER_NAME = "Slider";
var [Collection, useCollection, createCollectionScope] = createCollection(SLIDER_NAME);
var [createSliderContext, createSliderScope] = createContextScope(SLIDER_NAME, [
  createCollectionScope
]);
var [SliderProvider, useSliderContext] = createSliderContext(SLIDER_NAME);
var Slider$1 = React$3.forwardRef(
  (props, forwardedRef) => {
    const {
      name,
      min: min2 = 0,
      max: max2 = 100,
      step = 1,
      orientation = "horizontal",
      disabled = false,
      minStepsBetweenThumbs = 0,
      defaultValue = [min2],
      value,
      onValueChange = () => {
      },
      onValueCommit = () => {
      },
      inverted = false,
      form,
      ...sliderProps
    } = props;
    const thumbRefs = React$3.useRef(/* @__PURE__ */ new Set());
    const valueIndexToChangeRef = React$3.useRef(0);
    const isHorizontal = orientation === "horizontal";
    const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;
    const [values = [], setValues] = useControllableState({
      prop: value,
      defaultProp: defaultValue,
      onChange: (value2) => {
        const thumbs = [...thumbRefs.current];
        thumbs[valueIndexToChangeRef.current]?.focus();
        onValueChange(value2);
      }
    });
    const valuesBeforeSlideStartRef = React$3.useRef(values);
    function handleSlideStart(value2) {
      const closestIndex = getClosestValueIndex(values, value2);
      updateValues(value2, closestIndex);
    }
    function handleSlideMove(value2) {
      updateValues(value2, valueIndexToChangeRef.current);
    }
    function handleSlideEnd() {
      const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current];
      const nextValue = values[valueIndexToChangeRef.current];
      const hasChanged = nextValue !== prevValue;
      if (hasChanged) onValueCommit(values);
    }
    function updateValues(value2, atIndex, { commit } = { commit: false }) {
      const decimalCount = getDecimalCount(step);
      const snapToStep = roundValue(Math.round((value2 - min2) / step) * step + min2, decimalCount);
      const nextValue = clamp(snapToStep, [min2, max2]);
      setValues((prevValues = []) => {
        const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);
        if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {
          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);
          const hasChanged = String(nextValues) !== String(prevValues);
          if (hasChanged && commit) onValueCommit(nextValues);
          return hasChanged ? nextValues : prevValues;
        } else {
          return prevValues;
        }
      });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SliderProvider,
      {
        scope: props.__scopeSlider,
        name,
        disabled,
        min: min2,
        max: max2,
        valueIndexToChangeRef,
        thumbs: thumbRefs.current,
        values,
        orientation,
        form,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Provider, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SliderOrientation,
          {
            "aria-disabled": disabled,
            "data-disabled": disabled ? "" : void 0,
            ...sliderProps,
            ref: forwardedRef,
            onPointerDown: composeEventHandlers(sliderProps.onPointerDown, () => {
              if (!disabled) valuesBeforeSlideStartRef.current = values;
            }),
            min: min2,
            max: max2,
            inverted,
            onSlideStart: disabled ? void 0 : handleSlideStart,
            onSlideMove: disabled ? void 0 : handleSlideMove,
            onSlideEnd: disabled ? void 0 : handleSlideEnd,
            onHomeKeyDown: () => !disabled && updateValues(min2, 0, { commit: true }),
            onEndKeyDown: () => !disabled && updateValues(max2, values.length - 1, { commit: true }),
            onStepKeyDown: ({ event, direction: stepDirection }) => {
              if (!disabled) {
                const isPageKey = PAGE_KEYS.includes(event.key);
                const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.includes(event.key);
                const multiplier = isSkipKey ? 10 : 1;
                const atIndex = valueIndexToChangeRef.current;
                const value2 = values[atIndex];
                const stepInDirection = step * multiplier * stepDirection;
                updateValues(value2 + stepInDirection, atIndex, { commit: true });
              }
            }
          }
        ) }) })
      }
    );
  }
);
Slider$1.displayName = SLIDER_NAME;
var [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext(SLIDER_NAME, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
});
var SliderHorizontal = React$3.forwardRef(
  (props, forwardedRef) => {
    const {
      min: min2,
      max: max2,
      dir,
      inverted,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const [slider, setSlider] = React$3.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setSlider(node));
    const rectRef = React$3.useRef(void 0);
    const direction = useDirection(dir);
    const isDirectionLTR = direction === "ltr";
    const isSlidingFromLeft = isDirectionLTR && !inverted || !isDirectionLTR && inverted;
    function getValueFromPointer(pointerPosition) {
      const rect = rectRef.current || slider.getBoundingClientRect();
      const input = [0, rect.width];
      const output = isSlidingFromLeft ? [min2, max2] : [max2, min2];
      const value = linearScale(input, output);
      rectRef.current = rect;
      return value(pointerPosition - rect.left);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: isSlidingFromLeft ? "left" : "right",
        endEdge: isSlidingFromLeft ? "right" : "left",
        direction: isSlidingFromLeft ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SliderImpl,
          {
            dir: direction,
            "data-orientation": "horizontal",
            ...sliderProps,
            ref: composedRefs,
            style: {
              ...sliderProps.style,
              ["--radix-slider-thumb-transform"]: "translateX(-50%)"
            },
            onSlideStart: (event) => {
              const value = getValueFromPointer(event.clientX);
              onSlideStart?.(value);
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.clientX);
              onSlideMove?.(value);
            },
            onSlideEnd: () => {
              rectRef.current = void 0;
              onSlideEnd?.();
            },
            onStepKeyDown: (event) => {
              const slideDirection = isSlidingFromLeft ? "from-left" : "from-right";
              const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
              onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
var SliderVertical = React$3.forwardRef(
  (props, forwardedRef) => {
    const {
      min: min2,
      max: max2,
      inverted,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const sliderRef = React$3.useRef(null);
    const ref = useComposedRefs(forwardedRef, sliderRef);
    const rectRef = React$3.useRef(void 0);
    const isSlidingFromBottom = !inverted;
    function getValueFromPointer(pointerPosition) {
      const rect = rectRef.current || sliderRef.current.getBoundingClientRect();
      const input = [0, rect.height];
      const output = isSlidingFromBottom ? [max2, min2] : [min2, max2];
      const value = linearScale(input, output);
      rectRef.current = rect;
      return value(pointerPosition - rect.top);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: isSlidingFromBottom ? "bottom" : "top",
        endEdge: isSlidingFromBottom ? "top" : "bottom",
        size: "height",
        direction: isSlidingFromBottom ? 1 : -1,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SliderImpl,
          {
            "data-orientation": "vertical",
            ...sliderProps,
            ref,
            style: {
              ...sliderProps.style,
              ["--radix-slider-thumb-transform"]: "translateY(50%)"
            },
            onSlideStart: (event) => {
              const value = getValueFromPointer(event.clientY);
              onSlideStart?.(value);
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.clientY);
              onSlideMove?.(value);
            },
            onSlideEnd: () => {
              rectRef.current = void 0;
              onSlideEnd?.();
            },
            onStepKeyDown: (event) => {
              const slideDirection = isSlidingFromBottom ? "from-bottom" : "from-top";
              const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
              onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
var SliderImpl = React$3.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSlider,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onHomeKeyDown,
      onEndKeyDown,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const context = useSliderContext(SLIDER_NAME, __scopeSlider);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...sliderProps,
        ref: forwardedRef,
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (event.key === "Home") {
            onHomeKeyDown(event);
            event.preventDefault();
          } else if (event.key === "End") {
            onEndKeyDown(event);
            event.preventDefault();
          } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {
            onStepKeyDown(event);
            event.preventDefault();
          }
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          const target = event.target;
          target.setPointerCapture(event.pointerId);
          event.preventDefault();
          if (context.thumbs.has(target)) {
            target.focus();
          } else {
            onSlideStart(event);
          }
        }),
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) onSlideMove(event);
        }),
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
            onSlideEnd(event);
          }
        })
      }
    );
  }
);
var TRACK_NAME = "SliderTrack";
var SliderTrack = React$3.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...trackProps } = props;
    const context = useSliderContext(TRACK_NAME, __scopeSlider);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-disabled": context.disabled ? "" : void 0,
        "data-orientation": context.orientation,
        ...trackProps,
        ref: forwardedRef
      }
    );
  }
);
SliderTrack.displayName = TRACK_NAME;
var RANGE_NAME = "SliderRange";
var SliderRange = React$3.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...rangeProps } = props;
    const context = useSliderContext(RANGE_NAME, __scopeSlider);
    const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);
    const ref = React$3.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const valuesCount = context.values.length;
    const percentages = context.values.map(
      (value) => convertValueToPercentage(value, context.min, context.max)
    );
    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;
    const offsetEnd = 100 - Math.max(...percentages);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-orientation": context.orientation,
        "data-disabled": context.disabled ? "" : void 0,
        ...rangeProps,
        ref: composedRefs,
        style: {
          ...props.style,
          [orientation.startEdge]: offsetStart + "%",
          [orientation.endEdge]: offsetEnd + "%"
        }
      }
    );
  }
);
SliderRange.displayName = RANGE_NAME;
var THUMB_NAME = "SliderThumb";
var SliderThumb$1 = React$3.forwardRef(
  (props, forwardedRef) => {
    const getItems = useCollection(props.__scopeSlider);
    const [thumb, setThumb] = React$3.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));
    const index2 = React$3.useMemo(
      () => thumb ? getItems().findIndex((item) => item.ref.current === thumb) : -1,
      [getItems, thumb]
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderThumbImpl, { ...props, ref: composedRefs, index: index2 });
  }
);
var SliderThumbImpl = React$3.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, index: index2, name, ...thumbProps } = props;
    const context = useSliderContext(THUMB_NAME, __scopeSlider);
    const orientation = useSliderOrientationContext(THUMB_NAME, __scopeSlider);
    const [thumb, setThumb] = React$3.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));
    const isFormControl = thumb ? context.form || !!thumb.closest("form") : true;
    const size2 = useSize(thumb);
    const value = context.values[index2];
    const percent = value === void 0 ? 0 : convertValueToPercentage(value, context.min, context.max);
    const label = getLabel(index2, context.values.length);
    const orientationSize = size2?.[orientation.size];
    const thumbInBoundsOffset = orientationSize ? getThumbInBoundsOffset(orientationSize, percent, orientation.direction) : 0;
    React$3.useEffect(() => {
      if (thumb) {
        context.thumbs.add(thumb);
        return () => {
          context.thumbs.delete(thumb);
        };
      }
    }, [thumb, context.thumbs]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [orientation.startEdge]: `calc(${percent}% + ${thumbInBoundsOffset}px)`
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.ItemSlot, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.span,
            {
              role: "slider",
              "aria-label": props["aria-label"] || label,
              "aria-valuemin": context.min,
              "aria-valuenow": value,
              "aria-valuemax": context.max,
              "aria-orientation": context.orientation,
              "data-orientation": context.orientation,
              "data-disabled": context.disabled ? "" : void 0,
              tabIndex: context.disabled ? void 0 : 0,
              ...thumbProps,
              ref: composedRefs,
              style: value === void 0 ? { display: "none" } : props.style,
              onFocus: composeEventHandlers(props.onFocus, () => {
                context.valueIndexToChangeRef.current = index2;
              })
            }
          ) }),
          isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
            BubbleInput,
            {
              name: name ?? (context.name ? context.name + (context.values.length > 1 ? "[]" : "") : void 0),
              form: context.form,
              value
            },
            index2
          )
        ]
      }
    );
  }
);
SliderThumb$1.displayName = THUMB_NAME;
var BubbleInput = (props) => {
  const { value, ...inputProps } = props;
  const ref = React$3.useRef(null);
  const prevValue = usePrevious(value);
  React$3.useEffect(() => {
    const input = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "value");
    const setValue = descriptor.set;
    if (prevValue !== value && setValue) {
      const event = new Event("input", { bubbles: true });
      setValue.call(input, value);
      input.dispatchEvent(event);
    }
  }, [prevValue, value]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("input", { style: { display: "none" }, ...inputProps, ref, defaultValue: value });
};
function getNextSortedValues(prevValues = [], nextValue, atIndex) {
  const nextValues = [...prevValues];
  nextValues[atIndex] = nextValue;
  return nextValues.sort((a2, b) => a2 - b);
}
function convertValueToPercentage(value, min2, max2) {
  const maxSteps = max2 - min2;
  const percentPerStep = 100 / maxSteps;
  const percentage = percentPerStep * (value - min2);
  return clamp(percentage, [0, 100]);
}
function getLabel(index2, totalValues) {
  if (totalValues > 2) {
    return `Value ${index2 + 1} of ${totalValues}`;
  } else if (totalValues === 2) {
    return ["Minimum", "Maximum"][index2];
  } else {
    return void 0;
  }
}
function getClosestValueIndex(values, nextValue) {
  if (values.length === 1) return 0;
  const distances = values.map((value) => Math.abs(value - nextValue));
  const closestDistance = Math.min(...distances);
  return distances.indexOf(closestDistance);
}
function getThumbInBoundsOffset(width, left, direction) {
  const halfWidth = width / 2;
  const halfPercent = 50;
  const offset2 = linearScale([0, halfPercent], [0, halfWidth]);
  return (halfWidth - offset2(left) * direction) * direction;
}
function getStepsBetweenValues(values) {
  return values.slice(0, -1).map((value, index2) => values[index2 + 1] - value);
}
function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
  if (minStepsBetweenValues > 0) {
    const stepsBetweenValues = getStepsBetweenValues(values);
    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
    return actualMinStepsBetweenValues >= minStepsBetweenValues;
  }
  return true;
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1]) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function getDecimalCount(value) {
  return (String(value).split(".")[1] || "").length;
}
function roundValue(value, decimalCount) {
  const rounder = Math.pow(10, decimalCount);
  return Math.round(value * rounder) / rounder;
}
var Root = Slider$1;
var Track = SliderTrack;
var Range = SliderRange;
var Thumb = SliderThumb$1;
const React$2 = await importShared("react");
var [createTooltipContext, createTooltipScope] = createContextScope("Tooltip", [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var PROVIDER_NAME = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);
var TooltipProvider = (props) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props;
  const [isOpenDelayed, setIsOpenDelayed] = React$2.useState(true);
  const isPointerInTransitRef = React$2.useRef(false);
  const skipDelayTimerRef = React$2.useRef(0);
  React$2.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TooltipProviderContextProvider,
    {
      scope: __scopeTooltip,
      isOpenDelayed,
      delayDuration,
      onOpen: React$2.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        setIsOpenDelayed(false);
      }, []),
      onClose: React$2.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(
          () => setIsOpenDelayed(true),
          skipDelayDuration
        );
      }, [skipDelayDuration]),
      isPointerInTransitRef,
      onPointerInTransitChange: React$2.useCallback((inTransit) => {
        isPointerInTransitRef.current = inTransit;
      }, []),
      disableHoverableContent,
      children
    }
  );
};
TooltipProvider.displayName = PROVIDER_NAME;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var Tooltip$1 = (props) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen = false,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = usePopperScope(__scopeTooltip);
  const [trigger, setTrigger] = React$2.useState(null);
  const contentId = useId();
  const openTimerRef = React$2.useRef(0);
  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp ?? providerContext.delayDuration;
  const wasOpenDelayedRef = React$2.useRef(false);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange?.(open2);
    }
  });
  const stateAttribute = React$2.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = React$2.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = React$2.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = React$2.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
      openTimerRef.current = 0;
    }, delayDuration);
  }, [delayDuration, setOpen]);
  React$2.useEffect(() => {
    return () => {
      if (openTimerRef.current) {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = 0;
      }
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TooltipContextProvider,
    {
      scope: __scopeTooltip,
      contentId,
      open,
      stateAttribute,
      trigger,
      onTriggerChange: setTrigger,
      onTriggerEnter: React$2.useCallback(() => {
        if (providerContext.isOpenDelayed) handleDelayedOpen();
        else handleOpen();
      }, [providerContext.isOpenDelayed, handleDelayedOpen, handleOpen]),
      onTriggerLeave: React$2.useCallback(() => {
        if (disableHoverableContent) {
          handleClose();
        } else {
          window.clearTimeout(openTimerRef.current);
          openTimerRef.current = 0;
        }
      }, [handleClose, disableHoverableContent]),
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      children
    }
  ) });
};
Tooltip$1.displayName = TOOLTIP_NAME;
var TRIGGER_NAME$1 = "TooltipTrigger";
var TooltipTrigger = React$2.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...triggerProps } = props;
    const context = useTooltipContext(TRIGGER_NAME$1, __scopeTooltip);
    const providerContext = useTooltipProviderContext(TRIGGER_NAME$1, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const ref = React$2.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);
    const isPointerDownRef = React$2.useRef(false);
    const hasPointerMoveOpenedRef = React$2.useRef(false);
    const handlePointerUp = React$2.useCallback(() => isPointerDownRef.current = false, []);
    React$2.useEffect(() => {
      return () => document.removeEventListener("pointerup", handlePointerUp);
    }, [handlePointerUp]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        "aria-describedby": context.open ? context.contentId : void 0,
        "data-state": context.stateAttribute,
        ...triggerProps,
        ref: composedRefs,
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          if (event.pointerType === "touch") return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {
          context.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, () => {
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp, { once: true });
        }),
        onFocus: composeEventHandlers(props.onFocus, () => {
          if (!isPointerDownRef.current) context.onOpen();
        }),
        onBlur: composeEventHandlers(props.onBlur, context.onClose),
        onClick: composeEventHandlers(props.onClick, context.onClose)
      }
    ) });
  }
);
TooltipTrigger.displayName = TRIGGER_NAME$1;
var PORTAL_NAME = "TooltipPortal";
var [PortalProvider, usePortalContext] = createTooltipContext(PORTAL_NAME, {
  forceMount: void 0
});
var TooltipPortal = (props) => {
  const { __scopeTooltip, forceMount, children, container } = props;
  const context = useTooltipContext(PORTAL_NAME, __scopeTooltip);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider, { scope: __scopeTooltip, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$5, { asChild: true, container, children }) }) });
};
TooltipPortal.displayName = PORTAL_NAME;
var CONTENT_NAME$1 = "TooltipContent";
var TooltipContent = React$2.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME$1, props.__scopeTooltip);
    const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
    const context = useTooltipContext(CONTENT_NAME$1, props.__scopeTooltip);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
  }
);
var TooltipContentHoverable = React$2.forwardRef((props, forwardedRef) => {
  const context = useTooltipContext(CONTENT_NAME$1, props.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME$1, props.__scopeTooltip);
  const ref = React$2.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = React$2.useState(null);
  const { trigger, onClose } = context;
  const content = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = React$2.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = React$2.useCallback(
    (event, hoverTarget) => {
      const currentTarget = event.currentTarget;
      const exitPoint = { x: event.clientX, y: event.clientY };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
      setPointerGraceArea(graceArea);
      onPointerInTransitChange(true);
    },
    [onPointerInTransitChange]
  );
  React$2.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  React$2.useEffect(() => {
    if (trigger && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
      trigger.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);
  React$2.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = trigger?.contains(target) || content?.contains(target);
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger, content, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { ...props, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var TooltipContentImpl = React$2.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTooltip,
      children,
      "aria-label": ariaLabel,
      onEscapeKeyDown,
      onPointerDownOutside,
      ...contentProps
    } = props;
    const context = useTooltipContext(CONTENT_NAME$1, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const { onClose } = context;
    React$2.useEffect(() => {
      document.addEventListener(TOOLTIP_OPEN, onClose);
      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
    }, [onClose]);
    React$2.useEffect(() => {
      if (context.trigger) {
        const handleScroll2 = (event) => {
          const target = event.target;
          if (target?.contains(context.trigger)) onClose();
        };
        window.addEventListener("scroll", handleScroll2, { capture: true });
        return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
      }
    }, [context.trigger, onClose]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DismissableLayer,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Content,
          {
            "data-state": context.stateAttribute,
            ...popperScope,
            ...contentProps,
            ref: forwardedRef,
            style: {
              ...contentProps.style,
              // re-namespace exposed content custom properties
              ...{
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
              }
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Slottable, { children }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root$5, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
            ]
          }
        )
      }
    );
  }
);
TooltipContent.displayName = CONTENT_NAME$1;
var ARROW_NAME = "TooltipArrow";
var TooltipArrow = React$2.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeTooltip);
    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
      ARROW_NAME,
      __scopeTooltip
    );
    return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
TooltipArrow.displayName = ARROW_NAME;
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a2, b) => {
    if (a2.x < b.x) return -1;
    else if (a2.x > b.x) return 1;
    else if (a2.y < b.y) return -1;
    else if (a2.y > b.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p2 = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r2 = upperHull[upperHull.length - 2];
      if ((q.x - r2.x) * (p2.y - r2.y) >= (q.y - r2.y) * (p2.x - r2.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p2);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p2 = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r2 = lowerHull[lowerHull.length - 2];
      if ((q.x - r2.x) * (p2.y - r2.y) >= (q.y - r2.y) * (p2.x - r2.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p2);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Provider = TooltipProvider;
var Root3 = Tooltip$1;
var Trigger$1 = TooltipTrigger;
var Portal = TooltipPortal;
var Content2 = TooltipContent;
const React$1 = await importShared("react");
var TABS_NAME = "Tabs";
var [createTabsContext, createTabsScope] = createContextScope(TABS_NAME, [
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);
var Tabs$1 = React$1.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTabs,
      value: valueProp,
      onValueChange,
      defaultValue,
      orientation = "horizontal",
      dir,
      activationMode = "automatic",
      ...tabsProps
    } = props;
    const direction = useDirection(dir);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabsProvider,
      {
        scope: __scopeTabs,
        baseId: useId(),
        value,
        onValueChange: setValue,
        orientation,
        dir: direction,
        activationMode,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            dir: direction,
            "data-orientation": orientation,
            ...tabsProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Tabs$1.displayName = TABS_NAME;
var TAB_LIST_NAME = "TabsList";
var TabsList = React$1.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, loop = true, ...listProps } = props;
    const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root$2,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation: context.orientation,
        dir: context.dir,
        loop,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            role: "tablist",
            "aria-orientation": context.orientation,
            ...listProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
TabsList.displayName = TAB_LIST_NAME;
var TRIGGER_NAME = "TabsTrigger";
var TabsTrigger = React$1.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, disabled = false, ...triggerProps } = props;
    const context = useTabsContext(TRIGGER_NAME, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
    const triggerId = makeTriggerId(context.baseId, value);
    const contentId = makeContentId(context.baseId, value);
    const isSelected = value === context.value;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item$1,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        active: isSelected,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": isSelected,
            "aria-controls": contentId,
            "data-state": isSelected ? "active" : "inactive",
            "data-disabled": disabled ? "" : void 0,
            disabled,
            id: triggerId,
            ...triggerProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!disabled && event.button === 0 && event.ctrlKey === false) {
                context.onValueChange(value);
              } else {
                event.preventDefault();
              }
            }),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if ([" ", "Enter"].includes(event.key)) context.onValueChange(value);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => {
              const isAutomaticActivation = context.activationMode !== "manual";
              if (!isSelected && !disabled && isAutomaticActivation) {
                context.onValueChange(value);
              }
            })
          }
        )
      }
    );
  }
);
TabsTrigger.displayName = TRIGGER_NAME;
var CONTENT_NAME = "TabsContent";
var TabsContent = React$1.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, forceMount, children, ...contentProps } = props;
    const context = useTabsContext(CONTENT_NAME, __scopeTabs);
    const triggerId = makeTriggerId(context.baseId, value);
    const contentId = makeContentId(context.baseId, value);
    const isSelected = value === context.value;
    const isMountAnimationPreventedRef = React$1.useRef(isSelected);
    React$1.useEffect(() => {
      const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
      return () => cancelAnimationFrame(rAF);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || isSelected, children: ({ present }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        "data-state": isSelected ? "active" : "inactive",
        "data-orientation": context.orientation,
        role: "tabpanel",
        "aria-labelledby": triggerId,
        hidden: !present,
        id: contentId,
        tabIndex: 0,
        ...contentProps,
        ref: forwardedRef,
        style: {
          ...props.style,
          animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
        },
        children: present && children
      }
    ) });
  }
);
TabsContent.displayName = CONTENT_NAME;
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
var Root2 = Tabs$1;
var List = TabsList;
var Trigger = TabsTrigger;
const React = await importShared("react");
const React__default = await importShared("react");
const { useEffect, useState, useRef, Children, forwardRef, useCallback, useLayoutEffect, useDeferredValue } = React__default;
const ReactDOM = await importShared("react-dom");
const focusedDisabled = "focus-visible:ring-0 focus-visible:ring-offset-0";
const focusedInvisibleMixin = "focus:bg-opacity-70 focus:bg-surface-accent-100 focus:dark:bg-surface-800 focus:dark:bg-opacity-60";
const focusedClasses = "z-30 outline-none ring-2 ring-primary ring-opacity-75 ring-offset-2 ring-offset-transparent ";
const fieldBackgroundMixin = "bg-opacity-50 bg-surface-accent-200 dark:bg-surface-800 dark:bg-opacity-60";
const fieldBackgroundInvisibleMixin = "bg-opacity-0 bg-surface-accent-100 dark:bg-surface-800 dark:bg-opacity-0";
const fieldBackgroundDisabledMixin = "dark:bg-surface-800 bg-opacity-50 dark:bg-opacity-90";
const fieldBackgroundHoverMixin = "hover:bg-opacity-70 dark:hover:bg-surface-700 dark:hover:bg-opacity-40";
const defaultBorderMixin = "border-surface-200 border-opacity-40 dark:border-surface-700 dark:border-opacity-40";
const paperMixin = "bg-white rounded-md dark:bg-surface-950 border border-surface-200 border-opacity-40 dark:border-surface-700 dark:border-opacity-40";
const cardMixin = "bg-white border border-surface-200 border-opacity-40 dark:border-transparent rounded-md dark:bg-surface-950 dark:border-surface-700 dark:border-opacity-40 m-1 -p-1";
const cardClickableMixin = "hover:bg-primary-bg dark:hover:bg-primary-bg hover:bg-opacity-20 dark:hover:bg-opacity-20 hover:ring-2 hover:ring-primary cursor-pointer";
const cardSelectedMixin = "bg-primary-bg dark:bg-primary-bg bg-opacity-30 dark:bg-opacity-10 ring-1 ring-primary ring-opacity-75";
function cls(...classes) {
  return twMerge(clsx(classes));
}
function cn(...classes) {
  console.warn("cn() is deprecated, use cls() instead. cn will be removed in the final 3.0.0 version");
  return cls(...classes);
}
function debounce(func, wait = 166) {
  let timeout;
  function debounced(...args) {
    const later = () => {
      func.apply(this, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  }
  debounced.clear = () => {
    clearTimeout(timeout);
  };
  return debounced;
}
function hashString(str) {
  let hash = 0;
  let i;
  let chr;
  for (i = 0; i < str.length; i++) {
    chr = str.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash |= 0;
  }
  return Math.abs(hash);
}
const CHIP_COLORS = {
  blueLighter: {
    color: "#cfdfff",
    text: "#102046"
  },
  cyanLighter: {
    color: "#d0f0fd",
    text: "#04283f"
  },
  tealLighter: {
    color: "#c2f5e9",
    text: "#012524"
  },
  greenLighter: {
    color: "#d1f7c4",
    text: "#0b1d05"
  },
  yellowLighter: {
    color: "#ffeab6",
    text: "#3b2501"
  },
  orangeLighter: {
    color: "#fee2d5",
    text: "#6b2613"
  },
  redLighter: {
    color: "#ffdce5",
    text: "#4c0c1c"
  },
  pinkLighter: {
    color: "#ffdaf6",
    text: "#400832"
  },
  purpleLighter: {
    color: "#ede2fe",
    text: "#280b42"
  },
  grayLighter: {
    color: "#eee",
    text: "#040404"
  },
  blueLight: {
    color: "#9cc7ff",
    text: "#102046"
  },
  cyanLight: {
    color: "#77d1f3",
    text: "#04283f"
  },
  tealLight: {
    color: "#72ddc3",
    text: "#012524"
  },
  greenLight: {
    color: "#93e088",
    text: "#0b1d05"
  },
  yellowLight: {
    color: "#ffd66e",
    text: "#3b2501"
  },
  orangeLight: {
    color: "#ffa981",
    text: "#6b2613"
  },
  redLight: {
    color: "#ff9eb7",
    text: "#4c0c1c"
  },
  pinkLight: {
    color: "#f99de2",
    text: "#400832"
  },
  purpleLight: {
    color: "#cdb0ff",
    text: "#280b42"
  },
  grayLight: {
    color: "#ccc",
    text: "#040404"
  },
  blueDark: {
    color: "#2d7ff9",
    text: "#fff"
  },
  cyanDark: {
    color: "#18bfff",
    text: "#fff"
  },
  tealDark: {
    color: "#20d9d2",
    text: "#fff"
  },
  greenDark: {
    color: "#20c933",
    text: "#fff"
  },
  yellowDark: {
    color: "#fcb400",
    text: "#fff"
  },
  orangeDark: {
    color: "#ff6f2c",
    text: "#fff"
  },
  redDark: {
    color: "#f82b60",
    text: "#fff"
  },
  pinkDark: {
    color: "#ff08c2",
    text: "#fff"
  },
  purpleDark: {
    color: "#8b46ff",
    text: "#fff"
  },
  grayDark: {
    color: "#666",
    text: "#fff"
  },
  blueDarker: {
    color: "#2750ae",
    text: "#cfdfff"
  },
  cyanDarker: {
    color: "#0b76b7",
    text: "#d0f0fd"
  },
  tealDarker: {
    color: "#06a09b",
    text: "#daf3e9"
  },
  greenDarker: {
    color: "#338a17",
    text: "#d1f7c4"
  },
  yellowDarker: {
    color: "#b87503",
    text: "#ffeab6"
  },
  orangeDarker: {
    color: "#d74d26",
    text: "#fee2d5"
  },
  redDarker: {
    color: "#ba1e45",
    text: "#ffdce5"
  },
  pinkDarker: {
    color: "#b2158b",
    text: "#ffdaf6"
  },
  purpleDarker: {
    color: "#6b1cb0",
    text: "#ede2fe"
  },
  grayDarker: {
    color: "#444",
    text: "#eee"
  }
};
function getColorSchemeForKey(key) {
  return CHIP_COLORS[key];
}
function getColorSchemeForSeed(seed) {
  const hash = hashString(seed);
  const colorKeys = Object.keys(CHIP_COLORS);
  const index2 = hash % colorKeys.length;
  return CHIP_COLORS[colorKeys[index2]];
}
function keyToIconComponent(key) {
  const startsWithNumber = key.match(/^\d/);
  const componentName = (startsWithNumber ? "_" : "") + key.split("_").map((word) => {
    return word.charAt(0).toUpperCase() + word.slice(1);
  }).join("") + "Icon";
  return componentName;
}
function useInjectStyles(key, styles2) {
  const $ = c_1(4);
  let t0;
  if ($[0] !== key || $[1] !== styles2) {
    t0 = () => {
      const styleElement = document.getElementById(key);
      if (!styleElement) {
        const style = document.createElement("style");
        style.id = key;
        style.innerHTML = styles2;
        document.head.appendChild(style);
      }
    };
    $[0] = key;
    $[1] = styles2;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  let t1;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [];
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  useEffect(t0, t1);
}
function useOutsideAlerter(ref, onOutsideClick, t0) {
  const $ = c_1(5);
  const active = t0 === void 0 ? true : t0;
  let t1;
  let t2;
  if ($[0] !== active || $[1] !== onOutsideClick || $[2] !== ref) {
    t1 = () => {
      if (!active) {
        return;
      }
      const handleClickOutside = function handleClickOutside2(event) {
        if (isInPresentationLayer(event.target)) {
          return;
        }
        if (ref.current && !ref.current.contains(event.target)) {
          onOutsideClick();
        }
      };
      document.addEventListener("mousedown", handleClickOutside);
      return () => {
        document.removeEventListener("mousedown", handleClickOutside);
      };
    };
    t2 = [ref, active, onOutsideClick];
    $[0] = active;
    $[1] = onOutsideClick;
    $[2] = ref;
    $[3] = t1;
    $[4] = t2;
  } else {
    t1 = $[3];
    t2 = $[4];
  }
  useEffect(t1, t2);
}
function isInPresentationLayer(node) {
  if (node instanceof HTMLElement) {
    if (node.getAttribute("role") === "presentation") return true;
    return isInPresentationLayer(node.parentNode);
  }
  return false;
}
function useDebounceValue(value, t0) {
  const $ = c_1(4);
  const delay = t0 === void 0 ? 300 : t0;
  const [debouncedValue, setDebouncedValue] = useState(value);
  let t1;
  let t2;
  if ($[0] !== delay || $[1] !== value) {
    t1 = () => {
      const handler = setTimeout(() => {
        setDebouncedValue(value);
      }, delay);
      return () => {
        clearTimeout(handler);
      };
    };
    t2 = [value, delay];
    $[0] = delay;
    $[1] = value;
    $[2] = t1;
    $[3] = t2;
  } else {
    t1 = $[2];
    t2 = $[3];
  }
  useEffect(t1, t2);
  return debouncedValue;
}
function useIconStyles(t0) {
  const {
    fill: t1,
    weight: t2,
    grad: t3,
    opticalSize: t4
  } = t0;
  const fill = t1 === void 0 ? true : t1;
  const weight = t2 === void 0 ? 500 : t2;
  const grad = t3 === void 0 ? 0 : t3;
  const opticalSize = t4 === void 0 ? 24 : t4;
  useInjectStyles("icons", `
.material-symbols-rounded {
  font-variation-settings: 'FILL' ${fill ? 1 : 0}, 'wght' ${weight}, 'GRAD' ${grad}, 'opsz' ${opticalSize};
}`);
}
function Collapse(t0) {
  const $ = c_1(9);
  const {
    children,
    className,
    in: t1,
    duration: t2
  } = t0;
  const isOpen = t1 === void 0 ? false : t1;
  const duration = t2 === void 0 ? 220 : t2;
  useInjectStyles(`Collapse-${duration}`, `
.CollapseContent-${duration} {
  overflow: hidden;
}
.CollapseContent-${duration}[data-state='open'] {
  animation: slideDown ${duration}ms ease-out;
}
.CollapseContent-${duration}[data-state='closed'] {
  animation: slideUp ${duration}ms ease-in;
}

@keyframes slideDown {
  from {
    height: 0;
  }
  to {
    height: var(--radix-collapsible-content-height);
  }
}

@keyframes slideUp {
  from {
    height: var(--radix-collapsible-content-height);
  }
  to {
    height: 0;
  }
}
`);
  const t3 = `CollapseContent-${duration}`;
  let t4;
  if ($[0] !== t3) {
    t4 = cls(t3);
    $[0] = t3;
    $[1] = t4;
  } else {
    t4 = $[1];
  }
  let t5;
  if ($[2] !== children || $[3] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Content$2, { className: t4, children });
    $[2] = children;
    $[3] = t4;
    $[4] = t5;
  } else {
    t5 = $[4];
  }
  let t6;
  if ($[5] !== className || $[6] !== isOpen || $[7] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(Root$8, { open: isOpen, className, children: t5 });
    $[5] = className;
    $[6] = isOpen;
    $[7] = t5;
    $[8] = t6;
  } else {
    t6 = $[8];
  }
  return t6;
}
const useAutoComplete = ({
  ref
}) => {
  const [autoCompleteOpen, setAutoCompleteOpen] = React__default.useState(false);
  const [inputFocused, setInputFocused] = React__default.useState(false);
  React__default.useEffect(() => {
    if (ref.current) {
      ref.current.onfocus = () => {
        setAutoCompleteOpen(true);
        setInputFocused(true);
      };
      ref.current.onblur = () => {
        setInputFocused(false);
      };
    }
  }, [ref]);
  return {
    inputFocused,
    autoCompleteOpen,
    setAutoCompleteOpen
  };
};
function Autocomplete(t0) {
  const $ = c_1(13);
  const {
    children,
    open,
    setOpen
  } = t0;
  const autocompleteRef = React__default.useRef(null);
  let t1;
  if ($[0] !== setOpen) {
    t1 = () => setOpen(false);
    $[0] = setOpen;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  useOutsideAlerter(autocompleteRef, t1);
  const t2 = open ? "shadow" : "";
  let t3;
  if ($[2] !== t2) {
    t3 = cls("absolute top-full left-0 right-0 overflow-visible", t2, "my-2", "z-20", "w-full");
    $[2] = t2;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  const t4 = open ? paperMixin : "";
  let t5;
  if ($[4] !== t4) {
    t5 = cls(t4, "bg-surface-50 dark:bg-surface-900 py-2");
    $[4] = t4;
    $[5] = t5;
  } else {
    t5 = $[5];
  }
  let t6;
  if ($[6] !== children || $[7] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: autocompleteRef, className: t5, children });
    $[6] = children;
    $[7] = t5;
    $[8] = t6;
  } else {
    t6 = $[8];
  }
  let t7;
  if ($[9] !== open || $[10] !== t3 || $[11] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(Collapse, { in: open, duration: 50, className: t3, children: t6 });
    $[9] = open;
    $[10] = t3;
    $[11] = t6;
    $[12] = t7;
  } else {
    t7 = $[12];
  }
  return t7;
}
function AutocompleteItem(t0) {
  const $ = c_1(3);
  const {
    children,
    onClick
  } = t0;
  let t1;
  if ($[0] !== children || $[1] !== onClick) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-full items-center pr-6 pl-14 h-[48px] cursor-pointer hover:bg-surface-accent-100 dark:hover:bg-surface-accent-800", onClick, children });
    $[0] = children;
    $[1] = onClick;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}
const getSizeClasses = (size2) => {
  switch (size2) {
    case "small":
      return "px-4 py-1";
    case "large":
      return "px-4 py-4";
    case "medium":
    default:
      return "px-4 py-2";
  }
};
const getColorClasses = (severity) => {
  switch (severity) {
    case "error":
      return "bg-red-50 dark:bg-red-800 dark:text-red-100 text-red-900";
    case "warning":
      return "bg-amber-50 dark:bg-amber-800 dark:text-amber-100 text-amber-900";
    case "info":
      return "bg-blue-100 dark:bg-blue-800 dark:text-blue-100 text-blue-900";
    case "success":
      return "bg-emerald-50 dark:bg-emerald-800 dark:text-emerald-100 text-emerald-900";
    case "base":
    default:
      return "bg-surface-accent-50 dark:bg-surface-accent-800 dark:text-white text-surface-accent-900";
  }
};
const Alert = (t0) => {
  const $ = c_1(16);
  const {
    children,
    onDismiss,
    color: t1,
    size: t2,
    action,
    className,
    style
  } = t0;
  const color = t1 === void 0 ? "info" : t1;
  const size2 = t2 === void 0 ? "medium" : t2;
  let t3;
  let t4;
  if ($[0] !== className || $[1] !== color || $[2] !== size2 || $[3] !== style) {
    const classes = getColorClasses(color);
    t3 = style;
    t4 = cls(getSizeClasses(size2), "w-full", "font-medium", "rounded-md flex items-center gap-2", classes, className);
    $[0] = className;
    $[1] = color;
    $[2] = size2;
    $[3] = style;
    $[4] = t3;
    $[5] = t4;
  } else {
    t3 = $[4];
    t4 = $[5];
  }
  let t5;
  if ($[6] !== children) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow", children });
    $[6] = children;
    $[7] = t5;
  } else {
    t5 = $[7];
  }
  let t6;
  if ($[8] !== onDismiss) {
    t6 = onDismiss && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-surface-accent-400 hover:text-surface-accent-600 dark:text-surface-accent-500 dark:hover:text-surface-accent-400", onClick: onDismiss, children: "×" });
    $[8] = onDismiss;
    $[9] = t6;
  } else {
    t6 = $[9];
  }
  let t7;
  if ($[10] !== action || $[11] !== t3 || $[12] !== t4 || $[13] !== t5 || $[14] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: t3, className: t4, children: [
      t5,
      t6,
      action
    ] });
    $[10] = action;
    $[11] = t3;
    $[12] = t4;
    $[13] = t5;
    $[14] = t6;
    $[15] = t7;
  } else {
    t7 = $[15];
  }
  return t7;
};
const AvatarInner = (t0, ref) => {
  const $ = c_1(23);
  let alt;
  let children;
  let className;
  let outerClassName;
  let props;
  let src;
  let style;
  if ($[0] !== t0) {
    ({
      src,
      alt,
      children,
      className,
      style,
      outerClassName,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = alt;
    $[2] = children;
    $[3] = className;
    $[4] = outerClassName;
    $[5] = props;
    $[6] = src;
    $[7] = style;
  } else {
    alt = $[1];
    children = $[2];
    className = $[3];
    outerClassName = $[4];
    props = $[5];
    src = $[6];
    style = $[7];
  }
  const [isImageError, setIsImageError] = useState(false);
  let t1;
  if ($[8] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => {
      setIsImageError(true);
    };
    $[8] = t1;
  } else {
    t1 = $[8];
  }
  const handleImageError = t1;
  let t2;
  if ($[9] !== outerClassName) {
    t2 = cls("rounded-full flex items-center justify-center overflow-hidden", "p-1 hover:bg-surface-accent-200 hover:dark:bg-surface-accent-700 w-12 h-12 min-w-12 min-h-12", outerClassName);
    $[9] = outerClassName;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  let t3;
  if ($[11] !== alt || $[12] !== children || $[13] !== className || $[14] !== isImageError || $[15] !== src) {
    t3 = src && !isImageError ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: cls("bg-surface-accent-100 dark:bg-surface-accent-800", "w-full h-full object-cover rounded-full", className), src, alt, onError: handleImageError }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: cls("bg-surface-accent-100 dark:bg-surface-accent-800", "flex items-center justify-center", "w-full h-full py-1.5 text-lg font-medium text-surface-accent-900 dark:text-white rounded-full", className), children });
    $[11] = alt;
    $[12] = children;
    $[13] = className;
    $[14] = isImageError;
    $[15] = src;
    $[16] = t3;
  } else {
    t3 = $[16];
  }
  let t4;
  if ($[17] !== props || $[18] !== ref || $[19] !== style || $[20] !== t2 || $[21] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx("button", { ref, style, ...props, className: t2, children: t3 });
    $[17] = props;
    $[18] = ref;
    $[19] = style;
    $[20] = t2;
    $[21] = t3;
    $[22] = t4;
  } else {
    t4 = $[22];
  }
  return t4;
};
const Avatar = React__default.forwardRef(AvatarInner);
const BooleanSwitch = React__default.forwardRef(function BooleanSwitch2({
  value,
  allowIndeterminate,
  className,
  onValueChange,
  disabled = false,
  size: size2 = "medium",
  ...props
}, ref) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { type: "button", ref, tabIndex: disabled ? -1 : void 0, onClick: disabled ? (e) => e.preventDefault() : (e_0) => {
    e_0.preventDefault();
    if (allowIndeterminate) {
      if (value === null || value === void 0) onValueChange?.(true);
      else if (value) onValueChange?.(false);
      else onValueChange?.(null);
    } else {
      onValueChange?.(!value);
    }
  }, className: cls(size2 === "small" ? "w-[38px] h-[22px] min-w-[38px] min-h-[22px]" : "w-[42px] h-[26px] min-w-[42px] min-h-[26px]", "outline-none rounded-full relative shadow-sm", value ? disabled ? "bg-white bg-opacity-54 dark:bg-surface-accent-950 border-surface-accent-100 dark:border-surface-accent-700 ring-1 ring-surface-accent-200 dark:ring-surface-accent-700" : "ring-secondary ring-1 bg-secondary dark:bg-secondary" : "bg-white bg-opacity-54 dark:bg-surface-accent-900 ring-1 ring-surface-accent-200 dark:ring-surface-accent-700", className), ...props, children: [
    allowIndeterminate && (value === null || value === void 0) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls("block rounded-full transition-transform duration-100 transform will-change-auto", disabled ? "bg-surface-accent-400 dark:bg-surface-accent-600" : "bg-surface-accent-400 dark:bg-surface-accent-600", {
      "w-[21px] h-[10px]": size2 === "medium" || size2 === "large",
      "w-[19px] h-[8px]": size2 === "small",
      "translate-x-[10px]": size2 === "medium" || size2 === "large",
      "translate-x-[9px]": size2 === "small"
    }) }, "knob"),
    !(allowIndeterminate && (value === null || value === void 0)) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls("block rounded-full transition-transform duration-100 transform will-change-auto", disabled ? "bg-surface-accent-300 dark:bg-surface-accent-700" : value ? "bg-white" : "bg-surface-accent-600 dark:bg-surface-accent-400", {
      "w-[21px] h-[21px]": size2 === "medium" || size2 === "large",
      "w-[19px] h-[19px]": size2 === "small",
      [value ? "translate-x-[19px]" : "translate-x-[3px]"]: size2 === "medium" || size2 === "large",
      [value ? "translate-x-[17px]" : "translate-x-[2px]"]: size2 === "small"
    }) }, "knob")
  ] });
});
const BooleanSwitchWithLabel = function BooleanSwitchWithLabel2({
  value,
  position = "end",
  invisible,
  onValueChange,
  error,
  label,
  autoFocus,
  disabled,
  size: size2,
  className,
  fullWidth = true,
  inputClassName,
  ...props
}) {
  const ref = React__default.useRef(null);
  const refInput = React__default.useRef(null);
  const [_2, setFocused] = React__default.useState(autoFocus);
  const onFocus = () => setFocused(true);
  const onBlur = () => setFocused(false);
  React__default.useEffect(() => {
  }, []);
  const focus2 = document.activeElement === refInput?.current || document.activeElement === ref?.current;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref, onFocus, onBlur, tabIndex: -1, className: cls(!invisible && fieldBackgroundMixin, !invisible && (disabled ? fieldBackgroundDisabledMixin : fieldBackgroundHoverMixin), disabled ? "cursor-default" : "cursor-pointer", "rounded-md max-w-full justify-between box-border relative inline-flex items-center", !invisible && focus2 && !disabled ? focusedClasses : "", error ? "text-red-500 dark:text-red-600" : focus2 && !disabled ? "text-primary" : !disabled ? "text-text-primary dark:text-text-primary-dark" : "text-text-secondary dark:text-text-secondary-dark", size2 === "small" ? "min-h-[40px]" : size2 === "medium" ? "min-h-[48px]" : "min-h-[64px]", size2 === "small" ? "pl-2" : "pl-4", size2 === "small" ? "pr-4" : "pr-6", position === "end" ? "flex-row-reverse" : "flex-row", fullWidth ? "w-full" : "", className), onClick: disabled ? void 0 : (e) => {
    if (props.allowIndeterminate) {
      if (value === null || value === void 0) onValueChange?.(true);
      else if (value) onValueChange?.(false);
      else onValueChange?.(null);
    } else {
      onValueChange?.(!value);
    }
  }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanSwitch, { value, ref: refInput, size: size2, className: cls(invisible && focus2 ? focusedClasses : "", inputClassName), disabled, ...props }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls("flex-grow", position === "end" ? "mr-4" : "ml-4", size2 === "small" ? "text-sm" : "text-base"), children: label })
  ] });
};
const ButtonInner = React__default.forwardRef((t0, ref) => {
  const $ = c_1(53);
  let Component;
  let children;
  let className;
  let props;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  if ($[0] !== t0) {
    ({
      children,
      className,
      variant: t1,
      disabled: t2,
      size: t3,
      startIcon: t4,
      fullWidth: t5,
      component: Component,
      color: t6,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = Component;
    $[2] = children;
    $[3] = className;
    $[4] = props;
    $[5] = t1;
    $[6] = t2;
    $[7] = t3;
    $[8] = t4;
    $[9] = t5;
    $[10] = t6;
  } else {
    Component = $[1];
    children = $[2];
    className = $[3];
    props = $[4];
    t1 = $[5];
    t2 = $[6];
    t3 = $[7];
    t4 = $[8];
    t5 = $[9];
    t6 = $[10];
  }
  const variant = t1 === void 0 ? "filled" : t1;
  const disabled = t2 === void 0 ? false : t2;
  const size2 = t3 === void 0 ? "medium" : t3;
  const startIcon = t4 === void 0 ? null : t4;
  const fullWidth = t5 === void 0 ? false : t5;
  const color = t6 === void 0 ? "primary" : t6;
  const t7 = !fullWidth;
  const t8 = variant === "filled" && color === "primary" && !disabled;
  const t9 = variant === "filled" && color === "secondary" && !disabled;
  const t10 = variant === "filled" && color === "error" && !disabled;
  const t11 = variant === "filled" && color === "text" && !disabled;
  const t12 = variant === "text" && color === "primary" && !disabled;
  const t13 = variant === "text" && color === "secondary" && !disabled;
  const t14 = variant === "text" && color === "error" && !disabled;
  const t15 = variant === "text" && color === "text" && !disabled;
  const t16 = variant === "outlined" && color === "primary" && !disabled;
  const t17 = variant === "outlined" && color === "secondary" && !disabled;
  const t18 = variant === "outlined" && color === "error" && !disabled;
  const t19 = variant === "outlined" && color === "text" && !disabled;
  const t20 = variant === "neutral" && (color === "primary" || color === "text") && !disabled;
  const t21 = variant === "neutral" && color === "secondary" && !disabled;
  const t22 = variant === "neutral" && color === "error" && !disabled;
  const t23 = variant === "text" && disabled;
  const t24 = variant === "outlined" && disabled;
  const t25 = (variant === "filled" || variant === "neutral") && disabled;
  let t26;
  let t27;
  let t28;
  let t29;
  let t30;
  if ($[11] !== Component || $[12] !== children || $[13] !== className || $[14] !== disabled || $[15] !== fullWidth || $[16] !== props || $[17] !== ref || $[18] !== size2 || $[19] !== startIcon || $[20] !== t10 || $[21] !== t11 || $[22] !== t12 || $[23] !== t13 || $[24] !== t14 || $[25] !== t15 || $[26] !== t16 || $[27] !== t17 || $[28] !== t18 || $[29] !== t19 || $[30] !== t20 || $[31] !== t21 || $[32] !== t22 || $[33] !== t23 || $[34] !== t24 || $[35] !== t25 || $[36] !== t7 || $[37] !== t8 || $[38] !== t9) {
    t30 = Symbol.for("react.early_return_sentinel");
    bb0: {
      const buttonClasses2 = cls({
        "w-full": fullWidth,
        "w-fit": t7,
        "border border-primary bg-primary focus:ring-primary shadow hover:ring-1 hover:ring-primary text-white hover:text-white": t8,
        "border border-secondary bg-secondary focus:ring-secondary shadow hover:ring-1 hover:ring-secondary text-white hover:text-white": t9,
        "border border-red-500 bg-red-500 hover:bg-red-500 focus:ring-red-500 shadow hover:ring-1 hover:ring-red-600 text-white hover:text-white": t10,
        "border border-surface-accent-200 bg-surface-accent-200 hover:bg-surface-accent-300 focus:ring-surface-accent-400 shadow hover:ring-1 hover:ring-surface-accent-400 text-text-primary hover:text-text-primary dark:text-text-primary-dark hover:dark:text-text-primary-dark": t11,
        "border border-transparent text-primary hover:text-primary hover:bg-surface-accent-200 dark:hover:bg-surface-900": t12,
        "border border-transparent text-secondary hover:text-secondary hover:bg-secondary-bg": t13,
        "border border-transparent text-red-500 hover:text-red-500 hover:bg-red-500 hover:bg-opacity-10": t14,
        "border border-transparent text-text-primary hover:text-text-primary dark:text-text-primary-dark hover:dark:text-text-primary-dark hover:bg-surface-accent-200 hover:dark:bg-surface-700": t15,
        "border border-primary text-primary hover:text-primary hover:bg-primary-bg": t16,
        "border border-secondary text-secondary hover:text-secondary hover:bg-secondary-bg": t17,
        "border border-red-500 text-red-500 hover:text-red-500 hover:bg-red-500 hover:text-white": t18,
        "border border-surface-accent-400 text-text-primary hover:text-text-primary dark:text-text-primary-dark hover:bg-surface-accent-200": t19,
        "border border-transparent bg-surface-100 hover:bg-surface-accent-200 text-text-primary dark:bg-surface-800 dark:hover:bg-surface-accent-700 dark:text-white": t20,
        "border border-transparent bg-surface-100 hover:bg-surface-accent-200 text-text-secondary dark:bg-surface-800 dark:hover:bg-surface-accent-700 dark:text-white": t21,
        "border border-transparent bg-surface-100 hover:bg-surface-accent-200 text-error dark:bg-surface-800 dark:hover:bg-surface-accent-700 dark:text-error": t22,
        "text-text-disabled dark:text-text-disabled-dark": disabled,
        "border border-transparent opacity-50": t23,
        "border border-surface-500 opacity-50": t24,
        "border border-surface-500 bg-surface-500 opacity-50": t25
      });
      const sizeClasses2 = cls({
        "py-1 px-2": size2 === "small",
        "py-2 px-4": size2 === "medium",
        "py-2.5 px-5": size2 === "large",
        "py-3 px-6": size2 === "xl",
        "py-4 px-10": size2 === "2xl"
      });
      if (Component) {
        t30 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Component, { ref, onClick: props.onClick, className: cls(startIcon ? "pl-3" : "", "typography-button h-fit rounded-md whitespace-nowrap inline-flex items-center justify-center p-2 px-4 focus:outline-none transition ease-in-out duration-150 gap-2", buttonClasses2, sizeClasses2, className), ...props, children: [
          startIcon,
          children
        ] });
        break bb0;
      }
      t26 = ref;
      t27 = props.type ?? "button";
      t28 = props.onClick;
      t29 = cls(startIcon ? "pl-3" : "", "typography-button h-fit rounded-md whitespace-nowrap inline-flex items-center justify-center p-2 px-4 focus:outline-none transition ease-in-out duration-150 gap-2", buttonClasses2, sizeClasses2, className);
    }
    $[11] = Component;
    $[12] = children;
    $[13] = className;
    $[14] = disabled;
    $[15] = fullWidth;
    $[16] = props;
    $[17] = ref;
    $[18] = size2;
    $[19] = startIcon;
    $[20] = t10;
    $[21] = t11;
    $[22] = t12;
    $[23] = t13;
    $[24] = t14;
    $[25] = t15;
    $[26] = t16;
    $[27] = t17;
    $[28] = t18;
    $[29] = t19;
    $[30] = t20;
    $[31] = t21;
    $[32] = t22;
    $[33] = t23;
    $[34] = t24;
    $[35] = t25;
    $[36] = t7;
    $[37] = t8;
    $[38] = t9;
    $[39] = t26;
    $[40] = t27;
    $[41] = t28;
    $[42] = t29;
    $[43] = t30;
  } else {
    t26 = $[39];
    t27 = $[40];
    t28 = $[41];
    t29 = $[42];
    t30 = $[43];
  }
  if (t30 !== Symbol.for("react.early_return_sentinel")) {
    return t30;
  }
  const t31 = props;
  let t32;
  if ($[44] !== children || $[45] !== disabled || $[46] !== startIcon || $[47] !== t26 || $[48] !== t27 || $[49] !== t28 || $[50] !== t29 || $[51] !== t31) {
    t32 = /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { ref: t26, type: t27, onClick: t28, className: t29, disabled, ...t31, children: [
      startIcon,
      children
    ] });
    $[44] = children;
    $[45] = disabled;
    $[46] = startIcon;
    $[47] = t26;
    $[48] = t27;
    $[49] = t28;
    $[50] = t29;
    $[51] = t31;
    $[52] = t32;
  } else {
    t32 = $[52];
  }
  return t32;
});
ButtonInner.displayName = "Button";
const Button = ButtonInner;
const Card = React__default.forwardRef((t0, ref) => {
  const $ = c_1(21);
  let children;
  let className;
  let onClick;
  let props;
  let style;
  if ($[0] !== t0) {
    ({
      children,
      className,
      onClick,
      style,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = className;
    $[3] = onClick;
    $[4] = props;
    $[5] = style;
  } else {
    children = $[1];
    className = $[2];
    onClick = $[3];
    props = $[4];
    style = $[5];
  }
  let t1;
  if ($[6] !== onClick) {
    t1 = (e) => {
      if (e.key === "Enter" || e.key === " ") {
        onClick?.();
      }
    };
    $[6] = onClick;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  const onKeyPress = t1;
  const t2 = onClick ? "button" : void 0;
  const t3 = onClick ? 0 : void 0;
  const t4 = onClick && cardClickableMixin;
  let t5;
  if ($[8] !== className || $[9] !== t4) {
    t5 = cls(cardMixin, t4, className);
    $[8] = className;
    $[9] = t4;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  let t6;
  if ($[11] !== children || $[12] !== onClick || $[13] !== onKeyPress || $[14] !== props || $[15] !== ref || $[16] !== style || $[17] !== t2 || $[18] !== t3 || $[19] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, onKeyPress, role: t2, tabIndex: t3, onClick, className: t5, style, ...props, children });
    $[11] = children;
    $[12] = onClick;
    $[13] = onKeyPress;
    $[14] = props;
    $[15] = ref;
    $[16] = style;
    $[17] = t2;
    $[18] = t3;
    $[19] = t5;
    $[20] = t6;
  } else {
    t6 = $[20];
  }
  return t6;
});
const containerMaxWidths = {
  xs: "max-w-xs",
  sm: "max-w-sm",
  md: "max-w-md",
  lg: "max-w-lg",
  xl: "max-w-xl",
  "2xl": "max-w-2xl",
  "3xl": "max-w-3xl",
  "4xl": "max-w-4xl",
  "5xl": "max-w-5xl",
  "6xl": "max-w-6xl",
  "7xl": "max-w-7xl"
};
const ContainerInner = (t0, ref) => {
  const $ = c_1(8);
  const {
    children,
    className,
    style,
    maxWidth: t1
  } = t0;
  const maxWidth = t1 === void 0 ? "7xl" : t1;
  const classForMaxWidth = maxWidth ? containerMaxWidths[maxWidth] : "";
  let t2;
  if ($[0] !== classForMaxWidth || $[1] !== className) {
    t2 = cls("mx-auto px-3 md:px-4 lg-px-6", classForMaxWidth, className);
    $[0] = classForMaxWidth;
    $[1] = className;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  let t3;
  if ($[3] !== children || $[4] !== ref || $[5] !== style || $[6] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: t2, style, children });
    $[3] = children;
    $[4] = ref;
    $[5] = style;
    $[6] = t2;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  return t3;
};
const Container = React__default.forwardRef(ContainerInner);
const CenteredView = React__default.forwardRef((t0, ref) => {
  const $ = c_1(21);
  let children;
  let className;
  let fullScreen;
  let maxWidth;
  let outerClassName;
  let rest;
  if ($[0] !== t0) {
    ({
      children,
      maxWidth,
      outerClassName,
      className,
      fullScreen,
      ...rest
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = className;
    $[3] = fullScreen;
    $[4] = maxWidth;
    $[5] = outerClassName;
    $[6] = rest;
  } else {
    children = $[1];
    className = $[2];
    fullScreen = $[3];
    maxWidth = $[4];
    outerClassName = $[5];
    rest = $[6];
  }
  const t1 = fullScreen ? "h-screen" : "h-full";
  let t2;
  if ($[7] !== outerClassName || $[8] !== t1) {
    t2 = cls("flex flex-col flex-grow", t1, outerClassName);
    $[7] = outerClassName;
    $[8] = t1;
    $[9] = t2;
  } else {
    t2 = $[9];
  }
  let t3;
  if ($[10] !== className) {
    t3 = cls("m-auto", className);
    $[10] = className;
    $[11] = t3;
  } else {
    t3 = $[11];
  }
  let t4;
  if ($[12] !== children || $[13] !== maxWidth || $[14] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { className: t3, maxWidth, children });
    $[12] = children;
    $[13] = maxWidth;
    $[14] = t3;
    $[15] = t4;
  } else {
    t4 = $[15];
  }
  let t5;
  if ($[16] !== ref || $[17] !== rest || $[18] !== t2 || $[19] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: t2, ...rest, children: t4 });
    $[16] = ref;
    $[17] = rest;
    $[18] = t2;
    $[19] = t4;
    $[20] = t5;
  } else {
    t5 = $[20];
  }
  return t5;
});
CenteredView.displayName = "CenteredView";
function CircularProgress(t0) {
  const $ = c_1(7);
  const {
    size: t1,
    className
  } = t0;
  const size2 = t1 === void 0 ? "medium" : t1;
  let sizeClasses2;
  if (size2 === "small") {
    sizeClasses2 = "w-4 h-4";
  } else {
    if (size2 === "medium") {
      sizeClasses2 = "w-8 h-8 m-1";
    } else {
      sizeClasses2 = "w-10 h-10 m-1";
    }
  }
  let borderClasses;
  if (size2 === "small") {
    borderClasses = "border-[3px]";
  } else {
    if (size2 === "medium") {
      borderClasses = "border-4";
    } else {
      borderClasses = "border-[6px]";
    }
  }
  let t2;
  if ($[0] !== borderClasses || $[1] !== className || $[2] !== sizeClasses2) {
    t2 = cls(sizeClasses2, borderClasses, "inline-block animate-spin rounded-full border-solid border-current border-r-transparent align-[-0.125em] motion-reduce:animate-[spin_1.5s_linear_infinite]", "text-primary dark:text-primary", className);
    $[0] = borderClasses;
    $[1] = className;
    $[2] = sizeClasses2;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]", children: "Loading..." });
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== t2) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t2, role: "status", children: t3 });
    $[5] = t2;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  return t4;
}
const iconKeys = ["10k", "10mp", "11mp", "123", "12mp", "13mp", "14mp", "15mp", "16mp", "17mp", "18_up_rating", "18mp", "19mp", "1k", "1k_plus", "1x_mobiledata", "20mp", "21mp", "22mp", "23mp", "24mp", "2k", "2k_plus", "2mp", "30fps", "30fps_select", "360", "3d_rotation", "3g_mobiledata", "3k", "3k_plus", "3mp", "3p", "4g_mobiledata", "4g_plus_mobiledata", "4k", "4k_plus", "4mp", "5g", "5k", "5k_plus", "5mp", "60fps", "60fps_select", "6_ft_apart", "6k", "6k_plus", "6mp", "7k", "7k_plus", "7mp", "8k", "8k_plus", "8mp", "9k", "9k_plus", "9mp", "abc", "ac_unit", "access_alarm", "access_alarms", "access_time", "access_time_filled", "accessibility", "accessibility_new", "accessible", "accessible_forward", "account_balance", "account_balance_wallet", "account_box", "account_circle", "account_tree", "ad_units", "adb", "add", "add_a_photo", "add_alarm", "add_alert", "add_box", "add_business", "add_card", "add_chart", "add_circle", "add_circle_outline", "add_comment", "add_home", "add_home_work", "add_ic_call", "add_link", "add_location", "add_location_alt", "add_moderator", "add_photo_alternate", "add_reaction", "add_road", "add_shopping_cart", "add_task", "add_to_drive", "add_to_home_screen", "add_to_photos", "add_to_queue", "addchart", "adf_scanner", "adjust", "admin_panel_settings", "adobe", "ads_click", "agriculture", "air", "airline_seat_flat", "airline_seat_flat_angled", "airline_seat_individual_suite", "airline_seat_legroom_extra", "airline_seat_legroom_normal", "airline_seat_legroom_reduced", "airline_seat_recline_extra", "airline_seat_recline_normal", "airline_stops", "airlines", "airplane_ticket", "airplanemode_active", "airplanemode_inactive", "airplanemode_off", "airplanemode_on", "airplay", "airport_shuttle", "alarm", "alarm_add", "alarm_off", "alarm_on", "album", "align_horizontal_center", "align_horizontal_left", "align_horizontal_right", "align_vertical_bottom", "align_vertical_center", "align_vertical_top", "all_inbox", "all_inclusive", "all_out", "alt_route", "alternate_email", "amp_stories", "analytics", "anchor", "android", "animation", "announcement", "aod", "apartment", "api", "app_blocking", "app_registration", "app_settings_alt", "app_shortcut", "apple", "approval", "apps", "apps_outage", "architecture", "archive", "area_chart", "arrow_back", "arrow_back_ios", "arrow_back_ios_new", "arrow_circle_down", "arrow_circle_left", "arrow_circle_right", "arrow_circle_up", "arrow_downward", "arrow_drop_down", "arrow_drop_down_circle", "arrow_drop_up", "arrow_forward", "arrow_forward_ios", "arrow_left", "arrow_outward", "arrow_right", "arrow_right_alt", "arrow_upward", "art_track", "article", "aspect_ratio", "assessment", "assignment", "assignment_ind", "assignment_late", "assignment_return", "assignment_returned", "assignment_turned_in", "assist_walker", "assistant", "assistant_direction", "assistant_photo", "assured_workload", "atm", "attach_email", "attach_file", "attach_money", "attachment", "attractions", "attribution", "audio_file", "audiotrack", "auto_awesome", "auto_awesome_mosaic", "auto_awesome_motion", "auto_delete", "auto_fix_high", "auto_fix_normal", "auto_fix_off", "auto_graph", "auto_mode", "auto_stories", "autofps_select", "autorenew", "av_timer", "baby_changing_station", "back_hand", "backpack", "backspace", "backup", "backup_table", "badge", "bakery_dining", "balance", "balcony", "ballot", "bar_chart", "batch_prediction", "bathroom", "bathtub", "battery_0_bar", "battery_1_bar", "battery_2_bar", "battery_3_bar", "battery_4_bar", "battery_5_bar", "battery_6_bar", "battery_alert", "battery_charging_full", "battery_full", "battery_saver", "battery_std", "battery_unknown", "beach_access", "bed", "bedroom_baby", "bedroom_child", "bedroom_parent", "bedtime", "bedtime_off", "beenhere", "bento", "bike_scooter", "biotech", "blender", "blind", "blinds", "blinds_closed", "block", "bloodtype", "bluetooth", "bluetooth_audio", "bluetooth_connected", "bluetooth_disabled", "bluetooth_drive", "bluetooth_searching", "blur_circular", "blur_linear", "blur_off", "blur_on", "bolt", "book", "book_online", "bookmark", "bookmark_add", "bookmark_added", "bookmark_border", "bookmark_outline", "bookmark_remove", "bookmarks", "border_all", "border_bottom", "border_clear", "border_color", "border_horizontal", "border_inner", "border_left", "border_outer", "border_right", "border_style", "border_top", "border_vertical", "boy", "branding_watermark", "breakfast_dining", "brightness_1", "brightness_2", "brightness_3", "brightness_4", "brightness_5", "brightness_6", "brightness_7", "brightness_auto", "brightness_high", "brightness_low", "brightness_medium", "broadcast_on_home", "broadcast_on_personal", "broken_image", "browse_gallery", "browser_not_supported", "browser_updated", "brunch_dining", "brush", "bubble_chart", "bug_report", "build", "build_circle", "bungalow", "burst_mode", "bus_alert", "business", "business_center", "cabin", "cable", "cached", "cake", "calculate", "calendar_month", "calendar_today", "calendar_view_day", "calendar_view_month", "calendar_view_week", "call", "call_end", "call_made", "call_merge", "call_missed", "call_missed_outgoing", "call_received", "call_split", "call_to_action", "camera", "camera_alt", "camera_enhance", "camera_front", "camera_indoor", "camera_outdoor", "camera_rear", "camera_roll", "cameraswitch", "campaign", "cancel", "cancel_presentation", "cancel_schedule_send", "candlestick_chart", "car_crash", "car_rental", "car_repair", "card_giftcard", "card_membership", "card_travel", "carpenter", "cases", "casino", "cast", "cast_connected", "cast_for_education", "castle", "catching_pokemon", "category", "celebration", "cell_tower", "cell_wifi", "center_focus_strong", "center_focus_weak", "chair", "chair_alt", "chalet", "change_circle", "change_history", "charging_station", "chat", "chat_bubble", "chat_bubble_outline", "check", "check_box", "check_box_outline_blank", "check_circle", "check_circle_outline", "checklist", "checklist_rtl", "checkroom", "chevron_left", "chevron_right", "child_care", "child_friendly", "chrome_reader_mode", "church", "circle", "circle_notifications", "class", "clean_hands", "cleaning_services", "clear", "clear_all", "close", "close_fullscreen", "closed_caption", "closed_caption_disabled", "closed_caption_off", "cloud", "cloud_circle", "cloud_done", "cloud_download", "cloud_off", "cloud_queue", "cloud_sync", "cloud_upload", "co2", "co_present", "code", "code_off", "coffee", "coffee_maker", "collections", "collections_bookmark", "color_lens", "colorize", "comment", "comment_bank", "comments_disabled", "commit", "commute", "compare", "compare_arrows", "compass_calibration", "compost", "compress", "computer", "confirmation_num", "confirmation_number", "connect_without_contact", "connected_tv", "connecting_airports", "construction", "contact_emergency", "contact_mail", "contact_page", "contact_phone", "contact_support", "contactless", "contacts", "content_copy", "content_cut", "content_paste", "content_paste_go", "content_paste_off", "content_paste_search", "contrast", "control_camera", "control_point", "control_point_duplicate", "cookie", "copy", "copy_all", "copyright", "coronavirus", "corporate_fare", "cottage", "countertops", "create", "create_new_folder", "credit_card", "credit_card_off", "credit_score", "crib", "crisis_alert", "crop", "crop_16_9", "crop_3_2", "crop_5_4", "crop_7_5", "crop_din", "crop_free", "crop_landscape", "crop_original", "crop_portrait", "crop_rotate", "crop_square", "cruelty_free", "css", "currency_bitcoin", "currency_exchange", "currency_franc", "currency_lira", "currency_pound", "currency_ruble", "currency_rupee", "currency_yen", "currency_yuan", "curtains", "curtains_closed", "cut", "cyclone", "dangerous", "dark_mode", "dashboard", "dashboard_customize", "data_array", "data_exploration", "data_object", "data_saver_off", "data_saver_on", "data_thresholding", "data_usage", "dataset", "dataset_linked", "date_range", "deblur", "deck", "dehaze", "delete", "delete_forever", "delete_outline", "delete_sweep", "delivery_dining", "density_large", "density_medium", "density_small", "departure_board", "description", "deselect", "design_services", "desk", "desktop_access_disabled", "desktop_mac", "desktop_windows", "details", "developer_board", "developer_board_off", "developer_mode", "device_hub", "device_thermostat", "device_unknown", "devices", "devices_fold", "devices_other", "dialer_sip", "dialpad", "diamond", "difference", "dining", "dinner_dining", "directions", "directions_bike", "directions_boat", "directions_boat_filled", "directions_bus", "directions_bus_filled", "directions_car", "directions_car_filled", "directions_ferry", "directions_off", "directions_railway", "directions_railway_filled", "directions_run", "directions_subway", "directions_subway_filled", "directions_train", "directions_transit", "directions_transit_filled", "directions_walk", "dirty_lens", "disabled_by_default", "disabled_visible", "disc_full", "discord", "discount", "display_settings", "diversity_1", "diversity_2", "diversity_3", "dnd_forwardslash", "dns", "do_disturb", "do_disturb_alt", "do_disturb_off", "do_disturb_on", "do_not_disturb", "do_not_disturb_alt", "do_not_disturb_off", "do_not_disturb_on", "do_not_disturb_on_total_silence", "do_not_step", "do_not_touch", "dock", "document_scanner", "domain", "domain_add", "domain_disabled", "domain_verification", "done", "done_all", "done_outline", "donut_large", "donut_small", "door_back", "door_front", "door_sliding", "doorbell", "double_arrow", "downhill_skiing", "download", "download_done", "download_for_offline", "downloading", "drafts", "drag_handle", "drag_indicator", "draw", "drive_eta", "drive_file_move", "drive_file_move_rtl", "drive_file_rename_outline", "drive_folder_upload", "dry", "dry_cleaning", "duo", "dvr", "dynamic_feed", "dynamic_form", "e_mobiledata", "earbuds", "earbuds_battery", "east", "eco", "edgesensor_high", "edgesensor_low", "edit", "edit_attributes", "edit_calendar", "edit_location", "edit_location_alt", "edit_note", "edit_notifications", "edit_off", "edit_road", "egg", "egg_alt", "eject", "elderly", "elderly_woman", "electric_bike", "electric_bolt", "electric_car", "electric_meter", "electric_moped", "electric_rickshaw", "electric_scooter", "electrical_services", "elevator", "email", "emergency", "emergency_recording", "emergency_share", "emoji_emotions", "emoji_events", "emoji_flags", "emoji_food_beverage", "emoji_nature", "emoji_objects", "emoji_people", "emoji_symbols", "emoji_transportation", "energy_savings_leaf", "engineering", "enhance_photo_translate", "enhanced_encryption", "equalizer", "error", "error_outline", "escalator", "escalator_warning", "euro", "euro_symbol", "ev_station", "event", "event_available", "event_busy", "event_note", "event_repeat", "event_seat", "exit_to_app", "expand", "expand_circle_down", "expand_less", "expand_more", "explicit", "explore", "explore_off", "exposure", "exposure_minus_1", "exposure_minus_2", "exposure_neg_1", "exposure_neg_2", "exposure_plus_1", "exposure_plus_2", "exposure_zero", "extension", "extension_off", "face", "face_2", "face_3", "face_4", "face_5", "face_6", "face_retouching_natural", "face_retouching_off", "face_unlock", "facebook", "fact_check", "factory", "family_restroom", "fast_forward", "fast_rewind", "fastfood", "favorite", "favorite_border", "favorite_outline", "fax", "featured_play_list", "featured_video", "feed", "feedback", "female", "fence", "festival", "fiber_dvr", "fiber_manual_record", "fiber_new", "fiber_pin", "fiber_smart_record", "file_copy", "file_download", "file_download_done", "file_download_off", "file_open", "file_present", "file_upload", "filter", "filter_1", "filter_2", "filter_3", "filter_4", "filter_5", "filter_6", "filter_7", "filter_8", "filter_9", "filter_9_plus", "filter_alt", "filter_alt_off", "filter_b_and_w", "filter_center_focus", "filter_drama", "filter_frames", "filter_hdr", "filter_list", "filter_list_off", "filter_none", "filter_tilt_shift", "filter_vintage", "find_in_page", "find_replace", "fingerprint", "fire_extinguisher", "fire_hydrant_alt", "fire_truck", "fireplace", "first_page", "fit_screen", "fitbit", "fitness_center", "flag", "flag_circle", "flaky", "flare", "flash_auto", "flash_off", "flash_on", "flashlight_off", "flashlight_on", "flatware", "flight", "flight_class", "flight_land", "flight_takeoff", "flip", "flip_camera_android", "flip_camera_ios", "flip_to_back", "flip_to_front", "flood", "flourescent", "fluorescent", "flutter_dash", "fmd_bad", "fmd_good", "folder", "folder_copy", "folder_delete", "folder_off", "folder_open", "folder_shared", "folder_special", "folder_zip", "follow_the_signs", "font_download", "font_download_off", "food_bank", "forest", "fork_left", "fork_right", "format_align_center", "format_align_justify", "format_align_left", "format_align_right", "format_bold", "format_clear", "format_color_fill", "format_color_reset", "format_color_text", "format_indent_decrease", "format_indent_increase", "format_italic", "format_line_spacing", "format_list_bulleted", "format_list_numbered", "format_list_numbered_rtl", "format_overline", "format_paint", "format_quote", "format_shapes", "format_size", "format_strikethrough", "format_textdirection_l_to_r", "format_textdirection_r_to_l", "format_underline", "format_underlined", "fort", "forum", "forward", "forward_10", "forward_30", "forward_5", "forward_to_inbox", "foundation", "free_breakfast", "free_cancellation", "front_hand", "fullscreen", "fullscreen_exit", "functions", "g_mobiledata", "g_translate", "gamepad", "games", "garage", "gas_meter", "gavel", "generating_tokens", "gesture", "get_app", "gif", "gif_box", "girl", "gite", "golf_course", "gpp_bad", "gpp_good", "gpp_maybe", "gps_fixed", "gps_not_fixed", "gps_off", "grade", "gradient", "grading", "grain", "graphic_eq", "grass", "grid_3x3", "grid_4x4", "grid_goldenratio", "grid_off", "grid_on", "grid_view", "group", "group_add", "group_off", "group_remove", "group_work", "groups", "groups_2", "groups_3", "h_mobiledata", "h_plus_mobiledata", "hail", "handshake", "handyman", "hardware", "hd", "hdr_auto", "hdr_auto_select", "hdr_enhanced_select", "hdr_off", "hdr_off_select", "hdr_on", "hdr_on_select", "hdr_plus", "hdr_strong", "hdr_weak", "headphones", "headphones_battery", "headset", "headset_mic", "headset_off", "healing", "health_and_safety", "hearing", "hearing_disabled", "heart_broken", "heat_pump", "height", "help", "help_center", "help_outline", "hevc", "hexagon", "hide_image", "hide_source", "high_quality", "highlight", "highlight_alt", "highlight_off", "highlight_remove", "hiking", "history", "history_edu", "history_toggle_off", "hive", "hls", "hls_off", "holiday_village", "home", "home_max", "home_mini", "home_repair_service", "home_work", "horizontal_distribute", "horizontal_rule", "horizontal_split", "hot_tub", "hotel", "hotel_class", "hourglass_bottom", "hourglass_disabled", "hourglass_empty", "hourglass_full", "hourglass_top", "house", "house_siding", "houseboat", "how_to_reg", "how_to_vote", "html", "http", "https", "hub", "hvac", "ice_skating", "icecream", "image", "image_aspect_ratio", "image_not_supported", "image_search", "imagesearch_roller", "import_contacts", "import_export", "important_devices", "inbox", "incomplete_circle", "indeterminate_check_box", "info", "info_outline", "input", "insert_chart", "insert_chart_outlined", "insert_comment", "insert_drive_file", "insert_emoticon", "insert_invitation", "insert_link", "insert_page_break", "insert_photo", "insights", "install_desktop", "install_mobile", "integration_instructions", "interests", "interpreter_mode", "inventory", "inventory_2", "invert_colors", "invert_colors_off", "invert_colors_on", "ios_share", "iron", "iso", "javascript", "join_full", "join_inner", "join_left", "join_right", "kayaking", "kebab_dining", "key", "key_off", "keyboard", "keyboard_alt", "keyboard_arrow_down", "keyboard_arrow_left", "keyboard_arrow_right", "keyboard_arrow_up", "keyboard_backspace", "keyboard_capslock", "keyboard_command_key", "keyboard_control", "keyboard_control_key", "keyboard_double_arrow_down", "keyboard_double_arrow_left", "keyboard_double_arrow_right", "keyboard_double_arrow_up", "keyboard_hide", "keyboard_option_key", "keyboard_return", "keyboard_tab", "keyboard_voice", "king_bed", "kitchen", "kitesurfing", "label", "label_important", "label_important_outline", "label_off", "label_outline", "lan", "landscape", "landslide", "language", "laptop", "laptop_chromebook", "laptop_mac", "laptop_windows", "last_page", "launch", "layers", "layers_clear", "leaderboard", "leak_add", "leak_remove", "leave_bags_at_home", "legend_toggle", "lens", "lens_blur", "library_add", "library_add_check", "library_books", "library_music", "light", "light_mode", "lightbulb", "lightbulb_circle", "lightbulb_outline", "line_axis", "line_style", "line_weight", "linear_scale", "link", "link_off", "linked_camera", "liquor", "list", "list_alt", "live_help", "live_tv", "living", "local_activity", "local_airport", "local_atm", "local_attraction", "local_bar", "local_cafe", "local_car_wash", "local_convenience_store", "local_dining", "local_drink", "local_fire_department", "local_florist", "local_gas_station", "local_grocery_store", "local_hospital", "local_hotel", "local_laundry_service", "local_library", "local_mall", "local_movies", "local_offer", "local_parking", "local_pharmacy", "local_phone", "local_pizza", "local_play", "local_police", "local_post_office", "local_print_shop", "local_printshop", "local_restaurant", "local_see", "local_shipping", "local_taxi", "location_city", "location_disabled", "location_history", "location_off", "location_on", "location_searching", "lock", "lock_clock", "lock_open", "lock_outline", "lock_person", "lock_reset", "login", "logo_dev", "logout", "looks", "looks_3", "looks_4", "looks_5", "looks_6", "looks_one", "looks_two", "loop", "loupe", "low_priority", "loyalty", "lte_mobiledata", "lte_plus_mobiledata", "luggage", "lunch_dining", "lyrics", "macro_off", "mail", "mail_lock", "mail_outline", "male", "man", "man_2", "man_3", "man_4", "manage_accounts", "manage_history", "manage_search", "map", "maps_home_work", "maps_ugc", "margin", "mark_as_unread", "mark_chat_read", "mark_chat_unread", "mark_email_read", "mark_email_unread", "mark_unread_chat_alt", "markunread", "markunread_mailbox", "masks", "maximize", "media_bluetooth_off", "media_bluetooth_on", "mediation", "medical_information", "medical_services", "medication", "medication_liquid", "meeting_room", "memory", "menu", "menu_book", "menu_open", "merge", "merge_type", "message", "messenger", "messenger_outline", "mic", "mic_external_off", "mic_external_on", "mic_none", "mic_off", "microwave", "military_tech", "minimize", "minor_crash", "miscellaneous_services", "missed_video_call", "mms", "mobile_friendly", "mobile_off", "mobile_screen_share", "mobiledata_off", "mode", "mode_comment", "mode_edit", "mode_edit_outline", "mode_fan_off", "mode_night", "mode_of_travel", "mode_standby", "model_training", "monetization_on", "money", "money_off", "money_off_csred", "monitor", "monitor_heart", "monitor_weight", "monochrome_photos", "mood", "mood_bad", "moped", "more", "more_horiz", "more_time", "more_vert", "mosque", "motion_photos_auto", "motion_photos_off", "motion_photos_on", "motion_photos_pause", "motion_photos_paused", "motorcycle", "mouse", "move_down", "move_to_inbox", "move_up", "movie", "movie_creation", "movie_filter", "moving", "mp", "multiline_chart", "multiple_stop", "multitrack_audio", "museum", "music_note", "music_off", "music_video", "my_library_add", "my_library_books", "my_library_music", "my_location", "nat", "nature", "nature_people", "navigate_before", "navigate_next", "navigation", "near_me", "near_me_disabled", "nearby_error", "nearby_off", "nest_cam_wired_stand", "network_cell", "network_check", "network_locked", "network_ping", "network_wifi", "network_wifi_1_bar", "network_wifi_2_bar", "network_wifi_3_bar", "new_label", "new_releases", "newspaper", "next_plan", "next_week", "nfc", "night_shelter", "nightlife", "nightlight", "nightlight_round", "nights_stay", "no_accounts", "no_adult_content", "no_backpack", "no_cell", "no_crash", "no_drinks", "no_encryption", "no_encryption_gmailerrorred", "no_flash", "no_food", "no_luggage", "no_meals", "no_meeting_room", "no_photography", "no_sim", "no_stroller", "no_transfer", "noise_aware", "noise_control_off", "nordic_walking", "north", "north_east", "north_west", "not_accessible", "not_interested", "not_listed_location", "not_started", "note", "note_add", "note_alt", "notes", "notification_add", "notification_important", "notifications", "notifications_active", "notifications_none", "notifications_off", "notifications_on", "notifications_paused", "now_wallpaper", "now_widgets", "numbers", "offline_bolt", "offline_pin", "offline_share", "oil_barrel", "on_device_training", "ondemand_video", "online_prediction", "opacity", "open_in_browser", "open_in_full", "open_in_new", "open_in_new_off", "open_with", "other_houses", "outbond", "outbound", "outbox", "outdoor_grill", "outlet", "outlined_flag", "output", "padding", "pages", "pageview", "paid", "palette", "pan_tool", "pan_tool_alt", "panorama", "panorama_fish_eye", "panorama_fisheye", "panorama_horizontal", "panorama_horizontal_select", "panorama_photosphere", "panorama_photosphere_select", "panorama_vertical", "panorama_vertical_select", "panorama_wide_angle", "panorama_wide_angle_select", "paragliding", "park", "party_mode", "password", "paste", "pattern", "pause", "pause_circle", "pause_circle_filled", "pause_circle_outline", "pause_presentation", "payment", "payments", "paypal", "pedal_bike", "pending", "pending_actions", "pentagon", "people", "people_alt", "people_outline", "percent", "perm_camera_mic", "perm_contact_cal", "perm_contact_calendar", "perm_data_setting", "perm_device_info", "perm_device_information", "perm_identity", "perm_media", "perm_phone_msg", "perm_scan_wifi", "person", "person_2", "person_3", "person_4", "person_add", "person_add_alt", "person_add_alt_1", "person_add_disabled", "person_off", "person_outline", "person_pin", "person_pin_circle", "person_remove", "person_remove_alt_1", "person_search", "personal_injury", "personal_video", "pest_control", "pest_control_rodent", "pets", "phishing", "phone", "phone_android", "phone_bluetooth_speaker", "phone_callback", "phone_disabled", "phone_enabled", "phone_forwarded", "phone_in_talk", "phone_iphone", "phone_locked", "phone_missed", "phone_paused", "phonelink", "phonelink_erase", "phonelink_lock", "phonelink_off", "phonelink_ring", "phonelink_setup", "photo", "photo_album", "photo_camera", "photo_camera_back", "photo_camera_front", "photo_filter", "photo_library", "photo_size_select_actual", "photo_size_select_large", "photo_size_select_small", "php", "piano", "piano_off", "picture_as_pdf", "picture_in_picture", "picture_in_picture_alt", "pie_chart", "pie_chart_outline", "pin", "pin_drop", "pin_end", "pin_invoke", "pinch", "pivot_table_chart", "pix", "place", "plagiarism", "play_arrow", "play_circle", "play_circle_fill", "play_circle_filled", "play_circle_outline", "play_disabled", "play_for_work", "play_lesson", "playlist_add", "playlist_add_check", "playlist_add_check_circle", "playlist_add_circle", "playlist_play", "playlist_remove", "plumbing", "plus_one", "podcasts", "point_of_sale", "policy", "poll", "polyline", "polymer", "pool", "portable_wifi_off", "portrait", "post_add", "power", "power_input", "power_off", "power_settings_new", "precision_manufacturing", "pregnant_woman", "present_to_all", "preview", "price_change", "price_check", "print", "print_disabled", "priority_high", "privacy_tip", "private_connectivity", "production_quantity_limits", "propane", "propane_tank", "psychology", "psychology_alt", "public", "public_off", "publish", "published_with_changes", "punch_clock", "push_pin", "qr_code", "qr_code_2", "qr_code_scanner", "query_builder", "query_stats", "question_answer", "question_mark", "queue", "queue_music", "queue_play_next", "quick_contacts_dialer", "quick_contacts_mail", "quickreply", "quiz", "quora", "r_mobiledata", "radar", "radio", "radio_button_checked", "radio_button_off", "radio_button_on", "radio_button_unchecked", "railway_alert", "ramen_dining", "ramp_left", "ramp_right", "rate_review", "raw_off", "raw_on", "read_more", "real_estate_agent", "receipt", "receipt_long", "recent_actors", "recommend", "record_voice_over", "rectangle", "recycling", "reddit", "redeem", "redo", "reduce_capacity", "refresh", "remember_me", "remove", "remove_circle", "remove_circle_outline", "remove_done", "remove_from_queue", "remove_moderator", "remove_red_eye", "remove_road", "remove_shopping_cart", "reorder", "repartition", "repeat", "repeat_on", "repeat_one", "repeat_one_on", "replay", "replay_10", "replay_30", "replay_5", "replay_circle_filled", "reply", "reply_all", "report", "report_gmailerrorred", "report_off", "report_problem", "request_page", "request_quote", "reset_tv", "restart_alt", "restaurant", "restaurant_menu", "restore", "restore_from_trash", "restore_page", "reviews", "rice_bowl", "ring_volume", "rocket", "rocket_launch", "roller_shades", "roller_shades_closed", "roller_skating", "roofing", "room", "room_preferences", "room_service", "rotate_90_degrees_ccw", "rotate_90_degrees_cw", "rotate_left", "rotate_right", "roundabout_left", "roundabout_right", "rounded_corner", "route", "router", "rowing", "rss_feed", "rsvp", "rtt", "rule", "rule_folder", "run_circle", "running_with_errors", "rv_hookup", "safety_check", "safety_divider", "sailing", "sanitizer", "satellite", "satellite_alt", "save", "save_alt", "save_as", "saved_search", "savings", "scale", "scanner", "scatter_plot", "schedule", "schedule_send", "schema", "school", "science", "score", "scoreboard", "screen_lock_landscape", "screen_lock_portrait", "screen_lock_rotation", "screen_rotation", "screen_rotation_alt", "screen_search_desktop", "screen_share", "screenshot", "screenshot_monitor", "scuba_diving", "sd", "sd_card", "sd_card_alert", "sd_storage", "search", "search_off", "security", "security_update", "security_update_good", "security_update_warning", "segment", "select_all", "self_improvement", "sell", "send", "send_and_archive", "send_time_extension", "send_to_mobile", "sensor_door", "sensor_occupied", "sensor_window", "sensors", "sensors_off", "sentiment_dissatisfied", "sentiment_neutral", "sentiment_satisfied", "sentiment_satisfied_alt", "sentiment_very_dissatisfied", "sentiment_very_satisfied", "set_meal", "settings", "settings_accessibility", "settings_applications", "settings_backup_restore", "settings_bluetooth", "settings_brightness", "settings_cell", "settings_display", "settings_ethernet", "settings_input_antenna", "settings_input_component", "settings_input_composite", "settings_input_hdmi", "settings_input_svideo", "settings_overscan", "settings_phone", "settings_power", "settings_remote", "settings_suggest", "settings_system_daydream", "settings_voice", "severe_cold", "shape_line", "share", "share_arrival_time", "share_location", "shield", "shield_moon", "shop", "shop_2", "shop_two", "shopify", "shopping_bag", "shopping_basket", "shopping_cart", "shopping_cart_checkout", "short_text", "shortcut", "show_chart", "shower", "shuffle", "shuffle_on", "shutter_speed", "sick", "sign_language", "signal_cellular_0_bar", "signal_cellular_4_bar", "signal_cellular_alt", "signal_cellular_alt_1_bar", "signal_cellular_alt_2_bar", "signal_cellular_connected_no_internet_0_bar", "signal_cellular_connected_no_internet_4_bar", "signal_cellular_no_sim", "signal_cellular_nodata", "signal_cellular_null", "signal_cellular_off", "signal_wifi_0_bar", "signal_wifi_4_bar", "signal_wifi_4_bar_lock", "signal_wifi_bad", "signal_wifi_connected_no_internet_4", "signal_wifi_off", "signal_wifi_statusbar_4_bar", "signal_wifi_statusbar_connected_no_internet_4", "signal_wifi_statusbar_null", "signpost", "sim_card", "sim_card_alert", "sim_card_download", "single_bed", "sip", "skateboarding", "skip_next", "skip_previous", "sledding", "slideshow", "slow_motion_video", "smart_button", "smart_display", "smart_screen", "smart_toy", "smartphone", "smoke_free", "smoking_rooms", "sms", "sms_failed", "snapchat", "snippet_folder", "snooze", "snowboarding", "snowmobile", "snowshoeing", "soap", "social_distance", "solar_power", "sort", "sort_by_alpha", "sos", "soup_kitchen", "source", "south", "south_america", "south_east", "south_west", "spa", "space_bar", "space_dashboard", "spatial_audio", "spatial_audio_off", "spatial_tracking", "speaker", "speaker_group", "speaker_notes", "speaker_notes_off", "speaker_phone", "speed", "spellcheck", "splitscreen", "spoke", "sports", "sports_bar", "sports_baseball", "sports_basketball", "sports_cricket", "sports_esports", "sports_football", "sports_golf", "sports_gymnastics", "sports_handball", "sports_hockey", "sports_kabaddi", "sports_martial_arts", "sports_mma", "sports_motorsports", "sports_rugby", "sports_score", "sports_soccer", "sports_tennis", "sports_volleyball", "square", "square_foot", "ssid_chart", "stacked_bar_chart", "stacked_line_chart", "stadium", "stairs", "star", "star_border", "star_border_purple500", "star_half", "star_outline", "star_purple500", "star_rate", "stars", "start", "stay_current_landscape", "stay_current_portrait", "stay_primary_landscape", "stay_primary_portrait", "sticky_note_2", "stop", "stop_circle", "stop_screen_share", "storage", "store", "store_mall_directory", "storefront", "storm", "straight", "straighten", "stream", "streetview", "strikethrough_s", "stroller", "style", "subdirectory_arrow_left", "subdirectory_arrow_right", "subject", "subscript", "subscriptions", "subtitles", "subtitles_off", "subway", "summarize", "superscript", "supervised_user_circle", "supervisor_account", "support", "support_agent", "surfing", "surround_sound", "swap_calls", "swap_horiz", "swap_horizontal_circle", "swap_vert", "swap_vert_circle", "swap_vertical_circle", "swipe", "swipe_down", "swipe_down_alt", "swipe_left", "swipe_left_alt", "swipe_right", "swipe_right_alt", "swipe_up", "swipe_up_alt", "swipe_vertical", "switch_access_shortcut", "switch_access_shortcut_add", "switch_account", "switch_camera", "switch_left", "switch_right", "switch_video", "synagogue", "sync", "sync_alt", "sync_disabled", "sync_lock", "sync_problem", "system_security_update", "system_security_update_good", "system_security_update_warning", "system_update", "system_update_alt", "system_update_tv", "tab", "tab_unselected", "table_bar", "table_chart", "table_restaurant", "table_rows", "table_view", "tablet", "tablet_android", "tablet_mac", "tag", "tag_faces", "takeout_dining", "tap_and_play", "tapas", "task", "task_alt", "taxi_alert", "telegram", "temple_buddhist", "temple_hindu", "terminal", "terrain", "text_decrease", "text_fields", "text_format", "text_increase", "text_rotate_up", "text_rotate_vertical", "text_rotation_angledown", "text_rotation_angleup", "text_rotation_down", "text_rotation_none", "text_snippet", "textsms", "texture", "theater_comedy", "theaters", "thermostat", "thermostat_auto", "thumb_down", "thumb_down_alt", "thumb_down_off_alt", "thumb_up", "thumb_up_alt", "thumb_up_off_alt", "thumbs_up_down", "thunderstorm", "tiktok", "time_to_leave", "timelapse", "timeline", "timer", "timer_10", "timer_10_select", "timer_3", "timer_3_select", "timer_off", "tips_and_updates", "tire_repair", "title", "toc", "today", "toggle_off", "toggle_on", "token", "toll", "tonality", "topic", "tornado", "touch_app", "tour", "toys", "track_changes", "traffic", "train", "tram", "transcribe", "transfer_within_a_station", "transform", "transgender", "transit_enterexit", "translate", "travel_explore", "trending_down", "trending_flat", "trending_neutral", "trending_up", "trip_origin", "troubleshoot", "try", "tsunami", "tty", "tune", "tungsten", "turn_left", "turn_right", "turn_sharp_left", "turn_sharp_right", "turn_slight_left", "turn_slight_right", "turned_in", "turned_in_not", "tv", "tv_off", "two_wheeler", "type_specimen", "u_turn_left", "u_turn_right", "umbrella", "unarchive", "undo", "unfold_less", "unfold_less_double", "unfold_more", "unfold_more_double", "unpublished", "unsubscribe", "upcoming", "update", "update_disabled", "upgrade", "upload", "upload_file", "usb", "usb_off", "vaccines", "vape_free", "vaping_rooms", "verified", "verified_user", "vertical_align_bottom", "vertical_align_center", "vertical_align_top", "vertical_distribute", "vertical_shades", "vertical_shades_closed", "vertical_split", "vibration", "video_call", "video_camera_back", "video_camera_front", "video_chat", "video_collection", "video_file", "video_label", "video_library", "video_settings", "video_stable", "videocam", "videocam_off", "videogame_asset", "videogame_asset_off", "view_agenda", "view_array", "view_carousel", "view_column", "view_comfortable", "view_comfy", "view_comfy_alt", "view_compact", "view_compact_alt", "view_cozy", "view_day", "view_headline", "view_in_ar", "view_kanban", "view_list", "view_module", "view_quilt", "view_sidebar", "view_stream", "view_timeline", "view_week", "vignette", "villa", "visibility", "visibility_off", "voice_chat", "voice_over_off", "voicemail", "volcano", "volume_down", "volume_mute", "volume_off", "volume_up", "volunteer_activism", "vpn_key", "vpn_key_off", "vpn_lock", "vrpano", "wallet", "wallet_giftcard", "wallet_membership", "wallet_travel", "wallpaper", "warehouse", "warning", "warning_amber", "wash", "watch", "watch_later", "watch_off", "water", "water_damage", "water_drop", "waterfall_chart", "waves", "waving_hand", "wb_auto", "wb_cloudy", "wb_incandescent", "wb_iridescent", "wb_shade", "wb_sunny", "wb_twilight", "wc", "web", "web_asset", "web_asset_off", "web_stories", "webhook", "wechat", "weekend", "west", "whatshot", "wheelchair_pickup", "where_to_vote", "widgets", "width_full", "width_normal", "width_wide", "wifi", "wifi_1_bar", "wifi_2_bar", "wifi_calling", "wifi_calling_3", "wifi_channel", "wifi_find", "wifi_lock", "wifi_off", "wifi_password", "wifi_protected_setup", "wifi_tethering", "wifi_tethering_error", "wifi_tethering_error_rounded", "wifi_tethering_off", "wind_power", "window", "wine_bar", "woman", "woman_2", "woo_commerce", "wordpress", "work", "work_history", "work_off", "work_outline", "workspace_premium", "workspaces", "wrap_text", "wrong_location", "wysiwyg", "yard", "youtube_searched_for", "zoom_in", "zoom_in_map", "zoom_out", "zoom_out_map", ""];
const coolIconKeys = ["table_rows", "video_label", "airlines", "bento", "border_all", "border_clear", "ac_unit", "adjust", "align_horizontal_center", "album", "all_inclusive", "all_out", "animation", "assistant", "audiotrack", "account_balance_wallet", "auto_awesome_mosaic", "bolt", "brightness_1", "breakfast_dining", "broken_image", "brightness_5", "cable", "calendar_view_month", "casino", "category", "cloud", "color_lens", "credit_card", "earbuds", "egg_alt", "fiber_smart_record", "flag", "healing", "heat_pump", "hive", "hub", "local_library", "local_pizza", "memory", "outlet", "pages", "panorama_photosphere", "signal_cellular_0_bar", "sports_baseball", "storm", "stairs", "keyboard_command_key"];
const colorClassesMapping = {
  inherit: "",
  primary: "text-primary",
  success: "text-green-500",
  warning: "text-yellow-500",
  secondary: "text-secondary",
  disabled: "text-text-disabled dark:text-text-disabled-dark",
  error: "text-red-500"
};
const Icon = React.forwardRef((t0, ref) => {
  const $ = c_1(12);
  const {
    iconKey,
    size: t1,
    color,
    className,
    onClick,
    style
  } = t0;
  const size2 = t1 === void 0 ? "medium" : t1;
  let sizeInPx;
  bb0: switch (size2) {
    case "smallest": {
      sizeInPx = 16;
      break bb0;
    }
    case "small": {
      sizeInPx = 20;
      break bb0;
    }
    case "medium": {
      sizeInPx = 24;
      break bb0;
    }
    case "large": {
      sizeInPx = 28;
      break bb0;
    }
    default: {
      sizeInPx = typeof size2 === "number" ? size2 : 24;
    }
  }
  const t2 = `${sizeInPx}px`;
  let t3;
  if ($[0] !== style || $[1] !== t2) {
    t3 = {
      fontSize: t2,
      ...style
    };
    $[0] = style;
    $[1] = t2;
    $[2] = t3;
  } else {
    t3 = $[2];
  }
  const t4 = color ? colorClassesMapping[color] : "";
  let t5;
  if ($[3] !== className || $[4] !== t4) {
    t5 = cls("material-icons", "block", t4, "select-none", className);
    $[3] = className;
    $[4] = t4;
    $[5] = t5;
  } else {
    t5 = $[5];
  }
  let t6;
  if ($[6] !== iconKey || $[7] !== onClick || $[8] !== ref || $[9] !== t3 || $[10] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", { ref, style: t3, className: t5, onClick, children: iconKey });
    $[6] = iconKey;
    $[7] = onClick;
    $[8] = ref;
    $[9] = t3;
    $[10] = t5;
    $[11] = t6;
  } else {
    t6 = $[11];
  }
  return t6;
});
Icon.displayName = "Icon";
function GitHubIcon(props) {
  const $ = c_1(5);
  const t0 = props.size ?? 24;
  const t1 = props.size ?? 24;
  let t2;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z" });
    $[0] = t2;
  } else {
    t2 = $[0];
  }
  let t3;
  if ($[1] !== props.className || $[2] !== t0 || $[3] !== t1) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: props.className, fill: "currentColor", width: t0, height: t1, viewBox: "0 0 24 24", children: t2 });
    $[1] = props.className;
    $[2] = t0;
    $[3] = t1;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  return t3;
}
function HandleIcon() {
  const $ = c_1(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "24", height: "24", viewBox: "0 0 100 100", fill: "none", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "28", cy: "50", r: "9", fill: "currentColor" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "28", cy: "21", r: "9", fill: "currentColor" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "71", cy: "21", r: "9", fill: "currentColor" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "71", cy: "50", r: "9", fill: "currentColor" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "71", cy: "78", r: "9", fill: "currentColor" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "28", cy: "78", r: "9", fill: "currentColor" })
    ] });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
function _10kIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "10k" });
}
function _10mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "10mp" });
}
function _11mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "11mp" });
}
function _123Icon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "123" });
}
function _12mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "12mp" });
}
function _13mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "13mp" });
}
function _14mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "14mp" });
}
function _15mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "15mp" });
}
function _16mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "16mp" });
}
function _17mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "17mp" });
}
function _18UpRatingIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "18_up_rating" });
}
function _18mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "18mp" });
}
function _19mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "19mp" });
}
function _1kIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "1k" });
}
function _1kPlusIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "1k_plus" });
}
function _1xMobiledataIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "1x_mobiledata" });
}
function _20mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "20mp" });
}
function _21mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "21mp" });
}
function _22mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "22mp" });
}
function _23mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "23mp" });
}
function _24mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "24mp" });
}
function _2kIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "2k" });
}
function _2kPlusIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "2k_plus" });
}
function _2mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "2mp" });
}
function _30fpsIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "30fps" });
}
function _30fpsSelectIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "30fps_select" });
}
function _360Icon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "360" });
}
function _3dRotationIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "3d_rotation" });
}
function _3gMobiledataIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "3g_mobiledata" });
}
function _3kIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "3k" });
}
function _3kPlusIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "3k_plus" });
}
function _3mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "3mp" });
}
function _3pIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "3p" });
}
function _4gMobiledataIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "4g_mobiledata" });
}
function _4gPlusMobiledataIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "4g_plus_mobiledata" });
}
function _4kIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "4k" });
}
function _4kPlusIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "4k_plus" });
}
function _4mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "4mp" });
}
function _5gIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "5g" });
}
function _5kIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "5k" });
}
function _5kPlusIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "5k_plus" });
}
function _5mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "5mp" });
}
function _60fpsIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "60fps" });
}
function _60fpsSelectIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "60fps_select" });
}
function _6FtApartIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "6_ft_apart" });
}
function _6kIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "6k" });
}
function _6kPlusIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "6k_plus" });
}
function _6mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "6mp" });
}
function _7kIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "7k" });
}
function _7kPlusIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "7k_plus" });
}
function _7mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "7mp" });
}
function _8kIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "8k" });
}
function _8kPlusIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "8k_plus" });
}
function _8mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "8mp" });
}
function _9kIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "9k" });
}
function _9kPlusIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "9k_plus" });
}
function _9mpIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "9mp" });
}
function AbcIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "abc" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AcUnitIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "ac_unit" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AccessAlarmIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "access_alarm" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AccessAlarmsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "access_alarms" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AccessTimeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "access_time" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AccessTimeFilledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "access_time_filled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AccessibilityIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "accessibility" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AccessibilityNewIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "accessibility_new" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AccessibleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "accessible" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AccessibleForwardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "accessible_forward" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AccountBalanceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "account_balance" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AccountBalanceWalletIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "account_balance_wallet" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AccountBoxIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "account_box" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AccountCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "account_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AccountTreeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "account_tree" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AdUnitsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "ad_units" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AdbIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "adb" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddAPhotoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_a_photo" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddAlarmIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_alarm" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddAlertIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_alert" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddBoxIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_box" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddBusinessIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_business" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddCardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_card" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddChartIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "addchart" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddCircleOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_circle_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddCommentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_comment" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddHomeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_home" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddHomeWorkIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_home_work" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddIcCallIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_ic_call" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddLinkIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_link" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddLocationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_location" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddLocationAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_location_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddModeratorIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_moderator" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddPhotoAlternateIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_photo_alternate" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddReactionIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_reaction" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddRoadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_road" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddShoppingCartIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_shopping_cart" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddTaskIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_task" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddToDriveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_to_drive" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddToHomeScreenIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_to_home_screen" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddToPhotosIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_to_photos" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AddToQueueIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "add_to_queue" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AdfScannerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "adf_scanner" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AdjustIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "adjust" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AdminPanelSettingsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "admin_panel_settings" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AdobeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "adobe" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AdsClickIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "ads_click" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AgricultureIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "agriculture" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AirIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "air" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AirlineSeatFlatIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "airline_seat_flat" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AirlineSeatFlatAngledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "airline_seat_flat_angled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AirlineSeatIndividualSuiteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "airline_seat_individual_suite" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AirlineSeatLegroomExtraIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "airline_seat_legroom_extra" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AirlineSeatLegroomNormalIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "airline_seat_legroom_normal" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AirlineSeatLegroomReducedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "airline_seat_legroom_reduced" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AirlineSeatReclineExtraIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "airline_seat_recline_extra" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AirlineSeatReclineNormalIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "airline_seat_recline_normal" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AirlineStopsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "airline_stops" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AirlinesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "airlines" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AirplaneTicketIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "airplane_ticket" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AirplanemodeActiveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "airplanemode_active" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AirplanemodeInactiveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "airplanemode_inactive" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AirplanemodeOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "airplanemode_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AirplanemodeOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "airplanemode_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AirplayIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "airplay" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AirportShuttleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "airport_shuttle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AlarmIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "alarm" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AlarmAddIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "alarm_add" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AlarmOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "alarm_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AlarmOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "alarm_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AlbumIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "album" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AlignHorizontalCenterIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "align_horizontal_center" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AlignHorizontalLeftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "align_horizontal_left" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AlignHorizontalRightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "align_horizontal_right" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AlignVerticalBottomIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "align_vertical_bottom" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AlignVerticalCenterIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "align_vertical_center" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AlignVerticalTopIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "align_vertical_top" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AllInboxIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "all_inbox" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AllInclusiveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "all_inclusive" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AllOutIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "all_out" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AltRouteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "alt_route" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AlternateEmailIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "alternate_email" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AmpStoriesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "amp_stories" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AnalyticsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "analytics" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AnchorIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "anchor" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AndroidIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "android" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AnimationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "animation" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AnnouncementIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "announcement" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AodIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "aod" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ApartmentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "apartment" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ApiIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "api" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AppBlockingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "app_blocking" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AppRegistrationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "app_registration" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AppSettingsAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "app_settings_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AppShortcutIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "app_shortcut" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AppleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "apple" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ApprovalIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "approval" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AppsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "apps" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AppsOutageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "apps_outage" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArchitectureIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "architecture" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArchiveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "archive" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AreaChartIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "area_chart" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArrowBackIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "arrow_back" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArrowBackIosIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "arrow_back_ios" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArrowBackIosNewIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "arrow_back_ios_new" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArrowCircleDownIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "arrow_circle_down" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArrowCircleLeftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "arrow_circle_left" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArrowCircleRightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "arrow_circle_right" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArrowCircleUpIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "arrow_circle_up" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArrowDownwardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "arrow_downward" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArrowDropDownIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "arrow_drop_down" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArrowDropDownCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "arrow_drop_down_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArrowDropUpIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "arrow_drop_up" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArrowForwardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "arrow_forward" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArrowForwardIosIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "arrow_forward_ios" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArrowLeftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "arrow_left" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArrowOutwardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "arrow_outward" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArrowRightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "arrow_right" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArrowRightAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "arrow_right_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArrowUpwardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "arrow_upward" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArtTrackIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "art_track" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ArticleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "article" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AspectRatioIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "aspect_ratio" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AssessmentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "assessment" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AssignmentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "assignment" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AssignmentIndIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "assignment_ind" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AssignmentLateIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "assignment_late" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AssignmentReturnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "assignment_return" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AssignmentReturnedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "assignment_returned" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AssignmentTurnedInIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "assignment_turned_in" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AssistWalkerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "assist_walker" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AssistantIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "assistant" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AssistantDirectionIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "assistant_direction" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AssistantPhotoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "assistant_photo" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AssuredWorkloadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "assured_workload" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AtmIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "atm" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AttachEmailIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "attach_email" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AttachFileIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "attach_file" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AttachMoneyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "attach_money" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AttachmentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "attachment" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AttractionsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "attractions" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AttributionIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "attribution" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AudioFileIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "audio_file" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AudiotrackIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "audiotrack" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AutoAwesomeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "auto_awesome" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AutoAwesomeMosaicIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "auto_awesome_mosaic" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AutoAwesomeMotionIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "auto_awesome_motion" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AutoDeleteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "auto_delete" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AutoFixHighIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "auto_fix_high" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AutoFixNormalIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "auto_fix_normal" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AutoFixOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "auto_fix_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AutoGraphIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "auto_graph" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AutoModeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "auto_mode" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AutoStoriesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "auto_stories" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AutofpsSelectIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "autofps_select" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AutorenewIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "autorenew" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function AvTimerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "av_timer" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BabyChangingStationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "baby_changing_station" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BackHandIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "back_hand" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BackpackIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "backpack" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BackspaceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "backspace" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BackupIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "backup" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BackupTableIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "backup_table" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BadgeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "badge" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BakeryDiningIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bakery_dining" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BalanceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "balance" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BalconyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "balcony" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BallotIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "ballot" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BarChartIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bar_chart" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BatchPredictionIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "batch_prediction" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BathroomIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bathroom" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BathtubIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bathtub" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Battery0BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "battery_0_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Battery1BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "battery_1_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Battery2BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "battery_2_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Battery3BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "battery_3_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Battery4BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "battery_4_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Battery5BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "battery_5_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Battery6BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "battery_6_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BatteryAlertIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "battery_alert" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BatteryChargingFullIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "battery_charging_full" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BatteryFullIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "battery_full" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BatterySaverIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "battery_saver" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BatteryStdIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "battery_std" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BatteryUnknownIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "battery_unknown" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BeachAccessIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "beach_access" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bed" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BedroomBabyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bedroom_baby" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BedroomChildIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bedroom_child" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BedroomParentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bedroom_parent" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BedtimeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bedtime" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BedtimeOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bedtime_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BeenhereIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "beenhere" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BentoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bento" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BikeScooterIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bike_scooter" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BiotechIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "biotech" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BlenderIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "blender" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BlindIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "blind" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BlindsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "blinds" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BlindsClosedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "blinds_closed" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BlockIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "block" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BloodtypeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bloodtype" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BluetoothIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bluetooth" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BluetoothAudioIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bluetooth_audio" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BluetoothConnectedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bluetooth_connected" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BluetoothDisabledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bluetooth_disabled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BluetoothDriveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bluetooth_drive" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BluetoothSearchingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bluetooth_searching" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BlurCircularIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "blur_circular" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BlurLinearIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "blur_linear" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BlurOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "blur_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BlurOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "blur_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BoltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bolt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BookIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "book" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BookOnlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "book_online" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BookmarkIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bookmark" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BookmarkAddIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bookmark_add" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BookmarkAddedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bookmark_added" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BookmarkBorderIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bookmark_border" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BookmarkOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bookmark_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BookmarkRemoveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bookmark_remove" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BookmarksIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bookmarks" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BorderAllIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "border_all" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BorderBottomIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "border_bottom" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BorderClearIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "border_clear" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BorderColorIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "border_color" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BorderHorizontalIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "border_horizontal" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BorderInnerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "border_inner" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BorderLeftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "border_left" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BorderOuterIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "border_outer" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BorderRightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "border_right" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BorderStyleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "border_style" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BorderTopIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "border_top" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BorderVerticalIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "border_vertical" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BoyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "boy" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BrandingWatermarkIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "branding_watermark" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BreakfastDiningIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "breakfast_dining" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Brightness1Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "brightness_1" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Brightness2Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "brightness_2" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Brightness3Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "brightness_3" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Brightness4Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "brightness_4" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Brightness5Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "brightness_5" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Brightness6Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "brightness_6" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Brightness7Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "brightness_7" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BrightnessAutoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "brightness_auto" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BrightnessHighIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "brightness_high" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BrightnessLowIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "brightness_low" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BrightnessMediumIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "brightness_medium" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BroadcastOnHomeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "broadcast_on_home" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BroadcastOnPersonalIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "broadcast_on_personal" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BrokenImageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "broken_image" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BrowseGalleryIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "browse_gallery" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BrowserNotSupportedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "browser_not_supported" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BrowserUpdatedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "browser_updated" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BrunchDiningIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "brunch_dining" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BrushIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "brush" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BubbleChartIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bubble_chart" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BugReportIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bug_report" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BuildIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "build" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BuildCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "build_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BungalowIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bungalow" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BurstModeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "burst_mode" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BusAlertIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "bus_alert" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BusinessIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "business" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function BusinessCenterIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "business_center" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CabinIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cabin" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CableIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cable" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CachedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cached" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CakeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cake" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CalculateIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "calculate" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CalendarMonthIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "calendar_month" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CalendarTodayIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "calendar_today" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CalendarViewDayIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "calendar_view_day" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CalendarViewMonthIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "calendar_view_month" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CalendarViewWeekIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "calendar_view_week" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CallIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "call" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CallEndIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "call_end" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CallMadeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "call_made" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CallMergeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "call_merge" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CallMissedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "call_missed" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CallMissedOutgoingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "call_missed_outgoing" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CallReceivedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "call_received" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CallSplitIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "call_split" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CallToActionIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "call_to_action" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CameraIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "camera" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CameraAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "camera_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CameraEnhanceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "camera_enhance" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CameraFrontIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "camera_front" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CameraIndoorIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "camera_indoor" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CameraOutdoorIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "camera_outdoor" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CameraRearIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "camera_rear" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CameraRollIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "camera_roll" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CameraswitchIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cameraswitch" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CampaignIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "campaign" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CancelIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cancel" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CancelPresentationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cancel_presentation" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CancelScheduleSendIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cancel_schedule_send" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CandlestickChartIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "candlestick_chart" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CarCrashIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "car_crash" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CarRentalIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "car_rental" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CarRepairIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "car_repair" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CardGiftcardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "card_giftcard" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CardMembershipIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "card_membership" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CardTravelIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "card_travel" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CarpenterIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "carpenter" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CasesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cases" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CasinoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "casino" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CastIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cast" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CastConnectedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cast_connected" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CastForEducationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cast_for_education" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CastleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "castle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CatchingPokemonIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "catching_pokemon" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CategoryIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "category" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CelebrationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "celebration" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CellTowerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cell_tower" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CellWifiIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cell_wifi" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CenterFocusStrongIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "center_focus_strong" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CenterFocusWeakIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "center_focus_weak" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ChairIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "chair" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ChairAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "chair_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ChaletIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "chalet" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ChangeCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "change_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ChangeHistoryIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "change_history" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ChargingStationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "charging_station" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ChatIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "chat" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ChatBubbleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "chat_bubble" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ChatBubbleOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "chat_bubble_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CheckIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "check" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CheckBoxIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "check_box" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CheckBoxOutlineBlankIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "check_box_outline_blank" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CheckCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "check_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CheckCircleOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "check_circle_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ChecklistIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "checklist" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ChecklistRtlIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "checklist_rtl" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CheckroomIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "checkroom" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ChevronLeftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "chevron_left" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ChevronRightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "chevron_right" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ChildCareIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "child_care" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ChildFriendlyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "child_friendly" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ChromeReaderModeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "chrome_reader_mode" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ChurchIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "church" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CircleNotificationsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "circle_notifications" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ClassIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "class" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CleanHandsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "clean_hands" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CleaningServicesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cleaning_services" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ClearIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "clear" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ClearAllIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "clear_all" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CloseIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "close" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CloseFullscreenIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "close_fullscreen" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ClosedCaptionIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "closed_caption" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ClosedCaptionDisabledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "closed_caption_disabled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ClosedCaptionOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "closed_caption_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CloudIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cloud" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CloudCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cloud_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CloudDoneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cloud_done" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CloudDownloadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cloud_download" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CloudOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cloud_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CloudQueueIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cloud_queue" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CloudSyncIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cloud_sync" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CloudUploadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cloud_upload" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Co2Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "co2" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CoPresentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "co_present" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CodeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "code" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CodeOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "code_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CoffeeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "coffee" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CoffeeMakerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "coffee_maker" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CollectionsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "collections" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CollectionsBookmarkIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "collections_bookmark" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ColorLensIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "color_lens" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ColorizeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "colorize" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CommentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "comment" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CommentBankIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "comment_bank" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CommentsDisabledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "comments_disabled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CommitIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "commit" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CommuteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "commute" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CompareIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "compare" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CompareArrowsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "compare_arrows" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CompassCalibrationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "compass_calibration" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CompostIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "compost" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CompressIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "compress" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ComputerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "computer" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ConfirmationNumIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "confirmation_num" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ConfirmationNumberIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "confirmation_number" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ConnectWithoutContactIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "connect_without_contact" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ConnectedTvIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "connected_tv" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ConnectingAirportsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "connecting_airports" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ConstructionIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "construction" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ContactEmergencyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "contact_emergency" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ContactMailIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "contact_mail" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ContactPageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "contact_page" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ContactPhoneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "contact_phone" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ContactSupportIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "contact_support" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ContactlessIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "contactless" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ContactsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "contacts" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ContentCopyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "content_copy" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ContentCutIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "content_cut" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ContentPasteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "content_paste" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ContentPasteGoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "content_paste_go" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ContentPasteOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "content_paste_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ContentPasteSearchIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "content_paste_search" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ContrastIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "contrast" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ControlCameraIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "control_camera" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ControlPointIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "control_point" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ControlPointDuplicateIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "control_point_duplicate" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CookieIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cookie" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CopyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "copy" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CopyAllIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "copy_all" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CopyrightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "copyright" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CoronavirusIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "coronavirus" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CorporateFareIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "corporate_fare" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CottageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cottage" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CountertopsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "countertops" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CreateIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "create" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CreateNewFolderIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "create_new_folder" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CreditCardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "credit_card" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CreditCardOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "credit_card_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CreditScoreIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "credit_score" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CribIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "crib" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CrisisAlertIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "crisis_alert" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CropIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "crop" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Crop169Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "crop_16_9" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Crop32Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "crop_3_2" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Crop54Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "crop_5_4" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Crop75Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "crop_7_5" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CropDinIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "crop_din" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CropFreeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "crop_free" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CropLandscapeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "crop_landscape" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CropOriginalIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "crop_original" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CropPortraitIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "crop_portrait" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CropRotateIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "crop_rotate" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CropSquareIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "crop_square" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CrueltyFreeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cruelty_free" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CssIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "css" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CurrencyBitcoinIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "currency_bitcoin" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CurrencyExchangeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "currency_exchange" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CurrencyFrancIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "currency_franc" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CurrencyLiraIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "currency_lira" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CurrencyPoundIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "currency_pound" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CurrencyRubleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "currency_ruble" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CurrencyRupeeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "currency_rupee" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CurrencyYenIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "currency_yen" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CurrencyYuanIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "currency_yuan" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CurtainsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "curtains" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CurtainsClosedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "curtains_closed" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CutIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cut" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function CycloneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "cyclone" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DangerousIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "dangerous" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DarkModeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "dark_mode" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DashboardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "dashboard" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DashboardCustomizeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "dashboard_customize" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DataArrayIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "data_array" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DataExplorationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "data_exploration" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DataObjectIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "data_object" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DataSaverOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "data_saver_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DataSaverOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "data_saver_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DataThresholdingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "data_thresholding" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DataUsageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "data_usage" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DatasetIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "dataset" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DatasetLinkedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "dataset_linked" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DateRangeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "date_range" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DeblurIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "deblur" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DeckIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "deck" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DehazeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "dehaze" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DeleteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "delete" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DeleteForeverIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "delete_forever" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DeleteOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "delete_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DeleteSweepIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "delete_sweep" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DeliveryDiningIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "delivery_dining" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DensityLargeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "density_large" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DensityMediumIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "density_medium" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DensitySmallIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "density_small" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DepartureBoardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "departure_board" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DescriptionIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "description" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DeselectIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "deselect" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DesignServicesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "design_services" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DeskIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "desk" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DesktopAccessDisabledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "desktop_access_disabled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DesktopMacIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "desktop_mac" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DesktopWindowsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "desktop_windows" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DetailsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "details" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DeveloperBoardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "developer_board" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DeveloperBoardOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "developer_board_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DeveloperModeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "developer_mode" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DeviceHubIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "device_hub" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DeviceThermostatIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "device_thermostat" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DeviceUnknownIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "device_unknown" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DevicesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "devices" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DevicesFoldIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "devices_fold" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DevicesOtherIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "devices_other" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DialerSipIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "dialer_sip" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DialpadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "dialpad" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DiamondIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "diamond" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DifferenceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "difference" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DiningIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "dining" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DinnerDiningIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "dinner_dining" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DirectionsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "directions" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DirectionsBikeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "directions_bike" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DirectionsBoatIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "directions_boat" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DirectionsBoatFilledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "directions_boat_filled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DirectionsBusIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "directions_bus" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DirectionsBusFilledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "directions_bus_filled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DirectionsCarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "directions_car" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DirectionsCarFilledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "directions_car_filled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DirectionsFerryIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "directions_ferry" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DirectionsOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "directions_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DirectionsRailwayIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "directions_railway" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DirectionsRailwayFilledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "directions_railway_filled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DirectionsRunIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "directions_run" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DirectionsSubwayIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "directions_subway" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DirectionsSubwayFilledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "directions_subway_filled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DirectionsTrainIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "directions_train" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DirectionsTransitIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "directions_transit" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DirectionsTransitFilledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "directions_transit_filled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DirectionsWalkIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "directions_walk" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DirtyLensIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "dirty_lens" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DisabledByDefaultIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "disabled_by_default" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DisabledVisibleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "disabled_visible" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DiscFullIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "disc_full" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DiscordIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "discord" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DiscountIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "discount" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DisplaySettingsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "display_settings" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Diversity1Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "diversity_1" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Diversity2Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "diversity_2" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Diversity3Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "diversity_3" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DndForwardslashIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "dnd_forwardslash" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DnsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "dns" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DoDisturbIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "do_disturb" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DoDisturbAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "do_disturb_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DoDisturbOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "do_disturb_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DoDisturbOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "do_disturb_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DoNotDisturbIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "do_not_disturb" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DoNotDisturbAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "do_not_disturb_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DoNotDisturbOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "do_not_disturb_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DoNotDisturbOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "do_not_disturb_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DoNotDisturbOnTotalSilenceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "do_not_disturb_on_total_silence" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DoNotStepIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "do_not_step" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DoNotTouchIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "do_not_touch" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DockIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "dock" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DocumentScannerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "document_scanner" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DomainIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "domain" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DomainAddIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "domain_add" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DomainDisabledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "domain_disabled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DomainVerificationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "domain_verification" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DoneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "done" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DoneAllIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "done_all" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DoneOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "done_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DonutLargeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "donut_large" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DonutSmallIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "donut_small" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DoorBackIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "door_back" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DoorFrontIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "door_front" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DoorSlidingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "door_sliding" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DoorbellIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "doorbell" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DoubleArrowIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "double_arrow" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DownhillSkiingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "downhill_skiing" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DownloadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "download" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DownloadDoneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "download_done" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DownloadForOfflineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "download_for_offline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DownloadingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "downloading" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DraftsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "drafts" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DragHandleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "drag_handle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DragIndicatorIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "drag_indicator" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DrawIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "draw" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DriveEtaIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "drive_eta" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DriveFileMoveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "drive_file_move" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DriveFileMoveRtlIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "drive_file_move_rtl" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DriveFileRenameOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "drive_file_rename_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DriveFolderUploadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "drive_folder_upload" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DryIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "dry" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DryCleaningIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "dry_cleaning" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DuoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "duo" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DvrIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "dvr" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DynamicFeedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "dynamic_feed" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DynamicFormIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "dynamic_form" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EMobiledataIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "e_mobiledata" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EarbudsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "earbuds" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EarbudsBatteryIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "earbuds_battery" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EastIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "east" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EcoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "eco" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EdgesensorHighIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "edgesensor_high" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EdgesensorLowIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "edgesensor_low" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EditIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "edit" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EditAttributesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "edit_attributes" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EditCalendarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "edit_calendar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EditLocationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "edit_location" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EditLocationAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "edit_location_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EditNoteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "edit_note" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EditNotificationsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "edit_notifications" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EditOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "edit_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EditRoadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "edit_road" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EggIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "egg" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EggAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "egg_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EjectIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "eject" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ElderlyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "elderly" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ElderlyWomanIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "elderly_woman" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ElectricBikeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "electric_bike" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ElectricBoltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "electric_bolt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ElectricCarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "electric_car" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ElectricMeterIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "electric_meter" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ElectricMopedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "electric_moped" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ElectricRickshawIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "electric_rickshaw" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ElectricScooterIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "electric_scooter" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ElectricalServicesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "electrical_services" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ElevatorIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "elevator" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EmailIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "email" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EmergencyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "emergency" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EmergencyRecordingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "emergency_recording" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EmergencyShareIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "emergency_share" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EmojiEmotionsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "emoji_emotions" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EmojiEventsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "emoji_events" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EmojiFlagsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "emoji_flags" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EmojiFoodBeverageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "emoji_food_beverage" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EmojiNatureIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "emoji_nature" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EmojiObjectsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "emoji_objects" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EmojiPeopleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "emoji_people" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EmojiSymbolsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "emoji_symbols" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EmojiTransportationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "emoji_transportation" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EnergySavingsLeafIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "energy_savings_leaf" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EngineeringIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "engineering" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EnhancePhotoTranslateIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "enhance_photo_translate" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EnhancedEncryptionIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "enhanced_encryption" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EqualizerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "equalizer" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ErrorIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "error" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ErrorOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "error_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EscalatorIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "escalator" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EscalatorWarningIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "escalator_warning" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EuroIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "euro" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EuroSymbolIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "euro_symbol" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EvStationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "ev_station" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EventIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "event" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EventAvailableIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "event_available" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EventBusyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "event_busy" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EventNoteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "event_note" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EventRepeatIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "event_repeat" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EventSeatIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "event_seat" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ExitToAppIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "exit_to_app" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ExpandIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "expand" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ExpandCircleDownIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "expand_circle_down" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ExpandLessIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "expand_less" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ExpandMoreIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "expand_more" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ExplicitIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "explicit" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ExploreIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "explore" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ExploreOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "explore_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ExposureIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "exposure" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ExposureMinus1Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "exposure_minus_1" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ExposureMinus2Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "exposure_minus_2" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ExposureNeg1Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "exposure_neg_1" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ExposureNeg2Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "exposure_neg_2" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ExposurePlus1Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "exposure_plus_1" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ExposurePlus2Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "exposure_plus_2" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ExposureZeroIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "exposure_zero" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ExtensionIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "extension" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ExtensionOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "extension_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FaceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "face" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Face2Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "face_2" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Face3Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "face_3" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Face4Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "face_4" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Face5Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "face_5" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Face6Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "face_6" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FaceRetouchingNaturalIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "face_retouching_natural" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FaceRetouchingOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "face_retouching_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FaceUnlockIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "face_unlock" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FacebookIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "facebook" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FactCheckIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fact_check" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FactoryIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "factory" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FamilyRestroomIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "family_restroom" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FastForwardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fast_forward" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FastRewindIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fast_rewind" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FastfoodIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fastfood" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FavoriteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "favorite" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FavoriteBorderIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "favorite_border" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FavoriteOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "favorite_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FaxIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fax" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FeaturedPlayListIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "featured_play_list" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FeaturedVideoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "featured_video" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FeedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "feed" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FeedbackIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "feedback" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FemaleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "female" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FenceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fence" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FestivalIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "festival" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FiberDvrIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fiber_dvr" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FiberManualRecordIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fiber_manual_record" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FiberNewIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fiber_new" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FiberPinIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fiber_pin" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FiberSmartRecordIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fiber_smart_record" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FileCopyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "file_copy" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FileDownloadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "file_download" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FileDownloadDoneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "file_download_done" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FileDownloadOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "file_download_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FileOpenIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "file_open" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FilePresentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "file_present" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FileUploadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "file_upload" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FilterIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Filter1Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_1" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Filter2Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_2" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Filter3Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_3" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Filter4Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_4" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Filter5Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_5" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Filter6Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_6" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Filter7Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_7" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Filter8Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_8" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Filter9Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_9" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Filter9PlusIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_9_plus" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FilterAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FilterAltOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_alt_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FilterBAndWIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_b_and_w" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FilterCenterFocusIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_center_focus" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FilterDramaIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_drama" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FilterFramesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_frames" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FilterHdrIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_hdr" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FilterListIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_list" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FilterListOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_list_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FilterNoneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_none" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FilterTiltShiftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_tilt_shift" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FilterVintageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "filter_vintage" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FindInPageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "find_in_page" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FindReplaceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "find_replace" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FingerprintIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fingerprint" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FireExtinguisherIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fire_extinguisher" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FireHydrantAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fire_hydrant_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FireTruckIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fire_truck" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FireplaceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fireplace" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FirstPageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "first_page" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FitScreenIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fit_screen" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FitbitIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fitbit" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FitnessCenterIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fitness_center" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlagIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flag" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlagCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flag_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlakyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flaky" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlareIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flare" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlashAutoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flash_auto" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlashOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flash_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlashOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flash_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlashlightOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flashlight_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlashlightOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flashlight_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlatwareIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flatware" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flight" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlightClassIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flight_class" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlightLandIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flight_land" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlightTakeoffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flight_takeoff" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlipIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flip" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlipCameraAndroidIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flip_camera_android" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlipCameraIosIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flip_camera_ios" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlipToBackIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flip_to_back" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlipToFrontIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flip_to_front" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FloodIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flood" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlourescentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flourescent" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FluorescentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fluorescent" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FlutterDashIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "flutter_dash" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FmdBadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fmd_bad" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FmdGoodIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fmd_good" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FolderIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "folder" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FolderCopyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "folder_copy" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FolderDeleteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "folder_delete" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FolderOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "folder_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FolderOpenIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "folder_open" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FolderSharedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "folder_shared" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FolderSpecialIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "folder_special" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FolderZipIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "folder_zip" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FollowTheSignsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "follow_the_signs" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FontDownloadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "font_download" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FontDownloadOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "font_download_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FoodBankIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "food_bank" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ForestIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "forest" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ForkLeftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fork_left" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ForkRightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fork_right" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatAlignCenterIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_align_center" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatAlignJustifyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_align_justify" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatAlignLeftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_align_left" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatAlignRightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_align_right" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatBoldIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_bold" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatClearIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_clear" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatColorFillIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_color_fill" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatColorResetIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_color_reset" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatColorTextIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_color_text" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatIndentDecreaseIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_indent_decrease" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatIndentIncreaseIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_indent_increase" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatItalicIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_italic" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatLineSpacingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_line_spacing" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatListBulletedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_list_bulleted" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatListNumberedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_list_numbered" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatListNumberedRtlIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_list_numbered_rtl" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatOverlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_overline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatPaintIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_paint" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatQuoteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_quote" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatShapesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_shapes" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatSizeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_size" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatStrikethroughIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_strikethrough" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatTextdirectionLToRIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_textdirection_l_to_r" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatTextdirectionRToLIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_textdirection_r_to_l" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatUnderlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_underline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FormatUnderlinedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "format_underlined" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FortIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fort" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ForumIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "forum" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ForwardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "forward" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Forward10Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "forward_10" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Forward30Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "forward_30" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Forward5Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "forward_5" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ForwardToInboxIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "forward_to_inbox" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FoundationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "foundation" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FreeBreakfastIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "free_breakfast" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FreeCancellationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "free_cancellation" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FrontHandIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "front_hand" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FullscreenIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fullscreen" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FullscreenExitIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "fullscreen_exit" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function FunctionsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "functions" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GMobiledataIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "g_mobiledata" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GTranslateIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "g_translate" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GamepadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "gamepad" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GamesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "games" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GarageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "garage" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GasMeterIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "gas_meter" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GavelIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "gavel" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GeneratingTokensIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "generating_tokens" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GestureIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "gesture" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GetAppIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "get_app" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GifIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "gif" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GifBoxIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "gif_box" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GirlIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "girl" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GiteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "gite" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GolfCourseIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "golf_course" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GppBadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "gpp_bad" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GppGoodIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "gpp_good" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GppMaybeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "gpp_maybe" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GpsFixedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "gps_fixed" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GpsNotFixedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "gps_not_fixed" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GpsOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "gps_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GradeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "grade" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GradientIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "gradient" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GradingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "grading" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GrainIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "grain" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GraphicEqIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "graphic_eq" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GrassIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "grass" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Grid3x3Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "grid_3x3" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Grid4x4Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "grid_4x4" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GridGoldenratioIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "grid_goldenratio" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GridOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "grid_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GridOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "grid_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GridViewIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "grid_view" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GroupIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "group" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GroupAddIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "group_add" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GroupOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "group_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GroupRemoveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "group_remove" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GroupWorkIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "group_work" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function GroupsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "groups" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Groups2Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "groups_2" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Groups3Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "groups_3" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HMobiledataIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "h_mobiledata" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HPlusMobiledataIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "h_plus_mobiledata" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HailIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hail" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HandshakeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "handshake" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HandymanIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "handyman" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HardwareIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hardware" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HdIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hd" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HdrAutoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hdr_auto" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HdrAutoSelectIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hdr_auto_select" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HdrEnhancedSelectIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hdr_enhanced_select" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HdrOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hdr_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HdrOffSelectIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hdr_off_select" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HdrOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hdr_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HdrOnSelectIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hdr_on_select" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HdrPlusIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hdr_plus" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HdrStrongIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hdr_strong" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HdrWeakIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hdr_weak" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HeadphonesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "headphones" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HeadphonesBatteryIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "headphones_battery" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HeadsetIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "headset" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HeadsetMicIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "headset_mic" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HeadsetOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "headset_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HealingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "healing" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HealthAndSafetyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "health_and_safety" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HearingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hearing" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HearingDisabledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hearing_disabled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HeartBrokenIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "heart_broken" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HeatPumpIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "heat_pump" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HeightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "height" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HelpIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "help" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HelpCenterIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "help_center" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HelpOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "help_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HevcIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hevc" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HexagonIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hexagon" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HideImageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hide_image" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HideSourceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hide_source" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HighQualityIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "high_quality" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HighlightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "highlight" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HighlightAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "highlight_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HighlightOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "highlight_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HighlightRemoveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "highlight_remove" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HikingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hiking" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HistoryIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "history" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HistoryEduIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "history_edu" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HistoryToggleOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "history_toggle_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HiveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hive" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HlsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hls" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HlsOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hls_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HolidayVillageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "holiday_village" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HomeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "home" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HomeMaxIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "home_max" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HomeMiniIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "home_mini" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HomeRepairServiceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "home_repair_service" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HomeWorkIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "home_work" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HorizontalDistributeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "horizontal_distribute" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HorizontalRuleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "horizontal_rule" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HorizontalSplitIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "horizontal_split" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HotTubIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hot_tub" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HotelIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hotel" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HotelClassIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hotel_class" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HourglassBottomIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hourglass_bottom" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HourglassDisabledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hourglass_disabled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HourglassEmptyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hourglass_empty" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HourglassFullIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hourglass_full" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HourglassTopIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hourglass_top" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HouseIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "house" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HouseSidingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "house_siding" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HouseboatIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "houseboat" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HowToRegIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "how_to_reg" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HowToVoteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "how_to_vote" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HtmlIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "html" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HttpIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "http" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HttpsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "https" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HubIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hub" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function HvacIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "hvac" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function IceSkatingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "ice_skating" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function IcecreamIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "icecream" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ImageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "image" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ImageAspectRatioIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "image_aspect_ratio" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ImageNotSupportedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "image_not_supported" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ImageSearchIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "image_search" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ImagesearchRollerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "imagesearch_roller" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ImportContactsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "import_contacts" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ImportExportIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "import_export" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ImportantDevicesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "important_devices" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InboxIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "inbox" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function IncompleteCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "incomplete_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function IndeterminateCheckBoxIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "indeterminate_check_box" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InfoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "info" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InfoOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "info_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InputIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "input" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InsertChartIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "insert_chart" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InsertChartOutlinedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "insert_chart_outlined" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InsertCommentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "insert_comment" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InsertDriveFileIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "insert_drive_file" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InsertEmoticonIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "insert_emoticon" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InsertInvitationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "insert_invitation" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InsertLinkIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "insert_link" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InsertPageBreakIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "insert_page_break" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InsertPhotoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "insert_photo" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InsightsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "insights" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InstallDesktopIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "install_desktop" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InstallMobileIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "install_mobile" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function IntegrationInstructionsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "integration_instructions" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InterestsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "interests" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InterpreterModeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "interpreter_mode" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InventoryIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "inventory" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Inventory2Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "inventory_2" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InvertColorsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "invert_colors" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InvertColorsOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "invert_colors_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function InvertColorsOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "invert_colors_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function IosShareIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "ios_share" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function IronIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "iron" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function IsoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "iso" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function JavascriptIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "javascript" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function JoinFullIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "join_full" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function JoinInnerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "join_inner" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function JoinLeftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "join_left" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function JoinRightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "join_right" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KayakingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "kayaking" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KebabDiningIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "kebab_dining" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "key" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "key_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyboardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "keyboard" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyboardAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "keyboard_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyboardArrowDownIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "keyboard_arrow_down" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyboardArrowLeftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "keyboard_arrow_left" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyboardArrowRightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "keyboard_arrow_right" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyboardArrowUpIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "keyboard_arrow_up" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyboardBackspaceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "keyboard_backspace" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyboardCapslockIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "keyboard_capslock" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyboardCommandKeyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "keyboard_command_key" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyboardControlIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "keyboard_control" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyboardControlKeyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "keyboard_control_key" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyboardDoubleArrowDownIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "keyboard_double_arrow_down" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyboardDoubleArrowLeftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "keyboard_double_arrow_left" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyboardDoubleArrowRightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "keyboard_double_arrow_right" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyboardDoubleArrowUpIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "keyboard_double_arrow_up" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyboardHideIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "keyboard_hide" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyboardOptionKeyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "keyboard_option_key" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyboardReturnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "keyboard_return" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyboardTabIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "keyboard_tab" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KeyboardVoiceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "keyboard_voice" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KingBedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "king_bed" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KitchenIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "kitchen" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function KitesurfingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "kitesurfing" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LabelIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "label" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LabelImportantIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "label_important" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LabelImportantOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "label_important_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LabelOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "label_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LabelOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "label_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LanIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "lan" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LandscapeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "landscape" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LandslideIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "landslide" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LanguageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "language" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LaptopIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "laptop" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LaptopChromebookIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "laptop_chromebook" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LaptopMacIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "laptop_mac" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LaptopWindowsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "laptop_windows" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LastPageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "last_page" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LaunchIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "launch" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LayersIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "layers" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LayersClearIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "layers_clear" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LeaderboardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "leaderboard" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LeakAddIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "leak_add" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LeakRemoveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "leak_remove" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LeaveBagsAtHomeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "leave_bags_at_home" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LegendToggleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "legend_toggle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LensIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "lens" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LensBlurIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "lens_blur" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LibraryAddIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "library_add" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LibraryAddCheckIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "library_add_check" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LibraryBooksIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "library_books" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LibraryMusicIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "library_music" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "light" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LightModeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "light_mode" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LightbulbIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "lightbulb" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LightbulbCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "lightbulb_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LightbulbOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "lightbulb_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LineAxisIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "line_axis" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LineStyleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "line_style" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LineWeightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "line_weight" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LinearScaleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "linear_scale" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LinkIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "link" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LinkOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "link_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LinkedCameraIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "linked_camera" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LiquorIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "liquor" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ListIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "list" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ListAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "list_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LiveHelpIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "live_help" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LiveTvIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "live_tv" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LivingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "living" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalActivityIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_activity" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalAirportIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_airport" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalAtmIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_atm" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalAttractionIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_attraction" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalBarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalCafeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_cafe" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalCarWashIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_car_wash" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalConvenienceStoreIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_convenience_store" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalDiningIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_dining" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalDrinkIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_drink" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalFireDepartmentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_fire_department" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalFloristIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_florist" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalGasStationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_gas_station" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalGroceryStoreIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_grocery_store" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalHospitalIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_hospital" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalHotelIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_hotel" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalLaundryServiceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_laundry_service" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalLibraryIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_library" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalMallIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_mall" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalMoviesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_movies" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalOfferIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_offer" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalParkingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_parking" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalPharmacyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_pharmacy" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalPhoneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_phone" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalPizzaIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_pizza" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalPlayIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_play" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalPoliceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_police" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalPostOfficeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_post_office" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalPrintshopIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_printshop" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalRestaurantIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_restaurant" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalSeeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_see" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalShippingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_shipping" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocalTaxiIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "local_taxi" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocationCityIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "location_city" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocationDisabledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "location_disabled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocationHistoryIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "location_history" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocationOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "location_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocationOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "location_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LocationSearchingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "location_searching" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LockIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "lock" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LockClockIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "lock_clock" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LockOpenIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "lock_open" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LockOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "lock_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LockPersonIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "lock_person" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LockResetIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "lock_reset" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LoginIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "login" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LogoDevIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "logo_dev" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LogoutIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "logout" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LooksIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "looks" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Looks3Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "looks_3" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Looks4Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "looks_4" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Looks5Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "looks_5" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Looks6Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "looks_6" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LooksOneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "looks_one" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LooksTwoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "looks_two" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LoopIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "loop" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LoupeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "loupe" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LowPriorityIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "low_priority" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LoyaltyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "loyalty" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LteMobiledataIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "lte_mobiledata" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LtePlusMobiledataIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "lte_plus_mobiledata" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LuggageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "luggage" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LunchDiningIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "lunch_dining" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function LyricsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "lyrics" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MacroOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "macro_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MailIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mail" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MailLockIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mail_lock" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MailOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mail_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MaleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "male" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ManIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "man" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Man2Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "man_2" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Man3Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "man_3" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Man4Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "man_4" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ManageAccountsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "manage_accounts" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ManageHistoryIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "manage_history" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ManageSearchIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "manage_search" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MapIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "map" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MapsHomeWorkIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "maps_home_work" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MapsUgcIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "maps_ugc" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MarginIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "margin" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MarkAsUnreadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mark_as_unread" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MarkChatReadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mark_chat_read" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MarkChatUnreadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mark_chat_unread" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MarkEmailReadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mark_email_read" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MarkEmailUnreadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mark_email_unread" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MarkUnreadChatAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mark_unread_chat_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MarkunreadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "markunread" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MarkunreadMailboxIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "markunread_mailbox" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MasksIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "masks" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MaximizeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "maximize" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MediaBluetoothOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "media_bluetooth_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MediaBluetoothOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "media_bluetooth_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MediationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mediation" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MedicalInformationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "medical_information" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MedicalServicesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "medical_services" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MedicationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "medication" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MedicationLiquidIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "medication_liquid" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MeetingRoomIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "meeting_room" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MemoryIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "memory" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MenuIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "menu" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MenuBookIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "menu_book" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MenuOpenIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "menu_open" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MergeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "merge" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MergeTypeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "merge_type" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MessageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "message" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MessengerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "messenger" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MessengerOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "messenger_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MicIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mic" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MicExternalOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mic_external_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MicExternalOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mic_external_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MicNoneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mic_none" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MicOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mic_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MicrowaveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "microwave" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MilitaryTechIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "military_tech" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MinimizeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "minimize" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MinorCrashIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "minor_crash" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MiscellaneousServicesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "miscellaneous_services" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MissedVideoCallIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "missed_video_call" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MmsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mms" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MobileFriendlyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mobile_friendly" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MobileOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mobile_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MobileScreenShareIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mobile_screen_share" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MobiledataOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mobiledata_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ModeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mode" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ModeCommentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mode_comment" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ModeEditIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mode_edit" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ModeEditOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mode_edit_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ModeFanOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mode_fan_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ModeNightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mode_night" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ModeOfTravelIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mode_of_travel" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ModeStandbyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mode_standby" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ModelTrainingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "model_training" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MonetizationOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "monetization_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MoneyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "money" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MoneyOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "money_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MoneyOffCsredIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "money_off_csred" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MonitorIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "monitor" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MonitorHeartIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "monitor_heart" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MonitorWeightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "monitor_weight" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MonochromePhotosIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "monochrome_photos" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MoodIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mood" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MoodBadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mood_bad" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MopedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "moped" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MoreIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "more" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MoreHorizIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "more_horiz" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MoreTimeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "more_time" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MoreVertIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "more_vert" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MosqueIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mosque" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MotionPhotosAutoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "motion_photos_auto" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MotionPhotosOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "motion_photos_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MotionPhotosOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "motion_photos_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MotionPhotosPauseIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "motion_photos_pause" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MotionPhotosPausedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "motion_photos_paused" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MotorcycleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "motorcycle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MouseIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mouse" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MoveDownIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "move_down" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MoveToInboxIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "move_to_inbox" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MoveUpIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "move_up" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MovieIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "movie" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MovieCreationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "movie_creation" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MovieFilterIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "movie_filter" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MovingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "moving" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MpIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "mp" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MultilineChartIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "multiline_chart" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MultipleStopIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "multiple_stop" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MultitrackAudioIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "multitrack_audio" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MuseumIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "museum" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MusicNoteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "music_note" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MusicOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "music_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MusicVideoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "music_video" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MyLibraryAddIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "my_library_add" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MyLibraryBooksIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "my_library_books" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MyLibraryMusicIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "my_library_music" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function MyLocationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "my_location" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NatIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "nat" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NatureIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "nature" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NaturePeopleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "nature_people" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NavigateBeforeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "navigate_before" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NavigateNextIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "navigate_next" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NavigationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "navigation" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NearMeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "near_me" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NearMeDisabledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "near_me_disabled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NearbyErrorIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "nearby_error" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NearbyOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "nearby_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NestCamWiredStandIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "nest_cam_wired_stand" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NetworkCellIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "network_cell" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NetworkCheckIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "network_check" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NetworkLockedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "network_locked" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NetworkPingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "network_ping" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NetworkWifiIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "network_wifi" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NetworkWifi1BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "network_wifi_1_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NetworkWifi2BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "network_wifi_2_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NetworkWifi3BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "network_wifi_3_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NewLabelIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "new_label" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NewReleasesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "new_releases" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NewspaperIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "newspaper" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NextPlanIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "next_plan" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NextWeekIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "next_week" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NfcIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "nfc" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NightShelterIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "night_shelter" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NightlifeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "nightlife" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NightlightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "nightlight" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NightlightRoundIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "nightlight_round" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NightsStayIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "nights_stay" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoAccountsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "no_accounts" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoAdultContentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "no_adult_content" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoBackpackIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "no_backpack" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoCellIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "no_cell" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoCrashIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "no_crash" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoDrinksIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "no_drinks" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoEncryptionIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "no_encryption" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoEncryptionGmailerrorredIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "no_encryption_gmailerrorred" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoFlashIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "no_flash" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoFoodIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "no_food" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoLuggageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "no_luggage" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoMealsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "no_meals" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoMeetingRoomIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "no_meeting_room" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoPhotographyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "no_photography" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoSimIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "no_sim" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoStrollerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "no_stroller" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoTransferIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "no_transfer" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoiseAwareIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "noise_aware" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoiseControlOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "noise_control_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NordicWalkingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "nordic_walking" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NorthIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "north" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NorthEastIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "north_east" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NorthWestIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "north_west" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NotAccessibleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "not_accessible" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NotInterestedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "not_interested" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NotListedLocationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "not_listed_location" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NotStartedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "not_started" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "note" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoteAddIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "note_add" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NoteAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "note_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NotesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "notes" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NotificationAddIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "notification_add" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NotificationImportantIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "notification_important" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NotificationsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "notifications" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NotificationsActiveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "notifications_active" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NotificationsNoneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "notifications_none" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NotificationsOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "notifications_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NotificationsOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "notifications_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NotificationsPausedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "notifications_paused" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NowWallpaperIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "now_wallpaper" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NowWidgetsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "now_widgets" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function NumbersIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "numbers" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OfflineBoltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "offline_bolt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OfflinePinIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "offline_pin" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OfflineShareIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "offline_share" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OilBarrelIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "oil_barrel" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OnDeviceTrainingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "on_device_training" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OndemandVideoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "ondemand_video" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OnlinePredictionIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "online_prediction" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OpacityIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "opacity" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OpenInBrowserIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "open_in_browser" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OpenInFullIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "open_in_full" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OpenInNewIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "open_in_new" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OpenInNewOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "open_in_new_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OpenWithIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "open_with" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OtherHousesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "other_houses" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OutbondIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "outbond" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OutboundIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "outbound" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OutboxIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "outbox" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OutdoorGrillIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "outdoor_grill" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OutletIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "outlet" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OutlinedFlagIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "outlined_flag" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function OutputIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "output" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PaddingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "padding" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PagesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pages" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PageviewIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pageview" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PaidIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "paid" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PaletteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "palette" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PanToolIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pan_tool" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PanToolAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pan_tool_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PanoramaIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "panorama" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PanoramaFisheyeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "panorama_fisheye" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PanoramaHorizontalIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "panorama_horizontal" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PanoramaHorizontalSelectIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "panorama_horizontal_select" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PanoramaPhotosphereIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "panorama_photosphere" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PanoramaPhotosphereSelectIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "panorama_photosphere_select" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PanoramaVerticalIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "panorama_vertical" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PanoramaVerticalSelectIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "panorama_vertical_select" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PanoramaWideAngleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "panorama_wide_angle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PanoramaWideAngleSelectIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "panorama_wide_angle_select" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ParaglidingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "paragliding" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ParkIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "park" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PartyModeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "party_mode" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PasswordIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "password" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PasteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "paste" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PatternIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pattern" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PauseIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pause" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PauseCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pause_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PauseCircleFilledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pause_circle_filled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PauseCircleOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pause_circle_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PausePresentationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pause_presentation" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PaymentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "payment" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PaymentsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "payments" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PaypalIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "paypal" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PedalBikeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pedal_bike" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PendingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pending" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PendingActionsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pending_actions" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PentagonIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pentagon" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PeopleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "people" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PeopleAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "people_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PeopleOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "people_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PercentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "percent" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PermCameraMicIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "perm_camera_mic" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PermContactCalIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "perm_contact_cal" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PermContactCalendarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "perm_contact_calendar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PermDataSettingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "perm_data_setting" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PermDeviceInfoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "perm_device_info" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PermDeviceInformationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "perm_device_information" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PermIdentityIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "perm_identity" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PermMediaIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "perm_media" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PermPhoneMsgIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "perm_phone_msg" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PermScanWifiIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "perm_scan_wifi" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PersonIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "person" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Person2Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "person_2" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Person3Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "person_3" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Person4Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "person_4" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PersonAddIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "person_add" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PersonAddAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "person_add_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PersonAddAlt1Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "person_add_alt_1" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PersonAddDisabledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "person_add_disabled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PersonOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "person_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PersonOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "person_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PersonPinIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "person_pin" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PersonPinCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "person_pin_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PersonRemoveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "person_remove" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PersonRemoveAlt1Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "person_remove_alt_1" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PersonSearchIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "person_search" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PersonalInjuryIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "personal_injury" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PersonalVideoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "personal_video" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PestControlIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pest_control" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PestControlRodentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pest_control_rodent" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PetsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pets" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhishingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "phishing" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhoneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "phone" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhoneAndroidIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "phone_android" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhoneBluetoothSpeakerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "phone_bluetooth_speaker" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhoneCallbackIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "phone_callback" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhoneDisabledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "phone_disabled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhoneEnabledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "phone_enabled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhoneForwardedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "phone_forwarded" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhoneInTalkIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "phone_in_talk" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhoneIphoneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "phone_iphone" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhoneLockedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "phone_locked" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhoneMissedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "phone_missed" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhonePausedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "phone_paused" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhonelinkIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "phonelink" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhonelinkEraseIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "phonelink_erase" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhonelinkLockIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "phonelink_lock" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhonelinkOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "phonelink_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhonelinkRingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "phonelink_ring" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhonelinkSetupIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "phonelink_setup" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhotoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "photo" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhotoAlbumIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "photo_album" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhotoCameraIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "photo_camera" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhotoCameraBackIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "photo_camera_back" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhotoCameraFrontIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "photo_camera_front" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhotoFilterIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "photo_filter" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhotoLibraryIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "photo_library" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhotoSizeSelectActualIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "photo_size_select_actual" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhotoSizeSelectLargeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "photo_size_select_large" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhotoSizeSelectSmallIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "photo_size_select_small" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PhpIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "php" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PianoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "piano" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PianoOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "piano_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PictureAsPdfIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "picture_as_pdf" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PictureInPictureIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "picture_in_picture" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PictureInPictureAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "picture_in_picture_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PieChartIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pie_chart" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PieChartOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pie_chart_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PinIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pin" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PinDropIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pin_drop" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PinEndIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pin_end" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PinInvokeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pin_invoke" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PinchIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pinch" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PivotTableChartIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pivot_table_chart" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PixIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pix" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PlaceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "place" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PlagiarismIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "plagiarism" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PlayArrowIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "play_arrow" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PlayCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "play_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PlayCircleFillIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "play_circle_fill" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PlayCircleFilledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "play_circle_filled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PlayCircleOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "play_circle_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PlayDisabledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "play_disabled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PlayForWorkIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "play_for_work" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PlayLessonIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "play_lesson" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PlaylistAddIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "playlist_add" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PlaylistAddCheckIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "playlist_add_check" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PlaylistAddCheckCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "playlist_add_check_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PlaylistAddCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "playlist_add_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PlaylistPlayIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "playlist_play" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PlaylistRemoveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "playlist_remove" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PlumbingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "plumbing" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PlusOneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "plus_one" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PodcastsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "podcasts" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PointOfSaleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "point_of_sale" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PolicyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "policy" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PollIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "poll" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PolylineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "polyline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PolymerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "polymer" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PoolIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pool" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PortableWifiOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "portable_wifi_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PortraitIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "portrait" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PostAddIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "post_add" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PowerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "power" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PowerInputIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "power_input" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PowerOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "power_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PowerSettingsNewIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "power_settings_new" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PrecisionManufacturingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "precision_manufacturing" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PregnantWomanIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "pregnant_woman" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PresentToAllIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "present_to_all" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PreviewIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "preview" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PriceChangeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "price_change" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PriceCheckIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "price_check" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PrintIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "print" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PrintDisabledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "print_disabled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PriorityHighIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "priority_high" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PrivacyTipIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "privacy_tip" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PrivateConnectivityIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "private_connectivity" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ProductionQuantityLimitsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "production_quantity_limits" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PropaneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "propane" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PropaneTankIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "propane_tank" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PsychologyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "psychology" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PsychologyAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "psychology_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PublicIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "public" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PublicOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "public_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PublishIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "publish" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PublishedWithChangesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "published_with_changes" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PunchClockIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "punch_clock" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PushPinIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "push_pin" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function QrCodeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "qr_code" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function QrCode2Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "qr_code_2" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function QrCodeScannerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "qr_code_scanner" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function QueryBuilderIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "query_builder" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function QueryStatsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "query_stats" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function QuestionAnswerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "question_answer" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function QuestionMarkIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "question_mark" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function QueueIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "queue" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function QueueMusicIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "queue_music" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function QueuePlayNextIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "queue_play_next" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function QuickContactsDialerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "quick_contacts_dialer" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function QuickContactsMailIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "quick_contacts_mail" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function QuickreplyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "quickreply" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function QuizIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "quiz" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function QuoraIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "quora" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RMobiledataIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "r_mobiledata" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RadarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "radar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RadioIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "radio" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RadioButtonCheckedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "radio_button_checked" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RadioButtonOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "radio_button_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RadioButtonOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "radio_button_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RadioButtonUncheckedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "radio_button_unchecked" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RailwayAlertIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "railway_alert" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RamenDiningIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "ramen_dining" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RampLeftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "ramp_left" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RampRightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "ramp_right" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RateReviewIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "rate_review" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RawOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "raw_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RawOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "raw_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ReadMoreIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "read_more" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RealEstateAgentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "real_estate_agent" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ReceiptIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "receipt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ReceiptLongIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "receipt_long" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RecentActorsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "recent_actors" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RecommendIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "recommend" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RecordVoiceOverIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "record_voice_over" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RectangleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "rectangle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RecyclingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "recycling" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RedditIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "reddit" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RedeemIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "redeem" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RedoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "redo" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ReduceCapacityIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "reduce_capacity" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RefreshIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "refresh" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RememberMeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "remember_me" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RemoveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "remove" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RemoveCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "remove_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RemoveCircleOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "remove_circle_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RemoveDoneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "remove_done" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RemoveFromQueueIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "remove_from_queue" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RemoveModeratorIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "remove_moderator" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RemoveRedEyeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "remove_red_eye" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RemoveRoadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "remove_road" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RemoveShoppingCartIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "remove_shopping_cart" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ReorderIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "reorder" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RepartitionIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "repartition" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RepeatIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "repeat" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RepeatOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "repeat_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RepeatOneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "repeat_one" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RepeatOneOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "repeat_one_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ReplayIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "replay" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Replay10Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "replay_10" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Replay30Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "replay_30" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Replay5Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "replay_5" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ReplayCircleFilledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "replay_circle_filled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ReplyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "reply" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ReplyAllIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "reply_all" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ReportIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "report" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ReportGmailerrorredIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "report_gmailerrorred" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ReportOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "report_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ReportProblemIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "report_problem" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RequestPageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "request_page" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RequestQuoteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "request_quote" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ResetTvIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "reset_tv" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RestartAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "restart_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RestaurantIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "restaurant" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RestaurantMenuIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "restaurant_menu" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RestoreIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "restore" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RestoreFromTrashIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "restore_from_trash" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RestorePageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "restore_page" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ReviewsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "reviews" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RiceBowlIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "rice_bowl" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RingVolumeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "ring_volume" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RocketIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "rocket" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RocketLaunchIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "rocket_launch" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RollerShadesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "roller_shades" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RollerShadesClosedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "roller_shades_closed" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RollerSkatingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "roller_skating" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RoofingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "roofing" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RoomIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "room" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RoomPreferencesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "room_preferences" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RoomServiceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "room_service" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Rotate90DegreesCcwIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "rotate_90_degrees_ccw" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Rotate90DegreesCwIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "rotate_90_degrees_cw" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RotateLeftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "rotate_left" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RotateRightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "rotate_right" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RoundaboutLeftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "roundabout_left" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RoundaboutRightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "roundabout_right" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RoundedCornerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "rounded_corner" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RouteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "route" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RouterIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "router" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RowingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "rowing" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RssFeedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "rss_feed" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RsvpIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "rsvp" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RttIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "rtt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RuleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "rule" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RuleFolderIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "rule_folder" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RunCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "run_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RunningWithErrorsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "running_with_errors" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function RvHookupIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "rv_hookup" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SafetyCheckIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "safety_check" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SafetyDividerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "safety_divider" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SailingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sailing" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SanitizerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sanitizer" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SatelliteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "satellite" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SatelliteAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "satellite_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SaveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "save" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SaveAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "save_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SaveAsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "save_as" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SavedSearchIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "saved_search" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SavingsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "savings" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ScaleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "scale" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ScannerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "scanner" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ScatterPlotIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "scatter_plot" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ScheduleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "schedule" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ScheduleSendIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "schedule_send" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SchemaIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "schema" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SchoolIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "school" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ScienceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "science" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ScoreIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "score" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ScoreboardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "scoreboard" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ScreenLockLandscapeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "screen_lock_landscape" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ScreenLockPortraitIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "screen_lock_portrait" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ScreenLockRotationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "screen_lock_rotation" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ScreenRotationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "screen_rotation" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ScreenRotationAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "screen_rotation_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ScreenSearchDesktopIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "screen_search_desktop" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ScreenShareIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "screen_share" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ScreenshotIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "screenshot" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ScreenshotMonitorIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "screenshot_monitor" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ScubaDivingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "scuba_diving" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SdIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sd" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SdCardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sd_card" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SdCardAlertIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sd_card_alert" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SdStorageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sd_storage" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SearchIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "search" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SearchOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "search_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SecurityIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "security" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SecurityUpdateIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "security_update" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SecurityUpdateGoodIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "security_update_good" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SecurityUpdateWarningIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "security_update_warning" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SegmentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "segment" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SelectAllIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "select_all" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SelfImprovementIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "self_improvement" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SellIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sell" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SendIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "send" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SendAndArchiveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "send_and_archive" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SendTimeExtensionIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "send_time_extension" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SendToMobileIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "send_to_mobile" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SensorDoorIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sensor_door" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SensorOccupiedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sensor_occupied" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SensorWindowIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sensor_window" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SensorsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sensors" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SensorsOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sensors_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SentimentDissatisfiedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sentiment_dissatisfied" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SentimentNeutralIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sentiment_neutral" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SentimentSatisfiedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sentiment_satisfied" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SentimentSatisfiedAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sentiment_satisfied_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SentimentVeryDissatisfiedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sentiment_very_dissatisfied" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SentimentVerySatisfiedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sentiment_very_satisfied" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SetMealIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "set_meal" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsAccessibilityIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings_accessibility" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsApplicationsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings_applications" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsBackupRestoreIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings_backup_restore" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsBluetoothIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings_bluetooth" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsBrightnessIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings_brightness" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsCellIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings_cell" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsDisplayIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings_display" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsEthernetIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings_ethernet" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsInputAntennaIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings_input_antenna" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsInputComponentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings_input_component" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsInputCompositeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings_input_composite" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsInputHdmiIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings_input_hdmi" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsInputSvideoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings_input_svideo" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsOverscanIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings_overscan" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsPhoneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings_phone" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsPowerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings_power" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsRemoteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings_remote" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsSuggestIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings_suggest" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsSystemDaydreamIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings_system_daydream" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SettingsVoiceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "settings_voice" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SevereColdIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "severe_cold" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ShapeLineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "shape_line" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ShareIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "share" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ShareArrivalTimeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "share_arrival_time" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ShareLocationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "share_location" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ShieldIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "shield" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ShieldMoonIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "shield_moon" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ShopIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "shop" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Shop2Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "shop_2" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ShopTwoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "shop_two" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ShopifyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "shopify" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ShoppingBagIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "shopping_bag" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ShoppingBasketIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "shopping_basket" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ShoppingCartIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "shopping_cart" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ShoppingCartCheckoutIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "shopping_cart_checkout" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ShortTextIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "short_text" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ShortcutIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "shortcut" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ShowChartIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "show_chart" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ShowerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "shower" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ShuffleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "shuffle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ShuffleOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "shuffle_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ShutterSpeedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "shutter_speed" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SickIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sick" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignLanguageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sign_language" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignalCellular0BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signal_cellular_0_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignalCellular4BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signal_cellular_4_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignalCellularAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signal_cellular_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignalCellularAlt1BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signal_cellular_alt_1_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignalCellularAlt2BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signal_cellular_alt_2_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignalCellularConnectedNoInternet0BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signal_cellular_connected_no_internet_0_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignalCellularConnectedNoInternet4BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signal_cellular_connected_no_internet_4_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignalCellularNoSimIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signal_cellular_no_sim" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignalCellularNodataIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signal_cellular_nodata" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignalCellularNullIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signal_cellular_null" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignalCellularOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signal_cellular_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignalWifi0BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signal_wifi_0_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignalWifi4BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signal_wifi_4_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignalWifi4BarLockIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signal_wifi_4_bar_lock" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignalWifiBadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signal_wifi_bad" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignalWifiConnectedNoInternet4Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signal_wifi_connected_no_internet_4" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignalWifiOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signal_wifi_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignalWifiStatusbar4BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signal_wifi_statusbar_4_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignalWifiStatusbarConnectedNoInternet4Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signal_wifi_statusbar_connected_no_internet_4" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignalWifiStatusbarNullIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signal_wifi_statusbar_null" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SignpostIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "signpost" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SimCardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sim_card" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SimCardAlertIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sim_card_alert" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SimCardDownloadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sim_card_download" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SingleBedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "single_bed" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SipIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sip" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SkateboardingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "skateboarding" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SkipNextIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "skip_next" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SkipPreviousIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "skip_previous" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SleddingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sledding" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SlideshowIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "slideshow" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SlowMotionVideoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "slow_motion_video" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SmartButtonIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "smart_button" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SmartDisplayIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "smart_display" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SmartScreenIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "smart_screen" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SmartToyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "smart_toy" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SmartphoneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "smartphone" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SmokeFreeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "smoke_free" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SmokingRoomsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "smoking_rooms" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SmsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sms" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SmsFailedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sms_failed" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SnapchatIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "snapchat" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SnippetFolderIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "snippet_folder" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SnoozeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "snooze" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SnowboardingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "snowboarding" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SnowmobileIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "snowmobile" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SnowshoeingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "snowshoeing" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SoapIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "soap" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SocialDistanceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "social_distance" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SolarPowerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "solar_power" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SortIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sort" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SortByAlphaIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sort_by_alpha" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SosIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sos" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SoupKitchenIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "soup_kitchen" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SourceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "source" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SouthIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "south" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SouthAmericaIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "south_america" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SouthEastIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "south_east" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SouthWestIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "south_west" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SpaIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "spa" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SpaceBarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "space_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SpaceDashboardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "space_dashboard" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SpatialAudioIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "spatial_audio" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SpatialAudioOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "spatial_audio_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SpatialTrackingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "spatial_tracking" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SpeakerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "speaker" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SpeakerGroupIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "speaker_group" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SpeakerNotesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "speaker_notes" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SpeakerNotesOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "speaker_notes_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SpeakerPhoneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "speaker_phone" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SpeedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "speed" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SpellcheckIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "spellcheck" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SplitscreenIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "splitscreen" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SpokeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "spoke" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SportsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sports" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SportsBarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sports_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SportsBaseballIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sports_baseball" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SportsBasketballIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sports_basketball" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SportsCricketIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sports_cricket" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SportsEsportsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sports_esports" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SportsFootballIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sports_football" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SportsGolfIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sports_golf" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SportsGymnasticsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sports_gymnastics" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SportsHandballIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sports_handball" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SportsHockeyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sports_hockey" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SportsKabaddiIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sports_kabaddi" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SportsMartialArtsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sports_martial_arts" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SportsMmaIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sports_mma" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SportsMotorsportsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sports_motorsports" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SportsRugbyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sports_rugby" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SportsScoreIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sports_score" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SportsSoccerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sports_soccer" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SportsTennisIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sports_tennis" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SportsVolleyballIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sports_volleyball" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SquareIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "square" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SquareFootIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "square_foot" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SsidChartIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "ssid_chart" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StackedBarChartIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "stacked_bar_chart" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StackedLineChartIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "stacked_line_chart" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StadiumIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "stadium" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StairsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "stairs" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "star" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StarBorderIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "star_border" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StarBorderPurple500Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "star_border_purple500" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StarHalfIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "star_half" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StarOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "star_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StarPurple500Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "star_purple500" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StarRateIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "star_rate" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StarsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "stars" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StartIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "start" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StayCurrentLandscapeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "stay_current_landscape" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StayCurrentPortraitIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "stay_current_portrait" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StayPrimaryLandscapeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "stay_primary_landscape" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StayPrimaryPortraitIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "stay_primary_portrait" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StickyNote2Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sticky_note_2" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StopIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "stop" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StopCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "stop_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StopScreenShareIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "stop_screen_share" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StorageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "storage" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StoreIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "store" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StoreMallDirectoryIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "store_mall_directory" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StorefrontIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "storefront" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StormIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "storm" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StraightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "straight" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StraightenIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "straighten" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StreamIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "stream" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StreetviewIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "streetview" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StrikethroughSIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "strikethrough_s" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StrollerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "stroller" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function StyleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "style" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SubdirectoryArrowLeftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "subdirectory_arrow_left" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SubdirectoryArrowRightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "subdirectory_arrow_right" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SubjectIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "subject" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SubscriptIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "subscript" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SubscriptionsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "subscriptions" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SubtitlesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "subtitles" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SubtitlesOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "subtitles_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SubwayIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "subway" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SummarizeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "summarize" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SuperscriptIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "superscript" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SupervisedUserCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "supervised_user_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SupervisorAccountIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "supervisor_account" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SupportIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "support" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SupportAgentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "support_agent" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SurfingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "surfing" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SurroundSoundIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "surround_sound" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwapCallsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "swap_calls" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwapHorizIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "swap_horiz" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwapHorizontalCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "swap_horizontal_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwapVertIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "swap_vert" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwapVertCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "swap_vert_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwapVerticalCircleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "swap_vertical_circle" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwipeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "swipe" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwipeDownIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "swipe_down" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwipeDownAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "swipe_down_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwipeLeftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "swipe_left" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwipeLeftAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "swipe_left_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwipeRightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "swipe_right" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwipeRightAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "swipe_right_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwipeUpIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "swipe_up" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwipeUpAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "swipe_up_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwipeVerticalIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "swipe_vertical" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwitchAccessShortcutIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "switch_access_shortcut" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwitchAccessShortcutAddIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "switch_access_shortcut_add" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwitchAccountIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "switch_account" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwitchCameraIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "switch_camera" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwitchLeftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "switch_left" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwitchRightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "switch_right" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SwitchVideoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "switch_video" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SynagogueIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "synagogue" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SyncIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sync" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SyncAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sync_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SyncDisabledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sync_disabled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SyncLockIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sync_lock" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SyncProblemIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "sync_problem" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SystemSecurityUpdateIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "system_security_update" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SystemSecurityUpdateGoodIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "system_security_update_good" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SystemSecurityUpdateWarningIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "system_security_update_warning" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SystemUpdateIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "system_update" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SystemUpdateAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "system_update_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function SystemUpdateTvIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "system_update_tv" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TabIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tab" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TabUnselectedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tab_unselected" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TableBarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "table_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TableChartIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "table_chart" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TableRestaurantIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "table_restaurant" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TableRowsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "table_rows" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TableViewIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "table_view" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TabletIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tablet" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TabletAndroidIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tablet_android" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TabletMacIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tablet_mac" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TagIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tag" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TagFacesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tag_faces" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TakeoutDiningIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "takeout_dining" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TapAndPlayIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tap_and_play" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TapasIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tapas" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TaskIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "task" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TaskAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "task_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TaxiAlertIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "taxi_alert" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TelegramIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "telegram" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TempleBuddhistIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "temple_buddhist" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TempleHinduIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "temple_hindu" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TerminalIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "terminal" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TerrainIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "terrain" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TextDecreaseIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "text_decrease" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TextFieldsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "text_fields" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TextFormatIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "text_format" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TextIncreaseIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "text_increase" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TextRotateUpIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "text_rotate_up" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TextRotateVerticalIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "text_rotate_vertical" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TextRotationAngledownIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "text_rotation_angledown" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TextRotationAngleupIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "text_rotation_angleup" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TextRotationDownIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "text_rotation_down" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TextRotationNoneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "text_rotation_none" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TextSnippetIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "text_snippet" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TextsmsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "textsms" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TextureIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "texture" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TheaterComedyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "theater_comedy" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TheatersIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "theaters" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ThermostatIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "thermostat" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ThermostatAutoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "thermostat_auto" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ThumbDownIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "thumb_down" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ThumbDownAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "thumb_down_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ThumbDownOffAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "thumb_down_off_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ThumbUpIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "thumb_up" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ThumbUpAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "thumb_up_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ThumbUpOffAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "thumb_up_off_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ThumbsUpDownIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "thumbs_up_down" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ThunderstormIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "thunderstorm" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TiktokIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tiktok" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TimeToLeaveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "time_to_leave" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TimelapseIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "timelapse" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TimelineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "timeline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TimerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "timer" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Timer10Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "timer_10" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Timer10SelectIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "timer_10_select" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Timer3Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "timer_3" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Timer3SelectIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "timer_3_select" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TimerOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "timer_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TipsAndUpdatesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tips_and_updates" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TireRepairIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tire_repair" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TitleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "title" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TocIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "toc" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TodayIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "today" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ToggleOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "toggle_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ToggleOnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "toggle_on" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TokenIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "token" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TollIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "toll" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TonalityIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tonality" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TopicIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "topic" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TornadoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tornado" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TouchAppIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "touch_app" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TourIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tour" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ToysIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "toys" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TrackChangesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "track_changes" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TrafficIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "traffic" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TrainIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "train" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TramIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tram" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TranscribeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "transcribe" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TransferWithinAStationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "transfer_within_a_station" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TransformIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "transform" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TransgenderIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "transgender" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TransitEnterexitIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "transit_enterexit" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TranslateIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "translate" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TravelExploreIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "travel_explore" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TrendingDownIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "trending_down" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TrendingFlatIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "trending_flat" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TrendingNeutralIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "trending_neutral" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TrendingUpIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "trending_up" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TripOriginIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "trip_origin" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TroubleshootIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "troubleshoot" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TryIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "try" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TsunamiIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tsunami" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TtyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tty" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TuneIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tune" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TungstenIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tungsten" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TurnLeftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "turn_left" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TurnRightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "turn_right" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TurnSharpLeftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "turn_sharp_left" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TurnSharpRightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "turn_sharp_right" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TurnSlightLeftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "turn_slight_left" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TurnSlightRightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "turn_slight_right" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TurnedInIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "turned_in" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TurnedInNotIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "turned_in_not" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TvIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tv" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TvOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "tv_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TwoWheelerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "two_wheeler" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function TypeSpecimenIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "type_specimen" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function UTurnLeftIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "u_turn_left" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function UTurnRightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "u_turn_right" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function UmbrellaIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "umbrella" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function UnarchiveIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "unarchive" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function UndoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "undo" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function UnfoldLessIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "unfold_less" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function UnfoldLessDoubleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "unfold_less_double" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function UnfoldMoreIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "unfold_more" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function UnfoldMoreDoubleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "unfold_more_double" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function UnpublishedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "unpublished" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function UnsubscribeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "unsubscribe" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function UpcomingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "upcoming" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function UpdateIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "update" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function UpdateDisabledIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "update_disabled" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function UpgradeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "upgrade" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function UploadIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "upload" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function UploadFileIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "upload_file" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function UsbIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "usb" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function UsbOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "usb_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VaccinesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "vaccines" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VapeFreeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "vape_free" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VapingRoomsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "vaping_rooms" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VerifiedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "verified" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VerifiedUserIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "verified_user" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VerticalAlignBottomIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "vertical_align_bottom" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VerticalAlignCenterIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "vertical_align_center" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VerticalAlignTopIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "vertical_align_top" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VerticalDistributeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "vertical_distribute" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VerticalShadesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "vertical_shades" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VerticalShadesClosedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "vertical_shades_closed" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VerticalSplitIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "vertical_split" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VibrationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "vibration" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VideoCallIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "video_call" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VideoCameraBackIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "video_camera_back" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VideoCameraFrontIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "video_camera_front" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VideoChatIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "video_chat" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VideoCollectionIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "video_collection" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VideoFileIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "video_file" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VideoLabelIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "video_label" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VideoLibraryIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "video_library" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VideoSettingsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "video_settings" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VideoStableIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "video_stable" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VideocamIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "videocam" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VideocamOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "videocam_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VideogameAssetIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "videogame_asset" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VideogameAssetOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "videogame_asset_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewAgendaIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_agenda" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewArrayIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_array" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewCarouselIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_carousel" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewColumnIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_column" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewComfortableIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_comfortable" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewComfyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_comfy" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewComfyAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_comfy_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewCompactIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_compact" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewCompactAltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_compact_alt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewCozyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_cozy" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewDayIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_day" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewHeadlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_headline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewInArIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_in_ar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewKanbanIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_kanban" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewListIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_list" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewModuleIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_module" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewQuiltIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_quilt" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewSidebarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_sidebar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewStreamIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_stream" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewTimelineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_timeline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ViewWeekIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "view_week" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VignetteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "vignette" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VillaIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "villa" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VisibilityIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "visibility" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VisibilityOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "visibility_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VoiceChatIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "voice_chat" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VoiceOverOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "voice_over_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VoicemailIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "voicemail" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VolcanoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "volcano" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VolumeDownIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "volume_down" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VolumeMuteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "volume_mute" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VolumeOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "volume_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VolumeUpIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "volume_up" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VolunteerActivismIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "volunteer_activism" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VpnKeyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "vpn_key" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VpnKeyOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "vpn_key_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VpnLockIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "vpn_lock" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function VrpanoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "vrpano" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WalletIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wallet" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WalletGiftcardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wallet_giftcard" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WalletMembershipIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wallet_membership" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WalletTravelIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wallet_travel" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WallpaperIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wallpaper" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WarehouseIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "warehouse" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WarningIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "warning" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WarningAmberIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "warning_amber" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WashIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wash" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WatchIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "watch" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WatchLaterIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "watch_later" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WatchOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "watch_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WaterIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "water" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WaterDamageIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "water_damage" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WaterDropIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "water_drop" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WaterfallChartIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "waterfall_chart" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WavesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "waves" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WavingHandIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "waving_hand" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WbAutoIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wb_auto" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WbCloudyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wb_cloudy" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WbIncandescentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wb_incandescent" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WbIridescentIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wb_iridescent" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WbShadeIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wb_shade" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WbSunnyIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wb_sunny" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WbTwilightIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wb_twilight" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WcIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wc" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WebIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "web" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WebAssetIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "web_asset" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WebAssetOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "web_asset_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WebStoriesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "web_stories" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WebhookIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "webhook" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WechatIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wechat" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WeekendIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "weekend" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WestIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "west" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WhatshotIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "whatshot" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WheelchairPickupIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wheelchair_pickup" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WhereToVoteIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "where_to_vote" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WidgetsIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "widgets" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WidthFullIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "width_full" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WidthNormalIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "width_normal" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WidthWideIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "width_wide" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WifiIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wifi" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Wifi1BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wifi_1_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Wifi2BarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wifi_2_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WifiCallingIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wifi_calling" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WifiCalling3Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wifi_calling_3" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WifiChannelIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wifi_channel" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WifiFindIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wifi_find" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WifiLockIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wifi_lock" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WifiOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wifi_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WifiPasswordIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wifi_password" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WifiProtectedSetupIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wifi_protected_setup" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WifiTetheringIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wifi_tethering" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WifiTetheringErrorIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wifi_tethering_error" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WifiTetheringErrorRoundedIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wifi_tethering_error_rounded" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WifiTetheringOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wifi_tethering_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WindPowerIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wind_power" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WindowIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "window" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WineBarIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wine_bar" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WomanIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "woman" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Woman2Icon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "woman_2" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WooCommerceIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "woo_commerce" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WordpressIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wordpress" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WorkIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "work" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WorkHistoryIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "work_history" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WorkOffIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "work_off" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WorkOutlineIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "work_outline" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WorkspacePremiumIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "workspace_premium" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WorkspacesIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "workspaces" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WrapTextIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wrap_text" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WrongLocationIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wrong_location" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function WysiwygIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "wysiwyg" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function YardIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "yard" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function YoutubeSearchedForIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "youtube_searched_for" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ZoomInIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "zoom_in" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ZoomInMapIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "zoom_in_map" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ZoomOutIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "zoom_out" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ZoomOutMapIcon(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...props, iconKey: "zoom_out_map" });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
const sizeClasses$1 = {
  large: "w-6 h-6 rounded flex items-center justify-center",
  medium: "w-5 h-5 rounded flex items-center justify-center",
  small: "w-4 h-4 rounded flex items-center justify-center",
  smallest: "w-4 h-4 rounded flex items-center justify-center"
};
const outerSizeClasses = {
  medium: "w-10 h-10",
  small: "w-8 h-8",
  large: "w-12 h-12 ",
  smallest: "w-6 h-6"
};
const paddingClasses = {
  medium: "p-2",
  small: "p-2",
  large: "p-2",
  smallest: ""
};
const colorClasses$2 = {
  primary: "bg-primary",
  secondary: "bg-secondary"
};
const Checkbox = (t0) => {
  const $ = c_1(25);
  const {
    id,
    checked,
    indeterminate: t1,
    padding: t2,
    disabled,
    size: t3,
    onCheckedChange,
    color: t4
  } = t0;
  const indeterminate = t1 === void 0 ? false : t1;
  const padding = t2 === void 0 ? true : t2;
  const size2 = t3 === void 0 ? "medium" : t3;
  const color = t4 === void 0 ? "primary" : t4;
  const isChecked = indeterminate ? false : checked;
  const iconSize = size2 === "medium" ? 20 : size2 === "small" ? 16 : size2 === "smallest" ? 14 : 24;
  const t5 = indeterminate || isChecked;
  const t6 = disabled ? void 0 : onCheckedChange;
  const t7 = padding ? paddingClasses[size2] : "";
  const t8 = outerSizeClasses[size2];
  const t9 = onCheckedChange ? "rounded-full hover:bg-surface-accent-200 hover:bg-opacity-75 dark:hover:bg-surface-accent-700 dark:hover:bg-opacity-75" : "";
  const t10 = onCheckedChange ? "cursor-pointer" : "cursor-default";
  let t11;
  if ($[0] !== t10 || $[1] !== t7 || $[2] !== t8 || $[3] !== t9) {
    t11 = cls(t7, t8, "inline-flex items-center justify-center text-sm font-medium focus:outline-none transition-colors ease-in-out duration-150", t9, t10);
    $[0] = t10;
    $[1] = t7;
    $[2] = t8;
    $[3] = t9;
    $[4] = t11;
  } else {
    t11 = $[4];
  }
  const t12 = sizeClasses$1[size2];
  const t13 = disabled ? indeterminate || isChecked ? "bg-surface-accent-400 dark:bg-surface-accent-600" : "bg-surface-accent-400 dark:bg-surface-accent-600" : indeterminate || isChecked ? colorClasses$2[color] : "bg-white dark:bg-surface-900";
  const t14 = indeterminate || isChecked ? "text-surface-accent-100 dark:text-surface-accent-900" : "";
  const t15 = disabled ? "border-transparent" : indeterminate || isChecked ? "border-transparent" : "border-surface-accent-800 dark:border-surface-accent-200";
  let t16;
  if ($[5] !== t12 || $[6] !== t13 || $[7] !== t14 || $[8] !== t15) {
    t16 = cls("border-2 relative transition-colors ease-in-out duration-150", t12, t13, t14, t15);
    $[5] = t12;
    $[6] = t13;
    $[7] = t14;
    $[8] = t15;
    $[9] = t16;
  } else {
    t16 = $[9];
  }
  let t17;
  if ($[10] !== iconSize || $[11] !== indeterminate) {
    t17 = /* @__PURE__ */ jsxRuntimeExports.jsx(Indicator$1, { asChild: true, children: indeterminate ? /* @__PURE__ */ jsxRuntimeExports.jsx(RemoveIcon, { size: iconSize, className: "absolute" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon, { size: iconSize, className: "absolute" }) });
    $[10] = iconSize;
    $[11] = indeterminate;
    $[12] = t17;
  } else {
    t17 = $[12];
  }
  let t18;
  if ($[13] !== t16 || $[14] !== t17) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t16, children: t17 });
    $[13] = t16;
    $[14] = t17;
    $[15] = t18;
  } else {
    t18 = $[15];
  }
  let t19;
  if ($[16] !== t11 || $[17] !== t18) {
    t19 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t11, children: t18 });
    $[16] = t11;
    $[17] = t18;
    $[18] = t19;
  } else {
    t19 = $[18];
  }
  let t20;
  if ($[19] !== disabled || $[20] !== id || $[21] !== t19 || $[22] !== t5 || $[23] !== t6) {
    t20 = /* @__PURE__ */ jsxRuntimeExports.jsx(Root$7, { id, checked: t5, disabled, onCheckedChange: t6, children: t19 });
    $[19] = disabled;
    $[20] = id;
    $[21] = t19;
    $[22] = t5;
    $[23] = t6;
    $[24] = t20;
  } else {
    t20 = $[24];
  }
  return t20;
};
const sizeClassNames = {
  small: "px-2 py-0.5 text-sm",
  medium: "px-3 py-1 text-sm",
  large: "px-4 py-1.5 text-sm"
};
function Chip(t0) {
  const $ = c_1(18);
  const {
    children,
    colorScheme,
    error,
    onClick,
    icon,
    size: t1,
    className,
    style
  } = t0;
  const size2 = t1 === void 0 ? "large" : t1;
  let t2;
  if ($[0] !== colorScheme) {
    t2 = typeof colorScheme === "string" ? getColorSchemeForKey(colorScheme) : colorScheme;
    $[0] = colorScheme;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  const usedColorScheme = t2;
  const t3 = onClick ? "cursor-pointer hover:bg-surface-accent-300 hover:dark:bg-surface-accent-700" : "";
  const t4 = sizeClassNames[size2];
  const t5 = error || !usedColorScheme ? "bg-surface-accent-200 dark:bg-surface-accent-800 text-surface-accent-800 dark:text-white" : "";
  const t6 = error ? "text-red-500 dark:text-red-400" : "";
  let t7;
  if ($[2] !== className || $[3] !== t3 || $[4] !== t4 || $[5] !== t5 || $[6] !== t6) {
    t7 = cls("rounded-lg max-w-full w-max h-fit font-regular inline-flex gap-1", "text-ellipsis", t3, t4, t5, t6, className);
    $[2] = className;
    $[3] = t3;
    $[4] = t4;
    $[5] = t5;
    $[6] = t6;
    $[7] = t7;
  } else {
    t7 = $[7];
  }
  const t8 = error || !usedColorScheme ? void 0 : usedColorScheme.color;
  const t9 = error || !usedColorScheme ? void 0 : usedColorScheme.text;
  let t10;
  if ($[8] !== style || $[9] !== t8 || $[10] !== t9) {
    t10 = {
      backgroundColor: t8,
      color: t9,
      overflow: "hidden",
      ...style
    };
    $[8] = style;
    $[9] = t8;
    $[10] = t9;
    $[11] = t10;
  } else {
    t10 = $[11];
  }
  let t11;
  if ($[12] !== children || $[13] !== icon || $[14] !== onClick || $[15] !== t10 || $[16] !== t7) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t7, onClick, style: t10, children: [
      children,
      icon
    ] });
    $[12] = children;
    $[13] = icon;
    $[14] = onClick;
    $[15] = t10;
    $[16] = t7;
    $[17] = t11;
  } else {
    t11 = $[17];
  }
  return t11;
}
const buttonClasses = "hover:bg-surface-accent-200 hover:bg-opacity-75 dark:hover:bg-surface-accent-800 hover:scale-105 transition-transform";
const baseClasses = "inline-flex items-center justify-center p-2 text-sm font-medium focus:outline-none transition-colors ease-in-out duration-150";
const colorClasses$1 = "text-surface-accent-600 visited:text-surface-accent-600 dark:text-surface-accent-300 dark:visited:text-surface-300";
const sizeClasses = {
  medium: "w-10 !h-10 min-w-10 min-h-10",
  small: "w-8 !h-8 min-w-8 min-h-8",
  smallest: "w-6 !h-6 min-w-6 min-h-6",
  large: "w-12 !h-12 min-w-12 min-h-12"
};
const shapeClasses = {
  circular: "rounded-full",
  square: "rounded-md"
};
const IconButtonInner = (t0, ref) => {
  const $ = c_1(23);
  let children;
  let className;
  let component;
  let disabled;
  let props;
  let t1;
  let t2;
  let t3;
  let toggled;
  if ($[0] !== t0) {
    ({
      children,
      className,
      size: t1,
      variant: t2,
      shape: t3,
      disabled,
      toggled,
      component,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = className;
    $[3] = component;
    $[4] = disabled;
    $[5] = props;
    $[6] = t1;
    $[7] = t2;
    $[8] = t3;
    $[9] = toggled;
  } else {
    children = $[1];
    className = $[2];
    component = $[3];
    disabled = $[4];
    props = $[5];
    t1 = $[6];
    t2 = $[7];
    t3 = $[8];
    toggled = $[9];
  }
  const size2 = t1 === void 0 ? "medium" : t1;
  const variant = t2 === void 0 ? "ghost" : t2;
  const shape = t3 === void 0 ? "circular" : t3;
  const bgClasses = variant === "ghost" ? "bg-transparent" : "bg-surface-accent-200 bg-opacity-50 dark:bg-surface-950 dark:bg-opacity-50";
  const Component = component || "button";
  const t4 = disabled ? "opacity-50 pointer-events-none" : "cursor-pointer";
  const t5 = toggled ? "outline outline-2 outline-primary" : "";
  const t6 = shapeClasses[shape];
  const t7 = sizeClasses[size2];
  let t8;
  if ($[10] !== bgClasses || $[11] !== className || $[12] !== t4 || $[13] !== t5 || $[14] !== t6 || $[15] !== t7) {
    t8 = cls(t4, t5, colorClasses$1, bgClasses, baseClasses, buttonClasses, t6, t7, className);
    $[10] = bgClasses;
    $[11] = className;
    $[12] = t4;
    $[13] = t5;
    $[14] = t6;
    $[15] = t7;
    $[16] = t8;
  } else {
    t8 = $[16];
  }
  let t9;
  if ($[17] !== Component || $[18] !== children || $[19] !== props || $[20] !== ref || $[21] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { type: "button", ref, ...props, className: t8, children });
    $[17] = Component;
    $[18] = children;
    $[19] = props;
    $[20] = ref;
    $[21] = t8;
    $[22] = t9;
  } else {
    t9 = $[22];
  }
  return t9;
};
const IconButton = React__default.forwardRef(IconButtonInner);
const defaultClasses = {
  root: "origin-left transition-transform block whitespace-nowrap overflow-hidden text-overflow-ellipsis max-w-full",
  shrink: "transform translate-y-[2px] scale-75 translate-x-[12px]",
  expanded: "translate-x-[16px] top-0 transform translate-y-[16px] scale-100"
};
const InputLabel = React.forwardRef(function InputLabel2(inProps, ref) {
  const $ = c_1(13);
  let className;
  let other;
  let shrink;
  if ($[0] !== inProps) {
    ({
      shrink,
      className,
      ...other
    } = inProps);
    $[0] = inProps;
    $[1] = className;
    $[2] = other;
    $[3] = shrink;
  } else {
    className = $[1];
    other = $[2];
    shrink = $[3];
  }
  const t0 = !shrink;
  let t1;
  if ($[4] !== className || $[5] !== shrink || $[6] !== t0) {
    const computedClassName = cls(defaultClasses.root, {
      [defaultClasses.shrink]: shrink,
      [defaultClasses.expanded]: t0
    }, className);
    t1 = cls("text-sm font-medium peer-disabled:cursor-not-allowed peer-disabled:opacity-70", defaultBorderMixin, computedClassName);
    $[4] = className;
    $[5] = shrink;
    $[6] = t0;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  let t2;
  if ($[8] !== other || $[9] !== ref || $[10] !== shrink || $[11] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: t1, "data-shrink": shrink, ref, ...other });
    $[8] = other;
    $[9] = ref;
    $[10] = shrink;
    $[11] = t1;
    $[12] = t2;
  } else {
    t2 = $[12];
  }
  return t2;
});
const typographyVariants = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  label: "label",
  body1: "p",
  body2: "p",
  inherit: "p",
  caption: "p",
  button: "span"
};
const colorToClasses = {
  inherit: "text-inherit",
  initial: "text-current",
  primary: "text-text-primary dark:text-text-primary-dark",
  secondary: "text-text-secondary dark:text-text-secondary-dark",
  disabled: "text-text-disabled dark:text-text-disabled-dark",
  error: "text-red-600 dark:text-red-500"
};
const gutterBottomClasses = {
  h1: "mb-5",
  h2: "mb-4",
  h3: "mb-4",
  h4: "mb-4",
  h5: "mb-3",
  h6: "mb-3",
  subtitle1: "mb-3",
  subtitle2: "mb-3",
  body1: "mb-3",
  body2: "mb-3",
  inherit: "mb-3",
  caption: "mb-2",
  button: "mb-2",
  label: "mb-2"
};
const variantToClasses = {
  h1: "typography-h1",
  h2: "typography-h2",
  h3: "typography-h3",
  h4: "typography-h4",
  h5: "typography-h5",
  h6: "typography-h6",
  subtitle1: "typography-subtitle1",
  subtitle2: "typography-subtitle2",
  body1: "typography-body1",
  body2: "typography-body2",
  label: "typography-label",
  inherit: "typography-inherit",
  caption: "typography-caption",
  button: "typography-button"
};
function Typography(t0) {
  const $ = c_1(29);
  let children;
  let className;
  let component;
  let onClick;
  let other;
  let style;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  if ($[0] !== t0) {
    ({
      align: t1,
      color: t2,
      children,
      className,
      component,
      gutterBottom: t3,
      noWrap: t4,
      paragraph: t5,
      variant: t6,
      variantMapping: t7,
      style,
      onClick,
      ...other
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = className;
    $[3] = component;
    $[4] = onClick;
    $[5] = other;
    $[6] = style;
    $[7] = t1;
    $[8] = t2;
    $[9] = t3;
    $[10] = t4;
    $[11] = t5;
    $[12] = t6;
    $[13] = t7;
  } else {
    children = $[1];
    className = $[2];
    component = $[3];
    onClick = $[4];
    other = $[5];
    style = $[6];
    t1 = $[7];
    t2 = $[8];
    t3 = $[9];
    t4 = $[10];
    t5 = $[11];
    t6 = $[12];
    t7 = $[13];
  }
  const align = t1 === void 0 ? "inherit" : t1;
  const color = t2 === void 0 ? "primary" : t2;
  const gutterBottom = t3 === void 0 ? false : t3;
  const noWrap = t4 === void 0 ? false : t4;
  const paragraph = t5 === void 0 ? false : t5;
  const variant = t6 === void 0 ? "body1" : t6;
  const variantMapping = t7 === void 0 ? typographyVariants : t7;
  const Component = component || (paragraph ? "p" : variantMapping[variant] || typographyVariants[variant]) || "span";
  const t8 = variantToClasses[variant];
  const t9 = color ? colorToClasses[color] : "";
  const t10 = align !== "inherit" && `text-${align}`;
  const t11 = gutterBottom && gutterBottomClasses[variant];
  const t12 = noWrap && "truncate";
  const t13 = paragraph && "mb-3";
  let t14;
  if ($[14] !== className || $[15] !== t10 || $[16] !== t11 || $[17] !== t12 || $[18] !== t13 || $[19] !== t8 || $[20] !== t9) {
    t14 = cls(t8, t9, t10, t11, t12, t13, className);
    $[14] = className;
    $[15] = t10;
    $[16] = t11;
    $[17] = t12;
    $[18] = t13;
    $[19] = t8;
    $[20] = t9;
    $[21] = t14;
  } else {
    t14 = $[21];
  }
  const classes = t14;
  let t15;
  if ($[22] !== Component || $[23] !== children || $[24] !== classes || $[25] !== onClick || $[26] !== other || $[27] !== style) {
    t15 = /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { className: classes, onClick, style, ...other, children });
    $[22] = Component;
    $[23] = children;
    $[24] = classes;
    $[25] = onClick;
    $[26] = other;
    $[27] = style;
    $[28] = t15;
  } else {
    t15 = $[28];
  }
  return t15;
}
const DateTimeField = (t0) => {
  const $ = c_1(52);
  const {
    value,
    label,
    onChange,
    disabled,
    clearable,
    mode: t1,
    error,
    size: t2,
    className,
    style,
    inputClassName,
    invisible
  } = t0;
  const mode = t1 === void 0 ? "date" : t1;
  const size2 = t2 === void 0 ? "large" : t2;
  const inputRef = useRef(null);
  const [focused, setFocused] = useState(false);
  const invalidValue = value !== void 0 && value !== null && !(value instanceof Date);
  useInjectStyles("DateTimeField", inputStyles);
  let t3;
  if ($[0] !== onChange) {
    t3 = (e) => {
      e.preventDefault();
      onChange?.(null);
    };
    $[0] = onChange;
    $[1] = t3;
  } else {
    t3 = $[1];
  }
  const handleClear = t3;
  const valueAsInputValue = _temp2$1;
  let t4;
  if ($[2] !== mode || $[3] !== onChange) {
    t4 = (e_0) => {
      const inputValue = e_0.target.value;
      if (!inputValue) {
        onChange?.(null);
        return;
      }
      let newDate;
      try {
        if (mode === "date_time") {
          const [datePart, timePart] = inputValue.split("T");
          const [year_0, month_0, day_0] = datePart.split("-").map(Number);
          const [hours_0, minutes_0] = timePart.split(":").map(Number);
          newDate = new Date(year_0, month_0 - 1, day_0, hours_0, minutes_0);
        } else {
          const [year_1, month_1, day_1] = inputValue.split("-").map(Number);
          newDate = new Date(year_1, month_1 - 1, day_1);
        }
      } catch (t52) {
        newDate = null;
      }
      onChange?.(newDate);
    };
    $[2] = mode;
    $[3] = onChange;
    $[4] = t4;
  } else {
    t4 = $[4];
  }
  const handleInputChange = t4;
  let t5;
  if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: inputStyles });
    $[5] = t5;
  } else {
    t5 = $[5];
  }
  const t6 = !invisible && fieldBackgroundMixin;
  const t7 = disabled ? fieldBackgroundDisabledMixin : fieldBackgroundHoverMixin;
  const t8 = size2 === "medium";
  const t9 = size2 === "large";
  let t10;
  if ($[6] !== className || $[7] !== t6 || $[8] !== t7 || $[9] !== t8 || $[10] !== t9) {
    t10 = cls("rounded-md relative max-w-full", t6, t7, {
      "min-h-[48px]": t8,
      "min-h-[64px]": t9
    }, className);
    $[6] = className;
    $[7] = t6;
    $[8] = t7;
    $[9] = t8;
    $[10] = t9;
    $[11] = t10;
  } else {
    t10 = $[11];
  }
  let t11;
  if ($[12] !== disabled) {
    t11 = () => {
      if (!disabled) {
        inputRef.current?.focus();
      }
    };
    $[12] = disabled;
    $[13] = t11;
  } else {
    t11 = $[13];
  }
  let t12;
  if ($[14] !== disabled || $[15] !== error || $[16] !== focused || $[17] !== label) {
    t12 = label && /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { className: cls("absolute top-1 pointer-events-none", !error ? focused ? "text-primary" : "text-text-secondary dark:text-text-secondary-dark" : "text-red-500 dark:text-red-500", disabled ? "opacity-50" : ""), shrink: true, children: label });
    $[14] = disabled;
    $[15] = error;
    $[16] = focused;
    $[17] = label;
    $[18] = t12;
  } else {
    t12 = $[18];
  }
  const t13 = mode === "date_time" ? "datetime-local" : "date";
  const t14 = valueAsInputValue(value ?? null, mode);
  let t15;
  let t16;
  if ($[19] === Symbol.for("react.memo_cache_sentinel")) {
    t15 = () => setFocused(true);
    t16 = () => setFocused(false);
    $[19] = t15;
    $[20] = t16;
  } else {
    t15 = $[19];
    t16 = $[20];
  }
  const t17 = clearable ? "pr-14" : "pr-12";
  const t18 = size2 === "medium" ? "min-h-[48px]" : "min-h-[64px]";
  const t19 = label ? "pt-8 pb-2" : "py-2";
  const t20 = disabled && "border border-transparent outline-none opacity-50 dark:opacity-50 text-surface-accent-600 dark:text-surface-accent-500";
  let t21;
  if ($[21] !== inputClassName || $[22] !== t17 || $[23] !== t18 || $[24] !== t19 || $[25] !== t20) {
    t21 = cls("w-full outline-none bg-transparent leading-normal text-base px-3", t17, "rounded-md", t18, t19, inputClassName, t20);
    $[21] = inputClassName;
    $[22] = t17;
    $[23] = t18;
    $[24] = t19;
    $[25] = t20;
    $[26] = t21;
  } else {
    t21 = $[26];
  }
  let t22;
  if ($[27] !== disabled || $[28] !== handleInputChange || $[29] !== t13 || $[30] !== t14 || $[31] !== t21) {
    t22 = /* @__PURE__ */ jsxRuntimeExports.jsx("input", { ref: inputRef, type: t13, value: t14, onChange: handleInputChange, onFocus: t15, onBlur: t16, disabled, className: t21 });
    $[27] = disabled;
    $[28] = handleInputChange;
    $[29] = t13;
    $[30] = t14;
    $[31] = t21;
    $[32] = t22;
  } else {
    t22 = $[32];
  }
  let t23;
  if ($[33] === Symbol.for("react.memo_cache_sentinel")) {
    t23 = (e_2) => {
      e_2.stopPropagation();
      inputRef.current?.showPicker();
    };
    $[33] = t23;
  } else {
    t23 = $[33];
  }
  let t24;
  if ($[34] === Symbol.for("react.memo_cache_sentinel")) {
    t24 = /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: t23, className: "absolute right-3 top-1/2 transform -translate-y-1/2 !text-surface-accent-500", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CalendarMonthIcon, { color: "disabled" }) });
    $[34] = t24;
  } else {
    t24 = $[34];
  }
  let t25;
  if ($[35] !== clearable || $[36] !== handleClear || $[37] !== value) {
    t25 = clearable && value && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: handleClear, className: "absolute right-14 top-1/2 transform -translate-y-1/2 text-surface-accent-400 ", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {}) });
    $[35] = clearable;
    $[36] = handleClear;
    $[37] = value;
    $[38] = t25;
  } else {
    t25 = $[38];
  }
  let t26;
  if ($[39] !== style || $[40] !== t10 || $[41] !== t11 || $[42] !== t12 || $[43] !== t22 || $[44] !== t25) {
    t26 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t10, style, onClick: t11, children: [
      t12,
      t22,
      t24,
      t25
    ] });
    $[39] = style;
    $[40] = t10;
    $[41] = t11;
    $[42] = t12;
    $[43] = t22;
    $[44] = t25;
    $[45] = t26;
  } else {
    t26 = $[45];
  }
  let t27;
  if ($[46] !== invalidValue || $[47] !== value) {
    t27 = invalidValue && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center m-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorIcon, { size: "medium", color: "error" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pl-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: "Invalid date value for this field" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: `The provided value is: ${JSON.stringify(value)}` })
      ] })
    ] });
    $[46] = invalidValue;
    $[47] = value;
    $[48] = t27;
  } else {
    t27 = $[48];
  }
  let t28;
  if ($[49] !== t26 || $[50] !== t27) {
    t28 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t5,
      t26,
      t27
    ] });
    $[49] = t26;
    $[50] = t27;
    $[51] = t28;
  } else {
    t28 = $[51];
  }
  return t28;
};
const inputStyles = `
    /* Hide the default calendar icon in Chrome, Safari, Edge, Opera */
    input[type="date"]::-webkit-calendar-picker-indicator,
    input[type="datetime-local"]::-webkit-calendar-picker-indicator {
        display: none;
        -webkit-appearance: none;
    }
    /* Hide default calendar icon in Firefox */
    input[type="date"],
    input[type="datetime-local"] {
        -moz-appearance:textfield;
    }
  `;
function _temp$3(n) {
  return n.toString().padStart(2, "0");
}
function _temp2$1(dateValue, mode_0) {
  if (!dateValue) {
    return "";
  }
  const pad = _temp$3;
  const year = dateValue.getFullYear();
  const month = pad(dateValue.getMonth() + 1);
  const day = pad(dateValue.getDate());
  if (mode_0 === "date") {
    return `${year}-${month}-${day}`;
  } else {
    const hours = pad(dateValue.getHours());
    const minutes = pad(dateValue.getMinutes());
    return `${year}-${month}-${day}T${hours}:${minutes}`;
  }
}
const widthClasses = {
  xs: "max-w-xs min-w-xs w-xs",
  sm: "max-w-sm min-w-sm w-sm",
  md: "max-w-md min-w-md w-md",
  lg: "max-w-lg min-w-lg w-lg",
  xl: "max-w-xl min-w-xl w-xl",
  "2xl": "max-w-2xl min-w-2xl w-2xl",
  "3xl": "max-w-3xl min-w-3xl w-3xl",
  "4xl": "max-w-4xl min-w-4xl w-4xl",
  "5xl": "max-w-5xl min-w-5xl w-5xl",
  "6xl": "max-w-6xl min-w-6xl w-6xl",
  "7xl": "max-w-7xl min-w-7xl w-7xl",
  full: "max-w-full min-w-full w-full"
};
const Dialog = (t0) => {
  const $ = c_1(36);
  const {
    open,
    onOpenChange,
    children,
    className,
    fullWidth: t1,
    fullHeight,
    fullScreen,
    scrollable: t2,
    maxWidth: t3,
    modal: t4,
    onOpenAutoFocus,
    onEscapeKeyDown,
    onPointerDownOutside,
    onInteractOutside
  } = t0;
  const fullWidth = t1 === void 0 ? true : t1;
  const scrollable = t2 === void 0 ? true : t2;
  const maxWidth = t3 === void 0 ? "lg" : t3;
  const modal = t4 === void 0 ? true : t4;
  const [displayed, setDisplayed] = useState(false);
  let t5;
  let t6;
  if ($[0] !== open) {
    t5 = () => {
      if (!open) {
        const timeout = setTimeout(() => {
          setDisplayed(false);
        }, 150);
        return () => clearTimeout(timeout);
      } else {
        setDisplayed(true);
        return _temp$2;
      }
    };
    t6 = [open];
    $[0] = open;
    $[1] = t5;
    $[2] = t6;
  } else {
    t5 = $[1];
    t6 = $[2];
  }
  useEffect(t5, t6);
  const t7 = displayed || open;
  const t8 = displayed && open ? "opacity-100" : "opacity-0";
  let t9;
  if ($[3] !== t8) {
    t9 = cls("fixed inset-0 transition-opacity z-20 ease-in-out duration-200 bg-black bg-opacity-50 dark:bg-opacity-60 backdrop-blur-sm ", t8, "z-20 fixed top-0 left-0 w-full h-full flex justify-center items-center");
    $[3] = t8;
    $[4] = t9;
  } else {
    t9 = $[4];
  }
  const t10 = displayed ? "auto" : "none";
  let t11;
  if ($[5] !== t10) {
    t11 = {
      pointerEvents: t10
    };
    $[5] = t10;
    $[6] = t11;
  } else {
    t11 = $[6];
  }
  let t12;
  if ($[7] !== t11 || $[8] !== t9) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(Overlay, { className: t9, style: t11 });
    $[7] = t11;
    $[8] = t9;
    $[9] = t12;
  } else {
    t12 = $[9];
  }
  let t13;
  if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
    t13 = cls("h-full outline-none flex justify-center items-center z-40 opacity-100 transition-all duration-200 ease-in-out");
    $[10] = t13;
  } else {
    t13 = $[10];
  }
  const t14 = fullWidth && !fullScreen ? "w-11/12" : void 0;
  const t15 = fullHeight && !fullScreen ? "h-full" : void 0;
  const t16 = fullScreen ? "h-screen w-screen" : "max-h-[90vh] shadow-xl";
  const t17 = scrollable && "overflow-y-auto";
  const t18 = displayed && open ? "opacity-100" : "opacity-0";
  const t19 = maxWidth && !fullScreen ? widthClasses[maxWidth] : void 0;
  let t20;
  if ($[11] !== className || $[12] !== t14 || $[13] !== t15 || $[14] !== t16 || $[15] !== t17 || $[16] !== t18 || $[17] !== t19) {
    t20 = cls(paperMixin, "z-30", "relative", "outline-none focus:outline-none", t14, t15, "text-surface-accent-900 dark:text-white", "justify-center items-center", t16, "ease-in-out duration-200", t17, t18, t19, className);
    $[11] = className;
    $[12] = t14;
    $[13] = t15;
    $[14] = t16;
    $[15] = t17;
    $[16] = t18;
    $[17] = t19;
    $[18] = t20;
  } else {
    t20 = $[18];
  }
  let t21;
  if ($[19] !== children || $[20] !== t20) {
    t21 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t20, children });
    $[19] = children;
    $[20] = t20;
    $[21] = t21;
  } else {
    t21 = $[21];
  }
  let t22;
  if ($[22] !== onEscapeKeyDown || $[23] !== onInteractOutside || $[24] !== onOpenAutoFocus || $[25] !== onPointerDownOutside || $[26] !== t21) {
    t22 = /* @__PURE__ */ jsxRuntimeExports.jsx(Content$1, { onEscapeKeyDown, onOpenAutoFocus, onPointerDownOutside, onInteractOutside, className: t13, children: t21 });
    $[22] = onEscapeKeyDown;
    $[23] = onInteractOutside;
    $[24] = onOpenAutoFocus;
    $[25] = onPointerDownOutside;
    $[26] = t21;
    $[27] = t22;
  } else {
    t22 = $[27];
  }
  let t23;
  if ($[28] !== t12 || $[29] !== t22) {
    t23 = /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$4, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fixed inset-0 z-30", children: [
      t12,
      t22
    ] }) });
    $[28] = t12;
    $[29] = t22;
    $[30] = t23;
  } else {
    t23 = $[30];
  }
  let t24;
  if ($[31] !== modal || $[32] !== onOpenChange || $[33] !== t23 || $[34] !== t7) {
    t24 = /* @__PURE__ */ jsxRuntimeExports.jsx(Root$6, { open: t7, modal, onOpenChange, children: t23 });
    $[31] = modal;
    $[32] = onOpenChange;
    $[33] = t23;
    $[34] = t7;
    $[35] = t24;
  } else {
    t24 = $[35];
  }
  return t24;
};
function _temp$2() {
}
function DialogActions(t0) {
  const $ = c_1(7);
  const {
    children,
    position: t1,
    translucent: t2,
    className
  } = t0;
  const position = t1 === void 0 ? "sticky" : t1;
  const translucent = t2 === void 0 ? true : t2;
  const t3 = translucent ? "backdrop-blur-sm" : "";
  let t4;
  if ($[0] !== className || $[1] !== position || $[2] !== t3) {
    t4 = cls(defaultBorderMixin, "py-3 px-4 border-t flex flex-row items-center justify-end bottom-0 right-0 left-0 text-right z-2 gap-2", position, "bg-white bg-opacity-60 dark:bg-surface-900 dark:bg-opacity-60", t3, className);
    $[0] = className;
    $[1] = position;
    $[2] = t3;
    $[3] = t4;
  } else {
    t4 = $[3];
  }
  let t5;
  if ($[4] !== children || $[5] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t4, children });
    $[4] = children;
    $[5] = t4;
    $[6] = t5;
  } else {
    t5 = $[6];
  }
  return t5;
}
function DialogContent(t0) {
  const $ = c_1(8);
  const {
    children,
    className,
    fullHeight,
    includeMargin: t1
  } = t0;
  const includeMargin = t1 === void 0 ? true : t1;
  if (fullHeight) {
    let t22;
    if ($[0] !== children) {
      t22 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow flex flex-col h-full relative", children });
      $[0] = children;
      $[1] = t22;
    } else {
      t22 = $[1];
    }
    return t22;
  }
  let t2;
  if ($[2] !== className || $[3] !== includeMargin) {
    t2 = cls("h-full flex-grow", {
      "my-6 mx-6": includeMargin
    }, className);
    $[2] = className;
    $[3] = includeMargin;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  let t3;
  if ($[5] !== children || $[6] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t2, children });
    $[5] = children;
    $[6] = t2;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  return t3;
}
function DialogTitle(t0) {
  const $ = c_1(19);
  let children;
  let className;
  let hidden;
  let props;
  let t1;
  let t2;
  let t3;
  if ($[0] !== t0) {
    ({
      children,
      hidden,
      className,
      variant: t1,
      gutterBottom: t2,
      includeMargin: t3,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = className;
    $[3] = hidden;
    $[4] = props;
    $[5] = t1;
    $[6] = t2;
    $[7] = t3;
  } else {
    children = $[1];
    className = $[2];
    hidden = $[3];
    props = $[4];
    t1 = $[5];
    t2 = $[6];
    t3 = $[7];
  }
  const variant = t1 === void 0 ? "subtitle2" : t1;
  const gutterBottom = t2 === void 0 ? true : t2;
  const includeMargin = t3 === void 0 ? true : t3;
  let t4;
  if ($[8] !== className || $[9] !== includeMargin) {
    t4 = cls({
      "mt-8 mx-6": includeMargin
    }, className);
    $[8] = className;
    $[9] = includeMargin;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  let t5;
  if ($[11] !== children || $[12] !== gutterBottom || $[13] !== props || $[14] !== t4 || $[15] !== variant) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Title, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant, className: t4, gutterBottom, ...props, children }) });
    $[11] = children;
    $[12] = gutterBottom;
    $[13] = props;
    $[14] = t4;
    $[15] = variant;
    $[16] = t5;
  } else {
    t5 = $[16];
  }
  const title = t5;
  if (hidden) {
    let t6;
    if ($[17] !== title) {
      t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(Root$5, { children: title });
      $[17] = title;
      $[18] = t6;
    } else {
      t6 = $[18];
    }
    return t6;
  }
  return title;
}
function ExpandablePanel(t0) {
  const $ = c_1(40);
  const {
    title,
    children,
    invisible: t1,
    expanded,
    onExpandedChange,
    initiallyExpanded: t2,
    titleClassName,
    asField,
    className,
    innerClassName
  } = t0;
  const invisible = t1 === void 0 ? false : t1;
  const initiallyExpanded = t2 === void 0 ? true : t2;
  useInjectStyles("ExpandablePanel", `
.CollapsibleContent {
  overflow: hidden;
}
.CollapsibleContent[data-state='open'] {
  animation: slideDown 220ms ease-out
}
.CollapsibleContent[data-state='closed'] {
  animation: slideUp 220ms ease-out;
}

@keyframes slideDown {
  from {
    height: 0;
  }
  to {
    height: var(--radix-collapsible-content-height);
  }
}

@keyframes slideUp {
  from {
    height: var(--radix-collapsible-content-height);
  }
  to {
    height: 0;
  }
}`);
  const [open, setOpen] = useState(expanded !== void 0 ? expanded : initiallyExpanded);
  const [allowOverflow, setAllowOverflow] = useState(open);
  let t3;
  let t4;
  if ($[0] !== open) {
    t3 = () => {
      if (open) {
        setTimeout(() => {
          setAllowOverflow(true);
        }, 220);
      } else {
        setAllowOverflow(false);
      }
    };
    t4 = [open];
    $[0] = open;
    $[1] = t3;
    $[2] = t4;
  } else {
    t3 = $[1];
    t4 = $[2];
  }
  useEffect(t3, t4);
  let t5;
  let t6;
  if ($[3] !== expanded) {
    t5 = () => {
      if (expanded !== void 0) {
        setOpen(expanded);
      }
    };
    t6 = [expanded];
    $[3] = expanded;
    $[4] = t5;
    $[5] = t6;
  } else {
    t5 = $[4];
    t6 = $[5];
  }
  useEffect(t5, t6);
  const t7 = !invisible && defaultBorderMixin + " border";
  let t8;
  if ($[6] !== className || $[7] !== t7) {
    t8 = cls(t7, "rounded-md", "w-full", className);
    $[6] = className;
    $[7] = t7;
    $[8] = t8;
  } else {
    t8 = $[8];
  }
  let t9;
  if ($[9] !== onExpandedChange) {
    t9 = (updatedOpen) => {
      onExpandedChange?.(updatedOpen);
      setOpen(updatedOpen);
    };
    $[9] = onExpandedChange;
    $[10] = t9;
  } else {
    t9 = $[10];
  }
  const t10 = invisible ? "border-b px-2" : "p-4";
  const t11 = open ? "py-6" : "py-4";
  const t12 = invisible && defaultBorderMixin;
  const t13 = asField && fieldBackgroundMixin;
  let t14;
  if ($[11] !== t10 || $[12] !== t11 || $[13] !== t12 || $[14] !== t13 || $[15] !== titleClassName) {
    t14 = cls("rounded-t flex items-center justify-between w-full min-h-[52px]", "hover:bg-surface-accent-200 hover:bg-opacity-20 dark:hover:bg-surface-800 dark:hover:bg-opacity-20", t10, t11, "transition-all duration-200", t12, t13, titleClassName);
    $[11] = t10;
    $[12] = t11;
    $[13] = t12;
    $[14] = t13;
    $[15] = titleClassName;
    $[16] = t14;
  } else {
    t14 = $[16];
  }
  const t15 = open ? "rotate-180" : "";
  let t16;
  if ($[17] !== t15) {
    t16 = cls("transition", t15);
    $[17] = t15;
    $[18] = t16;
  } else {
    t16 = $[18];
  }
  let t17;
  if ($[19] !== t16) {
    t17 = /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardArrowDownIcon, { className: t16 });
    $[19] = t16;
    $[20] = t17;
  } else {
    t17 = $[20];
  }
  let t18;
  if ($[21] !== t14 || $[22] !== t17 || $[23] !== title) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Trigger$6, { className: t14, children: [
      title,
      t17
    ] });
    $[21] = t14;
    $[22] = t17;
    $[23] = title;
    $[24] = t18;
  } else {
    t18 = $[24];
  }
  let t19;
  if ($[25] === Symbol.for("react.memo_cache_sentinel")) {
    t19 = cls("CollapsibleContent");
    $[25] = t19;
  } else {
    t19 = $[25];
  }
  const t20 = allowOverflow ? "visible" : "hidden";
  let t21;
  if ($[26] !== t20) {
    t21 = {
      overflow: t20
    };
    $[26] = t20;
    $[27] = t21;
  } else {
    t21 = $[27];
  }
  let t22;
  if ($[28] !== children || $[29] !== innerClassName) {
    t22 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: innerClassName, children });
    $[28] = children;
    $[29] = innerClassName;
    $[30] = t22;
  } else {
    t22 = $[30];
  }
  let t23;
  if ($[31] !== t21 || $[32] !== t22) {
    t23 = /* @__PURE__ */ jsxRuntimeExports.jsx(Content$2, { className: t19, style: t21, children: t22 });
    $[31] = t21;
    $[32] = t22;
    $[33] = t23;
  } else {
    t23 = $[33];
  }
  let t24;
  if ($[34] !== open || $[35] !== t18 || $[36] !== t23 || $[37] !== t8 || $[38] !== t9) {
    t24 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Root$8, { className: t8, open, onOpenChange: t9, children: [
      t18,
      t23
    ] }) });
    $[34] = open;
    $[35] = t18;
    $[36] = t23;
    $[37] = t8;
    $[38] = t9;
    $[39] = t24;
  } else {
    t24 = $[39];
  }
  return t24;
}
function FileUpload(t0) {
  const $ = c_1(32);
  const {
    accept,
    onFilesAdded,
    onFilesRejected,
    maxSize,
    disabled,
    maxFiles,
    title,
    uploadDescription,
    children,
    preventDropOnDocument: t1,
    size: size2
  } = t0;
  const preventDropOnDocument = t1 === void 0 ? true : t1;
  let t2;
  if ($[0] !== accept || $[1] !== disabled || $[2] !== maxFiles || $[3] !== maxSize || $[4] !== onFilesAdded || $[5] !== onFilesRejected || $[6] !== preventDropOnDocument) {
    t2 = {
      accept,
      noDragEventsBubbling: true,
      maxSize,
      onDrop: onFilesAdded,
      onDropRejected: onFilesRejected,
      disabled,
      maxFiles,
      preventDropOnDocument
    };
    $[0] = accept;
    $[1] = disabled;
    $[2] = maxFiles;
    $[3] = maxSize;
    $[4] = onFilesAdded;
    $[5] = onFilesRejected;
    $[6] = preventDropOnDocument;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  const {
    getRootProps,
    getInputProps,
    isDragActive,
    isDragAccept,
    isDragReject
  } = useDropzone(t2);
  let t3;
  if ($[8] !== getRootProps) {
    t3 = getRootProps();
    $[8] = getRootProps;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  const t4 = size2 === "large";
  const t5 = size2 === "medium";
  const t6 = !disabled;
  const t7 = !isDragActive;
  let t8;
  if ($[10] !== isDragAccept || $[11] !== isDragReject || $[12] !== t4 || $[13] !== t5 || $[14] !== t6 || $[15] !== t7) {
    t8 = cls(fieldBackgroundMixin, "flex gap-2", "p-4 box-border relative items-center border-2 border-solid border-transparent outline-none rounded-md duration-200 ease-[cubic-bezier(0.4,0,0.2,1)] focus:border-primary-solid", {
      "h-44": t4,
      "h-28": t5,
      "cursor-pointer": t6,
      [fieldBackgroundHoverMixin]: t7,
      "transition-colors duration-200 ease-[cubic-bezier(0,0,0.2,1)] border-red-500": isDragReject,
      "transition-colors duration-200 ease-[cubic-bezier(0,0,0.2,1)] border-green-500": isDragAccept
    });
    $[10] = isDragAccept;
    $[11] = isDragReject;
    $[12] = t4;
    $[13] = t5;
    $[14] = t6;
    $[15] = t7;
    $[16] = t8;
  } else {
    t8 = $[16];
  }
  let t9;
  if ($[17] !== title) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "secondary", className: "absolute top-2 left-3.5 cursor-inherit", children: title });
    $[17] = title;
    $[18] = t9;
  } else {
    t9 = $[18];
  }
  let t10;
  if ($[19] !== getInputProps) {
    t10 = getInputProps();
    $[19] = getInputProps;
    $[20] = t10;
  } else {
    t10 = $[20];
  }
  let t11;
  if ($[21] !== t10) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx("input", { ...t10 });
    $[21] = t10;
    $[22] = t11;
  } else {
    t11 = $[22];
  }
  let t12;
  if ($[23] !== uploadDescription) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow h-28 box-border flex flex-col items-center justify-center text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { align: "center", variant: "label", children: uploadDescription }) });
    $[23] = uploadDescription;
    $[24] = t12;
  } else {
    t12 = $[24];
  }
  let t13;
  if ($[25] !== children || $[26] !== t11 || $[27] !== t12 || $[28] !== t3 || $[29] !== t8 || $[30] !== t9) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ...t3, className: t8, children: [
      t9,
      t11,
      children,
      t12
    ] });
    $[25] = children;
    $[26] = t11;
    $[27] = t12;
    $[28] = t3;
    $[29] = t8;
    $[30] = t9;
    $[31] = t13;
  } else {
    t13 = $[31];
  }
  return t13;
}
const colorClasses = {
  info: "bg-sky-200 dark:bg-teal-900",
  warn: "bg-orange-200 dark:bg-yellow-950"
};
function InfoLabel(t0) {
  const $ = c_1(5);
  const {
    children,
    mode: t1
  } = t0;
  const mode = t1 === void 0 ? "info" : t1;
  const t2 = colorClasses[mode];
  let t3;
  if ($[0] !== t2) {
    t3 = cls("my-3 py-2 px-4 rounded", t2);
    $[0] = t2;
    $[1] = t3;
  } else {
    t3 = $[1];
  }
  let t4;
  if ($[2] !== children || $[3] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t3, children });
    $[2] = children;
    $[3] = t3;
    $[4] = t4;
  } else {
    t4 = $[4];
  }
  return t4;
}
const Label = React.forwardRef((t0, ref) => {
  const $ = c_1(14);
  let border;
  let className;
  let onClick;
  let props;
  if ($[0] !== t0) {
    ({
      className,
      border,
      onClick,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = border;
    $[2] = className;
    $[3] = onClick;
    $[4] = props;
  } else {
    border = $[1];
    className = $[2];
    onClick = $[3];
    props = $[4];
  }
  const t1 = border && "border border-surface-300 dark:border-surface-700 rounded-md px-3 py-1.5";
  const t2 = onClick && "hover:cursor-pointer hover:bg-surface-200 dark:hover:bg-surface-800";
  let t3;
  if ($[5] !== className || $[6] !== t1 || $[7] !== t2) {
    t3 = cls("text-sm font-medium peer-disabled:cursor-not-allowed peer-disabled:opacity-70", t1, t2, defaultBorderMixin, className);
    $[5] = className;
    $[6] = t1;
    $[7] = t2;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  let t4;
  if ($[9] !== onClick || $[10] !== props || $[11] !== ref || $[12] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(Root$4, { ref, onClick, className: t3, ...props });
    $[9] = onClick;
    $[10] = props;
    $[11] = ref;
    $[12] = t3;
    $[13] = t4;
  } else {
    t4 = $[13];
  }
  return t4;
});
Label.displayName = Root$4.displayName;
function LoadingButton(t0) {
  const $ = c_1(17);
  let children;
  let disabled;
  let loading;
  let onClick;
  let props;
  let startIcon;
  if ($[0] !== t0) {
    ({
      children,
      loading,
      disabled,
      onClick,
      startIcon,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = disabled;
    $[3] = loading;
    $[4] = onClick;
    $[5] = props;
    $[6] = startIcon;
  } else {
    children = $[1];
    disabled = $[2];
    loading = $[3];
    onClick = $[4];
    props = $[5];
    startIcon = $[6];
  }
  const t1 = loading || disabled;
  const t2 = props.component;
  let t3;
  if ($[7] !== loading) {
    t3 = loading && /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: "small" });
    $[7] = loading;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  const t4 = !loading && startIcon;
  let t5;
  if ($[9] !== children || $[10] !== onClick || $[11] !== props || $[12] !== t1 || $[13] !== t2 || $[14] !== t3 || $[15] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { disabled: t1, onClick, component: t2, ...props, children: [
      t3,
      t4,
      children
    ] });
    $[9] = children;
    $[10] = onClick;
    $[11] = props;
    $[12] = t1;
    $[13] = t2;
    $[14] = t3;
    $[15] = t4;
    $[16] = t5;
  } else {
    t5 = $[16];
  }
  return t5;
}
const proseClasses = {
  small: "prose-sm typography-body2",
  medium: "prose typography-body1",
  large: "prose-lg",
  xl: "prose-xl",
  "2xl": "prose-2xl"
};
const md = new MarkdownIt({
  html: true
});
const Markdown = React__default.memo(function Markdown2(t0) {
  const $ = c_1(10);
  const {
    source,
    className,
    size: t1
  } = t0;
  const size2 = t1 === void 0 ? "medium" : t1;
  let t2;
  let t3;
  if ($[0] !== source) {
    t3 = md.render(typeof source === "string" ? source : "");
    $[0] = source;
    $[1] = t3;
  } else {
    t3 = $[1];
  }
  t2 = t3;
  const html = t2;
  const t4 = proseClasses[size2];
  let t5;
  if ($[2] !== className || $[3] !== t4) {
    t5 = cls(t4, "dark:prose-invert prose-headings:font-title", className);
    $[2] = className;
    $[3] = t4;
    $[4] = t5;
  } else {
    t5 = $[4];
  }
  let t6;
  if ($[5] !== html) {
    t6 = {
      __html: html
    };
    $[5] = html;
    $[6] = t6;
  } else {
    t6 = $[6];
  }
  let t7;
  if ($[7] !== t5 || $[8] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t5, dangerouslySetInnerHTML: t6 });
    $[7] = t5;
    $[8] = t6;
    $[9] = t7;
  } else {
    t7 = $[9];
  }
  return t7;
}, equal);
const Menu = React__default.forwardRef((t0, ref) => {
  const $ = c_1(17);
  const {
    children,
    trigger,
    open,
    defaultOpen,
    side,
    align,
    onOpenChange,
    portalContainer
  } = t0;
  let t1;
  if ($[0] !== ref || $[1] !== trigger) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger$5, { ref, asChild: true, children: trigger });
    $[0] = ref;
    $[1] = trigger;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = cls(paperMixin, focusedDisabled, "shadow py-2 z-30");
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== align || $[5] !== children || $[6] !== side) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(Content2$4, { side, align, className: t2, children });
    $[4] = align;
    $[5] = children;
    $[6] = side;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  let t4;
  if ($[8] !== portalContainer || $[9] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(Portal2$1, { container: portalContainer, children: t3 });
    $[8] = portalContainer;
    $[9] = t3;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  let t5;
  if ($[11] !== defaultOpen || $[12] !== onOpenChange || $[13] !== open || $[14] !== t1 || $[15] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2$4, { open, defaultOpen, onOpenChange, children: [
      t1,
      t4
    ] });
    $[11] = defaultOpen;
    $[12] = onOpenChange;
    $[13] = open;
    $[14] = t1;
    $[15] = t4;
    $[16] = t5;
  } else {
    t5 = $[16];
  }
  return t5;
});
Menu.displayName = "Menu";
function MenuItem(t0) {
  const $ = c_1(7);
  const {
    children,
    dense: t1,
    onClick
  } = t0;
  const dense = t1 === void 0 ? false : t1;
  const t2 = onClick && "cursor-pointer";
  const t3 = dense ? "px-3 py-1.5" : "px-4 py-2";
  let t4;
  if ($[0] !== t2 || $[1] !== t3) {
    t4 = cls(t2, "rounded-md text-sm font-medium text-surface-accent-700 dark:text-surface-accent-300 hover:bg-surface-accent-100 dark:hover:bg-surface-accent-900 flex items-center gap-4", t3);
    $[0] = t2;
    $[1] = t3;
    $[2] = t4;
  } else {
    t4 = $[2];
  }
  const classNames = t4;
  let t5;
  if ($[3] !== children || $[4] !== classNames || $[5] !== onClick) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Item2$1, { className: classNames, onClick, children });
    $[3] = children;
    $[4] = classNames;
    $[5] = onClick;
    $[6] = t5;
  } else {
    t5 = $[6];
  }
  return t5;
}
function Menubar(t0) {
  const $ = c_1(6);
  const {
    children,
    onSelect,
    className
  } = t0;
  let t1;
  if ($[0] !== className) {
    t1 = cls("z-10 flex bg-white dark:bg-surface-950 p-[3px] rounded-sm shadow-sm", className);
    $[0] = className;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== children || $[3] !== onSelect || $[4] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Root3$1, { onSelect, className: t1, children });
    $[2] = children;
    $[3] = onSelect;
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}
function MenubarMenu(t0) {
  const $ = c_1(2);
  const {
    children
  } = t0;
  let t1;
  if ($[0] !== children) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(Menu$1, { children });
    $[0] = children;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}
function MenubarTrigger(t0) {
  const $ = c_1(6);
  const {
    children,
    onSelect,
    className
  } = t0;
  let t1;
  if ($[0] !== className) {
    t1 = cls("py-2 px-3 outline-none select-none font-medium leading-none rounded text-text-primary dark:text-text-primary-dark text-[13px] flex items-center justify-between gap-[2px] data-[highlighted]:bg-surface-accent-100 data-[highlighted]:dark:bg-surface-800 data-[state=open]:bg-surface-accent-100 data-[state=open]:dark:bg-surface-800 hover:bg-surface-accent-200 hover:bg-opacity-75 dark:hover:bg-surface-700 dark:hover:bg-opacity-50", className);
    $[0] = className;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== children || $[3] !== onSelect || $[4] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger$4, { onSelect, className: t1, children });
    $[2] = children;
    $[3] = onSelect;
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}
function MenubarPortal(t0) {
  const $ = c_1(2);
  const {
    children
  } = t0;
  let t1;
  if ($[0] !== children) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(Portal2, { children });
    $[0] = children;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}
function MenubarContent(t0) {
  const $ = c_1(18);
  let align;
  let alignOffset;
  let children;
  let className;
  let onSelect;
  let rest;
  let sideOffset;
  if ($[0] !== t0) {
    ({
      children,
      className,
      align,
      sideOffset,
      alignOffset,
      onSelect,
      ...rest
    } = t0);
    $[0] = t0;
    $[1] = align;
    $[2] = alignOffset;
    $[3] = children;
    $[4] = className;
    $[5] = onSelect;
    $[6] = rest;
    $[7] = sideOffset;
  } else {
    align = $[1];
    alignOffset = $[2];
    children = $[3];
    className = $[4];
    onSelect = $[5];
    rest = $[6];
    sideOffset = $[7];
  }
  let t1;
  if ($[8] !== className) {
    t1 = cls("min-w-[220px] bg-white dark:bg-surface-950 rounded-md p-[6px] shadow-[0px_10px_38px_-10px_rgba(22,_23,_24,_0.35),_0px_10px_20px_-15px_rgba(22,_23,_24,_0.2)] [animation-duration:_400ms] [animation-timing-function:_cubic-bezier(0.16,_1,_0.3,_1)] will-change-[transform,opacity]", className);
    $[8] = className;
    $[9] = t1;
  } else {
    t1 = $[9];
  }
  const t2 = align ?? "start";
  const t3 = sideOffset ?? 5;
  const t4 = alignOffset ?? -3;
  let t5;
  if ($[10] !== children || $[11] !== onSelect || $[12] !== rest || $[13] !== t1 || $[14] !== t2 || $[15] !== t3 || $[16] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Content2$3, { onSelect, className: t1, align: t2, sideOffset: t3, alignOffset: t4, ...rest, children });
    $[10] = children;
    $[11] = onSelect;
    $[12] = rest;
    $[13] = t1;
    $[14] = t2;
    $[15] = t3;
    $[16] = t4;
    $[17] = t5;
  } else {
    t5 = $[17];
  }
  return t5;
}
function MenubarItem(t0) {
  const $ = c_1(17);
  let children;
  let className;
  let disabled;
  let leftPadding;
  let onSelect;
  let rest;
  if ($[0] !== t0) {
    ({
      children,
      leftPadding,
      className,
      disabled,
      onSelect,
      ...rest
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = className;
    $[3] = disabled;
    $[4] = leftPadding;
    $[5] = onSelect;
    $[6] = rest;
  } else {
    children = $[1];
    className = $[2];
    disabled = $[3];
    leftPadding = $[4];
    onSelect = $[5];
    rest = $[6];
  }
  const t1 = leftPadding ? "pl-5" : "";
  const t2 = disabled ? "pointer-events-none text-text-secondary dark:text-text-secondary-dark" : "text-text-primary dark:text-text-primary-dark";
  let t3;
  if ($[7] !== className || $[8] !== t1 || $[9] !== t2) {
    t3 = cls("group text-[13px] leading-none rounded flex items-center h-[32px] px-[10px] py-[2px] relative select-none outline-none data-[state=open]:bg-surface-accent-100 data-[state=open]:dark:bg-surface-800 data-[state=open]:text-text-primary data-[state=open]:dark:text-text-primary-dark data-[highlighted]:bg-surface-accent-100 data-[highlighted]:dark:bg-surface-800  data-[disabled]:text-text-disabled data-[disabled]:dark:text-text-disabled-dark data-[disabled]:pointer-events-none", t1, t2, className);
    $[7] = className;
    $[8] = t1;
    $[9] = t2;
    $[10] = t3;
  } else {
    t3 = $[10];
  }
  let t4;
  if ($[11] !== children || $[12] !== disabled || $[13] !== onSelect || $[14] !== rest || $[15] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(Item3, { onSelect, className: t3, disabled, ...rest, children });
    $[11] = children;
    $[12] = disabled;
    $[13] = onSelect;
    $[14] = rest;
    $[15] = t3;
    $[16] = t4;
  } else {
    t4 = $[16];
  }
  return t4;
}
function MenubarSeparator(t0) {
  const $ = c_1(10);
  let children;
  let className;
  let rest;
  if ($[0] !== t0) {
    ({
      children,
      className,
      ...rest
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = className;
    $[3] = rest;
  } else {
    children = $[1];
    className = $[2];
    rest = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cls("h-[1px] bg-surface-accent-100 dark:bg-surface-800 m-[5px]", className);
    $[4] = className;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  let t2;
  if ($[6] !== children || $[7] !== rest || $[8] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Separator2, { className: t1, ...rest, children });
    $[6] = children;
    $[7] = rest;
    $[8] = t1;
    $[9] = t2;
  } else {
    t2 = $[9];
  }
  return t2;
}
function MenubarSub(t0) {
  const $ = c_1(6);
  let children;
  let rest;
  if ($[0] !== t0) {
    ({
      children,
      ...rest
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = rest;
  } else {
    children = $[1];
    rest = $[2];
  }
  let t1;
  if ($[3] !== children || $[4] !== rest) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(Sub2, { ...rest, children });
    $[3] = children;
    $[4] = rest;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  return t1;
}
function MenubarSubTrigger(t0) {
  const $ = c_1(12);
  let children;
  let className;
  let onSelect;
  let rest;
  if ($[0] !== t0) {
    ({
      children,
      className,
      onSelect,
      ...rest
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = className;
    $[3] = onSelect;
    $[4] = rest;
  } else {
    children = $[1];
    className = $[2];
    onSelect = $[3];
    rest = $[4];
  }
  let t1;
  if ($[5] !== className) {
    t1 = cls("group text-[13px] leading-none text-text-primary dark:text-text-primary-dark rounded flex items-center h-[32px] px-[10px] py-[2px] relative select-none outline-none data-[state=open]:bg-surface-accent-100 data-[state=open]:dark:bg-surface-800 data-[state=open]:text-text-primary data-[state=open]:dark:text-text-primary-dark data-[highlighted]:bg-surface-accent-100 data-[highlighted]:dark:bg-surface-800  data-[disabled]:text-text-disabled data-[disabled]:dark:text-text-disabled-dark data-[disabled]:pointer-events-none", className);
    $[5] = className;
    $[6] = t1;
  } else {
    t1 = $[6];
  }
  let t2;
  if ($[7] !== children || $[8] !== onSelect || $[9] !== rest || $[10] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(SubTrigger2, { onSelect, className: t1, ...rest, children });
    $[7] = children;
    $[8] = onSelect;
    $[9] = rest;
    $[10] = t1;
    $[11] = t2;
  } else {
    t2 = $[11];
  }
  return t2;
}
function MenubarSubContent(t0) {
  const $ = c_1(14);
  let alignOffset;
  let children;
  let className;
  let onSelect;
  let rest;
  if ($[0] !== t0) {
    ({
      children,
      alignOffset,
      className,
      onSelect,
      ...rest
    } = t0);
    $[0] = t0;
    $[1] = alignOffset;
    $[2] = children;
    $[3] = className;
    $[4] = onSelect;
    $[5] = rest;
  } else {
    alignOffset = $[1];
    children = $[2];
    className = $[3];
    onSelect = $[4];
    rest = $[5];
  }
  const t1 = alignOffset ?? -5;
  let t2;
  if ($[6] !== className) {
    t2 = cls("min-w-[220px] bg-white dark:bg-surface-950 rounded-md p-[6px] shadow-[0px_10px_38px_-10px_rgba(22,_23,_24,_0.35),_0px_10px_20px_-15px_rgba(22,_23,_24,_0.2)] [animation-duration:_400ms] [animation-timing-function:_cubic-bezier(0.16,_1,_0.3,_1)] will-change-[transform,opacity]", className);
    $[6] = className;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  let t3;
  if ($[8] !== children || $[9] !== onSelect || $[10] !== rest || $[11] !== t1 || $[12] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(SubContent2, { onSelect, alignOffset: t1, className: t2, ...rest, children });
    $[8] = children;
    $[9] = onSelect;
    $[10] = rest;
    $[11] = t1;
    $[12] = t2;
    $[13] = t3;
  } else {
    t3 = $[13];
  }
  return t3;
}
function MenubarCheckboxItem(t0) {
  const $ = c_1(16);
  let checked;
  let children;
  let className;
  let onCheckedChange;
  let onSelect;
  let rest;
  if ($[0] !== t0) {
    ({
      children,
      checked,
      onCheckedChange,
      className,
      onSelect,
      ...rest
    } = t0);
    $[0] = t0;
    $[1] = checked;
    $[2] = children;
    $[3] = className;
    $[4] = onCheckedChange;
    $[5] = onSelect;
    $[6] = rest;
  } else {
    checked = $[1];
    children = $[2];
    className = $[3];
    onCheckedChange = $[4];
    onSelect = $[5];
    rest = $[6];
  }
  let t1;
  if ($[7] !== className) {
    t1 = cls("text-[13px] leading-none text-text-primary dark:text-text-primary-dark rounded flex items-center h-[32px] px-[10px] py-[2px] relative select-none pl-5 outline-none data-[highlighted]:bg-surface-accent-100 data-[highlighted]:dark:bg-surface-800 data-[disabled]:text-text-disabled data-[disabled]:dark:text-text-disabled-dark data-[disabled]:pointer-events-none", className);
    $[7] = className;
    $[8] = t1;
  } else {
    t1 = $[8];
  }
  let t2;
  if ($[9] !== checked || $[10] !== children || $[11] !== onCheckedChange || $[12] !== onSelect || $[13] !== rest || $[14] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxItem2, { onSelect, className: t1, checked, onCheckedChange, ...rest, children });
    $[9] = checked;
    $[10] = children;
    $[11] = onCheckedChange;
    $[12] = onSelect;
    $[13] = rest;
    $[14] = t1;
    $[15] = t2;
  } else {
    t2 = $[15];
  }
  return t2;
}
function MenubarItemIndicator(t0) {
  const $ = c_1(12);
  let children;
  let className;
  let rest;
  if ($[0] !== t0) {
    ({
      children,
      className,
      ...rest
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = className;
    $[3] = rest;
  } else {
    children = $[1];
    className = $[2];
    rest = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cls("absolute left-0 w-4 inline-flex items-center justify-center", className);
    $[4] = className;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  let t2;
  if ($[6] !== children) {
    t2 = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon, { size: "smallest" });
    $[6] = children;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  let t3;
  if ($[8] !== rest || $[9] !== t1 || $[10] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator2, { className: t1, ...rest, children: t2 });
    $[8] = rest;
    $[9] = t1;
    $[10] = t2;
    $[11] = t3;
  } else {
    t3 = $[11];
  }
  return t3;
}
function MenubarRadioGroup(t0) {
  const $ = c_1(18);
  let children;
  let className;
  let onSelect;
  let onValueChange;
  let rest;
  let value;
  if ($[0] !== t0) {
    ({
      children,
      className,
      value,
      onValueChange,
      onSelect,
      ...rest
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = className;
    $[3] = onSelect;
    $[4] = onValueChange;
    $[5] = rest;
    $[6] = value;
  } else {
    children = $[1];
    className = $[2];
    onSelect = $[3];
    onValueChange = $[4];
    rest = $[5];
    value = $[6];
  }
  let t1;
  if ($[7] !== className) {
    t1 = cls(className);
    $[7] = className;
    $[8] = t1;
  } else {
    t1 = $[8];
  }
  let t2;
  if ($[9] !== children) {
    t2 = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon, { size: "small" });
    $[9] = children;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  let t3;
  if ($[11] !== onSelect || $[12] !== onValueChange || $[13] !== rest || $[14] !== t1 || $[15] !== t2 || $[16] !== value) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroup2, { className: t1, value, onValueChange, onSelect, ...rest, children: t2 });
    $[11] = onSelect;
    $[12] = onValueChange;
    $[13] = rest;
    $[14] = t1;
    $[15] = t2;
    $[16] = value;
    $[17] = t3;
  } else {
    t3 = $[17];
  }
  return t3;
}
function MenubarRadioItem(t0) {
  const $ = c_1(16);
  let children;
  let className;
  let onSelect;
  let rest;
  let value;
  if ($[0] !== t0) {
    ({
      children,
      className,
      value,
      onSelect,
      ...rest
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = className;
    $[3] = onSelect;
    $[4] = rest;
    $[5] = value;
  } else {
    children = $[1];
    className = $[2];
    onSelect = $[3];
    rest = $[4];
    value = $[5];
  }
  let t1;
  if ($[6] !== className) {
    t1 = cls("text-[13px] leading-none text-text-primary dark:text-text-primary-dark rounded flex items-center h-[32px] px-[10px] py-[2px] relative select-none pl-5 outline-none data-[highlighted]:bg-surface-accent-100 data-[highlighted]:dark:bg-surface-800 data-[disabled]:text-text-disabled data-[disabled]:dark:text-text-disabled-dark data-[disabled]:pointer-events-none", className);
    $[6] = className;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  let t2;
  if ($[8] !== children) {
    t2 = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon, { size: "small" });
    $[8] = children;
    $[9] = t2;
  } else {
    t2 = $[9];
  }
  let t3;
  if ($[10] !== onSelect || $[11] !== rest || $[12] !== t1 || $[13] !== t2 || $[14] !== value) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(RadioItem2, { onSelect, className: t1, value, ...rest, children: t2 });
    $[10] = onSelect;
    $[11] = rest;
    $[12] = t1;
    $[13] = t2;
    $[14] = value;
    $[15] = t3;
  } else {
    t3 = $[15];
  }
  return t3;
}
function MenubarShortcut(t0) {
  const $ = c_1(10);
  let children;
  let className;
  let rest;
  if ($[0] !== t0) {
    ({
      children,
      className,
      ...rest
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = className;
    $[3] = rest;
  } else {
    children = $[1];
    className = $[2];
    rest = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cls("ml-auto pl-5 group-data-[disabled]:text-text-disabled data-[disabled]:dark:text-text-disabled-dark", className);
    $[4] = className;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  let t2;
  if ($[6] !== children || $[7] !== rest || $[8] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t1, ...rest, children });
    $[6] = children;
    $[7] = rest;
    $[8] = t1;
    $[9] = t2;
  } else {
    t2 = $[9];
  }
  return t2;
}
function MenubarSubTriggerIndicator() {
  const $ = c_1(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-auto pl-5 ", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightIcon, { size: "small" }) });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
function Separator(t0) {
  const $ = c_1(10);
  const {
    orientation,
    decorative,
    className
  } = t0;
  if (orientation === "horizontal") {
    let t1;
    if ($[0] !== className) {
      t1 = cls("dark:bg-opacity-80 dark:bg-surface-800 bg-surface-100 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px my-4", className);
      $[0] = className;
      $[1] = t1;
    } else {
      t1 = $[1];
    }
    let t2;
    if ($[2] !== decorative || $[3] !== t1) {
      t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Root$1, { decorative, orientation: "horizontal", className: t1 });
      $[2] = decorative;
      $[3] = t1;
      $[4] = t2;
    } else {
      t2 = $[4];
    }
    return t2;
  } else {
    let t1;
    if ($[5] !== className) {
      t1 = cls("dark:bg-opacity-80 dark:bg-surface-800 bg-surface-100 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px mx-4", className);
      $[5] = className;
      $[6] = t1;
    } else {
      t1 = $[6];
    }
    let t2;
    if ($[7] !== decorative || $[8] !== t1) {
      t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Root$1, { className: t1, decorative, orientation: "vertical" });
      $[7] = decorative;
      $[8] = t1;
      $[9] = t2;
    } else {
      t2 = $[9];
    }
    return t2;
  }
}
function SelectInputLabel(t0) {
  const $ = c_1(5);
  const {
    children,
    error
  } = t0;
  const t1 = error ? "text-red-500 dark:text-red-600" : "text-surface-accent-500 dark:text-surface-accent-300";
  let t2;
  if ($[0] !== t1) {
    t2 = cls("text-sm  font-medium ml-3.5 mb-1", t1);
    $[0] = t1;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  let t3;
  if ($[2] !== children || $[3] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t2, children });
    $[2] = children;
    $[3] = t2;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  return t3;
}
const MultiSelectContext = React.createContext({});
const MultiSelect = React.forwardRef((t0, ref) => {
  const $ = c_1(98);
  const {
    value,
    size: size2,
    label,
    error,
    onValueChange,
    invisible,
    disabled,
    placeholder,
    modalPopover: t1,
    includeClear: t2,
    includeSelectAll: t3,
    useChips: t4,
    className,
    children,
    renderValues,
    open,
    onOpenChange
  } = t0;
  const modalPopover = t1 === void 0 ? true : t1;
  const includeClear = t2 === void 0 ? true : t2;
  const includeSelectAll = t3 === void 0 ? true : t3;
  const useChips = t4 === void 0 ? true : t4;
  const [isPopoverOpen, setIsPopoverOpen] = React.useState(open ?? false);
  let t5;
  if ($[0] !== value) {
    t5 = value ?? [];
    $[0] = value;
    $[1] = t5;
  } else {
    t5 = $[1];
  }
  const [selectedValues, setSelectedValues] = React.useState(t5);
  let t6;
  if ($[2] !== onOpenChange) {
    t6 = (open_0) => {
      setIsPopoverOpen(open_0);
      onOpenChange?.(open_0);
    };
    $[2] = onOpenChange;
    $[3] = t6;
  } else {
    t6 = $[3];
  }
  const onPopoverOpenChange = t6;
  let t7;
  let t8;
  if ($[4] !== open) {
    t7 = () => {
      setIsPopoverOpen(open ?? false);
    };
    t8 = [open];
    $[4] = open;
    $[5] = t7;
    $[6] = t8;
  } else {
    t7 = $[5];
    t8 = $[6];
  }
  useEffect(t7, t8);
  let t9;
  if ($[7] !== children) {
    t9 = children ? Children.map(children, _temp$1).filter(Boolean) : [];
    $[7] = children;
    $[8] = t9;
  } else {
    t9 = $[8];
  }
  const allValues = t9;
  let t10;
  let t11;
  if ($[9] !== value) {
    t10 = () => {
      setSelectedValues(value ?? []);
    };
    t11 = [value];
    $[9] = value;
    $[10] = t10;
    $[11] = t11;
  } else {
    t10 = $[10];
    t11 = $[11];
  }
  React.useEffect(t10, t11);
  let onItemClick;
  let updateValues;
  if ($[12] !== onValueChange || $[13] !== selectedValues) {
    onItemClick = function onItemClick2(newValue) {
      let newSelectedValues;
      if (selectedValues.includes(newValue)) {
        newSelectedValues = selectedValues.filter((v) => v !== newValue);
      } else {
        newSelectedValues = [...selectedValues, newValue];
      }
      updateValues(newSelectedValues);
    };
    updateValues = function updateValues2(values) {
      setSelectedValues(values);
      onValueChange?.(values);
    };
    $[12] = onValueChange;
    $[13] = selectedValues;
    $[14] = onItemClick;
    $[15] = updateValues;
  } else {
    onItemClick = $[14];
    updateValues = $[15];
  }
  let t12;
  if ($[16] !== onPopoverOpenChange || $[17] !== selectedValues || $[18] !== updateValues) {
    t12 = (event) => {
      if (event.key === "Enter") {
        onPopoverOpenChange(true);
      } else {
        if (event.key === "Backspace" && !event.currentTarget.value) {
          const newSelectedValues_0 = [...selectedValues];
          newSelectedValues_0.pop();
          updateValues(newSelectedValues_0);
        }
      }
    };
    $[16] = onPopoverOpenChange;
    $[17] = selectedValues;
    $[18] = updateValues;
    $[19] = t12;
  } else {
    t12 = $[19];
  }
  const handleInputKeyDown = t12;
  let t13;
  if ($[20] !== selectedValues || $[21] !== updateValues) {
    t13 = (value_0) => {
      const newSelectedValues_1 = selectedValues.includes(value_0) ? selectedValues.filter((v_0) => v_0 !== value_0) : [...selectedValues, value_0];
      updateValues(newSelectedValues_1);
    };
    $[20] = selectedValues;
    $[21] = updateValues;
    $[22] = t13;
  } else {
    t13 = $[22];
  }
  const toggleOption = t13;
  let t14;
  if ($[23] !== updateValues) {
    t14 = () => {
      updateValues([]);
    };
    $[23] = updateValues;
    $[24] = t14;
  } else {
    t14 = $[24];
  }
  const handleClear = t14;
  let t15;
  if ($[25] !== isPopoverOpen || $[26] !== onPopoverOpenChange) {
    t15 = () => {
      onPopoverOpenChange(!isPopoverOpen);
    };
    $[25] = isPopoverOpen;
    $[26] = onPopoverOpenChange;
    $[27] = t15;
  } else {
    t15 = $[27];
  }
  const handleTogglePopover = t15;
  let t16;
  if ($[28] !== allValues || $[29] !== handleClear || $[30] !== onPopoverOpenChange || $[31] !== selectedValues.length || $[32] !== updateValues) {
    t16 = () => {
      if (selectedValues.length === allValues.length) {
        handleClear();
      } else {
        updateValues(allValues);
      }
      onPopoverOpenChange(false);
    };
    $[28] = allValues;
    $[29] = handleClear;
    $[30] = onPopoverOpenChange;
    $[31] = selectedValues.length;
    $[32] = updateValues;
    $[33] = t16;
  } else {
    t16 = $[33];
  }
  const toggleAll = t16;
  useInjectStyles("MultiSelect", `
[cmdk-group] {
  max-height: 45vh;
  overflow-y: auto;
  // width: 400px;
} `);
  let t17;
  if ($[34] !== onItemClick || $[35] !== selectedValues) {
    t17 = {
      fieldValue: selectedValues,
      onItemClick
    };
    $[34] = onItemClick;
    $[35] = selectedValues;
    $[36] = t17;
  } else {
    t17 = $[36];
  }
  let t18;
  if ($[37] !== error || $[38] !== label) {
    t18 = typeof label === "string" ? /* @__PURE__ */ jsxRuntimeExports.jsx(SelectInputLabel, { error, children: label }) : label;
    $[37] = error;
    $[38] = label;
    $[39] = t18;
  } else {
    t18 = $[39];
  }
  const t19 = size2 === "small" ? "min-h-[42px]" : "min-h-[64px]";
  const t20 = invisible ? fieldBackgroundInvisibleMixin : fieldBackgroundMixin;
  const t21 = disabled ? fieldBackgroundDisabledMixin : fieldBackgroundHoverMixin;
  let t22;
  if ($[40] !== className || $[41] !== t19 || $[42] !== t20 || $[43] !== t21) {
    t22 = cls(t19, "py-2", "px-4", "select-none rounded-md text-sm", t20, t21, "relative flex items-center", className);
    $[40] = className;
    $[41] = t19;
    $[42] = t20;
    $[43] = t21;
    $[44] = t22;
  } else {
    t22 = $[44];
  }
  let t23;
  if ($[45] !== children || $[46] !== handleClear || $[47] !== includeClear || $[48] !== isPopoverOpen || $[49] !== placeholder || $[50] !== renderValues || $[51] !== selectedValues || $[52] !== toggleOption || $[53] !== useChips) {
    t23 = selectedValues.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center w-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap items-center gap-1.5 text-start", children: [
        renderValues && renderValues(selectedValues),
        !renderValues && selectedValues.map((value_1) => {
          const childrenProps = Children.map(children, _temp2).filter(Boolean);
          const option = childrenProps.find((o) => o.value === value_1);
          if (!useChips) {
            return option?.children;
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(Chip, { size: "medium", className: cls("flex flex-row items-center p-1"), children: [
            option?.children,
            /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, { size: "smallest", onClick: (event_0) => {
              event_0.stopPropagation();
              toggleOption(value_1);
            } })
          ] }, value_1);
        })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        includeClear && /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, { className: "ml-4", size: "small", onClick: (event_1) => {
          event_1.stopPropagation();
          handleClear();
        } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls("px-2 h-full flex items-center"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardArrowDownIcon, { size: "small", className: cls("transition", isPopoverOpen ? "rotate-180" : "") }) })
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between w-full mx-auto", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm", children: placeholder }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls("px-2 h-full flex items-center"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardArrowDownIcon, { size: "small", className: cls("transition", isPopoverOpen ? "rotate-180" : "") }) })
    ] });
    $[45] = children;
    $[46] = handleClear;
    $[47] = includeClear;
    $[48] = isPopoverOpen;
    $[49] = placeholder;
    $[50] = renderValues;
    $[51] = selectedValues;
    $[52] = toggleOption;
    $[53] = useChips;
    $[54] = t23;
  } else {
    t23 = $[54];
  }
  let t24;
  if ($[55] !== handleTogglePopover || $[56] !== ref || $[57] !== t22 || $[58] !== t23) {
    t24 = /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger$3, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { ref, onClick: handleTogglePopover, className: t22, children: t23 }) });
    $[55] = handleTogglePopover;
    $[56] = ref;
    $[57] = t22;
    $[58] = t23;
    $[59] = t24;
  } else {
    t24 = $[59];
  }
  let t25;
  if ($[60] === Symbol.for("react.memo_cache_sentinel")) {
    t25 = cls("z-50 relative overflow-hidden border bg-white dark:bg-surface-900 rounded-lg w-[400px]", defaultBorderMixin);
    $[60] = t25;
  } else {
    t25 = $[60];
  }
  let t26;
  if ($[61] !== onPopoverOpenChange) {
    t26 = () => onPopoverOpenChange(false);
    $[61] = onPopoverOpenChange;
    $[62] = t26;
  } else {
    t26 = $[62];
  }
  let t27;
  if ($[63] === Symbol.for("react.memo_cache_sentinel")) {
    t27 = cls(focusedDisabled, "bg-transparent outline-none flex-1 h-full w-full m-4 flex-grow ");
    $[63] = t27;
  } else {
    t27 = $[63];
  }
  let t28;
  if ($[64] !== handleInputKeyDown) {
    t28 = /* @__PURE__ */ jsxRuntimeExports.jsx(we.Input, { className: t27, placeholder: "Search...", onKeyDown: handleInputKeyDown });
    $[64] = handleInputKeyDown;
    $[65] = t28;
  } else {
    t28 = $[65];
  }
  let t29;
  if ($[66] !== handleClear || $[67] !== selectedValues.length) {
    t29 = selectedValues.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: handleClear, className: "text-sm justify-center cursor-pointer py-3 px-4 text-text-secondary dark:text-text-secondary-dark", children: "Clear" });
    $[66] = handleClear;
    $[67] = selectedValues.length;
    $[68] = t29;
  } else {
    t29 = $[68];
  }
  let t30;
  if ($[69] !== t28 || $[70] !== t29) {
    t30 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row items-center", children: [
      t28,
      t29
    ] });
    $[69] = t28;
    $[70] = t29;
    $[71] = t30;
  } else {
    t30 = $[71];
  }
  let t31;
  if ($[72] === Symbol.for("react.memo_cache_sentinel")) {
    t31 = /* @__PURE__ */ jsxRuntimeExports.jsx(Separator, { orientation: "horizontal", className: "my-0" });
    $[72] = t31;
  } else {
    t31 = $[72];
  }
  let t32;
  if ($[73] === Symbol.for("react.memo_cache_sentinel")) {
    t32 = /* @__PURE__ */ jsxRuntimeExports.jsx(we.Empty, { className: "px-4 py-2", children: "No results found." });
    $[73] = t32;
  } else {
    t32 = $[73];
  }
  let t33;
  if ($[74] !== allValues.length || $[75] !== includeSelectAll || $[76] !== selectedValues.length || $[77] !== toggleAll) {
    t33 = includeSelectAll && /* @__PURE__ */ jsxRuntimeExports.jsxs(we.Item, { onSelect: toggleAll, className: cls("flex flex-row items-center gap-1.5", "cursor-pointer", "m-1", "ring-offset-transparent", "p-1 rounded aria-[selected=true]:outline-none aria-[selected=true]:ring-2 aria-[selected=true]:ring-primary aria-[selected=true]:ring-opacity-75 aria-[selected=true]:ring-offset-2", "aria-[selected=true]:bg-surface-accent-100 aria-[selected=true]:dark:bg-surface-accent-900", "cursor-pointer p-2 rounded aria-[selected=true]:bg-surface-accent-100 aria-[selected=true]:dark:bg-surface-accent-900"), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(InnerCheckBox, { checked: selectedValues.length === allValues.length }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-text-secondary dark:text-text-secondary-dark", children: "(Select All)" })
    ] }, "all");
    $[74] = allValues.length;
    $[75] = includeSelectAll;
    $[76] = selectedValues.length;
    $[77] = toggleAll;
    $[78] = t33;
  } else {
    t33 = $[78];
  }
  let t34;
  if ($[79] !== children || $[80] !== t33) {
    t34 = /* @__PURE__ */ jsxRuntimeExports.jsxs(we.List, { children: [
      t32,
      /* @__PURE__ */ jsxRuntimeExports.jsxs(we.Group, { children: [
        t33,
        children
      ] })
    ] });
    $[79] = children;
    $[80] = t33;
    $[81] = t34;
  } else {
    t34 = $[81];
  }
  let t35;
  if ($[82] !== t30 || $[83] !== t34) {
    t35 = /* @__PURE__ */ jsxRuntimeExports.jsxs(we, { children: [
      t30,
      t31,
      t34
    ] });
    $[82] = t30;
    $[83] = t34;
    $[84] = t35;
  } else {
    t35 = $[84];
  }
  let t36;
  if ($[85] !== t26 || $[86] !== t35) {
    t36 = /* @__PURE__ */ jsxRuntimeExports.jsx(Content2$2, { className: t25, align: "start", sideOffset: 8, onEscapeKeyDown: t26, children: t35 });
    $[85] = t26;
    $[86] = t35;
    $[87] = t36;
  } else {
    t36 = $[87];
  }
  let t37;
  if ($[88] !== isPopoverOpen || $[89] !== modalPopover || $[90] !== onPopoverOpenChange || $[91] !== t24 || $[92] !== t36) {
    t37 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2$3, { open: isPopoverOpen, onOpenChange: onPopoverOpenChange, modal: modalPopover, children: [
      t24,
      t36
    ] });
    $[88] = isPopoverOpen;
    $[89] = modalPopover;
    $[90] = onPopoverOpenChange;
    $[91] = t24;
    $[92] = t36;
    $[93] = t37;
  } else {
    t37 = $[93];
  }
  let t38;
  if ($[94] !== t17 || $[95] !== t18 || $[96] !== t37) {
    t38 = /* @__PURE__ */ jsxRuntimeExports.jsxs(MultiSelectContext.Provider, { value: t17, children: [
      t18,
      t37
    ] });
    $[94] = t17;
    $[95] = t18;
    $[96] = t37;
    $[97] = t38;
  } else {
    t38 = $[97];
  }
  return t38;
});
MultiSelect.displayName = "MultiSelect";
function MultiSelectItem(t0) {
  const $ = c_1(18);
  const {
    children,
    value,
    className
  } = t0;
  const context = React.useContext(MultiSelectContext);
  if (!context) {
    throw new Error("MultiSelectItem must be used inside a MultiSelect");
  }
  const {
    fieldValue,
    onItemClick
  } = context;
  let t1;
  if ($[0] !== fieldValue) {
    t1 = fieldValue ?? [];
    $[0] = fieldValue;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== t1 || $[3] !== value) {
    t2 = t1.includes(value);
    $[2] = t1;
    $[3] = value;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  const isSelected = t2;
  let t3;
  if ($[5] !== onItemClick || $[6] !== value) {
    t3 = (_2) => {
      onItemClick(value);
    };
    $[5] = onItemClick;
    $[6] = value;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  const t4 = isSelected ? "bg-surface-accent-200 dark:bg-surface-accent-950" : "";
  let t5;
  if ($[8] !== className || $[9] !== t4) {
    t5 = cls("flex flex-row items-center gap-1.5", t4, "cursor-pointer", "m-1", "ring-offset-transparent", "p-1 rounded aria-[selected=true]:outline-none aria-[selected=true]:ring-2 aria-[selected=true]:ring-primary aria-[selected=true]:ring-opacity-75 aria-[selected=true]:ring-offset-2", "aria-[selected=true]:bg-surface-accent-100 aria-[selected=true]:dark:bg-surface-accent-900", "cursor-pointer p-2 rounded aria-[selected=true]:bg-surface-accent-100 aria-[selected=true]:dark:bg-surface-accent-900", className);
    $[8] = className;
    $[9] = t4;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  let t6;
  if ($[11] !== isSelected) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(InnerCheckBox, { checked: isSelected });
    $[11] = isSelected;
    $[12] = t6;
  } else {
    t6 = $[12];
  }
  let t7;
  if ($[13] !== children || $[14] !== t3 || $[15] !== t5 || $[16] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs(we.Item, { onMouseDown: _temp3, onSelect: t3, className: t5, children: [
      t6,
      children
    ] });
    $[13] = children;
    $[14] = t3;
    $[15] = t5;
    $[16] = t6;
    $[17] = t7;
  } else {
    t7 = $[17];
  }
  return t7;
}
function _temp3(e) {
  e.preventDefault();
  e.stopPropagation();
}
function InnerCheckBox(t0) {
  const $ = c_1(10);
  const {
    checked
  } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = cls("p-2", "w-8 h-8", "inline-flex items-center justify-center text-sm font-medium focus:outline-none transition-colors ease-in-out duration-150");
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  const t2 = checked ? "bg-primary" : "bg-white dark:bg-surface-accent-900";
  const t3 = checked ? "text-surface-accent-100 dark:text-surface-accent-900" : "";
  const t4 = checked ? "border-transparent" : "border-surface-accent-800 dark:border-surface-accent-200";
  let t5;
  if ($[1] !== t2 || $[2] !== t3 || $[3] !== t4) {
    t5 = cls("border-2 relative transition-colors ease-in-out duration-150", "w-4 h-4 rounded flex items-center justify-center", t2, t3, t4);
    $[1] = t2;
    $[2] = t3;
    $[3] = t4;
    $[4] = t5;
  } else {
    t5 = $[4];
  }
  let t6;
  if ($[5] !== checked) {
    t6 = checked && /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon, { size: 16, className: "absolute" });
    $[5] = checked;
    $[6] = t6;
  } else {
    t6 = $[6];
  }
  let t7;
  if ($[7] !== t5 || $[8] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t1, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t5, children: t6 }) });
    $[7] = t5;
    $[8] = t6;
    $[9] = t7;
  } else {
    t7 = $[9];
  }
  return t7;
}
function _temp$1(child) {
  if (React.isValidElement(child)) {
    return child.props.value;
  }
  return null;
}
function _temp2(child_0) {
  if (React.isValidElement(child_0)) {
    return child_0.props;
  }
}
function Paper(t0) {
  const $ = c_1(6);
  const {
    children,
    style,
    className
  } = t0;
  let t1;
  if ($[0] !== className) {
    t1 = cls(paperMixin, className);
    $[0] = className;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== children || $[3] !== style || $[4] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t1, style, children });
    $[2] = children;
    $[3] = style;
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}
const RadioGroup = React.forwardRef((t0, ref) => {
  const $ = c_1(9);
  let className;
  let props;
  if ($[0] !== t0) {
    ({
      className,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = className;
    $[2] = props;
  } else {
    className = $[1];
    props = $[2];
  }
  let t1;
  if ($[3] !== className) {
    t1 = cls("grid gap-2", className);
    $[3] = className;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  let t2;
  if ($[5] !== props || $[6] !== ref || $[7] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$2, { className: t1, ...props, ref });
    $[5] = props;
    $[6] = ref;
    $[7] = t1;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  return t2;
});
RadioGroup.displayName = Root2$2.displayName;
const RadioGroupItem = React.forwardRef((t0, ref) => {
  const $ = c_1(10);
  let className;
  let props;
  if ($[0] !== t0) {
    ({
      className,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = className;
    $[2] = props;
  } else {
    className = $[1];
    props = $[2];
  }
  let t1;
  if ($[3] !== className) {
    t1 = cls("aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", className);
    $[3] = className;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  let t2;
  if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Indicator, { className: "flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-2.5 w-2.5 fill-current text-current bg-primary rounded-lg" }) });
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  let t3;
  if ($[6] !== props || $[7] !== ref || $[8] !== t1) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(Item2, { ref, className: t1, ...props, children: t2 });
    $[6] = props;
    $[7] = ref;
    $[8] = t1;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  return t3;
});
RadioGroupItem.displayName = Item2.displayName;
function SearchBar(t0) {
  const $ = c_1(39);
  const {
    onClick,
    onTextSearch,
    placeholder: t1,
    expandable: t2,
    large: t3,
    innerClassName,
    className,
    autoFocus,
    disabled,
    loading,
    inputRef
  } = t0;
  const placeholder = t1 === void 0 ? "Search" : t1;
  const expandable = t2 === void 0 ? false : t2;
  const large = t3 === void 0 ? false : t3;
  const [searchText, setSearchText] = useState("");
  const [active, setActive] = useState(false);
  const deferredValues = useDebounceValue(searchText, 200);
  let t4;
  if ($[0] !== deferredValues || $[1] !== onTextSearch) {
    t4 = () => {
      if (!onTextSearch) {
        return;
      }
      if (deferredValues) {
        onTextSearch(deferredValues);
      } else {
        onTextSearch(void 0);
      }
    };
    $[0] = deferredValues;
    $[1] = onTextSearch;
    $[2] = t4;
  } else {
    t4 = $[2];
  }
  let t5;
  if ($[3] !== deferredValues) {
    t5 = [deferredValues];
    $[3] = deferredValues;
    $[4] = t5;
  } else {
    t5 = $[4];
  }
  React__default.useEffect(t4, t5);
  let t6;
  if ($[5] !== onTextSearch) {
    t6 = () => {
      if (!onTextSearch) {
        return;
      }
      setSearchText("");
      onTextSearch(void 0);
    };
    $[5] = onTextSearch;
    $[6] = t6;
  } else {
    t6 = $[6];
  }
  const clearText = t6;
  const t7 = large ? "h-14" : "h-[42px]";
  let t8;
  if ($[7] !== className || $[8] !== t7) {
    t8 = cls("relative", t7, "bg-surface-accent-50 dark:bg-surface-800 border", defaultBorderMixin, "rounded-lg", className);
    $[7] = className;
    $[8] = t7;
    $[9] = t8;
  } else {
    t8 = $[9];
  }
  let t9;
  if ($[10] !== loading) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute p-0 px-4 h-full pointer-events-none flex items-center justify-center top-0", children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: "small" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SearchIcon, { className: "text-text-disabled dark:text-text-disabled-dark" }) });
    $[10] = loading;
    $[11] = t9;
  } else {
    t9 = $[11];
  }
  const t10 = searchText ?? "";
  const t11 = !onTextSearch;
  let t12;
  if ($[12] !== onTextSearch) {
    t12 = onTextSearch ? (event) => {
      setSearchText(event.target.value);
    } : void 0;
    $[12] = onTextSearch;
    $[13] = t12;
  } else {
    t12 = $[13];
  }
  let t13;
  let t14;
  if ($[14] === Symbol.for("react.memo_cache_sentinel")) {
    t13 = () => setActive(true);
    t14 = () => setActive(false);
    $[14] = t13;
    $[15] = t14;
  } else {
    t13 = $[14];
    t14 = $[15];
  }
  const t15 = (disabled || loading) && "pointer-events-none";
  const t16 = expandable ? active ? "w-[220px]" : "w-[180px]" : "";
  let t17;
  if ($[16] !== innerClassName || $[17] !== t15 || $[18] !== t16) {
    t17 = cls(t15, "placeholder-text-disabled dark:placeholder-text-disabled-dark", "relative flex items-center rounded-lg transition-all bg-transparent outline-none appearance-none border-none", "pl-12 h-full text-current ", t16, innerClassName);
    $[16] = innerClassName;
    $[17] = t15;
    $[18] = t16;
    $[19] = t17;
  } else {
    t17 = $[19];
  }
  let t18;
  if ($[20] !== autoFocus || $[21] !== inputRef || $[22] !== onClick || $[23] !== placeholder || $[24] !== t10 || $[25] !== t11 || $[26] !== t12 || $[27] !== t17) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsx("input", { value: t10, ref: inputRef, onClick, placeholder, readOnly: t11, onChange: t12, autoFocus, onFocus: t13, onBlur: t14, className: t17 });
    $[20] = autoFocus;
    $[21] = inputRef;
    $[22] = onClick;
    $[23] = placeholder;
    $[24] = t10;
    $[25] = t11;
    $[26] = t12;
    $[27] = t17;
    $[28] = t18;
  } else {
    t18 = $[28];
  }
  let t19;
  if ($[29] !== clearText || $[30] !== large || $[31] !== searchText) {
    t19 = searchText ? /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { className: `${large ? "mr-2 top-1" : "mr-1 top-0"} absolute right-0 z-10`, onClick: clearText, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, { size: "small" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
      width: 26
    } });
    $[29] = clearText;
    $[30] = large;
    $[31] = searchText;
    $[32] = t19;
  } else {
    t19 = $[32];
  }
  let t20;
  if ($[33] !== onClick || $[34] !== t18 || $[35] !== t19 || $[36] !== t8 || $[37] !== t9) {
    t20 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick, className: t8, children: [
      t9,
      t18,
      t19
    ] });
    $[33] = onClick;
    $[34] = t18;
    $[35] = t19;
    $[36] = t8;
    $[37] = t9;
    $[38] = t20;
  } else {
    t20 = $[38];
  }
  return t20;
}
const Select = forwardRef(({
  inputRef,
  open,
  name,
  fullWidth = false,
  id,
  onOpenChange,
  value,
  onChange,
  onValueChange,
  className,
  inputClassName,
  placeholder,
  renderValue,
  label,
  size: size2 = "large",
  error,
  disabled,
  padding = true,
  position = "item-aligned",
  endAdornment,
  invisible,
  children,
  ...props
}, ref) => {
  const [openInternal, setOpenInternal] = useState(open ?? false);
  useEffect(() => {
    setOpenInternal(open ?? false);
  }, [open]);
  const onValueChangeInternal = useCallback((newValue) => {
    onValueChange?.(newValue);
    if (onChange) {
      const event = {
        target: {
          name,
          value: newValue
        }
      };
      onChange(event);
    }
  }, [onChange, value, onValueChange]);
  const hasValue = Array.isArray(value) ? value.length > 0 : value != null && value !== "" && value !== void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2$1, { name, value, open: openInternal, disabled, onValueChange: onValueChangeInternal, onOpenChange: (open_0) => {
    onOpenChange?.(open_0);
    setOpenInternal(open_0);
  }, ...props, children: [
    typeof label === "string" ? /* @__PURE__ */ jsxRuntimeExports.jsx(SelectInputLabel, { error, children: label }) : label,
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls("select-none rounded-md text-sm", invisible ? fieldBackgroundInvisibleMixin : fieldBackgroundMixin, disabled ? fieldBackgroundDisabledMixin : fieldBackgroundHoverMixin, "relative flex items-center", className, {
      "min-h-[28px]": size2 === "small",
      "min-h-[42px]": size2 === "medium",
      "min-h-[64px]": size2 === "large",
      "w-fit": !fullWidth,
      "w-full": fullWidth
    }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger$2, { ref: inputRef, id, asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cls("h-full", padding ? {
      "px-4": size2 === "large",
      "px-3": size2 === "medium",
      "px-2": size2 === "small"
    } : "", "outline-none focus:outline-none", "select-none rounded-md text-sm", error ? "text-red-500 dark:text-red-600" : "focus:text-text-primary dark:focus:text-text-primary-dark", error ? "border border-red-500 dark:border-red-600" : "", disabled ? "text-surface-accent-600 dark:text-surface-accent-400" : "text-surface-accent-800 dark:text-white", "relative flex flex-row items-center", {
      "min-h-[28px]": size2 === "small",
      "min-h-[42px]": size2 === "medium",
      "min-h-[64px]": size2 === "large",
      "w-full": fullWidth,
      "w-fit": !fullWidth
    }, inputClassName), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: cls("flex-grow max-w-full flex flex-row gap-2 items-center", "overflow-visible", {
        "min-h-[28px]": size2 === "small",
        "min-h-[42px]": size2 === "medium",
        "min-h-[64px]": size2 === "large"
      }), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Value, { onClick: (e) => {
        e.preventDefault();
        e.stopPropagation();
      }, placeholder, className: "w-full", children: [
        hasValue && value && renderValue ? renderValue(value) : placeholder,
        hasValue && !renderValue && (() => {
          const childrenProps = Children.map(children, (child) => {
            if (React__default.isValidElement(child)) {
              return child.props;
            }
          }).filter(Boolean);
          const option = childrenProps.find((o) => o.value === value);
          return option?.children;
        })()
      ] }) }),
      endAdornment && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls("h-full flex items-center"), onClick: (e_0) => {
        e_0.preventDefault();
        e_0.stopPropagation();
      }, children: endAdornment }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Icon$1, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardArrowDownIcon, { size: "medium", className: cls("transition", open ? "rotate-180" : "", {
        "px-2": size2 === "large",
        "px-1": size2 === "medium" || size2 === "small"
      }) }) })
    ] }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Content2$1, { position, className: cls(focusedDisabled, "z-50 relative overflow-hidden border bg-white dark:bg-surface-900 p-2 rounded-lg", defaultBorderMixin), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Viewport, { className: "p-1", style: {
      maxHeight: "var(--radix-select-content-available-height)"
    }, children }) }) })
  ] });
});
Select.displayName = "Select";
function SelectItem(t0) {
  const $ = c_1(11);
  const {
    value,
    children,
    disabled,
    className
  } = t0;
  const t1 = disabled ? "opacity-50 cursor-not-allowed" : "cursor-pointer";
  let t2;
  if ($[0] !== className || $[1] !== t1) {
    t2 = cls("w-full", "relative flex items-center p-2 rounded-md text-sm text-surface-accent-700 dark:text-surface-accent-300", "focus:z-10", "data-[state=checked]:bg-surface-accent-100 data-[state=checked]:dark:bg-surface-accent-800 focus:bg-surface-accent-100 dark:focus:bg-surface-950", "data-[state=checked]:focus:bg-surface-accent-200 data-[state=checked]:dark:focus:bg-surface-950", t1, "[&>*]:w-full", "overflow-visible", className);
    $[0] = className;
    $[1] = t1;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  let t3;
  if ($[3] !== children) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(ItemText, { children });
    $[3] = children;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute left-1 data-[state=checked]:block hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon, { size: 16 }) });
    $[5] = t4;
  } else {
    t4 = $[5];
  }
  let t5;
  if ($[6] !== disabled || $[7] !== t2 || $[8] !== t3 || $[9] !== value) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Item, { value, disabled, className: t2, children: [
      t3,
      t4
    ] }, value);
    $[6] = disabled;
    $[7] = t2;
    $[8] = t3;
    $[9] = value;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  return t5;
}
function SelectGroup(t0) {
  const $ = c_1(8);
  const {
    label,
    children,
    className
  } = t0;
  let t1;
  if ($[0] !== className) {
    t1 = cls("text-xs text-surface-accent-900 dark:text-white uppercase tracking-wider font-bold mt-6 first:mt-2", "px-2 py-2", className);
    $[0] = className;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== label || $[3] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Group, { className: t1, children: label });
    $[2] = label;
    $[3] = t1;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  let t3;
  if ($[5] !== children || $[6] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t2,
      children
    ] });
    $[5] = children;
    $[6] = t2;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  return t3;
}
function SliderThumb(props) {
  const $ = c_1(13);
  const t0 = props.hovered;
  const t1 = !props.props.disabled;
  let t2;
  if ($[0] !== props.classes || $[1] !== props.props.disabled || $[2] !== t1) {
    t2 = cls({
      "border-primary bg-primary outline-none": t1,
      "border-surface-accent-300 bg-surface-accent-300 dark:border-surface-700 dark:bg-surface-700": props.props.disabled
    }, props.classes, "focus-visible:ring-4 focus-visible:ring-primary focus-visible:ring-opacity-50", "hover:ring-4 hover:ring-primary hover:ring-opacity-25", "block rounded-full transition-colors focus-visible:outline-none disabled:pointer-events-none disabled:opacity-50");
    $[0] = props.classes;
    $[1] = props.props.disabled;
    $[2] = t1;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger$1, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Thumb, { className: t2 }) });
    $[4] = t2;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = cls("TooltipContent", "max-w-lg leading-relaxed", "z-50 rounded px-3 py-2 text-xs leading-none bg-surface-accent-700 dark:bg-surface-accent-800 bg-opacity-90 font-medium text-surface-accent-50 shadow-2xl select-none duration-400 ease-in transform opacity-100");
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  const t5 = props.props.value?.[props.index];
  let t6;
  if ($[7] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(Content2, { side: "top", sideOffset: 5, className: t4, children: t5 });
    $[7] = t5;
    $[8] = t6;
  } else {
    t6 = $[8];
  }
  let t7;
  if ($[9] !== props.hovered || $[10] !== t3 || $[11] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Root3, { open: t0, children: [
      t3,
      t6
    ] });
    $[9] = props.hovered;
    $[10] = t3;
    $[11] = t6;
    $[12] = t7;
  } else {
    t7 = $[12];
  }
  return t7;
}
const Slider = React.forwardRef((t0, ref) => {
  const $ = c_1(35);
  let className;
  let props;
  let t1;
  if ($[0] !== t0) {
    ({
      className,
      size: t1,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = className;
    $[2] = props;
    $[3] = t1;
  } else {
    className = $[1];
    props = $[2];
    t1 = $[3];
  }
  const size2 = t1 === void 0 ? "regular" : t1;
  const [hovered, setHovered] = React.useState(false);
  const thumbSizeClasses = size2 === "small" ? "h-4 w-4" : "h-6 w-6";
  let t2;
  let t3;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = () => setHovered(true);
    t3 = () => setHovered(false);
    $[4] = t2;
    $[5] = t3;
  } else {
    t2 = $[4];
    t3 = $[5];
  }
  let t4;
  if ($[6] !== className) {
    t4 = cls("relative flex w-full touch-none select-none items-center", className);
    $[6] = className;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  const t5 = size2 === "small" ? 4 : 8;
  let t6;
  if ($[8] !== t5) {
    t6 = {
      height: t5
    };
    $[8] = t5;
    $[9] = t6;
  } else {
    t6 = $[9];
  }
  const t7 = !props.disabled;
  let t8;
  if ($[10] !== props.disabled || $[11] !== t7) {
    t8 = cls("absolute h-full", {
      "bg-primary": t7,
      "bg-surface-accent-300 dark:bg-surface-700": props.disabled
    });
    $[10] = props.disabled;
    $[11] = t7;
    $[12] = t8;
  } else {
    t8 = $[12];
  }
  let t9;
  if ($[13] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(Range, { className: t8 });
    $[13] = t8;
    $[14] = t9;
  } else {
    t9 = $[14];
  }
  let t10;
  if ($[15] !== t6 || $[16] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(Track, { style: t6, className: "relative w-full grow overflow-hidden rounded-full bg-surface-accent-300 bg-opacity-40 dark:bg-surface-700 dark:bg-opacity-40", children: t9 });
    $[15] = t6;
    $[16] = t9;
    $[17] = t10;
  } else {
    t10 = $[17];
  }
  let t11;
  if ($[18] !== props.value) {
    t11 = props.value ?? [0];
    $[18] = props.value;
    $[19] = t11;
  } else {
    t11 = $[19];
  }
  let t12;
  if ($[20] !== hovered || $[21] !== props || $[22] !== t11 || $[23] !== thumbSizeClasses) {
    let t132;
    if ($[25] !== hovered || $[26] !== props || $[27] !== thumbSizeClasses) {
      t132 = (_2, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(SliderThumb, { index: index2, props, hovered, classes: thumbSizeClasses }, index2);
      $[25] = hovered;
      $[26] = props;
      $[27] = thumbSizeClasses;
      $[28] = t132;
    } else {
      t132 = $[28];
    }
    t12 = t11.map(t132);
    $[20] = hovered;
    $[21] = props;
    $[22] = t11;
    $[23] = thumbSizeClasses;
    $[24] = t12;
  } else {
    t12 = $[24];
  }
  let t13;
  if ($[29] !== props || $[30] !== ref || $[31] !== t10 || $[32] !== t12 || $[33] !== t4) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, { delayDuration: 200, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, { ref, onMouseEnter: t2, onMouseLeave: t3, className: t4, ...props, children: [
      t10,
      t12
    ] }) });
    $[29] = props;
    $[30] = ref;
    $[31] = t10;
    $[32] = t12;
    $[33] = t4;
    $[34] = t13;
  } else {
    t13 = $[34];
  }
  return t13;
});
Slider.displayName = "Slider";
const Sheet = (t0) => {
  const $ = c_1(61);
  let children;
  let className;
  let onOpenChange;
  let open;
  let overlayClassName;
  let props;
  let t1;
  let t2;
  let t3;
  let title;
  let transparent;
  if ($[0] !== t0) {
    ({
      children,
      side: t1,
      title,
      modal: t2,
      includeBackgroundOverlay: t3,
      open,
      onOpenChange,
      transparent,
      className,
      overlayClassName,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = className;
    $[3] = onOpenChange;
    $[4] = open;
    $[5] = overlayClassName;
    $[6] = props;
    $[7] = t1;
    $[8] = t2;
    $[9] = t3;
    $[10] = title;
    $[11] = transparent;
  } else {
    children = $[1];
    className = $[2];
    onOpenChange = $[3];
    open = $[4];
    overlayClassName = $[5];
    props = $[6];
    t1 = $[7];
    t2 = $[8];
    t3 = $[9];
    title = $[10];
    transparent = $[11];
  }
  const side = t1 === void 0 ? "right" : t1;
  const modal = t2 === void 0 ? true : t2;
  const includeBackgroundOverlay = t3 === void 0 ? true : t3;
  const [displayed, setDisplayed] = useState(false);
  let t4;
  let t5;
  if ($[12] !== open) {
    t4 = () => {
      const timeout = setTimeout(() => {
        setDisplayed(open);
      }, 1);
      return () => clearTimeout(timeout);
    };
    t5 = [open];
    $[12] = open;
    $[13] = t4;
    $[14] = t5;
  } else {
    t4 = $[13];
    t5 = $[14];
  }
  useEffect(t4, t5);
  let T0;
  let T1;
  let T2;
  let t10;
  let t11;
  let t12;
  let t13;
  let t6;
  let t7;
  let t8;
  let t9;
  if ($[15] !== className || $[16] !== displayed || $[17] !== includeBackgroundOverlay || $[18] !== modal || $[19] !== onOpenChange || $[20] !== open || $[21] !== overlayClassName || $[22] !== props || $[23] !== side || $[24] !== title || $[25] !== transparent) {
    const transformValue = {
      top: "-translate-y-full",
      bottom: "translate-y-full",
      left: "-translate-x-full",
      right: "translate-x-full"
    };
    const borderClass = {
      top: "border-b",
      bottom: "border-t",
      left: "border-r",
      right: "border-l"
    };
    T2 = Root$6;
    t11 = displayed || open;
    t12 = modal;
    t13 = onOpenChange;
    T1 = Portal$4;
    const t142 = title ?? "Sheet";
    if ($[37] !== t142) {
      t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(Title, { autoFocus: true, tabIndex: 0, children: t142 });
      $[37] = t142;
      $[38] = t9;
    } else {
      t9 = $[38];
    }
    if ($[39] !== displayed || $[40] !== includeBackgroundOverlay || $[41] !== open || $[42] !== overlayClassName) {
      t10 = includeBackgroundOverlay && /* @__PURE__ */ jsxRuntimeExports.jsx(Overlay, { className: cls("fixed inset-0 transition-opacity z-20 ease-in-out duration-100 backdrop-blur-sm", "bg-black bg-opacity-50", "dark:bg-surface-900 dark:bg-opacity-60", displayed && open ? "opacity-100" : "opacity-0", overlayClassName), style: {
        pointerEvents: displayed ? "auto" : "none"
      } });
      $[39] = displayed;
      $[40] = includeBackgroundOverlay;
      $[41] = open;
      $[42] = overlayClassName;
      $[43] = t10;
    } else {
      t10 = $[43];
    }
    T0 = Content$1;
    t6 = props;
    t7 = _temp;
    t8 = cls(borderClass[side], defaultBorderMixin, "transform-gpu", "will-change-transform", "text-surface-accent-900 dark:text-white", "fixed transform z-20 transition-all ease-in-out", !displayed ? "duration-150" : "duration-100", "outline-none focus:outline-none", transparent ? "" : "shadow-md bg-white dark:bg-surface-950", side === "top" || side === "bottom" ? "w-full" : "h-full", side === "left" || side === "top" ? "left-0 top-0" : "right-0 bottom-0", displayed && open ? "opacity-100" : "opacity-50", !displayed || !open ? transformValue[side] : "", className);
    $[15] = className;
    $[16] = displayed;
    $[17] = includeBackgroundOverlay;
    $[18] = modal;
    $[19] = onOpenChange;
    $[20] = open;
    $[21] = overlayClassName;
    $[22] = props;
    $[23] = side;
    $[24] = title;
    $[25] = transparent;
    $[26] = T0;
    $[27] = T1;
    $[28] = T2;
    $[29] = t10;
    $[30] = t11;
    $[31] = t12;
    $[32] = t13;
    $[33] = t6;
    $[34] = t7;
    $[35] = t8;
    $[36] = t9;
  } else {
    T0 = $[26];
    T1 = $[27];
    T2 = $[28];
    t10 = $[29];
    t11 = $[30];
    t12 = $[31];
    t13 = $[32];
    t6 = $[33];
    t7 = $[34];
    t8 = $[35];
    t9 = $[36];
  }
  let t14;
  if ($[44] !== T0 || $[45] !== children || $[46] !== t6 || $[47] !== t7 || $[48] !== t8) {
    t14 = /* @__PURE__ */ jsxRuntimeExports.jsx(T0, { ...t6, onFocusCapture: t7, className: t8, children });
    $[44] = T0;
    $[45] = children;
    $[46] = t6;
    $[47] = t7;
    $[48] = t8;
    $[49] = t14;
  } else {
    t14 = $[49];
  }
  let t15;
  if ($[50] !== T1 || $[51] !== t10 || $[52] !== t14 || $[53] !== t9) {
    t15 = /* @__PURE__ */ jsxRuntimeExports.jsxs(T1, { children: [
      t9,
      t10,
      t14
    ] });
    $[50] = T1;
    $[51] = t10;
    $[52] = t14;
    $[53] = t9;
    $[54] = t15;
  } else {
    t15 = $[54];
  }
  let t16;
  if ($[55] !== T2 || $[56] !== t11 || $[57] !== t12 || $[58] !== t13 || $[59] !== t15) {
    t16 = /* @__PURE__ */ jsxRuntimeExports.jsx(T2, { open: t11, modal: t12, onOpenChange: t13, children: t15 });
    $[55] = T2;
    $[56] = t11;
    $[57] = t12;
    $[58] = t13;
    $[59] = t15;
    $[60] = t16;
  } else {
    t16 = $[60];
  }
  return t16;
};
function _temp(event) {
  return event.preventDefault();
}
function getStyleValue(value) {
  return parseInt(value, 10) || 0;
}
const styles$1 = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function isEmpty(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0 || obj.outerHeightStyle === 0 && !obj.overflow;
}
const TextareaAutosize = React.forwardRef(function TextareaAutosize2(props, ref) {
  const {
    onChange,
    onScroll,
    onResize,
    maxRows,
    minRows = 1,
    style,
    value,
    onFocus,
    onBlur,
    sizeRef,
    ignoreBoxSizing,
    ...other
  } = props;
  const {
    current: isControlled
  } = React.useRef(value != null);
  const inputRef = React.useRef(null);
  const handleRef = useForkRef(ref, inputRef);
  const shadowRef = React.useRef(null);
  const renders = React.useRef(0);
  const [state, setState] = React.useState({
    outerHeightStyle: 0
  });
  const getUpdatedState = React.useCallback(() => {
    const input = inputRef.current;
    if (typeof window === "undefined") {
      return {
        outerHeightStyle: 0
      };
    }
    const containerWindow = window;
    const computedStyle = containerWindow.getComputedStyle(input);
    if (computedStyle.width === "0px") {
      return {
        outerHeightStyle: 0
      };
    }
    const sizeReferenceElement = sizeRef?.current ?? shadowRef.current;
    const inputShallow = shadowRef.current;
    sizeReferenceElement.style.width = computedStyle.width;
    inputShallow.value = input.value || props.placeholder || "x";
    if (inputShallow.value.slice(-1) === "\n") {
      inputShallow.value += " ";
    }
    const boxSizing = computedStyle.boxSizing;
    const padding = getStyleValue(computedStyle.paddingBottom) + getStyleValue(computedStyle.paddingTop);
    const border = getStyleValue(computedStyle.borderBottomWidth) + getStyleValue(computedStyle.borderTopWidth);
    const minHeight = getStyleValue(computedStyle.minHeight);
    const innerHeight = sizeReferenceElement.scrollHeight;
    inputShallow.value = "x";
    const singleRowHeight = sizeReferenceElement.scrollHeight;
    let outerHeight = innerHeight;
    if (minRows) {
      outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
    }
    if (maxRows) {
      outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
    }
    outerHeight = Math.max(outerHeight, singleRowHeight, minHeight);
    const outerHeightStyle = outerHeight + (!ignoreBoxSizing && boxSizing === "border-box" ? padding + border : 0);
    const overflow = Math.abs(outerHeight - innerHeight) <= 1;
    return {
      outerHeightStyle,
      overflow
    };
  }, [maxRows, minRows, props.placeholder]);
  const updateState = (prevState, newState) => {
    const {
      outerHeightStyle: outerHeightStyle_0,
      overflow: overflow_0
    } = newState;
    if (renders.current < 20 && (outerHeightStyle_0 > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle_0) > 1 || prevState.overflow !== overflow_0)) {
      renders.current += 1;
      return {
        overflow: overflow_0,
        outerHeightStyle: outerHeightStyle_0
      };
    }
    return prevState;
  };
  const syncHeight = React.useCallback(() => {
    const newState_0 = getUpdatedState();
    if (isEmpty(newState_0)) {
      return;
    }
    if (onResize) {
      onResize(newState_0);
    }
    setState((prevState_0) => {
      return updateState(prevState_0, newState_0);
    });
  }, [getUpdatedState, onResize]);
  const syncHeightWithFlushSync = () => {
    const newState_1 = getUpdatedState();
    if (isEmpty(newState_1)) {
      return;
    }
    ReactDOM.flushSync(() => {
      setState((prevState_1) => {
        return updateState(prevState_1, newState_1);
      });
    });
  };
  React.useEffect(() => {
    const handleResize = debounce(() => {
      renders.current = 0;
      if (inputRef.current) {
        syncHeightWithFlushSync();
      }
    });
    let resizeObserver;
    const input_0 = inputRef.current;
    const containerWindow_0 = window;
    if (typeof window === "undefined") {
      return;
    }
    containerWindow_0.addEventListener("resize", handleResize);
    if (typeof ResizeObserver !== "undefined") {
      resizeObserver = new ResizeObserver(handleResize);
      resizeObserver.observe(input_0);
    }
    return () => {
      handleResize.clear();
      containerWindow_0.removeEventListener("resize", handleResize);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  });
  useLayoutEffect(() => {
    syncHeight();
  });
  React.useEffect(() => {
    renders.current = 0;
  }, [value]);
  const handleChange = (event) => {
    renders.current = 0;
    if (!isControlled) {
      syncHeight();
    }
    if (onChange) {
      onChange(event);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "textarea",
      {
        value,
        onChange: handleChange,
        className: props.className,
        ref: handleRef,
        onFocus,
        onBlur,
        rows: minRows,
        style: {
          height: state.outerHeightStyle,
          // Need a large enough difference to allow scrolling.
          // This prevents infinite rendering loop.
          overflow: state.overflow ? "hidden" : void 0,
          ...style
        },
        onScroll,
        ...other
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", { "aria-hidden": true, className: cls(props.className, props.shadowClassName), readOnly: true, ref: shadowRef, tabIndex: -1, style: {
      ...styles$1.shadow,
      ...style,
      padding: 0
    } })
  ] });
});
function useForkRef(...refs) {
  return React.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (instance) => {
      refs.forEach((ref) => {
        setRef(ref, instance);
      });
    };
  }, refs);
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
function TextField({
  value,
  onChange,
  label,
  type = "text",
  multiline = false,
  invisible,
  rows,
  disabled,
  error,
  endAdornment,
  autoFocus,
  placeholder,
  size: size2 = "large",
  className,
  style,
  inputClassName,
  inputStyle,
  inputRef: inputRefProp,
  ...inputProps
}) {
  const inputRef = inputRefProp ?? useRef(null);
  const [focused, setFocused] = React__default.useState(document.activeElement === inputRef.current);
  const hasValue = value !== void 0 && value !== null && value !== "";
  useEffect(() => {
    if (type !== "number") return;
    const handleWheel = (event) => {
      if (event.target instanceof HTMLElement) event.target.blur();
    };
    const element = "current" in inputRef ? inputRef.current : inputRef;
    element.addEventListener("wheel", handleWheel);
    return () => {
      element.removeEventListener("wheel", handleWheel);
    };
  }, [inputRef, type]);
  const numberInputOnWheelPreventChange = useCallback((e) => {
    e.preventDefault();
  }, []);
  const input = multiline ? /* @__PURE__ */ jsxRuntimeExports.jsx(TextareaAutosize, { ...inputProps, ref: inputRef, placeholder: focused || hasValue || !label ? placeholder : void 0, autoFocus, rows, value: value ?? "", onChange, style: inputStyle, className: cls(invisible ? focusedInvisibleMixin : "", "rounded-md resize-none w-full outline-none p-[32px] text-base bg-transparent min-h-[64px] px-3 pt-8", disabled && "border border-transparent outline-none opacity-50 text-surface-accent-600 dark:text-surface-accent-500") }) : /* @__PURE__ */ jsxRuntimeExports.jsx("input", { ...inputProps, ref: inputRef, onWheel: type === "number" ? numberInputOnWheelPreventChange : void 0, disabled, style: inputStyle, className: cls("w-full outline-none bg-transparent leading-normal px-3", "rounded-md", "focused:text-text-primary focused:dark:text-text-primary-dark", invisible ? focusedInvisibleMixin : "", disabled ? fieldBackgroundDisabledMixin : fieldBackgroundHoverMixin, size2 === "small" ? "min-h-[32px]" : size2 === "medium" ? "min-h-[48px]" : "min-h-[64px]", label ? size2 === "large" ? "pt-8 pb-2" : "pt-4 pb-2" : "py-2", endAdornment ? "pr-10" : "pr-3", disabled && "border border-transparent outline-none opacity-50 dark:opacity-50 text-surface-accent-800 dark:text-white", inputClassName), placeholder: focused || hasValue || !label ? placeholder : void 0, autoFocus, onFocus: () => setFocused(true), onBlur: () => setFocused(false), type, value: Number.isNaN(value) ? "" : value ?? "", onChange });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cls("rounded-md relative max-w-full", invisible ? fieldBackgroundInvisibleMixin : fieldBackgroundMixin, disabled ? fieldBackgroundDisabledMixin : fieldBackgroundHoverMixin, error ? "border border-red-500 dark:border-red-600" : "", {
    "min-h-[32px]": !invisible && size2 === "small",
    "min-h-[48px]": !invisible && size2 === "medium",
    "min-h-[64px]": !invisible && size2 === "large"
  }, className), style, children: [
    label && /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { className: cls("pointer-events-none absolute", size2 === "large" ? "top-1" : "top-[-1px]", !error ? focused ? "text-primary dark:text-primary" : "text-text-secondary dark:text-text-secondary-dark" : "text-red-500 dark:text-red-600", disabled ? "opacity-50" : ""), shrink: hasValue || focused, children: label }),
    input,
    endAdornment && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls("flex flex-row justify-center items-center absolute h-full right-0 top-0", {
      "mr-4": size2 === "large",
      "mr-3": size2 === "medium",
      "mr-2": size2 === "small"
    }), children: endAdornment })
  ] });
}
const Tooltip = (t0) => {
  const $ = c_1(28);
  const {
    open,
    defaultOpen,
    side: t1,
    delayDuration: t2,
    sideOffset,
    align,
    onOpenChange,
    title,
    tooltipClassName,
    tooltipStyle,
    children,
    asChild: t3,
    container,
    className,
    style
  } = t0;
  const side = t1 === void 0 ? "bottom" : t1;
  const delayDuration = t2 === void 0 ? 200 : t2;
  const asChild = t3 === void 0 ? false : t3;
  useInjectStyles("Tooltip", styles);
  if (!title) {
    let t42;
    if ($[0] !== children) {
      t42 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
      $[0] = children;
      $[1] = t42;
    } else {
      t42 = $[1];
    }
    return t42;
  }
  let t4;
  if ($[2] !== asChild || $[3] !== children || $[4] !== className || $[5] !== style) {
    t4 = asChild ? /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger$1, { asChild: true, children }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger$1, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style, className, children }) });
    $[2] = asChild;
    $[3] = children;
    $[4] = className;
    $[5] = style;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  const trigger = t4;
  let t5;
  if ($[7] !== tooltipClassName) {
    t5 = cls("TooltipContent", "max-w-lg leading-relaxed", "z-50 rounded px-3 py-2 text-xs leading-none bg-surface-accent-700 dark:bg-surface-accent-800 bg-opacity-90 font-medium text-surface-accent-50 shadow-2xl select-none duration-400 ease-in transform opacity-100", tooltipClassName);
    $[7] = tooltipClassName;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  const t6 = sideOffset === void 0 ? 4 : sideOffset;
  let t7;
  if ($[9] !== align || $[10] !== side || $[11] !== t5 || $[12] !== t6 || $[13] !== title || $[14] !== tooltipStyle) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(Content2, { className: t5, style: tooltipStyle, sideOffset: t6, align, side, children: title });
    $[9] = align;
    $[10] = side;
    $[11] = t5;
    $[12] = t6;
    $[13] = title;
    $[14] = tooltipStyle;
    $[15] = t7;
  } else {
    t7 = $[15];
  }
  let t8;
  if ($[16] !== container || $[17] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { container, children: t7 });
    $[16] = container;
    $[17] = t7;
    $[18] = t8;
  } else {
    t8 = $[18];
  }
  let t9;
  if ($[19] !== defaultOpen || $[20] !== onOpenChange || $[21] !== open || $[22] !== t8 || $[23] !== trigger) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Root3, { open, onOpenChange, defaultOpen, children: [
      trigger,
      t8
    ] });
    $[19] = defaultOpen;
    $[20] = onOpenChange;
    $[21] = open;
    $[22] = t8;
    $[23] = trigger;
    $[24] = t9;
  } else {
    t9 = $[24];
  }
  let t10;
  if ($[25] !== delayDuration || $[26] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, { delayDuration, children: t9 });
    $[25] = delayDuration;
    $[26] = t9;
    $[27] = t10;
  } else {
    t10 = $[27];
  }
  return t10;
};
const styles = `

.TooltipContent {
  animation-duration: 220ms;
  animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
  will-change: transform, opacity;
}

.TooltipContent[data-state='delayed-open'][data-side='top'] {
  animation-name: slideDownAndFade;
}
.TooltipContent[data-state='delayed-open'][data-side='right'] {
  animation-name: slideLeftAndFade;
}
.TooltipContent[data-state='delayed-open'][data-side='bottom'] {
  animation-name: slideUpAndFade;
}
.TooltipContent[data-state='delayed-open'][data-side='left'] {
  animation-name: slideRightAndFade;
}


@keyframes slideUpAndFade {
  from {
    opacity: 0;
    transform: translateY(4px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideRightAndFade {
  from {
    opacity: 0;
    transform: translateX(-4px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes slideDownAndFade {
  from {
    opacity: 0;
    transform: translateY(-4px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideLeftAndFade {
  from {
    opacity: 0;
    transform: translateX(4px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}`;
function Tabs(t0) {
  const $ = c_1(10);
  const {
    value,
    onValueChange,
    className,
    innerClassName,
    children
  } = t0;
  let t1;
  if ($[0] !== innerClassName) {
    t1 = cls("flex text-sm font-medium text-center text-surface-accent-800 dark:text-white max-w-full overflow-auto no-scrollbar items-end", innerClassName);
    $[0] = innerClassName;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== children || $[3] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(List, { className: t1, children });
    $[2] = children;
    $[3] = t1;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  let t3;
  if ($[5] !== className || $[6] !== onValueChange || $[7] !== t2 || $[8] !== value) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(Root2, { value, onValueChange, className, children: t2 });
    $[5] = className;
    $[6] = onValueChange;
    $[7] = t2;
    $[8] = value;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  return t3;
}
function Tab(t0) {
  const $ = c_1(13);
  const {
    value,
    className,
    innerClassName,
    children,
    disabled
  } = t0;
  let t1;
  if ($[0] !== className || $[1] !== disabled) {
    t1 = cls("border-b-2 border-transparent", "data-[state=active]:border-secondary", disabled ? "text-surface-accent-400 dark:text-surface-accent-500" : cls("text-surface-accent-700 dark:text-surface-accent-300", "data-[state=active]:text-surface-accent-900 data-[state=active]:dark:text-white", "hover:text-surface-accent-800 dark:hover:text-surface-accent-200"), className);
    $[0] = className;
    $[1] = disabled;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[3] !== innerClassName) {
    t2 = cls("uppercase inline-block p-2 px-4 m-2 rounded", "hover:bg-surface-accent-200 hover:bg-opacity-75 dark:hover:bg-surface-accent-800", innerClassName);
    $[3] = innerClassName;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  let t3;
  if ($[5] !== children || $[6] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t2, children });
    $[5] = children;
    $[6] = t2;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  let t4;
  if ($[8] !== disabled || $[9] !== t1 || $[10] !== t3 || $[11] !== value) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger, { value, disabled, className: t1, children: t3 });
    $[8] = disabled;
    $[9] = t1;
    $[10] = t3;
    $[11] = value;
    $[12] = t4;
  } else {
    t4 = $[12];
  }
  return t4;
}
const Table = ({
  children,
  className,
  style,
  ...rest
}) => /* @__PURE__ */ jsxRuntimeExports.jsx("table", { className: cls("text-left text-surface-800 dark:text-white rounded-md overflow-x-auto", className), style, ...rest, children });
const TableBody = ({
  children,
  className,
  ...rest
}) => /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { className: cls("bg-white dark:bg-surface-950 text-sm divide-y divide-surface-100 dark:divide-surface-700 dark:divide-opacity-70", className), ...rest, children });
const TableHeader = ({
  children,
  className,
  ...rest
}) => /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { ...rest, children: /* @__PURE__ */ jsxRuntimeExports.jsx("tr", { className: cls(defaultBorderMixin, "text-sm font-medium text-surface-700 dark:text-surface-accent-300", "bg-surface-accent-50 border-b dark:bg-surface-900", className), children }) });
const TableRow = ({
  children,
  className,
  onClick,
  style,
  ...rest
}) => /* @__PURE__ */ jsxRuntimeExports.jsx("tr", { onClick, style, className: cls("bg-white dark:bg-surface-950", onClick ? "hover:bg-surface-accent-100 dark:hover:bg-surface-accent-800 cursor-pointer" : "", className), ...rest, children });
const TableCell = ({
  children,
  header = false,
  scope = "",
  align,
  className,
  style,
  colspan,
  ...rest
}) => {
  const ref = useRef(null);
  const Tag = header || getParentName(ref.current) === "TableHeader" ? "th" : "td";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { scope, colSpan: colspan, ref, style, className: cls("px-4 py-3 text-clip ", align === "center" ? "text-center" : align === "right" ? "text-right" : "text-left", className), ...rest, children });
};
function getParentName(element) {
  if (element) {
    const key = Object.keys(element).find((key2) => {
      return key2.startsWith("__reactFiber$") || key2.startsWith("__reactInternalInstance$");
    });
    const domFiber = element[key];
    const getComponentFiber = (fiber2) => {
      let parentFiber = fiber2.return;
      while (typeof parentFiber.type === "string") {
        parentFiber = parentFiber.return;
      }
      return parentFiber;
    };
    let fiber = getComponentFiber(domFiber);
    fiber = getComponentFiber(fiber);
    return fiber?.elementType?.name;
  }
  return void 0;
}
function Popover(t0) {
  const $ = c_1(27);
  const {
    trigger,
    children,
    open,
    onOpenChange,
    side,
    sideOffset: t1,
    align,
    alignOffset,
    arrowPadding,
    sticky,
    hideWhenDetached,
    avoidCollisions,
    enabled: t2,
    modal: t3,
    portalContainer,
    className
  } = t0;
  const sideOffset = t1 === void 0 ? 5 : t1;
  const enabled = t2 === void 0 ? true : t2;
  const modal = t3 === void 0 ? false : t3;
  useInjectStyles("Popover", popoverStyles);
  if (!enabled) {
    let t42;
    if ($[0] !== trigger) {
      t42 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: trigger });
      $[0] = trigger;
      $[1] = t42;
    } else {
      t42 = $[1];
    }
    return t42;
  }
  let t4;
  if ($[2] !== trigger) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger$3, { asChild: true, children: trigger });
    $[2] = trigger;
    $[3] = t4;
  } else {
    t4 = $[3];
  }
  let t5;
  if ($[4] !== className) {
    t5 = cls(paperMixin, "PopoverContent z-40", className);
    $[4] = className;
    $[5] = t5;
  } else {
    t5 = $[5];
  }
  let t6;
  if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow2, { className: "fill-white dark:fill-surface-accent-950" });
    $[6] = t6;
  } else {
    t6 = $[6];
  }
  let t7;
  if ($[7] !== align || $[8] !== alignOffset || $[9] !== arrowPadding || $[10] !== avoidCollisions || $[11] !== children || $[12] !== hideWhenDetached || $[13] !== side || $[14] !== sideOffset || $[15] !== sticky || $[16] !== t5) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Content2$2, { className: t5, side, sideOffset, align, alignOffset, arrowPadding, sticky, hideWhenDetached, avoidCollisions, children: [
      children,
      t6
    ] });
    $[7] = align;
    $[8] = alignOffset;
    $[9] = arrowPadding;
    $[10] = avoidCollisions;
    $[11] = children;
    $[12] = hideWhenDetached;
    $[13] = side;
    $[14] = sideOffset;
    $[15] = sticky;
    $[16] = t5;
    $[17] = t7;
  } else {
    t7 = $[17];
  }
  let t8;
  if ($[18] !== portalContainer || $[19] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$2, { container: portalContainer, children: t7 });
    $[18] = portalContainer;
    $[19] = t7;
    $[20] = t8;
  } else {
    t8 = $[20];
  }
  let t9;
  if ($[21] !== modal || $[22] !== onOpenChange || $[23] !== open || $[24] !== t4 || $[25] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2$3, { open, onOpenChange, modal, children: [
      t4,
      t8
    ] });
    $[21] = modal;
    $[22] = onOpenChange;
    $[23] = open;
    $[24] = t4;
    $[25] = t8;
    $[26] = t9;
  } else {
    t9 = $[26];
  }
  return t9;
}
const popoverStyles = `

.PopoverContent {
  animation-duration: 400ms;
  animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
  will-change: transform, opacity;
}
.PopoverContent[data-state='open'][data-side='top'] {
  animation-name: slideDownAndFade;
}
.PopoverContent[data-state='open'][data-side='right'] {
  animation-name: slideLeftAndFade;
}
.PopoverContent[data-state='open'][data-side='bottom'] {
  animation-name: slideUpAndFade;
}
.PopoverContent[data-state='open'][data-side='left'] {
  animation-name: slideRightAndFade;
}


@keyframes slideUpAndFade {
  from {
    opacity: 0;
    transform: translateY(2px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideRightAndFade {
  from {
    opacity: 0;
    transform: translateX(-2px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes slideDownAndFade {
  from {
    opacity: 0;
    transform: translateY(-2px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideLeftAndFade {
  from {
    opacity: 0;
    transform: translateX(2px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}
`;
const getColor = (color) => {
  switch (color) {
    case "primary":
      return "bg-primary";
    case "secondary":
      return "bg-secondary";
    case "error":
      return "bg-red-500";
    default:
      return "bg-surface-accent-300 dark:bg-surface-accent-700";
  }
};
const Badge = (t0) => {
  const $ = c_1(5);
  const {
    color: t1,
    invisible: t2,
    children
  } = t0;
  const color = t1 === void 0 ? "primary" : t1;
  const invisible = t2 === void 0 ? false : t2;
  const t3 = `absolute top-0.5 right-0.5 transform translate-x-1/2 -translate-y-1/2 rounded-full
        ${getColor(color)}
        transition-all duration-200 ease-out
        ${invisible ? "w-0 h-0" : "w-2 h-2"}`;
  let t4;
  if ($[0] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: t3 });
    $[0] = t3;
    $[1] = t4;
  } else {
    t4 = $[1];
  }
  let t5;
  if ($[2] !== children || $[3] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative inline-block w-fit", children: [
      children,
      t4
    ] });
    $[2] = children;
    $[3] = t4;
    $[4] = t5;
  } else {
    t5 = $[4];
  }
  return t5;
};
function DebouncedTextField(props) {
  const $ = c_1(13);
  const previousEventRef = React__default.useRef();
  const [internalValue, setInternalValue] = React__default.useState(props.value);
  const deferredValue = useDeferredValue(internalValue);
  let t0;
  let t1;
  if ($[0] !== props.value) {
    t0 = () => {
      setInternalValue(props.value);
    };
    t1 = [props.value];
    $[0] = props.value;
    $[1] = t0;
    $[2] = t1;
  } else {
    t0 = $[1];
    t1 = $[2];
  }
  useEffect(t0, t1);
  let t2;
  if ($[3] !== deferredValue || $[4] !== props) {
    t2 = () => {
      const emptyInitialValue = !props.value;
      if (emptyInitialValue && !deferredValue) {
        return;
      }
      if (deferredValue !== props.value && previousEventRef.current && props.onChange) {
        props.onChange(previousEventRef.current);
      }
    };
    $[3] = deferredValue;
    $[4] = props;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  let t3;
  if ($[6] !== deferredValue || $[7] !== props.value) {
    t3 = [deferredValue, props.value];
    $[6] = deferredValue;
    $[7] = props.value;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  useEffect(t2, t3);
  let t4;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = (event) => {
      previousEventRef.current = event;
      setInternalValue(event.target.value);
    };
    $[9] = t4;
  } else {
    t4 = $[9];
  }
  const internalOnChange = t4;
  let t5;
  if ($[10] !== internalValue || $[11] !== props) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { ...props, onChange: internalOnChange, value: internalValue });
    $[10] = internalValue;
    $[11] = props;
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  return t5;
}
function Skeleton(t0) {
  const $ = c_1(8);
  const {
    width,
    height,
    className
  } = t0;
  const t1 = width ? `${width}px` : "100%";
  const t2 = height ? `${height}px` : "12px";
  let t3;
  if ($[0] !== t1 || $[1] !== t2) {
    t3 = {
      width: t1,
      height: t2
    };
    $[0] = t1;
    $[1] = t2;
    $[2] = t3;
  } else {
    t3 = $[2];
  }
  let t4;
  if ($[3] !== className) {
    t4 = cls("block", "bg-surface-accent-200 dark:bg-surface-accent-800 rounded-md", "animate-pulse", "max-w-full max-h-full", className);
    $[3] = className;
    $[4] = t4;
  } else {
    t4 = $[4];
  }
  let t5;
  if ($[5] !== t3 || $[6] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: t3, className: t4 });
    $[5] = t3;
    $[6] = t4;
    $[7] = t5;
  } else {
    t5 = $[7];
  }
  return t5;
}
export {
  AbcIcon,
  AcUnitIcon,
  AccessAlarmIcon,
  AccessAlarmsIcon,
  AccessTimeFilledIcon,
  AccessTimeIcon,
  AccessibilityIcon,
  AccessibilityNewIcon,
  AccessibleForwardIcon,
  AccessibleIcon,
  AccountBalanceIcon,
  AccountBalanceWalletIcon,
  AccountBoxIcon,
  AccountCircleIcon,
  AccountTreeIcon,
  AdUnitsIcon,
  AdbIcon,
  AddAPhotoIcon,
  AddAlarmIcon,
  AddAlertIcon,
  AddBoxIcon,
  AddBusinessIcon,
  AddCardIcon,
  AddChartIcon,
  AddCircleIcon,
  AddCircleOutlineIcon,
  AddCommentIcon,
  AddHomeIcon,
  AddHomeWorkIcon,
  AddIcCallIcon,
  AddIcon,
  AddLinkIcon,
  AddLocationAltIcon,
  AddLocationIcon,
  AddModeratorIcon,
  AddPhotoAlternateIcon,
  AddReactionIcon,
  AddRoadIcon,
  AddShoppingCartIcon,
  AddTaskIcon,
  AddToDriveIcon,
  AddToHomeScreenIcon,
  AddToPhotosIcon,
  AddToQueueIcon,
  AdfScannerIcon,
  AdjustIcon,
  AdminPanelSettingsIcon,
  AdobeIcon,
  AdsClickIcon,
  AgricultureIcon,
  AirIcon,
  AirlineSeatFlatAngledIcon,
  AirlineSeatFlatIcon,
  AirlineSeatIndividualSuiteIcon,
  AirlineSeatLegroomExtraIcon,
  AirlineSeatLegroomNormalIcon,
  AirlineSeatLegroomReducedIcon,
  AirlineSeatReclineExtraIcon,
  AirlineSeatReclineNormalIcon,
  AirlineStopsIcon,
  AirlinesIcon,
  AirplaneTicketIcon,
  AirplanemodeActiveIcon,
  AirplanemodeInactiveIcon,
  AirplanemodeOffIcon,
  AirplanemodeOnIcon,
  AirplayIcon,
  AirportShuttleIcon,
  AlarmAddIcon,
  AlarmIcon,
  AlarmOffIcon,
  AlarmOnIcon,
  AlbumIcon,
  Alert,
  AlignHorizontalCenterIcon,
  AlignHorizontalLeftIcon,
  AlignHorizontalRightIcon,
  AlignVerticalBottomIcon,
  AlignVerticalCenterIcon,
  AlignVerticalTopIcon,
  AllInboxIcon,
  AllInclusiveIcon,
  AllOutIcon,
  AltRouteIcon,
  AlternateEmailIcon,
  AmpStoriesIcon,
  AnalyticsIcon,
  AnchorIcon,
  AndroidIcon,
  AnimationIcon,
  AnnouncementIcon,
  AodIcon,
  ApartmentIcon,
  ApiIcon,
  AppBlockingIcon,
  AppRegistrationIcon,
  AppSettingsAltIcon,
  AppShortcutIcon,
  AppleIcon,
  ApprovalIcon,
  AppsIcon,
  AppsOutageIcon,
  ArchitectureIcon,
  ArchiveIcon,
  AreaChartIcon,
  ArrowBackIcon,
  ArrowBackIosIcon,
  ArrowBackIosNewIcon,
  ArrowCircleDownIcon,
  ArrowCircleLeftIcon,
  ArrowCircleRightIcon,
  ArrowCircleUpIcon,
  ArrowDownwardIcon,
  ArrowDropDownCircleIcon,
  ArrowDropDownIcon,
  ArrowDropUpIcon,
  ArrowForwardIcon,
  ArrowForwardIosIcon,
  ArrowLeftIcon,
  ArrowOutwardIcon,
  ArrowRightAltIcon,
  ArrowRightIcon,
  ArrowUpwardIcon,
  ArtTrackIcon,
  ArticleIcon,
  AspectRatioIcon,
  AssessmentIcon,
  AssignmentIcon,
  AssignmentIndIcon,
  AssignmentLateIcon,
  AssignmentReturnIcon,
  AssignmentReturnedIcon,
  AssignmentTurnedInIcon,
  AssistWalkerIcon,
  AssistantDirectionIcon,
  AssistantIcon,
  AssistantPhotoIcon,
  AssuredWorkloadIcon,
  AtmIcon,
  AttachEmailIcon,
  AttachFileIcon,
  AttachMoneyIcon,
  AttachmentIcon,
  AttractionsIcon,
  AttributionIcon,
  AudioFileIcon,
  AudiotrackIcon,
  AutoAwesomeIcon,
  AutoAwesomeMosaicIcon,
  AutoAwesomeMotionIcon,
  AutoDeleteIcon,
  AutoFixHighIcon,
  AutoFixNormalIcon,
  AutoFixOffIcon,
  AutoGraphIcon,
  AutoModeIcon,
  AutoStoriesIcon,
  Autocomplete,
  AutocompleteItem,
  AutofpsSelectIcon,
  AutorenewIcon,
  AvTimerIcon,
  Avatar,
  BabyChangingStationIcon,
  BackHandIcon,
  BackpackIcon,
  BackspaceIcon,
  BackupIcon,
  BackupTableIcon,
  Badge,
  BadgeIcon,
  BakeryDiningIcon,
  BalanceIcon,
  BalconyIcon,
  BallotIcon,
  BarChartIcon,
  BatchPredictionIcon,
  BathroomIcon,
  BathtubIcon,
  Battery0BarIcon,
  Battery1BarIcon,
  Battery2BarIcon,
  Battery3BarIcon,
  Battery4BarIcon,
  Battery5BarIcon,
  Battery6BarIcon,
  BatteryAlertIcon,
  BatteryChargingFullIcon,
  BatteryFullIcon,
  BatterySaverIcon,
  BatteryStdIcon,
  BatteryUnknownIcon,
  BeachAccessIcon,
  BedIcon,
  BedroomBabyIcon,
  BedroomChildIcon,
  BedroomParentIcon,
  BedtimeIcon,
  BedtimeOffIcon,
  BeenhereIcon,
  BentoIcon,
  BikeScooterIcon,
  BiotechIcon,
  BlenderIcon,
  BlindIcon,
  BlindsClosedIcon,
  BlindsIcon,
  BlockIcon,
  BloodtypeIcon,
  BluetoothAudioIcon,
  BluetoothConnectedIcon,
  BluetoothDisabledIcon,
  BluetoothDriveIcon,
  BluetoothIcon,
  BluetoothSearchingIcon,
  BlurCircularIcon,
  BlurLinearIcon,
  BlurOffIcon,
  BlurOnIcon,
  BoltIcon,
  BookIcon,
  BookOnlineIcon,
  BookmarkAddIcon,
  BookmarkAddedIcon,
  BookmarkBorderIcon,
  BookmarkIcon,
  BookmarkOutlineIcon,
  BookmarkRemoveIcon,
  BookmarksIcon,
  BooleanSwitch,
  BooleanSwitchWithLabel,
  BorderAllIcon,
  BorderBottomIcon,
  BorderClearIcon,
  BorderColorIcon,
  BorderHorizontalIcon,
  BorderInnerIcon,
  BorderLeftIcon,
  BorderOuterIcon,
  BorderRightIcon,
  BorderStyleIcon,
  BorderTopIcon,
  BorderVerticalIcon,
  BoyIcon,
  BrandingWatermarkIcon,
  BreakfastDiningIcon,
  Brightness1Icon,
  Brightness2Icon,
  Brightness3Icon,
  Brightness4Icon,
  Brightness5Icon,
  Brightness6Icon,
  Brightness7Icon,
  BrightnessAutoIcon,
  BrightnessHighIcon,
  BrightnessLowIcon,
  BrightnessMediumIcon,
  BroadcastOnHomeIcon,
  BroadcastOnPersonalIcon,
  BrokenImageIcon,
  BrowseGalleryIcon,
  BrowserNotSupportedIcon,
  BrowserUpdatedIcon,
  BrunchDiningIcon,
  BrushIcon,
  BubbleChartIcon,
  BugReportIcon,
  BuildCircleIcon,
  BuildIcon,
  BungalowIcon,
  BurstModeIcon,
  BusAlertIcon,
  BusinessCenterIcon,
  BusinessIcon,
  Button,
  CHIP_COLORS,
  CabinIcon,
  CableIcon,
  CachedIcon,
  CakeIcon,
  CalculateIcon,
  CalendarMonthIcon,
  CalendarTodayIcon,
  CalendarViewDayIcon,
  CalendarViewMonthIcon,
  CalendarViewWeekIcon,
  CallEndIcon,
  CallIcon,
  CallMadeIcon,
  CallMergeIcon,
  CallMissedIcon,
  CallMissedOutgoingIcon,
  CallReceivedIcon,
  CallSplitIcon,
  CallToActionIcon,
  CameraAltIcon,
  CameraEnhanceIcon,
  CameraFrontIcon,
  CameraIcon,
  CameraIndoorIcon,
  CameraOutdoorIcon,
  CameraRearIcon,
  CameraRollIcon,
  CameraswitchIcon,
  CampaignIcon,
  CancelIcon,
  CancelPresentationIcon,
  CancelScheduleSendIcon,
  CandlestickChartIcon,
  CarCrashIcon,
  CarRentalIcon,
  CarRepairIcon,
  Card,
  CardGiftcardIcon,
  CardMembershipIcon,
  CardTravelIcon,
  CarpenterIcon,
  CasesIcon,
  CasinoIcon,
  CastConnectedIcon,
  CastForEducationIcon,
  CastIcon,
  CastleIcon,
  CatchingPokemonIcon,
  CategoryIcon,
  CelebrationIcon,
  CellTowerIcon,
  CellWifiIcon,
  CenterFocusStrongIcon,
  CenterFocusWeakIcon,
  CenteredView,
  ChairAltIcon,
  ChairIcon,
  ChaletIcon,
  ChangeCircleIcon,
  ChangeHistoryIcon,
  ChargingStationIcon,
  ChatBubbleIcon,
  ChatBubbleOutlineIcon,
  ChatIcon,
  CheckBoxIcon,
  CheckBoxOutlineBlankIcon,
  CheckCircleIcon,
  CheckCircleOutlineIcon,
  CheckIcon,
  Checkbox,
  ChecklistIcon,
  ChecklistRtlIcon,
  CheckroomIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
  ChildCareIcon,
  ChildFriendlyIcon,
  Chip,
  ChromeReaderModeIcon,
  ChurchIcon,
  CircleIcon,
  CircleNotificationsIcon,
  CircularProgress,
  ClassIcon,
  CleanHandsIcon,
  CleaningServicesIcon,
  ClearAllIcon,
  ClearIcon,
  CloseFullscreenIcon,
  CloseIcon,
  ClosedCaptionDisabledIcon,
  ClosedCaptionIcon,
  ClosedCaptionOffIcon,
  CloudCircleIcon,
  CloudDoneIcon,
  CloudDownloadIcon,
  CloudIcon,
  CloudOffIcon,
  CloudQueueIcon,
  CloudSyncIcon,
  CloudUploadIcon,
  Co2Icon,
  CoPresentIcon,
  CodeIcon,
  CodeOffIcon,
  CoffeeIcon,
  CoffeeMakerIcon,
  Collapse,
  CollectionsBookmarkIcon,
  CollectionsIcon,
  ColorLensIcon,
  ColorizeIcon,
  CommentBankIcon,
  CommentIcon,
  CommentsDisabledIcon,
  CommitIcon,
  CommuteIcon,
  CompareArrowsIcon,
  CompareIcon,
  CompassCalibrationIcon,
  CompostIcon,
  CompressIcon,
  ComputerIcon,
  ConfirmationNumIcon,
  ConfirmationNumberIcon,
  ConnectWithoutContactIcon,
  ConnectedTvIcon,
  ConnectingAirportsIcon,
  ConstructionIcon,
  ContactEmergencyIcon,
  ContactMailIcon,
  ContactPageIcon,
  ContactPhoneIcon,
  ContactSupportIcon,
  ContactlessIcon,
  ContactsIcon,
  Container,
  ContentCopyIcon,
  ContentCutIcon,
  ContentPasteGoIcon,
  ContentPasteIcon,
  ContentPasteOffIcon,
  ContentPasteSearchIcon,
  ContrastIcon,
  ControlCameraIcon,
  ControlPointDuplicateIcon,
  ControlPointIcon,
  CookieIcon,
  CopyAllIcon,
  CopyIcon,
  CopyrightIcon,
  CoronavirusIcon,
  CorporateFareIcon,
  CottageIcon,
  CountertopsIcon,
  CreateIcon,
  CreateNewFolderIcon,
  CreditCardIcon,
  CreditCardOffIcon,
  CreditScoreIcon,
  CribIcon,
  CrisisAlertIcon,
  Crop169Icon,
  Crop32Icon,
  Crop54Icon,
  Crop75Icon,
  CropDinIcon,
  CropFreeIcon,
  CropIcon,
  CropLandscapeIcon,
  CropOriginalIcon,
  CropPortraitIcon,
  CropRotateIcon,
  CropSquareIcon,
  CrueltyFreeIcon,
  CssIcon,
  CurrencyBitcoinIcon,
  CurrencyExchangeIcon,
  CurrencyFrancIcon,
  CurrencyLiraIcon,
  CurrencyPoundIcon,
  CurrencyRubleIcon,
  CurrencyRupeeIcon,
  CurrencyYenIcon,
  CurrencyYuanIcon,
  CurtainsClosedIcon,
  CurtainsIcon,
  CutIcon,
  CycloneIcon,
  DangerousIcon,
  DarkModeIcon,
  DashboardCustomizeIcon,
  DashboardIcon,
  DataArrayIcon,
  DataExplorationIcon,
  DataObjectIcon,
  DataSaverOffIcon,
  DataSaverOnIcon,
  DataThresholdingIcon,
  DataUsageIcon,
  DatasetIcon,
  DatasetLinkedIcon,
  DateRangeIcon,
  DateTimeField,
  DeblurIcon,
  DebouncedTextField,
  DeckIcon,
  DehazeIcon,
  DeleteForeverIcon,
  DeleteIcon,
  DeleteOutlineIcon,
  DeleteSweepIcon,
  DeliveryDiningIcon,
  DensityLargeIcon,
  DensityMediumIcon,
  DensitySmallIcon,
  DepartureBoardIcon,
  DescriptionIcon,
  DeselectIcon,
  DesignServicesIcon,
  DeskIcon,
  DesktopAccessDisabledIcon,
  DesktopMacIcon,
  DesktopWindowsIcon,
  DetailsIcon,
  DeveloperBoardIcon,
  DeveloperBoardOffIcon,
  DeveloperModeIcon,
  DeviceHubIcon,
  DeviceThermostatIcon,
  DeviceUnknownIcon,
  DevicesFoldIcon,
  DevicesIcon,
  DevicesOtherIcon,
  DialerSipIcon,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  DialpadIcon,
  DiamondIcon,
  DifferenceIcon,
  DiningIcon,
  DinnerDiningIcon,
  DirectionsBikeIcon,
  DirectionsBoatFilledIcon,
  DirectionsBoatIcon,
  DirectionsBusFilledIcon,
  DirectionsBusIcon,
  DirectionsCarFilledIcon,
  DirectionsCarIcon,
  DirectionsFerryIcon,
  DirectionsIcon,
  DirectionsOffIcon,
  DirectionsRailwayFilledIcon,
  DirectionsRailwayIcon,
  DirectionsRunIcon,
  DirectionsSubwayFilledIcon,
  DirectionsSubwayIcon,
  DirectionsTrainIcon,
  DirectionsTransitFilledIcon,
  DirectionsTransitIcon,
  DirectionsWalkIcon,
  DirtyLensIcon,
  DisabledByDefaultIcon,
  DisabledVisibleIcon,
  DiscFullIcon,
  DiscordIcon,
  DiscountIcon,
  DisplaySettingsIcon,
  Diversity1Icon,
  Diversity2Icon,
  Diversity3Icon,
  DndForwardslashIcon,
  DnsIcon,
  DoDisturbAltIcon,
  DoDisturbIcon,
  DoDisturbOffIcon,
  DoDisturbOnIcon,
  DoNotDisturbAltIcon,
  DoNotDisturbIcon,
  DoNotDisturbOffIcon,
  DoNotDisturbOnIcon,
  DoNotDisturbOnTotalSilenceIcon,
  DoNotStepIcon,
  DoNotTouchIcon,
  DockIcon,
  DocumentScannerIcon,
  DomainAddIcon,
  DomainDisabledIcon,
  DomainIcon,
  DomainVerificationIcon,
  DoneAllIcon,
  DoneIcon,
  DoneOutlineIcon,
  DonutLargeIcon,
  DonutSmallIcon,
  DoorBackIcon,
  DoorFrontIcon,
  DoorSlidingIcon,
  DoorbellIcon,
  DoubleArrowIcon,
  DownhillSkiingIcon,
  DownloadDoneIcon,
  DownloadForOfflineIcon,
  DownloadIcon,
  DownloadingIcon,
  DraftsIcon,
  DragHandleIcon,
  DragIndicatorIcon,
  DrawIcon,
  DriveEtaIcon,
  DriveFileMoveIcon,
  DriveFileMoveRtlIcon,
  DriveFileRenameOutlineIcon,
  DriveFolderUploadIcon,
  DryCleaningIcon,
  DryIcon,
  DuoIcon,
  DvrIcon,
  DynamicFeedIcon,
  DynamicFormIcon,
  EMobiledataIcon,
  EarbudsBatteryIcon,
  EarbudsIcon,
  EastIcon,
  EcoIcon,
  EdgesensorHighIcon,
  EdgesensorLowIcon,
  EditAttributesIcon,
  EditCalendarIcon,
  EditIcon,
  EditLocationAltIcon,
  EditLocationIcon,
  EditNoteIcon,
  EditNotificationsIcon,
  EditOffIcon,
  EditRoadIcon,
  EggAltIcon,
  EggIcon,
  EjectIcon,
  ElderlyIcon,
  ElderlyWomanIcon,
  ElectricBikeIcon,
  ElectricBoltIcon,
  ElectricCarIcon,
  ElectricMeterIcon,
  ElectricMopedIcon,
  ElectricRickshawIcon,
  ElectricScooterIcon,
  ElectricalServicesIcon,
  ElevatorIcon,
  EmailIcon,
  EmergencyIcon,
  EmergencyRecordingIcon,
  EmergencyShareIcon,
  EmojiEmotionsIcon,
  EmojiEventsIcon,
  EmojiFlagsIcon,
  EmojiFoodBeverageIcon,
  EmojiNatureIcon,
  EmojiObjectsIcon,
  EmojiPeopleIcon,
  EmojiSymbolsIcon,
  EmojiTransportationIcon,
  EnergySavingsLeafIcon,
  EngineeringIcon,
  EnhancePhotoTranslateIcon,
  EnhancedEncryptionIcon,
  EqualizerIcon,
  ErrorIcon,
  ErrorOutlineIcon,
  EscalatorIcon,
  EscalatorWarningIcon,
  EuroIcon,
  EuroSymbolIcon,
  EvStationIcon,
  EventAvailableIcon,
  EventBusyIcon,
  EventIcon,
  EventNoteIcon,
  EventRepeatIcon,
  EventSeatIcon,
  ExitToAppIcon,
  ExpandCircleDownIcon,
  ExpandIcon,
  ExpandLessIcon,
  ExpandMoreIcon,
  ExpandablePanel,
  ExplicitIcon,
  ExploreIcon,
  ExploreOffIcon,
  ExposureIcon,
  ExposureMinus1Icon,
  ExposureMinus2Icon,
  ExposureNeg1Icon,
  ExposureNeg2Icon,
  ExposurePlus1Icon,
  ExposurePlus2Icon,
  ExposureZeroIcon,
  ExtensionIcon,
  ExtensionOffIcon,
  Face2Icon,
  Face3Icon,
  Face4Icon,
  Face5Icon,
  Face6Icon,
  FaceIcon,
  FaceRetouchingNaturalIcon,
  FaceRetouchingOffIcon,
  FaceUnlockIcon,
  FacebookIcon,
  FactCheckIcon,
  FactoryIcon,
  FamilyRestroomIcon,
  FastForwardIcon,
  FastRewindIcon,
  FastfoodIcon,
  FavoriteBorderIcon,
  FavoriteIcon,
  FavoriteOutlineIcon,
  FaxIcon,
  FeaturedPlayListIcon,
  FeaturedVideoIcon,
  FeedIcon,
  FeedbackIcon,
  FemaleIcon,
  FenceIcon,
  FestivalIcon,
  FiberDvrIcon,
  FiberManualRecordIcon,
  FiberNewIcon,
  FiberPinIcon,
  FiberSmartRecordIcon,
  FileCopyIcon,
  FileDownloadDoneIcon,
  FileDownloadIcon,
  FileDownloadOffIcon,
  FileOpenIcon,
  FilePresentIcon,
  FileUpload,
  FileUploadIcon,
  Filter1Icon,
  Filter2Icon,
  Filter3Icon,
  Filter4Icon,
  Filter5Icon,
  Filter6Icon,
  Filter7Icon,
  Filter8Icon,
  Filter9Icon,
  Filter9PlusIcon,
  FilterAltIcon,
  FilterAltOffIcon,
  FilterBAndWIcon,
  FilterCenterFocusIcon,
  FilterDramaIcon,
  FilterFramesIcon,
  FilterHdrIcon,
  FilterIcon,
  FilterListIcon,
  FilterListOffIcon,
  FilterNoneIcon,
  FilterTiltShiftIcon,
  FilterVintageIcon,
  FindInPageIcon,
  FindReplaceIcon,
  FingerprintIcon,
  FireExtinguisherIcon,
  FireHydrantAltIcon,
  FireTruckIcon,
  FireplaceIcon,
  FirstPageIcon,
  FitScreenIcon,
  FitbitIcon,
  FitnessCenterIcon,
  FlagCircleIcon,
  FlagIcon,
  FlakyIcon,
  FlareIcon,
  FlashAutoIcon,
  FlashOffIcon,
  FlashOnIcon,
  FlashlightOffIcon,
  FlashlightOnIcon,
  FlatwareIcon,
  FlightClassIcon,
  FlightIcon,
  FlightLandIcon,
  FlightTakeoffIcon,
  FlipCameraAndroidIcon,
  FlipCameraIosIcon,
  FlipIcon,
  FlipToBackIcon,
  FlipToFrontIcon,
  FloodIcon,
  FlourescentIcon,
  FluorescentIcon,
  FlutterDashIcon,
  FmdBadIcon,
  FmdGoodIcon,
  FolderCopyIcon,
  FolderDeleteIcon,
  FolderIcon,
  FolderOffIcon,
  FolderOpenIcon,
  FolderSharedIcon,
  FolderSpecialIcon,
  FolderZipIcon,
  FollowTheSignsIcon,
  FontDownloadIcon,
  FontDownloadOffIcon,
  FoodBankIcon,
  ForestIcon,
  ForkLeftIcon,
  ForkRightIcon,
  FormatAlignCenterIcon,
  FormatAlignJustifyIcon,
  FormatAlignLeftIcon,
  FormatAlignRightIcon,
  FormatBoldIcon,
  FormatClearIcon,
  FormatColorFillIcon,
  FormatColorResetIcon,
  FormatColorTextIcon,
  FormatIndentDecreaseIcon,
  FormatIndentIncreaseIcon,
  FormatItalicIcon,
  FormatLineSpacingIcon,
  FormatListBulletedIcon,
  FormatListNumberedIcon,
  FormatListNumberedRtlIcon,
  FormatOverlineIcon,
  FormatPaintIcon,
  FormatQuoteIcon,
  FormatShapesIcon,
  FormatSizeIcon,
  FormatStrikethroughIcon,
  FormatTextdirectionLToRIcon,
  FormatTextdirectionRToLIcon,
  FormatUnderlineIcon,
  FormatUnderlinedIcon,
  FortIcon,
  ForumIcon,
  Forward10Icon,
  Forward30Icon,
  Forward5Icon,
  ForwardIcon,
  ForwardToInboxIcon,
  FoundationIcon,
  FreeBreakfastIcon,
  FreeCancellationIcon,
  FrontHandIcon,
  FullscreenExitIcon,
  FullscreenIcon,
  FunctionsIcon,
  GMobiledataIcon,
  GTranslateIcon,
  GamepadIcon,
  GamesIcon,
  GarageIcon,
  GasMeterIcon,
  GavelIcon,
  GeneratingTokensIcon,
  GestureIcon,
  GetAppIcon,
  GifBoxIcon,
  GifIcon,
  GirlIcon,
  GitHubIcon,
  GiteIcon,
  GolfCourseIcon,
  GppBadIcon,
  GppGoodIcon,
  GppMaybeIcon,
  GpsFixedIcon,
  GpsNotFixedIcon,
  GpsOffIcon,
  GradeIcon,
  GradientIcon,
  GradingIcon,
  GrainIcon,
  GraphicEqIcon,
  GrassIcon,
  Grid3x3Icon,
  Grid4x4Icon,
  GridGoldenratioIcon,
  GridOffIcon,
  GridOnIcon,
  GridViewIcon,
  GroupAddIcon,
  GroupIcon,
  GroupOffIcon,
  GroupRemoveIcon,
  GroupWorkIcon,
  Groups2Icon,
  Groups3Icon,
  GroupsIcon,
  HMobiledataIcon,
  HPlusMobiledataIcon,
  HailIcon,
  HandleIcon,
  HandshakeIcon,
  HandymanIcon,
  HardwareIcon,
  HdIcon,
  HdrAutoIcon,
  HdrAutoSelectIcon,
  HdrEnhancedSelectIcon,
  HdrOffIcon,
  HdrOffSelectIcon,
  HdrOnIcon,
  HdrOnSelectIcon,
  HdrPlusIcon,
  HdrStrongIcon,
  HdrWeakIcon,
  HeadphonesBatteryIcon,
  HeadphonesIcon,
  HeadsetIcon,
  HeadsetMicIcon,
  HeadsetOffIcon,
  HealingIcon,
  HealthAndSafetyIcon,
  HearingDisabledIcon,
  HearingIcon,
  HeartBrokenIcon,
  HeatPumpIcon,
  HeightIcon,
  HelpCenterIcon,
  HelpIcon,
  HelpOutlineIcon,
  HevcIcon,
  HexagonIcon,
  HideImageIcon,
  HideSourceIcon,
  HighQualityIcon,
  HighlightAltIcon,
  HighlightIcon,
  HighlightOffIcon,
  HighlightRemoveIcon,
  HikingIcon,
  HistoryEduIcon,
  HistoryIcon,
  HistoryToggleOffIcon,
  HiveIcon,
  HlsIcon,
  HlsOffIcon,
  HolidayVillageIcon,
  HomeIcon,
  HomeMaxIcon,
  HomeMiniIcon,
  HomeRepairServiceIcon,
  HomeWorkIcon,
  HorizontalDistributeIcon,
  HorizontalRuleIcon,
  HorizontalSplitIcon,
  HotTubIcon,
  HotelClassIcon,
  HotelIcon,
  HourglassBottomIcon,
  HourglassDisabledIcon,
  HourglassEmptyIcon,
  HourglassFullIcon,
  HourglassTopIcon,
  HouseIcon,
  HouseSidingIcon,
  HouseboatIcon,
  HowToRegIcon,
  HowToVoteIcon,
  HtmlIcon,
  HttpIcon,
  HttpsIcon,
  HubIcon,
  HvacIcon,
  IceSkatingIcon,
  IcecreamIcon,
  Icon,
  IconButton,
  ImageAspectRatioIcon,
  ImageIcon,
  ImageNotSupportedIcon,
  ImageSearchIcon,
  ImagesearchRollerIcon,
  ImportContactsIcon,
  ImportExportIcon,
  ImportantDevicesIcon,
  InboxIcon,
  IncompleteCircleIcon,
  IndeterminateCheckBoxIcon,
  InfoIcon,
  InfoLabel,
  InfoOutlineIcon,
  InputIcon,
  InputLabel,
  InsertChartIcon,
  InsertChartOutlinedIcon,
  InsertCommentIcon,
  InsertDriveFileIcon,
  InsertEmoticonIcon,
  InsertInvitationIcon,
  InsertLinkIcon,
  InsertPageBreakIcon,
  InsertPhotoIcon,
  InsightsIcon,
  InstallDesktopIcon,
  InstallMobileIcon,
  IntegrationInstructionsIcon,
  InterestsIcon,
  InterpreterModeIcon,
  Inventory2Icon,
  InventoryIcon,
  InvertColorsIcon,
  InvertColorsOffIcon,
  InvertColorsOnIcon,
  IosShareIcon,
  IronIcon,
  IsoIcon,
  JavascriptIcon,
  JoinFullIcon,
  JoinInnerIcon,
  JoinLeftIcon,
  JoinRightIcon,
  KayakingIcon,
  KebabDiningIcon,
  KeyIcon,
  KeyOffIcon,
  KeyboardAltIcon,
  KeyboardArrowDownIcon,
  KeyboardArrowLeftIcon,
  KeyboardArrowRightIcon,
  KeyboardArrowUpIcon,
  KeyboardBackspaceIcon,
  KeyboardCapslockIcon,
  KeyboardCommandKeyIcon,
  KeyboardControlIcon,
  KeyboardControlKeyIcon,
  KeyboardDoubleArrowDownIcon,
  KeyboardDoubleArrowLeftIcon,
  KeyboardDoubleArrowRightIcon,
  KeyboardDoubleArrowUpIcon,
  KeyboardHideIcon,
  KeyboardIcon,
  KeyboardOptionKeyIcon,
  KeyboardReturnIcon,
  KeyboardTabIcon,
  KeyboardVoiceIcon,
  KingBedIcon,
  KitchenIcon,
  KitesurfingIcon,
  Label,
  LabelIcon,
  LabelImportantIcon,
  LabelImportantOutlineIcon,
  LabelOffIcon,
  LabelOutlineIcon,
  LanIcon,
  LandscapeIcon,
  LandslideIcon,
  LanguageIcon,
  LaptopChromebookIcon,
  LaptopIcon,
  LaptopMacIcon,
  LaptopWindowsIcon,
  LastPageIcon,
  LaunchIcon,
  LayersClearIcon,
  LayersIcon,
  LeaderboardIcon,
  LeakAddIcon,
  LeakRemoveIcon,
  LeaveBagsAtHomeIcon,
  LegendToggleIcon,
  LensBlurIcon,
  LensIcon,
  LibraryAddCheckIcon,
  LibraryAddIcon,
  LibraryBooksIcon,
  LibraryMusicIcon,
  LightIcon,
  LightModeIcon,
  LightbulbCircleIcon,
  LightbulbIcon,
  LightbulbOutlineIcon,
  LineAxisIcon,
  LineStyleIcon,
  LineWeightIcon,
  LinearScaleIcon,
  LinkIcon,
  LinkOffIcon,
  LinkedCameraIcon,
  LiquorIcon,
  ListAltIcon,
  ListIcon,
  LiveHelpIcon,
  LiveTvIcon,
  LivingIcon,
  LoadingButton,
  LocalActivityIcon,
  LocalAirportIcon,
  LocalAtmIcon,
  LocalAttractionIcon,
  LocalBarIcon,
  LocalCafeIcon,
  LocalCarWashIcon,
  LocalConvenienceStoreIcon,
  LocalDiningIcon,
  LocalDrinkIcon,
  LocalFireDepartmentIcon,
  LocalFloristIcon,
  LocalGasStationIcon,
  LocalGroceryStoreIcon,
  LocalHospitalIcon,
  LocalHotelIcon,
  LocalLaundryServiceIcon,
  LocalLibraryIcon,
  LocalMallIcon,
  LocalMoviesIcon,
  LocalOfferIcon,
  LocalParkingIcon,
  LocalPharmacyIcon,
  LocalPhoneIcon,
  LocalPizzaIcon,
  LocalPlayIcon,
  LocalPoliceIcon,
  LocalPostOfficeIcon,
  LocalPrintshopIcon,
  LocalRestaurantIcon,
  LocalSeeIcon,
  LocalShippingIcon,
  LocalTaxiIcon,
  LocationCityIcon,
  LocationDisabledIcon,
  LocationHistoryIcon,
  LocationOffIcon,
  LocationOnIcon,
  LocationSearchingIcon,
  LockClockIcon,
  LockIcon,
  LockOpenIcon,
  LockOutlineIcon,
  LockPersonIcon,
  LockResetIcon,
  LoginIcon,
  LogoDevIcon,
  LogoutIcon,
  Looks3Icon,
  Looks4Icon,
  Looks5Icon,
  Looks6Icon,
  LooksIcon,
  LooksOneIcon,
  LooksTwoIcon,
  LoopIcon,
  LoupeIcon,
  LowPriorityIcon,
  LoyaltyIcon,
  LteMobiledataIcon,
  LtePlusMobiledataIcon,
  LuggageIcon,
  LunchDiningIcon,
  LyricsIcon,
  MacroOffIcon,
  MailIcon,
  MailLockIcon,
  MailOutlineIcon,
  MaleIcon,
  Man2Icon,
  Man3Icon,
  Man4Icon,
  ManIcon,
  ManageAccountsIcon,
  ManageHistoryIcon,
  ManageSearchIcon,
  MapIcon,
  MapsHomeWorkIcon,
  MapsUgcIcon,
  MarginIcon,
  MarkAsUnreadIcon,
  MarkChatReadIcon,
  MarkChatUnreadIcon,
  MarkEmailReadIcon,
  MarkEmailUnreadIcon,
  MarkUnreadChatAltIcon,
  Markdown,
  MarkunreadIcon,
  MarkunreadMailboxIcon,
  MasksIcon,
  MaximizeIcon,
  MediaBluetoothOffIcon,
  MediaBluetoothOnIcon,
  MediationIcon,
  MedicalInformationIcon,
  MedicalServicesIcon,
  MedicationIcon,
  MedicationLiquidIcon,
  MeetingRoomIcon,
  MemoryIcon,
  Menu,
  MenuBookIcon,
  MenuIcon,
  MenuItem,
  MenuOpenIcon,
  Menubar,
  MenubarCheckboxItem,
  MenubarContent,
  MenubarItem,
  MenubarItemIndicator,
  MenubarMenu,
  MenubarPortal,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarSeparator,
  MenubarShortcut,
  MenubarSub,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarSubTriggerIndicator,
  MenubarTrigger,
  MergeIcon,
  MergeTypeIcon,
  MessageIcon,
  MessengerIcon,
  MessengerOutlineIcon,
  MicExternalOffIcon,
  MicExternalOnIcon,
  MicIcon,
  MicNoneIcon,
  MicOffIcon,
  MicrowaveIcon,
  MilitaryTechIcon,
  MinimizeIcon,
  MinorCrashIcon,
  MiscellaneousServicesIcon,
  MissedVideoCallIcon,
  MmsIcon,
  MobileFriendlyIcon,
  MobileOffIcon,
  MobileScreenShareIcon,
  MobiledataOffIcon,
  ModeCommentIcon,
  ModeEditIcon,
  ModeEditOutlineIcon,
  ModeFanOffIcon,
  ModeIcon,
  ModeNightIcon,
  ModeOfTravelIcon,
  ModeStandbyIcon,
  ModelTrainingIcon,
  MonetizationOnIcon,
  MoneyIcon,
  MoneyOffCsredIcon,
  MoneyOffIcon,
  MonitorHeartIcon,
  MonitorIcon,
  MonitorWeightIcon,
  MonochromePhotosIcon,
  MoodBadIcon,
  MoodIcon,
  MopedIcon,
  MoreHorizIcon,
  MoreIcon,
  MoreTimeIcon,
  MoreVertIcon,
  MosqueIcon,
  MotionPhotosAutoIcon,
  MotionPhotosOffIcon,
  MotionPhotosOnIcon,
  MotionPhotosPauseIcon,
  MotionPhotosPausedIcon,
  MotorcycleIcon,
  MouseIcon,
  MoveDownIcon,
  MoveToInboxIcon,
  MoveUpIcon,
  MovieCreationIcon,
  MovieFilterIcon,
  MovieIcon,
  MovingIcon,
  MpIcon,
  MultiSelect,
  MultiSelectContext,
  MultiSelectItem,
  MultilineChartIcon,
  MultipleStopIcon,
  MultitrackAudioIcon,
  MuseumIcon,
  MusicNoteIcon,
  MusicOffIcon,
  MusicVideoIcon,
  MyLibraryAddIcon,
  MyLibraryBooksIcon,
  MyLibraryMusicIcon,
  MyLocationIcon,
  NatIcon,
  NatureIcon,
  NaturePeopleIcon,
  NavigateBeforeIcon,
  NavigateNextIcon,
  NavigationIcon,
  NearMeDisabledIcon,
  NearMeIcon,
  NearbyErrorIcon,
  NearbyOffIcon,
  NestCamWiredStandIcon,
  NetworkCellIcon,
  NetworkCheckIcon,
  NetworkLockedIcon,
  NetworkPingIcon,
  NetworkWifi1BarIcon,
  NetworkWifi2BarIcon,
  NetworkWifi3BarIcon,
  NetworkWifiIcon,
  NewLabelIcon,
  NewReleasesIcon,
  NewspaperIcon,
  NextPlanIcon,
  NextWeekIcon,
  NfcIcon,
  NightShelterIcon,
  NightlifeIcon,
  NightlightIcon,
  NightlightRoundIcon,
  NightsStayIcon,
  NoAccountsIcon,
  NoAdultContentIcon,
  NoBackpackIcon,
  NoCellIcon,
  NoCrashIcon,
  NoDrinksIcon,
  NoEncryptionGmailerrorredIcon,
  NoEncryptionIcon,
  NoFlashIcon,
  NoFoodIcon,
  NoLuggageIcon,
  NoMealsIcon,
  NoMeetingRoomIcon,
  NoPhotographyIcon,
  NoSimIcon,
  NoStrollerIcon,
  NoTransferIcon,
  NoiseAwareIcon,
  NoiseControlOffIcon,
  NordicWalkingIcon,
  NorthEastIcon,
  NorthIcon,
  NorthWestIcon,
  NotAccessibleIcon,
  NotInterestedIcon,
  NotListedLocationIcon,
  NotStartedIcon,
  NoteAddIcon,
  NoteAltIcon,
  NoteIcon,
  NotesIcon,
  NotificationAddIcon,
  NotificationImportantIcon,
  NotificationsActiveIcon,
  NotificationsIcon,
  NotificationsNoneIcon,
  NotificationsOffIcon,
  NotificationsOnIcon,
  NotificationsPausedIcon,
  NowWallpaperIcon,
  NowWidgetsIcon,
  NumbersIcon,
  OfflineBoltIcon,
  OfflinePinIcon,
  OfflineShareIcon,
  OilBarrelIcon,
  OnDeviceTrainingIcon,
  OndemandVideoIcon,
  OnlinePredictionIcon,
  OpacityIcon,
  OpenInBrowserIcon,
  OpenInFullIcon,
  OpenInNewIcon,
  OpenInNewOffIcon,
  OpenWithIcon,
  OtherHousesIcon,
  OutbondIcon,
  OutboundIcon,
  OutboxIcon,
  OutdoorGrillIcon,
  OutletIcon,
  OutlinedFlagIcon,
  OutputIcon,
  PaddingIcon,
  PagesIcon,
  PageviewIcon,
  PaidIcon,
  PaletteIcon,
  PanToolAltIcon,
  PanToolIcon,
  PanoramaFisheyeIcon,
  PanoramaHorizontalIcon,
  PanoramaHorizontalSelectIcon,
  PanoramaIcon,
  PanoramaPhotosphereIcon,
  PanoramaPhotosphereSelectIcon,
  PanoramaVerticalIcon,
  PanoramaVerticalSelectIcon,
  PanoramaWideAngleIcon,
  PanoramaWideAngleSelectIcon,
  Paper,
  ParaglidingIcon,
  ParkIcon,
  PartyModeIcon,
  PasswordIcon,
  PasteIcon,
  PatternIcon,
  PauseCircleFilledIcon,
  PauseCircleIcon,
  PauseCircleOutlineIcon,
  PauseIcon,
  PausePresentationIcon,
  PaymentIcon,
  PaymentsIcon,
  PaypalIcon,
  PedalBikeIcon,
  PendingActionsIcon,
  PendingIcon,
  PentagonIcon,
  PeopleAltIcon,
  PeopleIcon,
  PeopleOutlineIcon,
  PercentIcon,
  PermCameraMicIcon,
  PermContactCalIcon,
  PermContactCalendarIcon,
  PermDataSettingIcon,
  PermDeviceInfoIcon,
  PermDeviceInformationIcon,
  PermIdentityIcon,
  PermMediaIcon,
  PermPhoneMsgIcon,
  PermScanWifiIcon,
  Person2Icon,
  Person3Icon,
  Person4Icon,
  PersonAddAlt1Icon,
  PersonAddAltIcon,
  PersonAddDisabledIcon,
  PersonAddIcon,
  PersonIcon,
  PersonOffIcon,
  PersonOutlineIcon,
  PersonPinCircleIcon,
  PersonPinIcon,
  PersonRemoveAlt1Icon,
  PersonRemoveIcon,
  PersonSearchIcon,
  PersonalInjuryIcon,
  PersonalVideoIcon,
  PestControlIcon,
  PestControlRodentIcon,
  PetsIcon,
  PhishingIcon,
  PhoneAndroidIcon,
  PhoneBluetoothSpeakerIcon,
  PhoneCallbackIcon,
  PhoneDisabledIcon,
  PhoneEnabledIcon,
  PhoneForwardedIcon,
  PhoneIcon,
  PhoneInTalkIcon,
  PhoneIphoneIcon,
  PhoneLockedIcon,
  PhoneMissedIcon,
  PhonePausedIcon,
  PhonelinkEraseIcon,
  PhonelinkIcon,
  PhonelinkLockIcon,
  PhonelinkOffIcon,
  PhonelinkRingIcon,
  PhonelinkSetupIcon,
  PhotoAlbumIcon,
  PhotoCameraBackIcon,
  PhotoCameraFrontIcon,
  PhotoCameraIcon,
  PhotoFilterIcon,
  PhotoIcon,
  PhotoLibraryIcon,
  PhotoSizeSelectActualIcon,
  PhotoSizeSelectLargeIcon,
  PhotoSizeSelectSmallIcon,
  PhpIcon,
  PianoIcon,
  PianoOffIcon,
  PictureAsPdfIcon,
  PictureInPictureAltIcon,
  PictureInPictureIcon,
  PieChartIcon,
  PieChartOutlineIcon,
  PinDropIcon,
  PinEndIcon,
  PinIcon,
  PinInvokeIcon,
  PinchIcon,
  PivotTableChartIcon,
  PixIcon,
  PlaceIcon,
  PlagiarismIcon,
  PlayArrowIcon,
  PlayCircleFillIcon,
  PlayCircleFilledIcon,
  PlayCircleIcon,
  PlayCircleOutlineIcon,
  PlayDisabledIcon,
  PlayForWorkIcon,
  PlayLessonIcon,
  PlaylistAddCheckCircleIcon,
  PlaylistAddCheckIcon,
  PlaylistAddCircleIcon,
  PlaylistAddIcon,
  PlaylistPlayIcon,
  PlaylistRemoveIcon,
  PlumbingIcon,
  PlusOneIcon,
  PodcastsIcon,
  PointOfSaleIcon,
  PolicyIcon,
  PollIcon,
  PolylineIcon,
  PolymerIcon,
  PoolIcon,
  Popover,
  PortableWifiOffIcon,
  PortraitIcon,
  PostAddIcon,
  PowerIcon,
  PowerInputIcon,
  PowerOffIcon,
  PowerSettingsNewIcon,
  PrecisionManufacturingIcon,
  PregnantWomanIcon,
  PresentToAllIcon,
  PreviewIcon,
  PriceChangeIcon,
  PriceCheckIcon,
  PrintDisabledIcon,
  PrintIcon,
  PriorityHighIcon,
  PrivacyTipIcon,
  PrivateConnectivityIcon,
  ProductionQuantityLimitsIcon,
  PropaneIcon,
  PropaneTankIcon,
  PsychologyAltIcon,
  PsychologyIcon,
  PublicIcon,
  PublicOffIcon,
  PublishIcon,
  PublishedWithChangesIcon,
  PunchClockIcon,
  PushPinIcon,
  QrCode2Icon,
  QrCodeIcon,
  QrCodeScannerIcon,
  QueryBuilderIcon,
  QueryStatsIcon,
  QuestionAnswerIcon,
  QuestionMarkIcon,
  QueueIcon,
  QueueMusicIcon,
  QueuePlayNextIcon,
  QuickContactsDialerIcon,
  QuickContactsMailIcon,
  QuickreplyIcon,
  QuizIcon,
  QuoraIcon,
  RMobiledataIcon,
  RadarIcon,
  RadioButtonCheckedIcon,
  RadioButtonOffIcon,
  RadioButtonOnIcon,
  RadioButtonUncheckedIcon,
  RadioGroup,
  RadioGroupItem,
  RadioIcon,
  RailwayAlertIcon,
  RamenDiningIcon,
  RampLeftIcon,
  RampRightIcon,
  RateReviewIcon,
  RawOffIcon,
  RawOnIcon,
  ReadMoreIcon,
  RealEstateAgentIcon,
  ReceiptIcon,
  ReceiptLongIcon,
  RecentActorsIcon,
  RecommendIcon,
  RecordVoiceOverIcon,
  RectangleIcon,
  RecyclingIcon,
  RedditIcon,
  RedeemIcon,
  RedoIcon,
  ReduceCapacityIcon,
  RefreshIcon,
  RememberMeIcon,
  RemoveCircleIcon,
  RemoveCircleOutlineIcon,
  RemoveDoneIcon,
  RemoveFromQueueIcon,
  RemoveIcon,
  RemoveModeratorIcon,
  RemoveRedEyeIcon,
  RemoveRoadIcon,
  RemoveShoppingCartIcon,
  ReorderIcon,
  RepartitionIcon,
  RepeatIcon,
  RepeatOnIcon,
  RepeatOneIcon,
  RepeatOneOnIcon,
  Replay10Icon,
  Replay30Icon,
  Replay5Icon,
  ReplayCircleFilledIcon,
  ReplayIcon,
  ReplyAllIcon,
  ReplyIcon,
  ReportGmailerrorredIcon,
  ReportIcon,
  ReportOffIcon,
  ReportProblemIcon,
  RequestPageIcon,
  RequestQuoteIcon,
  ResetTvIcon,
  RestartAltIcon,
  RestaurantIcon,
  RestaurantMenuIcon,
  RestoreFromTrashIcon,
  RestoreIcon,
  RestorePageIcon,
  ReviewsIcon,
  RiceBowlIcon,
  RingVolumeIcon,
  RocketIcon,
  RocketLaunchIcon,
  RollerShadesClosedIcon,
  RollerShadesIcon,
  RollerSkatingIcon,
  RoofingIcon,
  RoomIcon,
  RoomPreferencesIcon,
  RoomServiceIcon,
  Rotate90DegreesCcwIcon,
  Rotate90DegreesCwIcon,
  RotateLeftIcon,
  RotateRightIcon,
  RoundaboutLeftIcon,
  RoundaboutRightIcon,
  RoundedCornerIcon,
  RouteIcon,
  RouterIcon,
  RowingIcon,
  RssFeedIcon,
  RsvpIcon,
  RttIcon,
  RuleFolderIcon,
  RuleIcon,
  RunCircleIcon,
  RunningWithErrorsIcon,
  RvHookupIcon,
  SafetyCheckIcon,
  SafetyDividerIcon,
  SailingIcon,
  SanitizerIcon,
  SatelliteAltIcon,
  SatelliteIcon,
  SaveAltIcon,
  SaveAsIcon,
  SaveIcon,
  SavedSearchIcon,
  SavingsIcon,
  ScaleIcon,
  ScannerIcon,
  ScatterPlotIcon,
  ScheduleIcon,
  ScheduleSendIcon,
  SchemaIcon,
  SchoolIcon,
  ScienceIcon,
  ScoreIcon,
  ScoreboardIcon,
  ScreenLockLandscapeIcon,
  ScreenLockPortraitIcon,
  ScreenLockRotationIcon,
  ScreenRotationAltIcon,
  ScreenRotationIcon,
  ScreenSearchDesktopIcon,
  ScreenShareIcon,
  ScreenshotIcon,
  ScreenshotMonitorIcon,
  ScubaDivingIcon,
  SdCardAlertIcon,
  SdCardIcon,
  SdIcon,
  SdStorageIcon,
  SearchBar,
  SearchIcon,
  SearchOffIcon,
  SecurityIcon,
  SecurityUpdateGoodIcon,
  SecurityUpdateIcon,
  SecurityUpdateWarningIcon,
  SegmentIcon,
  Select,
  SelectAllIcon,
  SelectGroup,
  SelectItem,
  SelfImprovementIcon,
  SellIcon,
  SendAndArchiveIcon,
  SendIcon,
  SendTimeExtensionIcon,
  SendToMobileIcon,
  SensorDoorIcon,
  SensorOccupiedIcon,
  SensorWindowIcon,
  SensorsIcon,
  SensorsOffIcon,
  SentimentDissatisfiedIcon,
  SentimentNeutralIcon,
  SentimentSatisfiedAltIcon,
  SentimentSatisfiedIcon,
  SentimentVeryDissatisfiedIcon,
  SentimentVerySatisfiedIcon,
  Separator,
  SetMealIcon,
  SettingsAccessibilityIcon,
  SettingsApplicationsIcon,
  SettingsBackupRestoreIcon,
  SettingsBluetoothIcon,
  SettingsBrightnessIcon,
  SettingsCellIcon,
  SettingsDisplayIcon,
  SettingsEthernetIcon,
  SettingsIcon,
  SettingsInputAntennaIcon,
  SettingsInputComponentIcon,
  SettingsInputCompositeIcon,
  SettingsInputHdmiIcon,
  SettingsInputSvideoIcon,
  SettingsOverscanIcon,
  SettingsPhoneIcon,
  SettingsPowerIcon,
  SettingsRemoteIcon,
  SettingsSuggestIcon,
  SettingsSystemDaydreamIcon,
  SettingsVoiceIcon,
  SevereColdIcon,
  ShapeLineIcon,
  ShareArrivalTimeIcon,
  ShareIcon,
  ShareLocationIcon,
  Sheet,
  ShieldIcon,
  ShieldMoonIcon,
  Shop2Icon,
  ShopIcon,
  ShopTwoIcon,
  ShopifyIcon,
  ShoppingBagIcon,
  ShoppingBasketIcon,
  ShoppingCartCheckoutIcon,
  ShoppingCartIcon,
  ShortTextIcon,
  ShortcutIcon,
  ShowChartIcon,
  ShowerIcon,
  ShuffleIcon,
  ShuffleOnIcon,
  ShutterSpeedIcon,
  SickIcon,
  SignLanguageIcon,
  SignalCellular0BarIcon,
  SignalCellular4BarIcon,
  SignalCellularAlt1BarIcon,
  SignalCellularAlt2BarIcon,
  SignalCellularAltIcon,
  SignalCellularConnectedNoInternet0BarIcon,
  SignalCellularConnectedNoInternet4BarIcon,
  SignalCellularNoSimIcon,
  SignalCellularNodataIcon,
  SignalCellularNullIcon,
  SignalCellularOffIcon,
  SignalWifi0BarIcon,
  SignalWifi4BarIcon,
  SignalWifi4BarLockIcon,
  SignalWifiBadIcon,
  SignalWifiConnectedNoInternet4Icon,
  SignalWifiOffIcon,
  SignalWifiStatusbar4BarIcon,
  SignalWifiStatusbarConnectedNoInternet4Icon,
  SignalWifiStatusbarNullIcon,
  SignpostIcon,
  SimCardAlertIcon,
  SimCardDownloadIcon,
  SimCardIcon,
  SingleBedIcon,
  SipIcon,
  SkateboardingIcon,
  Skeleton,
  SkipNextIcon,
  SkipPreviousIcon,
  SleddingIcon,
  Slider,
  SlideshowIcon,
  SlowMotionVideoIcon,
  SmartButtonIcon,
  SmartDisplayIcon,
  SmartScreenIcon,
  SmartToyIcon,
  SmartphoneIcon,
  SmokeFreeIcon,
  SmokingRoomsIcon,
  SmsFailedIcon,
  SmsIcon,
  SnapchatIcon,
  SnippetFolderIcon,
  SnoozeIcon,
  SnowboardingIcon,
  SnowmobileIcon,
  SnowshoeingIcon,
  SoapIcon,
  SocialDistanceIcon,
  SolarPowerIcon,
  SortByAlphaIcon,
  SortIcon,
  SosIcon,
  SoupKitchenIcon,
  SourceIcon,
  SouthAmericaIcon,
  SouthEastIcon,
  SouthIcon,
  SouthWestIcon,
  SpaIcon,
  SpaceBarIcon,
  SpaceDashboardIcon,
  SpatialAudioIcon,
  SpatialAudioOffIcon,
  SpatialTrackingIcon,
  SpeakerGroupIcon,
  SpeakerIcon,
  SpeakerNotesIcon,
  SpeakerNotesOffIcon,
  SpeakerPhoneIcon,
  SpeedIcon,
  SpellcheckIcon,
  SplitscreenIcon,
  SpokeIcon,
  SportsBarIcon,
  SportsBaseballIcon,
  SportsBasketballIcon,
  SportsCricketIcon,
  SportsEsportsIcon,
  SportsFootballIcon,
  SportsGolfIcon,
  SportsGymnasticsIcon,
  SportsHandballIcon,
  SportsHockeyIcon,
  SportsIcon,
  SportsKabaddiIcon,
  SportsMartialArtsIcon,
  SportsMmaIcon,
  SportsMotorsportsIcon,
  SportsRugbyIcon,
  SportsScoreIcon,
  SportsSoccerIcon,
  SportsTennisIcon,
  SportsVolleyballIcon,
  SquareFootIcon,
  SquareIcon,
  SsidChartIcon,
  StackedBarChartIcon,
  StackedLineChartIcon,
  StadiumIcon,
  StairsIcon,
  StarBorderIcon,
  StarBorderPurple500Icon,
  StarHalfIcon,
  StarIcon,
  StarOutlineIcon,
  StarPurple500Icon,
  StarRateIcon,
  StarsIcon,
  StartIcon,
  StayCurrentLandscapeIcon,
  StayCurrentPortraitIcon,
  StayPrimaryLandscapeIcon,
  StayPrimaryPortraitIcon,
  StickyNote2Icon,
  StopCircleIcon,
  StopIcon,
  StopScreenShareIcon,
  StorageIcon,
  StoreIcon,
  StoreMallDirectoryIcon,
  StorefrontIcon,
  StormIcon,
  StraightIcon,
  StraightenIcon,
  StreamIcon,
  StreetviewIcon,
  StrikethroughSIcon,
  StrollerIcon,
  StyleIcon,
  SubdirectoryArrowLeftIcon,
  SubdirectoryArrowRightIcon,
  SubjectIcon,
  SubscriptIcon,
  SubscriptionsIcon,
  SubtitlesIcon,
  SubtitlesOffIcon,
  SubwayIcon,
  SummarizeIcon,
  SuperscriptIcon,
  SupervisedUserCircleIcon,
  SupervisorAccountIcon,
  SupportAgentIcon,
  SupportIcon,
  SurfingIcon,
  SurroundSoundIcon,
  SwapCallsIcon,
  SwapHorizIcon,
  SwapHorizontalCircleIcon,
  SwapVertCircleIcon,
  SwapVertIcon,
  SwapVerticalCircleIcon,
  SwipeDownAltIcon,
  SwipeDownIcon,
  SwipeIcon,
  SwipeLeftAltIcon,
  SwipeLeftIcon,
  SwipeRightAltIcon,
  SwipeRightIcon,
  SwipeUpAltIcon,
  SwipeUpIcon,
  SwipeVerticalIcon,
  SwitchAccessShortcutAddIcon,
  SwitchAccessShortcutIcon,
  SwitchAccountIcon,
  SwitchCameraIcon,
  SwitchLeftIcon,
  SwitchRightIcon,
  SwitchVideoIcon,
  SynagogueIcon,
  SyncAltIcon,
  SyncDisabledIcon,
  SyncIcon,
  SyncLockIcon,
  SyncProblemIcon,
  SystemSecurityUpdateGoodIcon,
  SystemSecurityUpdateIcon,
  SystemSecurityUpdateWarningIcon,
  SystemUpdateAltIcon,
  SystemUpdateIcon,
  SystemUpdateTvIcon,
  Tab,
  TabIcon,
  TabUnselectedIcon,
  Table,
  TableBarIcon,
  TableBody,
  TableCell,
  TableChartIcon,
  TableHeader,
  TableRestaurantIcon,
  TableRow,
  TableRowsIcon,
  TableViewIcon,
  TabletAndroidIcon,
  TabletIcon,
  TabletMacIcon,
  Tabs,
  TagFacesIcon,
  TagIcon,
  TakeoutDiningIcon,
  TapAndPlayIcon,
  TapasIcon,
  TaskAltIcon,
  TaskIcon,
  TaxiAlertIcon,
  TelegramIcon,
  TempleBuddhistIcon,
  TempleHinduIcon,
  TerminalIcon,
  TerrainIcon,
  TextDecreaseIcon,
  TextField,
  TextFieldsIcon,
  TextFormatIcon,
  TextIncreaseIcon,
  TextRotateUpIcon,
  TextRotateVerticalIcon,
  TextRotationAngledownIcon,
  TextRotationAngleupIcon,
  TextRotationDownIcon,
  TextRotationNoneIcon,
  TextSnippetIcon,
  TextareaAutosize,
  TextsmsIcon,
  TextureIcon,
  TheaterComedyIcon,
  TheatersIcon,
  ThermostatAutoIcon,
  ThermostatIcon,
  ThumbDownAltIcon,
  ThumbDownIcon,
  ThumbDownOffAltIcon,
  ThumbUpAltIcon,
  ThumbUpIcon,
  ThumbUpOffAltIcon,
  ThumbsUpDownIcon,
  ThunderstormIcon,
  TiktokIcon,
  TimeToLeaveIcon,
  TimelapseIcon,
  TimelineIcon,
  Timer10Icon,
  Timer10SelectIcon,
  Timer3Icon,
  Timer3SelectIcon,
  TimerIcon,
  TimerOffIcon,
  TipsAndUpdatesIcon,
  TireRepairIcon,
  TitleIcon,
  TocIcon,
  TodayIcon,
  ToggleOffIcon,
  ToggleOnIcon,
  TokenIcon,
  TollIcon,
  TonalityIcon,
  Tooltip,
  TopicIcon,
  TornadoIcon,
  TouchAppIcon,
  TourIcon,
  ToysIcon,
  TrackChangesIcon,
  TrafficIcon,
  TrainIcon,
  TramIcon,
  TranscribeIcon,
  TransferWithinAStationIcon,
  TransformIcon,
  TransgenderIcon,
  TransitEnterexitIcon,
  TranslateIcon,
  TravelExploreIcon,
  TrendingDownIcon,
  TrendingFlatIcon,
  TrendingNeutralIcon,
  TrendingUpIcon,
  TripOriginIcon,
  TroubleshootIcon,
  TryIcon,
  TsunamiIcon,
  TtyIcon,
  TuneIcon,
  TungstenIcon,
  TurnLeftIcon,
  TurnRightIcon,
  TurnSharpLeftIcon,
  TurnSharpRightIcon,
  TurnSlightLeftIcon,
  TurnSlightRightIcon,
  TurnedInIcon,
  TurnedInNotIcon,
  TvIcon,
  TvOffIcon,
  TwoWheelerIcon,
  TypeSpecimenIcon,
  Typography,
  UTurnLeftIcon,
  UTurnRightIcon,
  UmbrellaIcon,
  UnarchiveIcon,
  UndoIcon,
  UnfoldLessDoubleIcon,
  UnfoldLessIcon,
  UnfoldMoreDoubleIcon,
  UnfoldMoreIcon,
  UnpublishedIcon,
  UnsubscribeIcon,
  UpcomingIcon,
  UpdateDisabledIcon,
  UpdateIcon,
  UpgradeIcon,
  UploadFileIcon,
  UploadIcon,
  UsbIcon,
  UsbOffIcon,
  VaccinesIcon,
  VapeFreeIcon,
  VapingRoomsIcon,
  VerifiedIcon,
  VerifiedUserIcon,
  VerticalAlignBottomIcon,
  VerticalAlignCenterIcon,
  VerticalAlignTopIcon,
  VerticalDistributeIcon,
  VerticalShadesClosedIcon,
  VerticalShadesIcon,
  VerticalSplitIcon,
  VibrationIcon,
  VideoCallIcon,
  VideoCameraBackIcon,
  VideoCameraFrontIcon,
  VideoChatIcon,
  VideoCollectionIcon,
  VideoFileIcon,
  VideoLabelIcon,
  VideoLibraryIcon,
  VideoSettingsIcon,
  VideoStableIcon,
  VideocamIcon,
  VideocamOffIcon,
  VideogameAssetIcon,
  VideogameAssetOffIcon,
  ViewAgendaIcon,
  ViewArrayIcon,
  ViewCarouselIcon,
  ViewColumnIcon,
  ViewComfortableIcon,
  ViewComfyAltIcon,
  ViewComfyIcon,
  ViewCompactAltIcon,
  ViewCompactIcon,
  ViewCozyIcon,
  ViewDayIcon,
  ViewHeadlineIcon,
  ViewInArIcon,
  ViewKanbanIcon,
  ViewListIcon,
  ViewModuleIcon,
  ViewQuiltIcon,
  ViewSidebarIcon,
  ViewStreamIcon,
  ViewTimelineIcon,
  ViewWeekIcon,
  VignetteIcon,
  VillaIcon,
  VisibilityIcon,
  VisibilityOffIcon,
  VoiceChatIcon,
  VoiceOverOffIcon,
  VoicemailIcon,
  VolcanoIcon,
  VolumeDownIcon,
  VolumeMuteIcon,
  VolumeOffIcon,
  VolumeUpIcon,
  VolunteerActivismIcon,
  VpnKeyIcon,
  VpnKeyOffIcon,
  VpnLockIcon,
  VrpanoIcon,
  WalletGiftcardIcon,
  WalletIcon,
  WalletMembershipIcon,
  WalletTravelIcon,
  WallpaperIcon,
  WarehouseIcon,
  WarningAmberIcon,
  WarningIcon,
  WashIcon,
  WatchIcon,
  WatchLaterIcon,
  WatchOffIcon,
  WaterDamageIcon,
  WaterDropIcon,
  WaterIcon,
  WaterfallChartIcon,
  WavesIcon,
  WavingHandIcon,
  WbAutoIcon,
  WbCloudyIcon,
  WbIncandescentIcon,
  WbIridescentIcon,
  WbShadeIcon,
  WbSunnyIcon,
  WbTwilightIcon,
  WcIcon,
  WebAssetIcon,
  WebAssetOffIcon,
  WebIcon,
  WebStoriesIcon,
  WebhookIcon,
  WechatIcon,
  WeekendIcon,
  WestIcon,
  WhatshotIcon,
  WheelchairPickupIcon,
  WhereToVoteIcon,
  WidgetsIcon,
  WidthFullIcon,
  WidthNormalIcon,
  WidthWideIcon,
  Wifi1BarIcon,
  Wifi2BarIcon,
  WifiCalling3Icon,
  WifiCallingIcon,
  WifiChannelIcon,
  WifiFindIcon,
  WifiIcon,
  WifiLockIcon,
  WifiOffIcon,
  WifiPasswordIcon,
  WifiProtectedSetupIcon,
  WifiTetheringErrorIcon,
  WifiTetheringErrorRoundedIcon,
  WifiTetheringIcon,
  WifiTetheringOffIcon,
  WindPowerIcon,
  WindowIcon,
  WineBarIcon,
  Woman2Icon,
  WomanIcon,
  WooCommerceIcon,
  WordpressIcon,
  WorkHistoryIcon,
  WorkIcon,
  WorkOffIcon,
  WorkOutlineIcon,
  WorkspacePremiumIcon,
  WorkspacesIcon,
  WrapTextIcon,
  WrongLocationIcon,
  WysiwygIcon,
  YardIcon,
  YoutubeSearchedForIcon,
  ZoomInIcon,
  ZoomInMapIcon,
  ZoomOutIcon,
  ZoomOutMapIcon,
  _10kIcon,
  _10mpIcon,
  _11mpIcon,
  _123Icon,
  _12mpIcon,
  _13mpIcon,
  _14mpIcon,
  _15mpIcon,
  _16mpIcon,
  _17mpIcon,
  _18UpRatingIcon,
  _18mpIcon,
  _19mpIcon,
  _1kIcon,
  _1kPlusIcon,
  _1xMobiledataIcon,
  _20mpIcon,
  _21mpIcon,
  _22mpIcon,
  _23mpIcon,
  _24mpIcon,
  _2kIcon,
  _2kPlusIcon,
  _2mpIcon,
  _30fpsIcon,
  _30fpsSelectIcon,
  _360Icon,
  _3dRotationIcon,
  _3gMobiledataIcon,
  _3kIcon,
  _3kPlusIcon,
  _3mpIcon,
  _3pIcon,
  _4gMobiledataIcon,
  _4gPlusMobiledataIcon,
  _4kIcon,
  _4kPlusIcon,
  _4mpIcon,
  _5gIcon,
  _5kIcon,
  _5kPlusIcon,
  _5mpIcon,
  _60fpsIcon,
  _60fpsSelectIcon,
  _6FtApartIcon,
  _6kIcon,
  _6kPlusIcon,
  _6mpIcon,
  _7kIcon,
  _7kPlusIcon,
  _7mpIcon,
  _8kIcon,
  _8kPlusIcon,
  _8mpIcon,
  _9kIcon,
  _9kPlusIcon,
  _9mpIcon,
  clsx as c,
  cardClickableMixin,
  cardMixin,
  cardSelectedMixin,
  cls,
  cn,
  coolIconKeys,
  debounce,
  defaultBorderMixin,
  fieldBackgroundDisabledMixin,
  fieldBackgroundHoverMixin,
  fieldBackgroundInvisibleMixin,
  fieldBackgroundMixin,
  focusedClasses,
  focusedDisabled,
  focusedInvisibleMixin,
  getColorSchemeForKey,
  getColorSchemeForSeed,
  iconKeys,
  keyToIconComponent,
  paperMixin,
  useAutoComplete,
  useDebounceValue,
  useIconStyles,
  useInjectStyles,
  useOutsideAlerter
};
