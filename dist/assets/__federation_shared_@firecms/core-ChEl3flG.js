import { importShared } from "../__federation_fn_import-Ca_-J8Zi.js";
import { j as jsxRuntimeExports } from "../jsx-runtime-BcIfvQoK.js";
import { c as c_1, e as equal } from "../index-zKQ-pyZr.js";
import { c as commonjsGlobal, g as getDefaultExportFromCjs$1, r as reactExports } from "../__federation_shared_react-DfUnMP8L.js";
import { _ as _extends$9, M as MarkdownIt, S as Slot, R as Root, f as useDropzone } from "../index-CY1eqRJM.js";
import { F as Fuse } from "../fuse-BHMvtmJb.js";
var map$1;
try {
  map$1 = Map;
} catch (_) {
}
var set;
try {
  set = Set;
} catch (_) {
}
function baseClone(src, circulars, clones) {
  if (!src || typeof src !== "object" || typeof src === "function") {
    return src;
  }
  if (src.nodeType && "cloneNode" in src) {
    return src.cloneNode(true);
  }
  if (src instanceof Date) {
    return new Date(src.getTime());
  }
  if (src instanceof RegExp) {
    return new RegExp(src);
  }
  if (Array.isArray(src)) {
    return src.map(clone$1);
  }
  if (map$1 && src instanceof map$1) {
    return new Map(Array.from(src.entries()));
  }
  if (set && src instanceof set) {
    return new Set(Array.from(src.values()));
  }
  if (src instanceof Object) {
    circulars.push(src);
    var obj = Object.create(src);
    clones.push(obj);
    for (var key in src) {
      var idx = circulars.findIndex(function(i) {
        return i === src[key];
      });
      obj[key] = idx > -1 ? clones[idx] : baseClone(src[key], circulars, clones);
    }
    return obj;
  }
  return src;
}
function clone$1(src) {
  return baseClone(src, [], []);
}
const toString$6 = Object.prototype.toString;
const errorToString = Error.prototype.toString;
const regExpToString = RegExp.prototype.toString;
const symbolToString$1 = typeof Symbol !== "undefined" ? Symbol.prototype.toString : () => "";
const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
function printNumber(val) {
  if (val != +val) return "NaN";
  const isNegativeZero = val === 0 && 1 / val < 0;
  return isNegativeZero ? "-0" : "" + val;
}
function printSimpleValue(val, quoteStrings = false) {
  if (val == null || val === true || val === false) return "" + val;
  const typeOf2 = typeof val;
  if (typeOf2 === "number") return printNumber(val);
  if (typeOf2 === "string") return quoteStrings ? `"${val}"` : val;
  if (typeOf2 === "function") return "[Function " + (val.name || "anonymous") + "]";
  if (typeOf2 === "symbol") return symbolToString$1.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
  const tag = toString$6.call(val).slice(8, -1);
  if (tag === "Date") return isNaN(val.getTime()) ? "" + val : val.toISOString(val);
  if (tag === "Error" || val instanceof Error) return "[" + errorToString.call(val) + "]";
  if (tag === "RegExp") return regExpToString.call(val);
  return null;
}
function printValue(value, quoteStrings) {
  let result = printSimpleValue(value, quoteStrings);
  if (result !== null) return result;
  return JSON.stringify(value, function(key, value2) {
    let result2 = printSimpleValue(this[key], quoteStrings);
    if (result2 !== null) return result2;
    return value2;
  }, 2);
}
let mixed = {
  default: "${path} is invalid",
  required: "${path} is a required field",
  oneOf: "${path} must be one of the following values: ${values}",
  notOneOf: "${path} must not be one of the following values: ${values}",
  notType: ({
    path,
    type,
    value,
    originalValue
  }) => {
    let isCast = originalValue != null && originalValue !== value;
    let msg = `${path} must be a \`${type}\` type, but the final value was: \`${printValue(value, true)}\`` + (isCast ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : ".");
    if (value === null) {
      msg += `
 If "null" is intended as an empty value be sure to mark the schema as \`.nullable()\``;
    }
    return msg;
  },
  defined: "${path} must be defined"
};
let string = {
  length: "${path} must be exactly ${length} characters",
  min: "${path} must be at least ${min} characters",
  max: "${path} must be at most ${max} characters",
  matches: '${path} must match the following: "${regex}"',
  email: "${path} must be a valid email",
  url: "${path} must be a valid URL",
  uuid: "${path} must be a valid UUID",
  trim: "${path} must be a trimmed string",
  lowercase: "${path} must be a lowercase string",
  uppercase: "${path} must be a upper case string"
};
let number = {
  min: "${path} must be greater than or equal to ${min}",
  max: "${path} must be less than or equal to ${max}",
  lessThan: "${path} must be less than ${less}",
  moreThan: "${path} must be greater than ${more}",
  positive: "${path} must be a positive number",
  negative: "${path} must be a negative number",
  integer: "${path} must be an integer"
};
let date = {
  min: "${path} field must be later than ${min}",
  max: "${path} field must be at earlier than ${max}"
};
let boolean = {
  isValue: "${path} field must be ${value}"
};
let object = {
  noUnknown: "${path} field has unspecified keys: ${unknown}"
};
let array = {
  min: "${path} field must have at least ${min} items",
  max: "${path} field must have less than or equal to ${max} items",
  length: "${path} must have ${length} items"
};
Object.assign(/* @__PURE__ */ Object.create(null), {
  mixed,
  string,
  number,
  date,
  object,
  array,
  boolean
});
var objectProto$c = Object.prototype;
var hasOwnProperty$9 = objectProto$c.hasOwnProperty;
function baseHas$1(object2, key) {
  return object2 != null && hasOwnProperty$9.call(object2, key);
}
var _baseHas = baseHas$1;
var isArray$8 = Array.isArray;
var isArray_1 = isArray$8;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$8 = freeGlobal || freeSelf || Function("return this")();
var _root$2 = root$8;
var root$7 = _root$2;
var Symbol$5 = root$7.Symbol;
var _Symbol = Symbol$5;
var Symbol$4 = _Symbol;
var objectProto$b = Object.prototype;
var hasOwnProperty$8 = objectProto$b.hasOwnProperty;
var nativeObjectToString$1 = objectProto$b.toString;
var symToStringTag$1 = Symbol$4 ? Symbol$4.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$8.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$a = Object.prototype;
var nativeObjectToString = objectProto$a.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$3 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$3 ? Symbol$3.toStringTag : void 0;
function baseGetTag$5(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$5;
function isObjectLike$5(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$5;
var baseGetTag$4 = _baseGetTag, isObjectLike$4 = isObjectLike_1;
var symbolTag$1 = "[object Symbol]";
function isSymbol$3(value) {
  return typeof value == "symbol" || isObjectLike$4(value) && baseGetTag$4(value) == symbolTag$1;
}
var isSymbol_1 = isSymbol$3;
var isArray$7 = isArray_1, isSymbol$2 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey$3(value, object2) {
  if (isArray$7(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$2(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
}
var _isKey = isKey$3;
function isObject$6(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$6;
var baseGetTag$3 = _baseGetTag, isObject$5 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$5(value) {
  if (!isObject$5(value)) {
    return false;
  }
  var tag = baseGetTag$3(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$5;
var root$6 = _root$2;
var coreJsData$1 = root$6["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$4 = isFunction_1, isMasked = _isMasked, isObject$4 = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$9 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$7).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject$4(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$4(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$2(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
var _getValue = getValue$2;
var baseIsNative = _baseIsNative, getValue$1 = _getValue;
function getNative$7(object2, key) {
  var value = getValue$1(object2, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative;
var nativeCreate$4 = getNative$6(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$8 = Object.prototype;
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$6.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$7 = Object.prototype;
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$5.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$2(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$2;
var eq$1 = eq_1;
function assocIndexOf$4(array2, key) {
  var length = array2.length;
  while (length--) {
    if (eq$1(array2[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index2 = assocIndexOf$3(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index2 = assocIndexOf$2(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var getNative$5 = _getNative, root$5 = _root$2;
var Map$4 = getNative$5(root$5, "Map");
var _Map = Map$4;
var Hash = _Hash, ListCache$3 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$3)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map3, key) {
  var data = map3.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$3(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$3.prototype.clear = mapCacheClear;
MapCache$3.prototype["delete"] = mapCacheDelete;
MapCache$3.prototype.get = mapCacheGet;
MapCache$3.prototype.has = mapCacheHas;
MapCache$3.prototype.set = mapCacheSet;
var _MapCache = MapCache$3;
var MapCache$2 = _MapCache;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache$2)();
  return memoized;
}
memoize$1.Cache = MapCache$2;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string2) {
  var result = [];
  if (string2.charCodeAt(0) === 46) {
    result.push("");
  }
  string2.replace(rePropName, function(match2, number2, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match2);
  });
  return result;
});
var _stringToPath = stringToPath$1;
function arrayMap$1(array2, iteratee) {
  var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array2[index2], index2, array2);
  }
  return result;
}
var _arrayMap = arrayMap$1;
var Symbol$2 = _Symbol, arrayMap = _arrayMap, isArray$6 = isArray_1, isSymbol$1 = isSymbol_1;
var INFINITY$1 = 1 / 0;
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$6(value)) {
    return arrayMap(value, baseToString$1) + "";
  }
  if (isSymbol$1(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$5(value) {
  return value == null ? "" : baseToString(value);
}
var toString_1 = toString$5;
var isArray$5 = isArray_1, isKey$2 = _isKey, stringToPath = _stringToPath, toString$4 = toString_1;
function castPath$2(value, object2) {
  if (isArray$5(value)) {
    return value;
  }
  return isKey$2(value, object2) ? [value] : stringToPath(toString$4(value));
}
var _castPath = castPath$2;
var baseGetTag$2 = _baseGetTag, isObjectLike$3 = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$3(value) && baseGetTag$2(value) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$2 = isObjectLike_1;
var objectProto$6 = Object.prototype;
var hasOwnProperty$4 = objectProto$6.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;
var isArguments$2 = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$2(value) && hasOwnProperty$4.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$2;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$2(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$2;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$3;
var isSymbol = isSymbol_1;
var INFINITY = 1 / 0;
function toKey$4(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var _toKey = toKey$4;
var castPath$1 = _castPath, isArguments$1 = isArguments_1, isArray$4 = isArray_1, isIndex$1 = _isIndex, isLength$2 = isLength_1, toKey$3 = _toKey;
function hasPath$2(object2, path, hasFunc) {
  path = castPath$1(path, object2);
  var index2 = -1, length = path.length, result = false;
  while (++index2 < length) {
    var key = toKey$3(path[index2]);
    if (!(result = object2 != null && hasFunc(object2, key))) {
      break;
    }
    object2 = object2[key];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object2 == null ? 0 : object2.length;
  return !!length && isLength$2(length) && isIndex$1(key, length) && (isArray$4(object2) || isArguments$1(object2));
}
var _hasPath = hasPath$2;
var baseHas = _baseHas, hasPath$1 = _hasPath;
function has(object2, path) {
  return object2 != null && hasPath$1(object2, path, baseHas);
}
var has_1 = has;
const has$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(has_1);
const isSchema = (obj) => obj && obj.__isYupSchema__;
class Condition {
  constructor(refs, options) {
    this.fn = void 0;
    this.refs = refs;
    this.refs = refs;
    if (typeof options === "function") {
      this.fn = options;
      return;
    }
    if (!has$1(options, "is")) throw new TypeError("`is:` is required for `when()` conditions");
    if (!options.then && !options.otherwise) throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
    let {
      is: is2,
      then,
      otherwise
    } = options;
    let check = typeof is2 === "function" ? is2 : (...values) => values.every((value) => value === is2);
    this.fn = function(...args) {
      let options2 = args.pop();
      let schema2 = args.pop();
      let branch = check(...args) ? then : otherwise;
      if (!branch) return void 0;
      if (typeof branch === "function") return branch(schema2);
      return schema2.concat(branch.resolve(options2));
    };
  }
  resolve(base2, options) {
    let values = this.refs.map((ref) => ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context));
    let schema2 = this.fn.apply(base2, values.concat(base2, options));
    if (schema2 === void 0 || schema2 === base2) return base2;
    if (!isSchema(schema2)) throw new TypeError("conditions must return a schema object");
    return schema2.resolve(options);
  }
}
function toArray$1(value) {
  return value == null ? [] : [].concat(value);
}
function _extends$8() {
  _extends$8 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$8.apply(this, arguments);
}
let strReg = /\$\{\s*(\w+)\s*\}/g;
class ValidationError extends Error {
  static formatError(message2, params) {
    const path = params.label || params.path || "this";
    if (path !== params.path) params = _extends$8({}, params, {
      path
    });
    if (typeof message2 === "string") return message2.replace(strReg, (_, key) => printValue(params[key]));
    if (typeof message2 === "function") return message2(params);
    return message2;
  }
  static isError(err) {
    return err && err.name === "ValidationError";
  }
  constructor(errorOrErrors, value, field, type) {
    super();
    this.value = void 0;
    this.path = void 0;
    this.type = void 0;
    this.errors = void 0;
    this.params = void 0;
    this.inner = void 0;
    this.name = "ValidationError";
    this.value = value;
    this.path = field;
    this.type = type;
    this.errors = [];
    this.inner = [];
    toArray$1(errorOrErrors).forEach((err) => {
      if (ValidationError.isError(err)) {
        this.errors.push(...err.errors);
        this.inner = this.inner.concat(err.inner.length ? err.inner : err);
      } else {
        this.errors.push(err);
      }
    });
    this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
    if (Error.captureStackTrace) Error.captureStackTrace(this, ValidationError);
  }
}
const once = (cb) => {
  let fired = false;
  return (...args) => {
    if (fired) return;
    fired = true;
    cb(...args);
  };
};
function runTests(options, cb) {
  let {
    endEarly,
    tests,
    args,
    value,
    errors,
    sort,
    path
  } = options;
  let callback = once(cb);
  let count = tests.length;
  const nestedErrors = [];
  errors = errors ? errors : [];
  if (!count) return errors.length ? callback(new ValidationError(errors, value, path)) : callback(null, value);
  for (let i = 0; i < tests.length; i++) {
    const test = tests[i];
    test(args, function finishTestRun(err) {
      if (err) {
        if (!ValidationError.isError(err)) {
          return callback(err, value);
        }
        if (endEarly) {
          err.value = value;
          return callback(err, value);
        }
        nestedErrors.push(err);
      }
      if (--count <= 0) {
        if (nestedErrors.length) {
          if (sort) nestedErrors.sort(sort);
          if (errors.length) nestedErrors.push(...errors);
          errors = nestedErrors;
        }
        if (errors.length) {
          callback(new ValidationError(errors, value, path), value);
          return;
        }
        callback(null, value);
      }
    });
  }
}
var getNative$4 = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative$4(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var _defineProperty = defineProperty$2;
var defineProperty$1 = _defineProperty;
function baseAssignValue$2(object2, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object2, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object2[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$2;
function createBaseFor$1(fromRight) {
  return function(object2, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object2;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
function baseTimes$1(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$1;
var isBuffer$2 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
isBuffer$2.exports;
(function(module, exports) {
  var root2 = _root$2, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$2, isBuffer$2.exports);
var isBufferExports = isBuffer$2.exports;
var baseGetTag$1 = _baseGetTag, isLength$1 = isLength_1, isObjectLike$1 = isObjectLike_1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$1(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$1(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$1(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$1;
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var _nodeUtilExports = _nodeUtil.exports;
var baseIsTypedArray = _baseIsTypedArray, baseUnary = _baseUnary, nodeUtil = _nodeUtilExports;
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
var baseTimes = _baseTimes, isArguments = isArguments_1, isArray$3 = isArray_1, isBuffer$1 = isBufferExports, isIndex = _isIndex, isTypedArray$1 = isTypedArray_1;
var objectProto$5 = Object.prototype;
var hasOwnProperty$3 = objectProto$5.hasOwnProperty;
function arrayLikeKeys$1(value, inherited) {
  var isArr = isArray$3(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$3.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$1;
var objectProto$4 = Object.prototype;
function isPrototype$1(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$4;
  return value === proto;
}
var _isPrototype = isPrototype$1;
function overArg$1(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$1;
var overArg = _overArg;
var nativeKeys$1 = overArg(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function baseKeys$1(object2) {
  if (!isPrototype(object2)) {
    return nativeKeys(object2);
  }
  var result = [];
  for (var key in Object(object2)) {
    if (hasOwnProperty$2.call(object2, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var isFunction$3 = isFunction_1, isLength = isLength_1;
function isArrayLike$1(value) {
  return value != null && isLength(value.length) && !isFunction$3(value);
}
var isArrayLike_1 = isArrayLike$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike = isArrayLike_1;
function keys$5(object2) {
  return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
}
var keys_1 = keys$5;
var baseFor = _baseFor, keys$4 = keys_1;
function baseForOwn$2(object2, iteratee) {
  return object2 && baseFor(object2, iteratee, keys$4);
}
var _baseForOwn = baseForOwn$2;
var ListCache$2 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$2();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var ListCache$1 = _ListCache, Map$2 = _Map, MapCache$1 = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$1(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$2(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$2.prototype.clear = stackClear;
Stack$2.prototype["delete"] = stackDelete;
Stack$2.prototype.get = stackGet;
Stack$2.prototype.has = stackHas;
Stack$2.prototype.set = stackSet;
var _Stack = Stack$2;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$1;
var MapCache = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$1(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
SetCache$1.prototype.has = setCacheHas;
var _SetCache = SetCache$1;
function arraySome$1(array2, predicate) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    if (predicate(array2[index2], index2, array2)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$1;
function cacheHas$1(cache, key) {
  return cache.has(key);
}
var _cacheHas = cacheHas$1;
var SetCache = _SetCache, arraySome = _arraySome, cacheHas = _cacheHas;
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays$2(array2, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array2.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array2);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array2;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack.set(array2, other);
  stack.set(other, array2);
  while (++index2 < arrLength) {
    var arrValue = array2[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array2);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
var root$4 = _root$2;
var Uint8Array$2 = root$4.Uint8Array;
var _Uint8Array = Uint8Array$2;
function mapToArray$1(map3) {
  var index2 = -1, result = Array(map3.size);
  map3.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$1(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var _setToArray = setToArray$1;
var Symbol$1 = _Symbol, Uint8Array$1 = _Uint8Array, eq = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray = _setToArray;
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag$1 = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]";
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag$1(object2, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$1:
      if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
        return false;
      }
      object2 = object2.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object2), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object2, +other);
    case errorTag:
      return object2.name == other.name && object2.message == other.message;
    case regexpTag:
    case stringTag:
      return object2 == other + "";
    case mapTag$1:
      var convert = mapToArray;
    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object2.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object2);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object2, other);
      var result = equalArrays$1(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object2);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object2) == symbolValueOf.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
function arrayPush$1(array2, values) {
  var index2 = -1, length = values.length, offset3 = array2.length;
  while (++index2 < length) {
    array2[offset3 + index2] = values[index2];
  }
  return array2;
}
var _arrayPush = arrayPush$1;
var arrayPush = _arrayPush, isArray$2 = isArray_1;
function baseGetAllKeys$1(object2, keysFunc, symbolsFunc) {
  var result = keysFunc(object2);
  return isArray$2(object2) ? result : arrayPush(result, symbolsFunc(object2));
}
var _baseGetAllKeys = baseGetAllKeys$1;
function arrayFilter$1(array2, predicate) {
  var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array2[index2];
    if (predicate(value, index2, array2)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$1() {
  return [];
}
var stubArray_1 = stubArray$1;
var arrayFilter = _arrayFilter, stubArray = stubArray_1;
var objectProto$2 = Object.prototype;
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols$1 = !nativeGetSymbols ? stubArray : function(object2) {
  if (object2 == null) {
    return [];
  }
  object2 = Object(object2);
  return arrayFilter(nativeGetSymbols(object2), function(symbol) {
    return propertyIsEnumerable.call(object2, symbol);
  });
};
var _getSymbols = getSymbols$1;
var baseGetAllKeys = _baseGetAllKeys, getSymbols = _getSymbols, keys$3 = keys_1;
function getAllKeys$1(object2) {
  return baseGetAllKeys(object2, keys$3, getSymbols);
}
var _getAllKeys = getAllKeys$1;
var getAllKeys = _getAllKeys;
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function equalObjects$1(object2, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object2);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object2;
  }
  var result = true;
  stack.set(object2, other);
  stack.set(other, object2);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object2[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object2.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object2);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var getNative$3 = _getNative, root$3 = _root$2;
var DataView$1 = getNative$3(root$3, "DataView");
var _DataView = DataView$1;
var getNative$2 = _getNative, root$2 = _root$2;
var Promise$2 = getNative$2(root$2, "Promise");
var _Promise = Promise$2;
var getNative$1 = _getNative, root$1 = _root$2;
var Set$2 = getNative$1(root$1, "Set");
var _Set = Set$2;
var getNative = _getNative, root = _root$2;
var WeakMap$2 = getNative(root, "WeakMap");
var _WeakMap = WeakMap$2;
var DataView = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap$1 = _WeakMap, baseGetTag = _baseGetTag, toSource = _toSource;
var mapTag = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag$1 = baseGetTag;
if (DataView && getTag$1(new DataView(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag$1(new Map$1()) != mapTag || Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag || Set$1 && getTag$1(new Set$1()) != setTag || WeakMap$1 && getTag$1(new WeakMap$1()) != weakMapTag) {
  getTag$1 = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var _getTag = getTag$1;
var Stack$1 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag = _getTag, isArray$1 = isArray_1, isBuffer = isBufferExports, isTypedArray = isTypedArray_1;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseIsEqualDeep$1(object2, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$1(object2), othIsArr = isArray$1(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer(object2)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$1());
    return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$1());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$1());
  return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike = isObjectLike_1;
function baseIsEqual$2(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$2, stack);
}
var _baseIsEqual = baseIsEqual$2;
var Stack = _Stack, baseIsEqual$1 = _baseIsEqual;
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch$1(object2, source, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object2 == null) {
    return !length;
  }
  object2 = Object(object2);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
      return false;
    }
  }
  while (++index2 < length) {
    data = matchData[index2];
    var key = data[0], objValue = object2[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object2)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object2, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch$1;
var isObject$3 = isObject_1;
function isStrictComparable$2(value) {
  return value === value && !isObject$3(value);
}
var _isStrictComparable = isStrictComparable$2;
var isStrictComparable$1 = _isStrictComparable, keys$2 = keys_1;
function getMatchData$1(object2) {
  var result = keys$2(object2), length = result.length;
  while (length--) {
    var key = result[length], value = object2[key];
    result[length] = [key, value, isStrictComparable$1(value)];
  }
  return result;
}
var _getMatchData = getMatchData$1;
function matchesStrictComparable$2(key, srcValue) {
  return function(object2) {
    if (object2 == null) {
      return false;
    }
    return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
  };
}
var _matchesStrictComparable = matchesStrictComparable$2;
var baseIsMatch = _baseIsMatch, getMatchData = _getMatchData, matchesStrictComparable$1 = _matchesStrictComparable;
function baseMatches$1(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
  }
  return function(object2) {
    return object2 === source || baseIsMatch(object2, source, matchData);
  };
}
var _baseMatches = baseMatches$1;
var castPath = _castPath, toKey$2 = _toKey;
function baseGet$2(object2, path) {
  path = castPath(path, object2);
  var index2 = 0, length = path.length;
  while (object2 != null && index2 < length) {
    object2 = object2[toKey$2(path[index2++])];
  }
  return index2 && index2 == length ? object2 : void 0;
}
var _baseGet = baseGet$2;
var baseGet$1 = _baseGet;
function get$1(object2, path, defaultValue) {
  var result = object2 == null ? void 0 : baseGet$1(object2, path);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get$1;
function baseHasIn$1(object2, key) {
  return object2 != null && key in Object(object2);
}
var _baseHasIn = baseHasIn$1;
var baseHasIn = _baseHasIn, hasPath = _hasPath;
function hasIn$1(object2, path) {
  return object2 != null && hasPath(object2, path, baseHasIn);
}
var hasIn_1 = hasIn$1;
var baseIsEqual = _baseIsEqual, get = get_1, hasIn = hasIn_1, isKey$1 = _isKey, isStrictComparable = _isStrictComparable, matchesStrictComparable = _matchesStrictComparable, toKey$1 = _toKey;
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty$1(path, srcValue) {
  if (isKey$1(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey$1(path), srcValue);
  }
  return function(object2) {
    var objValue = get(object2, path);
    return objValue === void 0 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
var _baseMatchesProperty = baseMatchesProperty$1;
function identity$1(value) {
  return value;
}
var identity_1 = identity$1;
function baseProperty$1(key) {
  return function(object2) {
    return object2 == null ? void 0 : object2[key];
  };
}
var _baseProperty = baseProperty$1;
var baseGet = _baseGet;
function basePropertyDeep$1(path) {
  return function(object2) {
    return baseGet(object2, path);
  };
}
var _basePropertyDeep = basePropertyDeep$1;
var baseProperty = _baseProperty, basePropertyDeep = _basePropertyDeep, isKey = _isKey, toKey = _toKey;
function property$1(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
var property_1 = property$1;
var baseMatches = _baseMatches, baseMatchesProperty = _baseMatchesProperty, identity = identity_1, isArray = isArray_1, property = property_1;
function baseIteratee$2(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == "object") {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
var _baseIteratee = baseIteratee$2;
var baseAssignValue$1 = _baseAssignValue, baseForOwn$1 = _baseForOwn, baseIteratee$1 = _baseIteratee;
function mapValues(object2, iteratee) {
  var result = {};
  iteratee = baseIteratee$1(iteratee);
  baseForOwn$1(object2, function(value, key, object3) {
    baseAssignValue$1(result, key, iteratee(value, key, object3));
  });
  return result;
}
var mapValues_1 = mapValues;
const mapValues$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(mapValues_1);
function Cache(maxSize) {
  this._maxSize = maxSize;
  this.clear();
}
Cache.prototype.clear = function() {
  this._size = 0;
  this._values = /* @__PURE__ */ Object.create(null);
};
Cache.prototype.get = function(key) {
  return this._values[key];
};
Cache.prototype.set = function(key, value) {
  this._size >= this._maxSize && this.clear();
  if (!(key in this._values)) this._size++;
  return this._values[key] = value;
};
var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g, DIGIT_REGEX = /^\d+$/, LEAD_DIGIT_REGEX = /^\d/, SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g, CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/, MAX_CACHE_SIZE = 512;
var pathCache = new Cache(MAX_CACHE_SIZE), setCache = new Cache(MAX_CACHE_SIZE), getCache = new Cache(MAX_CACHE_SIZE);
var propertyExpr = {
  Cache,
  split: split$1,
  normalizePath,
  setter: function(path) {
    var parts = normalizePath(path);
    return setCache.get(path) || setCache.set(path, function setter(obj, value) {
      var index2 = 0;
      var len = parts.length;
      var data = obj;
      while (index2 < len - 1) {
        var part = parts[index2];
        if (part === "__proto__" || part === "constructor" || part === "prototype") {
          return obj;
        }
        data = data[parts[index2++]];
      }
      data[parts[index2]] = value;
    });
  },
  getter: function(path, safe) {
    var parts = normalizePath(path);
    return getCache.get(path) || getCache.set(path, function getter(data) {
      var index2 = 0, len = parts.length;
      while (index2 < len) {
        if (data != null || !safe) data = data[parts[index2++]];
        else return;
      }
      return data;
    });
  },
  join: function(segments) {
    return segments.reduce(function(path, part) {
      return path + (isQuoted(part) || DIGIT_REGEX.test(part) ? "[" + part + "]" : (path ? "." : "") + part);
    }, "");
  },
  forEach: function(path, cb, thisArg) {
    forEach$2(Array.isArray(path) ? path : split$1(path), cb, thisArg);
  }
};
function normalizePath(path) {
  return pathCache.get(path) || pathCache.set(
    path,
    split$1(path).map(function(part) {
      return part.replace(CLEAN_QUOTES_REGEX, "$2");
    })
  );
}
function split$1(path) {
  return path.match(SPLIT_REGEX) || [""];
}
function forEach$2(parts, iter, thisArg) {
  var len = parts.length, part, idx, isArray2, isBracket;
  for (idx = 0; idx < len; idx++) {
    part = parts[idx];
    if (part) {
      if (shouldBeQuoted(part)) {
        part = '"' + part + '"';
      }
      isBracket = isQuoted(part);
      isArray2 = !isBracket && /^\d+$/.test(part);
      iter.call(thisArg, part, isBracket, isArray2, idx, parts);
    }
  }
}
function isQuoted(str) {
  return typeof str === "string" && str && ["'", '"'].indexOf(str.charAt(0)) !== -1;
}
function hasLeadingNumber(part) {
  return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
}
function hasSpecialChars(part) {
  return SPEC_CHAR_REGEX.test(part);
}
function shouldBeQuoted(part) {
  return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
}
const prefixes = {
  context: "$",
  value: "."
};
class Reference {
  constructor(key, options = {}) {
    this.key = void 0;
    this.isContext = void 0;
    this.isValue = void 0;
    this.isSibling = void 0;
    this.path = void 0;
    this.getter = void 0;
    this.map = void 0;
    if (typeof key !== "string") throw new TypeError("ref must be a string, got: " + key);
    this.key = key.trim();
    if (key === "") throw new TypeError("ref must be a non-empty string");
    this.isContext = this.key[0] === prefixes.context;
    this.isValue = this.key[0] === prefixes.value;
    this.isSibling = !this.isContext && !this.isValue;
    let prefix2 = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
    this.path = this.key.slice(prefix2.length);
    this.getter = this.path && propertyExpr.getter(this.path, true);
    this.map = options.map;
  }
  getValue(value, parent, context) {
    let result = this.isContext ? context : this.isValue ? value : parent;
    if (this.getter) result = this.getter(result || {});
    if (this.map) result = this.map(result);
    return result;
  }
  /**
   *
   * @param {*} value
   * @param {Object} options
   * @param {Object=} options.context
   * @param {Object=} options.parent
   */
  cast(value, options) {
    return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);
  }
  resolve() {
    return this;
  }
  describe() {
    return {
      type: "ref",
      key: this.key
    };
  }
  toString() {
    return `Ref(${this.key})`;
  }
  static isRef(value) {
    return value && value.__isYupRef;
  }
}
Reference.prototype.__isYupRef = true;
function _extends$7() {
  _extends$7 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$7.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function createValidation(config) {
  function validate(_ref, cb) {
    let {
      value,
      path = "",
      label,
      options,
      originalValue,
      sync
    } = _ref, rest = _objectWithoutPropertiesLoose$2(_ref, ["value", "path", "label", "options", "originalValue", "sync"]);
    const {
      name,
      test,
      params,
      message: message2
    } = config;
    let {
      parent,
      context
    } = options;
    function resolve(item) {
      return Reference.isRef(item) ? item.getValue(value, parent, context) : item;
    }
    function createError(overrides = {}) {
      const nextParams = mapValues$1(_extends$7({
        value,
        originalValue,
        label,
        path: overrides.path || path
      }, params, overrides.params), resolve);
      const error = new ValidationError(ValidationError.formatError(overrides.message || message2, nextParams), value, nextParams.path, overrides.type || name);
      error.params = nextParams;
      return error;
    }
    let ctx = _extends$7({
      path,
      parent,
      type: name,
      createError,
      resolve,
      options,
      originalValue
    }, rest);
    if (!sync) {
      try {
        Promise.resolve(test.call(ctx, value, ctx)).then((validOrError) => {
          if (ValidationError.isError(validOrError)) cb(validOrError);
          else if (!validOrError) cb(createError());
          else cb(null, validOrError);
        }).catch(cb);
      } catch (err) {
        cb(err);
      }
      return;
    }
    let result;
    try {
      var _ref2;
      result = test.call(ctx, value, ctx);
      if (typeof ((_ref2 = result) == null ? void 0 : _ref2.then) === "function") {
        throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
      }
    } catch (err) {
      cb(err);
      return;
    }
    if (ValidationError.isError(result)) cb(result);
    else if (!result) cb(createError());
    else cb(null, result);
  }
  validate.OPTIONS = config;
  return validate;
}
let trim = (part) => part.substr(0, part.length - 1).substr(1);
function getIn$1(schema2, path, value, context = value) {
  let parent, lastPart, lastPartDebug;
  if (!path) return {
    parent,
    parentPath: path,
    schema: schema2
  };
  propertyExpr.forEach(path, (_part, isBracket, isArray2) => {
    let part = isBracket ? trim(_part) : _part;
    schema2 = schema2.resolve({
      context,
      parent,
      value
    });
    if (schema2.innerType) {
      let idx = isArray2 ? parseInt(part, 10) : 0;
      if (value && idx >= value.length) {
        throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. because there is no value at that index. `);
      }
      parent = value;
      value = value && value[idx];
      schema2 = schema2.innerType;
    }
    if (!isArray2) {
      if (!schema2.fields || !schema2.fields[part]) throw new Error(`The schema does not contain the path: ${path}. (failed at: ${lastPartDebug} which is a type: "${schema2._type}")`);
      parent = value;
      value = value && value[part];
      schema2 = schema2.fields[part];
    }
    lastPart = part;
    lastPartDebug = isBracket ? "[" + _part + "]" : "." + _part;
  });
  return {
    schema: schema2,
    parent,
    parentPath: lastPart
  };
}
class ReferenceSet {
  constructor() {
    this.list = void 0;
    this.refs = void 0;
    this.list = /* @__PURE__ */ new Set();
    this.refs = /* @__PURE__ */ new Map();
  }
  get size() {
    return this.list.size + this.refs.size;
  }
  describe() {
    const description = [];
    for (const item of this.list) description.push(item);
    for (const [, ref] of this.refs) description.push(ref.describe());
    return description;
  }
  toArray() {
    return Array.from(this.list).concat(Array.from(this.refs.values()));
  }
  resolveAll(resolve) {
    return this.toArray().reduce((acc, e2) => acc.concat(Reference.isRef(e2) ? resolve(e2) : e2), []);
  }
  add(value) {
    Reference.isRef(value) ? this.refs.set(value.key, value) : this.list.add(value);
  }
  delete(value) {
    Reference.isRef(value) ? this.refs.delete(value.key) : this.list.delete(value);
  }
  clone() {
    const next = new ReferenceSet();
    next.list = new Set(this.list);
    next.refs = new Map(this.refs);
    return next;
  }
  merge(newItems, removeItems) {
    const next = this.clone();
    newItems.list.forEach((value) => next.add(value));
    newItems.refs.forEach((value) => next.add(value));
    removeItems.list.forEach((value) => next.delete(value));
    removeItems.refs.forEach((value) => next.delete(value));
    return next;
  }
}
function _extends$6() {
  _extends$6 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$6.apply(this, arguments);
}
class BaseSchema {
  constructor(options) {
    this.deps = [];
    this.tests = void 0;
    this.transforms = void 0;
    this.conditions = [];
    this._mutate = void 0;
    this._typeError = void 0;
    this._whitelist = new ReferenceSet();
    this._blacklist = new ReferenceSet();
    this.exclusiveTests = /* @__PURE__ */ Object.create(null);
    this.spec = void 0;
    this.tests = [];
    this.transforms = [];
    this.withMutation(() => {
      this.typeError(mixed.notType);
    });
    this.type = (options == null ? void 0 : options.type) || "mixed";
    this.spec = _extends$6({
      strip: false,
      strict: false,
      abortEarly: true,
      recursive: true,
      nullable: false,
      presence: "optional"
    }, options == null ? void 0 : options.spec);
  }
  // TODO: remove
  get _type() {
    return this.type;
  }
  _typeCheck(_value) {
    return true;
  }
  clone(spec) {
    if (this._mutate) {
      if (spec) Object.assign(this.spec, spec);
      return this;
    }
    const next = Object.create(Object.getPrototypeOf(this));
    next.type = this.type;
    next._typeError = this._typeError;
    next._whitelistError = this._whitelistError;
    next._blacklistError = this._blacklistError;
    next._whitelist = this._whitelist.clone();
    next._blacklist = this._blacklist.clone();
    next.exclusiveTests = _extends$6({}, this.exclusiveTests);
    next.deps = [...this.deps];
    next.conditions = [...this.conditions];
    next.tests = [...this.tests];
    next.transforms = [...this.transforms];
    next.spec = clone$1(_extends$6({}, this.spec, spec));
    return next;
  }
  label(label) {
    let next = this.clone();
    next.spec.label = label;
    return next;
  }
  meta(...args) {
    if (args.length === 0) return this.spec.meta;
    let next = this.clone();
    next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
    return next;
  }
  // withContext<TContext extends AnyObject>(): BaseSchema<
  //   TCast,
  //   TContext,
  //   TOutput
  // > {
  //   return this as any;
  // }
  withMutation(fn2) {
    let before = this._mutate;
    this._mutate = true;
    let result = fn2(this);
    this._mutate = before;
    return result;
  }
  concat(schema2) {
    if (!schema2 || schema2 === this) return this;
    if (schema2.type !== this.type && this.type !== "mixed") throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema2.type}`);
    let base2 = this;
    let combined = schema2.clone();
    const mergedSpec = _extends$6({}, base2.spec, combined.spec);
    combined.spec = mergedSpec;
    combined._typeError || (combined._typeError = base2._typeError);
    combined._whitelistError || (combined._whitelistError = base2._whitelistError);
    combined._blacklistError || (combined._blacklistError = base2._blacklistError);
    combined._whitelist = base2._whitelist.merge(schema2._whitelist, schema2._blacklist);
    combined._blacklist = base2._blacklist.merge(schema2._blacklist, schema2._whitelist);
    combined.tests = base2.tests;
    combined.exclusiveTests = base2.exclusiveTests;
    combined.withMutation((next) => {
      schema2.tests.forEach((fn2) => {
        next.test(fn2.OPTIONS);
      });
    });
    combined.transforms = [...base2.transforms, ...combined.transforms];
    return combined;
  }
  isType(v) {
    if (this.spec.nullable && v === null) return true;
    return this._typeCheck(v);
  }
  resolve(options) {
    let schema2 = this;
    if (schema2.conditions.length) {
      let conditions = schema2.conditions;
      schema2 = schema2.clone();
      schema2.conditions = [];
      schema2 = conditions.reduce((schema3, condition) => condition.resolve(schema3, options), schema2);
      schema2 = schema2.resolve(options);
    }
    return schema2;
  }
  /**
   *
   * @param {*} value
   * @param {Object} options
   * @param {*=} options.parent
   * @param {*=} options.context
   */
  cast(value, options = {}) {
    let resolvedSchema = this.resolve(_extends$6({
      value
    }, options));
    let result = resolvedSchema._cast(value, options);
    if (value !== void 0 && options.assert !== false && resolvedSchema.isType(result) !== true) {
      let formattedValue = printValue(value);
      let formattedResult = printValue(result);
      throw new TypeError(`The value of ${options.path || "field"} could not be cast to a value that satisfies the schema type: "${resolvedSchema._type}". 

attempted value: ${formattedValue} 
` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ""));
    }
    return result;
  }
  _cast(rawValue, _options) {
    let value = rawValue === void 0 ? rawValue : this.transforms.reduce((value2, fn2) => fn2.call(this, value2, rawValue, this), rawValue);
    if (value === void 0) {
      value = this.getDefault();
    }
    return value;
  }
  _validate(_value, options = {}, cb) {
    let {
      sync,
      path,
      from: from2 = [],
      originalValue = _value,
      strict = this.spec.strict,
      abortEarly = this.spec.abortEarly
    } = options;
    let value = _value;
    if (!strict) {
      value = this._cast(value, _extends$6({
        assert: false
      }, options));
    }
    let args = {
      value,
      path,
      options,
      originalValue,
      schema: this,
      label: this.spec.label,
      sync,
      from: from2
    };
    let initialTests = [];
    if (this._typeError) initialTests.push(this._typeError);
    let finalTests = [];
    if (this._whitelistError) finalTests.push(this._whitelistError);
    if (this._blacklistError) finalTests.push(this._blacklistError);
    runTests({
      args,
      value,
      path,
      sync,
      tests: initialTests,
      endEarly: abortEarly
    }, (err) => {
      if (err) return void cb(err, value);
      runTests({
        tests: this.tests.concat(finalTests),
        args,
        path,
        sync,
        value,
        endEarly: abortEarly
      }, cb);
    });
  }
  validate(value, options, maybeCb) {
    let schema2 = this.resolve(_extends$6({}, options, {
      value
    }));
    return typeof maybeCb === "function" ? schema2._validate(value, options, maybeCb) : new Promise((resolve, reject) => schema2._validate(value, options, (err, value2) => {
      if (err) reject(err);
      else resolve(value2);
    }));
  }
  validateSync(value, options) {
    let schema2 = this.resolve(_extends$6({}, options, {
      value
    }));
    let result;
    schema2._validate(value, _extends$6({}, options, {
      sync: true
    }), (err, value2) => {
      if (err) throw err;
      result = value2;
    });
    return result;
  }
  isValid(value, options) {
    return this.validate(value, options).then(() => true, (err) => {
      if (ValidationError.isError(err)) return false;
      throw err;
    });
  }
  isValidSync(value, options) {
    try {
      this.validateSync(value, options);
      return true;
    } catch (err) {
      if (ValidationError.isError(err)) return false;
      throw err;
    }
  }
  _getDefault() {
    let defaultValue = this.spec.default;
    if (defaultValue == null) {
      return defaultValue;
    }
    return typeof defaultValue === "function" ? defaultValue.call(this) : clone$1(defaultValue);
  }
  getDefault(options) {
    let schema2 = this.resolve(options || {});
    return schema2._getDefault();
  }
  default(def) {
    if (arguments.length === 0) {
      return this._getDefault();
    }
    let next = this.clone({
      default: def
    });
    return next;
  }
  strict(isStrict = true) {
    let next = this.clone();
    next.spec.strict = isStrict;
    return next;
  }
  _isPresent(value) {
    return value != null;
  }
  defined(message2 = mixed.defined) {
    return this.test({
      message: message2,
      name: "defined",
      exclusive: true,
      test(value) {
        return value !== void 0;
      }
    });
  }
  required(message2 = mixed.required) {
    return this.clone({
      presence: "required"
    }).withMutation((s2) => s2.test({
      message: message2,
      name: "required",
      exclusive: true,
      test(value) {
        return this.schema._isPresent(value);
      }
    }));
  }
  notRequired() {
    let next = this.clone({
      presence: "optional"
    });
    next.tests = next.tests.filter((test) => test.OPTIONS.name !== "required");
    return next;
  }
  nullable(isNullable = true) {
    let next = this.clone({
      nullable: isNullable !== false
    });
    return next;
  }
  transform(fn2) {
    let next = this.clone();
    next.transforms.push(fn2);
    return next;
  }
  /**
   * Adds a test function to the schema's queue of tests.
   * tests can be exclusive or non-exclusive.
   *
   * - exclusive tests, will replace any existing tests of the same name.
   * - non-exclusive: can be stacked
   *
   * If a non-exclusive test is added to a schema with an exclusive test of the same name
   * the exclusive test is removed and further tests of the same name will be stacked.
   *
   * If an exclusive test is added to a schema with non-exclusive tests of the same name
   * the previous tests are removed and further tests of the same name will replace each other.
   */
  test(...args) {
    let opts;
    if (args.length === 1) {
      if (typeof args[0] === "function") {
        opts = {
          test: args[0]
        };
      } else {
        opts = args[0];
      }
    } else if (args.length === 2) {
      opts = {
        name: args[0],
        test: args[1]
      };
    } else {
      opts = {
        name: args[0],
        message: args[1],
        test: args[2]
      };
    }
    if (opts.message === void 0) opts.message = mixed.default;
    if (typeof opts.test !== "function") throw new TypeError("`test` is a required parameters");
    let next = this.clone();
    let validate = createValidation(opts);
    let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;
    if (opts.exclusive) {
      if (!opts.name) throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
    }
    if (opts.name) next.exclusiveTests[opts.name] = !!opts.exclusive;
    next.tests = next.tests.filter((fn2) => {
      if (fn2.OPTIONS.name === opts.name) {
        if (isExclusive) return false;
        if (fn2.OPTIONS.test === validate.OPTIONS.test) return false;
      }
      return true;
    });
    next.tests.push(validate);
    return next;
  }
  when(keys2, options) {
    if (!Array.isArray(keys2) && typeof keys2 !== "string") {
      options = keys2;
      keys2 = ".";
    }
    let next = this.clone();
    let deps = toArray$1(keys2).map((key) => new Reference(key));
    deps.forEach((dep) => {
      if (dep.isSibling) next.deps.push(dep.key);
    });
    next.conditions.push(new Condition(deps, options));
    return next;
  }
  typeError(message2) {
    let next = this.clone();
    next._typeError = createValidation({
      message: message2,
      name: "typeError",
      test(value) {
        if (value !== void 0 && !this.schema.isType(value)) return this.createError({
          params: {
            type: this.schema._type
          }
        });
        return true;
      }
    });
    return next;
  }
  oneOf(enums, message2 = mixed.oneOf) {
    let next = this.clone();
    enums.forEach((val) => {
      next._whitelist.add(val);
      next._blacklist.delete(val);
    });
    next._whitelistError = createValidation({
      message: message2,
      name: "oneOf",
      test(value) {
        if (value === void 0) return true;
        let valids = this.schema._whitelist;
        let resolved = valids.resolveAll(this.resolve);
        return resolved.includes(value) ? true : this.createError({
          params: {
            values: valids.toArray().join(", "),
            resolved
          }
        });
      }
    });
    return next;
  }
  notOneOf(enums, message2 = mixed.notOneOf) {
    let next = this.clone();
    enums.forEach((val) => {
      next._blacklist.add(val);
      next._whitelist.delete(val);
    });
    next._blacklistError = createValidation({
      message: message2,
      name: "notOneOf",
      test(value) {
        let invalids = this.schema._blacklist;
        let resolved = invalids.resolveAll(this.resolve);
        if (resolved.includes(value)) return this.createError({
          params: {
            values: invalids.toArray().join(", "),
            resolved
          }
        });
        return true;
      }
    });
    return next;
  }
  strip(strip = true) {
    let next = this.clone();
    next.spec.strip = strip;
    return next;
  }
  describe() {
    const next = this.clone();
    const {
      label,
      meta
    } = next.spec;
    const description = {
      meta,
      label,
      type: next.type,
      oneOf: next._whitelist.describe(),
      notOneOf: next._blacklist.describe(),
      tests: next.tests.map((fn2) => ({
        name: fn2.OPTIONS.name,
        params: fn2.OPTIONS.params
      })).filter((n2, idx, list) => list.findIndex((c2) => c2.name === n2.name) === idx)
    };
    return description;
  }
}
BaseSchema.prototype.__isYupSchema__ = true;
for (const method of ["validate", "validateSync"]) BaseSchema.prototype[`${method}At`] = function(path, value, options = {}) {
  const {
    parent,
    parentPath,
    schema: schema2
  } = getIn$1(this, path, value, options.context);
  return schema2[method](parent && parent[parentPath], _extends$6({}, options, {
    parent,
    path
  }));
};
for (const alias of ["equals", "is"]) BaseSchema.prototype[alias] = BaseSchema.prototype.oneOf;
for (const alias of ["not", "nope"]) BaseSchema.prototype[alias] = BaseSchema.prototype.notOneOf;
BaseSchema.prototype.optional = BaseSchema.prototype.notRequired;
const Mixed = BaseSchema;
function create$7() {
  return new Mixed();
}
create$7.prototype = Mixed.prototype;
const isAbsent = (value) => value == null;
function create$6() {
  return new BooleanSchema();
}
class BooleanSchema extends BaseSchema {
  constructor() {
    super({
      type: "boolean"
    });
    this.withMutation(() => {
      this.transform(function(value) {
        if (!this.isType(value)) {
          if (/^(true|1)$/i.test(String(value))) return true;
          if (/^(false|0)$/i.test(String(value))) return false;
        }
        return value;
      });
    });
  }
  _typeCheck(v) {
    if (v instanceof Boolean) v = v.valueOf();
    return typeof v === "boolean";
  }
  isTrue(message2 = boolean.isValue) {
    return this.test({
      message: message2,
      name: "is-value",
      exclusive: true,
      params: {
        value: "true"
      },
      test(value) {
        return isAbsent(value) || value === true;
      }
    });
  }
  isFalse(message2 = boolean.isValue) {
    return this.test({
      message: message2,
      name: "is-value",
      exclusive: true,
      params: {
        value: "false"
      },
      test(value) {
        return isAbsent(value) || value === false;
      }
    });
  }
}
create$6.prototype = BooleanSchema.prototype;
let rEmail = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
let rUrl = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
let rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
let isTrimmed = (value) => isAbsent(value) || value === value.trim();
let objStringTag = {}.toString();
function create$5() {
  return new StringSchema();
}
class StringSchema extends BaseSchema {
  constructor() {
    super({
      type: "string"
    });
    this.withMutation(() => {
      this.transform(function(value) {
        if (this.isType(value)) return value;
        if (Array.isArray(value)) return value;
        const strValue = value != null && value.toString ? value.toString() : value;
        if (strValue === objStringTag) return value;
        return strValue;
      });
    });
  }
  _typeCheck(value) {
    if (value instanceof String) value = value.valueOf();
    return typeof value === "string";
  }
  _isPresent(value) {
    return super._isPresent(value) && !!value.length;
  }
  length(length, message2 = string.length) {
    return this.test({
      message: message2,
      name: "length",
      exclusive: true,
      params: {
        length
      },
      test(value) {
        return isAbsent(value) || value.length === this.resolve(length);
      }
    });
  }
  min(min2, message2 = string.min) {
    return this.test({
      message: message2,
      name: "min",
      exclusive: true,
      params: {
        min: min2
      },
      test(value) {
        return isAbsent(value) || value.length >= this.resolve(min2);
      }
    });
  }
  max(max2, message2 = string.max) {
    return this.test({
      name: "max",
      exclusive: true,
      message: message2,
      params: {
        max: max2
      },
      test(value) {
        return isAbsent(value) || value.length <= this.resolve(max2);
      }
    });
  }
  matches(regex, options) {
    let excludeEmptyString = false;
    let message2;
    let name;
    if (options) {
      if (typeof options === "object") {
        ({
          excludeEmptyString = false,
          message: message2,
          name
        } = options);
      } else {
        message2 = options;
      }
    }
    return this.test({
      name: name || "matches",
      message: message2 || string.matches,
      params: {
        regex
      },
      test: (value) => isAbsent(value) || value === "" && excludeEmptyString || value.search(regex) !== -1
    });
  }
  email(message2 = string.email) {
    return this.matches(rEmail, {
      name: "email",
      message: message2,
      excludeEmptyString: true
    });
  }
  url(message2 = string.url) {
    return this.matches(rUrl, {
      name: "url",
      message: message2,
      excludeEmptyString: true
    });
  }
  uuid(message2 = string.uuid) {
    return this.matches(rUUID, {
      name: "uuid",
      message: message2,
      excludeEmptyString: false
    });
  }
  //-- transforms --
  ensure() {
    return this.default("").transform((val) => val === null ? "" : val);
  }
  trim(message2 = string.trim) {
    return this.transform((val) => val != null ? val.trim() : val).test({
      message: message2,
      name: "trim",
      test: isTrimmed
    });
  }
  lowercase(message2 = string.lowercase) {
    return this.transform((value) => !isAbsent(value) ? value.toLowerCase() : value).test({
      message: message2,
      name: "string_case",
      exclusive: true,
      test: (value) => isAbsent(value) || value === value.toLowerCase()
    });
  }
  uppercase(message2 = string.uppercase) {
    return this.transform((value) => !isAbsent(value) ? value.toUpperCase() : value).test({
      message: message2,
      name: "string_case",
      exclusive: true,
      test: (value) => isAbsent(value) || value === value.toUpperCase()
    });
  }
}
create$5.prototype = StringSchema.prototype;
let isNaN$1 = (value) => value != +value;
function create$4() {
  return new NumberSchema();
}
class NumberSchema extends BaseSchema {
  constructor() {
    super({
      type: "number"
    });
    this.withMutation(() => {
      this.transform(function(value) {
        let parsed = value;
        if (typeof parsed === "string") {
          parsed = parsed.replace(/\s/g, "");
          if (parsed === "") return NaN;
          parsed = +parsed;
        }
        if (this.isType(parsed)) return parsed;
        return parseFloat(parsed);
      });
    });
  }
  _typeCheck(value) {
    if (value instanceof Number) value = value.valueOf();
    return typeof value === "number" && !isNaN$1(value);
  }
  min(min2, message2 = number.min) {
    return this.test({
      message: message2,
      name: "min",
      exclusive: true,
      params: {
        min: min2
      },
      test(value) {
        return isAbsent(value) || value >= this.resolve(min2);
      }
    });
  }
  max(max2, message2 = number.max) {
    return this.test({
      message: message2,
      name: "max",
      exclusive: true,
      params: {
        max: max2
      },
      test(value) {
        return isAbsent(value) || value <= this.resolve(max2);
      }
    });
  }
  lessThan(less, message2 = number.lessThan) {
    return this.test({
      message: message2,
      name: "max",
      exclusive: true,
      params: {
        less
      },
      test(value) {
        return isAbsent(value) || value < this.resolve(less);
      }
    });
  }
  moreThan(more, message2 = number.moreThan) {
    return this.test({
      message: message2,
      name: "min",
      exclusive: true,
      params: {
        more
      },
      test(value) {
        return isAbsent(value) || value > this.resolve(more);
      }
    });
  }
  positive(msg = number.positive) {
    return this.moreThan(0, msg);
  }
  negative(msg = number.negative) {
    return this.lessThan(0, msg);
  }
  integer(message2 = number.integer) {
    return this.test({
      name: "integer",
      message: message2,
      test: (val) => isAbsent(val) || Number.isInteger(val)
    });
  }
  truncate() {
    return this.transform((value) => !isAbsent(value) ? value | 0 : value);
  }
  round(method) {
    var _method;
    let avail = ["ceil", "floor", "round", "trunc"];
    method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || "round";
    if (method === "trunc") return this.truncate();
    if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError("Only valid options for round() are: " + avail.join(", "));
    return this.transform((value) => !isAbsent(value) ? Math[method](value) : value);
  }
}
create$4.prototype = NumberSchema.prototype;
var isoReg = /^(\d{4}|[+\-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;
function parseIsoDate(date2) {
  var numericKeys = [1, 4, 5, 6, 7, 10, 11], minutesOffset = 0, timestamp, struct;
  if (struct = isoReg.exec(date2)) {
    for (var i = 0, k; k = numericKeys[i]; ++i) struct[k] = +struct[k] || 0;
    struct[2] = (+struct[2] || 1) - 1;
    struct[3] = +struct[3] || 1;
    struct[7] = struct[7] ? String(struct[7]).substr(0, 3) : 0;
    if ((struct[8] === void 0 || struct[8] === "") && (struct[9] === void 0 || struct[9] === "")) timestamp = +new Date(struct[1], struct[2], struct[3], struct[4], struct[5], struct[6], struct[7]);
    else {
      if (struct[8] !== "Z" && struct[9] !== void 0) {
        minutesOffset = struct[10] * 60 + struct[11];
        if (struct[9] === "+") minutesOffset = 0 - minutesOffset;
      }
      timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);
    }
  } else timestamp = Date.parse ? Date.parse(date2) : NaN;
  return timestamp;
}
let invalidDate = /* @__PURE__ */ new Date("");
let isDate$1 = (obj) => Object.prototype.toString.call(obj) === "[object Date]";
function create$3() {
  return new DateSchema();
}
class DateSchema extends BaseSchema {
  constructor() {
    super({
      type: "date"
    });
    this.withMutation(() => {
      this.transform(function(value) {
        if (this.isType(value)) return value;
        value = parseIsoDate(value);
        return !isNaN(value) ? new Date(value) : invalidDate;
      });
    });
  }
  _typeCheck(v) {
    return isDate$1(v) && !isNaN(v.getTime());
  }
  prepareParam(ref, name) {
    let param;
    if (!Reference.isRef(ref)) {
      let cast = this.cast(ref);
      if (!this._typeCheck(cast)) throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
      param = cast;
    } else {
      param = ref;
    }
    return param;
  }
  min(min2, message2 = date.min) {
    let limit = this.prepareParam(min2, "min");
    return this.test({
      message: message2,
      name: "min",
      exclusive: true,
      params: {
        min: min2
      },
      test(value) {
        return isAbsent(value) || value >= this.resolve(limit);
      }
    });
  }
  max(max2, message2 = date.max) {
    let limit = this.prepareParam(max2, "max");
    return this.test({
      message: message2,
      name: "max",
      exclusive: true,
      params: {
        max: max2
      },
      test(value) {
        return isAbsent(value) || value <= this.resolve(limit);
      }
    });
  }
}
DateSchema.INVALID_DATE = invalidDate;
create$3.prototype = DateSchema.prototype;
create$3.INVALID_DATE = invalidDate;
function arrayReduce$1(array2, iteratee, accumulator, initAccum) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  if (initAccum && length) {
    accumulator = array2[++index2];
  }
  while (++index2 < length) {
    accumulator = iteratee(accumulator, array2[index2], index2, array2);
  }
  return accumulator;
}
var _arrayReduce = arrayReduce$1;
function basePropertyOf$1(object2) {
  return function(key) {
    return object2 == null ? void 0 : object2[key];
  };
}
var _basePropertyOf = basePropertyOf$1;
var basePropertyOf = _basePropertyOf;
var deburredLetters = {
  // Latin-1 Supplement block.
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "C",
  "": "c",
  "": "D",
  "": "d",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "N",
  "": "n",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "Y",
  "": "y",
  "": "y",
  "": "Ae",
  "": "ae",
  "": "Th",
  "": "th",
  "": "ss",
  // Latin Extended-A block.
  "": "A",
  "": "A",
  "": "A",
  "": "a",
  "": "a",
  "": "a",
  "": "C",
  "": "C",
  "": "C",
  "": "C",
  "": "c",
  "": "c",
  "": "c",
  "": "c",
  "": "D",
  "": "D",
  "": "d",
  "": "d",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "G",
  "": "G",
  "": "G",
  "": "G",
  "": "g",
  "": "g",
  "": "g",
  "": "g",
  "": "H",
  "": "H",
  "": "h",
  "": "h",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "J",
  "": "j",
  "": "K",
  "": "k",
  "": "k",
  "": "L",
  "": "L",
  "": "L",
  "": "L",
  "": "L",
  "": "l",
  "": "l",
  "": "l",
  "": "l",
  "": "l",
  "": "N",
  "": "N",
  "": "N",
  "": "N",
  "": "n",
  "": "n",
  "": "n",
  "": "n",
  "": "O",
  "": "O",
  "": "O",
  "": "o",
  "": "o",
  "": "o",
  "": "R",
  "": "R",
  "": "R",
  "": "r",
  "": "r",
  "": "r",
  "": "S",
  "": "S",
  "": "S",
  "": "S",
  "": "s",
  "": "s",
  "": "s",
  "": "s",
  "": "T",
  "": "T",
  "": "T",
  "": "t",
  "": "t",
  "": "t",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "W",
  "": "w",
  "": "Y",
  "": "y",
  "": "Y",
  "": "Z",
  "": "Z",
  "": "Z",
  "": "z",
  "": "z",
  "": "z",
  "": "IJ",
  "": "ij",
  "": "Oe",
  "": "oe",
  "": "'n",
  "": "s"
};
var deburrLetter$1 = basePropertyOf(deburredLetters);
var _deburrLetter = deburrLetter$1;
var deburrLetter = _deburrLetter, toString$3 = toString_1;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3;
var rsCombo$2 = "[" + rsComboRange$3 + "]";
var reComboMark = RegExp(rsCombo$2, "g");
function deburr$1(string2) {
  string2 = toString$3(string2);
  return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
}
var deburr_1 = deburr$1;
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords$1(string2) {
  return string2.match(reAsciiWord) || [];
}
var _asciiWords = asciiWords$1;
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord$1(string2) {
  return reHasUnicodeWord.test(string2);
}
var _hasUnicodeWord = hasUnicodeWord$1;
var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange$2 = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos$1 = "[']", rsBreak = "[" + rsBreakRange + "]", rsCombo$1 = "[" + rsComboRange$2 + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange$2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$1 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$2 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ$2 = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$2 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$2 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsEmoji = "(?:" + [rsDingbat, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsSeq$1;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords$1(string2) {
  return string2.match(reUnicodeWord) || [];
}
var _unicodeWords = unicodeWords$1;
var asciiWords = _asciiWords, hasUnicodeWord = _hasUnicodeWord, toString$2 = toString_1, unicodeWords = _unicodeWords;
function words$1(string2, pattern, guard2) {
  string2 = toString$2(string2);
  pattern = guard2 ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
  }
  return string2.match(pattern) || [];
}
var words_1 = words$1;
var arrayReduce = _arrayReduce, deburr = deburr_1, words = words_1;
var rsApos = "[']";
var reApos = RegExp(rsApos, "g");
function createCompounder$2(callback) {
  return function(string2) {
    return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
  };
}
var _createCompounder = createCompounder$2;
var createCompounder$1 = _createCompounder;
var snakeCase = createCompounder$1(function(result, word, index2) {
  return result + (index2 ? "_" : "") + word.toLowerCase();
});
var snakeCase_1 = snakeCase;
const snakeCase$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(snakeCase_1);
function baseSlice$1(array2, start2, end2) {
  var index2 = -1, length = array2.length;
  if (start2 < 0) {
    start2 = -start2 > length ? 0 : length + start2;
  }
  end2 = end2 > length ? length : end2;
  if (end2 < 0) {
    end2 += length;
  }
  length = start2 > end2 ? 0 : end2 - start2 >>> 0;
  start2 >>>= 0;
  var result = Array(length);
  while (++index2 < length) {
    result[index2] = array2[index2 + start2];
  }
  return result;
}
var _baseSlice = baseSlice$1;
var baseSlice = _baseSlice;
function castSlice$1(array2, start2, end2) {
  var length = array2.length;
  end2 = end2 === void 0 ? length : end2;
  return !start2 && end2 >= length ? array2 : baseSlice(array2, start2, end2);
}
var _castSlice = castSlice$1;
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsZWJ$1 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
function hasUnicode$2(string2) {
  return reHasUnicode.test(string2);
}
var _hasUnicode = hasUnicode$2;
function asciiToArray$1(string2) {
  return string2.split("");
}
var _asciiToArray = asciiToArray$1;
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray$1(string2) {
  return string2.match(reUnicode) || [];
}
var _unicodeToArray = unicodeToArray$1;
var asciiToArray = _asciiToArray, hasUnicode$1 = _hasUnicode, unicodeToArray = _unicodeToArray;
function stringToArray$2(string2) {
  return hasUnicode$1(string2) ? unicodeToArray(string2) : asciiToArray(string2);
}
var _stringToArray = stringToArray$2;
var castSlice = _castSlice, hasUnicode = _hasUnicode, stringToArray$1 = _stringToArray, toString$1 = toString_1;
function createCaseFirst$1(methodName) {
  return function(string2) {
    string2 = toString$1(string2);
    var strSymbols = hasUnicode(string2) ? stringToArray$1(string2) : void 0;
    var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
    return chr[methodName]() + trailing;
  };
}
var _createCaseFirst = createCaseFirst$1;
var createCaseFirst = _createCaseFirst;
var upperFirst$1 = createCaseFirst("toUpperCase");
var upperFirst_1 = upperFirst$1;
var toString = toString_1, upperFirst = upperFirst_1;
function capitalize$1(string2) {
  return upperFirst(toString(string2).toLowerCase());
}
var capitalize_1 = capitalize$1;
var capitalize = capitalize_1, createCompounder = _createCompounder;
var camelCase = createCompounder(function(result, word, index2) {
  word = word.toLowerCase();
  return result + (index2 ? capitalize(word) : word);
});
var camelCase_1 = camelCase;
const camelCase$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(camelCase_1);
var baseAssignValue = _baseAssignValue, baseForOwn = _baseForOwn, baseIteratee = _baseIteratee;
function mapKeys(object2, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee);
  baseForOwn(object2, function(value, key, object3) {
    baseAssignValue(result, iteratee(value, key, object3), value);
  });
  return result;
}
var mapKeys_1 = mapKeys;
const mapKeys$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(mapKeys_1);
var toposort$2 = { exports: {} };
toposort$2.exports = function(edges) {
  return toposort(uniqueNodes(edges), edges);
};
toposort$2.exports.array = toposort;
function toposort(nodes, edges) {
  var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
  edges.forEach(function(edge) {
    if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
      throw new Error("Unknown node. There is an unknown node in the supplied edges.");
    }
  });
  while (i--) {
    if (!visited[i]) visit(nodes[i], i, /* @__PURE__ */ new Set());
  }
  return sorted;
  function visit(node, i2, predecessors) {
    if (predecessors.has(node)) {
      var nodeRep;
      try {
        nodeRep = ", node was:" + JSON.stringify(node);
      } catch (e2) {
        nodeRep = "";
      }
      throw new Error("Cyclic dependency" + nodeRep);
    }
    if (!nodesHash.has(node)) {
      throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node));
    }
    if (visited[i2]) return;
    visited[i2] = true;
    var outgoing = outgoingEdges.get(node) || /* @__PURE__ */ new Set();
    outgoing = Array.from(outgoing);
    if (i2 = outgoing.length) {
      predecessors.add(node);
      do {
        var child = outgoing[--i2];
        visit(child, nodesHash.get(child), predecessors);
      } while (i2);
      predecessors.delete(node);
    }
    sorted[--cursor] = node;
  }
}
function uniqueNodes(arr) {
  var res = /* @__PURE__ */ new Set();
  for (var i = 0, len = arr.length; i < len; i++) {
    var edge = arr[i];
    res.add(edge[0]);
    res.add(edge[1]);
  }
  return Array.from(res);
}
function makeOutgoingEdges(arr) {
  var edges = /* @__PURE__ */ new Map();
  for (var i = 0, len = arr.length; i < len; i++) {
    var edge = arr[i];
    if (!edges.has(edge[0])) edges.set(edge[0], /* @__PURE__ */ new Set());
    if (!edges.has(edge[1])) edges.set(edge[1], /* @__PURE__ */ new Set());
    edges.get(edge[0]).add(edge[1]);
  }
  return edges;
}
function makeNodesHash(arr) {
  var res = /* @__PURE__ */ new Map();
  for (var i = 0, len = arr.length; i < len; i++) {
    res.set(arr[i], i);
  }
  return res;
}
var toposortExports = toposort$2.exports;
const toposort$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(toposortExports);
function sortFields(fields, excludedEdges = []) {
  let edges = [];
  let nodes = /* @__PURE__ */ new Set();
  let excludes = new Set(excludedEdges.map(([a2, b]) => `${a2}-${b}`));
  function addNode2(depPath, key) {
    let node = propertyExpr.split(depPath)[0];
    nodes.add(node);
    if (!excludes.has(`${key}-${node}`)) edges.push([key, node]);
  }
  for (const key in fields) if (has$1(fields, key)) {
    let value = fields[key];
    nodes.add(key);
    if (Reference.isRef(value) && value.isSibling) addNode2(value.path, key);
    else if (isSchema(value) && "deps" in value) value.deps.forEach((path) => addNode2(path, key));
  }
  return toposort$1.array(Array.from(nodes), edges).reverse();
}
function findIndex$1(arr, err) {
  let idx = Infinity;
  arr.some((key, ii) => {
    var _err$path;
    if (((_err$path = err.path) == null ? void 0 : _err$path.indexOf(key)) !== -1) {
      idx = ii;
      return true;
    }
  });
  return idx;
}
function sortByKeyOrder(keys2) {
  return (a2, b) => {
    return findIndex$1(keys2, a2) - findIndex$1(keys2, b);
  };
}
function _extends$5() {
  _extends$5 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$5.apply(this, arguments);
}
let isObject$2 = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
function unknown(ctx, value) {
  let known = Object.keys(ctx.fields);
  return Object.keys(value).filter((key) => known.indexOf(key) === -1);
}
const defaultSort = sortByKeyOrder([]);
class ObjectSchema extends BaseSchema {
  constructor(spec) {
    super({
      type: "object"
    });
    this.fields = /* @__PURE__ */ Object.create(null);
    this._sortErrors = defaultSort;
    this._nodes = [];
    this._excludedEdges = [];
    this.withMutation(() => {
      this.transform(function coerce(value) {
        if (typeof value === "string") {
          try {
            value = JSON.parse(value);
          } catch (err) {
            value = null;
          }
        }
        if (this.isType(value)) return value;
        return null;
      });
      if (spec) {
        this.shape(spec);
      }
    });
  }
  _typeCheck(value) {
    return isObject$2(value) || typeof value === "function";
  }
  _cast(_value, options = {}) {
    var _options$stripUnknown;
    let value = super._cast(_value, options);
    if (value === void 0) return this.getDefault();
    if (!this._typeCheck(value)) return value;
    let fields = this.fields;
    let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
    let props = this._nodes.concat(Object.keys(value).filter((v) => this._nodes.indexOf(v) === -1));
    let intermediateValue = {};
    let innerOptions = _extends$5({}, options, {
      parent: intermediateValue,
      __validating: options.__validating || false
    });
    let isChanged = false;
    for (const prop of props) {
      let field = fields[prop];
      let exists = has$1(value, prop);
      if (field) {
        let fieldValue;
        let inputValue = value[prop];
        innerOptions.path = (options.path ? `${options.path}.` : "") + prop;
        field = field.resolve({
          value: inputValue,
          context: options.context,
          parent: intermediateValue
        });
        let fieldSpec = "spec" in field ? field.spec : void 0;
        let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
        if (fieldSpec == null ? void 0 : fieldSpec.strip) {
          isChanged = isChanged || prop in value;
          continue;
        }
        fieldValue = !options.__validating || !strict ? (
          // TODO: use _cast, this is double resolving
          field.cast(value[prop], innerOptions)
        ) : value[prop];
        if (fieldValue !== void 0) {
          intermediateValue[prop] = fieldValue;
        }
      } else if (exists && !strip) {
        intermediateValue[prop] = value[prop];
      }
      if (intermediateValue[prop] !== value[prop]) {
        isChanged = true;
      }
    }
    return isChanged ? intermediateValue : value;
  }
  _validate(_value, opts = {}, callback) {
    let errors = [];
    let {
      sync,
      from: from2 = [],
      originalValue = _value,
      abortEarly = this.spec.abortEarly,
      recursive = this.spec.recursive
    } = opts;
    from2 = [{
      schema: this,
      value: originalValue
    }, ...from2];
    opts.__validating = true;
    opts.originalValue = originalValue;
    opts.from = from2;
    super._validate(_value, opts, (err, value) => {
      if (err) {
        if (!ValidationError.isError(err) || abortEarly) {
          return void callback(err, value);
        }
        errors.push(err);
      }
      if (!recursive || !isObject$2(value)) {
        callback(errors[0] || null, value);
        return;
      }
      originalValue = originalValue || value;
      let tests = this._nodes.map((key) => (_, cb) => {
        let path = key.indexOf(".") === -1 ? (opts.path ? `${opts.path}.` : "") + key : `${opts.path || ""}["${key}"]`;
        let field = this.fields[key];
        if (field && "validate" in field) {
          field.validate(value[key], _extends$5({}, opts, {
            // @ts-ignore
            path,
            from: from2,
            // inner fields are always strict:
            // 1. this isn't strict so the casting will also have cast inner values
            // 2. this is strict in which case the nested values weren't cast either
            strict: true,
            parent: value,
            originalValue: originalValue[key]
          }), cb);
          return;
        }
        cb(null);
      });
      runTests({
        sync,
        tests,
        value,
        errors,
        endEarly: abortEarly,
        sort: this._sortErrors,
        path: opts.path
      }, callback);
    });
  }
  clone(spec) {
    const next = super.clone(spec);
    next.fields = _extends$5({}, this.fields);
    next._nodes = this._nodes;
    next._excludedEdges = this._excludedEdges;
    next._sortErrors = this._sortErrors;
    return next;
  }
  concat(schema2) {
    let next = super.concat(schema2);
    let nextFields = next.fields;
    for (let [field, schemaOrRef] of Object.entries(this.fields)) {
      const target = nextFields[field];
      if (target === void 0) {
        nextFields[field] = schemaOrRef;
      } else if (target instanceof BaseSchema && schemaOrRef instanceof BaseSchema) {
        nextFields[field] = schemaOrRef.concat(target);
      }
    }
    return next.withMutation(() => next.shape(nextFields, this._excludedEdges));
  }
  getDefaultFromShape() {
    let dft = {};
    this._nodes.forEach((key) => {
      const field = this.fields[key];
      dft[key] = "default" in field ? field.getDefault() : void 0;
    });
    return dft;
  }
  _getDefault() {
    if ("default" in this.spec) {
      return super._getDefault();
    }
    if (!this._nodes.length) {
      return void 0;
    }
    return this.getDefaultFromShape();
  }
  shape(additions, excludes = []) {
    let next = this.clone();
    let fields = Object.assign(next.fields, additions);
    next.fields = fields;
    next._sortErrors = sortByKeyOrder(Object.keys(fields));
    if (excludes.length) {
      if (!Array.isArray(excludes[0])) excludes = [excludes];
      next._excludedEdges = [...next._excludedEdges, ...excludes];
    }
    next._nodes = sortFields(fields, next._excludedEdges);
    return next;
  }
  pick(keys2) {
    const picked = {};
    for (const key of keys2) {
      if (this.fields[key]) picked[key] = this.fields[key];
    }
    return this.clone().withMutation((next) => {
      next.fields = {};
      return next.shape(picked);
    });
  }
  omit(keys2) {
    const next = this.clone();
    const fields = next.fields;
    next.fields = {};
    for (const key of keys2) {
      delete fields[key];
    }
    return next.withMutation(() => next.shape(fields));
  }
  from(from2, to, alias) {
    let fromGetter = propertyExpr.getter(from2, true);
    return this.transform((obj) => {
      if (obj == null) return obj;
      let newObj = obj;
      if (has$1(obj, from2)) {
        newObj = _extends$5({}, obj);
        if (!alias) delete newObj[from2];
        newObj[to] = fromGetter(obj);
      }
      return newObj;
    });
  }
  noUnknown(noAllow = true, message2 = object.noUnknown) {
    if (typeof noAllow === "string") {
      message2 = noAllow;
      noAllow = true;
    }
    let next = this.test({
      name: "noUnknown",
      exclusive: true,
      message: message2,
      test(value) {
        if (value == null) return true;
        const unknownKeys = unknown(this.schema, value);
        return !noAllow || unknownKeys.length === 0 || this.createError({
          params: {
            unknown: unknownKeys.join(", ")
          }
        });
      }
    });
    next.spec.noUnknown = noAllow;
    return next;
  }
  unknown(allow = true, message2 = object.noUnknown) {
    return this.noUnknown(!allow, message2);
  }
  transformKeys(fn2) {
    return this.transform((obj) => obj && mapKeys$1(obj, (_, key) => fn2(key)));
  }
  camelCase() {
    return this.transformKeys(camelCase$1);
  }
  snakeCase() {
    return this.transformKeys(snakeCase$1);
  }
  constantCase() {
    return this.transformKeys((key) => snakeCase$1(key).toUpperCase());
  }
  describe() {
    let base2 = super.describe();
    base2.fields = mapValues$1(this.fields, (value) => value.describe());
    return base2;
  }
}
function create$2(spec) {
  return new ObjectSchema(spec);
}
create$2.prototype = ObjectSchema.prototype;
function _extends$4() {
  _extends$4 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
function create$1(type) {
  return new ArraySchema(type);
}
class ArraySchema extends BaseSchema {
  constructor(type) {
    super({
      type: "array"
    });
    this.innerType = void 0;
    this.innerType = type;
    this.withMutation(() => {
      this.transform(function(values) {
        if (typeof values === "string") try {
          values = JSON.parse(values);
        } catch (err) {
          values = null;
        }
        return this.isType(values) ? values : null;
      });
    });
  }
  _typeCheck(v) {
    return Array.isArray(v);
  }
  get _subType() {
    return this.innerType;
  }
  _cast(_value, _opts) {
    const value = super._cast(_value, _opts);
    if (!this._typeCheck(value) || !this.innerType) return value;
    let isChanged = false;
    const castArray = value.map((v, idx) => {
      const castElement = this.innerType.cast(v, _extends$4({}, _opts, {
        path: `${_opts.path || ""}[${idx}]`
      }));
      if (castElement !== v) {
        isChanged = true;
      }
      return castElement;
    });
    return isChanged ? castArray : value;
  }
  _validate(_value, options = {}, callback) {
    var _options$abortEarly, _options$recursive;
    let errors = [];
    let sync = options.sync;
    let path = options.path;
    let innerType = this.innerType;
    let endEarly = (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly;
    let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;
    let originalValue = options.originalValue != null ? options.originalValue : _value;
    super._validate(_value, options, (err, value) => {
      if (err) {
        if (!ValidationError.isError(err) || endEarly) {
          return void callback(err, value);
        }
        errors.push(err);
      }
      if (!recursive || !innerType || !this._typeCheck(value)) {
        callback(errors[0] || null, value);
        return;
      }
      originalValue = originalValue || value;
      let tests = new Array(value.length);
      for (let idx = 0; idx < value.length; idx++) {
        let item = value[idx];
        let path2 = `${options.path || ""}[${idx}]`;
        let innerOptions = _extends$4({}, options, {
          path: path2,
          strict: true,
          parent: value,
          index: idx,
          originalValue: originalValue[idx]
        });
        tests[idx] = (_, cb) => innerType.validate(item, innerOptions, cb);
      }
      runTests({
        sync,
        path,
        value,
        errors,
        endEarly,
        tests
      }, callback);
    });
  }
  clone(spec) {
    const next = super.clone(spec);
    next.innerType = this.innerType;
    return next;
  }
  concat(schema2) {
    let next = super.concat(schema2);
    next.innerType = this.innerType;
    if (schema2.innerType) next.innerType = next.innerType ? (
      // @ts-expect-error Lazy doesn't have concat()
      next.innerType.concat(schema2.innerType)
    ) : schema2.innerType;
    return next;
  }
  of(schema2) {
    let next = this.clone();
    if (!isSchema(schema2)) throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(schema2));
    next.innerType = schema2;
    return next;
  }
  length(length, message2 = array.length) {
    return this.test({
      message: message2,
      name: "length",
      exclusive: true,
      params: {
        length
      },
      test(value) {
        return isAbsent(value) || value.length === this.resolve(length);
      }
    });
  }
  min(min2, message2) {
    message2 = message2 || array.min;
    return this.test({
      message: message2,
      name: "min",
      exclusive: true,
      params: {
        min: min2
      },
      // FIXME(ts): Array<typeof T>
      test(value) {
        return isAbsent(value) || value.length >= this.resolve(min2);
      }
    });
  }
  max(max2, message2) {
    message2 = message2 || array.max;
    return this.test({
      message: message2,
      name: "max",
      exclusive: true,
      params: {
        max: max2
      },
      test(value) {
        return isAbsent(value) || value.length <= this.resolve(max2);
      }
    });
  }
  ensure() {
    return this.default(() => []).transform((val, original) => {
      if (this._typeCheck(val)) return val;
      return original == null ? [] : [].concat(original);
    });
  }
  compact(rejector) {
    let reject = !rejector ? (v) => !!v : (v, i, a2) => !rejector(v, i, a2);
    return this.transform((values) => values != null ? values.filter(reject) : values);
  }
  describe() {
    let base2 = super.describe();
    if (this.innerType) base2.innerType = this.innerType.describe();
    return base2;
  }
  nullable(isNullable = true) {
    return super.nullable(isNullable);
  }
  defined() {
    return super.defined();
  }
  required(msg) {
    return super.required(msg);
  }
}
create$1.prototype = ArraySchema.prototype;
function addMethod(schemaType, name, fn2) {
  if (!schemaType || !isSchema(schemaType.prototype)) throw new TypeError("You must provide a yup schema constructor function");
  if (typeof fn2 !== "function") throw new TypeError("Method function must be provided");
  schemaType.prototype[name] = fn2;
}
const React$8 = await importShared("react");
const React__default$2 = await importShared("react");
const { useContext: useContext$4, useState: useState$7, useEffect: useEffect$8 } = React__default$2;
const FormexContext = React__default$2.createContext({});
const useFormex = () => {
  return useContext$4(FormexContext);
};
const Formex = FormexContext.Provider;
const isFunction$2 = (obj) => typeof obj === "function";
const isObject$1 = (obj) => obj !== null && typeof obj === "object";
const isInteger = (obj) => String(Math.floor(Number(obj))) === obj;
function getIn(obj, key, def, p2 = 0) {
  const path = toPath(key);
  while (obj && p2 < path.length) {
    obj = obj[path[p2++]];
  }
  if (p2 !== path.length && !obj) {
    return def;
  }
  return obj === void 0 ? def : obj;
}
function setIn(obj, path, value) {
  const res = clone(obj);
  let resVal = res;
  let i = 0;
  const pathArray = toPath(path);
  for (; i < pathArray.length - 1; i++) {
    const currentPath = pathArray[i];
    const currentObj = getIn(obj, pathArray.slice(0, i + 1));
    if (currentObj && (isObject$1(currentObj) || Array.isArray(currentObj))) {
      resVal = resVal[currentPath] = clone(currentObj);
    } else {
      const nextPath = pathArray[i + 1];
      resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};
    }
  }
  if ((i === 0 ? obj : resVal)[pathArray[i]] === value) {
    return obj;
  }
  if (value === void 0) {
    delete resVal[pathArray[i]];
  } else {
    resVal[pathArray[i]] = value;
  }
  if (i === 0 && value === void 0) {
    delete res[pathArray[i]];
  }
  return res;
}
function clone(value) {
  if (Array.isArray(value)) {
    return [...value];
  } else if (typeof value === "object" && value !== null) {
    return {
      ...value
    };
  } else {
    return value;
  }
}
function toPath(value) {
  if (Array.isArray(value)) return value;
  return value.replace(/\[(\d+)]/g, ".$1").replace(/^\./, "").replace(/\.$/, "").split(".");
}
function Field(t0) {
  const $ = c_1(37);
  let children;
  let className;
  let is2;
  let name;
  let props;
  if ($[0] !== t0) {
    const {
      validate,
      name: t12,
      children: t22,
      as: t3,
      className: t4,
      ...t5
    } = t0;
    name = t12;
    children = t22;
    is2 = t3;
    className = t4;
    props = t5;
    $[0] = t0;
    $[1] = children;
    $[2] = className;
    $[3] = is2;
    $[4] = name;
    $[5] = props;
  } else {
    children = $[1];
    className = $[2];
    is2 = $[3];
    name = $[4];
    props = $[5];
  }
  const formex = useFormex();
  let field;
  let t1;
  if ($[6] !== children || $[7] !== formex || $[8] !== name || $[9] !== props) {
    t1 = Symbol.for("react.early_return_sentinel");
    bb0: {
      field = getFieldProps({
        name,
        ...props
      }, formex);
      if (isFunction$2(children)) {
        t1 = children({
          field,
          form: formex
        });
        break bb0;
      }
    }
    $[6] = children;
    $[7] = formex;
    $[8] = name;
    $[9] = props;
    $[10] = field;
    $[11] = t1;
  } else {
    field = $[10];
    t1 = $[11];
  }
  if (t1 !== Symbol.for("react.early_return_sentinel")) {
    return t1;
  }
  const asElement = is2 || "input";
  if (typeof asElement === "string") {
    let innerRef;
    let rest;
    if ($[12] !== props) {
      ({
        innerRef,
        ...rest
      } = props);
      $[12] = props;
      $[13] = innerRef;
      $[14] = rest;
    } else {
      innerRef = $[13];
      rest = $[14];
    }
    let t22;
    if ($[15] !== asElement || $[16] !== children || $[17] !== className || $[18] !== field || $[19] !== innerRef || $[20] !== rest) {
      let t3;
      if ($[22] !== className || $[23] !== field || $[24] !== innerRef || $[25] !== rest) {
        t3 = {
          ref: innerRef,
          ...field,
          ...rest,
          className
        };
        $[22] = className;
        $[23] = field;
        $[24] = innerRef;
        $[25] = rest;
        $[26] = t3;
      } else {
        t3 = $[26];
      }
      t22 = React$8.createElement(asElement, t3, children);
      $[15] = asElement;
      $[16] = children;
      $[17] = className;
      $[18] = field;
      $[19] = innerRef;
      $[20] = rest;
      $[21] = t22;
    } else {
      t22 = $[21];
    }
    return t22;
  }
  let t2;
  if ($[27] !== asElement || $[28] !== children || $[29] !== className || $[30] !== field || $[31] !== props) {
    let t3;
    if ($[33] !== className || $[34] !== field || $[35] !== props) {
      t3 = {
        ...field,
        ...props,
        className
      };
      $[33] = className;
      $[34] = field;
      $[35] = props;
      $[36] = t3;
    } else {
      t3 = $[36];
    }
    t2 = React$8.createElement(asElement, t3, children);
    $[27] = asElement;
    $[28] = children;
    $[29] = className;
    $[30] = field;
    $[31] = props;
    $[32] = t2;
  } else {
    t2 = $[32];
  }
  return t2;
}
const getFieldProps = (nameOrOptions, formex) => {
  const isAnObject = isObject$1(nameOrOptions);
  const name = isAnObject ? nameOrOptions.name : nameOrOptions;
  const valueState = getIn(formex.values, name);
  const field = {
    name,
    value: valueState,
    onChange: formex.handleChange,
    onBlur: formex.handleBlur
  };
  if (isAnObject) {
    const {
      type,
      value: valueProp,
      // value is special for checkboxes
      as: is2,
      multiple
    } = nameOrOptions;
    if (type === "checkbox") {
      if (valueProp === void 0) {
        field.checked = !!valueState;
      } else {
        field.checked = !!(Array.isArray(valueState) && ~valueState.indexOf(valueProp));
        field.value = valueProp;
      }
    } else if (type === "radio") {
      field.checked = valueState === valueProp;
      field.value = valueProp;
    } else if (is2 === "select" && multiple) {
      field.value = field.value || [];
      field.multiple = true;
    }
  }
  return field;
};
function useCreateFormex({
  initialValues,
  initialErrors,
  validation,
  validateOnChange = false,
  onSubmit,
  validateOnInitialRender = false,
  debugId
}) {
  const initialValuesRef = React__default$2.useRef(initialValues);
  const valuesRef = React__default$2.useRef(initialValues);
  const debugIdRef = React__default$2.useRef(debugId);
  const [values, setValuesInner] = useState$7(initialValues);
  const [touchedState, setTouchedState] = useState$7({});
  const [errors, setErrors] = useState$7(initialErrors ?? {});
  const [dirty, setDirty] = useState$7(false);
  const [submitCount, setSubmitCount] = useState$7(0);
  const [isSubmitting, setIsSubmitting] = useState$7(false);
  const [isValidating, setIsValidating] = useState$7(false);
  const [version, setVersion] = useState$7(0);
  useEffect$8(() => {
    if (validateOnInitialRender) {
      validate();
    }
  }, []);
  const setValues = (newValues) => {
    valuesRef.current = newValues;
    setValuesInner(newValues);
    setDirty(equal(initialValuesRef.current, newValues));
  };
  const validate = async () => {
    setIsValidating(true);
    const validationErrors = await validation?.(valuesRef.current);
    setErrors(validationErrors ?? {});
    setIsValidating(false);
    return validationErrors;
  };
  const setFieldValue = (key, value, shouldValidate) => {
    const newValues_0 = setIn(valuesRef.current, key, value);
    valuesRef.current = newValues_0;
    setValuesInner(newValues_0);
    if (!equal(getIn(initialValuesRef.current, key), value)) {
      setDirty(true);
    }
    if (shouldValidate) {
      validate();
    }
  };
  const setFieldError = (key_0, error) => {
    const newErrors = {
      ...errors
    };
    if (error) {
      newErrors[key_0] = error;
    } else {
      delete newErrors[key_0];
    }
    setErrors(newErrors);
  };
  const setFieldTouched = (key_1, touched, shouldValidate_0) => {
    const newTouched = {
      ...touchedState
    };
    newTouched[key_1] = touched;
    setTouchedState(newTouched);
    if (shouldValidate_0) {
      validate();
    }
  };
  const handleChange = (event) => {
    const target = event.target;
    let value_0;
    if (target.type === "checkbox") {
      value_0 = target.checked;
    } else if (target.type === "number") {
      value_0 = target.valueAsNumber;
    } else {
      value_0 = target.value;
    }
    const name = target.name;
    setFieldValue(name, value_0, validateOnChange);
    setFieldTouched(name, true);
  };
  const handleBlur = (event_0) => {
    const target_0 = event_0.target;
    const name_0 = target_0.name;
    setFieldTouched(name_0, true);
  };
  const submit = async (e2) => {
    e2?.preventDefault();
    e2?.stopPropagation();
    setIsSubmitting(true);
    setSubmitCount(submitCount + 1);
    const validationErrors_0 = await validation?.(valuesRef.current);
    if (validationErrors_0 && Object.keys(validationErrors_0).length > 0) {
      setErrors(validationErrors_0);
    } else {
      setErrors({});
      await onSubmit?.(valuesRef.current, controllerRef.current);
    }
    setIsSubmitting(false);
    setVersion(version + 1);
  };
  const resetForm = (props) => {
    const {
      submitCount: submitCountProp,
      values: valuesProp,
      errors: errorsProp,
      touched: touchedProp
    } = props ?? {};
    initialValuesRef.current = valuesProp ?? initialValues;
    valuesRef.current = valuesProp ?? initialValues;
    setValuesInner(valuesProp ?? initialValues);
    setErrors(errorsProp ?? {});
    setTouchedState(touchedProp ?? {});
    setDirty(false);
    setSubmitCount(submitCountProp ?? 0);
    setVersion(version + 1);
  };
  const controller = {
    values,
    initialValues: initialValuesRef.current,
    handleChange,
    isSubmitting,
    setSubmitting: setIsSubmitting,
    setValues,
    setFieldValue,
    errors,
    setFieldError,
    touched: touchedState,
    setFieldTouched,
    dirty,
    setDirty,
    handleSubmit: submit,
    submitCount,
    setSubmitCount,
    handleBlur,
    validate,
    isValidating,
    resetForm,
    version,
    debugId: debugIdRef.current
  };
  const controllerRef = React__default$2.useRef(controller);
  controllerRef.current = controller;
  return controller;
}
function toDate(argument) {
  const argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new argument.constructor(+argument);
  } else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") {
    return new Date(argument);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
}
function constructFrom(date2, value) {
  if (date2 instanceof Date) {
    return new date2.constructor(value);
  } else {
    return new Date(value);
  }
}
const millisecondsInWeek = 6048e5;
const millisecondsInDay = 864e5;
let defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
function startOfWeek(date2, options) {
  const defaultOptions2 = getDefaultOptions();
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
  const _date = toDate(date2);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function startOfISOWeek(date2) {
  return startOfWeek(date2, { weekStartsOn: 1 });
}
function getISOWeekYear(date2) {
  const _date = toDate(date2);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(date2, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(date2, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfDay(date2) {
  const _date = toDate(date2);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function getTimezoneOffsetInMilliseconds(date2) {
  const _date = toDate(date2);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date2 - +utcDate;
}
function differenceInCalendarDays(dateLeft, dateRight) {
  const startOfDayLeft = startOfDay(dateLeft);
  const startOfDayRight = startOfDay(dateRight);
  const timestampLeft = +startOfDayLeft - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  const timestampRight = +startOfDayRight - getTimezoneOffsetInMilliseconds(startOfDayRight);
  return Math.round((timestampLeft - timestampRight) / millisecondsInDay);
}
function startOfISOWeekYear(date2) {
  const year = getISOWeekYear(date2);
  const fourthOfJanuary = constructFrom(date2, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}
function isDate(value) {
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function isValid(date2) {
  if (!isDate(date2) && typeof date2 !== "number") {
    return false;
  }
  const _date = toDate(date2);
  return !isNaN(Number(_date));
}
function startOfYear(date2) {
  const cleanDate = toDate(date2);
  const _date = constructFrom(date2, 0);
  _date.setFullYear(cleanDate.getFullYear(), 0, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
const formatDistanceLocale$1j = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
const formatDistance$1k = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$1j[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
function buildFormatLongFn(args) {
  return (options = {}) => {
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
const dateFormats$1s = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
const timeFormats$1s = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$1s = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$1s = {
  date: buildFormatLongFn({
    formats: dateFormats$1s,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1s,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1s,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$1k = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
const formatRelative$1k = (token, _date, _baseDate, _options) => formatRelativeLocale$1k[token];
function buildLocalizeFn(args) {
  return (value, options) => {
    const context = options?.context ? String(options.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = options?.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = options?.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index2 = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index2];
  };
}
const eraValues$1k = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
const quarterValues$1k = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
const monthValues$1k = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
const dayValues$1k = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
const dayPeriodValues$1k = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
const formattingDayPeriodValues$14 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
const ordinalNumber$1k = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  const rem100 = number2 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number2 + "st";
      case 2:
        return number2 + "nd";
      case 3:
        return number2 + "rd";
    }
  }
  return number2 + "th";
};
const localize$1k = {
  ordinalNumber: ordinalNumber$1k,
  era: buildLocalizeFn({
    values: eraValues$1k,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$1k,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$1k,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$1k,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$1k,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$14,
    defaultFormattingWidth: "wide"
  })
};
function buildMatchFn(args) {
  return (string2, options = {}) => {
    const width = options.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string2.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      options.valueCallback(value)
    ) : value;
    const rest = string2.slice(matchedString.length);
    return { value, rest };
  };
}
function findKey(object2, predicate) {
  for (const key in object2) {
    if (Object.prototype.hasOwnProperty.call(object2, key) && predicate(object2[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array2, predicate) {
  for (let key = 0; key < array2.length; key++) {
    if (predicate(array2[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return (string2, options = {}) => {
    const matchResult = string2.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];
    const parseResult = string2.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    const rest = string2.slice(matchedString.length);
    return { value, rest };
  };
}
const matchOrdinalNumberPattern$1j = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$1j = /\d+/i;
const matchEraPatterns$1j = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
const parseEraPatterns$1j = {
  any: [/^b/i, /^(a|c)/i]
};
const matchQuarterPatterns$1j = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
const parseQuarterPatterns$1j = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$1j = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
const parseMonthPatterns$1j = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$1j = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
const parseDayPatterns$1j = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns$1j = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
const parseDayPeriodPatterns$1j = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
const match$1j = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$1j,
    parsePattern: parseOrdinalNumberPattern$1j,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$1j,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1j,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$1j,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1j,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$1j,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1j,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$1j,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1j,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$1j,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1j,
    defaultParseWidth: "any"
  })
};
const enUS = {
  code: "en-US",
  formatDistance: formatDistance$1k,
  formatLong: formatLong$1s,
  formatRelative: formatRelative$1k,
  localize: localize$1k,
  match: match$1j,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function getDayOfYear(date2) {
  const _date = toDate(date2);
  const diff = differenceInCalendarDays(_date, startOfYear(_date));
  const dayOfYear = diff + 1;
  return dayOfYear;
}
function getISOWeek(date2) {
  const _date = toDate(date2);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}
function getWeekYear(date2, options) {
  const _date = toDate(date2);
  const year = _date.getFullYear();
  const defaultOptions2 = getDefaultOptions();
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
  const firstWeekOfNextYear = constructFrom(date2, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  const firstWeekOfThisYear = constructFrom(date2, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfWeekYear(date2, options) {
  const defaultOptions2 = getDefaultOptions();
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
  const year = getWeekYear(date2, options);
  const firstWeek = constructFrom(date2, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options);
  return _date;
}
function getWeek(date2, options) {
  const _date = toDate(date2);
  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
  return Math.round(diff / millisecondsInWeek) + 1;
}
function addLeadingZeros(number2, targetLength) {
  const sign = number2 < 0 ? "-" : "";
  const output = Math.abs(number2).toString().padStart(targetLength, "0");
  return sign + output;
}
const lightFormatters = {
  // Year
  y(date2, token) {
    const signedYear = date2.getFullYear();
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  // Month
  M(date2, token) {
    const month = date2.getMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d(date2, token) {
    return addLeadingZeros(date2.getDate(), token.length);
  },
  // AM or PM
  a(date2, token) {
    const dayPeriodEnumValue = date2.getHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(date2, token) {
    return addLeadingZeros(date2.getHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H(date2, token) {
    return addLeadingZeros(date2.getHours(), token.length);
  },
  // Minute
  m(date2, token) {
    return addLeadingZeros(date2.getMinutes(), token.length);
  },
  // Second
  s(date2, token) {
    return addLeadingZeros(date2.getSeconds(), token.length);
  },
  // Fraction of second
  S(date2, token) {
    const numberOfDigits = token.length;
    const milliseconds = date2.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3)
    );
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
const dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
const formatters = {
  // Era
  G: function(date2, token, localize2) {
    const era = date2.getFullYear() > 0 ? 1 : 0;
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, { width: "abbreviated" });
      case "GGGGG":
        return localize2.era(era, { width: "narrow" });
      case "GGGG":
      default:
        return localize2.era(era, { width: "wide" });
    }
  },
  // Year
  y: function(date2, token, localize2) {
    if (token === "yo") {
      const signedYear = date2.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, { unit: "year" });
    }
    return lightFormatters.y(date2, token);
  },
  // Local week-numbering year
  Y: function(date2, token, localize2, options) {
    const signedWeekYear = getWeekYear(date2, options);
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      const twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, { unit: "year" });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function(date2, token) {
    const isoWeekYear = getISOWeekYear(date2);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(date2, token) {
    const year = date2.getFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function(date2, token, localize2) {
    const quarter = Math.ceil((date2.getMonth() + 1) / 3);
    switch (token) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(date2, token, localize2) {
    const quarter = Math.ceil((date2.getMonth() + 1) / 3);
    switch (token) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(date2, token, localize2) {
    const month = date2.getMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters.M(date2, token);
      case "Mo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(date2, token, localize2) {
    const month = date2.getMonth();
    switch (token) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(date2, token, localize2, options) {
    const week2 = getWeek(date2, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week2, { unit: "week" });
    }
    return addLeadingZeros(week2, token.length);
  },
  // ISO week of year
  I: function(date2, token, localize2) {
    const isoWeek = getISOWeek(date2);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, { unit: "week" });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function(date2, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date2.getDate(), { unit: "date" });
    }
    return lightFormatters.d(date2, token);
  },
  // Day of year
  D: function(date2, token, localize2) {
    const dayOfYear = getDayOfYear(date2);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function(date2, token, localize2) {
    const dayOfWeek = date2.getDay();
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(date2, token, localize2, options) {
    const dayOfWeek = date2.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(date2, token, localize2, options) {
    const dayOfWeek = date2.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(date2, token, localize2) {
    const dayOfWeek = date2.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(date2, token, localize2) {
    const hours = date2.getHours();
    const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(date2, token, localize2) {
    const hours = date2.getHours();
    let dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(date2, token, localize2) {
    const hours = date2.getHours();
    let dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(date2, token, localize2) {
    if (token === "ho") {
      let hours = date2.getHours() % 12;
      if (hours === 0) hours = 12;
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return lightFormatters.h(date2, token);
  },
  // Hour [0-23]
  H: function(date2, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date2.getHours(), { unit: "hour" });
    }
    return lightFormatters.H(date2, token);
  },
  // Hour [0-11]
  K: function(date2, token, localize2) {
    const hours = date2.getHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function(date2, token, localize2) {
    let hours = date2.getHours();
    if (hours === 0) hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function(date2, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date2.getMinutes(), { unit: "minute" });
    }
    return lightFormatters.m(date2, token);
  },
  // Second
  s: function(date2, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date2.getSeconds(), { unit: "second" });
    }
    return lightFormatters.s(date2, token);
  },
  // Fraction of second
  S: function(date2, token) {
    return lightFormatters.S(date2, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date2, token, _localize) {
    const timezoneOffset = date2.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date2, token, _localize) {
    const timezoneOffset = date2.getTimezoneOffset();
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date2, token, _localize) {
    const timezoneOffset = date2.getTimezoneOffset();
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date2, token, _localize) {
    const timezoneOffset = date2.getTimezoneOffset();
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function(date2, token, _localize) {
    const timestamp = Math.trunc(date2.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function(date2, token, _localize) {
    const timestamp = date2.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset3, delimiter = "") {
  const sign = offset3 > 0 ? "-" : "+";
  const absOffset = Math.abs(offset3);
  const hours = Math.trunc(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset3, delimiter) {
  if (offset3 % 60 === 0) {
    const sign = offset3 > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset3) / 60, 2);
  }
  return formatTimezone(offset3, delimiter);
}
function formatTimezone(offset3, delimiter = "") {
  const sign = offset3 > 0 ? "-" : "+";
  const absOffset = Math.abs(offset3);
  const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
  const minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
const dateLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "P":
      return formatLong2.date({ width: "short" });
    case "PP":
      return formatLong2.date({ width: "medium" });
    case "PPP":
      return formatLong2.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong2.date({ width: "full" });
  }
};
const timeLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "p":
      return formatLong2.time({ width: "short" });
    case "pp":
      return formatLong2.time({ width: "medium" });
    case "ppp":
      return formatLong2.time({ width: "long" });
    case "pppp":
    default:
      return formatLong2.time({ width: "full" });
  }
};
const dateTimeLongFormatter = (pattern, formatLong2) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  let dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({ width: "full" });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
const longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
const dayOfYearTokenRE = /^D+$/;
const weekYearTokenRE = /^Y+$/;
const throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return dayOfYearTokenRE.test(token);
}
function isProtectedWeekYearToken(token) {
  return weekYearTokenRE.test(token);
}
function warnOrThrowProtectedError(token, format2, input) {
  const _message = message(token, format2, input);
  console.warn(_message);
  if (throwTokens.includes(token)) throw new RangeError(_message);
}
function message(token, format2, input) {
  const subject = token[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(date2, formatStr, options) {
  const defaultOptions2 = getDefaultOptions();
  const locale = options?.locale ?? defaultOptions2.locale ?? enUS;
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
  const originalDate = toDate(date2);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map((substring) => {
    if (substring === "''") {
      return { isToken: false, value: "'" };
    }
    const firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return { isToken: false, value: cleanEscapedString(substring) };
    }
    if (formatters[firstCharacter]) {
      return { isToken: true, value: substring };
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
      );
    }
    return { isToken: false, value: substring };
  });
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts);
  }
  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale
  };
  return parts.map((part) => {
    if (!part.isToken) return part.value;
    const token = part.value;
    if (!options?.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token) || !options?.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, String(date2));
    }
    const formatter = formatters[token[0]];
    return formatter(originalDate, token, locale.localize, formatterOptions);
  }).join("");
}
function cleanEscapedString(input) {
  const matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}
function isSameWeek(dateLeft, dateRight, options) {
  const dateLeftStartOfWeek = startOfWeek(dateLeft, options);
  const dateRightStartOfWeek = startOfWeek(dateRight, options);
  return +dateLeftStartOfWeek === +dateRightStartOfWeek;
}
const formatDistanceLocale$1i = {
  lessThanXSeconds: {
    one: "minder as 'n sekonde",
    other: "minder as {{count}} sekondes"
  },
  xSeconds: {
    one: "1 sekonde",
    other: "{{count}} sekondes"
  },
  halfAMinute: "'n halwe minuut",
  lessThanXMinutes: {
    one: "minder as 'n minuut",
    other: "minder as {{count}} minute"
  },
  xMinutes: {
    one: "'n minuut",
    other: "{{count}} minute"
  },
  aboutXHours: {
    one: "ongeveer 1 uur",
    other: "ongeveer {{count}} ure"
  },
  xHours: {
    one: "1 uur",
    other: "{{count}} ure"
  },
  xDays: {
    one: "1 dag",
    other: "{{count}} dae"
  },
  aboutXWeeks: {
    one: "ongeveer 1 week",
    other: "ongeveer {{count}} weke"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weke"
  },
  aboutXMonths: {
    one: "ongeveer 1 maand",
    other: "ongeveer {{count}} maande"
  },
  xMonths: {
    one: "1 maand",
    other: "{{count}} maande"
  },
  aboutXYears: {
    one: "ongeveer 1 jaar",
    other: "ongeveer {{count}} jaar"
  },
  xYears: {
    one: "1 jaar",
    other: "{{count}} jaar"
  },
  overXYears: {
    one: "meer as 1 jaar",
    other: "meer as {{count}} jaar"
  },
  almostXYears: {
    one: "byna 1 jaar",
    other: "byna {{count}} jaar"
  }
};
const formatDistance$1j = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$1i[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "oor " + result;
    } else {
      return result + " gelede";
    }
  }
  return result;
};
const dateFormats$1r = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "yyyy/MM/dd"
};
const timeFormats$1r = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$1r = {
  full: "{{date}} 'om' {{time}}",
  long: "{{date}} 'om' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$1r = {
  date: buildFormatLongFn({
    formats: dateFormats$1r,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1r,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1r,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$1j = {
  lastWeek: "'verlede' eeee 'om' p",
  yesterday: "'gister om' p",
  today: "'vandag om' p",
  tomorrow: "'mre om' p",
  nextWeek: "eeee 'om' p",
  other: "P"
};
const formatRelative$1j = (token, _date, _baseDate, _options) => formatRelativeLocale$1j[token];
const eraValues$1j = {
  narrow: ["vC", "nC"],
  abbreviated: ["vC", "nC"],
  wide: ["voor Christus", "na Christus"]
};
const quarterValues$1j = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1ste kwartaal", "2de kwartaal", "3de kwartaal", "4de kwartaal"]
};
const monthValues$1j = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mrt",
    "Apr",
    "Mei",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Okt",
    "Nov",
    "Des"
  ],
  wide: [
    "Januarie",
    "Februarie",
    "Maart",
    "April",
    "Mei",
    "Junie",
    "Julie",
    "Augustus",
    "September",
    "Oktober",
    "November",
    "Desember"
  ]
};
const dayValues$1j = {
  narrow: ["S", "M", "D", "W", "D", "V", "S"],
  short: ["So", "Ma", "Di", "Wo", "Do", "Vr", "Sa"],
  abbreviated: ["Son", "Maa", "Din", "Woe", "Don", "Vry", "Sat"],
  wide: [
    "Sondag",
    "Maandag",
    "Dinsdag",
    "Woensdag",
    "Donderdag",
    "Vrydag",
    "Saterdag"
  ]
};
const dayPeriodValues$1j = {
  narrow: {
    am: "vm",
    pm: "nm",
    midnight: "middernag",
    noon: "middaguur",
    morning: "oggend",
    afternoon: "middag",
    evening: "laat middag",
    night: "aand"
  },
  abbreviated: {
    am: "vm",
    pm: "nm",
    midnight: "middernag",
    noon: "middaguur",
    morning: "oggend",
    afternoon: "middag",
    evening: "laat middag",
    night: "aand"
  },
  wide: {
    am: "vm",
    pm: "nm",
    midnight: "middernag",
    noon: "middaguur",
    morning: "oggend",
    afternoon: "middag",
    evening: "laat middag",
    night: "aand"
  }
};
const formattingDayPeriodValues$13 = {
  narrow: {
    am: "vm",
    pm: "nm",
    midnight: "middernag",
    noon: "uur die middag",
    morning: "uur die oggend",
    afternoon: "uur die middag",
    evening: "uur die aand",
    night: "uur die aand"
  },
  abbreviated: {
    am: "vm",
    pm: "nm",
    midnight: "middernag",
    noon: "uur die middag",
    morning: "uur die oggend",
    afternoon: "uur die middag",
    evening: "uur die aand",
    night: "uur die aand"
  },
  wide: {
    am: "vm",
    pm: "nm",
    midnight: "middernag",
    noon: "uur die middag",
    morning: "uur die oggend",
    afternoon: "uur die middag",
    evening: "uur die aand",
    night: "uur die aand"
  }
};
const ordinalNumber$1j = (dirtyNumber) => {
  const number2 = Number(dirtyNumber);
  const rem100 = number2 % 100;
  if (rem100 < 20) {
    switch (rem100) {
      case 1:
      case 8:
        return number2 + "ste";
      default:
        return number2 + "de";
    }
  }
  return number2 + "ste";
};
const localize$1j = {
  ordinalNumber: ordinalNumber$1j,
  era: buildLocalizeFn({
    values: eraValues$1j,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$1j,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$1j,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$1j,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$1j,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$13,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$1i = /^(\d+)(ste|de)?/i;
const parseOrdinalNumberPattern$1i = /\d+/i;
const matchEraPatterns$1i = {
  narrow: /^([vn]\.? ?C\.?)/,
  abbreviated: /^([vn]\. ?C\.?)/,
  wide: /^((voor|na) Christus)/
};
const parseEraPatterns$1i = {
  any: [/^v/, /^n/]
};
const matchQuarterPatterns$1i = {
  narrow: /^[1234]/i,
  abbreviated: /^K[1234]/i,
  wide: /^[1234](st|d)e kwartaal/i
};
const parseQuarterPatterns$1i = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$1i = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(Jan|Feb|Mrt|Apr|Mei|Jun|Jul|Aug|Sep|Okt|Nov|Dec)\.?/i,
  wide: /^(Januarie|Februarie|Maart|April|Mei|Junie|Julie|Augustus|September|Oktober|November|Desember)/i
};
const parseMonthPatterns$1i = {
  narrow: [
    /^J/i,
    /^F/i,
    /^M/i,
    /^A/i,
    /^M/i,
    /^J/i,
    /^J/i,
    /^A/i,
    /^S/i,
    /^O/i,
    /^N/i,
    /^D/i
  ],
  any: [
    /^Jan/i,
    /^Feb/i,
    /^Mrt/i,
    /^Apr/i,
    /^Mei/i,
    /^Jun/i,
    /^Jul/i,
    /^Aug/i,
    /^Sep/i,
    /^Okt/i,
    /^Nov/i,
    /^Dec/i
  ]
};
const matchDayPatterns$1i = {
  narrow: /^[smdwv]/i,
  short: /^(So|Ma|Di|Wo|Do|Vr|Sa)/i,
  abbreviated: /^(Son|Maa|Din|Woe|Don|Vry|Sat)/i,
  wide: /^(Sondag|Maandag|Dinsdag|Woensdag|Donderdag|Vrydag|Saterdag)/i
};
const parseDayPatterns$1i = {
  narrow: [/^S/i, /^M/i, /^D/i, /^W/i, /^D/i, /^V/i, /^S/i],
  any: [/^So/i, /^Ma/i, /^Di/i, /^Wo/i, /^Do/i, /^Vr/i, /^Sa/i]
};
const matchDayPeriodPatterns$1i = {
  any: /^(vm|nm|middernag|(?:uur )?die (oggend|middag|aand))/i
};
const parseDayPeriodPatterns$1i = {
  any: {
    am: /^vm/i,
    pm: /^nm/i,
    midnight: /^middernag/i,
    noon: /^middaguur/i,
    morning: /oggend/i,
    afternoon: /middag/i,
    evening: /laat middag/i,
    night: /aand/i
  }
};
const match$1i = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$1i,
    parsePattern: parseOrdinalNumberPattern$1i,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$1i,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1i,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$1i,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1i,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$1i,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1i,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$1i,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1i,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$1i,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1i,
    defaultParseWidth: "any"
  })
};
const af = {
  code: "af",
  formatDistance: formatDistance$1j,
  formatLong: formatLong$1r,
  formatRelative: formatRelative$1j,
  localize: localize$1j,
  match: match$1i,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$1h = {
  lessThanXSeconds: {
    one: "  ",
    two: "  ",
    threeToTen: "  {{count}} ",
    other: "  {{count}} "
  },
  xSeconds: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  halfAMinute: " ",
  lessThanXMinutes: {
    one: "  ",
    two: "  ",
    threeToTen: "  {{count}} ",
    other: "  {{count}} "
  },
  xMinutes: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: "  ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  },
  xHours: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  xDays: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: "  ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  },
  xWeeks: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: "  ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  },
  xMonths: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: "  ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  },
  xYears: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  overXYears: {
    one: "  ",
    two: "  ",
    threeToTen: "  {{count}} ",
    other: "  {{count}} "
  },
  almostXYears: {
    one: "   ",
    two: "  ",
    threeToTen: "  {{count}} ",
    other: "  {{count}} "
  }
};
const formatDistance$1i = (token, count, options) => {
  const usageGroup = formatDistanceLocale$1h[token];
  let result;
  if (typeof usageGroup === "string") {
    result = usageGroup;
  } else if (count === 1) {
    result = usageGroup.one;
  } else if (count === 2) {
    result = usageGroup.two;
  } else if (count <= 10) {
    result = usageGroup.threeToTen.replace("{{count}}", String(count));
  } else {
    result = usageGroup.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return " " + result;
    } else {
      return " " + result;
    }
  }
  return result;
};
const dateFormats$1q = {
  full: "EEEE do MMMM y",
  long: "do MMMM y",
  medium: "d MMM y",
  short: "dd/MM/yyyy"
};
const timeFormats$1q = {
  full: "HH:mm:ss",
  long: "HH:mm:ss",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$1q = {
  full: "{{date}} ' ' {{time}}",
  long: "{{date}} ' ' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$1q = {
  date: buildFormatLongFn({
    formats: dateFormats$1q,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1q,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1q,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$1i = {
  lastWeek: "eeee '  ' p",
  yesterday: "'  ' p",
  today: "'  ' p",
  tomorrow: "'  ' p",
  nextWeek: "eeee '  ' p",
  other: "P"
};
const formatRelative$1i = (token) => formatRelativeLocale$1i[token];
const eraValues$1i = {
  narrow: ["", ""],
  abbreviated: ["..", ".."],
  wide: [" ", " "]
};
const quarterValues$1i = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1", "2", "3", "4"],
  wide: [" ", " ", " ", " "]
};
const monthValues$1i = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$1i = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$1i = {
  narrow: {
    am: "",
    pm: "",
    morning: "",
    noon: "",
    afternoon: " ",
    evening: "",
    night: "",
    midnight: " "
  },
  abbreviated: {
    am: "",
    pm: "",
    morning: "",
    noon: "",
    afternoon: " ",
    evening: "",
    night: "",
    midnight: " "
  },
  wide: {
    am: "",
    pm: "",
    morning: "",
    noon: "",
    afternoon: " ",
    evening: "",
    night: "",
    midnight: " "
  }
};
const formattingDayPeriodValues$12 = {
  narrow: {
    am: "",
    pm: "",
    morning: " ",
    noon: "",
    afternoon: " ",
    evening: " ",
    night: " ",
    midnight: " "
  },
  abbreviated: {
    am: "",
    pm: "",
    morning: " ",
    noon: "",
    afternoon: " ",
    evening: " ",
    night: " ",
    midnight: " "
  },
  wide: {
    am: "",
    pm: "",
    morning: " ",
    noon: "",
    afternoon: " ",
    evening: " ",
    night: " ",
    midnight: " "
  }
};
const ordinalNumber$1i = (num) => String(num);
const localize$1i = {
  ordinalNumber: ordinalNumber$1i,
  era: buildLocalizeFn({
    values: eraValues$1i,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$1i,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$1i,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$1i,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$1i,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$12,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$1h = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$1h = /\d+/i;
const matchEraPatterns$1h = {
  narrow: /[]/,
  abbreviated: /[]\.\./,
  wide: /(|) /
};
const parseEraPatterns$1h = {
  any: [//, //]
};
const matchQuarterPatterns$1h = {
  narrow: /^[1234]/i,
  abbreviated: /[1234]/,
  wide: / (|||)/
};
const parseQuarterPatterns$1h = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$1h = {
  narrow: /^[]/,
  abbreviated: /^(|||||||||||)/,
  wide: /^(|||||||||||)/
};
const parseMonthPatterns$1h = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$1h = {
  narrow: /^[]/i,
  short: /^(||||||)/i,
  abbreviated: /^(||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$1h = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  wide: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$1h = {
  narrow: /^(|| || | | | )/,
  any: /^(|| || | | | )/
};
const parseDayPeriodPatterns$1h = {
  any: {
    am: /^/,
    pm: /^/,
    midnight: / /,
    noon: //,
    afternoon: / /,
    morning: / /,
    evening: / /,
    night: / /
  }
};
const match$1h = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$1h,
    parsePattern: parseOrdinalNumberPattern$1h,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$1h,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1h,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$1h,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1h,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$1h,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1h,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$1h,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1h,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$1h,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1h,
    defaultParseWidth: "any"
  })
};
const ar = {
  code: "ar",
  formatDistance: formatDistance$1i,
  formatLong: formatLong$1q,
  formatRelative: formatRelative$1i,
  localize: localize$1i,
  match: match$1h,
  options: {
    weekStartsOn: 6,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$1g = {
  lessThanXSeconds: {
    one: "   ",
    two: "  ",
    threeToTen: "  {{count}} ",
    other: "  {{count}} "
  },
  xSeconds: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  halfAMinute: " ",
  lessThanXMinutes: {
    one: "  ",
    two: "  ",
    threeToTen: "  {{count}} ",
    other: "  {{count}} "
  },
  xMinutes: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: "  ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  },
  xHours: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  xDays: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: "  ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  },
  xWeeks: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: "  ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  },
  xMonths: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: "  ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  },
  xYears: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  overXYears: {
    one: "  ",
    two: "  ",
    threeToTen: "  {{count}} ",
    other: "  {{count}} "
  },
  almostXYears: {
    one: "  ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  }
};
const formatDistance$1h = (token, count, options) => {
  options = options || {};
  const usageGroup = formatDistanceLocale$1g[token];
  let result;
  if (typeof usageGroup === "string") {
    result = usageGroup;
  } else if (count === 1) {
    result = usageGroup.one;
  } else if (count === 2) {
    result = usageGroup.two;
  } else if (count <= 10) {
    result = usageGroup.threeToTen.replace("{{count}}", String(count));
  } else {
    result = usageGroup.other.replace("{{count}}", String(count));
  }
  if (options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "  " + result;
    } else {
      return " " + result;
    }
  }
  return result;
};
const dateFormats$1p = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
const timeFormats$1p = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$1p = {
  full: "{{date}} '' {{time}}",
  long: "{{date}} '' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$1p = {
  date: buildFormatLongFn({
    formats: dateFormats$1p,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1p,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1p,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$1h = {
  lastWeek: "'' eeee '' p",
  yesterday: "' ' p",
  today: "' ' p",
  tomorrow: "' ' p",
  nextWeek: "eeee '' p",
  other: "P"
};
const formatRelative$1h = (token, _date, _baseDate, _options) => {
  return formatRelativeLocale$1h[token];
};
const eraValues$1h = {
  narrow: ["", ""],
  abbreviated: ["..", ".."],
  wide: [" ", " "]
};
const quarterValues$1h = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1", "2", "3", "4"],
  wide: [" ", " ", " ", " "]
};
const monthValues$1h = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$1h = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$1h = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$11 = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: " ",
    afternoon: " ",
    evening: " ",
    night: " "
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: " ",
    afternoon: " ",
    evening: " ",
    night: " "
  },
  wide: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: " ",
    night: " "
  }
};
const ordinalNumber$1h = (dirtyNumber) => {
  return String(dirtyNumber);
};
const localize$1h = {
  ordinalNumber: ordinalNumber$1h,
  era: buildLocalizeFn({
    values: eraValues$1h,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$1h,
    defaultWidth: "wide",
    argumentCallback: (quarter) => Number(quarter) - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$1h,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$1h,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$1h,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$11,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$1g = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$1g = /\d+/i;
const matchEraPatterns$1g = {
  narrow: /^(|)/i,
  abbreviated: /^(\.?\s?\.?|\.?\s?\.?\s?|a\.?\s?d\.?|c\.?\s?)/i,
  wide: /^( | | | )/i
};
const parseEraPatterns$1g = {
  any: [/^/i, /^/i]
};
const matchQuarterPatterns$1g = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]/i,
  wide: /^ [1234]/i
};
const parseQuarterPatterns$1g = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$1g = {
  narrow: /^[]/i,
  abbreviated: /^(|||||||||||)/i,
  wide: /^(|||||||||||)/i
};
const parseMonthPatterns$1g = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$1g = {
  narrow: /^[]/i,
  short: /^(||||||)/i,
  abbreviated: /^(||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$1g = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  wide: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$1g = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
const parseDayPeriodPatterns$1g = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
const match$1g = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$1g,
    parsePattern: parseOrdinalNumberPattern$1g,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$1g,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1g,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$1g,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1g,
    defaultParseWidth: "any",
    valueCallback: (index2) => Number(index2) + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$1g,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1g,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$1g,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1g,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$1g,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1g,
    defaultParseWidth: "any"
  })
};
const arDZ = {
  code: "ar-DZ",
  formatDistance: formatDistance$1h,
  formatLong: formatLong$1p,
  formatRelative: formatRelative$1h,
  localize: localize$1h,
  match: match$1g,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$1f = {
  lessThanXSeconds: {
    one: "  ",
    two: "  ",
    threeToTen: "  {{count}} ",
    other: "  {{count}} "
  },
  xSeconds: {
    one: "",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  halfAMinute: " ",
  lessThanXMinutes: {
    one: "  ",
    two: "  ",
    threeToTen: "  {{count}} ",
    other: "  {{count}} "
  },
  xMinutes: {
    one: "",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: " ",
    two: " ",
    threeToTen: " {{count}} ",
    other: " {{count}} "
  },
  xHours: {
    one: "",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  xDays: {
    one: "",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: " ",
    two: " ",
    threeToTen: " {{count}} ",
    other: " {{count}} "
  },
  xWeeks: {
    one: "",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: " ",
    two: " ",
    threeToTen: " {{count}} ",
    other: " {{count}} "
  },
  xMonths: {
    one: "",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: " ",
    two: " ",
    threeToTen: " {{count}} ",
    other: " {{count}} "
  },
  xYears: {
    one: "",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  overXYears: {
    one: "  ",
    two: "  ",
    threeToTen: "  {{count}} ",
    other: "  {{count}} "
  },
  almostXYears: {
    one: " ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  }
};
const formatDistance$1g = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$1f[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 2) {
    result = tokenValue.two;
  } else if (count <= 10) {
    result = tokenValue.threeToTen.replace("{{count}}", String(count));
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return `  ${result}`;
    } else {
      return ` ${result}`;
    }
  }
  return result;
};
const dateFormats$1o = {
  full: "EEEE do MMMM y",
  long: "do MMMM y",
  medium: "dd/MMM/y",
  short: "d/MM/y"
};
const timeFormats$1o = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$1o = {
  full: "{{date}} '' {{time}}",
  long: "{{date}} '' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$1o = {
  date: buildFormatLongFn({
    formats: dateFormats$1o,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1o,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1o,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$1g = {
  lastWeek: "eeee '  ' p",
  yesterday: "' ' p",
  today: "' ' p",
  tomorrow: "' ' p",
  nextWeek: "eeee '' p",
  other: "P"
};
const formatRelative$1g = (token, _date, _baseDate, _options) => formatRelativeLocale$1g[token];
const eraValues$1g = {
  narrow: ["", ""],
  abbreviated: [".", "."],
  wide: [" ", " "]
};
const quarterValues$1g = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1", "2", "3", "4"],
  wide: [" ", " ", " ", " "]
};
const monthValues$1g = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$1g = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$1g = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$10 = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: " ",
    afternoon: " ",
    evening: " ",
    night: " "
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: " ",
    afternoon: " ",
    evening: " ",
    night: " "
  },
  wide: {
    am: "",
    pm: "",
    midnight: " ",
    morning: " ",
    noon: "",
    afternoon: " ",
    evening: " ",
    night: " "
  }
};
const ordinalNumber$1g = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
const localize$1g = {
  ordinalNumber: ordinalNumber$1g,
  era: buildLocalizeFn({
    values: eraValues$1g,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$1g,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$1g,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$1g,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$1g,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$10,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$1f = /^(\d+)/;
const parseOrdinalNumberPattern$1f = /\d+/i;
const matchEraPatterns$1f = {
  narrow: /^(|)/g,
  abbreviated: /^(.|.)/g,
  wide: /^( | )/g
};
const parseEraPatterns$1f = {
  any: [/^/g, /^/g]
};
const matchQuarterPatterns$1f = {
  narrow: /^[1234]/,
  abbreviated: /^[1234]/,
  wide: /^ (|||)/
};
const parseQuarterPatterns$1f = {
  wide: [/ /, / /, / /, / /],
  any: [/1/, /2/, /3/, /4/]
};
const matchMonthPatterns$1f = {
  narrow: /^(||||||)/,
  abbreviated: /^(|||||||||||)/,
  wide: /^(|||||||||||)/
};
const parseMonthPatterns$1f = {
  narrow: [
    /^/,
    /^/,
    /^/,
    /^/,
    /^/,
    /^/,
    /^/,
    /^/,
    /^/,
    /^/,
    /^/,
    /^/
  ],
  any: [
    /^/,
    /^/,
    /^/,
    /^/,
    /^/,
    /^/,
    /^/,
    /^/,
    /^/,
    /^/,
    /^/,
    /^/
  ]
};
const matchDayPatterns$1f = {
  narrow: /^(||||||)/,
  short: /^(||||||)/,
  abbreviated: /^(||||||)/,
  wide: /^(||||||)/
};
const parseDayPatterns$1f = {
  narrow: [/^/, /^/, /^/, /^/, /^/, /^/, /^/],
  any: [//, //, //, //, //, //, //]
};
const matchDayPeriodPatterns$1f = {
  narrow: /^(|||| | | | )/,
  abbreviated: /^(|| || | | | )/,
  wide: /^(|| | || | | )/,
  any: /^(|||||)/
};
const parseDayPeriodPatterns$1f = {
  any: {
    am: /^/,
    pm: /^/,
    midnight: /^/,
    noon: /^/,
    morning: /^/,
    afternoon: /^/,
    evening: /^/,
    night: /^/
  }
};
const match$1f = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$1f,
    parsePattern: parseOrdinalNumberPattern$1f,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$1f,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1f,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$1f,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1f,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$1f,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1f,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$1f,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1f,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$1f,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1f,
    defaultParseWidth: "any"
  })
};
const arEG = {
  code: "ar-EG",
  formatDistance: formatDistance$1g,
  formatLong: formatLong$1o,
  formatRelative: formatRelative$1g,
  localize: localize$1g,
  match: match$1f,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$1e = {
  lessThanXSeconds: {
    one: "   ",
    two: "  ",
    threeToTen: "  {{count}} ",
    other: "  {{count}} "
  },
  xSeconds: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  halfAMinute: " ",
  lessThanXMinutes: {
    one: "  ",
    two: "  ",
    threeToTen: "  {{count}} ",
    other: "  {{count}} "
  },
  xMinutes: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: "  ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  },
  xHours: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  xDays: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: "  ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  },
  xWeeks: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: "  ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  },
  xMonths: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: "  ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  },
  xYears: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  overXYears: {
    one: "  ",
    two: "  ",
    threeToTen: "  {{count}} ",
    other: "  {{count}} "
  },
  almostXYears: {
    one: "  ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  }
};
const formatDistance$1f = (token, count, options) => {
  options = options || {};
  const usageGroup = formatDistanceLocale$1e[token];
  let result;
  if (typeof usageGroup === "string") {
    result = usageGroup;
  } else if (count === 1) {
    result = usageGroup.one;
  } else if (count === 2) {
    result = usageGroup.two;
  } else if (count <= 10) {
    result = usageGroup.threeToTen.replace("{{count}}", String(count));
  } else {
    result = usageGroup.other.replace("{{count}}", String(count));
  }
  if (options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "  " + result;
    } else {
      return " " + result;
    }
  }
  return result;
};
const dateFormats$1n = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
const timeFormats$1n = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$1n = {
  full: "{{date}} '' {{time}}",
  long: "{{date}} '' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$1n = {
  date: buildFormatLongFn({
    formats: dateFormats$1n,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1n,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1n,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$1f = {
  lastWeek: "'' eeee '' p",
  yesterday: "' ' p",
  today: "' ' p",
  tomorrow: "' ' p",
  nextWeek: "eeee '' p",
  other: "P"
};
const formatRelative$1f = (token, _date, _baseDate, _options) => {
  return formatRelativeLocale$1f[token];
};
const eraValues$1f = {
  narrow: ["", ""],
  abbreviated: ["..", ".."],
  wide: [" ", " "]
};
const quarterValues$1f = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1", "2", "3", "4"],
  wide: [" ", " ", " ", " "]
};
const monthValues$1f = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$1f = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$1f = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$$ = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: " ",
    afternoon: " ",
    evening: " ",
    night: " "
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: " ",
    afternoon: " ",
    evening: " ",
    night: " "
  },
  wide: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: " ",
    night: " "
  }
};
const ordinalNumber$1f = (dirtyNumber) => {
  return String(dirtyNumber);
};
const localize$1f = {
  ordinalNumber: ordinalNumber$1f,
  era: buildLocalizeFn({
    values: eraValues$1f,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$1f,
    defaultWidth: "wide",
    argumentCallback: (quarter) => Number(quarter) - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$1f,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$1f,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$1f,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$$,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$1e = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$1e = /\d+/i;
const matchEraPatterns$1e = {
  narrow: /^(|)/i,
  abbreviated: /^(\.?\s?\.?|\.?\s?\.?\s?|a\.?\s?d\.?|c\.?\s?)/i,
  wide: /^( | | | )/i
};
const parseEraPatterns$1e = {
  any: [/^/i, /^/i]
};
const matchQuarterPatterns$1e = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]/i,
  wide: /^ [1234]/i
};
const parseQuarterPatterns$1e = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$1e = {
  narrow: /^[]/i,
  abbreviated: /^(|||||||||||)/i,
  wide: /^(|||||||||||)/i
};
const parseMonthPatterns$1e = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$1e = {
  narrow: /^[]/i,
  short: /^(||||||)/i,
  abbreviated: /^(||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$1e = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  wide: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$1e = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
const parseDayPeriodPatterns$1e = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
const match$1e = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$1e,
    parsePattern: parseOrdinalNumberPattern$1e,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$1e,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1e,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$1e,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1e,
    defaultParseWidth: "any",
    valueCallback: (index2) => Number(index2) + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$1e,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1e,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$1e,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1e,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$1e,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1e,
    defaultParseWidth: "any"
  })
};
const arMA = {
  code: "ar-MA",
  formatDistance: formatDistance$1f,
  formatLong: formatLong$1n,
  formatRelative: formatRelative$1f,
  localize: localize$1f,
  match: match$1e,
  options: {
    // Monday is 1
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$1d = {
  lessThanXSeconds: {
    one: "   ",
    two: "  ",
    threeToTen: "  {{count}} ",
    other: "  {{count}} "
  },
  xSeconds: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  halfAMinute: " ",
  lessThanXMinutes: {
    one: "  ",
    two: "  ",
    threeToTen: "  {{count}} ",
    other: "  {{count}} "
  },
  xMinutes: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: "  ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  },
  xHours: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  xDays: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: "  ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  },
  xWeeks: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: "  ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  },
  xMonths: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: "  ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  },
  xYears: {
    one: " ",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  overXYears: {
    one: "  ",
    two: "  ",
    threeToTen: "  {{count}} ",
    other: "  {{count}} "
  },
  almostXYears: {
    one: "  ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  }
};
const formatDistance$1e = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$1d[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 2) {
    result = tokenValue.two;
  } else if (count <= 10) {
    result = tokenValue.threeToTen.replace("{{count}}", String(count));
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "  " + result;
    } else {
      return " " + result;
    }
  }
  return result;
};
const dateFormats$1m = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
const timeFormats$1m = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$1m = {
  full: "{{date}} '' {{time}}",
  long: "{{date}} '' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$1m = {
  date: buildFormatLongFn({
    formats: dateFormats$1m,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1m,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1m,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$1e = {
  lastWeek: "'' eeee '' p",
  yesterday: "' ' p",
  today: "' ' p",
  tomorrow: "' ' p",
  nextWeek: "eeee '' p",
  other: "P"
};
const formatRelative$1e = (token, _date, _baseDate, _options) => formatRelativeLocale$1e[token];
const eraValues$1e = {
  narrow: ["", ""],
  abbreviated: ["..", ".."],
  wide: [" ", " "]
};
const quarterValues$1e = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1", "2", "3", "4"],
  wide: [" ", " ", " ", " "]
};
const monthValues$1e = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$1e = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$1e = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$_ = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: " ",
    afternoon: " ",
    evening: " ",
    night: " "
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: " ",
    afternoon: " ",
    evening: " ",
    night: " "
  },
  wide: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: " ",
    night: " "
  }
};
const ordinalNumber$1e = (dirtyNumber) => {
  return String(dirtyNumber);
};
const localize$1e = {
  ordinalNumber: ordinalNumber$1e,
  era: buildLocalizeFn({
    values: eraValues$1e,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$1e,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$1e,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$1e,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$1e,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$_,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$1d = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$1d = /\d+/i;
const matchEraPatterns$1d = {
  narrow: /^(|)/i,
  abbreviated: /^(\.?\s?\.?|\.?\s?\.?\s?|a\.?\s?d\.?|c\.?\s?)/i,
  wide: /^( | | | )/i
};
const parseEraPatterns$1d = {
  any: [/^/i, /^/i]
};
const matchQuarterPatterns$1d = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]/i,
  wide: /^ [1234]/i
};
const parseQuarterPatterns$1d = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$1d = {
  narrow: /^[]/i,
  abbreviated: /^(|||||||||||)/i,
  wide: /^(|||||||||||)/i
};
const parseMonthPatterns$1d = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$1d = {
  narrow: /^[]/i,
  short: /^(||||||)/i,
  abbreviated: /^(||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$1d = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  wide: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$1d = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
const parseDayPeriodPatterns$1d = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
const match$1d = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$1d,
    parsePattern: parseOrdinalNumberPattern$1d,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$1d,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1d,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$1d,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1d,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$1d,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1d,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$1d,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1d,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$1d,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1d,
    defaultParseWidth: "any"
  })
};
const arSA = {
  code: "ar-SA",
  formatDistance: formatDistance$1e,
  formatLong: formatLong$1m,
  formatRelative: formatRelative$1e,
  localize: localize$1e,
  match: match$1d,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$1c = {
  lessThanXSeconds: {
    one: "  ",
    two: "   ",
    threeToTen: "  {{count}} ",
    other: "  {{count}} "
  },
  xSeconds: {
    one: "",
    two: " ",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  halfAMinute: " ",
  lessThanXMinutes: {
    one: "  ",
    two: "  ",
    threeToTen: "  {{count}} ",
    other: "  {{count}} "
  },
  xMinutes: {
    one: "",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: " ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  },
  xHours: {
    one: "",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  xDays: {
    one: "",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: " ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  },
  xWeeks: {
    one: "",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: " ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  },
  xMonths: {
    one: "",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: " ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  },
  xYears: {
    one: "",
    two: "",
    threeToTen: "{{count}} ",
    other: "{{count}} "
  },
  overXYears: {
    one: "  ",
    two: "  ",
    threeToTen: "  {{count}} ",
    other: "  {{count}} "
  },
  almostXYears: {
    one: " ",
    two: " ",
    threeToTen: "{{count}}  ",
    other: "{{count}}  "
  }
};
const formatDistance$1d = (token, count, options) => {
  const usageGroup = formatDistanceLocale$1c[token];
  let result;
  if (typeof usageGroup === "string") {
    result = usageGroup;
  } else if (count === 1) {
    result = usageGroup.one;
  } else if (count === 2) {
    result = usageGroup.two;
  } else if (count <= 10) {
    result = usageGroup.threeToTen.replace("{{count}}", String(count));
  } else {
    result = usageGroup.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return " " + result;
    } else {
      return " " + result;
    }
  }
  return result;
};
const dateFormats$1l = {
  full: "EEEE do MMMM y",
  long: "do MMMM y",
  medium: "d MMM y",
  short: "dd/MM/yyyy"
};
const timeFormats$1l = {
  full: "HH:mm:ss",
  long: "HH:mm:ss",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$1l = {
  full: "{{date}} '' {{time}}",
  long: "{{date}} '' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$1l = {
  date: buildFormatLongFn({
    formats: dateFormats$1l,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1l,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1l,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$1d = {
  lastWeek: "eeee '  ' p",
  yesterday: "' ' p",
  today: "' ' p",
  tomorrow: "' ' p",
  nextWeek: "eeee '  ' p ''",
  other: "P"
};
const formatRelative$1d = (token) => formatRelativeLocale$1d[token];
const eraValues$1d = {
  narrow: ["", ""],
  abbreviated: ["..", ".."],
  wide: [" ", " "]
};
const quarterValues$1d = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1", "2", "3", "4"],
  wide: [" ", " ", " ", " "]
};
const monthValues$1d = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$1d = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$1d = {
  narrow: {
    am: "",
    pm: "",
    morning: "",
    noon: "",
    afternoon: " ",
    evening: "",
    night: "",
    midnight: " "
  },
  abbreviated: {
    am: "",
    pm: "",
    morning: "",
    noon: "",
    afternoon: " ",
    evening: "",
    night: "",
    midnight: " "
  },
  wide: {
    am: "",
    pm: "",
    morning: "",
    noon: "",
    afternoon: " ",
    evening: "",
    night: "",
    midnight: " "
  }
};
const formattingDayPeriodValues$Z = {
  narrow: {
    am: "",
    pm: "",
    morning: " ",
    noon: " ",
    afternoon: " ",
    evening: " ",
    night: " ",
    midnight: " "
  },
  abbreviated: {
    am: "",
    pm: "",
    morning: " ",
    noon: " ",
    afternoon: " ",
    evening: " ",
    night: " ",
    midnight: " "
  },
  wide: {
    am: "",
    pm: "",
    morning: " ",
    noon: " ",
    afternoon: " ",
    evening: " ",
    night: " ",
    midnight: " "
  }
};
const ordinalNumber$1d = (num) => String(num);
const localize$1d = {
  ordinalNumber: ordinalNumber$1d,
  era: buildLocalizeFn({
    values: eraValues$1d,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$1d,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$1d,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$1d,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$1d,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$Z,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$1c = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$1c = /\d+/i;
const matchEraPatterns$1c = {
  narrow: /[]/,
  abbreviated: /[]\.\./,
  wide: /(|) /
};
const parseEraPatterns$1c = {
  any: [//, //]
};
const matchQuarterPatterns$1c = {
  narrow: /^[1234]/i,
  abbreviated: /[1234]/,
  wide: / (|||)/
};
const parseQuarterPatterns$1c = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$1c = {
  narrow: /^[]/,
  abbreviated: /^(|||||||||||)/,
  wide: /^(|||||||||||)/
};
const parseMonthPatterns$1c = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$1c = {
  narrow: /^[]/i,
  short: /^(||||||)/i,
  abbreviated: /^(||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$1c = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  wide: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$1c = {
  narrow: /^(|| ||(|) (|||))/,
  any: /^([]| ||(|) (|||))/
};
const parseDayPeriodPatterns$1c = {
  any: {
    am: /^/,
    pm: /^/,
    midnight: / /,
    noon: //,
    afternoon: / /,
    morning: //,
    evening: //,
    night: //
  }
};
const match$1c = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$1c,
    parsePattern: parseOrdinalNumberPattern$1c,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$1c,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1c,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$1c,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1c,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$1c,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1c,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$1c,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1c,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$1c,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1c,
    defaultParseWidth: "any"
  })
};
const arTN = {
  code: "ar-TN",
  formatDistance: formatDistance$1d,
  formatLong: formatLong$1l,
  formatRelative: formatRelative$1d,
  localize: localize$1d,
  match: match$1c,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$1b = {
  lessThanXSeconds: {
    one: "bir saniydn az",
    other: "{{count}} bir saniydn az"
  },
  xSeconds: {
    one: "1 saniy",
    other: "{{count}} saniy"
  },
  halfAMinute: "yarm dqiq",
  lessThanXMinutes: {
    one: "bir dqiqdn az",
    other: "{{count}} bir dqiqdn az"
  },
  xMinutes: {
    one: "bir dqiq",
    other: "{{count}} dqiq"
  },
  aboutXHours: {
    one: "txminn 1 saat",
    other: "txminn {{count}} saat"
  },
  xHours: {
    one: "1 saat",
    other: "{{count}} saat"
  },
  xDays: {
    one: "1 gn",
    other: "{{count}} gn"
  },
  aboutXWeeks: {
    one: "txminn 1 hft",
    other: "txminn {{count}} hft"
  },
  xWeeks: {
    one: "1 hft",
    other: "{{count}} hft"
  },
  aboutXMonths: {
    one: "txminn 1 ay",
    other: "txminn {{count}} ay"
  },
  xMonths: {
    one: "1 ay",
    other: "{{count}} ay"
  },
  aboutXYears: {
    one: "txminn 1 il",
    other: "txminn {{count}} il"
  },
  xYears: {
    one: "1 il",
    other: "{{count}} il"
  },
  overXYears: {
    one: "1 ildn ox",
    other: "{{count}} ildn ox"
  },
  almostXYears: {
    one: "demk olar ki 1 il",
    other: "demk olar ki {{count}} il"
  }
};
const formatDistance$1c = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$1b[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + " sonra";
    } else {
      return result + " vvl";
    }
  }
  return result;
};
const dateFormats$1k = {
  full: "EEEE, do MMMM y 'il'",
  long: "do MMMM y 'il'",
  medium: "d MMM y 'il'",
  short: "dd.MM.yyyy"
};
const timeFormats$1k = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
const dateTimeFormats$1k = {
  full: "{{date}} {{time}} - 'd'",
  long: "{{date}} {{time}} - 'd'",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$1k = {
  date: buildFormatLongFn({
    formats: dateFormats$1k,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1k,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1k,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$1c = {
  lastWeek: "'sonuncu' eeee p -'d'",
  yesterday: "'dnn' p -'d'",
  today: "'bugn' p -'d'",
  tomorrow: "'sabah' p -'d'",
  nextWeek: "eeee p -'d'",
  other: "P"
};
const formatRelative$1c = (token, _date, _baseDate, _options) => formatRelativeLocale$1c[token];
const eraValues$1c = {
  narrow: ["e.", "b.e"],
  abbreviated: ["e.", "b.e"],
  wide: ["eramzdan vvl", "bizim era"]
};
const quarterValues$1c = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1ci kvartal", "2ci kvartal", "3c kvartal", "4c kvartal"]
};
const monthValues$1c = {
  narrow: ["Y", "F", "M", "A", "M", "", "", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Yan",
    "Fev",
    "Mar",
    "Apr",
    "May",
    "yun",
    "yul",
    "Avq",
    "Sen",
    "Okt",
    "Noy",
    "Dek"
  ],
  wide: [
    "Yanvar",
    "Fevral",
    "Mart",
    "Aprel",
    "May",
    "yun",
    "yul",
    "Avqust",
    "Sentyabr",
    "Oktyabr",
    "Noyabr",
    "Dekabr"
  ]
};
const dayValues$1c = {
  narrow: ["B.", "B.e", ".a", ".", "C.a", "C.", "."],
  short: ["B.", "B.e", ".a", ".", "C.a", "C.", "."],
  abbreviated: ["Baz", "Baz.e", "r.a", "r", "Cm.a", "Cm", ""],
  wide: [
    "Bazar",
    "Bazar ertsi",
    "rnb axam",
    "rnb",
    "Cm axam",
    "Cm",
    "nb"
  ]
};
const dayPeriodValues$1c = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "gecyar",
    noon: "gn",
    morning: "shr",
    afternoon: "gndz",
    evening: "axam",
    night: "gec"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "gecyar",
    noon: "gn",
    morning: "shr",
    afternoon: "gndz",
    evening: "axam",
    night: "gec"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "gecyar",
    noon: "gn",
    morning: "shr",
    afternoon: "gndz",
    evening: "axam",
    night: "gec"
  }
};
const formattingDayPeriodValues$Y = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "gecyar",
    noon: "gn",
    morning: "shr",
    afternoon: "gndz",
    evening: "axam",
    night: "gec"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "gecyar",
    noon: "gn",
    morning: "shr",
    afternoon: "gndz",
    evening: "axam",
    night: "gec"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "gecyar",
    noon: "gn",
    morning: "shr",
    afternoon: "gndz",
    evening: "axam",
    night: "gec"
  }
};
const suffixes$1 = {
  1: "-inci",
  5: "-inci",
  8: "-inci",
  70: "-inci",
  80: "-inci",
  2: "-nci",
  7: "-nci",
  20: "-nci",
  50: "-nci",
  3: "-nc",
  4: "-nc",
  100: "-nc",
  6: "-nc",
  9: "-uncu",
  10: "-uncu",
  30: "-uncu",
  60: "-nc",
  90: "-nc"
};
const getSuffix = (number2) => {
  if (number2 === 0) {
    return number2 + "-nc";
  }
  const a2 = number2 % 10;
  const b = number2 % 100 - a2;
  const c2 = number2 >= 100 ? 100 : null;
  if (suffixes$1[a2]) {
    return suffixes$1[a2];
  } else if (suffixes$1[b]) {
    return suffixes$1[b];
  } else if (c2 !== null) {
    return suffixes$1[c2];
  }
  return "";
};
const ordinalNumber$1c = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  const suffix = getSuffix(number2);
  return number2 + suffix;
};
const localize$1c = {
  ordinalNumber: ordinalNumber$1c,
  era: buildLocalizeFn({
    values: eraValues$1c,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$1c,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$1c,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$1c,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$1c,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$Y,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$1b = /^(\d+)(-?(ci|inci|nci|uncu|nc|nc))?/i;
const parseOrdinalNumberPattern$1b = /\d+/i;
const matchEraPatterns$1b = {
  narrow: /^(b|a)$/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)$/i,
  wide: /^(bizim eradan vvl|bizim era)$/i
};
const parseEraPatterns$1b = {
  any: [/^b$/i, /^(a|c)$/i]
};
const matchQuarterPatterns$1b = {
  narrow: /^[1234]$/i,
  abbreviated: /^K[1234]$/i,
  wide: /^[1234](ci)? kvartal$/i
};
const parseQuarterPatterns$1b = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$1b = {
  narrow: /^[(?-i)yfmaisond]$/i,
  abbreviated: /^(Yan|Fev|Mar|Apr|May|yun|yul|Avq|Sen|Okt|Noy|Dek)$/i,
  wide: /^(Yanvar|Fevral|Mart|Aprel|May|yun|yul|Avgust|Sentyabr|Oktyabr|Noyabr|Dekabr)$/i
};
const parseMonthPatterns$1b = {
  narrow: [
    /^[(?-i)y]$/i,
    /^[(?-i)f]$/i,
    /^[(?-i)m]$/i,
    /^[(?-i)a]$/i,
    /^[(?-i)m]$/i,
    /^[(?-i)i]$/i,
    /^[(?-i)i]$/i,
    /^[(?-i)a]$/i,
    /^[(?-i)s]$/i,
    /^[(?-i)o]$/i,
    /^[(?-i)n]$/i,
    /^[(?-i)d]$/i
  ],
  abbreviated: [
    /^Yan$/i,
    /^Fev$/i,
    /^Mar$/i,
    /^Apr$/i,
    /^May$/i,
    /^yun$/i,
    /^yul$/i,
    /^Avg$/i,
    /^Sen$/i,
    /^Okt$/i,
    /^Noy$/i,
    /^Dek$/i
  ],
  wide: [
    /^Yanvar$/i,
    /^Fevral$/i,
    /^Mart$/i,
    /^Aprel$/i,
    /^May$/i,
    /^yun$/i,
    /^yul$/i,
    /^Avgust$/i,
    /^Sentyabr$/i,
    /^Oktyabr$/i,
    /^Noyabr$/i,
    /^Dekabr$/i
  ]
};
const matchDayPatterns$1b = {
  narrow: /^(B\.|B\.e|\.a|\.|C\.a|C\.|\.)$/i,
  short: /^(B\.|B\.e|\.a|\.|C\.a|C\.|\.)$/i,
  abbreviated: /^(Baz\.e|r|r\.a|Cm|Cm\.a|)$/i,
  wide: /^(Bazar|Bazar ertsi|rnb axam|rnb|Cm axam|Cm|nb)$/i
};
const parseDayPatterns$1b = {
  narrow: [
    /^B\.$/i,
    /^B\.e$/i,
    /^\.a$/i,
    /^\.$/i,
    /^C\.a$/i,
    /^C\.$/i,
    /^\.$/i
  ],
  abbreviated: [
    /^Baz$/i,
    /^Baz\.e$/i,
    /^r\.a$/i,
    /^r$/i,
    /^Cm\.a$/i,
    /^Cm$/i,
    /^$/i
  ],
  wide: [
    /^Bazar$/i,
    /^Bazar ertsi$/i,
    /^rnb axam$/i,
    /^rnb$/i,
    /^Cm axam$/i,
    /^Cm$/i,
    /^nb$/i
  ],
  any: [
    /^B\.$/i,
    /^B\.e$/i,
    /^\.a$/i,
    /^\.$/i,
    /^C\.a$/i,
    /^C\.$/i,
    /^\.$/i
  ]
};
const matchDayPeriodPatterns$1b = {
  narrow: /^(a|p|gecyar|gn|shr|gndz|axam|gec)$/i,
  any: /^(am|pm|a\.m\.|p\.m\.|AM|PM|gecyar|gn|shr|gndz|axam|gec)$/i
};
const parseDayPeriodPatterns$1b = {
  any: {
    am: /^a$/i,
    pm: /^p$/i,
    midnight: /^gecyar$/i,
    noon: /^gn$/i,
    morning: /shr$/i,
    afternoon: /gndz$/i,
    evening: /axam$/i,
    night: /gec$/i
  }
};
const match$1b = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$1b,
    parsePattern: parseOrdinalNumberPattern$1b,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$1b,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1b,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$1b,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1b,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$1b,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1b,
    defaultParseWidth: "narrow"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$1b,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1b,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$1b,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1b,
    defaultParseWidth: "any"
  })
};
const az = {
  code: "az",
  formatDistance: formatDistance$1c,
  formatLong: formatLong$1k,
  formatRelative: formatRelative$1c,
  localize: localize$1c,
  match: match$1b,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
function declension$6(scheme2, count) {
  if (scheme2.one !== void 0 && count === 1) {
    return scheme2.one;
  }
  const rem10 = count % 10;
  const rem100 = count % 100;
  if (rem10 === 1 && rem100 !== 11) {
    return scheme2.singularNominative.replace("{{count}}", String(count));
  } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
    return scheme2.singularGenitive.replace("{{count}}", String(count));
  } else {
    return scheme2.pluralGenitive.replace("{{count}}", String(count));
  }
}
function buildLocalizeTokenFn$4(scheme2) {
  return (count, options) => {
    if (options && options.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        if (scheme2.future) {
          return declension$6(scheme2.future, count);
        } else {
          return " " + declension$6(scheme2.regular, count);
        }
      } else {
        if (scheme2.past) {
          return declension$6(scheme2.past, count);
        } else {
          return declension$6(scheme2.regular, count) + " ";
        }
      }
    } else {
      return declension$6(scheme2.regular, count);
    }
  };
}
const halfAMinute$1 = (_, options) => {
  if (options && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return " ";
    } else {
      return " ";
    }
  }
  return "";
};
const formatDistanceLocale$1a = {
  lessThanXSeconds: buildLocalizeTokenFn$4({
    regular: {
      one: "  ",
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    },
    future: {
      one: ",   ",
      singularNominative: ",   {{count}} ",
      singularGenitive: ",   {{count}} ",
      pluralGenitive: ",   {{count}} "
    }
  }),
  xSeconds: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    },
    past: {
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    },
    future: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    }
  }),
  halfAMinute: halfAMinute$1,
  lessThanXMinutes: buildLocalizeTokenFn$4({
    regular: {
      one: "  ",
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    },
    future: {
      one: ",   ",
      singularNominative: ",   {{count}} ",
      singularGenitive: ",   {{count}} ",
      pluralGenitive: ",   {{count}} "
    }
  }),
  xMinutes: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    },
    past: {
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    },
    future: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    }
  }),
  aboutXHours: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    }
  }),
  xHours: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    },
    past: {
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    },
    future: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    }
  }),
  xDays: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    }
  }),
  aboutXWeeks: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    }
  }),
  xWeeks: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    }
  }),
  aboutXMonths: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    }
  }),
  xMonths: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    }
  }),
  aboutXYears: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    }
  }),
  xYears: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    }
  }),
  overXYears: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    },
    future: {
      singularNominative: ",   {{count}} ",
      singularGenitive: ",   {{count}} ",
      pluralGenitive: ",   {{count}} "
    }
  }),
  almostXYears: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    }
  })
};
const formatDistance$1b = (token, count, options) => {
  options = options || {};
  return formatDistanceLocale$1a[token](count, options);
};
const dateFormats$1j = {
  full: "EEEE, d MMMM y '.'",
  long: "d MMMM y '.'",
  medium: "d MMM y '.'",
  short: "dd.MM.y"
};
const timeFormats$1j = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
const dateTimeFormats$1j = {
  any: "{{date}}, {{time}}"
};
const formatLong$1j = {
  date: buildFormatLongFn({
    formats: dateFormats$1j,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1j,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1j,
    defaultWidth: "any"
  })
};
const accusativeWeekdays$7 = [
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];
function lastWeek$8(day) {
  const weekday = accusativeWeekdays$7[day];
  switch (day) {
    case 0:
    case 3:
    case 5:
    case 6:
      return "'  " + weekday + " ' p";
    case 1:
    case 2:
    case 4:
      return "'  " + weekday + " ' p";
  }
}
function thisWeek$8(day) {
  const weekday = accusativeWeekdays$7[day];
  return "' " + weekday + " ' p";
}
function nextWeek$8(day) {
  const weekday = accusativeWeekdays$7[day];
  switch (day) {
    case 0:
    case 3:
    case 5:
    case 6:
      return "'  " + weekday + " ' p";
    case 1:
    case 2:
    case 4:
      return "'  " + weekday + " ' p";
  }
}
const lastWeekFormat$2 = (dirtyDate, baseDate, options) => {
  const date2 = toDate(dirtyDate);
  const day = date2.getDay();
  if (isSameWeek(date2, baseDate, options)) {
    return thisWeek$8(day);
  } else {
    return lastWeek$8(day);
  }
};
const nextWeekFormat$2 = (dirtyDate, baseDate, options) => {
  const date2 = toDate(dirtyDate);
  const day = date2.getDay();
  if (isSameWeek(date2, baseDate, options)) {
    return thisWeek$8(day);
  } else {
    return nextWeek$8(day);
  }
};
const formatRelativeLocale$1b = {
  lastWeek: lastWeekFormat$2,
  yesterday: "' ' p",
  today: "' ' p",
  tomorrow: "' ' p",
  nextWeek: nextWeekFormat$2,
  other: "P"
};
const formatRelative$1b = (token, date2, baseDate, options) => {
  const format2 = formatRelativeLocale$1b[token];
  if (typeof format2 === "function") {
    return format2(date2, baseDate, options);
  }
  return format2;
};
const eraValues$1b = {
  narrow: [" ..", ".."],
  abbreviated: [" . .", ". ."],
  wide: ["  ", " "]
};
const quarterValues$1b = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1- .", "2- .", "3- .", "4- ."],
  wide: ["1- ", "2- ", "3- ", "4- "]
};
const monthValues$1b = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    ".",
    ".",
    ".",
    ".",
    "",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    "."
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const formattingMonthValues$i = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    ".",
    ".",
    ".",
    ".",
    "",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    "."
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$1b = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$1b = {
  narrow: {
    am: "",
    pm: "",
    midnight: ".",
    noon: ".",
    morning: ".",
    afternoon: "",
    evening: ".",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: ".",
    noon: ".",
    morning: ".",
    afternoon: "",
    evening: ".",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$X = {
  narrow: {
    am: "",
    pm: "",
    midnight: ".",
    noon: ".",
    morning: ".",
    afternoon: "",
    evening: ".",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: ".",
    noon: ".",
    morning: ".",
    afternoon: "",
    evening: ".",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$1b = (dirtyNumber, options) => {
  const unit = String(options?.unit);
  const number2 = Number(dirtyNumber);
  let suffix;
  if (unit === "date") {
    suffix = "-";
  } else if (unit === "hour" || unit === "minute" || unit === "second") {
    suffix = "-";
  } else {
    suffix = (number2 % 10 === 2 || number2 % 10 === 3) && number2 % 100 !== 12 && number2 % 100 !== 13 ? "-" : "-";
  }
  return number2 + suffix;
};
const localize$1b = {
  ordinalNumber: ordinalNumber$1b,
  era: buildLocalizeFn({
    values: eraValues$1b,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$1b,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$1b,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$i,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$1b,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$1b,
    defaultWidth: "any",
    formattingValues: formattingDayPeriodValues$X,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$1a = /^(\d+)(-?(||||||||||||))?/i;
const parseOrdinalNumberPattern$1a = /\d+/i;
const matchEraPatterns$1a = {
  narrow: /^(( )?\.?\s?\.?)/i,
  abbreviated: /^(( )?\.?\s?\.?)/i,
  wide: /^(  | | )/i
};
const parseEraPatterns$1a = {
  any: [/^/i, /^/i]
};
const matchQuarterPatterns$1a = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?[]?)? .?/i,
  wide: /^[1234](-?[]?)? /i
};
const parseQuarterPatterns$1a = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$1a = {
  narrow: /^[]/i,
  abbreviated: /^(||||[]|||||||)\.?/i,
  wide: /^([]|(|)|?|?|[]|[]|[]|(|)|(|)|?|?|(|))/i
};
const parseMonthPatterns$1a = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$1a = {
  narrow: /^[]/i,
  short: /^(|||||||||||||)\.?/i,
  abbreviated: /^(?|||||||||||).?/i,
  wide: /^([]|(|)|(|)|[]|(|)|[]|[])/i
};
const parseDayPatterns$1a = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^/i, /^[]/i, /^/i, /^[]/i, /^/i, /^[]/i, /^[]/i]
};
const matchDayPeriodPatterns$1a = {
  narrow: /^([]|\.?|\.?|\.?|||\.?|?)/i,
  abbreviated: /^([]|\.?|\.?|\.?|||\.?|?)/i,
  wide: /^([]|||[]|||?|?)/i
};
const parseDayPeriodPatterns$1a = {
  any: {
    am: /^/i,
    pm: /^/i,
    midnight: /^/i,
    noon: /^/i,
    morning: /^/i,
    afternoon: /^[]/i,
    evening: /^/i,
    night: /^/i
  }
};
const match$1a = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$1a,
    parsePattern: parseOrdinalNumberPattern$1a,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$1a,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1a,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$1a,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1a,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$1a,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1a,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$1a,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1a,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$1a,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$1a,
    defaultParseWidth: "any"
  })
};
const be = {
  code: "be",
  formatDistance: formatDistance$1b,
  formatLong: formatLong$1j,
  formatRelative: formatRelative$1b,
  localize: localize$1b,
  match: match$1a,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
function declension$5(scheme2, count) {
  if (scheme2.one !== void 0 && count === 1) {
    return scheme2.one;
  }
  const rem10 = count % 10;
  const rem100 = count % 100;
  if (rem10 === 1 && rem100 !== 11) {
    return scheme2.singularNominative.replace("{{count}}", String(count));
  } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
    return scheme2.singularGenitive.replace("{{count}}", String(count));
  } else {
    return scheme2.pluralGenitive.replace("{{count}}", String(count));
  }
}
function buildLocalizeTokenFn$3(scheme2) {
  return (count, options) => {
    if (options && options.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        if (scheme2.future) {
          return declension$5(scheme2.future, count);
        } else {
          return " " + declension$5(scheme2.regular, count);
        }
      } else {
        if (scheme2.past) {
          return declension$5(scheme2.past, count);
        } else {
          return declension$5(scheme2.regular, count) + " ";
        }
      }
    } else {
      return declension$5(scheme2.regular, count);
    }
  };
}
const halfAMinute = (_, options) => {
  if (options && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return " ";
    } else {
      return " ";
    }
  }
  return "";
};
const formatDistanceLocale$19 = {
  lessThanXSeconds: buildLocalizeTokenFn$3({
    regular: {
      one: "  ",
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    },
    future: {
      one: ",   ",
      singularNominative: ",   {{count}} ",
      singularGenitive: ",   {{count}} ",
      pluralGenitive: ",   {{count}} "
    }
  }),
  xSeconds: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    },
    past: {
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    },
    future: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    }
  }),
  halfAMinute,
  lessThanXMinutes: buildLocalizeTokenFn$3({
    regular: {
      one: "  ",
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    },
    future: {
      one: ",   ",
      singularNominative: ",   {{count}} ",
      singularGenitive: ",   {{count}} ",
      pluralGenitive: ",   {{count}} "
    }
  }),
  xMinutes: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    },
    past: {
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    },
    future: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    }
  }),
  aboutXHours: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    }
  }),
  xHours: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    },
    past: {
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    },
    future: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    }
  }),
  xDays: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    }
  }),
  aboutXWeeks: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    }
  }),
  xWeeks: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    }
  }),
  aboutXMonths: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    }
  }),
  xMonths: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    }
  }),
  aboutXYears: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    }
  }),
  xYears: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    }
  }),
  overXYears: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    },
    future: {
      singularNominative: ",   {{count}} ",
      singularGenitive: ",   {{count}} ",
      pluralGenitive: ",   {{count}} "
    }
  }),
  almostXYears: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    }
  })
};
const formatDistance$1a = (token, count, options) => {
  options = options || {};
  return formatDistanceLocale$19[token](count, options);
};
const dateFormats$1i = {
  full: "EEEE, d MMMM y '.'",
  long: "d MMMM y '.'",
  medium: "d MMM y '.'",
  short: "dd.MM.y"
};
const timeFormats$1i = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
const dateTimeFormats$1i = {
  any: "{{date}}, {{time}}"
};
const formatLong$1i = {
  date: buildFormatLongFn({
    formats: dateFormats$1i,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1i,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1i,
    defaultWidth: "any"
  })
};
const accusativeWeekdays$6 = [
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];
function lastWeek$7(day) {
  const weekday = accusativeWeekdays$6[day];
  switch (day) {
    case 0:
    case 3:
    case 5:
    case 6:
      return "'  " + weekday + " ' p";
    case 1:
    case 2:
    case 4:
      return "'  " + weekday + " ' p";
  }
}
function thisWeek$7(day) {
  const weekday = accusativeWeekdays$6[day];
  return "' " + weekday + " ' p";
}
function nextWeek$7(day) {
  const weekday = accusativeWeekdays$6[day];
  switch (day) {
    case 0:
    case 3:
    case 5:
    case 6:
      return "'  " + weekday + " ' p";
    case 1:
    case 2:
    case 4:
      return "'  " + weekday + " ' p";
  }
}
const lastWeekFormat$1 = (dirtyDate, baseDate, options) => {
  const date2 = toDate(dirtyDate);
  const day = date2.getDay();
  if (isSameWeek(date2, baseDate, options)) {
    return thisWeek$7(day);
  } else {
    return lastWeek$7(day);
  }
};
const nextWeekFormat$1 = (dirtyDate, baseDate, options) => {
  const date2 = toDate(dirtyDate);
  const day = date2.getDay();
  if (isSameWeek(date2, baseDate, options)) {
    return thisWeek$7(day);
  } else {
    return nextWeek$7(day);
  }
};
const formatRelativeLocale$1a = {
  lastWeek: lastWeekFormat$1,
  yesterday: "' ' p",
  today: "' ' p",
  tomorrow: "' ' p",
  nextWeek: nextWeekFormat$1,
  other: "P"
};
const formatRelative$1a = (token, date2, baseDate, options) => {
  const format2 = formatRelativeLocale$1a[token];
  if (typeof format2 === "function") {
    return format2(date2, baseDate, options);
  }
  return format2;
};
const eraValues$1a = {
  narrow: [" ..", ".."],
  abbreviated: [" . .", ". ."],
  wide: ["  ", " "]
};
const quarterValues$1a = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1- .", "2- .", "3- .", "4- ."],
  wide: ["1- ", "2- ", "3- ", "4- "]
};
const monthValues$1a = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    "."
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const formattingMonthValues$h = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    "."
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$1a = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$1a = {
  narrow: {
    am: "",
    pm: "",
    midnight: ".",
    noon: ".",
    morning: ".",
    afternoon: "",
    evening: ".",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: ".",
    noon: ".",
    morning: ".",
    afternoon: "",
    evening: ".",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$W = {
  narrow: {
    am: "",
    pm: "",
    midnight: ".",
    noon: ".",
    morning: ".",
    afternoon: "",
    evening: ".",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: ".",
    noon: ".",
    morning: ".",
    afternoon: "",
    evening: ".",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$1a = (dirtyNumber, options) => {
  const unit = String(options?.unit);
  const number2 = Number(dirtyNumber);
  let suffix;
  if (unit === "date") {
    suffix = "-";
  } else if (unit === "hour" || unit === "minute" || unit === "second") {
    suffix = "-";
  } else {
    suffix = (number2 % 10 === 2 || number2 % 10 === 3) && number2 % 100 !== 12 && number2 % 100 !== 13 ? "-" : "-";
  }
  return number2 + suffix;
};
const localize$1a = {
  ordinalNumber: ordinalNumber$1a,
  era: buildLocalizeFn({
    values: eraValues$1a,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$1a,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$1a,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$h,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$1a,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$1a,
    defaultWidth: "any",
    formattingValues: formattingDayPeriodValues$W,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$19 = /^(\d+)(-?(||||||||||||))?/i;
const parseOrdinalNumberPattern$19 = /\d+/i;
const matchEraPatterns$19 = {
  narrow: /^(( )?\.?\s?\.?)/i,
  abbreviated: /^(( )?\.?\s?\.?)/i,
  wide: /^(  | | )/i
};
const parseEraPatterns$19 = {
  any: [/^/i, /^/i]
};
const matchQuarterPatterns$19 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?[]?)? .?/i,
  wide: /^[1234](-?[]?)? /i
};
const parseQuarterPatterns$19 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$19 = {
  narrow: /^[]/i,
  abbreviated: /^(||||()?|||||||)\.?/i,
  wide: /^([]|(|)|?|?|(|)|[]|[]|(|)|(|)|?|?|(|))/i
};
const parseMonthPatterns$19 = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$19 = {
  narrow: /^[]/i,
  short: /^(|||||||||||||)\.?/i,
  abbreviated: /^(?|||||||||||).?/i,
  wide: /^([]|(|)|(|)|[]|(|)|[]|[])/i
};
const parseDayPatterns$19 = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^/i, /^[]/i, /^/i, /^[]/i, /^/i, /^[]/i, /^[]/i]
};
const matchDayPeriodPatterns$19 = {
  narrow: /^([]|\.?|\.?|\.?|||\.?|?)/i,
  abbreviated: /^([]|\.?|\.?|\.?|||\.?|?)/i,
  wide: /^([]|||[]|||?|?)/i
};
const parseDayPeriodPatterns$19 = {
  any: {
    am: /^/i,
    pm: /^/i,
    midnight: /^/i,
    noon: /^/i,
    morning: /^/i,
    afternoon: /^[]/i,
    evening: /^/i,
    night: /^/i
  }
};
const match$19 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$19,
    parsePattern: parseOrdinalNumberPattern$19,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$19,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$19,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$19,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$19,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$19,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$19,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$19,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$19,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$19,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$19,
    defaultParseWidth: "any"
  })
};
const beTarask = {
  code: "be-tarask",
  formatDistance: formatDistance$1a,
  formatLong: formatLong$1i,
  formatRelative: formatRelative$1a,
  localize: localize$1a,
  match: match$19,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$18 = {
  lessThanXSeconds: {
    one: "-  ",
    other: "-  {{count}} "
  },
  xSeconds: {
    one: "1 ",
    other: "{{count}} "
  },
  halfAMinute: " ",
  lessThanXMinutes: {
    one: "-  ",
    other: "-  {{count}} "
  },
  xMinutes: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: " ",
    other: " {{count}} "
  },
  xHours: {
    one: "1 ",
    other: "{{count}} "
  },
  xDays: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: " ",
    other: " {{count}} "
  },
  xWeeks: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: " ",
    other: " {{count}} "
  },
  xMonths: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: " ",
    other: " {{count}} "
  },
  xYears: {
    one: "1 ",
    other: "{{count}} "
  },
  overXYears: {
    one: " ",
    other: " {{count}} "
  },
  almostXYears: {
    one: " ",
    other: " {{count}} "
  }
};
const formatDistance$19 = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$18[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return " " + result;
    } else {
      return " " + result;
    }
  }
  return result;
};
const dateFormats$1h = {
  full: "EEEE, dd MMMM yyyy",
  long: "dd MMMM yyyy",
  medium: "dd MMM yyyy",
  short: "dd/MM/yyyy"
};
const timeFormats$1h = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "H:mm"
};
const dateTimeFormats$1h = {
  any: "{{date}} {{time}}"
};
const formatLong$1h = {
  date: buildFormatLongFn({
    formats: dateFormats$1h,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1h,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1h,
    defaultWidth: "any"
  })
};
const weekdays$3 = [
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];
function lastWeek$6(day) {
  const weekday = weekdays$3[day];
  switch (day) {
    case 0:
    case 3:
    case 6:
      return "' " + weekday + " ' p";
    case 1:
    case 2:
    case 4:
    case 5:
      return "' " + weekday + " ' p";
  }
}
function thisWeek$6(day) {
  const weekday = weekdays$3[day];
  if (day === 2) {
    return "' " + weekday + " ' p";
  } else {
    return "' " + weekday + " ' p";
  }
}
function nextWeek$6(day) {
  const weekday = weekdays$3[day];
  switch (day) {
    case 0:
    case 3:
    case 6:
      return "' " + weekday + " ' p";
    case 1:
    case 2:
    case 4:
    case 5:
      return "' " + weekday + " ' p";
  }
}
const lastWeekFormatToken = (dirtyDate, baseDate, options) => {
  const date2 = toDate(dirtyDate);
  const day = date2.getDay();
  if (isSameWeek(date2, baseDate, options)) {
    return thisWeek$6(day);
  } else {
    return lastWeek$6(day);
  }
};
const nextWeekFormatToken = (dirtyDate, baseDate, options) => {
  const date2 = toDate(dirtyDate);
  const day = date2.getDay();
  if (isSameWeek(date2, baseDate, options)) {
    return thisWeek$6(day);
  } else {
    return nextWeek$6(day);
  }
};
const formatRelativeLocale$19 = {
  lastWeek: lastWeekFormatToken,
  yesterday: "' ' p",
  today: "' ' p",
  tomorrow: "' ' p",
  nextWeek: nextWeekFormatToken,
  other: "P"
};
const formatRelative$19 = (token, date2, baseDate, options) => {
  const format2 = formatRelativeLocale$19[token];
  if (typeof format2 === "function") {
    return format2(date2, baseDate, options);
  }
  return format2;
};
const eraValues$19 = {
  narrow: ["...", ".."],
  abbreviated: [" . .", ". ."],
  wide: ["  ", " "]
};
const quarterValues$19 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1- .", "2- .", "3- .", "4- ."],
  wide: [
    "1- ",
    "2- ",
    "3- ",
    "4- "
  ]
};
const monthValues$19 = {
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$19 = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$19 = {
  wide: {
    am: " ",
    pm: " ",
    midnight: " ",
    noon: " ",
    morning: "",
    afternoon: "",
    evening: "",
    night: " "
  }
};
function isFeminine(unit) {
  return unit === "year" || unit === "week" || unit === "minute" || unit === "second";
}
function isNeuter(unit) {
  return unit === "quarter";
}
function numberWithSuffix(number2, unit, masculine, feminine, neuter) {
  const suffix = isNeuter(unit) ? neuter : isFeminine(unit) ? feminine : masculine;
  return number2 + "-" + suffix;
}
const ordinalNumber$19 = (dirtyNumber, options) => {
  const number2 = Number(dirtyNumber);
  const unit = options?.unit;
  if (number2 === 0) {
    return numberWithSuffix(0, unit, "", "", "");
  } else if (number2 % 1e3 === 0) {
    return numberWithSuffix(number2, unit, "", "", "");
  } else if (number2 % 100 === 0) {
    return numberWithSuffix(number2, unit, "", "", "");
  }
  const rem100 = number2 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return numberWithSuffix(number2, unit, "", "", "");
      case 2:
        return numberWithSuffix(number2, unit, "", "", "");
      case 7:
      case 8:
        return numberWithSuffix(number2, unit, "", "", "");
    }
  }
  return numberWithSuffix(number2, unit, "", "", "");
};
const localize$19 = {
  ordinalNumber: ordinalNumber$19,
  era: buildLocalizeFn({
    values: eraValues$19,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$19,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$19,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$19,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$19,
    defaultWidth: "wide"
  })
};
const matchOrdinalNumberPattern$18 = /^(\d+)(-?[][]|-??(|)|-?(|))?/i;
const parseOrdinalNumberPattern$18 = /\d+/i;
const matchEraPatterns$18 = {
  narrow: /^(()?\.?\s?\.?)/i,
  abbreviated: /^(()?\.?\s?\.?)/i,
  wide: /^(  | | )/i
};
const parseEraPatterns$18 = {
  any: [/^/i, /^/i]
};
const matchQuarterPatterns$18 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?[]?o?)? .?/i,
  wide: /^[1234](-?[]??)? /i
};
const parseQuarterPatterns$18 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchDayPatterns$18 = {
  narrow: /^[]/i,
  short: /^(||||||)/i,
  abbreviated: /^(||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$18 = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^[]/i, /^[]/i, /^/i, /^/i, /^[]/i, /^[]/i, /^[]/i]
};
const matchMonthPatterns$18 = {
  abbreviated: /^(|||||||||||)/i,
  wide: /^(|||||||||||)/i
};
const parseMonthPatterns$18 = {
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPeriodPatterns$18 = {
  any: /^( | | | ||||)/i
};
const parseDayPeriodPatterns$18 = {
  any: {
    am: /^ /i,
    pm: /^ /i,
    midnight: /^ /i,
    noon: /^ /i,
    morning: /^/i,
    afternoon: /^/i,
    evening: /^/i,
    night: /^ /i
  }
};
const match$18 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$18,
    parsePattern: parseOrdinalNumberPattern$18,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$18,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$18,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$18,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$18,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$18,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$18,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$18,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$18,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$18,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$18,
    defaultParseWidth: "any"
  })
};
const bg = {
  code: "bg",
  formatDistance: formatDistance$19,
  formatLong: formatLong$1h,
  formatRelative: formatRelative$19,
  localize: localize$19,
  match: match$18,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const numberValues$1 = {
  locale: {
    1: "",
    2: "",
    3: "",
    4: "",
    5: "",
    6: "",
    7: "",
    8: "",
    9: "",
    0: ""
  },
  number: {
    "": "1",
    "": "2",
    "": "3",
    "": "4",
    "": "5",
    "": "6",
    "": "7",
    "": "8",
    "": "9",
    "": "0"
  }
};
const eraValues$18 = {
  narrow: ["", ""],
  abbreviated: ["", ""],
  wide: ["", ""]
};
const quarterValues$18 = {
  narrow: ["", "", "", ""],
  abbreviated: ["", "", "", ""],
  wide: [" ", " ", " ", " "]
};
const monthValues$18 = {
  narrow: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$18 = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    " ",
    "",
    ""
  ]
};
const dayPeriodValues$18 = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$V = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
function dateOrdinalNumber(number2, localeNumber) {
  if (number2 > 18 && number2 <= 31) {
    return localeNumber + "";
  } else {
    switch (number2) {
      case 1:
        return localeNumber + "";
      case 2:
      case 3:
        return localeNumber + "";
      case 4:
        return localeNumber + "";
      default:
        return localeNumber + "";
    }
  }
}
const ordinalNumber$18 = (dirtyNumber, options) => {
  const number2 = Number(dirtyNumber);
  const localeNumber = numberToLocale$1(number2);
  const unit = options?.unit;
  if (unit === "date") {
    return dateOrdinalNumber(number2, localeNumber);
  }
  if (number2 > 10 || number2 === 0) return localeNumber + "";
  const rem10 = number2 % 10;
  switch (rem10) {
    case 2:
    case 3:
      return localeNumber + "";
    case 4:
      return localeNumber + "";
    case 6:
      return localeNumber + "";
    default:
      return localeNumber + "";
  }
};
function numberToLocale$1(enNumber) {
  return enNumber.toString().replace(/\d/g, function(match2) {
    return numberValues$1.locale[match2];
  });
}
const localize$18 = {
  ordinalNumber: ordinalNumber$18,
  era: buildLocalizeFn({
    values: eraValues$18,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$18,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$18,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$18,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$18,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$V,
    defaultFormattingWidth: "wide"
  })
};
const formatDistanceLocale$17 = {
  lessThanXSeconds: {
    one: "  ",
    other: " {{count}} "
  },
  xSeconds: {
    one: " ",
    other: "{{count}} "
  },
  halfAMinute: " ",
  lessThanXMinutes: {
    one: "  ",
    other: " {{count}} "
  },
  xMinutes: {
    one: " ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: "  ",
    other: " {{count}} "
  },
  xHours: {
    one: " ",
    other: "{{count}} "
  },
  xDays: {
    one: " ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: "  ",
    other: " {{count}} "
  },
  xWeeks: {
    one: " ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: "  ",
    other: " {{count}} "
  },
  xMonths: {
    one: " ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: "  ",
    other: " {{count}} "
  },
  xYears: {
    one: " ",
    other: "{{count}} "
  },
  overXYears: {
    one: "  ",
    other: "{{count}}  "
  },
  almostXYears: {
    one: "  ",
    other: " {{count}} "
  }
};
const formatDistance$18 = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$17[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", numberToLocale$1(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "  ";
    } else {
      return result + " ";
    }
  }
  return result;
};
const dateFormats$1g = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
const timeFormats$1g = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$1g = {
  full: "{{date}} {{time}} ''",
  long: "{{date}} {{time}} ''",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$1g = {
  date: buildFormatLongFn({
    formats: dateFormats$1g,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1g,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1g,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$18 = {
  lastWeek: "'' eeee '' p",
  yesterday: "'' '' p",
  today: "'' '' p",
  tomorrow: "'' '' p",
  nextWeek: "eeee '' p",
  other: "P"
};
const formatRelative$18 = (token, _date, _baseDate, _options) => formatRelativeLocale$18[token];
const matchOrdinalNumberPattern$17 = /^(\d+)(||||||)?/i;
const parseOrdinalNumberPattern$17 = /\d+/i;
const matchEraPatterns$17 = {
  narrow: /^(|)/i,
  abbreviated: /^(|)/i,
  wide: /^(|)/i
};
const parseEraPatterns$17 = {
  narrow: [/^/i, /^/i],
  abbreviated: [/^/i, /^/i],
  wide: [/^/i, /^/i]
};
const matchQuarterPatterns$17 = {
  narrow: /^[]/i,
  abbreviated: /^[]/i,
  wide: /^[](||)? /i
};
const parseQuarterPatterns$17 = {
  any: [//i, //i, //i, //i]
};
const matchMonthPatterns$17 = {
  narrow: /^(|||||||||||)/i,
  abbreviated: /^(|||||||||||)/i,
  wide: /^(|||||||||||)/i
};
const parseMonthPatterns$17 = {
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$17 = {
  narrow: /^(||||||)+/i,
  short: /^(||||||)+/i,
  abbreviated: /^(||||||)+/i,
  wide: /^(|||| ||)+/i
};
const parseDayPatterns$17 = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  short: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  abbreviated: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  wide: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^ /i,
    /^/i,
    /^/i
  ]
};
const matchDayPeriodPatterns$17 = {
  narrow: /^(|||||||)/i,
  abbreviated: /^(|||||||)/i,
  wide: /^(|||||||)/i
};
const parseDayPeriodPatterns$17 = {
  any: {
    am: /^/i,
    pm: /^/i,
    midnight: /^/i,
    noon: /^/i,
    morning: //i,
    afternoon: //i,
    evening: //i,
    night: //i
  }
};
const match$17 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$17,
    parsePattern: parseOrdinalNumberPattern$17,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$17,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$17,
    defaultParseWidth: "wide"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$17,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$17,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$17,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$17,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$17,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$17,
    defaultParseWidth: "wide"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$17,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$17,
    defaultParseWidth: "any"
  })
};
const bn = {
  code: "bn",
  formatDistance: formatDistance$18,
  formatLong: formatLong$1g,
  formatRelative: formatRelative$18,
  localize: localize$18,
  match: match$17,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$16 = {
  lessThanXSeconds: {
    one: {
      standalone: "manje od 1 sekunde",
      withPrepositionAgo: "manje od 1 sekunde",
      withPrepositionIn: "manje od 1 sekundu"
    },
    dual: "manje od {{count}} sekunde",
    other: "manje od {{count}} sekundi"
  },
  xSeconds: {
    one: {
      standalone: "1 sekunda",
      withPrepositionAgo: "1 sekunde",
      withPrepositionIn: "1 sekundu"
    },
    dual: "{{count}} sekunde",
    other: "{{count}} sekundi"
  },
  halfAMinute: "pola minute",
  lessThanXMinutes: {
    one: {
      standalone: "manje od 1 minute",
      withPrepositionAgo: "manje od 1 minute",
      withPrepositionIn: "manje od 1 minutu"
    },
    dual: "manje od {{count}} minute",
    other: "manje od {{count}} minuta"
  },
  xMinutes: {
    one: {
      standalone: "1 minuta",
      withPrepositionAgo: "1 minute",
      withPrepositionIn: "1 minutu"
    },
    dual: "{{count}} minute",
    other: "{{count}} minuta"
  },
  aboutXHours: {
    one: {
      standalone: "oko 1 sat",
      withPrepositionAgo: "oko 1 sat",
      withPrepositionIn: "oko 1 sat"
    },
    dual: "oko {{count}} sata",
    other: "oko {{count}} sati"
  },
  xHours: {
    one: {
      standalone: "1 sat",
      withPrepositionAgo: "1 sat",
      withPrepositionIn: "1 sat"
    },
    dual: "{{count}} sata",
    other: "{{count}} sati"
  },
  xDays: {
    one: {
      standalone: "1 dan",
      withPrepositionAgo: "1 dan",
      withPrepositionIn: "1 dan"
    },
    dual: "{{count}} dana",
    other: "{{count}} dana"
  },
  aboutXWeeks: {
    one: {
      standalone: "oko 1 sedmicu",
      withPrepositionAgo: "oko 1 sedmicu",
      withPrepositionIn: "oko 1 sedmicu"
    },
    dual: "oko {{count}} sedmice",
    other: "oko {{count}} sedmice"
  },
  xWeeks: {
    one: {
      standalone: "1 sedmicu",
      withPrepositionAgo: "1 sedmicu",
      withPrepositionIn: "1 sedmicu"
    },
    dual: "{{count}} sedmice",
    other: "{{count}} sedmice"
  },
  aboutXMonths: {
    one: {
      standalone: "oko 1 mjesec",
      withPrepositionAgo: "oko 1 mjesec",
      withPrepositionIn: "oko 1 mjesec"
    },
    dual: "oko {{count}} mjeseca",
    other: "oko {{count}} mjeseci"
  },
  xMonths: {
    one: {
      standalone: "1 mjesec",
      withPrepositionAgo: "1 mjesec",
      withPrepositionIn: "1 mjesec"
    },
    dual: "{{count}} mjeseca",
    other: "{{count}} mjeseci"
  },
  aboutXYears: {
    one: {
      standalone: "oko 1 godinu",
      withPrepositionAgo: "oko 1 godinu",
      withPrepositionIn: "oko 1 godinu"
    },
    dual: "oko {{count}} godine",
    other: "oko {{count}} godina"
  },
  xYears: {
    one: {
      standalone: "1 godina",
      withPrepositionAgo: "1 godine",
      withPrepositionIn: "1 godinu"
    },
    dual: "{{count}} godine",
    other: "{{count}} godina"
  },
  overXYears: {
    one: {
      standalone: "preko 1 godinu",
      withPrepositionAgo: "preko 1 godinu",
      withPrepositionIn: "preko 1 godinu"
    },
    dual: "preko {{count}} godine",
    other: "preko {{count}} godina"
  },
  almostXYears: {
    one: {
      standalone: "gotovo 1 godinu",
      withPrepositionAgo: "gotovo 1 godinu",
      withPrepositionIn: "gotovo 1 godinu"
    },
    dual: "gotovo {{count}} godine",
    other: "gotovo {{count}} godina"
  }
};
const formatDistance$17 = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$16[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    if (options?.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        result = tokenValue.one.withPrepositionIn;
      } else {
        result = tokenValue.one.withPrepositionAgo;
      }
    } else {
      result = tokenValue.one.standalone;
    }
  } else if (count % 10 > 1 && count % 10 < 5 && // if last digit is between 2 and 4
  String(count).substr(-2, 1) !== "1") {
    result = tokenValue.dual.replace("{{count}}", String(count));
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "za " + result;
    } else {
      return "prije " + result;
    }
  }
  return result;
};
const dateFormats$1f = {
  full: "EEEE, d. MMMM yyyy.",
  long: "d. MMMM yyyy.",
  medium: "d. MMM yy.",
  short: "dd. MM. yy."
};
const timeFormats$1f = {
  full: "HH:mm:ss (zzzz)",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$1f = {
  full: "{{date}} 'u' {{time}}",
  long: "{{date}} 'u' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$1f = {
  date: buildFormatLongFn({
    formats: dateFormats$1f,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1f,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1f,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$17 = {
  lastWeek: (date2) => {
    switch (date2.getDay()) {
      case 0:
        return "'prole nedjelje u' p";
      case 3:
        return "'prole srijede u' p";
      case 6:
        return "'prole subote u' p";
      default:
        return "'proli' EEEE 'u' p";
    }
  },
  yesterday: "'jue u' p",
  today: "'danas u' p",
  tomorrow: "'sutra u' p",
  nextWeek: (date2) => {
    switch (date2.getDay()) {
      case 0:
        return "'sljedee nedjelje u' p";
      case 3:
        return "'sljedeu srijedu u' p";
      case 6:
        return "'sljedeu subotu u' p";
      default:
        return "'sljedei' EEEE 'u' p";
    }
  },
  other: "P"
};
const formatRelative$17 = (token, date2, _baseDate, _options) => {
  const format2 = formatRelativeLocale$17[token];
  if (typeof format2 === "function") {
    return format2(date2);
  }
  return format2;
};
const eraValues$17 = {
  narrow: ["pr.n.e.", "AD"],
  abbreviated: ["pr. Hr.", "po. Hr."],
  wide: ["Prije Hrista", "Poslije Hrista"]
};
const quarterValues$17 = {
  narrow: ["1.", "2.", "3.", "4."],
  abbreviated: ["1. kv.", "2. kv.", "3. kv.", "4. kv."],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
const monthValues$17 = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12."
  ],
  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "maj",
    "jun",
    "jul",
    "avg",
    "sep",
    "okt",
    "nov",
    "dec"
  ],
  wide: [
    "januar",
    "februar",
    "mart",
    "april",
    "maj",
    "juni",
    "juli",
    "avgust",
    "septembar",
    "oktobar",
    "novembar",
    "decembar"
  ]
};
const formattingMonthValues$g = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12."
  ],
  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "maj",
    "jun",
    "jul",
    "avg",
    "sep",
    "okt",
    "nov",
    "dec"
  ],
  wide: [
    "januar",
    "februar",
    "mart",
    "april",
    "maj",
    "juni",
    "juli",
    "avgust",
    "septembar",
    "oktobar",
    "novembar",
    "decembar"
  ]
};
const dayValues$17 = {
  narrow: ["N", "P", "U", "S", "", "P", "S"],
  short: ["ned", "pon", "uto", "sre", "et", "pet", "sub"],
  abbreviated: ["ned", "pon", "uto", "sre", "et", "pet", "sub"],
  wide: [
    "nedjelja",
    "ponedjeljak",
    "utorak",
    "srijeda",
    "etvrtak",
    "petak",
    "subota"
  ]
};
const dayPeriodValues$17 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "pono",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uvee",
    night: "nou"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "pono",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uvee",
    night: "nou"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "pono",
    noon: "podne",
    morning: "ujutru",
    afternoon: "poslije podne",
    evening: "uvee",
    night: "nou"
  }
};
const formattingDayPeriodValues$U = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "pono",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uvee",
    night: "nou"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "pono",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uvee",
    night: "nou"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "pono",
    noon: "podne",
    morning: "ujutru",
    afternoon: "poslije podne",
    evening: "uvee",
    night: "nou"
  }
};
const ordinalNumber$17 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return String(number2) + ".";
};
const localize$17 = {
  ordinalNumber: ordinalNumber$17,
  era: buildLocalizeFn({
    values: eraValues$17,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$17,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$17,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$g,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$17,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$17,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$U,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$16 = /^(\d+)\./i;
const parseOrdinalNumberPattern$16 = /\d+/i;
const matchEraPatterns$16 = {
  narrow: /^(pr\.n\.e\.|AD)/i,
  abbreviated: /^(pr\.\s?Hr\.|po\.\s?Hr\.)/i,
  wide: /^(Prije Hrista|prije nove ere|Poslije Hrista|nova era)/i
};
const parseEraPatterns$16 = {
  any: [/^pr/i, /^(po|nova)/i]
};
const matchQuarterPatterns$16 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]\.\s?kv\.?/i,
  wide: /^[1234]\. kvartal/i
};
const parseQuarterPatterns$16 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$16 = {
  narrow: /^(10|11|12|[123456789])\./i,
  abbreviated: /^(jan|feb|mar|apr|maj|jun|jul|avg|sep|okt|nov|dec)/i,
  wide: /^((januar|januara)|(februar|februara)|(mart|marta)|(april|aprila)|(maj|maja)|(juni|juna)|(juli|jula)|(avgust|avgusta)|(septembar|septembra)|(oktobar|oktobra)|(novembar|novembra)|(decembar|decembra))/i
};
const parseMonthPatterns$16 = {
  narrow: [
    /^1/i,
    /^2/i,
    /^3/i,
    /^4/i,
    /^5/i,
    /^6/i,
    /^7/i,
    /^8/i,
    /^9/i,
    /^10/i,
    /^11/i,
    /^12/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^avg/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$16 = {
  narrow: /^[npusc]/i,
  short: /^(ned|pon|uto|sre|(et|cet)|pet|sub)/i,
  abbreviated: /^(ned|pon|uto|sre|(et|cet)|pet|sub)/i,
  wide: /^(nedjelja|ponedjeljak|utorak|srijeda|(etvrtak|cetvrtak)|petak|subota)/i
};
const parseDayPatterns$16 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns$16 = {
  any: /^(am|pm|ponoc|pono|(po)?podne|uvece|uvee|nou|poslije podne|ujutru)/i
};
const parseDayPeriodPatterns$16 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^pono/i,
    noon: /^pod/i,
    morning: /jutro/i,
    afternoon: /(poslije\s|po)+podne/i,
    evening: /(uvece|uvee)/i,
    night: /(nocu|nou)/i
  }
};
const match$16 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$16,
    parsePattern: parseOrdinalNumberPattern$16,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$16,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$16,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$16,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$16,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$16,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$16,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$16,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$16,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$16,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$16,
    defaultParseWidth: "any"
  })
};
const bs = {
  code: "bs",
  formatDistance: formatDistance$17,
  formatLong: formatLong$1f,
  formatRelative: formatRelative$17,
  localize: localize$17,
  match: match$16,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$15 = {
  lessThanXSeconds: {
    one: "menys d'un segon",
    eleven: "menys d'onze segons",
    other: "menys de {{count}} segons"
  },
  xSeconds: {
    one: "1 segon",
    other: "{{count}} segons"
  },
  halfAMinute: "mig minut",
  lessThanXMinutes: {
    one: "menys d'un minut",
    eleven: "menys d'onze minuts",
    other: "menys de {{count}} minuts"
  },
  xMinutes: {
    one: "1 minut",
    other: "{{count}} minuts"
  },
  aboutXHours: {
    one: "aproximadament una hora",
    other: "aproximadament {{count}} hores"
  },
  xHours: {
    one: "1 hora",
    other: "{{count}} hores"
  },
  xDays: {
    one: "1 dia",
    other: "{{count}} dies"
  },
  aboutXWeeks: {
    one: "aproximadament una setmana",
    other: "aproximadament {{count}} setmanes"
  },
  xWeeks: {
    one: "1 setmana",
    other: "{{count}} setmanes"
  },
  aboutXMonths: {
    one: "aproximadament un mes",
    other: "aproximadament {{count}} mesos"
  },
  xMonths: {
    one: "1 mes",
    other: "{{count}} mesos"
  },
  aboutXYears: {
    one: "aproximadament un any",
    other: "aproximadament {{count}} anys"
  },
  xYears: {
    one: "1 any",
    other: "{{count}} anys"
  },
  overXYears: {
    one: "ms d'un any",
    eleven: "ms d'onze anys",
    other: "ms de {{count}} anys"
  },
  almostXYears: {
    one: "gaireb un any",
    other: "gaireb {{count}} anys"
  }
};
const formatDistance$16 = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$15[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 11 && tokenValue.eleven) {
    result = tokenValue.eleven;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "en " + result;
    } else {
      return "fa " + result;
    }
  }
  return result;
};
const dateFormats$1e = {
  full: "EEEE, d 'de' MMMM y",
  long: "d 'de' MMMM y",
  medium: "d MMM y",
  short: "dd/MM/y"
};
const timeFormats$1e = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$1e = {
  full: "{{date}} 'a les' {{time}}",
  long: "{{date}} 'a les' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$1e = {
  date: buildFormatLongFn({
    formats: dateFormats$1e,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1e,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1e,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$16 = {
  lastWeek: "'el' eeee 'passat a la' LT",
  yesterday: "'ahir a la' p",
  today: "'avui a la' p",
  tomorrow: "'dem a la' p",
  nextWeek: "eeee 'a la' p",
  other: "P"
};
const formatRelativeLocalePlural$3 = {
  lastWeek: "'el' eeee 'passat a les' p",
  yesterday: "'ahir a les' p",
  today: "'avui a les' p",
  tomorrow: "'dem a les' p",
  nextWeek: "eeee 'a les' p",
  other: "P"
};
const formatRelative$16 = (token, date2, _baseDate, _options) => {
  if (date2.getHours() !== 1) {
    return formatRelativeLocalePlural$3[token];
  }
  return formatRelativeLocale$16[token];
};
const eraValues$16 = {
  narrow: ["aC", "dC"],
  abbreviated: ["a. de C.", "d. de C."],
  wide: ["abans de Crist", "desprs de Crist"]
};
const quarterValues$16 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1r trimestre", "2n trimestre", "3r trimestre", "4t trimestre"]
};
const monthValues$16 = {
  narrow: [
    "GN",
    "FB",
    "M",
    "AB",
    "MG",
    "JN",
    "JL",
    "AG",
    "ST",
    "OC",
    "NV",
    "DS"
  ],
  /**
   * Les abreviatures dels mesos de l'any es formen seguint una de les normes generals de formaci d'abreviatures.
   * S'escriu la primera sllaba i les consonants de la sllaba segent anteriors a la primera vocal.
   * Els mesos de mar, maig i juny no s'abreugen perqu sn paraules d'una sola sllaba.
   */
  abbreviated: [
    "gen.",
    "febr.",
    "mar",
    "abr.",
    "maig",
    "juny",
    "jul.",
    "ag.",
    "set.",
    "oct.",
    "nov.",
    "des."
  ],
  wide: [
    "gener",
    "febrer",
    "mar",
    "abril",
    "maig",
    "juny",
    "juliol",
    "agost",
    "setembre",
    "octubre",
    "novembre",
    "desembre"
  ]
};
const dayValues$16 = {
  narrow: ["dg.", "dl.", "dt.", "dm.", "dj.", "dv.", "ds."],
  short: ["dg.", "dl.", "dt.", "dm.", "dj.", "dv.", "ds."],
  abbreviated: ["dg.", "dl.", "dt.", "dm.", "dj.", "dv.", "ds."],
  wide: [
    "diumenge",
    "dilluns",
    "dimarts",
    "dimecres",
    "dijous",
    "divendres",
    "dissabte"
  ]
};
const dayPeriodValues$16 = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "mitjanit",
    noon: "migdia",
    morning: "mat",
    afternoon: "tarda",
    evening: "vespre",
    night: "nit"
  },
  abbreviated: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "mitjanit",
    noon: "migdia",
    morning: "mat",
    afternoon: "tarda",
    evening: "vespre",
    night: "nit"
  },
  wide: {
    am: "ante meridiem",
    pm: "post meridiem",
    midnight: "mitjanit",
    noon: "migdia",
    morning: "mat",
    afternoon: "tarda",
    evening: "vespre",
    night: "nit"
  }
};
const formattingDayPeriodValues$T = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "de la mitjanit",
    noon: "del migdia",
    morning: "del mat",
    afternoon: "de la tarda",
    evening: "del vespre",
    night: "de la nit"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "de la mitjanit",
    noon: "del migdia",
    morning: "del mat",
    afternoon: "de la tarda",
    evening: "del vespre",
    night: "de la nit"
  },
  wide: {
    am: "ante meridiem",
    pm: "post meridiem",
    midnight: "de la mitjanit",
    noon: "del migdia",
    morning: "del mat",
    afternoon: "de la tarda",
    evening: "del vespre",
    night: "de la nit"
  }
};
const ordinalNumber$16 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  const rem100 = number2 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number2 + "r";
      case 2:
        return number2 + "n";
      case 3:
        return number2 + "r";
      case 4:
        return number2 + "t";
    }
  }
  return number2 + "";
};
const localize$16 = {
  ordinalNumber: ordinalNumber$16,
  era: buildLocalizeFn({
    values: eraValues$16,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$16,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$16,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$16,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$16,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$T,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$15 = /^(\d+)(|r|n|r|t)?/i;
const parseOrdinalNumberPattern$15 = /\d+/i;
const matchEraPatterns$15 = {
  narrow: /^(aC|dC)/i,
  abbreviated: /^(a. de C.|d. de C.)/i,
  wide: /^(abans de Crist|despr[e]s de Crist)/i
};
const parseEraPatterns$15 = {
  narrow: [/^aC/i, /^dC/i],
  abbreviated: [/^(a. de C.)/i, /^(d. de C.)/i],
  wide: [/^(abans de Crist)/i, /^(despr[e]s de Crist)/i]
};
const matchQuarterPatterns$15 = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^[1234](|r|n|r|t)? trimestre/i
};
const parseQuarterPatterns$15 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$15 = {
  narrow: /^(GN|FB|M|AB|MG|JN|JL|AG|ST|OC|NV|DS)/i,
  abbreviated: /^(gen.|febr.|mar|abr.|maig|juny|jul.|ag.|set.|oct.|nov.|des.)/i,
  wide: /^(gener|febrer|mar|abril|maig|juny|juliol|agost|setembre|octubre|novembre|desembre)/i
};
const parseMonthPatterns$15 = {
  narrow: [
    /^GN/i,
    /^FB/i,
    /^M/i,
    /^AB/i,
    /^MG/i,
    /^JN/i,
    /^JL/i,
    /^AG/i,
    /^ST/i,
    /^OC/i,
    /^NV/i,
    /^DS/i
  ],
  abbreviated: [
    /^gen./i,
    /^febr./i,
    /^mar/i,
    /^abr./i,
    /^maig/i,
    /^juny/i,
    /^jul./i,
    /^ag./i,
    /^set./i,
    /^oct./i,
    /^nov./i,
    /^des./i
  ],
  wide: [
    /^gener/i,
    /^febrer/i,
    /^mar/i,
    /^abril/i,
    /^maig/i,
    /^juny/i,
    /^juliol/i,
    /^agost/i,
    /^setembre/i,
    /^octubre/i,
    /^novembre/i,
    /^desembre/i
  ]
};
const matchDayPatterns$15 = {
  narrow: /^(dg\.|dl\.|dt\.|dm\.|dj\.|dv\.|ds\.)/i,
  short: /^(dg\.|dl\.|dt\.|dm\.|dj\.|dv\.|ds\.)/i,
  abbreviated: /^(dg\.|dl\.|dt\.|dm\.|dj\.|dv\.|ds\.)/i,
  wide: /^(diumenge|dilluns|dimarts|dimecres|dijous|divendres|dissabte)/i
};
const parseDayPatterns$15 = {
  narrow: [/^dg./i, /^dl./i, /^dt./i, /^dm./i, /^dj./i, /^dv./i, /^ds./i],
  abbreviated: [/^dg./i, /^dl./i, /^dt./i, /^dm./i, /^dj./i, /^dv./i, /^ds./i],
  wide: [
    /^diumenge/i,
    /^dilluns/i,
    /^dimarts/i,
    /^dimecres/i,
    /^dijous/i,
    /^divendres/i,
    /^disssabte/i
  ]
};
const matchDayPeriodPatterns$15 = {
  narrow: /^(a|p|mn|md|(del|de la) (mat|tarda|vespre|nit))/i,
  abbreviated: /^([ap]\.?\s?m\.?|mitjanit|migdia|(del|de la) (mat|tarda|vespre|nit))/i,
  wide: /^(ante meridiem|post meridiem|mitjanit|migdia|(del|de la) (mat|tarda|vespre|nit))/i
};
const parseDayPeriodPatterns$15 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mitjanit/i,
    noon: /^migdia/i,
    morning: /mat/i,
    afternoon: /tarda/i,
    evening: /vespre/i,
    night: /nit/i
  }
};
const match$15 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$15,
    parsePattern: parseOrdinalNumberPattern$15,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$15,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$15,
    defaultParseWidth: "wide"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$15,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$15,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$15,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$15,
    defaultParseWidth: "wide"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$15,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$15,
    defaultParseWidth: "wide"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$15,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$15,
    defaultParseWidth: "any"
  })
};
const ca = {
  code: "ca",
  formatDistance: formatDistance$16,
  formatLong: formatLong$1e,
  formatRelative: formatRelative$16,
  localize: localize$16,
  match: match$15,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$14 = {
  lessThanXSeconds: {
    one: "   ",
    other: "  {{count}} "
  },
  xSeconds: {
    one: "1 ",
    other: "{{count}} "
  },
  halfAMinute: " ",
  lessThanXMinutes: {
    one: "   ",
    other: "  {{count}} "
  },
  xMinutes: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: " 1 ",
    other: " {{count}} "
  },
  xHours: {
    one: "1 ",
    other: "{{count}} "
  },
  xDays: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: " 1 ",
    other: " {{count}} "
  },
  xWeeks: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: " 1 ",
    other: " {{count}} "
  },
  xMonths: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: "  1 ",
    other: " {{count}} "
  },
  xYears: {
    one: "1 ",
    other: "{{count}} "
  },
  overXYears: {
    one: "  ",
    other: "  {{count}} "
  },
  almostXYears: {
    one: "   ",
    other: " {{count}} "
  }
};
const formatDistance$15 = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$14[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "  " + result + "";
    } else {
      return result + " ";
    }
  }
  return result;
};
const dateFormats$1d = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
const timeFormats$1d = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$1d = {
  full: "{{date}} '' {{time}}",
  long: "{{date}} '' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$1d = {
  date: buildFormatLongFn({
    formats: dateFormats$1d,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1d,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1d,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$15 = {
  lastWeek: "' ' eeee '' p",
  yesterday: "' ' p",
  today: "' ' p",
  tomorrow: "' ' p",
  nextWeek: "eeee '' p",
  other: "P"
};
const formatRelative$15 = (token, _date, _baseDate, _options) => formatRelativeLocale$15[token];
const eraValues$15 = {
  narrow: ["", ""],
  abbreviated: ["-", "-"],
  wide: [" ", " "]
};
const quarterValues$15 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1", "2", "3", "4"],
  wide: [" ", " ", " ", " "]
};
const monthValues$15 = {
  narrow: [
    "-",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "-",
    "-",
    "-"
  ],
  abbreviated: [
    "-",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "-",
    "-",
    "-"
  ],
  wide: [
    " ",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    " ",
    " ",
    " "
  ]
};
const dayValues$15 = {
  narrow: ["-", "-", "-", "-", "-", "", ""],
  short: ["-", "-", "-", "-", "-", "", ""],
  abbreviated: [
    "-",
    "-",
    "-",
    "-",
    "-",
    "",
    ""
  ],
  wide: [
    " ",
    " ",
    " ",
    " ",
    " ",
    "",
    ""
  ]
};
const dayPeriodValues$15 = {
  narrow: {
    am: "",
    pm: "",
    midnight: "-",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "-",
    pm: "-",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  },
  wide: {
    am: " ",
    pm: " ",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$S = {
  narrow: {
    am: "",
    pm: "",
    midnight: "-",
    noon: "",
    morning: " ",
    afternoon: "  ",
    evening: " ",
    night: " "
  },
  abbreviated: {
    am: "-",
    pm: "-",
    midnight: " ",
    noon: "",
    morning: " ",
    afternoon: "  ",
    evening: " ",
    night: " "
  },
  wide: {
    am: " ",
    pm: " ",
    midnight: " ",
    noon: "",
    morning: " ",
    afternoon: "  ",
    evening: " ",
    night: " "
  }
};
const ordinalNumber$15 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
const localize$15 = {
  ordinalNumber: ordinalNumber$15,
  era: buildLocalizeFn({
    values: eraValues$15,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$15,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$15,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$15,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$15,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$S,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$14 = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$14 = /\d+/i;
const matchEraPatterns$14 = {
  narrow: /^(|)/i,
  abbreviated: /^(-|.)/i,
  wide: /^( |  )/i
};
const parseEraPatterns$14 = {
  any: [/^/g, /^/g]
};
const matchQuarterPatterns$14 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]/i,
  wide: /^(||| ) ()? quarter/i
};
const parseQuarterPatterns$14 = {
  wide: [/ /, / /, / /, / /],
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$14 = {
  narrow: /^(-||||||||-|-|-)/i,
  abbreviated: /^(-|||||||||-|-|-)/i,
  wide: /^( ||||||||| | | )/i
};
const parseMonthPatterns$14 = {
  narrow: [
    /^-/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^-/i,
    /^-/i,
    /^-/i
  ],
  any: [
    /^-/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^-/i,
    /^-/i,
    /^|-/i
  ]
};
const matchDayPatterns$14 = {
  narrow: /^(||||||)/i,
  short: /^(-|-|-|-|-||)/i,
  abbreviated: /^(-|-|-|-|-||)/i,
  wide: /^( | | | | ||)/i
};
const parseDayPatterns$14 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns$14 = {
  narrow: /^(||-|| (| ||))/i,
  abbreviated: /^(-|-| ||| ||)/,
  wide: /^( | || ||| | )/,
  any: /^(|||||)/
};
const parseDayPeriodPatterns$14 = {
  any: {
    am: /^/i,
    pm: /^/i,
    midnight: /^-/i,
    noon: /^/i,
    morning: //i,
    afternoon: //i,
    evening: //i,
    night: //i
  }
};
const match$14 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$14,
    parsePattern: parseOrdinalNumberPattern$14,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$14,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$14,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$14,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$14,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$14,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$14,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$14,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$14,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$14,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$14,
    defaultParseWidth: "any"
  })
};
const ckb = {
  code: "ckb",
  formatDistance: formatDistance$15,
  formatLong: formatLong$1d,
  formatRelative: formatRelative$15,
  localize: localize$15,
  match: match$14,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$13 = {
  lessThanXSeconds: {
    one: {
      regular: "mn ne 1 sekunda",
      past: "ped mn ne 1 sekundou",
      future: "za mn ne 1 sekundu"
    },
    few: {
      regular: "mn ne {{count}} sekundy",
      past: "ped mn ne {{count}} sekundami",
      future: "za mn ne {{count}} sekundy"
    },
    many: {
      regular: "mn ne {{count}} sekund",
      past: "ped mn ne {{count}} sekundami",
      future: "za mn ne {{count}} sekund"
    }
  },
  xSeconds: {
    one: {
      regular: "1 sekunda",
      past: "ped 1 sekundou",
      future: "za 1 sekundu"
    },
    few: {
      regular: "{{count}} sekundy",
      past: "ped {{count}} sekundami",
      future: "za {{count}} sekundy"
    },
    many: {
      regular: "{{count}} sekund",
      past: "ped {{count}} sekundami",
      future: "za {{count}} sekund"
    }
  },
  halfAMinute: {
    type: "other",
    other: {
      regular: "pl minuty",
      past: "ped pl minutou",
      future: "za pl minuty"
    }
  },
  lessThanXMinutes: {
    one: {
      regular: "mn ne 1 minuta",
      past: "ped mn ne 1 minutou",
      future: "za mn ne 1 minutu"
    },
    few: {
      regular: "mn ne {{count}} minuty",
      past: "ped mn ne {{count}} minutami",
      future: "za mn ne {{count}} minuty"
    },
    many: {
      regular: "mn ne {{count}} minut",
      past: "ped mn ne {{count}} minutami",
      future: "za mn ne {{count}} minut"
    }
  },
  xMinutes: {
    one: {
      regular: "1 minuta",
      past: "ped 1 minutou",
      future: "za 1 minutu"
    },
    few: {
      regular: "{{count}} minuty",
      past: "ped {{count}} minutami",
      future: "za {{count}} minuty"
    },
    many: {
      regular: "{{count}} minut",
      past: "ped {{count}} minutami",
      future: "za {{count}} minut"
    }
  },
  aboutXHours: {
    one: {
      regular: "piblin 1 hodina",
      past: "piblin ped 1 hodinou",
      future: "piblin za 1 hodinu"
    },
    few: {
      regular: "piblin {{count}} hodiny",
      past: "piblin ped {{count}} hodinami",
      future: "piblin za {{count}} hodiny"
    },
    many: {
      regular: "piblin {{count}} hodin",
      past: "piblin ped {{count}} hodinami",
      future: "piblin za {{count}} hodin"
    }
  },
  xHours: {
    one: {
      regular: "1 hodina",
      past: "ped 1 hodinou",
      future: "za 1 hodinu"
    },
    few: {
      regular: "{{count}} hodiny",
      past: "ped {{count}} hodinami",
      future: "za {{count}} hodiny"
    },
    many: {
      regular: "{{count}} hodin",
      past: "ped {{count}} hodinami",
      future: "za {{count}} hodin"
    }
  },
  xDays: {
    one: {
      regular: "1 den",
      past: "ped 1 dnem",
      future: "za 1 den"
    },
    few: {
      regular: "{{count}} dny",
      past: "ped {{count}} dny",
      future: "za {{count}} dny"
    },
    many: {
      regular: "{{count}} dn",
      past: "ped {{count}} dny",
      future: "za {{count}} dn"
    }
  },
  aboutXWeeks: {
    one: {
      regular: "piblin 1 tden",
      past: "piblin ped 1 tdnem",
      future: "piblin za 1 tden"
    },
    few: {
      regular: "piblin {{count}} tdny",
      past: "piblin ped {{count}} tdny",
      future: "piblin za {{count}} tdny"
    },
    many: {
      regular: "piblin {{count}} tdn",
      past: "piblin ped {{count}} tdny",
      future: "piblin za {{count}} tdn"
    }
  },
  xWeeks: {
    one: {
      regular: "1 tden",
      past: "ped 1 tdnem",
      future: "za 1 tden"
    },
    few: {
      regular: "{{count}} tdny",
      past: "ped {{count}} tdny",
      future: "za {{count}} tdny"
    },
    many: {
      regular: "{{count}} tdn",
      past: "ped {{count}} tdny",
      future: "za {{count}} tdn"
    }
  },
  aboutXMonths: {
    one: {
      regular: "piblin 1 msc",
      past: "piblin ped 1 mscem",
      future: "piblin za 1 msc"
    },
    few: {
      regular: "piblin {{count}} msce",
      past: "piblin ped {{count}} msci",
      future: "piblin za {{count}} msce"
    },
    many: {
      regular: "piblin {{count}} msc",
      past: "piblin ped {{count}} msci",
      future: "piblin za {{count}} msc"
    }
  },
  xMonths: {
    one: {
      regular: "1 msc",
      past: "ped 1 mscem",
      future: "za 1 msc"
    },
    few: {
      regular: "{{count}} msce",
      past: "ped {{count}} msci",
      future: "za {{count}} msce"
    },
    many: {
      regular: "{{count}} msc",
      past: "ped {{count}} msci",
      future: "za {{count}} msc"
    }
  },
  aboutXYears: {
    one: {
      regular: "piblin 1 rok",
      past: "piblin ped 1 rokem",
      future: "piblin za 1 rok"
    },
    few: {
      regular: "piblin {{count}} roky",
      past: "piblin ped {{count}} roky",
      future: "piblin za {{count}} roky"
    },
    many: {
      regular: "piblin {{count}} rok",
      past: "piblin ped {{count}} roky",
      future: "piblin za {{count}} rok"
    }
  },
  xYears: {
    one: {
      regular: "1 rok",
      past: "ped 1 rokem",
      future: "za 1 rok"
    },
    few: {
      regular: "{{count}} roky",
      past: "ped {{count}} roky",
      future: "za {{count}} roky"
    },
    many: {
      regular: "{{count}} rok",
      past: "ped {{count}} roky",
      future: "za {{count}} rok"
    }
  },
  overXYears: {
    one: {
      regular: "vce ne 1 rok",
      past: "ped vce ne 1 rokem",
      future: "za vce ne 1 rok"
    },
    few: {
      regular: "vce ne {{count}} roky",
      past: "ped vce ne {{count}} roky",
      future: "za vce ne {{count}} roky"
    },
    many: {
      regular: "vce ne {{count}} rok",
      past: "ped vce ne {{count}} roky",
      future: "za vce ne {{count}} rok"
    }
  },
  almostXYears: {
    one: {
      regular: "skoro 1 rok",
      past: "skoro ped 1 rokem",
      future: "skoro za 1 rok"
    },
    few: {
      regular: "skoro {{count}} roky",
      past: "skoro ped {{count}} roky",
      future: "skoro za {{count}} roky"
    },
    many: {
      regular: "skoro {{count}} rok",
      past: "skoro ped {{count}} roky",
      future: "skoro za {{count}} rok"
    }
  }
};
const formatDistance$14 = (token, count, options) => {
  let pluralResult;
  const tokenValue = formatDistanceLocale$13[token];
  if (tokenValue.type === "other") {
    pluralResult = tokenValue.other;
  } else if (count === 1) {
    pluralResult = tokenValue.one;
  } else if (count > 1 && count < 5) {
    pluralResult = tokenValue.few;
  } else {
    pluralResult = tokenValue.many;
  }
  const suffixExist = options?.addSuffix === true;
  const comparison = options?.comparison;
  let timeResult;
  if (suffixExist && comparison === -1) {
    timeResult = pluralResult.past;
  } else if (suffixExist && comparison === 1) {
    timeResult = pluralResult.future;
  } else {
    timeResult = pluralResult.regular;
  }
  return timeResult.replace("{{count}}", String(count));
};
const dateFormats$1c = {
  full: "EEEE, d. MMMM yyyy",
  long: "d. MMMM yyyy",
  medium: "d. M. yyyy",
  short: "dd.MM.yyyy"
};
const timeFormats$1c = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
const dateTimeFormats$1c = {
  full: "{{date}} 'v' {{time}}",
  long: "{{date}} 'v' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$1c = {
  date: buildFormatLongFn({
    formats: dateFormats$1c,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1c,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1c,
    defaultWidth: "full"
  })
};
const accusativeWeekdays$5 = [
  "nedli",
  "pondl",
  "ter",
  "stedu",
  "tvrtek",
  "ptek",
  "sobotu"
];
const formatRelativeLocale$14 = {
  lastWeek: "'posledn' eeee 've' p",
  yesterday: "'vera v' p",
  today: "'dnes v' p",
  tomorrow: "'ztra v' p",
  nextWeek: (date2) => {
    const day = date2.getDay();
    return "'v " + accusativeWeekdays$5[day] + " o' p";
  },
  other: "P"
};
const formatRelative$14 = (token, date2) => {
  const format2 = formatRelativeLocale$14[token];
  if (typeof format2 === "function") {
    return format2(date2);
  }
  return format2;
};
const eraValues$14 = {
  narrow: ["p. n. l.", "n. l."],
  abbreviated: ["p. n. l.", "n. l."],
  wide: ["ped nam letopotem", "naeho letopotu"]
};
const quarterValues$14 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1. tvrtlet", "2. tvrtlet", "3. tvrtlet", "4. tvrtlet"],
  wide: ["1. tvrtlet", "2. tvrtlet", "3. tvrtlet", "4. tvrtlet"]
};
const monthValues$14 = {
  narrow: ["L", "", "B", "D", "K", "", "", "S", "Z", "", "L", "P"],
  abbreviated: [
    "led",
    "no",
    "be",
    "dub",
    "kv",
    "vn",
    "vc",
    "srp",
    "z",
    "j",
    "lis",
    "pro"
  ],
  wide: [
    "leden",
    "nor",
    "bezen",
    "duben",
    "kvten",
    "erven",
    "ervenec",
    "srpen",
    "z",
    "jen",
    "listopad",
    "prosinec"
  ]
};
const formattingMonthValues$f = {
  narrow: ["L", "", "B", "D", "K", "", "", "S", "Z", "", "L", "P"],
  abbreviated: [
    "led",
    "no",
    "be",
    "dub",
    "kv",
    "vn",
    "vc",
    "srp",
    "z",
    "j",
    "lis",
    "pro"
  ],
  wide: [
    "ledna",
    "nora",
    "bezna",
    "dubna",
    "kvtna",
    "ervna",
    "ervence",
    "srpna",
    "z",
    "jna",
    "listopadu",
    "prosince"
  ]
};
const dayValues$14 = {
  narrow: ["ne", "po", "t", "st", "t", "p", "so"],
  short: ["ne", "po", "t", "st", "t", "p", "so"],
  abbreviated: ["ned", "pon", "te", "st", "tv", "pt", "sob"],
  wide: ["nedle", "pondl", "ter", "steda", "tvrtek", "ptek", "sobota"]
};
const dayPeriodValues$14 = {
  narrow: {
    am: "dop.",
    pm: "odp.",
    midnight: "plnoc",
    noon: "poledne",
    morning: "rno",
    afternoon: "odpoledne",
    evening: "veer",
    night: "noc"
  },
  abbreviated: {
    am: "dop.",
    pm: "odp.",
    midnight: "plnoc",
    noon: "poledne",
    morning: "rno",
    afternoon: "odpoledne",
    evening: "veer",
    night: "noc"
  },
  wide: {
    am: "dopoledne",
    pm: "odpoledne",
    midnight: "plnoc",
    noon: "poledne",
    morning: "rno",
    afternoon: "odpoledne",
    evening: "veer",
    night: "noc"
  }
};
const formattingDayPeriodValues$R = {
  narrow: {
    am: "dop.",
    pm: "odp.",
    midnight: "plnoc",
    noon: "poledne",
    morning: "rno",
    afternoon: "odpoledne",
    evening: "veer",
    night: "noc"
  },
  abbreviated: {
    am: "dop.",
    pm: "odp.",
    midnight: "plnoc",
    noon: "poledne",
    morning: "rno",
    afternoon: "odpoledne",
    evening: "veer",
    night: "noc"
  },
  wide: {
    am: "dopoledne",
    pm: "odpoledne",
    midnight: "plnoc",
    noon: "poledne",
    morning: "rno",
    afternoon: "odpoledne",
    evening: "veer",
    night: "noc"
  }
};
const ordinalNumber$14 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$14 = {
  ordinalNumber: ordinalNumber$14,
  era: buildLocalizeFn({
    values: eraValues$14,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$14,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$14,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$f,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$14,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$14,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$R,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$13 = /^(\d+)\.?/i;
const parseOrdinalNumberPattern$13 = /\d+/i;
const matchEraPatterns$13 = {
  narrow: /^(p[r](\.|ed) Kr\.|p[r](\.|ed) n\. l\.|po Kr\.|n\. l\.)/i,
  abbreviated: /^(p[r](\.|ed) Kr\.|p[r](\.|ed) n\. l\.|po Kr\.|n\. l\.)/i,
  wide: /^(p[r](\.|ed) Kristem|p[r](\.|ed) na[s][i]m letopo[c]tem|po Kristu|na[s]eho letopo[c]tu)/i
};
const parseEraPatterns$13 = {
  any: [/^p[r]/i, /^(po|n)/i]
};
const matchQuarterPatterns$13 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]\. [c]tvrtlet[i]/i,
  wide: /^[1234]\. [c]tvrtlet[i]/i
};
const parseQuarterPatterns$13 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$13 = {
  narrow: /^[lubdkcszrlp]/i,
  abbreviated: /^(led|[u]no|b[r]e|dub|kv[e]|[c]vn|[c]vc|srp|z[a][r]|[r][i]j|lis|pro)/i,
  wide: /^(leden|ledna|[u]nora?|b[r]ezen|b[r]ezna|duben|dubna|kv[e]ten|kv[e]tna|[c]erven(ec|ce)?|[c]ervna|srpen|srpna|z[a][r][i]|[r][i]jen|[r][i]jna|listopad(a|u)?|prosinec|prosince)/i
};
const parseMonthPatterns$13 = {
  narrow: [
    /^l/i,
    /^[u]/i,
    /^b/i,
    /^d/i,
    /^k/i,
    /^[c]/i,
    /^[c]/i,
    /^s/i,
    /^z/i,
    /^[r]/i,
    /^l/i,
    /^p/i
  ],
  any: [
    /^led/i,
    /^[u]n/i,
    /^b[r]e/i,
    /^dub/i,
    /^kv[e]/i,
    /^[c]vn|[c]erven(?!\w)|[c]ervna/i,
    /^[c]vc|[c]erven(ec|ce)/i,
    /^srp/i,
    /^z[a][r]/i,
    /^[r][i]j/i,
    /^lis/i,
    /^pro/i
  ]
};
const matchDayPatterns$13 = {
  narrow: /^[npusps]/i,
  short: /^(ne|po|[u]t|st|[c]t|p[a]|so)/i,
  abbreviated: /^(ned|pon|[u]te|st[r]|[c]tv|p[a]t|sob)/i,
  wide: /^(ned[e]le|pond[e]l[i]|[u]ter[y]|st[r]eda|[c]tvrtek|p[a]tek|sobota)/i
};
const parseDayPatterns$13 = {
  narrow: [/^n/i, /^p/i, /^[u]/i, /^s/i, /^[c]/i, /^p/i, /^s/i],
  any: [/^ne/i, /^po/i, /^[u]t/i, /^st/i, /^[c]t/i, /^p[a]/i, /^so/i]
};
const matchDayPeriodPatterns$13 = {
  any: /^dopoledne|dop\.?|odpoledne|odp\.?|p[u]lnoc|poledne|r[a]no|odpoledne|ve[c]er|(v )?noci?/i
};
const parseDayPeriodPatterns$13 = {
  any: {
    am: /^dop/i,
    pm: /^odp/i,
    midnight: /^p[u]lnoc/i,
    noon: /^poledne/i,
    morning: /r[a]no/i,
    afternoon: /odpoledne/i,
    evening: /ve[c]er/i,
    night: /noc/i
  }
};
const match$13 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$13,
    parsePattern: parseOrdinalNumberPattern$13,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$13,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$13,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$13,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$13,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$13,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$13,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$13,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$13,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$13,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$13,
    defaultParseWidth: "any"
  })
};
const cs = {
  code: "cs",
  formatDistance: formatDistance$14,
  formatLong: formatLong$1c,
  formatRelative: formatRelative$14,
  localize: localize$14,
  match: match$13,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$12 = {
  lessThanXSeconds: {
    one: "llai na eiliad",
    other: "llai na {{count}} eiliad"
  },
  xSeconds: {
    one: "1 eiliad",
    other: "{{count}} eiliad"
  },
  halfAMinute: "hanner munud",
  lessThanXMinutes: {
    one: "llai na munud",
    two: "llai na 2 funud",
    other: "llai na {{count}} munud"
  },
  xMinutes: {
    one: "1 munud",
    two: "2 funud",
    other: "{{count}} munud"
  },
  aboutXHours: {
    one: "tua 1 awr",
    other: "tua {{count}} awr"
  },
  xHours: {
    one: "1 awr",
    other: "{{count}} awr"
  },
  xDays: {
    one: "1 diwrnod",
    two: "2 ddiwrnod",
    other: "{{count}} diwrnod"
  },
  aboutXWeeks: {
    one: "tua 1 wythnos",
    two: "tua pythefnos",
    other: "tua {{count}} wythnos"
  },
  xWeeks: {
    one: "1 wythnos",
    two: "pythefnos",
    other: "{{count}} wythnos"
  },
  aboutXMonths: {
    one: "tua 1 mis",
    two: "tua 2 fis",
    other: "tua {{count}} mis"
  },
  xMonths: {
    one: "1 mis",
    two: "2 fis",
    other: "{{count}} mis"
  },
  aboutXYears: {
    one: "tua 1 flwyddyn",
    two: "tua 2 flynedd",
    other: "tua {{count}} mlynedd"
  },
  xYears: {
    one: "1 flwyddyn",
    two: "2 flynedd",
    other: "{{count}} mlynedd"
  },
  overXYears: {
    one: "dros 1 flwyddyn",
    two: "dros 2 flynedd",
    other: "dros {{count}} mlynedd"
  },
  almostXYears: {
    one: "bron 1 flwyddyn",
    two: "bron 2 flynedd",
    other: "bron {{count}} mlynedd"
  }
};
const formatDistance$13 = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$12[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 2 && !!tokenValue.two) {
    result = tokenValue.two;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "mewn " + result;
    } else {
      return result + " yn l";
    }
  }
  return result;
};
const dateFormats$1b = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd/MM/yyyy"
};
const timeFormats$1b = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$1b = {
  full: "{{date}} 'am' {{time}}",
  long: "{{date}} 'am' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$1b = {
  date: buildFormatLongFn({
    formats: dateFormats$1b,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1b,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1b,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$13 = {
  lastWeek: "eeee 'diwethaf am' p",
  yesterday: "'ddoe am' p",
  today: "'heddiw am' p",
  tomorrow: "'yfory am' p",
  nextWeek: "eeee 'am' p",
  other: "P"
};
const formatRelative$13 = (token, _date, _baseDate, _options) => formatRelativeLocale$13[token];
const eraValues$13 = {
  narrow: ["C", "O"],
  abbreviated: ["CC", "OC"],
  wide: ["Cyn Crist", "Ar l Crist"]
};
const quarterValues$13 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Ch1", "Ch2", "Ch3", "Ch4"],
  wide: ["Chwarter 1af", "2ail chwarter", "3ydd chwarter", "4ydd chwarter"]
};
const monthValues$13 = {
  narrow: ["I", "Ch", "Ma", "E", "Mi", "Me", "G", "A", "Md", "H", "T", "Rh"],
  abbreviated: [
    "Ion",
    "Chwe",
    "Maw",
    "Ebr",
    "Mai",
    "Meh",
    "Gor",
    "Aws",
    "Med",
    "Hyd",
    "Tach",
    "Rhag"
  ],
  wide: [
    "Ionawr",
    "Chwefror",
    "Mawrth",
    "Ebrill",
    "Mai",
    "Mehefin",
    "Gorffennaf",
    "Awst",
    "Medi",
    "Hydref",
    "Tachwedd",
    "Rhagfyr"
  ]
};
const dayValues$13 = {
  narrow: ["S", "Ll", "M", "M", "I", "G", "S"],
  short: ["Su", "Ll", "Ma", "Me", "Ia", "Gw", "Sa"],
  abbreviated: ["Sul", "Llun", "Maw", "Mer", "Iau", "Gwe", "Sad"],
  wide: [
    "dydd Sul",
    "dydd Llun",
    "dydd Mawrth",
    "dydd Mercher",
    "dydd Iau",
    "dydd Gwener",
    "dydd Sadwrn"
  ]
};
const dayPeriodValues$13 = {
  narrow: {
    am: "b",
    pm: "h",
    midnight: "hn",
    noon: "hd",
    morning: "bore",
    afternoon: "prynhawn",
    evening: "gyda'r nos",
    night: "nos"
  },
  abbreviated: {
    am: "yb",
    pm: "yh",
    midnight: "hanner nos",
    noon: "hanner dydd",
    morning: "bore",
    afternoon: "prynhawn",
    evening: "gyda'r nos",
    night: "nos"
  },
  wide: {
    am: "y.b.",
    pm: "y.h.",
    midnight: "hanner nos",
    noon: "hanner dydd",
    morning: "bore",
    afternoon: "prynhawn",
    evening: "gyda'r nos",
    night: "nos"
  }
};
const formattingDayPeriodValues$Q = {
  narrow: {
    am: "b",
    pm: "h",
    midnight: "hn",
    noon: "hd",
    morning: "yn y bore",
    afternoon: "yn y prynhawn",
    evening: "gyda'r nos",
    night: "yn y nos"
  },
  abbreviated: {
    am: "yb",
    pm: "yh",
    midnight: "hanner nos",
    noon: "hanner dydd",
    morning: "yn y bore",
    afternoon: "yn y prynhawn",
    evening: "gyda'r nos",
    night: "yn y nos"
  },
  wide: {
    am: "y.b.",
    pm: "y.h.",
    midnight: "hanner nos",
    noon: "hanner dydd",
    morning: "yn y bore",
    afternoon: "yn y prynhawn",
    evening: "gyda'r nos",
    night: "yn y nos"
  }
};
const ordinalNumber$13 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  if (number2 < 20) {
    switch (number2) {
      case 0:
        return number2 + "fed";
      case 1:
        return number2 + "af";
      case 2:
        return number2 + "ail";
      case 3:
      case 4:
        return number2 + "ydd";
      case 5:
      case 6:
        return number2 + "ed";
      case 7:
      case 8:
      case 9:
      case 10:
      case 12:
      case 15:
      case 18:
        return number2 + "fed";
      case 11:
      case 13:
      case 14:
      case 16:
      case 17:
      case 19:
        return number2 + "eg";
    }
  } else if (number2 >= 50 && number2 <= 60 || number2 === 80 || number2 >= 100) {
    return number2 + "fed";
  }
  return number2 + "ain";
};
const localize$13 = {
  ordinalNumber: ordinalNumber$13,
  era: buildLocalizeFn({
    values: eraValues$13,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$13,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$13,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$13,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$13,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$Q,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$12 = /^(\d+)(af|ail|ydd|ed|fed|eg|ain)?/i;
const parseOrdinalNumberPattern$12 = /\d+/i;
const matchEraPatterns$12 = {
  narrow: /^(c|o)/i,
  abbreviated: /^(c\.?\s?c\.?|o\.?\s?c\.?)/i,
  wide: /^(cyn christ|ar l crist|ar ol crist)/i
};
const parseEraPatterns$12 = {
  wide: [/^c/i, /^(ar l crist|ar ol crist)/i],
  any: [/^c/i, /^o/i]
};
const matchQuarterPatterns$12 = {
  narrow: /^[1234]/i,
  abbreviated: /^ch[1234]/i,
  wide: /^(chwarter 1af)|([234](ail|ydd)? chwarter)/i
};
const parseQuarterPatterns$12 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$12 = {
  narrow: /^(i|ch|m|e|g|a|h|t|rh)/i,
  abbreviated: /^(ion|chwe|maw|ebr|mai|meh|gor|aws|med|hyd|tach|rhag)/i,
  wide: /^(ionawr|chwefror|mawrth|ebrill|mai|mehefin|gorffennaf|awst|medi|hydref|tachwedd|rhagfyr)/i
};
const parseMonthPatterns$12 = {
  narrow: [
    /^i/i,
    /^ch/i,
    /^m/i,
    /^e/i,
    /^m/i,
    /^m/i,
    /^g/i,
    /^a/i,
    /^m/i,
    /^h/i,
    /^t/i,
    /^rh/i
  ],
  any: [
    /^io/i,
    /^ch/i,
    /^maw/i,
    /^e/i,
    /^mai/i,
    /^meh/i,
    /^g/i,
    /^a/i,
    /^med/i,
    /^h/i,
    /^t/i,
    /^rh/i
  ]
};
const matchDayPatterns$12 = {
  narrow: /^(s|ll|m|i|g)/i,
  short: /^(su|ll|ma|me|ia|gw|sa)/i,
  abbreviated: /^(sul|llun|maw|mer|iau|gwe|sad)/i,
  wide: /^dydd (sul|llun|mawrth|mercher|iau|gwener|sadwrn)/i
};
const parseDayPatterns$12 = {
  narrow: [/^s/i, /^ll/i, /^m/i, /^m/i, /^i/i, /^g/i, /^s/i],
  wide: [
    /^dydd su/i,
    /^dydd ll/i,
    /^dydd ma/i,
    /^dydd me/i,
    /^dydd i/i,
    /^dydd g/i,
    /^dydd sa/i
  ],
  any: [/^su/i, /^ll/i, /^ma/i, /^me/i, /^i/i, /^g/i, /^sa/i]
};
const matchDayPeriodPatterns$12 = {
  narrow: /^(b|h|hn|hd|(yn y|y|yr|gyda'r) (bore|prynhawn|nos|hwyr))/i,
  any: /^(y\.?\s?[bh]\.?|hanner nos|hanner dydd|(yn y|y|yr|gyda'r) (bore|prynhawn|nos|hwyr))/i
};
const parseDayPeriodPatterns$12 = {
  any: {
    am: /^b|(y\.?\s?b\.?)/i,
    pm: /^h|(y\.?\s?h\.?)|(yr hwyr)/i,
    midnight: /^hn|hanner nos/i,
    noon: /^hd|hanner dydd/i,
    morning: /bore/i,
    afternoon: /prynhawn/i,
    evening: /^gyda'r nos$/i,
    night: /blah/i
  }
};
const match$12 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$12,
    parsePattern: parseOrdinalNumberPattern$12,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$12,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$12,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$12,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$12,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$12,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$12,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$12,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$12,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$12,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$12,
    defaultParseWidth: "any"
  })
};
const cy = {
  code: "cy",
  formatDistance: formatDistance$13,
  formatLong: formatLong$1b,
  formatRelative: formatRelative$13,
  localize: localize$13,
  match: match$12,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$11 = {
  lessThanXSeconds: {
    one: "mindre end t sekund",
    other: "mindre end {{count}} sekunder"
  },
  xSeconds: {
    one: "1 sekund",
    other: "{{count}} sekunder"
  },
  halfAMinute: "t halvt minut",
  lessThanXMinutes: {
    one: "mindre end t minut",
    other: "mindre end {{count}} minutter"
  },
  xMinutes: {
    one: "1 minut",
    other: "{{count}} minutter"
  },
  aboutXHours: {
    one: "cirka 1 time",
    other: "cirka {{count}} timer"
  },
  xHours: {
    one: "1 time",
    other: "{{count}} timer"
  },
  xDays: {
    one: "1 dag",
    other: "{{count}} dage"
  },
  aboutXWeeks: {
    one: "cirka 1 uge",
    other: "cirka {{count}} uger"
  },
  xWeeks: {
    one: "1 uge",
    other: "{{count}} uger"
  },
  aboutXMonths: {
    one: "cirka 1 mned",
    other: "cirka {{count}} mneder"
  },
  xMonths: {
    one: "1 mned",
    other: "{{count}} mneder"
  },
  aboutXYears: {
    one: "cirka 1 r",
    other: "cirka {{count}} r"
  },
  xYears: {
    one: "1 r",
    other: "{{count}} r"
  },
  overXYears: {
    one: "over 1 r",
    other: "over {{count}} r"
  },
  almostXYears: {
    one: "nsten 1 r",
    other: "nsten {{count}} r"
  }
};
const formatDistance$12 = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$11[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "om " + result;
    } else {
      return result + " siden";
    }
  }
  return result;
};
const dateFormats$1a = {
  full: "EEEE 'den' d. MMMM y",
  long: "d. MMMM y",
  medium: "d. MMM y",
  short: "dd/MM/y"
};
const timeFormats$1a = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$1a = {
  full: "{{date}} 'kl'. {{time}}",
  long: "{{date}} 'kl'. {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$1a = {
  date: buildFormatLongFn({
    formats: dateFormats$1a,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1a,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1a,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$12 = {
  lastWeek: "'sidste' eeee 'kl.' p",
  yesterday: "'i gr kl.' p",
  today: "'i dag kl.' p",
  tomorrow: "'i morgen kl.' p",
  nextWeek: "'p' eeee 'kl.' p",
  other: "P"
};
const formatRelative$12 = (token, _date, _baseDate, _options) => formatRelativeLocale$12[token];
const eraValues$12 = {
  narrow: ["fvt", "vt"],
  abbreviated: ["f.v.t.", "v.t."],
  wide: ["fr vesterlandsk tidsregning", "vesterlandsk tidsregning"]
};
const quarterValues$12 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1. kvt.", "2. kvt.", "3. kvt.", "4. kvt."],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
const monthValues$12 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mar.",
    "apr.",
    "maj",
    "jun.",
    "jul.",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "dec."
  ],
  wide: [
    "januar",
    "februar",
    "marts",
    "april",
    "maj",
    "juni",
    "juli",
    "august",
    "september",
    "oktober",
    "november",
    "december"
  ]
};
const dayValues$12 = {
  narrow: ["S", "M", "T", "O", "T", "F", "L"],
  short: ["s", "ma", "ti", "on", "to", "fr", "l"],
  abbreviated: ["sn.", "man.", "tir.", "ons.", "tor.", "fre.", "lr."],
  wide: [
    "sndag",
    "mandag",
    "tirsdag",
    "onsdag",
    "torsdag",
    "fredag",
    "lrdag"
  ]
};
const dayPeriodValues$12 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "midnat",
    noon: "middag",
    morning: "morgen",
    afternoon: "eftermiddag",
    evening: "aften",
    night: "nat"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnat",
    noon: "middag",
    morning: "morgen",
    afternoon: "eftermiddag",
    evening: "aften",
    night: "nat"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnat",
    noon: "middag",
    morning: "morgen",
    afternoon: "eftermiddag",
    evening: "aften",
    night: "nat"
  }
};
const formattingDayPeriodValues$P = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "midnat",
    noon: "middag",
    morning: "om morgenen",
    afternoon: "om eftermiddagen",
    evening: "om aftenen",
    night: "om natten"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnat",
    noon: "middag",
    morning: "om morgenen",
    afternoon: "om eftermiddagen",
    evening: "om aftenen",
    night: "om natten"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnat",
    noon: "middag",
    morning: "om morgenen",
    afternoon: "om eftermiddagen",
    evening: "om aftenen",
    night: "om natten"
  }
};
const ordinalNumber$12 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$12 = {
  ordinalNumber: ordinalNumber$12,
  era: buildLocalizeFn({
    values: eraValues$12,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$12,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$12,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$12,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$12,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$P,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$11 = /^(\d+)(\.)?/i;
const parseOrdinalNumberPattern$11 = /\d+/i;
const matchEraPatterns$11 = {
  narrow: /^(fKr|fvt|eKr|vt)/i,
  abbreviated: /^(f\.Kr\.?|f\.v\.t\.?|e\.Kr\.?|v\.t\.)/i,
  wide: /^(f.Kr.|fr vesterlandsk tidsregning|e.Kr.|vesterlandsk tidsregning)/i
};
const parseEraPatterns$11 = {
  any: [/^f/i, /^(v|e)/i]
};
const matchQuarterPatterns$11 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]. kvt\./i,
  wide: /^[1234]\.? kvartal/i
};
const parseQuarterPatterns$11 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$11 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan.|feb.|mar.|apr.|maj|jun.|jul.|aug.|sep.|okt.|nov.|dec.)/i,
  wide: /^(januar|februar|marts|april|maj|juni|juli|august|september|oktober|november|december)/i
};
const parseMonthPatterns$11 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$11 = {
  narrow: /^[smtofl]/i,
  short: /^(sn.|man.|tir.|ons.|tor.|fre.|lr.)/i,
  abbreviated: /^(sn|man|tir|ons|tor|fre|lr)/i,
  wide: /^(sndag|mandag|tirsdag|onsdag|torsdag|fredag|lrdag)/i
};
const parseDayPatterns$11 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^o/i, /^t/i, /^f/i, /^l/i],
  any: [/^s/i, /^m/i, /^ti/i, /^o/i, /^to/i, /^f/i, /^l/i]
};
const matchDayPeriodPatterns$11 = {
  narrow: /^(a|p|midnat|middag|(om) (morgenen|eftermiddagen|aftenen|natten))/i,
  any: /^([ap]\.?\s?m\.?|midnat|middag|(om) (morgenen|eftermiddagen|aftenen|natten))/i
};
const parseDayPeriodPatterns$11 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /midnat/i,
    noon: /middag/i,
    morning: /morgen/i,
    afternoon: /eftermiddag/i,
    evening: /aften/i,
    night: /nat/i
  }
};
const match$11 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$11,
    parsePattern: parseOrdinalNumberPattern$11,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$11,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$11,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$11,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$11,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$11,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$11,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$11,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$11,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$11,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$11,
    defaultParseWidth: "any"
  })
};
const da = {
  code: "da",
  formatDistance: formatDistance$12,
  formatLong: formatLong$1a,
  formatRelative: formatRelative$12,
  localize: localize$12,
  match: match$11,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$10 = {
  lessThanXSeconds: {
    standalone: {
      one: "weniger als 1 Sekunde",
      other: "weniger als {{count}} Sekunden"
    },
    withPreposition: {
      one: "weniger als 1 Sekunde",
      other: "weniger als {{count}} Sekunden"
    }
  },
  xSeconds: {
    standalone: {
      one: "1 Sekunde",
      other: "{{count}} Sekunden"
    },
    withPreposition: {
      one: "1 Sekunde",
      other: "{{count}} Sekunden"
    }
  },
  halfAMinute: {
    standalone: "eine halbe Minute",
    withPreposition: "einer halben Minute"
  },
  lessThanXMinutes: {
    standalone: {
      one: "weniger als 1 Minute",
      other: "weniger als {{count}} Minuten"
    },
    withPreposition: {
      one: "weniger als 1 Minute",
      other: "weniger als {{count}} Minuten"
    }
  },
  xMinutes: {
    standalone: {
      one: "1 Minute",
      other: "{{count}} Minuten"
    },
    withPreposition: {
      one: "1 Minute",
      other: "{{count}} Minuten"
    }
  },
  aboutXHours: {
    standalone: {
      one: "etwa 1 Stunde",
      other: "etwa {{count}} Stunden"
    },
    withPreposition: {
      one: "etwa 1 Stunde",
      other: "etwa {{count}} Stunden"
    }
  },
  xHours: {
    standalone: {
      one: "1 Stunde",
      other: "{{count}} Stunden"
    },
    withPreposition: {
      one: "1 Stunde",
      other: "{{count}} Stunden"
    }
  },
  xDays: {
    standalone: {
      one: "1 Tag",
      other: "{{count}} Tage"
    },
    withPreposition: {
      one: "1 Tag",
      other: "{{count}} Tagen"
    }
  },
  aboutXWeeks: {
    standalone: {
      one: "etwa 1 Woche",
      other: "etwa {{count}} Wochen"
    },
    withPreposition: {
      one: "etwa 1 Woche",
      other: "etwa {{count}} Wochen"
    }
  },
  xWeeks: {
    standalone: {
      one: "1 Woche",
      other: "{{count}} Wochen"
    },
    withPreposition: {
      one: "1 Woche",
      other: "{{count}} Wochen"
    }
  },
  aboutXMonths: {
    standalone: {
      one: "etwa 1 Monat",
      other: "etwa {{count}} Monate"
    },
    withPreposition: {
      one: "etwa 1 Monat",
      other: "etwa {{count}} Monaten"
    }
  },
  xMonths: {
    standalone: {
      one: "1 Monat",
      other: "{{count}} Monate"
    },
    withPreposition: {
      one: "1 Monat",
      other: "{{count}} Monaten"
    }
  },
  aboutXYears: {
    standalone: {
      one: "etwa 1 Jahr",
      other: "etwa {{count}} Jahre"
    },
    withPreposition: {
      one: "etwa 1 Jahr",
      other: "etwa {{count}} Jahren"
    }
  },
  xYears: {
    standalone: {
      one: "1 Jahr",
      other: "{{count}} Jahre"
    },
    withPreposition: {
      one: "1 Jahr",
      other: "{{count}} Jahren"
    }
  },
  overXYears: {
    standalone: {
      one: "mehr als 1 Jahr",
      other: "mehr als {{count}} Jahre"
    },
    withPreposition: {
      one: "mehr als 1 Jahr",
      other: "mehr als {{count}} Jahren"
    }
  },
  almostXYears: {
    standalone: {
      one: "fast 1 Jahr",
      other: "fast {{count}} Jahre"
    },
    withPreposition: {
      one: "fast 1 Jahr",
      other: "fast {{count}} Jahren"
    }
  }
};
const formatDistance$11 = (token, count, options) => {
  let result;
  const tokenValue = options?.addSuffix ? formatDistanceLocale$10[token].withPreposition : formatDistanceLocale$10[token].standalone;
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return "vor " + result;
    }
  }
  return result;
};
const dateFormats$19 = {
  full: "EEEE, do MMMM y",
  // Montag, 7. Januar 2018
  long: "do MMMM y",
  // 7. Januar 2018
  medium: "do MMM y",
  // 7. Jan. 2018
  short: "dd.MM.y"
  // 07.01.2018
};
const timeFormats$19 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$19 = {
  full: "{{date}} 'um' {{time}}",
  long: "{{date}} 'um' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$19 = {
  date: buildFormatLongFn({
    formats: dateFormats$19,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$19,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$19,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$11 = {
  lastWeek: "'letzten' eeee 'um' p",
  yesterday: "'gestern um' p",
  today: "'heute um' p",
  tomorrow: "'morgen um' p",
  nextWeek: "eeee 'um' p",
  other: "P"
};
const formatRelative$11 = (token, _date, _baseDate, _options) => formatRelativeLocale$11[token];
const eraValues$11 = {
  narrow: ["v.Chr.", "n.Chr."],
  abbreviated: ["v.Chr.", "n.Chr."],
  wide: ["vor Christus", "nach Christus"]
};
const quarterValues$11 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. Quartal", "2. Quartal", "3. Quartal", "4. Quartal"]
};
const monthValues$11 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mr",
    "Apr",
    "Mai",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Okt",
    "Nov",
    "Dez"
  ],
  wide: [
    "Januar",
    "Februar",
    "Mrz",
    "April",
    "Mai",
    "Juni",
    "Juli",
    "August",
    "September",
    "Oktober",
    "November",
    "Dezember"
  ]
};
const formattingMonthValues$e = {
  narrow: monthValues$11.narrow,
  abbreviated: [
    "Jan.",
    "Feb.",
    "Mrz",
    "Apr.",
    "Mai",
    "Juni",
    "Juli",
    "Aug.",
    "Sep.",
    "Okt.",
    "Nov.",
    "Dez."
  ],
  wide: monthValues$11.wide
};
const dayValues$11 = {
  narrow: ["S", "M", "D", "M", "D", "F", "S"],
  short: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
  abbreviated: ["So.", "Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa."],
  wide: [
    "Sonntag",
    "Montag",
    "Dienstag",
    "Mittwoch",
    "Donnerstag",
    "Freitag",
    "Samstag"
  ]
};
const dayPeriodValues$11 = {
  narrow: {
    am: "vm.",
    pm: "nm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachm.",
    evening: "Abend",
    night: "Nacht"
  },
  abbreviated: {
    am: "vorm.",
    pm: "nachm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachmittag",
    evening: "Abend",
    night: "Nacht"
  },
  wide: {
    am: "vormittags",
    pm: "nachmittags",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachmittag",
    evening: "Abend",
    night: "Nacht"
  }
};
const formattingDayPeriodValues$O = {
  narrow: {
    am: "vm.",
    pm: "nm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachm.",
    evening: "abends",
    night: "nachts"
  },
  abbreviated: {
    am: "vorm.",
    pm: "nachm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachmittags",
    evening: "abends",
    night: "nachts"
  },
  wide: {
    am: "vormittags",
    pm: "nachmittags",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachmittags",
    evening: "abends",
    night: "nachts"
  }
};
const ordinalNumber$11 = (dirtyNumber) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$11 = {
  ordinalNumber: ordinalNumber$11,
  era: buildLocalizeFn({
    values: eraValues$11,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$11,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$11,
    formattingValues: formattingMonthValues$e,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$11,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$11,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$O,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$10 = /^(\d+)(\.)?/i;
const parseOrdinalNumberPattern$10 = /\d+/i;
const matchEraPatterns$10 = {
  narrow: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  abbreviated: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  wide: /^(vor Christus|vor unserer Zeitrechnung|nach Christus|unserer Zeitrechnung)/i
};
const parseEraPatterns$10 = {
  any: [/^v/i, /^n/i]
};
const matchQuarterPatterns$10 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? Quartal/i
};
const parseQuarterPatterns$10 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$10 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(j[a]n|feb|mr[z]?|apr|mai|jun[i]?|jul[i]?|aug|sep|okt|nov|dez)\.?/i,
  wide: /^(januar|februar|mrz|april|mai|juni|juli|august|september|oktober|november|dezember)/i
};
const parseMonthPatterns$10 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^j[a]/i,
    /^f/i,
    /^mr/i,
    /^ap/i,
    /^mai/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$10 = {
  narrow: /^[smdmf]/i,
  short: /^(so|mo|di|mi|do|fr|sa)/i,
  abbreviated: /^(son?|mon?|die?|mit?|don?|fre?|sam?)\.?/i,
  wide: /^(sonntag|montag|dienstag|mittwoch|donnerstag|freitag|samstag)/i
};
const parseDayPatterns$10 = {
  any: [/^so/i, /^mo/i, /^di/i, /^mi/i, /^do/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns$10 = {
  narrow: /^(vm\.?|nm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
  abbreviated: /^(vorm\.?|nachm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
  wide: /^(vormittags|nachmittags|Mitternacht|Mittag|morgens|nachmittags|abends|nachts)/i
};
const parseDayPeriodPatterns$10 = {
  any: {
    am: /^v/i,
    pm: /^n/i,
    midnight: /^Mitte/i,
    noon: /^Mitta/i,
    morning: /morgens/i,
    afternoon: /nachmittags/i,
    // will never be matched. Afternoon is matched by `pm`
    evening: /abends/i,
    night: /nachts/i
    // will never be matched. Night is matched by `pm`
  }
};
const match$10 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$10,
    parsePattern: parseOrdinalNumberPattern$10,
    valueCallback: (value) => parseInt(value)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$10,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$10,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$10,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$10,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$10,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$10,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$10,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$10,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$10,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$10,
    defaultParseWidth: "any"
  })
};
const de = {
  code: "de",
  formatDistance: formatDistance$11,
  formatLong: formatLong$19,
  formatRelative: formatRelative$11,
  localize: localize$11,
  match: match$10,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const eraValues$10 = {
  narrow: ["v.Chr.", "n.Chr."],
  abbreviated: ["v.Chr.", "n.Chr."],
  wide: ["vor Christus", "nach Christus"]
};
const quarterValues$10 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. Quartal", "2. Quartal", "3. Quartal", "4. Quartal"]
};
const monthValues$10 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jn",
    "Feb",
    "Mr",
    "Apr",
    "Mai",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Okt",
    "Nov",
    "Dez"
  ],
  wide: [
    "Jnner",
    "Februar",
    "Mrz",
    "April",
    "Mai",
    "Juni",
    "Juli",
    "August",
    "September",
    "Oktober",
    "November",
    "Dezember"
  ]
};
const formattingMonthValues$d = {
  narrow: monthValues$10.narrow,
  abbreviated: [
    "Jn.",
    "Feb.",
    "Mrz",
    "Apr.",
    "Mai",
    "Juni",
    "Juli",
    "Aug.",
    "Sep.",
    "Okt.",
    "Nov.",
    "Dez."
  ],
  wide: monthValues$10.wide
};
const dayValues$10 = {
  narrow: ["S", "M", "D", "M", "D", "F", "S"],
  short: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
  abbreviated: ["So.", "Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa."],
  wide: [
    "Sonntag",
    "Montag",
    "Dienstag",
    "Mittwoch",
    "Donnerstag",
    "Freitag",
    "Samstag"
  ]
};
const dayPeriodValues$10 = {
  narrow: {
    am: "vm.",
    pm: "nm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachm.",
    evening: "Abend",
    night: "Nacht"
  },
  abbreviated: {
    am: "vorm.",
    pm: "nachm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachmittag",
    evening: "Abend",
    night: "Nacht"
  },
  wide: {
    am: "vormittags",
    pm: "nachmittags",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachmittag",
    evening: "Abend",
    night: "Nacht"
  }
};
const formattingDayPeriodValues$N = {
  narrow: {
    am: "vm.",
    pm: "nm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachm.",
    evening: "abends",
    night: "nachts"
  },
  abbreviated: {
    am: "vorm.",
    pm: "nachm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachmittags",
    evening: "abends",
    night: "nachts"
  },
  wide: {
    am: "vormittags",
    pm: "nachmittags",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachmittags",
    evening: "abends",
    night: "nachts"
  }
};
const ordinalNumber$10 = (dirtyNumber) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$10 = {
  ordinalNumber: ordinalNumber$10,
  era: buildLocalizeFn({
    values: eraValues$10,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$10,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$10,
    formattingValues: formattingMonthValues$d,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$10,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$10,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$N,
    defaultFormattingWidth: "wide"
  })
};
const deAT = {
  code: "de-AT",
  formatDistance: formatDistance$11,
  formatLong: formatLong$19,
  formatRelative: formatRelative$11,
  localize: localize$10,
  match: match$10,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$$ = {
  lessThanXSeconds: {
    one: "   ",
    other: "  {{count}} "
  },
  xSeconds: {
    one: "1 ",
    other: "{{count}} "
  },
  halfAMinute: " ",
  lessThanXMinutes: {
    one: "   ",
    other: "  {{count}} "
  },
  xMinutes: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: " 1 ",
    other: " {{count}} "
  },
  xHours: {
    one: "1 ",
    other: "{{count}} "
  },
  xDays: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: " 1 ",
    other: " {{count}} "
  },
  xWeeks: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: " 1 ",
    other: " {{count}} "
  },
  xMonths: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: " 1 ",
    other: " {{count}} "
  },
  xYears: {
    one: "1 ",
    other: "{{count}} "
  },
  overXYears: {
    one: "  1 ",
    other: "  {{count}} "
  },
  almostXYears: {
    one: " 1 ",
    other: " {{count}} "
  }
};
const formatDistance$10 = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$$[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return " " + result;
    } else {
      return result + " ";
    }
  }
  return result;
};
const dateFormats$18 = {
  full: "EEEE, d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "d/M/yy"
};
const timeFormats$18 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$18 = {
  full: "{{date}} - {{time}}",
  long: "{{date}} - {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$18 = {
  date: buildFormatLongFn({
    formats: dateFormats$18,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$18,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$18,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$10 = {
  lastWeek: (date2) => {
    switch (date2.getDay()) {
      case 6:
        return "' ' eeee '' p";
      default:
        return "' ' eeee '' p";
    }
  },
  yesterday: "' ' p",
  today: "' ' p",
  tomorrow: "' ' p",
  nextWeek: "eeee '' p",
  other: "P"
};
const formatRelative$10 = (token, date2) => {
  const format2 = formatRelativeLocale$10[token];
  if (typeof format2 === "function") return format2(date2);
  return format2;
};
const eraValues$$ = {
  narrow: ["", ""],
  abbreviated: ["..", ".."],
  wide: [" ", " "]
};
const quarterValues$$ = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1", "2", "3", "4"],
  wide: ["1 ", "2 ", "3 ", "4 "]
};
const monthValues$$ = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const formattingMonthValues$c = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$$ = {
  narrow: ["", "", "T", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$$ = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "..",
    pm: "..",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "..",
    pm: "..",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$$ = (dirtyNumber, options) => {
  const number2 = Number(dirtyNumber);
  const unit = options?.unit;
  let suffix;
  if (unit === "year" || unit === "month") {
    suffix = "";
  } else if (unit === "week" || unit === "dayOfYear" || unit === "day" || unit === "hour" || unit === "date") {
    suffix = "";
  } else {
    suffix = "";
  }
  return number2 + suffix;
};
const localize$$ = {
  ordinalNumber: ordinalNumber$$,
  era: buildLocalizeFn({
    values: eraValues$$,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$$,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$$,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$c,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$$,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$$,
    defaultWidth: "wide"
  })
};
const matchOrdinalNumberPattern$$ = /^(\d+)(||)?/i;
const parseOrdinalNumberPattern$$ = /\d+/i;
const matchEraPatterns$$ = {
  narrow: /^(|)/i,
  abbreviated: /^(\.?\s?\.?|\.?\s?\.?\s?\.?|\.?\s?\.?|\.?\s?\.?)/i,
  wide: /^( (|)| (|)  (|) (|)|(|) (|)|(|) (|))/i
};
const parseEraPatterns$$ = {
  any: [/^/i, /^(|)/i]
};
const matchQuarterPatterns$$ = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]/i,
  wide: /^[1234]? (|)/i
};
const parseQuarterPatterns$$ = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$$ = {
  narrow: /^[]/i,
  abbreviated: /^(||[]||[][]|[]|[]|[]|||[]|)/i,
  wide: /^([][]|[][])(|)|([]|[]|[]|[]|[]|[]|[]|[]|[]|[])(|)/i
};
const parseMonthPatterns$$ = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^[]/i,
    /^/i,
    /^[][]/i,
    /^[]/i,
    /^[]/i,
    /^[]/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$$ = {
  narrow: /^[]/i,
  short: /^(||||[]|[]|[])/i,
  abbreviated: /^(||||||)/i,
  wide: /^((|)|(|)|(|)|(|)|(|)|(|)|(|))/i
};
const parseDayPatterns$$ = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^[]/i, /^/i]
};
const matchDayPeriodPatterns$$ = {
  narrow: /^(||(|)|(|)|(|)|(|)|(|)|(|))/i,
  any: /^([]\.?\s?\.?|(|)|(|)|(|)|(|)|(|)|(|))/i
};
const parseDayPeriodPatterns$$ = {
  any: {
    am: /^|\.\s?\./i,
    pm: /^|\.\s?\./i,
    midnight: /^/i,
    noon: /^(|)/i,
    morning: /(|)/i,
    afternoon: /(|)/i,
    evening: /(|)/i,
    night: /(|)/i
  }
};
const match$$ = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$$,
    parsePattern: parseOrdinalNumberPattern$$,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$$,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$$,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$$,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$$,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$$,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$$,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$$,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$$,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$$,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$$,
    defaultParseWidth: "any"
  })
};
const el = {
  code: "el",
  formatDistance: formatDistance$10,
  formatLong: formatLong$18,
  formatRelative: formatRelative$10,
  localize: localize$$,
  match: match$$,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const dateFormats$17 = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd/MM/yyyy"
};
const timeFormats$17 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$17 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$17 = {
  date: buildFormatLongFn({
    formats: dateFormats$17,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$17,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$17,
    defaultWidth: "full"
  })
};
const enAU = {
  code: "en-AU",
  formatDistance: formatDistance$1k,
  formatLong: formatLong$17,
  formatRelative: formatRelative$1k,
  localize: localize$1k,
  match: match$1j,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$_ = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "a second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "a minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about an hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "an hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "a day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about a week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "a week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about a month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "a month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about a year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "a year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over a year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost a year",
    other: "almost {{count}} years"
  }
};
const formatDistance$$ = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$_[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
const dateFormats$16 = {
  full: "EEEE, MMMM do, yyyy",
  long: "MMMM do, yyyy",
  medium: "MMM d, yyyy",
  short: "yyyy-MM-dd"
};
const timeFormats$16 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$16 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$16 = {
  date: buildFormatLongFn({
    formats: dateFormats$16,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$16,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$16,
    defaultWidth: "full"
  })
};
const enCA = {
  code: "en-CA",
  formatDistance: formatDistance$$,
  formatLong: formatLong$16,
  formatRelative: formatRelative$1k,
  localize: localize$1k,
  match: match$1j,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const dateFormats$15 = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd/MM/yyyy"
};
const timeFormats$15 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$15 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$15 = {
  date: buildFormatLongFn({
    formats: dateFormats$15,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$15,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$15,
    defaultWidth: "full"
  })
};
const enGB = {
  code: "en-GB",
  formatDistance: formatDistance$1k,
  formatLong: formatLong$15,
  formatRelative: formatRelative$1k,
  localize: localize$1k,
  match: match$1j,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const enIE = {
  code: "en-IE",
  formatDistance: formatDistance$1k,
  formatLong: formatLong$15,
  formatRelative: formatRelative$1k,
  localize: localize$1k,
  match: match$1j,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const dateFormats$14 = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM, yyyy",
  medium: "d MMM, yyyy",
  short: "dd/MM/yyyy"
};
const timeFormats$14 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$14 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$14 = {
  date: buildFormatLongFn({
    formats: dateFormats$14,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$14,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$14,
    defaultWidth: "full"
  })
};
const enIN = {
  code: "en-IN",
  formatDistance: formatDistance$1k,
  formatLong: formatLong$14,
  formatRelative: formatRelative$1k,
  localize: localize$1k,
  match: match$1j,
  options: {
    weekStartsOn: 1,
    // Monday is the first day of the week.
    firstWeekContainsDate: 4
    // The week that contains Jan 4th is the first week of the year.
  }
};
const dateFormats$13 = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd/MM/yyyy"
};
const timeFormats$13 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$13 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$13 = {
  date: buildFormatLongFn({
    formats: dateFormats$13,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$13,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$13,
    defaultWidth: "full"
  })
};
const enNZ = {
  code: "en-NZ",
  formatDistance: formatDistance$1k,
  formatLong: formatLong$13,
  formatRelative: formatRelative$1k,
  localize: localize$1k,
  match: match$1j,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const dateFormats$12 = {
  full: "EEEE, dd MMMM yyyy",
  long: "dd MMMM yyyy",
  medium: "dd MMM yyyy",
  short: "yyyy/MM/dd"
};
const timeFormats$12 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$12 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$12 = {
  date: buildFormatLongFn({
    formats: dateFormats$12,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$12,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$12,
    defaultWidth: "full"
  })
};
const enZA = {
  code: "en-ZA",
  formatDistance: formatDistance$1k,
  formatLong: formatLong$12,
  formatRelative: formatRelative$1k,
  localize: localize$1k,
  match: match$1j,
  options: {
    weekStartsOn: 0,
    // Sunday is the first day of the week.
    firstWeekContainsDate: 1
    // The week that contains Jan 1st is the first week of the year.
  }
};
const formatDistanceLocale$Z = {
  lessThanXSeconds: {
    one: "malpli ol sekundo",
    other: "malpli ol {{count}} sekundoj"
  },
  xSeconds: {
    one: "1 sekundo",
    other: "{{count}} sekundoj"
  },
  halfAMinute: "duonminuto",
  lessThanXMinutes: {
    one: "malpli ol minuto",
    other: "malpli ol {{count}} minutoj"
  },
  xMinutes: {
    one: "1 minuto",
    other: "{{count}} minutoj"
  },
  aboutXHours: {
    one: "proksimume 1 horo",
    other: "proksimume {{count}} horoj"
  },
  xHours: {
    one: "1 horo",
    other: "{{count}} horoj"
  },
  xDays: {
    one: "1 tago",
    other: "{{count}} tagoj"
  },
  aboutXMonths: {
    one: "proksimume 1 monato",
    other: "proksimume {{count}} monatoj"
  },
  xWeeks: {
    one: "1 semajno",
    other: "{{count}} semajnoj"
  },
  aboutXWeeks: {
    one: "proksimume 1 semajno",
    other: "proksimume {{count}} semajnoj"
  },
  xMonths: {
    one: "1 monato",
    other: "{{count}} monatoj"
  },
  aboutXYears: {
    one: "proksimume 1 jaro",
    other: "proksimume {{count}} jaroj"
  },
  xYears: {
    one: "1 jaro",
    other: "{{count}} jaroj"
  },
  overXYears: {
    one: "pli ol 1 jaro",
    other: "pli ol {{count}} jaroj"
  },
  almostXYears: {
    one: "preska 1 jaro",
    other: "preska {{count}} jaroj"
  }
};
const formatDistance$_ = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$Z[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options?.comparison && options.comparison > 0) {
      return "post " + result;
    } else {
      return "anta " + result;
    }
  }
  return result;
};
const dateFormats$11 = {
  full: "EEEE, do 'de' MMMM y",
  long: "y-MMMM-dd",
  medium: "y-MMM-dd",
  short: "yyyy-MM-dd"
};
const timeFormats$11 = {
  full: "Ho 'horo kaj' m:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$11 = {
  any: "{{date}} {{time}}"
};
const formatLong$11 = {
  date: buildFormatLongFn({
    formats: dateFormats$11,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$11,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$11,
    defaultWidth: "any"
  })
};
const formatRelativeLocale$$ = {
  lastWeek: "'pasinta' eeee 'je' p",
  yesterday: "'hiera je' p",
  today: "'hodia je' p",
  tomorrow: "'morga je' p",
  nextWeek: "eeee 'je' p",
  other: "P"
};
const formatRelative$$ = (token, _date, _baseDate, _options) => formatRelativeLocale$$[token];
const eraValues$_ = {
  narrow: ["aK", "pK"],
  abbreviated: ["a.K.E.", "p.K.E."],
  wide: ["anta Komuna Erao", "Komuna Erao"]
};
const quarterValues$_ = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: [
    "1-a kvaronjaro",
    "2-a kvaronjaro",
    "3-a kvaronjaro",
    "4-a kvaronjaro"
  ]
};
const monthValues$_ = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "maj",
    "jun",
    "jul",
    "ag",
    "sep",
    "okt",
    "nov",
    "dec"
  ],
  wide: [
    "januaro",
    "februaro",
    "marto",
    "aprilo",
    "majo",
    "junio",
    "julio",
    "agusto",
    "septembro",
    "oktobro",
    "novembro",
    "decembro"
  ]
};
const dayValues$_ = {
  narrow: ["D", "L", "M", "M", "", "V", "S"],
  short: ["di", "lu", "ma", "me", "a", "ve", "sa"],
  abbreviated: ["dim", "lun", "mar", "mer", "a", "ven", "sab"],
  wide: [
    "dimano",
    "lundo",
    "mardo",
    "merkredo",
    "ado",
    "vendredo",
    "sabato"
  ]
};
const dayPeriodValues$_ = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "noktomezo",
    noon: "tagmezo",
    morning: "matene",
    afternoon: "posttagmeze",
    evening: "vespere",
    night: "nokte"
  },
  abbreviated: {
    am: "a.t.m.",
    pm: "p.t.m.",
    midnight: "noktomezo",
    noon: "tagmezo",
    morning: "matene",
    afternoon: "posttagmeze",
    evening: "vespere",
    night: "nokte"
  },
  wide: {
    am: "antatagmeze",
    pm: "posttagmeze",
    midnight: "noktomezo",
    noon: "tagmezo",
    morning: "matene",
    afternoon: "posttagmeze",
    evening: "vespere",
    night: "nokte"
  }
};
const ordinalNumber$_ = (dirtyNumber) => {
  const number2 = Number(dirtyNumber);
  return number2 + "-a";
};
const localize$_ = {
  ordinalNumber: ordinalNumber$_,
  era: buildLocalizeFn({
    values: eraValues$_,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$_,
    defaultWidth: "wide",
    argumentCallback: function(quarter) {
      return Number(quarter) - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues$_,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$_,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$_,
    defaultWidth: "wide"
  })
};
const matchOrdinalNumberPattern$_ = /^(\d+)(-?a)?/i;
const parseOrdinalNumberPattern$_ = /\d+/i;
const matchEraPatterns$_ = {
  narrow: /^([ap]k)/i,
  abbreviated: /^([ap]\.?\s?k\.?\s?e\.?)/i,
  wide: /^((anta |post )?komuna erao)/i
};
const parseEraPatterns$_ = {
  any: [/^a/i, /^[kp]/i]
};
const matchQuarterPatterns$_ = {
  narrow: /^[1234]/i,
  abbreviated: /^k[1234]/i,
  wide: /^[1234](-?a)? kvaronjaro/i
};
const parseQuarterPatterns$_ = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$_ = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|maj|jun|jul|a(|ux|uh|u)g|sep|okt|nov|dec)/i,
  wide: /^(januaro|februaro|marto|aprilo|majo|junio|julio|a(|ux|uh|u)gusto|septembro|oktobro|novembro|decembro)/i
};
const parseMonthPatterns$_ = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^a(u|)/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$_ = {
  narrow: /^[dlmjvs]/i,
  short: /^(di|lu|ma|me|(|jx|jh|j)a|ve|sa)/i,
  abbreviated: /^(dim|lun|mar|mer|(|jx|jh|j)a(|ux|uh|u)|ven|sab)/i,
  wide: /^(diman(|cx|ch|c)o|lundo|mardo|merkredo|(|jx|jh|j)a(|ux|uh|u)do|vendredo|sabato)/i
};
const parseDayPatterns$_ = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^(j|)/i, /^v/i, /^s/i],
  any: [/^d/i, /^l/i, /^ma/i, /^me/i, /^(j|)/i, /^v/i, /^s/i]
};
const matchDayPeriodPatterns$_ = {
  narrow: /^([ap]|(posttagmez|noktomez|tagmez|maten|vesper|nokt)[eo])/i,
  abbreviated: /^([ap][.\s]?t[.\s]?m[.\s]?|(posttagmez|noktomez|tagmez|maten|vesper|nokt)[eo])/i,
  wide: /^(anta(|ux)tagmez|posttagmez|noktomez|tagmez|maten|vesper|nokt)[eo]/i
};
const parseDayPeriodPatterns$_ = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^noktom/i,
    noon: /^t/i,
    morning: /^m/i,
    afternoon: /^posttagmeze/i,
    evening: /^v/i,
    night: /^n/i
  }
};
const match$_ = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$_,
    parsePattern: parseOrdinalNumberPattern$_,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$_,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$_,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$_,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$_,
    defaultParseWidth: "any",
    valueCallback: function(index2) {
      return index2 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$_,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$_,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$_,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$_,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$_,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$_,
    defaultParseWidth: "any"
  })
};
const eo = {
  code: "eo",
  formatDistance: formatDistance$_,
  formatLong: formatLong$11,
  formatRelative: formatRelative$$,
  localize: localize$_,
  match: match$_,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$Y = {
  lessThanXSeconds: {
    one: "menos de un segundo",
    other: "menos de {{count}} segundos"
  },
  xSeconds: {
    one: "1 segundo",
    other: "{{count}} segundos"
  },
  halfAMinute: "medio minuto",
  lessThanXMinutes: {
    one: "menos de un minuto",
    other: "menos de {{count}} minutos"
  },
  xMinutes: {
    one: "1 minuto",
    other: "{{count}} minutos"
  },
  aboutXHours: {
    one: "alrededor de 1 hora",
    other: "alrededor de {{count}} horas"
  },
  xHours: {
    one: "1 hora",
    other: "{{count}} horas"
  },
  xDays: {
    one: "1 da",
    other: "{{count}} das"
  },
  aboutXWeeks: {
    one: "alrededor de 1 semana",
    other: "alrededor de {{count}} semanas"
  },
  xWeeks: {
    one: "1 semana",
    other: "{{count}} semanas"
  },
  aboutXMonths: {
    one: "alrededor de 1 mes",
    other: "alrededor de {{count}} meses"
  },
  xMonths: {
    one: "1 mes",
    other: "{{count}} meses"
  },
  aboutXYears: {
    one: "alrededor de 1 ao",
    other: "alrededor de {{count}} aos"
  },
  xYears: {
    one: "1 ao",
    other: "{{count}} aos"
  },
  overXYears: {
    one: "ms de 1 ao",
    other: "ms de {{count}} aos"
  },
  almostXYears: {
    one: "casi 1 ao",
    other: "casi {{count}} aos"
  }
};
const formatDistance$Z = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$Y[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "en " + result;
    } else {
      return "hace " + result;
    }
  }
  return result;
};
const dateFormats$10 = {
  full: "EEEE, d 'de' MMMM 'de' y",
  long: "d 'de' MMMM 'de' y",
  medium: "d MMM y",
  short: "dd/MM/y"
};
const timeFormats$10 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$10 = {
  full: "{{date}} 'a las' {{time}}",
  long: "{{date}} 'a las' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$10 = {
  date: buildFormatLongFn({
    formats: dateFormats$10,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$10,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$10,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$_ = {
  lastWeek: "'el' eeee 'pasado a la' p",
  yesterday: "'ayer a la' p",
  today: "'hoy a la' p",
  tomorrow: "'maana a la' p",
  nextWeek: "eeee 'a la' p",
  other: "P"
};
const formatRelativeLocalePlural$2 = {
  lastWeek: "'el' eeee 'pasado a las' p",
  yesterday: "'ayer a las' p",
  today: "'hoy a las' p",
  tomorrow: "'maana a las' p",
  nextWeek: "eeee 'a las' p",
  other: "P"
};
const formatRelative$_ = (token, date2, _baseDate, _options) => {
  if (date2.getHours() !== 1) {
    return formatRelativeLocalePlural$2[token];
  } else {
    return formatRelativeLocale$_[token];
  }
};
const eraValues$Z = {
  narrow: ["AC", "DC"],
  abbreviated: ["AC", "DC"],
  wide: ["antes de cristo", "despus de cristo"]
};
const quarterValues$Z = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1 trimestre", "2 trimestre", "3 trimestre", "4 trimestre"]
};
const monthValues$Z = {
  narrow: ["e", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "ene",
    "feb",
    "mar",
    "abr",
    "may",
    "jun",
    "jul",
    "ago",
    "sep",
    "oct",
    "nov",
    "dic"
  ],
  wide: [
    "enero",
    "febrero",
    "marzo",
    "abril",
    "mayo",
    "junio",
    "julio",
    "agosto",
    "septiembre",
    "octubre",
    "noviembre",
    "diciembre"
  ]
};
const dayValues$Z = {
  narrow: ["d", "l", "m", "m", "j", "v", "s"],
  short: ["do", "lu", "ma", "mi", "ju", "vi", "s"],
  abbreviated: ["dom", "lun", "mar", "mi", "jue", "vie", "sb"],
  wide: [
    "domingo",
    "lunes",
    "martes",
    "mircoles",
    "jueves",
    "viernes",
    "sbado"
  ]
};
const dayPeriodValues$Z = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "maana",
    afternoon: "tarde",
    evening: "tarde",
    night: "noche"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "medianoche",
    noon: "mediodia",
    morning: "maana",
    afternoon: "tarde",
    evening: "tarde",
    night: "noche"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "medianoche",
    noon: "mediodia",
    morning: "maana",
    afternoon: "tarde",
    evening: "tarde",
    night: "noche"
  }
};
const formattingDayPeriodValues$M = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "de la maana",
    afternoon: "de la tarde",
    evening: "de la tarde",
    night: "de la noche"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "medianoche",
    noon: "mediodia",
    morning: "de la maana",
    afternoon: "de la tarde",
    evening: "de la tarde",
    night: "de la noche"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "medianoche",
    noon: "mediodia",
    morning: "de la maana",
    afternoon: "de la tarde",
    evening: "de la tarde",
    night: "de la noche"
  }
};
const ordinalNumber$Z = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "";
};
const localize$Z = {
  ordinalNumber: ordinalNumber$Z,
  era: buildLocalizeFn({
    values: eraValues$Z,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$Z,
    defaultWidth: "wide",
    argumentCallback: (quarter) => Number(quarter) - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$Z,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$Z,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$Z,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$M,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$Z = /^(\d+)()?/i;
const parseOrdinalNumberPattern$Z = /\d+/i;
const matchEraPatterns$Z = {
  narrow: /^(ac|dc|a|d)/i,
  abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
  wide: /^(antes de cristo|antes de la era com[u]n|despu[e]s de cristo|era com[u]n)/i
};
const parseEraPatterns$Z = {
  any: [/^ac/i, /^dc/i],
  wide: [
    /^(antes de cristo|antes de la era com[u]n)/i,
    /^(despu[e]s de cristo|era com[u]n)/i
  ]
};
const matchQuarterPatterns$Z = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^[1234]()? trimestre/i
};
const parseQuarterPatterns$Z = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$Z = {
  narrow: /^[efmajsond]/i,
  abbreviated: /^(ene|feb|mar|abr|may|jun|jul|ago|sep|oct|nov|dic)/i,
  wide: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i
};
const parseMonthPatterns$Z = {
  narrow: [
    /^e/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^en/i,
    /^feb/i,
    /^mar/i,
    /^abr/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^ago/i,
    /^sep/i,
    /^oct/i,
    /^nov/i,
    /^dic/i
  ]
};
const matchDayPatterns$Z = {
  narrow: /^[dlmjvs]/i,
  short: /^(do|lu|ma|mi|ju|vi|s[a])/i,
  abbreviated: /^(dom|lun|mar|mi[e]|jue|vie|s[a]b)/i,
  wide: /^(domingo|lunes|martes|mi[e]rcoles|jueves|viernes|s[a]bado)/i
};
const parseDayPatterns$Z = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
  any: [/^do/i, /^lu/i, /^ma/i, /^mi/i, /^ju/i, /^vi/i, /^sa/i]
};
const matchDayPeriodPatterns$Z = {
  narrow: /^(a|p|mn|md|(de la|a las) (maana|tarde|noche))/i,
  any: /^([ap]\.?\s?m\.?|medianoche|mediodia|(de la|a las) (maana|tarde|noche))/i
};
const parseDayPeriodPatterns$Z = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mn/i,
    noon: /^md/i,
    morning: /maana/i,
    afternoon: /tarde/i,
    evening: /tarde/i,
    night: /noche/i
  }
};
const match$Z = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$Z,
    parsePattern: parseOrdinalNumberPattern$Z,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$Z,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$Z,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$Z,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$Z,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$Z,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$Z,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$Z,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$Z,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$Z,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$Z,
    defaultParseWidth: "any"
  })
};
const es = {
  code: "es",
  formatDistance: formatDistance$Z,
  formatLong: formatLong$10,
  formatRelative: formatRelative$_,
  localize: localize$Z,
  match: match$Z,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$X = {
  lessThanXSeconds: {
    standalone: {
      one: "vhem kui ks sekund",
      other: "vhem kui {{count}} sekundit"
    },
    withPreposition: {
      one: "vhem kui he sekundi",
      other: "vhem kui {{count}} sekundi"
    }
  },
  xSeconds: {
    standalone: {
      one: "ks sekund",
      other: "{{count}} sekundit"
    },
    withPreposition: {
      one: "he sekundi",
      other: "{{count}} sekundi"
    }
  },
  halfAMinute: {
    standalone: "pool minutit",
    withPreposition: "poole minuti"
  },
  lessThanXMinutes: {
    standalone: {
      one: "vhem kui ks minut",
      other: "vhem kui {{count}} minutit"
    },
    withPreposition: {
      one: "vhem kui he minuti",
      other: "vhem kui {{count}} minuti"
    }
  },
  xMinutes: {
    standalone: {
      one: "ks minut",
      other: "{{count}} minutit"
    },
    withPreposition: {
      one: "he minuti",
      other: "{{count}} minuti"
    }
  },
  aboutXHours: {
    standalone: {
      one: "umbes ks tund",
      other: "umbes {{count}} tundi"
    },
    withPreposition: {
      one: "umbes he tunni",
      other: "umbes {{count}} tunni"
    }
  },
  xHours: {
    standalone: {
      one: "ks tund",
      other: "{{count}} tundi"
    },
    withPreposition: {
      one: "he tunni",
      other: "{{count}} tunni"
    }
  },
  xDays: {
    standalone: {
      one: "ks pev",
      other: "{{count}} peva"
    },
    withPreposition: {
      one: "he peva",
      other: "{{count}} peva"
    }
  },
  aboutXWeeks: {
    standalone: {
      one: "umbes ks ndal",
      other: "umbes {{count}} ndalat"
    },
    withPreposition: {
      one: "umbes he ndala",
      other: "umbes {{count}} ndala"
    }
  },
  xWeeks: {
    standalone: {
      one: "ks ndal",
      other: "{{count}} ndalat"
    },
    withPreposition: {
      one: "he ndala",
      other: "{{count}} ndala"
    }
  },
  aboutXMonths: {
    standalone: {
      one: "umbes ks kuu",
      other: "umbes {{count}} kuud"
    },
    withPreposition: {
      one: "umbes he kuu",
      other: "umbes {{count}} kuu"
    }
  },
  xMonths: {
    standalone: {
      one: "ks kuu",
      other: "{{count}} kuud"
    },
    withPreposition: {
      one: "he kuu",
      other: "{{count}} kuu"
    }
  },
  aboutXYears: {
    standalone: {
      one: "umbes ks aasta",
      other: "umbes {{count}} aastat"
    },
    withPreposition: {
      one: "umbes he aasta",
      other: "umbes {{count}} aasta"
    }
  },
  xYears: {
    standalone: {
      one: "ks aasta",
      other: "{{count}} aastat"
    },
    withPreposition: {
      one: "he aasta",
      other: "{{count}} aasta"
    }
  },
  overXYears: {
    standalone: {
      one: "rohkem kui ks aasta",
      other: "rohkem kui {{count}} aastat"
    },
    withPreposition: {
      one: "rohkem kui he aasta",
      other: "rohkem kui {{count}} aasta"
    }
  },
  almostXYears: {
    standalone: {
      one: "peaaegu ks aasta",
      other: "peaaegu {{count}} aastat"
    },
    withPreposition: {
      one: "peaaegu he aasta",
      other: "peaaegu {{count}} aasta"
    }
  }
};
const formatDistance$Y = (token, count, options) => {
  const usageGroup = options?.addSuffix ? formatDistanceLocale$X[token].withPreposition : formatDistanceLocale$X[token].standalone;
  let result;
  if (typeof usageGroup === "string") {
    result = usageGroup;
  } else if (count === 1) {
    result = usageGroup.one;
  } else {
    result = usageGroup.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + " prast";
    } else {
      return result + " eest";
    }
  }
  return result;
};
const dateFormats$$ = {
  full: "EEEE, d. MMMM y",
  long: "d. MMMM y",
  medium: "d. MMM y",
  short: "dd.MM.y"
};
const timeFormats$$ = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$$ = {
  full: "{{date}} 'kell' {{time}}",
  long: "{{date}} 'kell' {{time}}",
  medium: "{{date}}. {{time}}",
  short: "{{date}}. {{time}}"
};
const formatLong$$ = {
  date: buildFormatLongFn({
    formats: dateFormats$$,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$$,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$$,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$Z = {
  lastWeek: "'eelmine' eeee 'kell' p",
  yesterday: "'eile kell' p",
  today: "'tna kell' p",
  tomorrow: "'homme kell' p",
  nextWeek: "'jrgmine' eeee 'kell' p",
  other: "P"
};
const formatRelative$Z = (token, _date, _baseDate, _options) => formatRelativeLocale$Z[token];
const eraValues$Y = {
  narrow: ["e.m.a", "m.a.j"],
  abbreviated: ["e.m.a", "m.a.j"],
  wide: ["enne meie ajaarvamist", "meie ajaarvamise jrgi"]
};
const quarterValues$Y = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
const monthValues$Y = {
  narrow: ["J", "V", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jaan",
    "veebr",
    "mrts",
    "apr",
    "mai",
    "juuni",
    "juuli",
    "aug",
    "sept",
    "okt",
    "nov",
    "dets"
  ],
  wide: [
    "jaanuar",
    "veebruar",
    "mrts",
    "aprill",
    "mai",
    "juuni",
    "juuli",
    "august",
    "september",
    "oktoober",
    "november",
    "detsember"
  ]
};
const dayValues$Y = {
  narrow: ["P", "E", "T", "K", "N", "R", "L"],
  short: ["P", "E", "T", "K", "N", "R", "L"],
  abbreviated: [
    "phap.",
    "esmasp.",
    "teisip.",
    "kolmap.",
    "neljap.",
    "reede.",
    "laup."
  ],
  wide: [
    "phapev",
    "esmaspev",
    "teisipev",
    "kolmapev",
    "neljapev",
    "reede",
    "laupev"
  ]
};
const dayPeriodValues$Y = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "kesk",
    noon: "keskpev",
    morning: "hommik",
    afternoon: "prastluna",
    evening: "htu",
    night: ""
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "kesk",
    noon: "keskpev",
    morning: "hommik",
    afternoon: "prastluna",
    evening: "htu",
    night: ""
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "kesk",
    noon: "keskpev",
    morning: "hommik",
    afternoon: "prastluna",
    evening: "htu",
    night: ""
  }
};
const formattingDayPeriodValues$L = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "keskl",
    noon: "keskpeval",
    morning: "hommikul",
    afternoon: "prastlunal",
    evening: "htul",
    night: "sel"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "keskl",
    noon: "keskpeval",
    morning: "hommikul",
    afternoon: "prastlunal",
    evening: "htul",
    night: "sel"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "keskl",
    noon: "keskpeval",
    morning: "hommikul",
    afternoon: "prastlunal",
    evening: "htul",
    night: "sel"
  }
};
const ordinalNumber$Y = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$Y = {
  ordinalNumber: ordinalNumber$Y,
  era: buildLocalizeFn({
    values: eraValues$Y,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$Y,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$Y,
    defaultWidth: "wide",
    formattingValues: monthValues$Y,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$Y,
    defaultWidth: "wide",
    formattingValues: dayValues$Y,
    defaultFormattingWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$Y,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$L,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$Y = /^\d+\./i;
const parseOrdinalNumberPattern$Y = /\d+/i;
const matchEraPatterns$Y = {
  narrow: /^(e\.m\.a|m\.a\.j|eKr|pKr)/i,
  abbreviated: /^(e\.m\.a|m\.a\.j|eKr|pKr)/i,
  wide: /^(enne meie ajaarvamist|meie ajaarvamise jrgi|enne Kristust|prast Kristust)/i
};
const parseEraPatterns$Y = {
  any: [/^e/i, /^(m|p)/i]
};
const matchQuarterPatterns$Y = {
  narrow: /^[1234]/i,
  abbreviated: /^K[1234]/i,
  wide: /^[1234](\.)? kvartal/i
};
const parseQuarterPatterns$Y = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$Y = {
  narrow: /^[jvmasond]/i,
  abbreviated: /^(jaan|veebr|mrts|apr|mai|juuni|juuli|aug|sept|okt|nov|dets)/i,
  wide: /^(jaanuar|veebruar|mrts|aprill|mai|juuni|juuli|august|september|oktoober|november|detsember)/i
};
const parseMonthPatterns$Y = {
  narrow: [
    /^j/i,
    /^v/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^v/i,
    /^mr/i,
    /^ap/i,
    /^mai/i,
    /^juun/i,
    /^juul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$Y = {
  narrow: /^[petknrl]/i,
  short: /^[petknrl]/i,
  abbreviated: /^(ph?|esm?|tei?|kolm?|nel?|ree?|laup?)\.?/i,
  wide: /^(phapev|esmaspev|teisipev|kolmapev|neljapev|reede|laupev)/i
};
const parseDayPatterns$Y = {
  any: [/^p/i, /^e/i, /^t/i, /^k/i, /^n/i, /^r/i, /^l/i]
};
const matchDayPeriodPatterns$Y = {
  any: /^(am|pm|keskl?|keskpev(al)?|hommik(ul)?|prastlunal?|htul?|(sel)?)/i
};
const parseDayPeriodPatterns$Y = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^kesk/i,
    noon: /^keskp/i,
    morning: /hommik/i,
    afternoon: /prastluna/i,
    evening: /htu/i,
    night: //i
  }
};
const match$Y = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$Y,
    parsePattern: parseOrdinalNumberPattern$Y,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$Y,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$Y,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$Y,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$Y,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$Y,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$Y,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$Y,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$Y,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$Y,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$Y,
    defaultParseWidth: "any"
  })
};
const et = {
  code: "et",
  formatDistance: formatDistance$Y,
  formatLong: formatLong$$,
  formatRelative: formatRelative$Z,
  localize: localize$Y,
  match: match$Y,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$W = {
  lessThanXSeconds: {
    one: "segundo bat baino gutxiago",
    other: "{{count}} segundo baino gutxiago"
  },
  xSeconds: {
    one: "1 segundo",
    other: "{{count}} segundo"
  },
  halfAMinute: "minutu erdi",
  lessThanXMinutes: {
    one: "minutu bat baino gutxiago",
    other: "{{count}} minutu baino gutxiago"
  },
  xMinutes: {
    one: "1 minutu",
    other: "{{count}} minutu"
  },
  aboutXHours: {
    one: "1 ordu gutxi gorabehera",
    other: "{{count}} ordu gutxi gorabehera"
  },
  xHours: {
    one: "1 ordu",
    other: "{{count}} ordu"
  },
  xDays: {
    one: "1 egun",
    other: "{{count}} egun"
  },
  aboutXWeeks: {
    one: "aste 1 inguru",
    other: "{{count}} aste inguru"
  },
  xWeeks: {
    one: "1 aste",
    other: "{{count}} astean"
  },
  aboutXMonths: {
    one: "1 hilabete gutxi gorabehera",
    other: "{{count}} hilabete gutxi gorabehera"
  },
  xMonths: {
    one: "1 hilabete",
    other: "{{count}} hilabete"
  },
  aboutXYears: {
    one: "1 urte gutxi gorabehera",
    other: "{{count}} urte gutxi gorabehera"
  },
  xYears: {
    one: "1 urte",
    other: "{{count}} urte"
  },
  overXYears: {
    one: "1 urte baino gehiago",
    other: "{{count}} urte baino gehiago"
  },
  almostXYears: {
    one: "ia 1 urte",
    other: "ia {{count}} urte"
  }
};
const formatDistance$X = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$W[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "en " + result;
    } else {
      return "duela " + result;
    }
  }
  return result;
};
const dateFormats$_ = {
  full: "EEEE, y'ko' MMMM'ren' d'a' y'ren'",
  long: "y'ko' MMMM'ren' d'a'",
  medium: "y MMM d",
  short: "yy/MM/dd"
};
const timeFormats$_ = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$_ = {
  full: "{{date}} 'tan' {{time}}",
  long: "{{date}} 'tan' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$_ = {
  date: buildFormatLongFn({
    formats: dateFormats$_,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$_,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$_,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$Y = {
  lastWeek: "'joan den' eeee, LT",
  yesterday: "'atzo,' p",
  today: "'gaur,' p",
  tomorrow: "'bihar,' p",
  nextWeek: "eeee, p",
  other: "P"
};
const formatRelativeLocalePlural$1 = {
  lastWeek: "'joan den' eeee, p",
  yesterday: "'atzo,' p",
  today: "'gaur,' p",
  tomorrow: "'bihar,' p",
  nextWeek: "eeee, p",
  other: "P"
};
const formatRelative$Y = (token, date2) => {
  if (date2.getHours() !== 1) {
    return formatRelativeLocalePlural$1[token];
  }
  return formatRelativeLocale$Y[token];
};
const eraValues$X = {
  narrow: ["k.a.", "k.o."],
  abbreviated: ["k.a.", "k.o."],
  wide: ["kristo aurretik", "kristo ondoren"]
};
const quarterValues$X = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1H", "2H", "3H", "4H"],
  wide: [
    "1. hiruhilekoa",
    "2. hiruhilekoa",
    "3. hiruhilekoa",
    "4. hiruhilekoa"
  ]
};
const monthValues$X = {
  narrow: ["u", "o", "m", "a", "m", "e", "u", "a", "i", "u", "a", "a"],
  abbreviated: [
    "urt",
    "ots",
    "mar",
    "api",
    "mai",
    "eka",
    "uzt",
    "abu",
    "ira",
    "urr",
    "aza",
    "abe"
  ],
  wide: [
    "urtarrila",
    "otsaila",
    "martxoa",
    "apirila",
    "maiatza",
    "ekaina",
    "uztaila",
    "abuztua",
    "iraila",
    "urria",
    "azaroa",
    "abendua"
  ]
};
const dayValues$X = {
  narrow: ["i", "a", "a", "a", "o", "o", "l"],
  short: ["ig", "al", "as", "az", "og", "or", "lr"],
  abbreviated: ["iga", "ast", "ast", "ast", "ost", "ost", "lar"],
  wide: [
    "igandea",
    "astelehena",
    "asteartea",
    "asteazkena",
    "osteguna",
    "ostirala",
    "larunbata"
  ]
};
const dayPeriodValues$X = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "ge",
    noon: "eg",
    morning: "goiza",
    afternoon: "arratsaldea",
    evening: "arratsaldea",
    night: "gaua"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "gauerdia",
    noon: "eguerdia",
    morning: "goiza",
    afternoon: "arratsaldea",
    evening: "arratsaldea",
    night: "gaua"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "gauerdia",
    noon: "eguerdia",
    morning: "goiza",
    afternoon: "arratsaldea",
    evening: "arratsaldea",
    night: "gaua"
  }
};
const formattingDayPeriodValues$K = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "ge",
    noon: "eg",
    morning: "goizean",
    afternoon: "arratsaldean",
    evening: "arratsaldean",
    night: "gauean"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "gauerdia",
    noon: "eguerdia",
    morning: "goizean",
    afternoon: "arratsaldean",
    evening: "arratsaldean",
    night: "gauean"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "gauerdia",
    noon: "eguerdia",
    morning: "goizean",
    afternoon: "arratsaldean",
    evening: "arratsaldean",
    night: "gauean"
  }
};
const ordinalNumber$X = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$X = {
  ordinalNumber: ordinalNumber$X,
  era: buildLocalizeFn({
    values: eraValues$X,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$X,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$X,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$X,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$X,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$K,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$X = /^(\d+)(.)?/i;
const parseOrdinalNumberPattern$X = /\d+/i;
const matchEraPatterns$X = {
  narrow: /^(k.a.|k.o.)/i,
  abbreviated: /^(k.a.|k.o.)/i,
  wide: /^(kristo aurretik|kristo ondoren)/i
};
const parseEraPatterns$X = {
  narrow: [/^k.a./i, /^k.o./i],
  abbreviated: [/^(k.a.)/i, /^(k.o.)/i],
  wide: [/^(kristo aurretik)/i, /^(kristo ondoren)/i]
};
const matchQuarterPatterns$X = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]H/i,
  wide: /^[1234](.)? hiruhilekoa/i
};
const parseQuarterPatterns$X = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$X = {
  narrow: /^[uomaei]/i,
  abbreviated: /^(urt|ots|mar|api|mai|eka|uzt|abu|ira|urr|aza|abe)/i,
  wide: /^(urtarrila|otsaila|martxoa|apirila|maiatza|ekaina|uztaila|abuztua|iraila|urria|azaroa|abendua)/i
};
const parseMonthPatterns$X = {
  narrow: [
    /^u/i,
    /^o/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^e/i,
    /^u/i,
    /^a/i,
    /^i/i,
    /^u/i,
    /^a/i,
    /^a/i
  ],
  any: [
    /^urt/i,
    /^ots/i,
    /^mar/i,
    /^api/i,
    /^mai/i,
    /^eka/i,
    /^uzt/i,
    /^abu/i,
    /^ira/i,
    /^urr/i,
    /^aza/i,
    /^abe/i
  ]
};
const matchDayPatterns$X = {
  narrow: /^[iaol]/i,
  short: /^(ig|al|as|az|og|or|lr)/i,
  abbreviated: /^(iga|ast|ast|ast|ost|ost|lar)/i,
  wide: /^(igandea|astelehena|asteartea|asteazkena|osteguna|ostirala|larunbata)/i
};
const parseDayPatterns$X = {
  narrow: [/^i/i, /^a/i, /^a/i, /^a/i, /^o/i, /^o/i, /^l/i],
  short: [/^ig/i, /^al/i, /^as/i, /^az/i, /^og/i, /^or/i, /^lr/i],
  abbreviated: [/^iga/i, /^ast/i, /^ast/i, /^ast/i, /^ost/i, /^ost/i, /^lar/i],
  wide: [
    /^igandea/i,
    /^astelehena/i,
    /^asteartea/i,
    /^asteazkena/i,
    /^osteguna/i,
    /^ostirala/i,
    /^larunbata/i
  ]
};
const matchDayPeriodPatterns$X = {
  narrow: /^(a|p|ge|eg|((goiza|goizean)|arratsaldea|(gaua|gauean)))/i,
  any: /^([ap]\.?\s?m\.?|gauerdia|eguerdia|((goiza|goizean)|arratsaldea|(gaua|gauean)))/i
};
const parseDayPeriodPatterns$X = {
  narrow: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^ge/i,
    noon: /^eg/i,
    morning: /goiz/i,
    afternoon: /arratsaldea/i,
    evening: /arratsaldea/i,
    night: /gau/i
  },
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^gauerdia/i,
    noon: /^eguerdia/i,
    morning: /goiz/i,
    afternoon: /arratsaldea/i,
    evening: /arratsaldea/i,
    night: /gau/i
  }
};
const match$X = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$X,
    parsePattern: parseOrdinalNumberPattern$X,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$X,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$X,
    defaultParseWidth: "wide"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$X,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$X,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$X,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$X,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$X,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$X,
    defaultParseWidth: "wide"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$X,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$X,
    defaultParseWidth: "any"
  })
};
const eu = {
  code: "eu",
  formatDistance: formatDistance$X,
  formatLong: formatLong$_,
  formatRelative: formatRelative$Y,
  localize: localize$X,
  match: match$X,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$V = {
  lessThanXSeconds: {
    one: "   ",
    other: "  {{count}} "
  },
  xSeconds: {
    one: "1 ",
    other: "{{count}} "
  },
  halfAMinute: " ",
  lessThanXMinutes: {
    one: "   ",
    other: "  {{count}} "
  },
  xMinutes: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: " 1 ",
    other: " {{count}} "
  },
  xHours: {
    one: "1 ",
    other: "{{count}} "
  },
  xDays: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: " 1 ",
    other: " {{count}} "
  },
  xWeeks: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: " 1 ",
    other: " {{count}} "
  },
  xMonths: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: " 1 ",
    other: " {{count}} "
  },
  xYears: {
    one: "1 ",
    other: "{{count}} "
  },
  overXYears: {
    one: "  1 ",
    other: "  {{count}} "
  },
  almostXYears: {
    one: " 1 ",
    other: " {{count}} "
  }
};
const formatDistance$W = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$V[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return " " + result;
    } else {
      return result + " ";
    }
  }
  return result;
};
const dateFormats$Z = {
  full: "EEEE do MMMM y",
  long: "do MMMM y",
  medium: "d MMM y",
  short: "yyyy/MM/dd"
};
const timeFormats$Z = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$Z = {
  full: "{{date}} '' {{time}}",
  long: "{{date}} '' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$Z = {
  date: buildFormatLongFn({
    formats: dateFormats$Z,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$Z,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$Z,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$X = {
  lastWeek: "eeee ' ' p",
  yesterday: "' ' p",
  today: "' ' p",
  tomorrow: "' ' p",
  nextWeek: "eeee '' p",
  other: "P"
};
const formatRelative$X = (token, _date, _baseDate, _options) => formatRelativeLocale$X[token];
const eraValues$W = {
  narrow: ["", ""],
  abbreviated: ["..", ".."],
  wide: ["  ", "  "]
};
const quarterValues$W = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1", "2", "3", "4"],
  wide: [" 1", " 2", " 3", " 4"]
};
const monthValues$W = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$W = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["1", "2", "3", "4", "5", "", ""],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: ["", "", "", "", "", "", ""]
};
const dayPeriodValues$W = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "..",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "..",
    pm: "..",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$J = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "..",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "..",
    pm: "..",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$W = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
const localize$W = {
  ordinalNumber: ordinalNumber$W,
  era: buildLocalizeFn({
    values: eraValues$W,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$W,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$W,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$W,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$W,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$J,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$W = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$W = /\d+/i;
const matchEraPatterns$W = {
  narrow: /^(|)/i,
  abbreviated: /^(\.?\s?\.?|\.?\s?\.?\s?\.?|\.?\s?|\.?\s?\.?)/i,
  wide: /^(  |   || |  )/i
};
const parseEraPatterns$W = {
  any: [/^/i, /^/i]
};
const matchQuarterPatterns$W = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]/i,
  wide: /^ [1234]/i
};
const parseQuarterPatterns$W = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$W = {
  narrow: /^[]/i,
  abbreviated: /^(|||||||||||||||||||||||||)/i,
  wide: /^(|||||||||||||||||||||||||||)/i
};
const parseMonthPatterns$W = {
  narrow: [
    /^(|)/i,
    /^/i,
    /^/i,
    /^(|)/i,
    /^/i,
    /^(|)/i,
    /^(|)/i,
    /^(|)/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^(|)/i,
    /^(|)/i,
    /^(|)/i,
    /^(|)/i,
    /^/i,
    /^(|)/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$W = {
  narrow: /^[]/i,
  short: /^(||1|2|3|4|5)/i,
  abbreviated: /^(||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$W = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [
    /^(|1|)/i,
    /^(|2|)/i,
    /^(|3|)/i,
    /^(|4|)/i,
    /^(|5|)/i,
    /^(|)/i,
    /^(|)/i
  ]
};
const matchDayPeriodPatterns$W = {
  narrow: /^(|||||..||)/i,
  abbreviated: /^(..|..||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPeriodPatterns$W = {
  any: {
    am: /^(|..|)/i,
    pm: /^(|..|)/i,
    midnight: /^(|)/i,
    noon: /^(|)/i,
    morning: /(|)/i,
    afternoon: /(|..|)/i,
    evening: /(|)/i,
    night: /(|)/i
  }
};
const match$W = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$W,
    parsePattern: parseOrdinalNumberPattern$W,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$W,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$W,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$W,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$W,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$W,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$W,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$W,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$W,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$W,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$W,
    defaultParseWidth: "any"
  })
};
const faIR = {
  code: "fa-IR",
  formatDistance: formatDistance$W,
  formatLong: formatLong$Z,
  formatRelative: formatRelative$X,
  localize: localize$W,
  match: match$W,
  options: {
    weekStartsOn: 6,
    firstWeekContainsDate: 1
  }
};
function futureSeconds(text) {
  return text.replace(/sekuntia?/, "sekunnin");
}
function futureMinutes(text) {
  return text.replace(/minuuttia?/, "minuutin");
}
function futureHours(text) {
  return text.replace(/tuntia?/, "tunnin");
}
function futureDays(text) {
  return text.replace(/piv?/, "pivn");
}
function futureWeeks(text) {
  return text.replace(/(viikko|viikkoa)/, "viikon");
}
function futureMonths(text) {
  return text.replace(/(kuukausi|kuukautta)/, "kuukauden");
}
function futureYears(text) {
  return text.replace(/(vuosi|vuotta)/, "vuoden");
}
const formatDistanceLocale$U = {
  lessThanXSeconds: {
    one: "alle sekunti",
    other: "alle {{count}} sekuntia",
    futureTense: futureSeconds
  },
  xSeconds: {
    one: "sekunti",
    other: "{{count}} sekuntia",
    futureTense: futureSeconds
  },
  halfAMinute: {
    one: "puoli minuuttia",
    other: "puoli minuuttia",
    futureTense: (_text) => "puolen minuutin"
  },
  lessThanXMinutes: {
    one: "alle minuutti",
    other: "alle {{count}} minuuttia",
    futureTense: futureMinutes
  },
  xMinutes: {
    one: "minuutti",
    other: "{{count}} minuuttia",
    futureTense: futureMinutes
  },
  aboutXHours: {
    one: "noin tunti",
    other: "noin {{count}} tuntia",
    futureTense: futureHours
  },
  xHours: {
    one: "tunti",
    other: "{{count}} tuntia",
    futureTense: futureHours
  },
  xDays: {
    one: "piv",
    other: "{{count}} piv",
    futureTense: futureDays
  },
  aboutXWeeks: {
    one: "noin viikko",
    other: "noin {{count}} viikkoa",
    futureTense: futureWeeks
  },
  xWeeks: {
    one: "viikko",
    other: "{{count}} viikkoa",
    futureTense: futureWeeks
  },
  aboutXMonths: {
    one: "noin kuukausi",
    other: "noin {{count}} kuukautta",
    futureTense: futureMonths
  },
  xMonths: {
    one: "kuukausi",
    other: "{{count}} kuukautta",
    futureTense: futureMonths
  },
  aboutXYears: {
    one: "noin vuosi",
    other: "noin {{count}} vuotta",
    futureTense: futureYears
  },
  xYears: {
    one: "vuosi",
    other: "{{count}} vuotta",
    futureTense: futureYears
  },
  overXYears: {
    one: "yli vuosi",
    other: "yli {{count}} vuotta",
    futureTense: futureYears
  },
  almostXYears: {
    one: "lhes vuosi",
    other: "lhes {{count}} vuotta",
    futureTense: futureYears
  }
};
const formatDistance$V = (token, count, options) => {
  const tokenValue = formatDistanceLocale$U[token];
  const result = count === 1 ? tokenValue.one : tokenValue.other.replace("{{count}}", String(count));
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return tokenValue.futureTense(result) + " kuluttua";
    } else {
      return result + " sitten";
    }
  }
  return result;
};
const dateFormats$Y = {
  full: "eeee d. MMMM y",
  long: "d. MMMM y",
  medium: "d. MMM y",
  short: "d.M.y"
};
const timeFormats$Y = {
  full: "HH.mm.ss zzzz",
  long: "HH.mm.ss z",
  medium: "HH.mm.ss",
  short: "HH.mm"
};
const dateTimeFormats$Y = {
  full: "{{date}} 'klo' {{time}}",
  long: "{{date}} 'klo' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$Y = {
  date: buildFormatLongFn({
    formats: dateFormats$Y,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$Y,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$Y,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$W = {
  lastWeek: "'viime' eeee 'klo' p",
  yesterday: "'eilen klo' p",
  today: "'tnn klo' p",
  tomorrow: "'huomenna klo' p",
  nextWeek: "'ensi' eeee 'klo' p",
  other: "P"
};
const formatRelative$W = (token, _date, _baseDate, _options) => formatRelativeLocale$W[token];
const eraValues$V = {
  narrow: ["eaa.", "jaa."],
  abbreviated: ["eaa.", "jaa."],
  wide: ["ennen ajanlaskun alkua", "jlkeen ajanlaskun alun"]
};
const quarterValues$V = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. kvartaali", "2. kvartaali", "3. kvartaali", "4. kvartaali"]
};
const monthValues$V = {
  narrow: ["T", "H", "M", "H", "T", "K", "H", "E", "S", "L", "M", "J"],
  abbreviated: [
    "tammi",
    "helmi",
    "maalis",
    "huhti",
    "touko",
    "kes",
    "hein",
    "elo",
    "syys",
    "loka",
    "marras",
    "joulu"
  ],
  wide: [
    "tammikuu",
    "helmikuu",
    "maaliskuu",
    "huhtikuu",
    "toukokuu",
    "keskuu",
    "heinkuu",
    "elokuu",
    "syyskuu",
    "lokakuu",
    "marraskuu",
    "joulukuu"
  ]
};
const formattingMonthValues$b = {
  narrow: monthValues$V.narrow,
  abbreviated: monthValues$V.abbreviated,
  wide: [
    "tammikuuta",
    "helmikuuta",
    "maaliskuuta",
    "huhtikuuta",
    "toukokuuta",
    "keskuuta",
    "heinkuuta",
    "elokuuta",
    "syyskuuta",
    "lokakuuta",
    "marraskuuta",
    "joulukuuta"
  ]
};
const dayValues$V = {
  narrow: ["S", "M", "T", "K", "T", "P", "L"],
  short: ["su", "ma", "ti", "ke", "to", "pe", "la"],
  abbreviated: ["sunn.", "maan.", "tiis.", "kesk.", "torst.", "perj.", "la"],
  wide: [
    "sunnuntai",
    "maanantai",
    "tiistai",
    "keskiviikko",
    "torstai",
    "perjantai",
    "lauantai"
  ]
};
const formattingDayValues$3 = {
  narrow: dayValues$V.narrow,
  short: dayValues$V.short,
  abbreviated: dayValues$V.abbreviated,
  wide: [
    "sunnuntaina",
    "maanantaina",
    "tiistaina",
    "keskiviikkona",
    "torstaina",
    "perjantaina",
    "lauantaina"
  ]
};
const dayPeriodValues$V = {
  narrow: {
    am: "ap",
    pm: "ip",
    midnight: "keskiy",
    noon: "keskipiv",
    morning: "ap",
    afternoon: "ip",
    evening: "illalla",
    night: "yll"
  },
  abbreviated: {
    am: "ap",
    pm: "ip",
    midnight: "keskiy",
    noon: "keskipiv",
    morning: "ap",
    afternoon: "ip",
    evening: "illalla",
    night: "yll"
  },
  wide: {
    am: "ap",
    pm: "ip",
    midnight: "keskiyll",
    noon: "keskipivll",
    morning: "aamupivll",
    afternoon: "iltapivll",
    evening: "illalla",
    night: "yll"
  }
};
const ordinalNumber$V = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$V = {
  ordinalNumber: ordinalNumber$V,
  era: buildLocalizeFn({
    values: eraValues$V,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$V,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$V,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$b,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$V,
    defaultWidth: "wide",
    formattingValues: formattingDayValues$3,
    defaultFormattingWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$V,
    defaultWidth: "wide"
  })
};
const matchOrdinalNumberPattern$V = /^(\d+)(\.)/i;
const parseOrdinalNumberPattern$V = /\d+/i;
const matchEraPatterns$V = {
  narrow: /^(e|j)/i,
  abbreviated: /^(eaa.|jaa.)/i,
  wide: /^(ennen ajanlaskun alkua|jlkeen ajanlaskun alun)/i
};
const parseEraPatterns$V = {
  any: [/^e/i, /^j/i]
};
const matchQuarterPatterns$V = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234]\.? kvartaali/i
};
const parseQuarterPatterns$V = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$V = {
  narrow: /^[thmkeslj]/i,
  abbreviated: /^(tammi|helmi|maalis|huhti|touko|kes|hein|elo|syys|loka|marras|joulu)/i,
  wide: /^(tammikuu|helmikuu|maaliskuu|huhtikuu|toukokuu|keskuu|heinkuu|elokuu|syyskuu|lokakuu|marraskuu|joulukuu)(ta)?/i
};
const parseMonthPatterns$V = {
  narrow: [
    /^t/i,
    /^h/i,
    /^m/i,
    /^h/i,
    /^t/i,
    /^k/i,
    /^h/i,
    /^e/i,
    /^s/i,
    /^l/i,
    /^m/i,
    /^j/i
  ],
  any: [
    /^ta/i,
    /^hel/i,
    /^maa/i,
    /^hu/i,
    /^to/i,
    /^k/i,
    /^hei/i,
    /^e/i,
    /^s/i,
    /^l/i,
    /^mar/i,
    /^j/i
  ]
};
const matchDayPatterns$V = {
  narrow: /^[smtkpl]/i,
  short: /^(su|ma|ti|ke|to|pe|la)/i,
  abbreviated: /^(sunn.|maan.|tiis.|kesk.|torst.|perj.|la)/i,
  wide: /^(sunnuntai|maanantai|tiistai|keskiviikko|torstai|perjantai|lauantai)(na)?/i
};
const parseDayPatterns$V = {
  narrow: [/^s/i, /^m/i, /^t/i, /^k/i, /^t/i, /^p/i, /^l/i],
  any: [/^s/i, /^m/i, /^ti/i, /^k/i, /^to/i, /^p/i, /^l/i]
};
const matchDayPeriodPatterns$V = {
  narrow: /^(ap|ip|keskiy|keskipiv|aamupivll|iltapivll|illalla|yll)/i,
  any: /^(ap|ip|keskiyll|keskipivll|aamupivll|iltapivll|illalla|yll)/i
};
const parseDayPeriodPatterns$V = {
  any: {
    am: /^ap/i,
    pm: /^ip/i,
    midnight: /^keskiy/i,
    noon: /^keskipiv/i,
    morning: /aamupivll/i,
    afternoon: /iltapivll/i,
    evening: /illalla/i,
    night: /yll/i
  }
};
const match$V = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$V,
    parsePattern: parseOrdinalNumberPattern$V,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$V,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$V,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$V,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$V,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$V,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$V,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$V,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$V,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$V,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$V,
    defaultParseWidth: "any"
  })
};
const fi = {
  code: "fi",
  formatDistance: formatDistance$V,
  formatLong: formatLong$Y,
  formatRelative: formatRelative$W,
  localize: localize$V,
  match: match$V,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$T = {
  lessThanXSeconds: {
    one: "moins dune seconde",
    other: "moins de {{count}} secondes"
  },
  xSeconds: {
    one: "1 seconde",
    other: "{{count}} secondes"
  },
  halfAMinute: "30 secondes",
  lessThanXMinutes: {
    one: "moins dune minute",
    other: "moins de {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "environ 1 heure",
    other: "environ {{count}} heures"
  },
  xHours: {
    one: "1 heure",
    other: "{{count}} heures"
  },
  xDays: {
    one: "1 jour",
    other: "{{count}} jours"
  },
  aboutXWeeks: {
    one: "environ 1 semaine",
    other: "environ {{count}} semaines"
  },
  xWeeks: {
    one: "1 semaine",
    other: "{{count}} semaines"
  },
  aboutXMonths: {
    one: "environ 1 mois",
    other: "environ {{count}} mois"
  },
  xMonths: {
    one: "1 mois",
    other: "{{count}} mois"
  },
  aboutXYears: {
    one: "environ 1 an",
    other: "environ {{count}} ans"
  },
  xYears: {
    one: "1 an",
    other: "{{count}} ans"
  },
  overXYears: {
    one: "plus dun an",
    other: "plus de {{count}} ans"
  },
  almostXYears: {
    one: "presquun an",
    other: "presque {{count}} ans"
  }
};
const formatDistance$U = (token, count, options) => {
  let result;
  const form = formatDistanceLocale$T[token];
  if (typeof form === "string") {
    result = form;
  } else if (count === 1) {
    result = form.one;
  } else {
    result = form.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "dans " + result;
    } else {
      return "il y a " + result;
    }
  }
  return result;
};
const dateFormats$X = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd/MM/y"
};
const timeFormats$X = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$X = {
  full: "{{date}} '' {{time}}",
  long: "{{date}} '' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$X = {
  date: buildFormatLongFn({
    formats: dateFormats$X,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$X,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$X,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$V = {
  lastWeek: "eeee 'dernier ' p",
  yesterday: "'hier ' p",
  today: "'aujourdhui ' p",
  tomorrow: "'demain ' p'",
  nextWeek: "eeee 'prochain ' p",
  other: "P"
};
const formatRelative$V = (token, _date, _baseDate, _options) => formatRelativeLocale$V[token];
const eraValues$U = {
  narrow: ["av. J.-C", "ap. J.-C"],
  abbreviated: ["av. J.-C", "ap. J.-C"],
  wide: ["avant Jsus-Christ", "aprs Jsus-Christ"]
};
const quarterValues$U = {
  narrow: ["T1", "T2", "T3", "T4"],
  abbreviated: ["1er trim.", "2me trim.", "3me trim.", "4me trim."],
  wide: ["1er trimestre", "2me trimestre", "3me trimestre", "4me trimestre"]
};
const monthValues$U = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "janv.",
    "fvr.",
    "mars",
    "avr.",
    "mai",
    "juin",
    "juil.",
    "aot",
    "sept.",
    "oct.",
    "nov.",
    "dc."
  ],
  wide: [
    "janvier",
    "fvrier",
    "mars",
    "avril",
    "mai",
    "juin",
    "juillet",
    "aot",
    "septembre",
    "octobre",
    "novembre",
    "dcembre"
  ]
};
const dayValues$U = {
  narrow: ["D", "L", "M", "M", "J", "V", "S"],
  short: ["di", "lu", "ma", "me", "je", "ve", "sa"],
  abbreviated: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],
  wide: [
    "dimanche",
    "lundi",
    "mardi",
    "mercredi",
    "jeudi",
    "vendredi",
    "samedi"
  ]
};
const dayPeriodValues$U = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "minuit",
    noon: "midi",
    morning: "mat.",
    afternoon: "ap.m.",
    evening: "soir",
    night: "mat."
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "minuit",
    noon: "midi",
    morning: "matin",
    afternoon: "aprs-midi",
    evening: "soir",
    night: "matin"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "minuit",
    noon: "midi",
    morning: "du matin",
    afternoon: "de laprs-midi",
    evening: "du soir",
    night: "du matin"
  }
};
const ordinalNumber$U = (dirtyNumber, options) => {
  const number2 = Number(dirtyNumber);
  const unit = options?.unit;
  if (number2 === 0) return "0";
  const feminineUnits = ["year", "week", "hour", "minute", "second"];
  let suffix;
  if (number2 === 1) {
    suffix = unit && feminineUnits.includes(unit) ? "re" : "er";
  } else {
    suffix = "me";
  }
  return number2 + suffix;
};
const LONG_MONTHS_TOKENS = ["MMM", "MMMM"];
const localize$U = {
  preprocessor: (date2, parts) => {
    if (date2.getDate() === 1) return parts;
    const hasLongMonthToken = parts.some(
      (part) => part.isToken && LONG_MONTHS_TOKENS.includes(part.value)
    );
    if (!hasLongMonthToken) return parts;
    return parts.map(
      (part) => part.isToken && part.value === "do" ? { isToken: true, value: "d" } : part
    );
  },
  ordinalNumber: ordinalNumber$U,
  era: buildLocalizeFn({
    values: eraValues$U,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$U,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$U,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$U,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$U,
    defaultWidth: "wide"
  })
};
const matchOrdinalNumberPattern$U = /^(\d+)(ime|re|me|er|e)?/i;
const parseOrdinalNumberPattern$U = /\d+/i;
const matchEraPatterns$U = {
  narrow: /^(av\.J\.C|ap\.J\.C|ap\.J\.-C)/i,
  abbreviated: /^(av\.J\.-C|av\.J-C|apr\.J\.-C|apr\.J-C|ap\.J-C)/i,
  wide: /^(avant Jsus-Christ|aprs Jsus-Christ)/i
};
const parseEraPatterns$U = {
  any: [/^av/i, /^ap/i]
};
const matchQuarterPatterns$U = {
  narrow: /^T?[1234]/i,
  abbreviated: /^[1234](er|me|e)? trim\.?/i,
  wide: /^[1234](er|me|e)? trimestre/i
};
const parseQuarterPatterns$U = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$U = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(janv|fvr|mars|avr|mai|juin|juill|juil|aot|sept|oct|nov|dc)\.?/i,
  wide: /^(janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i
};
const parseMonthPatterns$U = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^av/i,
    /^ma/i,
    /^juin/i,
    /^juil/i,
    /^ao/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$U = {
  narrow: /^[lmjvsd]/i,
  short: /^(di|lu|ma|me|je|ve|sa)/i,
  abbreviated: /^(dim|lun|mar|mer|jeu|ven|sam)\.?/i,
  wide: /^(dimanche|lundi|mardi|mercredi|jeudi|vendredi|samedi)/i
};
const parseDayPatterns$U = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
  any: [/^di/i, /^lu/i, /^ma/i, /^me/i, /^je/i, /^ve/i, /^sa/i]
};
const matchDayPeriodPatterns$U = {
  narrow: /^(a|p|minuit|midi|mat\.?|ap\.?m\.?|soir|nuit)/i,
  any: /^([ap]\.?\s?m\.?|du matin|de l'aprs[-\s]midi|du soir|de la nuit)/i
};
const parseDayPeriodPatterns$U = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^min/i,
    noon: /^mid/i,
    morning: /mat/i,
    afternoon: /ap/i,
    evening: /soir/i,
    night: /nuit/i
  }
};
const match$U = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$U,
    parsePattern: parseOrdinalNumberPattern$U,
    valueCallback: (value) => parseInt(value)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$U,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$U,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$U,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$U,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$U,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$U,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$U,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$U,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$U,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$U,
    defaultParseWidth: "any"
  })
};
const fr = {
  code: "fr",
  formatDistance: formatDistance$U,
  formatLong: formatLong$X,
  formatRelative: formatRelative$V,
  localize: localize$U,
  match: match$U,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const dateFormats$W = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "yy-MM-dd"
};
const timeFormats$W = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$W = {
  full: "{{date}} '' {{time}}",
  long: "{{date}} '' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$W = {
  date: buildFormatLongFn({
    formats: dateFormats$W,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$W,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$W,
    defaultWidth: "full"
  })
};
const frCA = {
  code: "fr-CA",
  formatDistance: formatDistance$U,
  formatLong: formatLong$W,
  formatRelative: formatRelative$V,
  localize: localize$U,
  match: match$U,
  // Unique for fr-CA
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const dateFormats$V = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd.MM.y"
};
const timeFormats$V = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$V = {
  full: "{{date}} '' {{time}}",
  long: "{{date}} '' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$V = {
  date: buildFormatLongFn({
    formats: dateFormats$V,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$V,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$V,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$U = {
  lastWeek: "eeee 'la semaine dernire ' p",
  yesterday: "'hier ' p",
  today: "'aujourdhui ' p",
  tomorrow: "'demain ' p'",
  nextWeek: "eeee 'la semaine prochaine ' p",
  other: "P"
};
const formatRelative$U = (token, _date, _baseDate, _options) => formatRelativeLocale$U[token];
const frCH = {
  code: "fr-CH",
  formatDistance: formatDistance$U,
  formatLong: formatLong$V,
  formatRelative: formatRelative$U,
  localize: localize$U,
  match: match$U,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$S = {
  lessThanXSeconds: {
    one: "minder as 1 sekonde",
    other: "minder as {{count}} sekonden"
  },
  xSeconds: {
    one: "1 sekonde",
    other: "{{count}} sekonden"
  },
  halfAMinute: "oardel mint",
  lessThanXMinutes: {
    one: "minder as 1 mint",
    other: "minder as {{count}} minuten"
  },
  xMinutes: {
    one: "1 mint",
    other: "{{count}} minuten"
  },
  aboutXHours: {
    one: "sawat 1 oere",
    other: "sawat {{count}} oere"
  },
  xHours: {
    one: "1 oere",
    other: "{{count}} oere"
  },
  xDays: {
    one: "1 dei",
    other: "{{count}} dagen"
  },
  aboutXWeeks: {
    one: "sawat 1 wike",
    other: "sawat {{count}} wiken"
  },
  xWeeks: {
    one: "1 wike",
    other: "{{count}} wiken"
  },
  aboutXMonths: {
    one: "sawat 1 moanne",
    other: "sawat {{count}} moannen"
  },
  xMonths: {
    one: "1 moanne",
    other: "{{count}} moannen"
  },
  aboutXYears: {
    one: "sawat 1 jier",
    other: "sawat {{count}} jier"
  },
  xYears: {
    one: "1 jier",
    other: "{{count}} jier"
  },
  overXYears: {
    one: "mear as 1 jier",
    other: "mear as {{count}}s jier"
  },
  almostXYears: {
    one: "hast 1 jier",
    other: "hast {{count}} jier"
  }
};
const formatDistance$T = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$S[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "oer " + result;
    } else {
      return result + " lyn";
    }
  }
  return result;
};
const dateFormats$U = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd-MM-y"
};
const timeFormats$U = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$U = {
  full: "{{date}} 'om' {{time}}",
  long: "{{date}} 'om' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$U = {
  date: buildFormatLongFn({
    formats: dateFormats$U,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$U,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$U,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$T = {
  lastWeek: "'frne' eeee 'om' p",
  yesterday: "'juster om' p",
  today: "'hjoed om' p",
  tomorrow: "'moarn om' p",
  nextWeek: "eeee 'om' p",
  other: "P"
};
const formatRelative$T = (token, _date, _baseDate, _options) => formatRelativeLocale$T[token];
const eraValues$T = {
  narrow: ["f.K.", "n.K."],
  abbreviated: ["f.Kr.", "n.Kr."],
  wide: ["foar Kristus", "nei Kristus"]
};
const quarterValues$T = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1e fearnsjier", "2e fearnsjier", "3e fearnsjier", "4e fearnsjier"]
};
const monthValues$T = {
  narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "jan.",
    "feb.",
    "mrt.",
    "apr.",
    "mai.",
    "jun.",
    "jul.",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "des."
  ],
  wide: [
    "jannewaris",
    "febrewaris",
    "maart",
    "april",
    "maaie",
    "juny",
    "july",
    "augustus",
    "septimber",
    "oktober",
    "novimber",
    "desimber"
  ]
};
const dayValues$T = {
  narrow: ["s", "m", "t", "w", "t", "f", "s"],
  short: ["si", "mo", "ti", "wo", "to", "fr", "so"],
  abbreviated: ["snein", "moa", "tii", "woa", "ton", "fre", "sneon"],
  wide: [
    "snein",
    "moandei",
    "tiisdei",
    "woansdei",
    "tongersdei",
    "freed",
    "sneon"
  ]
};
const dayPeriodValues$T = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "middei",
    morning: "moarns",
    afternoon: "middeis",
    evening: "jns",
    night: "nachts"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "middei",
    morning: "moarns",
    afternoon: "middeis",
    evening: "jns",
    night: "nachts"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "middei",
    morning: "moarns",
    afternoon: "middeis",
    evening: "jns",
    night: "nachts"
  }
};
const ordinalNumber$T = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "e";
};
const localize$T = {
  ordinalNumber: ordinalNumber$T,
  era: buildLocalizeFn({
    values: eraValues$T,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$T,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$T,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$T,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$T,
    defaultWidth: "wide"
  })
};
const matchOrdinalNumberPattern$T = /^(\d+)e?/i;
const parseOrdinalNumberPattern$T = /\d+/i;
const matchEraPatterns$T = {
  narrow: /^([fn]\.? ?K\.?)/,
  abbreviated: /^([fn]\. ?Kr\.?)/,
  wide: /^((foar|nei) Kristus)/
};
const parseEraPatterns$T = {
  any: [/^f/, /^n/]
};
const matchQuarterPatterns$T = {
  narrow: /^[1234]/i,
  abbreviated: /^K[1234]/i,
  wide: /^[1234]e fearnsjier/i
};
const parseQuarterPatterns$T = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$T = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan.|feb.|mrt.|apr.|mai.|jun.|jul.|aug.|sep.|okt.|nov.|des.)/i,
  wide: /^(jannewaris|febrewaris|maart|april|maaie|juny|july|augustus|septimber|oktober|novimber|desimber)/i
};
const parseMonthPatterns$T = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^jan/i,
    /^feb/i,
    /^m(r|a)/i,
    /^apr/i,
    /^mai/i,
    /^jun/i,
    /^jul/i,
    /^aug/i,
    /^sep/i,
    /^okt/i,
    /^nov/i,
    /^des/i
  ]
};
const matchDayPatterns$T = {
  narrow: /^[smtwf]/i,
  short: /^(si|mo|ti|wo|to|fr|so)/i,
  abbreviated: /^(snein|moa|tii|woa|ton|fre|sneon)/i,
  wide: /^(snein|moandei|tiisdei|woansdei|tongersdei|freed|sneon)/i
};
const parseDayPatterns$T = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^sn/i, /^mo/i, /^ti/i, /^wo/i, /^to/i, /^fr/i, /^sn/i]
};
const matchDayPeriodPatterns$T = {
  any: /^(am|pm|middernacht|middeis|moarns|middei|jns|nachts)/i
};
const parseDayPeriodPatterns$T = {
  any: {
    am: /^am/i,
    pm: /^pm/i,
    midnight: /^middernacht/i,
    noon: /^middei/i,
    morning: /moarns/i,
    afternoon: /^middeis/i,
    evening: /jns/i,
    night: /nachts/i
  }
};
const match$T = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$T,
    parsePattern: parseOrdinalNumberPattern$T,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$T,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$T,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$T,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$T,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$T,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$T,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$T,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$T,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$T,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$T,
    defaultParseWidth: "any"
  })
};
const fy = {
  code: "fy",
  formatDistance: formatDistance$T,
  formatLong: formatLong$U,
  formatRelative: formatRelative$T,
  localize: localize$T,
  match: match$T,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$R = {
  lessThanXSeconds: {
    one: "nas lugha na diog",
    other: "nas lugha na {{count}} diogan"
  },
  xSeconds: {
    one: "1 diog",
    two: "2 dhiog",
    twenty: "20 diog",
    other: "{{count}} diogan"
  },
  halfAMinute: "leth mhionaid",
  lessThanXMinutes: {
    one: "nas lugha na mionaid",
    other: "nas lugha na {{count}} mionaidean"
  },
  xMinutes: {
    one: "1 mionaid",
    two: "2 mhionaid",
    twenty: "20 mionaid",
    other: "{{count}} mionaidean"
  },
  aboutXHours: {
    one: "mu uair de thde",
    other: "mu {{count}} uairean de thde"
  },
  xHours: {
    one: "1 uair de thde",
    two: "2 uair de thde",
    twenty: "20 uair de thde",
    other: "{{count}} uairean de thde"
  },
  xDays: {
    one: "1 l",
    other: "{{count}} l"
  },
  aboutXWeeks: {
    one: "mu 1 seachdain",
    other: "mu {{count}} seachdainean"
  },
  xWeeks: {
    one: "1 seachdain",
    other: "{{count}} seachdainean"
  },
  aboutXMonths: {
    one: "mu mhos",
    other: "mu {{count}} mosan"
  },
  xMonths: {
    one: "1 mos",
    other: "{{count}} mosan"
  },
  aboutXYears: {
    one: "mu bhliadhna",
    other: "mu {{count}} bliadhnaichean"
  },
  xYears: {
    one: "1 bhliadhna",
    other: "{{count}} bliadhna"
  },
  overXYears: {
    one: "crr is bliadhna",
    other: "crr is {{count}} bliadhnaichean"
  },
  almostXYears: {
    one: "cha mhr bliadhna",
    other: "cha mhr {{count}} bliadhnaichean"
  }
};
const formatDistance$S = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$R[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 2 && !!tokenValue.two) {
    result = tokenValue.two;
  } else if (count === 20 && !!tokenValue.twenty) {
    result = tokenValue.twenty;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "ann an " + result;
    } else {
      return "o chionn " + result;
    }
  }
  return result;
};
const dateFormats$T = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
const timeFormats$T = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$T = {
  full: "{{date}} 'aig' {{time}}",
  long: "{{date}} 'aig' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$T = {
  date: buildFormatLongFn({
    formats: dateFormats$T,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$T,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$T,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$S = {
  lastWeek: "'mu dheireadh' eeee 'aig' p",
  //FIX
  yesterday: "'an-d aig' p",
  today: "'an-diugh aig' p",
  tomorrow: "'a-mireach aig' p",
  nextWeek: "eeee 'aig' p",
  other: "P"
};
const formatRelative$S = (token, _date, _baseDate, _options) => formatRelativeLocale$S[token];
const eraValues$S = {
  narrow: ["R", "A"],
  abbreviated: ["RC", "AD"],
  wide: ["ro Chrosta", "anno domini"]
};
const quarterValues$S = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["C1", "C2", "C3", "C4"],
  wide: [
    "a' chiad chairteal",
    "an drna cairteal",
    "an treas cairteal",
    "an ceathramh cairteal"
  ]
};
const monthValues$S = {
  narrow: ["F", "G", "M", "G", "C", "", "I", "L", "S", "D", "S", "D"],
  abbreviated: [
    "Faoi",
    "Gear",
    "Mrt",
    "Gibl",
    "Cit",
    "gmh",
    "Iuch",
    "Ln",
    "Sult",
    "Dmh",
    "Samh",
    "Dbh"
  ],
  wide: [
    "Am Faoilleach",
    "An Gearran",
    "Am Mrt",
    "An Giblean",
    "An Citean",
    "An t-gmhios",
    "An t-Iuchar",
    "An Lnastal",
    "An t-Sultain",
    "An Dmhair",
    "An t-Samhain",
    "An Dbhlachd"
  ]
};
const dayValues$S = {
  narrow: ["D", "L", "M", "C", "A", "H", "S"],
  short: ["D", "Lu", "M", "Ci", "Ar", "Ha", "Sa"],
  abbreviated: ["Did", "Dil", "Dim", "Dic", "Dia", "Dih", "Dis"],
  wide: [
    "Didmhnaich",
    "Diluain",
    "Dimirt",
    "Diciadain",
    "Diardaoin",
    "Dihaoine",
    "Disathairne"
  ]
};
const dayPeriodValues$S = {
  narrow: {
    am: "m",
    pm: "f",
    midnight: "m.o.",
    noon: "m.l.",
    morning: "madainn",
    afternoon: "feasgar",
    evening: "feasgar",
    night: "oidhche"
  },
  abbreviated: {
    am: "M.",
    pm: "F.",
    midnight: "meadhan oidhche",
    noon: "meadhan l",
    morning: "madainn",
    afternoon: "feasgar",
    evening: "feasgar",
    night: "oidhche"
  },
  wide: {
    am: "m.",
    pm: "f.",
    midnight: "meadhan oidhche",
    noon: "meadhan l",
    morning: "madainn",
    afternoon: "feasgar",
    evening: "feasgar",
    night: "oidhche"
  }
};
const formattingDayPeriodValues$I = {
  narrow: {
    am: "m",
    pm: "f",
    midnight: "m.o.",
    noon: "m.l.",
    morning: "sa mhadainn",
    afternoon: "feasgar",
    evening: "feasgar",
    night: "air an oidhche"
  },
  abbreviated: {
    am: "M.",
    pm: "F.",
    midnight: "meadhan oidhche",
    noon: "meadhan l",
    morning: "sa mhadainn",
    afternoon: "feasgar",
    evening: "feasgar",
    night: "air an oidhche"
  },
  wide: {
    am: "m.",
    pm: "f.",
    midnight: "meadhan oidhche",
    noon: "meadhan l",
    morning: "sa mhadainn",
    afternoon: "feasgar",
    evening: "feasgar",
    night: "air an oidhche"
  }
};
const ordinalNumber$S = (dirtyNumber) => {
  const number2 = Number(dirtyNumber);
  const rem100 = number2 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number2 + "d";
      case 2:
        return number2 + "na";
    }
  }
  if (rem100 === 12) {
    return number2 + "na";
  }
  return number2 + "mh";
};
const localize$S = {
  ordinalNumber: ordinalNumber$S,
  era: buildLocalizeFn({
    values: eraValues$S,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$S,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$S,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$S,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$S,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$I,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$S = /^(\d+)(d|na|tr|mh)?/i;
const parseOrdinalNumberPattern$S = /\d+/i;
const matchEraPatterns$S = {
  narrow: /^(r|a)/i,
  abbreviated: /^(r\.?\s?c\.?|r\.?\s?a\.?\s?c\.?|a\.?\s?d\.?|a\.?\s?c\.?)/i,
  wide: /^(ro Chrosta|ron aois choitchinn|anno domini|aois choitcheann)/i
};
const parseEraPatterns$S = {
  any: [/^b/i, /^(a|c)/i]
};
const matchQuarterPatterns$S = {
  narrow: /^[1234]/i,
  abbreviated: /^c[1234]/i,
  wide: /^[1234](cd|na|tr|mh)? cairteal/i
};
const parseQuarterPatterns$S = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$S = {
  narrow: /^[fgmcilsd]/i,
  abbreviated: /^(faoi|gear|mrt|gibl|cit|gmh|iuch|ln|sult|dmh|samh|dbh)/i,
  wide: /^(am faoilleach|an gearran|am mrt|an giblean|an citean|an t-gmhios|an t-Iuchar|an lnastal|an t-Sultain|an dmhair|an t-Samhain|an dbhlachd)/i
};
const parseMonthPatterns$S = {
  narrow: [
    /^f/i,
    /^g/i,
    /^m/i,
    /^g/i,
    /^c/i,
    /^/i,
    /^i/i,
    /^l/i,
    /^s/i,
    /^d/i,
    /^s/i,
    /^d/i
  ],
  any: [
    /^fa/i,
    /^ge/i,
    /^m/i,
    /^gi/i,
    /^c/i,
    /^/i,
    /^i/i,
    /^l/i,
    /^su/i,
    /^d/i,
    /^sa/i,
    /^d/i
  ]
};
const matchDayPatterns$S = {
  narrow: /^[dlmcahs]/i,
  short: /^(d|lu|m|ci|ar|ha|sa)/i,
  abbreviated: /^(did|dil|dim|dic|dia|dih|dis)/i,
  wide: /^(didmhnaich|diluain|dimirt|diciadain|diardaoin|dihaoine|disathairne)/i
};
const parseDayPatterns$S = {
  narrow: [/^d/i, /^l/i, /^m/i, /^c/i, /^a/i, /^h/i, /^s/i],
  any: [/^d/i, /^l/i, /^m/i, /^c/i, /^a/i, /^h/i, /^s/i]
};
const matchDayPeriodPatterns$S = {
  narrow: /^(a|p|mi|n|(san|aig) (madainn|feasgar|feasgar|oidhche))/i,
  any: /^([ap]\.?\s?m\.?|meadhan oidhche|meadhan l|(san|aig) (madainn|feasgar|feasgar|oidhche))/i
};
const parseDayPeriodPatterns$S = {
  any: {
    am: /^m/i,
    pm: /^f/i,
    midnight: /^meadhan oidhche/i,
    noon: /^meadhan l/i,
    morning: /sa mhadainn/i,
    afternoon: /feasgar/i,
    evening: /feasgar/i,
    night: /air an oidhche/i
  }
};
const match$S = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$S,
    parsePattern: parseOrdinalNumberPattern$S,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$S,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$S,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$S,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$S,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$S,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$S,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$S,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$S,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$S,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$S,
    defaultParseWidth: "any"
  })
};
const gd = {
  code: "gd",
  formatDistance: formatDistance$S,
  formatLong: formatLong$T,
  formatRelative: formatRelative$S,
  localize: localize$S,
  match: match$S,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$Q = {
  lessThanXSeconds: {
    one: "menos dun segundo",
    other: "menos de {{count}} segundos"
  },
  xSeconds: {
    one: "1 segundo",
    other: "{{count}} segundos"
  },
  halfAMinute: "medio minuto",
  lessThanXMinutes: {
    one: "menos dun minuto",
    other: "menos de {{count}} minutos"
  },
  xMinutes: {
    one: "1 minuto",
    other: "{{count}} minutos"
  },
  aboutXHours: {
    one: "arredor dunha hora",
    other: "arredor de {{count}} horas"
  },
  xHours: {
    one: "1 hora",
    other: "{{count}} horas"
  },
  xDays: {
    one: "1 da",
    other: "{{count}} das"
  },
  aboutXWeeks: {
    one: "arredor dunha semana",
    other: "arredor de {{count}} semanas"
  },
  xWeeks: {
    one: "1 semana",
    other: "{{count}} semanas"
  },
  aboutXMonths: {
    one: "arredor de 1 mes",
    other: "arredor de {{count}} meses"
  },
  xMonths: {
    one: "1 mes",
    other: "{{count}} meses"
  },
  aboutXYears: {
    one: "arredor dun ano",
    other: "arredor de {{count}} anos"
  },
  xYears: {
    one: "1 ano",
    other: "{{count}} anos"
  },
  overXYears: {
    one: "mis dun ano",
    other: "mis de {{count}} anos"
  },
  almostXYears: {
    one: "case un ano",
    other: "case {{count}} anos"
  }
};
const formatDistance$R = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$Q[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "en " + result;
    } else {
      return "hai " + result;
    }
  }
  return result;
};
const dateFormats$S = {
  full: "EEEE, d 'de' MMMM y",
  long: "d 'de' MMMM y",
  medium: "d MMM y",
  short: "dd/MM/y"
};
const timeFormats$S = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$S = {
  full: "{{date}} 's' {{time}}",
  long: "{{date}} 's' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$S = {
  date: buildFormatLongFn({
    formats: dateFormats$S,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$S,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$S,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$R = {
  lastWeek: "'o' eeee 'pasado ' LT",
  yesterday: "'onte ' p",
  today: "'hoxe ' p",
  tomorrow: "'ma ' p",
  nextWeek: "eeee '' p",
  other: "P"
};
const formatRelativeLocalePlural = {
  lastWeek: "'o' eeee 'pasado s' p",
  yesterday: "'onte s' p",
  today: "'hoxe s' p",
  tomorrow: "'ma s' p",
  nextWeek: "eeee 's' p",
  other: "P"
};
const formatRelative$R = (token, date2, _baseDate, _options) => {
  if (date2.getHours() !== 1) {
    return formatRelativeLocalePlural[token];
  }
  return formatRelativeLocale$R[token];
};
const eraValues$R = {
  narrow: ["AC", "DC"],
  abbreviated: ["AC", "DC"],
  wide: ["antes de cristo", "despois de cristo"]
};
const quarterValues$R = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1 trimestre", "2 trimestre", "3 trimestre", "4 trimestre"]
};
const monthValues$R = {
  narrow: ["e", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "xan",
    "feb",
    "mar",
    "abr",
    "mai",
    "xun",
    "xul",
    "ago",
    "set",
    "out",
    "nov",
    "dec"
  ],
  wide: [
    "xaneiro",
    "febreiro",
    "marzo",
    "abril",
    "maio",
    "xuo",
    "xullo",
    "agosto",
    "setembro",
    "outubro",
    "novembro",
    "decembro"
  ]
};
const dayValues$R = {
  narrow: ["d", "l", "m", "m", "j", "v", "s"],
  short: ["do", "lu", "ma", "me", "xo", "ve", "sa"],
  abbreviated: ["dom", "lun", "mar", "mer", "xov", "ven", "sab"],
  wide: ["domingo", "luns", "martes", "mrcores", "xoves", "venres", "sbado"]
};
const dayPeriodValues$R = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "ma",
    afternoon: "tarde",
    evening: "tarde",
    night: "noite"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "medianoite",
    noon: "medioda",
    morning: "ma",
    afternoon: "tarde",
    evening: "tardia",
    night: "noite"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "medianoite",
    noon: "medioda",
    morning: "ma",
    afternoon: "tarde",
    evening: "tardia",
    night: "noite"
  }
};
const formattingDayPeriodValues$H = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "da ma",
    afternoon: "da tarde",
    evening: "da tardia",
    night: "da noite"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "medianoite",
    noon: "medioda",
    morning: "da ma",
    afternoon: "da tarde",
    evening: "da tardia",
    night: "da noite"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "medianoite",
    noon: "medioda",
    morning: "da ma",
    afternoon: "da tarde",
    evening: "da tardia",
    night: "da noite"
  }
};
const ordinalNumber$R = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "";
};
const localize$R = {
  ordinalNumber: ordinalNumber$R,
  era: buildLocalizeFn({
    values: eraValues$R,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$R,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$R,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$R,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$R,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$H,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$R = /^(\d+)()?/i;
const parseOrdinalNumberPattern$R = /\d+/i;
const matchEraPatterns$R = {
  narrow: /^(ac|dc|a|d)/i,
  abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
  wide: /^(antes de cristo|antes da era com[u]n|despois de cristo|era com[u]n)/i
};
const parseEraPatterns$R = {
  any: [/^ac/i, /^dc/i],
  wide: [
    /^(antes de cristo|antes da era com[u]n)/i,
    /^(despois de cristo|era com[u]n)/i
  ]
};
const matchQuarterPatterns$R = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^[1234]()? trimestre/i
};
const parseQuarterPatterns$R = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$R = {
  narrow: /^[xfmasond]/i,
  abbreviated: /^(xan|feb|mar|abr|mai|xun|xul|ago|set|out|nov|dec)/i,
  wide: /^(xaneiro|febreiro|marzo|abril|maio|xuo|xullo|agosto|setembro|outubro|novembro|decembro)/i
};
const parseMonthPatterns$R = {
  narrow: [
    /^x/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^x/i,
    /^x/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^xan/i,
    /^feb/i,
    /^mar/i,
    /^abr/i,
    /^mai/i,
    /^xun/i,
    /^xul/i,
    /^ago/i,
    /^set/i,
    /^out/i,
    /^nov/i,
    /^dec/i
  ]
};
const matchDayPatterns$R = {
  narrow: /^[dlmxvs]/i,
  short: /^(do|lu|ma|me|xo|ve|sa)/i,
  abbreviated: /^(dom|lun|mar|mer|xov|ven|sab)/i,
  wide: /^(domingo|luns|martes|m[e]rcores|xoves|venres|s[a]bado)/i
};
const parseDayPatterns$R = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^x/i, /^v/i, /^s/i],
  any: [/^do/i, /^lu/i, /^ma/i, /^me/i, /^xo/i, /^ve/i, /^sa/i]
};
const matchDayPeriodPatterns$R = {
  narrow: /^(a|p|mn|md|(da|[a]s) (ma[a]|tarde|noite))/i,
  any: /^([ap]\.?\s?m\.?|medianoite|mediod[i]a|(da|[a]s) (ma[a]|tarde|noite))/i
};
const parseDayPeriodPatterns$R = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mn/i,
    noon: /^md/i,
    morning: /ma[a]/i,
    afternoon: /tarde/i,
    evening: /tardia/i,
    night: /noite/i
  }
};
const match$R = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$R,
    parsePattern: parseOrdinalNumberPattern$R,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$R,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$R,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$R,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$R,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$R,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$R,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$R,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$R,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$R,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$R,
    defaultParseWidth: "any"
  })
};
const gl = {
  code: "gl",
  formatDistance: formatDistance$R,
  formatLong: formatLong$S,
  formatRelative: formatRelative$R,
  localize: localize$R,
  match: match$R,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$P = {
  lessThanXSeconds: {
    one: "",
    // CLDR #1461
    other: " {{count}} "
  },
  xSeconds: {
    one: "1 ",
    other: "{{count}} "
  },
  halfAMinute: " ",
  lessThanXMinutes: {
    one: " ",
    // CLDR #1448
    other: " {{count}} "
  },
  xMinutes: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: " 1 ",
    other: " {{count}} "
  },
  xHours: {
    one: "1 ",
    other: "{{count}} "
  },
  xDays: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: " 1 ",
    other: " {{count}} "
  },
  xWeeks: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: " 1 ",
    other: " {{count}} "
  },
  xMonths: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: " 1 ",
    other: " {{count}} "
  },
  xYears: {
    one: "1 ",
    other: "{{count}} "
  },
  overXYears: {
    one: "1  ",
    other: "{{count}}  "
  },
  almostXYears: {
    one: " 1 ",
    other: " {{count}} "
  }
};
const formatDistance$Q = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$P[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "";
    } else {
      return result + " ";
    }
  }
  return result;
};
const dateFormats$R = {
  full: "EEEE, d MMMM, y",
  // CLDR #1825
  long: "d MMMM, y",
  // CLDR #1826
  medium: "d MMM, y",
  // CLDR #1827
  short: "d/M/yy"
  // CLDR #1828
};
const timeFormats$R = {
  full: "hh:mm:ss a zzzz",
  // CLDR #1829
  long: "hh:mm:ss a z",
  // CLDR #1830
  medium: "hh:mm:ss a",
  // CLDR #1831
  short: "hh:mm a"
  // CLDR #1832
};
const dateTimeFormats$R = {
  full: "{{date}} {{time}}",
  // CLDR #1833
  long: "{{date}} {{time}}",
  // CLDR #1834
  medium: "{{date}} {{time}}",
  // CLDR #1835
  short: "{{date}} {{time}}"
  // CLDR #1836
};
const formatLong$R = {
  date: buildFormatLongFn({
    formats: dateFormats$R,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$R,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$R,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$Q = {
  lastWeek: "'' eeee p",
  // CLDR #1384
  yesterday: "'' p",
  // CLDR #1409
  today: "'' p",
  // CLDR #1410
  tomorrow: "'' p",
  // CLDR #1411
  nextWeek: "eeee p",
  // CLDR #1386
  other: "P"
};
const formatRelative$Q = (token, _date, _baseDate, _options) => formatRelativeLocale$Q[token];
const eraValues$Q = {
  narrow: ["", ""],
  abbreviated: ["..", ".."],
  wide: [" ", ""]
};
const quarterValues$Q = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1 ", "2 ", "3 ", "4 "]
};
const monthValues$Q = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$Q = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$Q = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: ".",
    noon: ".",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$G = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: ".",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$Q = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
const localize$Q = {
  ordinalNumber: ordinalNumber$Q,
  era: buildLocalizeFn({
    values: eraValues$Q,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$Q,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$Q,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$Q,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$Q,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$G,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$Q = /^(\d+)(||||)?/i;
const parseOrdinalNumberPattern$Q = /\d+/i;
const matchEraPatterns$Q = {
  narrow: /^(|)/i,
  abbreviated: /^(\.\.|\.\.)/i,
  wide: /^(\s|)/i
};
const parseEraPatterns$Q = {
  any: [/^/i, /^/i]
};
const matchQuarterPatterns$Q = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](||)? /i
};
const parseQuarterPatterns$Q = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$Q = {
  // eslint-disable-next-line no-misleading-character-class
  narrow: /^[]/i,
  abbreviated: /^(|||||||||||)/i,
  wide: /^(|||||||||||)/i
};
const parseMonthPatterns$Q = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$Q = {
  narrow: /^(||||||)/i,
  short: /^(||||||)/i,
  abbreviated: /^(||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$Q = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$Q = {
  narrow: /^(a|p|\.?||||)/i,
  any: /^(a|p|\.?||||)/i
};
const parseDayPeriodPatterns$Q = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^\.?/i,
    noon: /^/i,
    morning: //i,
    afternoon: //i,
    evening: //i,
    night: //i
  }
};
const match$Q = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$Q,
    parsePattern: parseOrdinalNumberPattern$Q,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$Q,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$Q,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$Q,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$Q,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$Q,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$Q,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$Q,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$Q,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$Q,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$Q,
    defaultParseWidth: "any"
  })
};
const gu = {
  code: "gu",
  formatDistance: formatDistance$Q,
  formatLong: formatLong$R,
  formatRelative: formatRelative$Q,
  localize: localize$Q,
  match: match$Q,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$O = {
  lessThanXSeconds: {
    one: " ",
    two: "  ",
    other: " {{count}} "
  },
  xSeconds: {
    one: "",
    two: " ",
    other: "{{count}} "
  },
  halfAMinute: " ",
  lessThanXMinutes: {
    one: " ",
    two: "  ",
    other: " {{count}} "
  },
  xMinutes: {
    one: "",
    two: " ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: "",
    two: "",
    other: "{{count}} "
  },
  xHours: {
    one: "",
    two: "",
    other: "{{count}} "
  },
  xDays: {
    one: "",
    two: "",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: "",
    two: "",
    other: "{{count}} "
  },
  xWeeks: {
    one: "",
    two: "",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: "",
    two: "",
    other: "{{count}} "
  },
  xMonths: {
    one: "",
    two: "",
    other: "{{count}} "
  },
  aboutXYears: {
    one: "",
    two: "",
    other: "{{count}} "
  },
  xYears: {
    one: "",
    two: "",
    other: "{{count}} "
  },
  overXYears: {
    one: " ",
    two: " ",
    other: " {{count}} "
  },
  almostXYears: {
    one: " ",
    two: " ",
    other: " {{count}} "
  }
};
const formatDistance$P = (token, count, options) => {
  if (token === "xDays" && options?.addSuffix && count <= 2) {
    if (options.comparison && options.comparison > 0) {
      return count === 1 ? "" : "";
    }
    return count === 1 ? "" : "";
  }
  let result;
  const tokenValue = formatDistanceLocale$O[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 2) {
    result = tokenValue.two;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return " " + result;
    } else {
      return " " + result;
    }
  }
  return result;
};
const dateFormats$Q = {
  full: "EEEE, d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "d.M.y"
};
const timeFormats$Q = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
const dateTimeFormats$Q = {
  full: "{{date}} '' {{time}}",
  long: "{{date}} '' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$Q = {
  date: buildFormatLongFn({
    formats: dateFormats$Q,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$Q,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$Q,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$P = {
  lastWeek: "eeee ' ' p",
  yesterday: "' ' p",
  today: "' ' p",
  tomorrow: "' ' p",
  nextWeek: "eeee '' p",
  other: "P"
};
const formatRelative$P = (token, _date, _baseDate, _options) => formatRelativeLocale$P[token];
const eraValues$P = {
  narrow: ["", ""],
  abbreviated: ["", ""],
  wide: [" ", ""]
};
const quarterValues$P = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: [" 1", " 2", " 3", " 4"]
};
const monthValues$P = {
  narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$P = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: [
    " ",
    " ",
    " ",
    " ",
    " ",
    " ",
    ""
  ],
  wide: [
    " ",
    " ",
    " ",
    " ",
    " ",
    " ",
    " "
  ]
};
const dayPeriodValues$P = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$F = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  }
};
const ordinalNumber$P = (dirtyNumber, options) => {
  const number2 = Number(dirtyNumber);
  if (number2 <= 0 || number2 > 10) return String(number2);
  const unit = String(options?.unit);
  const isFemale = ["year", "hour", "minute", "second"].indexOf(unit) >= 0;
  const male = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ];
  const female = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ];
  const index2 = number2 - 1;
  return isFemale ? female[index2] : male[index2];
};
const localize$P = {
  ordinalNumber: ordinalNumber$P,
  era: buildLocalizeFn({
    values: eraValues$P,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$P,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$P,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$P,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$P,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$F,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$P = /^(\d+|(|||||||||||||||||||))/i;
const parseOrdinalNumberPattern$P = /^(\d+||||||||||)/i;
const matchEraPatterns$P = {
  narrow: /^(|)/i,
  abbreviated: /^(|)/i,
  wide: /^( )?/i
};
const parseEraPatterns$P = {
  any: [/^/i, /^/i]
};
const matchQuarterPatterns$P = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^ [1234]/i
};
const parseQuarterPatterns$P = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$P = {
  narrow: /^\d+/i,
  abbreviated: /^(|||||||||||)?/i,
  wide: /^(|||||||||||)/i
};
const parseMonthPatterns$P = {
  narrow: [
    /^1$/i,
    /^2/i,
    /^3/i,
    /^4/i,
    /^5/i,
    /^6/i,
    /^7/i,
    /^8/i,
    /^9/i,
    /^10/i,
    /^11/i,
    /^12/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$P = {
  narrow: /^[]/i,
  short: /^[]/i,
  abbreviated: /^(| (|||||))/i,
  wide: /^ (||||||)/i
};
const parseDayPatterns$P = {
  abbreviated: [/$/i, /$/i, /$/i, /$/i, /$/i, /$/i, /^/i],
  wide: [/$/i, /$/i, /$/i, /$/i, /$/i, /$/i, /$/i],
  any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$P = {
  any: /^( |)?(||||||)/i
};
const parseDayPeriodPatterns$P = {
  any: {
    am: /^/i,
    pm: /^/i,
    midnight: /^/i,
    noon: /^/i,
    morning: //i,
    afternoon: /|/i,
    evening: //i,
    night: //i
  }
};
const ordinalName = ["", "", "", "", "", "", "", "", "", ""];
const match$P = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$P,
    parsePattern: parseOrdinalNumberPattern$P,
    valueCallback: (value) => {
      const number2 = parseInt(value, 10);
      return isNaN(number2) ? ordinalName.indexOf(value) + 1 : number2;
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$P,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$P,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$P,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$P,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$P,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$P,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$P,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$P,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$P,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$P,
    defaultParseWidth: "any"
  })
};
const he = {
  code: "he",
  formatDistance: formatDistance$P,
  formatLong: formatLong$Q,
  formatRelative: formatRelative$P,
  localize: localize$P,
  match: match$P,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const numberValues = {
  locale: {
    1: "",
    2: "",
    3: "",
    4: "",
    5: "",
    6: "",
    7: "",
    8: "",
    9: "",
    0: ""
  },
  number: {
    "": "1",
    "": "2",
    "": "3",
    "": "4",
    "": "5",
    "": "6",
    "": "7",
    "": "8",
    "": "9",
    "": "0"
  }
};
const eraValues$O = {
  narrow: ["-", ""],
  abbreviated: ["-", ""],
  wide: ["-", " "]
};
const quarterValues$O = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1", "2", "3", "4"],
  wide: [" ", " ", " ", " "]
};
const monthValues$O = {
  narrow: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$O = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$O = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$E = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$O = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return numberToLocale(number2);
};
function localeToNumber(locale) {
  const enNumber = locale.toString().replace(/[]/g, function(match2) {
    return numberValues.number[match2];
  });
  return Number(enNumber);
}
function numberToLocale(enNumber) {
  return enNumber.toString().replace(/\d/g, function(match2) {
    return numberValues.locale[match2];
  });
}
const localize$O = {
  ordinalNumber: ordinalNumber$O,
  era: buildLocalizeFn({
    values: eraValues$O,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$O,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$O,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$O,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$O,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$E,
    defaultFormattingWidth: "wide"
  })
};
const formatDistanceLocale$N = {
  lessThanXSeconds: {
    one: "   ",
    // CLDR #1310
    other: "{{count}}   "
  },
  xSeconds: {
    one: " ",
    other: "{{count}} "
  },
  halfAMinute: " ",
  lessThanXMinutes: {
    one: "   ",
    other: "{{count}}   "
  },
  xMinutes: {
    one: " ",
    // CLDR #1307
    other: "{{count}} "
  },
  aboutXHours: {
    one: "  ",
    other: " {{count}} "
  },
  xHours: {
    one: " ",
    // CLDR #1304
    other: "{{count}} "
    // CLDR #4467
  },
  xDays: {
    one: " ",
    // CLDR #1286
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: "  ",
    other: " {{count}} "
  },
  xWeeks: {
    one: " ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: "  ",
    other: " {{count}} "
  },
  xMonths: {
    one: " ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: "  ",
    other: " {{count}} "
    // CLDR #4823
  },
  xYears: {
    one: " ",
    other: "{{count}} "
  },
  overXYears: {
    one: "   ",
    other: "{{count}}   "
  },
  almostXYears: {
    one: "  ",
    other: " {{count}} "
  }
};
const formatDistance$O = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$N[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", numberToLocale(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + " ";
    } else {
      return result + " ";
    }
  }
  return result;
};
const dateFormats$P = {
  full: "EEEE, do MMMM, y",
  // CLDR #1787
  long: "do MMMM, y",
  // CLDR #1788
  medium: "d MMM, y",
  // CLDR #1789
  short: "dd/MM/yyyy"
  // CLDR #1790
};
const timeFormats$P = {
  full: "h:mm:ss a zzzz",
  // CLDR #1791
  long: "h:mm:ss a z",
  // CLDR #1792
  medium: "h:mm:ss a",
  // CLDR #1793
  short: "h:mm a"
  // CLDR #1794
};
const dateTimeFormats$P = {
  full: "{{date}} '' {{time}}",
  // CLDR #1795
  long: "{{date}} '' {{time}}",
  // CLDR #1796
  medium: "{{date}}, {{time}}",
  // CLDR #1797
  short: "{{date}}, {{time}}"
  // CLDR #1798
};
const formatLong$P = {
  date: buildFormatLongFn({
    formats: dateFormats$P,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$P,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$P,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$O = {
  lastWeek: "'' eeee p",
  yesterday: "'' p",
  today: "'' p",
  tomorrow: "'' p",
  nextWeek: "eeee '' p",
  other: "P"
};
const formatRelative$O = (token, _date, _baseDate, _options) => formatRelativeLocale$O[token];
const matchOrdinalNumberPattern$O = /^[]+/i;
const parseOrdinalNumberPattern$O = /^[]+/i;
const matchEraPatterns$O = {
  narrow: /^(-|)/i,
  abbreviated: /^(\.?\s?\.?|\.?)/i,
  wide: /^(-| | |)/i
};
const parseEraPatterns$O = {
  any: [/^b/i, /^(a|c)/i]
};
const matchQuarterPatterns$O = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]/i,
  wide: /^[1234](|||)? /i
};
const parseQuarterPatterns$O = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$O = {
  // eslint-disable-next-line no-misleading-character-class
  narrow: /^[]/i,
  abbreviated: /^(|||||||||||)/i,
  wide: /^(|||||||||||)/i
};
const parseMonthPatterns$O = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$O = {
  // eslint-disable-next-line no-misleading-character-class
  narrow: /^[]/i,
  short: /^(||||||)/i,
  abbreviated: /^(||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$O = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$O = {
  narrow: /^(|||.\?||||)/i,
  any: /^(|||.\?||||)/i
};
const parseDayPeriodPatterns$O = {
  any: {
    am: /^/i,
    pm: /^/i,
    midnight: /^/i,
    noon: /^/i,
    morning: //i,
    afternoon: //i,
    evening: //i,
    night: //i
  }
};
const match$O = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$O,
    parsePattern: parseOrdinalNumberPattern$O,
    valueCallback: localeToNumber
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$O,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$O,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$O,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$O,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$O,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$O,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$O,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$O,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$O,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$O,
    defaultParseWidth: "any"
  })
};
const hi = {
  code: "hi",
  formatDistance: formatDistance$O,
  formatLong: formatLong$P,
  formatRelative: formatRelative$O,
  localize: localize$O,
  match: match$O,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$M = {
  lessThanXSeconds: {
    one: {
      standalone: "manje od 1 sekunde",
      withPrepositionAgo: "manje od 1 sekunde",
      withPrepositionIn: "manje od 1 sekundu"
    },
    dual: "manje od {{count}} sekunde",
    other: "manje od {{count}} sekundi"
  },
  xSeconds: {
    one: {
      standalone: "1 sekunda",
      withPrepositionAgo: "1 sekunde",
      withPrepositionIn: "1 sekundu"
    },
    dual: "{{count}} sekunde",
    other: "{{count}} sekundi"
  },
  halfAMinute: "pola minute",
  lessThanXMinutes: {
    one: {
      standalone: "manje od 1 minute",
      withPrepositionAgo: "manje od 1 minute",
      withPrepositionIn: "manje od 1 minutu"
    },
    dual: "manje od {{count}} minute",
    other: "manje od {{count}} minuta"
  },
  xMinutes: {
    one: {
      standalone: "1 minuta",
      withPrepositionAgo: "1 minute",
      withPrepositionIn: "1 minutu"
    },
    dual: "{{count}} minute",
    other: "{{count}} minuta"
  },
  aboutXHours: {
    one: {
      standalone: "oko 1 sat",
      withPrepositionAgo: "oko 1 sat",
      withPrepositionIn: "oko 1 sat"
    },
    dual: "oko {{count}} sata",
    other: "oko {{count}} sati"
  },
  xHours: {
    one: {
      standalone: "1 sat",
      withPrepositionAgo: "1 sat",
      withPrepositionIn: "1 sat"
    },
    dual: "{{count}} sata",
    other: "{{count}} sati"
  },
  xDays: {
    one: {
      standalone: "1 dan",
      withPrepositionAgo: "1 dan",
      withPrepositionIn: "1 dan"
    },
    dual: "{{count}} dana",
    other: "{{count}} dana"
  },
  aboutXWeeks: {
    one: {
      standalone: "oko 1 tjedan",
      withPrepositionAgo: "oko 1 tjedan",
      withPrepositionIn: "oko 1 tjedan"
    },
    dual: "oko {{count}} tjedna",
    other: "oko {{count}} tjedana"
  },
  xWeeks: {
    one: {
      standalone: "1 tjedan",
      withPrepositionAgo: "1 tjedan",
      withPrepositionIn: "1 tjedan"
    },
    dual: "{{count}} tjedna",
    other: "{{count}} tjedana"
  },
  aboutXMonths: {
    one: {
      standalone: "oko 1 mjesec",
      withPrepositionAgo: "oko 1 mjesec",
      withPrepositionIn: "oko 1 mjesec"
    },
    dual: "oko {{count}} mjeseca",
    other: "oko {{count}} mjeseci"
  },
  xMonths: {
    one: {
      standalone: "1 mjesec",
      withPrepositionAgo: "1 mjesec",
      withPrepositionIn: "1 mjesec"
    },
    dual: "{{count}} mjeseca",
    other: "{{count}} mjeseci"
  },
  aboutXYears: {
    one: {
      standalone: "oko 1 godinu",
      withPrepositionAgo: "oko 1 godinu",
      withPrepositionIn: "oko 1 godinu"
    },
    dual: "oko {{count}} godine",
    other: "oko {{count}} godina"
  },
  xYears: {
    one: {
      standalone: "1 godina",
      withPrepositionAgo: "1 godine",
      withPrepositionIn: "1 godinu"
    },
    dual: "{{count}} godine",
    other: "{{count}} godina"
  },
  overXYears: {
    one: {
      standalone: "preko 1 godinu",
      withPrepositionAgo: "preko 1 godinu",
      withPrepositionIn: "preko 1 godinu"
    },
    dual: "preko {{count}} godine",
    other: "preko {{count}} godina"
  },
  almostXYears: {
    one: {
      standalone: "gotovo 1 godinu",
      withPrepositionAgo: "gotovo 1 godinu",
      withPrepositionIn: "gotovo 1 godinu"
    },
    dual: "gotovo {{count}} godine",
    other: "gotovo {{count}} godina"
  }
};
const formatDistance$N = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$M[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    if (options?.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        result = tokenValue.one.withPrepositionIn;
      } else {
        result = tokenValue.one.withPrepositionAgo;
      }
    } else {
      result = tokenValue.one.standalone;
    }
  } else if (count % 10 > 1 && count % 10 < 5 && // if last digit is between 2 and 4
  String(count).substr(-2, 1) !== "1") {
    result = tokenValue.dual.replace("{{count}}", String(count));
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "za " + result;
    } else {
      return "prije " + result;
    }
  }
  return result;
};
const dateFormats$O = {
  full: "EEEE, d. MMMM y.",
  long: "d. MMMM y.",
  medium: "d. MMM y.",
  short: "dd. MM. y."
};
const timeFormats$O = {
  full: "HH:mm:ss (zzzz)",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$O = {
  full: "{{date}} 'u' {{time}}",
  long: "{{date}} 'u' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$O = {
  date: buildFormatLongFn({
    formats: dateFormats$O,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$O,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$O,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$N = {
  lastWeek: (date2) => {
    switch (date2.getDay()) {
      case 0:
        return "'prolu nedjelju u' p";
      case 3:
        return "'prolu srijedu u' p";
      case 6:
        return "'prolu subotu u' p";
      default:
        return "'proli' EEEE 'u' p";
    }
  },
  yesterday: "'juer u' p",
  today: "'danas u' p",
  tomorrow: "'sutra u' p",
  nextWeek: (date2) => {
    switch (date2.getDay()) {
      case 0:
        return "'iduu nedjelju u' p";
      case 3:
        return "'iduu srijedu u' p";
      case 6:
        return "'iduu subotu u' p";
      default:
        return "'proli' EEEE 'u' p";
    }
  },
  other: "P"
};
const formatRelative$N = (token, date2, _baseDate, _options) => {
  const format2 = formatRelativeLocale$N[token];
  if (typeof format2 === "function") {
    return format2(date2);
  }
  return format2;
};
const eraValues$N = {
  narrow: ["pr.n.e.", "AD"],
  abbreviated: ["pr. Kr.", "po. Kr."],
  wide: ["Prije Krista", "Poslije Krista"]
};
const quarterValues$N = {
  narrow: ["1.", "2.", "3.", "4."],
  abbreviated: ["1. kv.", "2. kv.", "3. kv.", "4. kv."],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
const monthValues$N = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12."
  ],
  abbreviated: [
    "sij",
    "velj",
    "ou",
    "tra",
    "svi",
    "lip",
    "srp",
    "kol",
    "ruj",
    "lis",
    "stu",
    "pro"
  ],
  wide: [
    "sijeanj",
    "veljaa",
    "oujak",
    "travanj",
    "svibanj",
    "lipanj",
    "srpanj",
    "kolovoz",
    "rujan",
    "listopad",
    "studeni",
    "prosinac"
  ]
};
const formattingMonthValues$a = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12."
  ],
  abbreviated: [
    "sij",
    "velj",
    "ou",
    "tra",
    "svi",
    "lip",
    "srp",
    "kol",
    "ruj",
    "lis",
    "stu",
    "pro"
  ],
  wide: [
    "sijenja",
    "veljae",
    "oujka",
    "travnja",
    "svibnja",
    "lipnja",
    "srpnja",
    "kolovoza",
    "rujna",
    "listopada",
    "studenog",
    "prosinca"
  ]
};
const dayValues$N = {
  narrow: ["N", "P", "U", "S", "", "P", "S"],
  short: ["ned", "pon", "uto", "sri", "et", "pet", "sub"],
  abbreviated: ["ned", "pon", "uto", "sri", "et", "pet", "sub"],
  wide: [
    "nedjelja",
    "ponedjeljak",
    "utorak",
    "srijeda",
    "etvrtak",
    "petak",
    "subota"
  ]
};
const formattingDayPeriodValues$D = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "pono",
    noon: "podne",
    morning: "ujutro",
    afternoon: "popodne",
    evening: "naveer",
    night: "nou"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "pono",
    noon: "podne",
    morning: "ujutro",
    afternoon: "popodne",
    evening: "naveer",
    night: "nou"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "pono",
    noon: "podne",
    morning: "ujutro",
    afternoon: "poslije podne",
    evening: "naveer",
    night: "nou"
  }
};
const dayPeriodValues$N = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "pono",
    noon: "podne",
    morning: "ujutro",
    afternoon: "popodne",
    evening: "naveer",
    night: "nou"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "pono",
    noon: "podne",
    morning: "ujutro",
    afternoon: "popodne",
    evening: "naveer",
    night: "nou"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "pono",
    noon: "podne",
    morning: "ujutro",
    afternoon: "poslije podne",
    evening: "naveer",
    night: "nou"
  }
};
const ordinalNumber$N = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$N = {
  ordinalNumber: ordinalNumber$N,
  era: buildLocalizeFn({
    values: eraValues$N,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$N,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$N,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$a,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$N,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$N,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$D,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$N = /^(\d+)\./i;
const parseOrdinalNumberPattern$N = /\d+/i;
const matchEraPatterns$N = {
  narrow: /^(pr\.n\.e\.|AD)/i,
  abbreviated: /^(pr\.\s?Kr\.|po\.\s?Kr\.)/i,
  wide: /^(Prije Krista|prije nove ere|Poslije Krista|nova era)/i
};
const parseEraPatterns$N = {
  any: [/^pr/i, /^(po|nova)/i]
};
const matchQuarterPatterns$N = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]\.\s?kv\.?/i,
  wide: /^[1234]\. kvartal/i
};
const parseQuarterPatterns$N = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$N = {
  narrow: /^(10|11|12|[123456789])\./i,
  abbreviated: /^(sij|velj|(ou|ozu)|tra|svi|lip|srp|kol|ruj|lis|stu|pro)/i,
  wide: /^((sijeanj|sijenja|sijecanj|sijecnja)|(veljaa|veljae|veljaca|veljace)|(oujak|oujka|ozujak|ozujka)|(travanj|travnja)|(svibanj|svibnja)|(lipanj|lipnja)|(srpanj|srpnja)|(kolovoz|kolovoza)|(rujan|rujna)|(listopad|listopada)|(studeni|studenog)|(prosinac|prosinca))/i
};
const parseMonthPatterns$N = {
  narrow: [
    /1/i,
    /2/i,
    /3/i,
    /4/i,
    /5/i,
    /6/i,
    /7/i,
    /8/i,
    /9/i,
    /10/i,
    /11/i,
    /12/i
  ],
  abbreviated: [
    /^sij/i,
    /^velj/i,
    /^(ou|ozu)/i,
    /^tra/i,
    /^svi/i,
    /^lip/i,
    /^srp/i,
    /^kol/i,
    /^ruj/i,
    /^lis/i,
    /^stu/i,
    /^pro/i
  ],
  wide: [
    /^sij/i,
    /^velj/i,
    /^(ou|ozu)/i,
    /^tra/i,
    /^svi/i,
    /^lip/i,
    /^srp/i,
    /^kol/i,
    /^ruj/i,
    /^lis/i,
    /^stu/i,
    /^pro/i
  ]
};
const matchDayPatterns$N = {
  narrow: /^[npusc]/i,
  short: /^(ned|pon|uto|sri|(et|cet)|pet|sub)/i,
  abbreviated: /^(ned|pon|uto|sri|(et|cet)|pet|sub)/i,
  wide: /^(nedjelja|ponedjeljak|utorak|srijeda|(etvrtak|cetvrtak)|petak|subota)/i
};
const parseDayPatterns$N = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns$N = {
  any: /^(am|pm|ponoc|pono|(po)?podne|navecer|naveer|nou|poslije podne|ujutro)/i
};
const parseDayPeriodPatterns$N = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^pono/i,
    noon: /^pod/i,
    morning: /jutro/i,
    afternoon: /(poslije\s|po)+podne/i,
    evening: /(navece|navee)/i,
    night: /(nocu|nou)/i
  }
};
const match$N = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$N,
    parsePattern: parseOrdinalNumberPattern$N,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$N,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$N,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$N,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$N,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$N,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$N,
    defaultParseWidth: "wide"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$N,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$N,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$N,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$N,
    defaultParseWidth: "any"
  })
};
const hr = {
  code: "hr",
  formatDistance: formatDistance$N,
  formatLong: formatLong$O,
  formatRelative: formatRelative$N,
  localize: localize$N,
  match: match$N,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$L = {
  lessThanXSeconds: {
    one: "mwens pase yon segond",
    other: "mwens pase {{count}} segond"
  },
  xSeconds: {
    one: "1 segond",
    other: "{{count}} segond"
  },
  halfAMinute: "30 segond",
  lessThanXMinutes: {
    one: "mwens pase yon minit",
    other: "mwens pase {{count}} minit"
  },
  xMinutes: {
    one: "1 minit",
    other: "{{count}} minit"
  },
  aboutXHours: {
    one: "anviwon in",
    other: "anviwon {{count}} "
  },
  xHours: {
    one: "1 l",
    other: "{{count}} l"
  },
  xDays: {
    one: "1 jou",
    other: "{{count}} jou"
  },
  aboutXWeeks: {
    one: "anviwon 1 semn",
    other: "anviwon {{count}} semn"
  },
  xWeeks: {
    one: "1 semn",
    other: "{{count}} semn"
  },
  aboutXMonths: {
    one: "anviwon 1 mwa",
    other: "anviwon {{count}} mwa"
  },
  xMonths: {
    one: "1 mwa",
    other: "{{count}} mwa"
  },
  aboutXYears: {
    one: "anviwon 1 an",
    other: "anviwon {{count}} an"
  },
  xYears: {
    one: "1 an",
    other: "{{count}} an"
  },
  overXYears: {
    one: "plis pase 1 an",
    other: "plis pase {{count}} an"
  },
  almostXYears: {
    one: "prske 1 an",
    other: "prske {{count}} an"
  }
};
const formatDistance$M = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$L[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "nan " + result;
    } else {
      return "sa f " + result;
    }
  }
  return result;
};
const dateFormats$N = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd/MM/y"
};
const timeFormats$N = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$N = {
  full: "{{date}} 'nan l' {{time}}",
  long: "{{date}} 'nan l' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$N = {
  date: buildFormatLongFn({
    formats: dateFormats$N,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$N,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$N,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$M = {
  lastWeek: "eeee 'pase nan l' p",
  yesterday: "'y nan l' p",
  today: "'jodi a' p",
  tomorrow: "'demen nan l' p'",
  nextWeek: "eeee 'pwochen nan l' p",
  other: "P"
};
const formatRelative$M = (token, _date, _baseDate, _options) => formatRelativeLocale$M[token];
const eraValues$M = {
  narrow: ["av. J.-K", "ap. J.-K"],
  abbreviated: ["av. J.-K", "ap. J.-K"],
  wide: ["anvan Jezi Kris", "apre Jezi Kris"]
};
const quarterValues$M = {
  narrow: ["T1", "T2", "T3", "T4"],
  abbreviated: ["1ye trim.", "2ym trim.", "3ym trim.", "4ym trim."],
  wide: ["1ye trims", "2ym trims", "3ym trims", "4ym trims"]
};
const monthValues$M = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "O", "S", "O", "N", "D"],
  abbreviated: [
    "janv.",
    "fevr.",
    "mas",
    "avr.",
    "me",
    "jen",
    "jiy",
    "out",
    "sept.",
    "okt.",
    "nov.",
    "des."
  ],
  wide: [
    "janvye",
    "fevrye",
    "mas",
    "avril",
    "me",
    "jen",
    "jiy",
    "out",
    "septanm",
    "oktb",
    "novanm",
    "desanm"
  ]
};
const dayValues$M = {
  narrow: ["D", "L", "M", "M", "J", "V", "S"],
  short: ["di", "le", "ma", "m", "je", "va", "sa"],
  abbreviated: ["dim.", "len.", "mad.", "mk.", "jed.", "van.", "sam."],
  wide: ["dimanch", "lendi", "madi", "mkredi", "jedi", "vandredi", "samdi"]
};
const dayPeriodValues$M = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "minwit",
    noon: "midi",
    morning: "mat.",
    afternoon: "ap.m.",
    evening: "swa",
    night: "mat."
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "minwit",
    noon: "midi",
    morning: "maten",
    afternoon: "aprmidi",
    evening: "swa",
    night: "maten"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "minwit",
    noon: "midi",
    morning: "nan maten",
    afternoon: "nan aprmidi",
    evening: "nan asw",
    night: "nan maten"
  }
};
const ordinalNumber$M = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  if (number2 === 0) return String(number2);
  const suffix = number2 === 1 ? "ye" : "ym";
  return number2 + suffix;
};
const localize$M = {
  ordinalNumber: ordinalNumber$M,
  era: buildLocalizeFn({
    values: eraValues$M,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$M,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$M,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$M,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$M,
    defaultWidth: "wide"
  })
};
const matchOrdinalNumberPattern$M = /^(\d+)(ye|ym)?/i;
const parseOrdinalNumberPattern$M = /\d+/i;
const matchEraPatterns$M = {
  narrow: /^(av\.J\.K|ap\.J\.K|ap\.J\.-K)/i,
  abbreviated: /^(av\.J\.-K|av\.J-K|apr\.J\.-K|apr\.J-K|ap\.J-K)/i,
  wide: /^(avan Jezi Kris|apre Jezi Kris)/i
};
const parseEraPatterns$M = {
  any: [/^av/i, /^ap/i]
};
const matchQuarterPatterns$M = {
  narrow: /^[1234]/i,
  abbreviated: /^t[1234]/i,
  wide: /^[1234](ye|ym)? trims/i
};
const parseQuarterPatterns$M = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$M = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(janv|fevr|mas|avr|me|jen|jiy|out|sept|okt|nov|des)\.?/i,
  wide: /^(janvye|fevrye|mas|avril|me|jen|jiy|out|septanm|oktb|novanm|desanm)/i
};
const parseMonthPatterns$M = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^o/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^ma/i,
    /^av/i,
    /^me/i,
    /^je/i,
    /^ji/i,
    /^ou/i,
    /^s/i,
    /^ok/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$M = {
  narrow: /^[lmjvsd]/i,
  short: /^(di|le|ma|me|je|va|sa)/i,
  abbreviated: /^(dim|len|mad|mk|jed|van|sam)\.?/i,
  wide: /^(dimanch|lendi|madi|mkredi|jedi|vandredi|samdi)/i
};
const parseDayPatterns$M = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
  any: [/^di/i, /^le/i, /^ma/i, /^m/i, /^je/i, /^va/i, /^sa/i]
};
const matchDayPeriodPatterns$M = {
  narrow: /^(a|p|minwit|midi|mat\.?|ap\.?m\.?|swa)/i,
  any: /^([ap]\.?\s?m\.?|nan maten|nan aprmidi|nan asw)/i
};
const parseDayPeriodPatterns$M = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^min/i,
    noon: /^mid/i,
    morning: /mat/i,
    afternoon: /ap/i,
    evening: /sw/i,
    night: /nwit/i
  }
};
const match$M = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$M,
    parsePattern: parseOrdinalNumberPattern$M,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$M,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$M,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$M,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$M,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$M,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$M,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$M,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$M,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$M,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$M,
    defaultParseWidth: "any"
  })
};
const ht = {
  code: "ht",
  formatDistance: formatDistance$M,
  formatLong: formatLong$N,
  formatRelative: formatRelative$M,
  localize: localize$M,
  match: match$M,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const translations$1 = {
  about: "krlbell",
  over: "tbb mint",
  almost: "majdnem",
  lessthan: "kevesebb mint"
};
const withoutSuffixes = {
  xseconds: " msodperc",
  halfaminute: "fl perc",
  xminutes: " perc",
  xhours: " ra",
  xdays: " nap",
  xweeks: " ht",
  xmonths: " hnap",
  xyears: " v"
};
const withSuffixes = {
  xseconds: {
    "-1": " msodperccel ezeltt",
    1: " msodperc mlva",
    0: " msodperce"
  },
  halfaminute: {
    "-1": "fl perccel ezeltt",
    1: "fl perc mlva",
    0: "fl perce"
  },
  xminutes: {
    "-1": " perccel ezeltt",
    1: " perc mlva",
    0: " perce"
  },
  xhours: {
    "-1": " rval ezeltt",
    1: " ra mlva",
    0: " rja"
  },
  xdays: {
    "-1": " nappal ezeltt",
    1: " nap mlva",
    0: " napja"
  },
  xweeks: {
    "-1": " httel ezeltt",
    1: " ht mlva",
    0: " hete"
  },
  xmonths: {
    "-1": " hnappal ezeltt",
    1: " hnap mlva",
    0: " hnapja"
  },
  xyears: {
    "-1": " vvel ezeltt",
    1: " v mlva",
    0: " ve"
  }
};
const formatDistance$L = (token, count, options) => {
  const adverb = token.match(/about|over|almost|lessthan/i);
  const unit = adverb ? token.replace(adverb[0], "") : token;
  const addSuffix = options?.addSuffix === true;
  const key = unit.toLowerCase();
  const comparison = options?.comparison || 0;
  const translated = addSuffix ? withSuffixes[key][comparison] : withoutSuffixes[key];
  let result = key === "halfaminute" ? translated : count + translated;
  if (adverb) {
    const adv = adverb[0].toLowerCase();
    result = translations$1[adv] + " " + result;
  }
  return result;
};
const dateFormats$M = {
  full: "y. MMMM d., EEEE",
  long: "y. MMMM d.",
  medium: "y. MMM d.",
  short: "y. MM. dd."
};
const timeFormats$M = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
const dateTimeFormats$M = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$M = {
  date: buildFormatLongFn({
    formats: dateFormats$M,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$M,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$M,
    defaultWidth: "full"
  })
};
const accusativeWeekdays$4 = [
  "vasrnap",
  "htfn",
  "kedden",
  "szerdn",
  "cstrtkn",
  "pnteken",
  "szombaton"
];
function week(isFuture) {
  return (date2) => {
    const weekday = accusativeWeekdays$4[date2.getDay()];
    const prefix2 = isFuture ? "" : "'mlt' ";
    return `${prefix2}'${weekday}' p'-kor'`;
  };
}
const formatRelativeLocale$L = {
  lastWeek: week(false),
  yesterday: "'tegnap' p'-kor'",
  today: "'ma' p'-kor'",
  tomorrow: "'holnap' p'-kor'",
  nextWeek: week(true),
  other: "P"
};
const formatRelative$L = (token, date2) => {
  const format2 = formatRelativeLocale$L[token];
  if (typeof format2 === "function") {
    return format2(date2);
  }
  return format2;
};
const eraValues$L = {
  narrow: ["ie.", "isz."],
  abbreviated: ["i. e.", "i. sz."],
  wide: ["Krisztus eltt", "idszmtsunk szerint"]
};
const quarterValues$L = {
  narrow: ["1.", "2.", "3.", "4."],
  abbreviated: ["1. n.v", "2. n.v", "3. n.v", "4. n.v"],
  wide: ["1. negyedv", "2. negyedv", "3. negyedv", "4. negyedv"]
};
const formattingQuarterValues$3 = {
  narrow: ["I.", "II.", "III.", "IV."],
  abbreviated: ["I. n.v", "II. n.v", "III. n.v", "IV. n.v"],
  wide: ["I. negyedv", "II. negyedv", "III. negyedv", "IV. negyedv"]
};
const monthValues$L = {
  narrow: ["J", "F", "M", "", "M", "J", "J", "A", "Sz", "O", "N", "D"],
  abbreviated: [
    "jan.",
    "febr.",
    "mrc.",
    "pr.",
    "mj.",
    "jn.",
    "jl.",
    "aug.",
    "szept.",
    "okt.",
    "nov.",
    "dec."
  ],
  wide: [
    "janur",
    "februr",
    "mrcius",
    "prilis",
    "mjus",
    "jnius",
    "jlius",
    "augusztus",
    "szeptember",
    "oktber",
    "november",
    "december"
  ]
};
const dayValues$L = {
  narrow: ["V", "H", "K", "Sz", "Cs", "P", "Sz"],
  short: ["V", "H", "K", "Sze", "Cs", "P", "Szo"],
  abbreviated: ["V", "H", "K", "Sze", "Cs", "P", "Szo"],
  wide: [
    "vasrnap",
    "htf",
    "kedd",
    "szerda",
    "cstrtk",
    "pntek",
    "szombat"
  ]
};
const dayPeriodValues$L = {
  narrow: {
    am: "de.",
    pm: "du.",
    midnight: "jfl",
    noon: "dl",
    morning: "reggel",
    afternoon: "du.",
    evening: "este",
    night: "jjel"
  },
  abbreviated: {
    am: "de.",
    pm: "du.",
    midnight: "jfl",
    noon: "dl",
    morning: "reggel",
    afternoon: "du.",
    evening: "este",
    night: "jjel"
  },
  wide: {
    am: "de.",
    pm: "du.",
    midnight: "jfl",
    noon: "dl",
    morning: "reggel",
    afternoon: "dlutn",
    evening: "este",
    night: "jjel"
  }
};
const ordinalNumber$L = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$L = {
  ordinalNumber: ordinalNumber$L,
  era: buildLocalizeFn({
    values: eraValues$L,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$L,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
    formattingValues: formattingQuarterValues$3,
    defaultFormattingWidth: "wide"
  }),
  month: buildLocalizeFn({
    values: monthValues$L,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$L,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$L,
    defaultWidth: "wide"
  })
};
const matchOrdinalNumberPattern$L = /^(\d+)\.?/i;
const parseOrdinalNumberPattern$L = /\d+/i;
const matchEraPatterns$L = {
  narrow: /^(ie\.|isz\.)/i,
  abbreviated: /^(i\.\s?e\.?|b?\s?c\s?e|i\.\s?sz\.?)/i,
  wide: /^(Krisztus eltt|idszmtsunk eltt|idszmtsunk szerint|i\. sz\.)/i
};
const parseEraPatterns$L = {
  narrow: [/ie/i, /isz/i],
  abbreviated: [/^(i\.?\s?e\.?|b\s?ce)/i, /^(i\.?\s?sz\.?|c\s?e)/i],
  any: [/eltt/i, /(szerint|i. sz.)/i]
};
const matchQuarterPatterns$L = {
  narrow: /^[1234]\.?/i,
  abbreviated: /^[1234]?\.?\s?n\.v/i,
  wide: /^([1234]|I|II|III|IV)?\.?\s?negyedv/i
};
const parseQuarterPatterns$L = {
  any: [/1|I$/i, /2|II$/i, /3|III/i, /4|IV/i]
};
const matchMonthPatterns$L = {
  narrow: /^[jfmasond]|sz/i,
  abbreviated: /^(jan\.?|febr\.?|mrc\.?|pr\.?|mj\.?|jn\.?|jl\.?|aug\.?|szept\.?|okt\.?|nov\.?|dec\.?)/i,
  wide: /^(janur|februr|mrcius|prilis|mjus|jnius|jlius|augusztus|szeptember|oktber|november|december)/i
};
const parseMonthPatterns$L = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a|/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s|sz/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mr/i,
    /^p/i,
    /^mj/i,
    /^jn/i,
    /^jl/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$L = {
  narrow: /^([vhkpc]|sz|cs|sz)/i,
  short: /^([vhkp]|sze|cs|szo)/i,
  abbreviated: /^([vhkp]|sze|cs|szo)/i,
  wide: /^(vasrnap|htf|kedd|szerda|cstrtk|pntek|szombat)/i
};
const parseDayPatterns$L = {
  narrow: [/^v/i, /^h/i, /^k/i, /^sz/i, /^c/i, /^p/i, /^sz/i],
  any: [/^v/i, /^h/i, /^k/i, /^sze/i, /^c/i, /^p/i, /^szo/i]
};
const matchDayPeriodPatterns$L = {
  any: /^((de|du)\.?|jfl|dlutn|dl|reggel|este|jjel)/i
};
const parseDayPeriodPatterns$L = {
  any: {
    am: /^de\.?/i,
    pm: /^du\.?/i,
    midnight: /^jf/i,
    noon: /^d/i,
    morning: /reg/i,
    afternoon: /^dlu\.?/i,
    evening: /es/i,
    night: /jj/i
  }
};
const match$L = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$L,
    parsePattern: parseOrdinalNumberPattern$L,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$L,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$L,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$L,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$L,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$L,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$L,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$L,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$L,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$L,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$L,
    defaultParseWidth: "any"
  })
};
const hu = {
  code: "hu",
  formatDistance: formatDistance$L,
  formatLong: formatLong$M,
  formatRelative: formatRelative$L,
  localize: localize$L,
  match: match$L,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$K = {
  lessThanXSeconds: {
    one: "   1 ",
    other: "   {{count}} "
  },
  xSeconds: {
    one: "1 ",
    other: "{{count}} "
  },
  halfAMinute: " ",
  lessThanXMinutes: {
    one: "   1 ",
    other: "   {{count}} "
  },
  xMinutes: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: " 1 ",
    other: " {{count}} "
  },
  xHours: {
    one: "1 ",
    other: "{{count}} "
  },
  xDays: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: " 1 ",
    other: " {{count}} "
  },
  xWeeks: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: " 1 ",
    other: " {{count}} "
  },
  xMonths: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: " 1 ",
    other: " {{count}} "
  },
  xYears: {
    one: "1 ",
    other: "{{count}} "
  },
  overXYears: {
    one: "  1 ",
    other: "  {{count}} "
  },
  almostXYears: {
    one: " 1 ",
    other: " {{count}} "
  }
};
const formatDistance$K = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$K[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + " ";
    } else {
      return result + " ";
    }
  }
  return result;
};
const dateFormats$L = {
  full: "d MMMM, y, EEEE",
  long: "d MMMM, y",
  medium: "d MMM, y",
  short: "dd.MM.yyyy"
};
const timeFormats$L = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$L = {
  full: "{{date}} ''{{time}}",
  long: "{{date}} ''{{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$L = {
  date: buildFormatLongFn({
    formats: dateFormats$L,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$L,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$L,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$K = {
  lastWeek: "'' eeee p''",
  yesterday: "'' p''",
  today: "'' p''",
  tomorrow: "'' p''",
  nextWeek: "'' eeee p''",
  other: "P"
};
const formatRelative$K = (token, _date, _baseDate, _options) => formatRelativeLocale$K[token];
const eraValues$K = {
  narrow: ["", ""],
  abbreviated: ["", ""],
  wide: [" ", " "]
};
const quarterValues$K = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1", "2", "3", "4"],
  wide: ["1 ", "2 ", "3 ", "4 "]
};
const monthValues$K = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$K = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$K = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$C = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$K = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  const rem100 = number2 % 100;
  if (rem100 < 10) {
    if (rem100 % 10 === 1) {
      return number2 + "";
    }
  }
  return number2 + "";
};
const localize$K = {
  ordinalNumber: ordinalNumber$K,
  era: buildLocalizeFn({
    values: eraValues$K,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$K,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$K,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$K,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$K,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$C,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$K = /^(\d+)((-|)?(|))?/i;
const parseOrdinalNumberPattern$K = /\d+/i;
const matchEraPatterns$K = {
  narrow: /^(|)/i,
  abbreviated: /^(\.?\s?\.?|\.?\s?\.?\s?\.?|\.?\s?\.?|\.?\s?\.?)/i,
  wide: /^( |  | | )/i
};
const parseEraPatterns$K = {
  any: [/^/i, /^/i]
};
const matchQuarterPatterns$K = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]/i,
  wide: /^[1234]((-|)?(|)) /i
};
const parseQuarterPatterns$K = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$K = {
  narrow: /^[]/i,
  abbreviated: /^(|||||||||||)/i,
  wide: /^(|||||||||||)/i
};
const parseMonthPatterns$K = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$K = {
  narrow: /^[]/i,
  short: /^(||||||)/i,
  abbreviated: /^(||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$K = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^(|)/, /^/i],
  short: [/^/i, /^/i, /^/i, /^/i, /^/i, /^(|)/, /^/i],
  abbreviated: [/^/i, /^/i, /^/i, /^/i, /^/i, /^(|)/, /^/i],
  wide: [/^/i, /^/i, /^/i, /^/i, /^/i, /^(|)/, /^/i]
};
const matchDayPeriodPatterns$K = {
  narrow: /^([ap]|||(?|?|()?|?))/i,
  any: /^([ap]\.?\s?m\.?|()?|()?|(?|?|()?|?))/i
};
const parseDayPeriodPatterns$K = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: //i,
    noon: //i,
    morning: //i,
    afternoon: //i,
    evening: //i,
    night: //i
  }
};
const match$K = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$K,
    parsePattern: parseOrdinalNumberPattern$K,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$K,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$K,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$K,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$K,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$K,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$K,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$K,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$K,
    defaultParseWidth: "wide"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$K,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$K,
    defaultParseWidth: "any"
  })
};
const hy = {
  code: "hy",
  formatDistance: formatDistance$K,
  formatLong: formatLong$L,
  formatRelative: formatRelative$K,
  localize: localize$K,
  match: match$K,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$J = {
  lessThanXSeconds: {
    one: "kurang dari 1 detik",
    other: "kurang dari {{count}} detik"
  },
  xSeconds: {
    one: "1 detik",
    other: "{{count}} detik"
  },
  halfAMinute: "setengah menit",
  lessThanXMinutes: {
    one: "kurang dari 1 menit",
    other: "kurang dari {{count}} menit"
  },
  xMinutes: {
    one: "1 menit",
    other: "{{count}} menit"
  },
  aboutXHours: {
    one: "sekitar 1 jam",
    other: "sekitar {{count}} jam"
  },
  xHours: {
    one: "1 jam",
    other: "{{count}} jam"
  },
  xDays: {
    one: "1 hari",
    other: "{{count}} hari"
  },
  aboutXWeeks: {
    one: "sekitar 1 minggu",
    other: "sekitar {{count}} minggu"
  },
  xWeeks: {
    one: "1 minggu",
    other: "{{count}} minggu"
  },
  aboutXMonths: {
    one: "sekitar 1 bulan",
    other: "sekitar {{count}} bulan"
  },
  xMonths: {
    one: "1 bulan",
    other: "{{count}} bulan"
  },
  aboutXYears: {
    one: "sekitar 1 tahun",
    other: "sekitar {{count}} tahun"
  },
  xYears: {
    one: "1 tahun",
    other: "{{count}} tahun"
  },
  overXYears: {
    one: "lebih dari 1 tahun",
    other: "lebih dari {{count}} tahun"
  },
  almostXYears: {
    one: "hampir 1 tahun",
    other: "hampir {{count}} tahun"
  }
};
const formatDistance$J = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$J[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "dalam waktu " + result;
    } else {
      return result + " yang lalu";
    }
  }
  return result;
};
const dateFormats$K = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "d/M/yyyy"
};
const timeFormats$K = {
  full: "HH.mm.ss",
  long: "HH.mm.ss",
  medium: "HH.mm",
  short: "HH.mm"
};
const dateTimeFormats$K = {
  full: "{{date}} 'pukul' {{time}}",
  long: "{{date}} 'pukul' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$K = {
  date: buildFormatLongFn({
    formats: dateFormats$K,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$K,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$K,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$J = {
  lastWeek: "eeee 'lalu pukul' p",
  yesterday: "'Kemarin pukul' p",
  today: "'Hari ini pukul' p",
  tomorrow: "'Besok pukul' p",
  nextWeek: "eeee 'pukul' p",
  other: "P"
};
const formatRelative$J = (token, _date, _baseDate, _options) => formatRelativeLocale$J[token];
const eraValues$J = {
  narrow: ["SM", "M"],
  abbreviated: ["SM", "M"],
  wide: ["Sebelum Masehi", "Masehi"]
};
const quarterValues$J = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["Kuartal ke-1", "Kuartal ke-2", "Kuartal ke-3", "Kuartal ke-4"]
};
const monthValues$J = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "Mei",
    "Jun",
    "Jul",
    "Agt",
    "Sep",
    "Okt",
    "Nov",
    "Des"
  ],
  wide: [
    "Januari",
    "Februari",
    "Maret",
    "April",
    "Mei",
    "Juni",
    "Juli",
    "Agustus",
    "September",
    "Oktober",
    "November",
    "Desember"
  ]
};
const dayValues$J = {
  narrow: ["M", "S", "S", "R", "K", "J", "S"],
  short: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
  abbreviated: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
  wide: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"]
};
const dayPeriodValues$J = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "siang",
    evening: "sore",
    night: "malam"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "siang",
    evening: "sore",
    night: "malam"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "siang",
    evening: "sore",
    night: "malam"
  }
};
const formattingDayPeriodValues$B = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "siang",
    evening: "sore",
    night: "malam"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "siang",
    evening: "sore",
    night: "malam"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "siang",
    evening: "sore",
    night: "malam"
  }
};
const ordinalNumber$J = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return "ke-" + number2;
};
const localize$J = {
  ordinalNumber: ordinalNumber$J,
  era: buildLocalizeFn({
    values: eraValues$J,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$J,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$J,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$J,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$J,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$B,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$J = /^ke-(\d+)?/i;
const parseOrdinalNumberPattern$J = /\d+/i;
const matchEraPatterns$J = {
  narrow: /^(sm|m)/i,
  abbreviated: /^(s\.?\s?m\.?|s\.?\s?e\.?\s?u\.?|m\.?|e\.?\s?u\.?)/i,
  wide: /^(sebelum masehi|sebelum era umum|masehi|era umum)/i
};
const parseEraPatterns$J = {
  any: [/^s/i, /^(m|e)/i]
};
const matchQuarterPatterns$J = {
  narrow: /^[1234]/i,
  abbreviated: /^K-?\s[1234]/i,
  wide: /^Kuartal ke-?\s?[1234]/i
};
const parseQuarterPatterns$J = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$J = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|mei|jun|jul|agt|sep|okt|nov|des)/i,
  wide: /^(januari|februari|maret|april|mei|juni|juli|agustus|september|oktober|november|desember)/i
};
const parseMonthPatterns$J = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^ma/i,
    /^ap/i,
    /^me/i,
    /^jun/i,
    /^jul/i,
    /^ag/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$J = {
  narrow: /^[srkjm]/i,
  short: /^(min|sen|sel|rab|kam|jum|sab)/i,
  abbreviated: /^(min|sen|sel|rab|kam|jum|sab)/i,
  wide: /^(minggu|senin|selasa|rabu|kamis|jumat|sabtu)/i
};
const parseDayPatterns$J = {
  narrow: [/^m/i, /^s/i, /^s/i, /^r/i, /^k/i, /^j/i, /^s/i],
  any: [/^m/i, /^sen/i, /^sel/i, /^r/i, /^k/i, /^j/i, /^sa/i]
};
const matchDayPeriodPatterns$J = {
  narrow: /^(a|p|tengah m|tengah h|(di(\swaktu)?) (pagi|siang|sore|malam))/i,
  any: /^([ap]\.?\s?m\.?|tengah malam|tengah hari|(di(\swaktu)?) (pagi|siang|sore|malam))/i
};
const parseDayPeriodPatterns$J = {
  any: {
    am: /^a/i,
    pm: /^pm/i,
    midnight: /^tengah m/i,
    noon: /^tengah h/i,
    morning: /pagi/i,
    afternoon: /siang/i,
    evening: /sore/i,
    night: /malam/i
  }
};
const match$J = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$J,
    parsePattern: parseOrdinalNumberPattern$J,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$J,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$J,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$J,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$J,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$J,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$J,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$J,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$J,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$J,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$J,
    defaultParseWidth: "any"
  })
};
const id = {
  code: "id",
  formatDistance: formatDistance$J,
  formatLong: formatLong$K,
  formatRelative: formatRelative$J,
  localize: localize$J,
  match: match$J,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$I = {
  lessThanXSeconds: {
    one: "minna en 1 seknda",
    other: "minna en {{count}} sekndur"
  },
  xSeconds: {
    one: "1 seknda",
    other: "{{count}} sekndur"
  },
  halfAMinute: "hlf mnta",
  lessThanXMinutes: {
    one: "minna en 1 mnta",
    other: "minna en {{count}} mntur"
  },
  xMinutes: {
    one: "1 mnta",
    other: "{{count}} mntur"
  },
  aboutXHours: {
    one: "u..b. 1 klukkustund",
    other: "u..b. {{count}} klukkustundir"
  },
  xHours: {
    one: "1 klukkustund",
    other: "{{count}} klukkustundir"
  },
  xDays: {
    one: "1 dagur",
    other: "{{count}} dagar"
  },
  aboutXWeeks: {
    one: "um viku",
    other: "um {{count}} vikur"
  },
  xWeeks: {
    one: "1 viku",
    other: "{{count}} vikur"
  },
  aboutXMonths: {
    one: "u..b. 1 mnuur",
    other: "u..b. {{count}} mnuir"
  },
  xMonths: {
    one: "1 mnuur",
    other: "{{count}} mnuir"
  },
  aboutXYears: {
    one: "u..b. 1 r",
    other: "u..b. {{count}} r"
  },
  xYears: {
    one: "1 r",
    other: "{{count}} r"
  },
  overXYears: {
    one: "meira en 1 r",
    other: "meira en {{count}} r"
  },
  almostXYears: {
    one: "nstum 1 r",
    other: "nstum {{count}} r"
  }
};
const formatDistance$I = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$I[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return " " + result;
    } else {
      return result + " san";
    }
  }
  return result;
};
const dateFormats$J = {
  full: "EEEE, do MMMM y",
  long: "do MMMM y",
  medium: "do MMM y",
  short: "d.MM.y"
};
const timeFormats$J = {
  full: "'kl'. HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$J = {
  full: "{{date}} 'kl.' {{time}}",
  long: "{{date}} 'kl.' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$J = {
  date: buildFormatLongFn({
    formats: dateFormats$J,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$J,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$J,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$I = {
  lastWeek: "'sasta' dddd 'kl.' p",
  yesterday: "' gr kl.' p",
  today: "' dag kl.' p",
  tomorrow: "' morgun kl.' p",
  nextWeek: "dddd 'kl.' p",
  other: "P"
};
const formatRelative$I = (token, _date, _baseDate, _options) => formatRelativeLocale$I[token];
const eraValues$I = {
  narrow: ["f.Kr.", "e.Kr."],
  abbreviated: ["f.Kr.", "e.Kr."],
  wide: ["fyrir Krist", "eftir Krist"]
};
const quarterValues$I = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1F", "2F", "3F", "4F"],
  wide: ["1. fjrungur", "2. fjrungur", "3. fjrungur", "4. fjrungur"]
};
const monthValues$I = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "", "S", "", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mars",
    "aprl",
    "ma",
    "jn",
    "jl",
    "gst",
    "sept.",
    "okt.",
    "nv.",
    "des."
  ],
  wide: [
    "janar",
    "febrar",
    "mars",
    "aprl",
    "ma",
    "jn",
    "jl",
    "gst",
    "september",
    "oktber",
    "nvember",
    "desember"
  ]
};
const dayValues$I = {
  narrow: ["S", "M", "", "M", "F", "F", "L"],
  short: ["Su", "M", "r", "Mi", "Fi", "F", "La"],
  abbreviated: ["sun.", "mn.", "ri.", "mi.", "fim.", "fs.", "lau."],
  wide: [
    "sunnudagur",
    "mnudagur",
    "rijudagur",
    "mivikudagur",
    "fimmtudagur",
    "fstudagur",
    "laugardagur"
  ]
};
const dayPeriodValues$I = {
  narrow: {
    am: "f",
    pm: "e",
    midnight: "mintti",
    noon: "hdegi",
    morning: "morgunn",
    afternoon: "sdegi",
    evening: "kvld",
    night: "ntt"
  },
  abbreviated: {
    am: "f.h.",
    pm: "e.h.",
    midnight: "mintti",
    noon: "hdegi",
    morning: "morgunn",
    afternoon: "sdegi",
    evening: "kvld",
    night: "ntt"
  },
  wide: {
    am: "fyrir hdegi",
    pm: "eftir hdegi",
    midnight: "mintti",
    noon: "hdegi",
    morning: "morgunn",
    afternoon: "sdegi",
    evening: "kvld",
    night: "ntt"
  }
};
const formattingDayPeriodValues$A = {
  narrow: {
    am: "f",
    pm: "e",
    midnight: " mintti",
    noon: " hdegi",
    morning: "a morgni",
    afternoon: "sdegis",
    evening: "um kvld",
    night: "um ntt"
  },
  abbreviated: {
    am: "f.h.",
    pm: "e.h.",
    midnight: " mintti",
    noon: " hdegi",
    morning: "a morgni",
    afternoon: "sdegis",
    evening: "um kvld",
    night: "um ntt"
  },
  wide: {
    am: "fyrir hdegi",
    pm: "eftir hdegi",
    midnight: " mintti",
    noon: " hdegi",
    morning: "a morgni",
    afternoon: "sdegis",
    evening: "um kvld",
    night: "um ntt"
  }
};
const ordinalNumber$I = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$I = {
  ordinalNumber: ordinalNumber$I,
  era: buildLocalizeFn({
    values: eraValues$I,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$I,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$I,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$I,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$I,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$A,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$I = /^(\d+)(\.)?/i;
const parseOrdinalNumberPattern$I = /\d+(\.)?/i;
const matchEraPatterns$I = {
  narrow: /^(f\.Kr\.|e\.Kr\.)/i,
  abbreviated: /^(f\.Kr\.|e\.Kr\.)/i,
  wide: /^(fyrir Krist|eftir Krist)/i
};
const parseEraPatterns$I = {
  any: [/^(f\.Kr\.)/i, /^(e\.Kr\.)/i]
};
const matchQuarterPatterns$I = {
  narrow: /^[1234]\.?/i,
  abbreviated: /^q[1234]\.?/i,
  wide: /^[1234]\.? fjrungur/i
};
const parseQuarterPatterns$I = {
  any: [/1\.?/i, /2\.?/i, /3\.?/i, /4\.?/i]
};
const matchMonthPatterns$I = {
  narrow: /^[jfmsnd]/i,
  abbreviated: /^(jan\.|feb\.|mars\.|aprl\.|ma|jn|jl|gust|sep\.|oct\.|nov\.|dec\.)/i,
  wide: /^(januar|febrar|mars|aprl|ma|jn|jl|gust|september|oktber|nvember|desember)/i
};
const parseMonthPatterns$I = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^/i,
    /^s/i,
    /^/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^ma/i,
    /^jn/i,
    /^jl/i,
    /^u/i,
    /^s/i,
    /^/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$I = {
  narrow: /^[smtwf]/i,
  short: /^(su|m|r|mi|fi|f|la)/i,
  abbreviated: /^(sun|mn|ri|mi|fim|fs|lau)\.?/i,
  wide: /^(sunnudagur|mnudagur|rijudagur|mivikudagur|fimmtudagur|fstudagur|laugardagur)/i
};
const parseDayPatterns$I = {
  narrow: [/^s/i, /^m/i, /^/i, /^m/i, /^f/i, /^f/i, /^l/i],
  any: [/^su/i, /^m/i, /^r/i, /^mi/i, /^fi/i, /^f/i, /^la/i]
};
const matchDayPeriodPatterns$I = {
  narrow: /^(f|e|sdegis|(|a|um) (morgni|kvld|ntt|mintti))/i,
  any: /^(fyrir hdegi|eftir hdegi|[ef]\.?h\.?|sdegis|morgunn|(|a|um) (morgni|kvld|ntt|mintti))/i
};
const parseDayPeriodPatterns$I = {
  any: {
    am: /^f/i,
    pm: /^e/i,
    midnight: /^mi/i,
    noon: /^h/i,
    morning: /morgunn/i,
    afternoon: /sdegi/i,
    evening: /kvld/i,
    night: /ntt/i
  }
};
const match$I = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$I,
    parsePattern: parseOrdinalNumberPattern$I,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$I,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$I,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$I,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$I,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$I,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$I,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$I,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$I,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$I,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$I,
    defaultParseWidth: "any"
  })
};
const is$2 = {
  code: "is",
  formatDistance: formatDistance$I,
  formatLong: formatLong$J,
  formatRelative: formatRelative$I,
  localize: localize$I,
  match: match$I,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$H = {
  lessThanXSeconds: {
    one: "meno di un secondo",
    other: "meno di {{count}} secondi"
  },
  xSeconds: {
    one: "un secondo",
    other: "{{count}} secondi"
  },
  halfAMinute: "alcuni secondi",
  lessThanXMinutes: {
    one: "meno di un minuto",
    other: "meno di {{count}} minuti"
  },
  xMinutes: {
    one: "un minuto",
    other: "{{count}} minuti"
  },
  aboutXHours: {
    one: "circa un'ora",
    other: "circa {{count}} ore"
  },
  xHours: {
    one: "un'ora",
    other: "{{count}} ore"
  },
  xDays: {
    one: "un giorno",
    other: "{{count}} giorni"
  },
  aboutXWeeks: {
    one: "circa una settimana",
    other: "circa {{count}} settimane"
  },
  xWeeks: {
    one: "una settimana",
    other: "{{count}} settimane"
  },
  aboutXMonths: {
    one: "circa un mese",
    other: "circa {{count}} mesi"
  },
  xMonths: {
    one: "un mese",
    other: "{{count}} mesi"
  },
  aboutXYears: {
    one: "circa un anno",
    other: "circa {{count}} anni"
  },
  xYears: {
    one: "un anno",
    other: "{{count}} anni"
  },
  overXYears: {
    one: "pi di un anno",
    other: "pi di {{count}} anni"
  },
  almostXYears: {
    one: "quasi un anno",
    other: "quasi {{count}} anni"
  }
};
const formatDistance$H = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$H[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "tra " + result;
    } else {
      return result + " fa";
    }
  }
  return result;
};
const dateFormats$I = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd/MM/y"
};
const timeFormats$I = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$I = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$I = {
  date: buildFormatLongFn({
    formats: dateFormats$I,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$I,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$I,
    defaultWidth: "full"
  })
};
const weekdays$2 = [
  "domenica",
  "luned",
  "marted",
  "mercoled",
  "gioved",
  "venerd",
  "sabato"
];
function lastWeek$5(day) {
  switch (day) {
    case 0:
      return "'domenica scorsa alle' p";
    default:
      return "'" + weekdays$2[day] + " scorso alle' p";
  }
}
function thisWeek$5(day) {
  return "'" + weekdays$2[day] + " alle' p";
}
function nextWeek$5(day) {
  switch (day) {
    case 0:
      return "'domenica prossima alle' p";
    default:
      return "'" + weekdays$2[day] + " prossimo alle' p";
  }
}
const formatRelativeLocale$H = {
  lastWeek: (date2, baseDate, options) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options)) {
      return thisWeek$5(day);
    } else {
      return lastWeek$5(day);
    }
  },
  yesterday: "'ieri alle' p",
  today: "'oggi alle' p",
  tomorrow: "'domani alle' p",
  nextWeek: (date2, baseDate, options) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options)) {
      return thisWeek$5(day);
    } else {
      return nextWeek$5(day);
    }
  },
  other: "P"
};
const formatRelative$H = (token, date2, baseDate, options) => {
  const format2 = formatRelativeLocale$H[token];
  if (typeof format2 === "function") {
    return format2(date2, baseDate, options);
  }
  return format2;
};
const eraValues$H = {
  narrow: ["aC", "dC"],
  abbreviated: ["a.C.", "d.C."],
  wide: ["avanti Cristo", "dopo Cristo"]
};
const quarterValues$H = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1 trimestre", "2 trimestre", "3 trimestre", "4 trimestre"]
};
const monthValues$H = {
  narrow: ["G", "F", "M", "A", "M", "G", "L", "A", "S", "O", "N", "D"],
  abbreviated: [
    "gen",
    "feb",
    "mar",
    "apr",
    "mag",
    "giu",
    "lug",
    "ago",
    "set",
    "ott",
    "nov",
    "dic"
  ],
  wide: [
    "gennaio",
    "febbraio",
    "marzo",
    "aprile",
    "maggio",
    "giugno",
    "luglio",
    "agosto",
    "settembre",
    "ottobre",
    "novembre",
    "dicembre"
  ]
};
const dayValues$H = {
  narrow: ["D", "L", "M", "M", "G", "V", "S"],
  short: ["dom", "lun", "mar", "mer", "gio", "ven", "sab"],
  abbreviated: ["dom", "lun", "mar", "mer", "gio", "ven", "sab"],
  wide: [
    "domenica",
    "luned",
    "marted",
    "mercoled",
    "gioved",
    "venerd",
    "sabato"
  ]
};
const dayPeriodValues$H = {
  narrow: {
    am: "m.",
    pm: "p.",
    midnight: "mezzanotte",
    noon: "mezzogiorno",
    morning: "mattina",
    afternoon: "pomeriggio",
    evening: "sera",
    night: "notte"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "mezzanotte",
    noon: "mezzogiorno",
    morning: "mattina",
    afternoon: "pomeriggio",
    evening: "sera",
    night: "notte"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "mezzanotte",
    noon: "mezzogiorno",
    morning: "mattina",
    afternoon: "pomeriggio",
    evening: "sera",
    night: "notte"
  }
};
const formattingDayPeriodValues$z = {
  narrow: {
    am: "m.",
    pm: "p.",
    midnight: "mezzanotte",
    noon: "mezzogiorno",
    morning: "di mattina",
    afternoon: "del pomeriggio",
    evening: "di sera",
    night: "di notte"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "mezzanotte",
    noon: "mezzogiorno",
    morning: "di mattina",
    afternoon: "del pomeriggio",
    evening: "di sera",
    night: "di notte"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "mezzanotte",
    noon: "mezzogiorno",
    morning: "di mattina",
    afternoon: "del pomeriggio",
    evening: "di sera",
    night: "di notte"
  }
};
const ordinalNumber$H = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return String(number2);
};
const localize$H = {
  ordinalNumber: ordinalNumber$H,
  era: buildLocalizeFn({
    values: eraValues$H,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$H,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$H,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$H,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$H,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$z,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$H = /^(\d+)()?/i;
const parseOrdinalNumberPattern$H = /\d+/i;
const matchEraPatterns$H = {
  narrow: /^(aC|dC)/i,
  abbreviated: /^(a\.?\s?C\.?|a\.?\s?e\.?\s?v\.?|d\.?\s?C\.?|e\.?\s?v\.?)/i,
  wide: /^(avanti Cristo|avanti Era Volgare|dopo Cristo|Era Volgare)/i
};
const parseEraPatterns$H = {
  any: [/^a/i, /^(d|e)/i]
};
const matchQuarterPatterns$H = {
  narrow: /^[1234]/i,
  abbreviated: /^t[1234]/i,
  wide: /^[1234]()? trimestre/i
};
const parseQuarterPatterns$H = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$H = {
  narrow: /^[gfmalsond]/i,
  abbreviated: /^(gen|feb|mar|apr|mag|giu|lug|ago|set|ott|nov|dic)/i,
  wide: /^(gennaio|febbraio|marzo|aprile|maggio|giugno|luglio|agosto|settembre|ottobre|novembre|dicembre)/i
};
const parseMonthPatterns$H = {
  narrow: [
    /^g/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^g/i,
    /^l/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ge/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^mag/i,
    /^gi/i,
    /^l/i,
    /^ag/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$H = {
  narrow: /^[dlmgvs]/i,
  short: /^(do|lu|ma|me|gi|ve|sa)/i,
  abbreviated: /^(dom|lun|mar|mer|gio|ven|sab)/i,
  wide: /^(domenica|luned[i|]|marted[i|]|mercoled[i|]|gioved[i|]|venerd[i|]|sabato)/i
};
const parseDayPatterns$H = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^g/i, /^v/i, /^s/i],
  any: [/^d/i, /^l/i, /^ma/i, /^me/i, /^g/i, /^v/i, /^s/i]
};
const matchDayPeriodPatterns$H = {
  narrow: /^(a|m\.|p|mezzanotte|mezzogiorno|(di|del) (mattina|pomeriggio|sera|notte))/i,
  any: /^([ap]\.?\s?m\.?|mezzanotte|mezzogiorno|(di|del) (mattina|pomeriggio|sera|notte))/i
};
const parseDayPeriodPatterns$H = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mezza/i,
    noon: /^mezzo/i,
    morning: /mattina/i,
    afternoon: /pomeriggio/i,
    evening: /sera/i,
    night: /notte/i
  }
};
const match$H = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$H,
    parsePattern: parseOrdinalNumberPattern$H,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$H,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$H,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$H,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$H,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$H,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$H,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$H,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$H,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$H,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$H,
    defaultParseWidth: "any"
  })
};
const it = {
  code: "it",
  formatDistance: formatDistance$H,
  formatLong: formatLong$I,
  formatRelative: formatRelative$H,
  localize: localize$H,
  match: match$H,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const dateFormats$H = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd.MM.y"
};
const timeFormats$H = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$H = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$H = {
  date: buildFormatLongFn({
    formats: dateFormats$H,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$H,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$H,
    defaultWidth: "full"
  })
};
const itCH = {
  code: "it-CH",
  formatDistance: formatDistance$H,
  formatLong: formatLong$H,
  formatRelative: formatRelative$H,
  localize: localize$H,
  match: match$H,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$G = {
  lessThanXSeconds: {
    one: "1",
    other: "{{count}}",
    oneWithSuffix: "1",
    otherWithSuffix: "{{count}}"
  },
  xSeconds: {
    one: "1",
    other: "{{count}}"
  },
  halfAMinute: "30",
  lessThanXMinutes: {
    one: "1",
    other: "{{count}}",
    oneWithSuffix: "1",
    otherWithSuffix: "{{count}}"
  },
  xMinutes: {
    one: "1",
    other: "{{count}}"
  },
  aboutXHours: {
    one: "1",
    other: "{{count}}"
  },
  xHours: {
    one: "1",
    other: "{{count}}"
  },
  xDays: {
    one: "1",
    other: "{{count}}"
  },
  aboutXWeeks: {
    one: "1",
    other: "{{count}}"
  },
  xWeeks: {
    one: "1",
    other: "{{count}}"
  },
  aboutXMonths: {
    one: "1",
    other: "{{count}}"
  },
  xMonths: {
    one: "1",
    other: "{{count}}"
  },
  aboutXYears: {
    one: "1",
    other: "{{count}}"
  },
  xYears: {
    one: "1",
    other: "{{count}}"
  },
  overXYears: {
    one: "1",
    other: "{{count}}"
  },
  almostXYears: {
    one: "1",
    other: "{{count}}"
  }
};
const formatDistance$G = (token, count, options) => {
  options = options || {};
  let result;
  const tokenValue = formatDistanceLocale$G[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    if (options.addSuffix && tokenValue.oneWithSuffix) {
      result = tokenValue.oneWithSuffix;
    } else {
      result = tokenValue.one;
    }
  } else {
    if (options.addSuffix && tokenValue.otherWithSuffix) {
      result = tokenValue.otherWithSuffix.replace("{{count}}", String(count));
    } else {
      result = tokenValue.other.replace("{{count}}", String(count));
    }
  }
  if (options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "";
    } else {
      return result + "";
    }
  }
  return result;
};
const dateFormats$G = {
  full: "yMdEEEE",
  long: "yMd",
  medium: "y/MM/dd",
  short: "y/MM/dd"
};
const timeFormats$G = {
  full: "Hmmss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
const dateTimeFormats$G = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$G = {
  date: buildFormatLongFn({
    formats: dateFormats$G,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$G,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$G,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$G = {
  lastWeek: "eeeep",
  yesterday: "p",
  today: "p",
  tomorrow: "p",
  nextWeek: "eeeep",
  other: "P"
};
const formatRelative$G = (token, _date, _baseDate, _options) => {
  return formatRelativeLocale$G[token];
};
const eraValues$G = {
  narrow: ["BC", "AC"],
  abbreviated: ["", ""],
  wide: ["", ""]
};
const quarterValues$G = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1", "2", "3", "4"]
};
const monthValues$G = {
  narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
  abbreviated: [
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "10",
    "11",
    "12"
  ],
  wide: [
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "10",
    "11",
    "12"
  ]
};
const dayValues$G = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: ["", "", "", "", "", "", ""]
};
const dayPeriodValues$G = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$y = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$G = (dirtyNumber, options) => {
  const number2 = Number(dirtyNumber);
  const unit = String(options?.unit);
  switch (unit) {
    case "year":
      return `${number2}`;
    case "quarter":
      return `${number2}`;
    case "month":
      return `${number2}`;
    case "week":
      return `${number2}`;
    case "date":
      return `${number2}`;
    case "hour":
      return `${number2}`;
    case "minute":
      return `${number2}`;
    case "second":
      return `${number2}`;
    default:
      return `${number2}`;
  }
};
const localize$G = {
  ordinalNumber: ordinalNumber$G,
  era: buildLocalizeFn({
    values: eraValues$G,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$G,
    defaultWidth: "wide",
    argumentCallback: (quarter) => Number(quarter) - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$G,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$G,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$G,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$y,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$G = /^?\d+(|||||||)?/i;
const parseOrdinalNumberPattern$G = /\d+/i;
const matchEraPatterns$G = {
  narrow: /^(B\.?C\.?|A\.?D\.?)/i,
  abbreviated: /^([]|)/i,
  wide: /^([]|)/i
};
const parseEraPatterns$G = {
  narrow: [/^B/i, /^A/i],
  any: [/^()/i, /^(|)/i]
};
const matchQuarterPatterns$G = {
  narrow: /^[1234]/i,
  abbreviated: /^Q[1234]/i,
  wide: /^[1234]/i
};
const parseQuarterPatterns$G = {
  any: [/(1||)/i, /(2||)/i, /(3||)/i, /(4||)/i]
};
const matchMonthPatterns$G = {
  narrow: /^([123456789]|1[012])/,
  abbreviated: /^([123456789]|1[012])/i,
  wide: /^([123456789]|1[012])/i
};
const parseMonthPatterns$G = {
  any: [
    /^1\D/,
    /^2/,
    /^3/,
    /^4/,
    /^5/,
    /^6/,
    /^7/,
    /^8/,
    /^9/,
    /^10/,
    /^11/,
    /^12/
  ]
};
const matchDayPatterns$G = {
  narrow: /^[]/,
  short: /^[]/,
  abbreviated: /^[]/,
  wide: /^[]/
};
const parseDayPatterns$G = {
  any: [/^/, /^/, /^/, /^/, /^/, /^/, /^/]
};
const matchDayPeriodPatterns$G = {
  any: /^(AM|PM|||||||)/i
};
const parseDayPeriodPatterns$G = {
  any: {
    am: /^(A|)/i,
    pm: /^(P|)/i,
    midnight: /^|/i,
    noon: /^/i,
    morning: /^/i,
    afternoon: /^/i,
    evening: /^/i,
    night: /^/i
  }
};
const match$G = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$G,
    parsePattern: parseOrdinalNumberPattern$G,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$G,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$G,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$G,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$G,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$G,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$G,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$G,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$G,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$G,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$G,
    defaultParseWidth: "any"
  })
};
const ja = {
  code: "ja",
  formatDistance: formatDistance$G,
  formatLong: formatLong$G,
  formatRelative: formatRelative$G,
  localize: localize$G,
  match: match$G,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$F = {
  lessThanXSeconds: {
    one: "1",
    other: "{{count}}",
    oneWithSuffix: "1",
    otherWithSuffix: "{{count}}"
  },
  xSeconds: {
    one: "1",
    other: "{{count}}"
  },
  halfAMinute: "30",
  lessThanXMinutes: {
    one: "1",
    other: "{{count}}",
    oneWithSuffix: "1",
    otherWithSuffix: "{{count}}"
  },
  xMinutes: {
    one: "1",
    other: "{{count}}"
  },
  aboutXHours: {
    one: "1",
    other: "{{count}}"
  },
  xHours: {
    one: "1",
    other: "{{count}}"
  },
  xDays: {
    one: "1",
    other: "{{count}}"
  },
  aboutXWeeks: {
    one: "1",
    other: "{{count}}"
  },
  xWeeks: {
    one: "1",
    other: "{{count}}"
  },
  aboutXMonths: {
    one: "1",
    other: "{{count}}"
  },
  xMonths: {
    one: "1",
    other: "{{count}}"
  },
  aboutXYears: {
    one: "1",
    other: "{{count}}"
  },
  xYears: {
    one: "1",
    other: "{{count}}"
  },
  overXYears: {
    one: "1",
    other: "{{count}}"
  },
  almostXYears: {
    one: "1",
    other: "{{count}}"
  }
};
const formatDistance$F = (token, count, options) => {
  options = options || {};
  let result;
  const tokenValue = formatDistanceLocale$F[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    if (options.addSuffix && tokenValue.oneWithSuffix) {
      result = tokenValue.oneWithSuffix;
    } else {
      result = tokenValue.one;
    }
  } else {
    if (options.addSuffix && tokenValue.otherWithSuffix) {
      result = tokenValue.otherWithSuffix.replace("{{count}}", String(count));
    } else {
      result = tokenValue.other.replace("{{count}}", String(count));
    }
  }
  if (options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "";
    } else {
      return result + "";
    }
  }
  return result;
};
const dateFormats$F = {
  full: "yMdEEEE",
  long: "yMd",
  medium: "y/MM/dd",
  short: "y/MM/dd"
};
const timeFormats$F = {
  full: "Hmmss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
const dateTimeFormats$F = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$F = {
  date: buildFormatLongFn({
    formats: dateFormats$F,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$F,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$F,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$F = {
  lastWeek: "eeeep",
  yesterday: "p",
  today: "p",
  tomorrow: "p",
  nextWeek: "eeeep",
  other: "P"
};
const formatRelative$F = (token, _date, _baseDate, _options) => {
  return formatRelativeLocale$F[token];
};
const eraValues$F = {
  narrow: ["BC", "AC"],
  abbreviated: ["", ""],
  wide: ["", ""]
};
const quarterValues$F = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1", "2", "3", "4"]
};
const monthValues$F = {
  narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
  abbreviated: [
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "10",
    "11",
    "12"
  ],
  wide: [
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "10",
    "11",
    "12"
  ]
};
const dayValues$F = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$F = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$x = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$F = (dirtyNumber, options) => {
  const number2 = Number(dirtyNumber);
  const unit = String(options?.unit);
  switch (unit) {
    case "year":
      return `${number2}`;
    case "quarter":
      return `${number2}`;
    case "month":
      return `${number2}`;
    case "week":
      return `${number2}`;
    case "date":
      return `${number2}`;
    case "hour":
      return `${number2}`;
    case "minute":
      return `${number2}`;
    case "second":
      return `${number2}`;
    default:
      return `${number2}`;
  }
};
const localize$F = {
  ordinalNumber: ordinalNumber$F,
  era: buildLocalizeFn({
    values: eraValues$F,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$F,
    defaultWidth: "wide",
    argumentCallback: (quarter) => Number(quarter) - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$F,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$F,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$F,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$x,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$F = /^??\d+(|||||||)?/i;
const parseOrdinalNumberPattern$F = /\d+/i;
const matchEraPatterns$F = {
  narrow: /^(B\.?C\.?|A\.?D\.?)/i,
  abbreviated: /^([]|)/i,
  wide: /^([]|)/i
};
const parseEraPatterns$F = {
  narrow: [/^B/i, /^A/i],
  any: [/^()/i, /^(|)/i]
};
const matchQuarterPatterns$F = {
  narrow: /^[1234]/i,
  abbreviated: /^Q[1234]/i,
  wide: /^[1234]/i
};
const parseQuarterPatterns$F = {
  any: [/(1||)/i, /(2||)/i, /(3||)/i, /(4||)/i]
};
const matchMonthPatterns$F = {
  narrow: /^([123456789]|1[012])/,
  abbreviated: /^([123456789]|1[012])/i,
  wide: /^([123456789]|1[012])/i
};
const parseMonthPatterns$F = {
  any: [
    /^1\D/,
    /^2/,
    /^3/,
    /^4/,
    /^5/,
    /^6/,
    /^7/,
    /^8/,
    /^9/,
    /^10/,
    /^11/,
    /^12/
  ]
};
const matchDayPatterns$F = {
  narrow: /^(||||||)/,
  short: /^(||||||)/,
  abbreviated: /^(||||||)/,
  wide: /^(||||||)/
};
const parseDayPatterns$F = {
  any: [/^/, /^/, /^/, /^/, /^/, /^/, /^/]
};
const matchDayPeriodPatterns$F = {
  any: /^(AM|PM|||||||)/i
};
const parseDayPeriodPatterns$F = {
  any: {
    am: /^(A|)/i,
    pm: /^(P|)/i,
    midnight: /^|/i,
    noon: /^/i,
    morning: /^/i,
    afternoon: /^/i,
    evening: /^/i,
    night: /^/i
  }
};
const match$F = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$F,
    parsePattern: parseOrdinalNumberPattern$F,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$F,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$F,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$F,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$F,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$F,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$F,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$F,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$F,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$F,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$F,
    defaultParseWidth: "any"
  })
};
const jaHira = {
  code: "ja-Hira",
  formatDistance: formatDistance$F,
  formatLong: formatLong$F,
  formatRelative: formatRelative$F,
  localize: localize$F,
  match: match$F,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$E = {
  lessThanXSeconds: {
    past: "{{count}}    ",
    present: "{{count}}  ",
    future: "{{count}}  "
  },
  xSeconds: {
    past: "{{count}}  ",
    present: "{{count}} ",
    future: "{{count}} "
  },
  halfAMinute: {
    past: "  ",
    present: " ",
    future: " "
  },
  lessThanXMinutes: {
    past: "{{count}}    ",
    present: "{{count}}  ",
    future: "{{count}}  "
  },
  xMinutes: {
    past: "{{count}}  ",
    present: "{{count}} ",
    future: "{{count}} "
  },
  aboutXHours: {
    past: " {{count}}  ",
    present: " {{count}} ",
    future: " {{count}} "
  },
  xHours: {
    past: "{{count}}  ",
    present: "{{count}} ",
    future: "{{count}} "
  },
  xDays: {
    past: "{{count}}  ",
    present: "{{count}} ",
    future: "{{count}} "
  },
  aboutXWeeks: {
    past: " {{count}}  ",
    present: " {{count}} ",
    future: " {{count}} "
  },
  xWeeks: {
    past: "{{count}}  ",
    present: "{{count}} ",
    future: "{{count}} "
  },
  aboutXMonths: {
    past: " {{count}}  ",
    present: " {{count}} ",
    future: " {{count}} "
  },
  xMonths: {
    past: "{{count}}  ",
    present: "{{count}} ",
    future: "{{count}} "
  },
  aboutXYears: {
    past: " {{count}}  ",
    present: " {{count}} ",
    future: " {{count}} "
  },
  xYears: {
    past: "{{count}}  ",
    present: "{{count}} ",
    future: "{{count}} "
  },
  overXYears: {
    past: "{{count}}    ",
    present: "{{count}}  ",
    future: "{{count}}    "
  },
  almostXYears: {
    past: " {{count}}  ",
    present: " {{count}} ",
    future: " {{count}} "
  }
};
const formatDistance$E = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$E[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (options?.addSuffix && options.comparison && options.comparison > 0) {
    result = tokenValue.future.replace("{{count}}", String(count));
  } else if (options?.addSuffix) {
    result = tokenValue.past.replace("{{count}}", String(count));
  } else {
    result = tokenValue.present.replace("{{count}}", String(count));
  }
  return result;
};
const dateFormats$E = {
  full: "EEEE, do MMMM, y",
  long: "do, MMMM, y",
  medium: "d, MMM, y",
  short: "dd/MM/yyyy"
};
const timeFormats$E = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$E = {
  full: "{{date}} {{time}}'-'",
  long: "{{date}} {{time}}'-'",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$E = {
  date: buildFormatLongFn({
    formats: dateFormats$E,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$E,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$E,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$E = {
  lastWeek: "'' eeee p'-'",
  yesterday: "'' p'-'",
  today: "'' p'-'",
  tomorrow: "'' p'-'",
  nextWeek: "'' eeee p'-'",
  other: "P"
};
const formatRelative$E = (token, _date, _baseDate, _options) => formatRelativeLocale$E[token];
const eraValues$E = {
  narrow: [".-", "."],
  abbreviated: [".-", "."],
  wide: [" ", " "]
};
const quarterValues$E = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1- ", "2- ", "3- ", "4- "],
  wide: ["1- ", "2- ", "3- ", "4- "]
};
const monthValues$E = {
  narrow: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$E = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$E = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$w = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$E = (dirtyNumber) => {
  const number2 = Number(dirtyNumber);
  if (number2 === 1) {
    return number2 + "-";
  }
  return number2 + "-";
};
const localize$E = {
  ordinalNumber: ordinalNumber$E,
  era: buildLocalizeFn({
    values: eraValues$E,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$E,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$E,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$E,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$E,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$w,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$E = /^(\d+)(-|-)?/i;
const parseOrdinalNumberPattern$E = /\d+/i;
const matchEraPatterns$E = {
  narrow: /^(?\.)/i,
  abbreviated: /^(?\.)/i,
  wide: /^( || |)/i
};
const parseEraPatterns$E = {
  any: [
    /^( |)/i,
    /^( |)/i
  ]
};
const matchQuarterPatterns$E = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]-(|)? /i,
  wide: /^[1234]-(|)? /i
};
const parseQuarterPatterns$E = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$E = {
  any: /^(|||||||||||)/i
};
const parseMonthPatterns$E = {
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^?/i,
    /^?/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$E = {
  narrow: /^(||||||)/i,
  short: /^(||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$E = {
  any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$E = {
  any: /^([ap]\.?\s?m\.?||)/i
};
const parseDayPeriodPatterns$E = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^/i,
    noon: /^/i,
    morning: /^/i,
    afternoon: //i,
    evening: //i,
    night: //i
  }
};
const match$E = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$E,
    parsePattern: parseOrdinalNumberPattern$E,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$E,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$E,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$E,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$E,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$E,
    defaultMatchWidth: "any",
    parsePatterns: parseMonthPatterns$E,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$E,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$E,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$E,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$E,
    defaultParseWidth: "any"
  })
};
const ka = {
  code: "ka",
  formatDistance: formatDistance$E,
  formatLong: formatLong$E,
  formatRelative: formatRelative$E,
  localize: localize$E,
  match: match$E,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$D = {
  lessThanXSeconds: {
    regular: {
      one: "1  ",
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    },
    future: {
      one: "  ",
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    }
  },
  xSeconds: {
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    },
    past: {
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    },
    future: {
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    }
  },
  halfAMinute: (options) => {
    if (options?.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        return "  ";
      } else {
        return "  ";
      }
    }
    return " ";
  },
  lessThanXMinutes: {
    regular: {
      one: "1  ",
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    },
    future: {
      one: "  ",
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    }
  },
  xMinutes: {
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    },
    past: {
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    },
    future: {
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    }
  },
  aboutXHours: {
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: " {{count}}  ",
      singularGenitive: " {{count}}  ",
      pluralGenitive: " {{count}}  "
    }
  },
  xHours: {
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    }
  },
  xDays: {
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    },
    future: {
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    }
  },
  aboutXWeeks: {
    type: "weeks",
    one: " 1 ",
    other: " {{count}} "
  },
  xWeeks: {
    type: "weeks",
    one: "1 ",
    other: "{{count}} "
  },
  aboutXMonths: {
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: " {{count}}  ",
      singularGenitive: " {{count}}  ",
      pluralGenitive: " {{count}}  "
    }
  },
  xMonths: {
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    }
  },
  aboutXYears: {
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: " {{count}}  ",
      singularGenitive: " {{count}}  ",
      pluralGenitive: " {{count}}  "
    }
  },
  xYears: {
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    },
    future: {
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    }
  },
  overXYears: {
    regular: {
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    },
    future: {
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    }
  },
  almostXYears: {
    regular: {
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    },
    future: {
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    }
  }
};
function declension$4(scheme2, count) {
  if (scheme2.one && count === 1) return scheme2.one;
  const rem10 = count % 10;
  const rem100 = count % 100;
  if (rem10 === 1 && rem100 !== 11) {
    return scheme2.singularNominative.replace("{{count}}", String(count));
  } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
    return scheme2.singularGenitive.replace("{{count}}", String(count));
  } else {
    return scheme2.pluralGenitive.replace("{{count}}", String(count));
  }
}
const formatDistance$D = (token, count, options) => {
  const tokenValue = formatDistanceLocale$D[token];
  if (typeof tokenValue === "function") return tokenValue(options);
  if (tokenValue.type === "weeks") {
    return count === 1 ? tokenValue.one : tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      if (tokenValue.future) {
        return declension$4(tokenValue.future, count);
      } else {
        return declension$4(tokenValue.regular, count) + " ";
      }
    } else {
      if (tokenValue.past) {
        return declension$4(tokenValue.past, count);
      } else {
        return declension$4(tokenValue.regular, count) + " ";
      }
    }
  } else {
    return declension$4(tokenValue.regular, count);
  }
};
const dateFormats$D = {
  full: "EEEE, do MMMM y '.'",
  long: "do MMMM y '.'",
  medium: "d MMM y '.'",
  short: "dd.MM.yyyy"
};
const timeFormats$D = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
const dateTimeFormats$D = {
  any: "{{date}}, {{time}}"
};
const formatLong$D = {
  date: buildFormatLongFn({
    formats: dateFormats$D,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$D,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$D,
    defaultWidth: "any"
  })
};
const accusativeWeekdays$3 = [
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];
function lastWeek$4(day) {
  const weekday = accusativeWeekdays$3[day];
  return "' " + weekday + " ' p'-'";
}
function thisWeek$4(day) {
  const weekday = accusativeWeekdays$3[day];
  return "'" + weekday + " ' p'-'";
}
function nextWeek$4(day) {
  const weekday = accusativeWeekdays$3[day];
  return "' " + weekday + " ' p'-'";
}
const formatRelativeLocale$D = {
  lastWeek: (date2, baseDate, options) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options)) {
      return thisWeek$4(day);
    } else {
      return lastWeek$4(day);
    }
  },
  yesterday: "' ' p'-'",
  today: "' ' p'-'",
  tomorrow: "' ' p'-'",
  nextWeek: (date2, baseDate, options) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options)) {
      return thisWeek$4(day);
    } else {
      return nextWeek$4(day);
    }
  },
  other: "P"
};
const formatRelative$D = (token, date2, baseDate, options) => {
  const format2 = formatRelativeLocale$D[token];
  if (typeof format2 === "function") {
    return format2(date2, baseDate, options);
  }
  return format2;
};
const eraValues$D = {
  narrow: ["...", ".."],
  abbreviated: ["...", ".."],
  wide: ["  ", " "]
};
const quarterValues$D = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1- .", "2- .", "3- .", "4- ."],
  wide: ["1- ", "2- ", "3- ", "4- "]
};
const monthValues$D = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const formattingMonthValues$9 = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$D = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$D = {
  narrow: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$v = {
  narrow: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const suffixes = {
  0: "-",
  1: "-",
  2: "-",
  3: "-",
  4: "-",
  5: "-",
  6: "-",
  7: "-",
  8: "-",
  9: "-",
  10: "-",
  20: "-",
  30: "-",
  40: "-",
  50: "-",
  60: "-",
  70: "-",
  80: "-",
  90: "-",
  100: "-"
};
const ordinalNumber$D = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  const mod10 = number2 % 10;
  const b = number2 >= 100 ? 100 : null;
  const suffix = suffixes[number2] || suffixes[mod10] || b && suffixes[b] || "";
  return number2 + suffix;
};
const localize$D = {
  ordinalNumber: ordinalNumber$D,
  era: buildLocalizeFn({
    values: eraValues$D,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$D,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$D,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$9,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$D,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$D,
    defaultWidth: "any",
    formattingValues: formattingDayPeriodValues$v,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$D = /^(\d+)(-?(|))?/i;
const parseOrdinalNumberPattern$D = /\d+/i;
const matchEraPatterns$D = {
  narrow: /^(( )?\.?\s?\.?)/i,
  abbreviated: /^(( )?\.?\s?\.?)/i,
  wide: /^(  | | )/i
};
const parseEraPatterns$D = {
  any: [/^/i, /^/i]
};
const matchQuarterPatterns$D = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?)? .?/i,
  wide: /^[1234](-?)? /i
};
const parseQuarterPatterns$D = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$D = {
  narrow: /^(|||||||||||)/i,
  abbreviated: /^(|||||||||||)/i,
  wide: /^(|||||||||||)/i
};
const parseMonthPatterns$D = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  abbreviated: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$D = {
  narrow: /^(||||||)/i,
  short: /^(||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$D = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  short: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [
    /^[]/i,
    /^[]/i,
    /^e[]/i,
    /^[]/i,
    /^[]/i,
    /^[]/i,
    /^[]/i
  ]
};
const matchDayPeriodPatterns$D = {
  narrow: /^\.?\s?[]\.?| |((|||||||||||)\.?)/i,
  wide: /^\.?\s?[]\.?| |((|||||||||||)\.?)/i,
  any: /^\.?\s?[]\.?| |((|||||||||||)\.?)/i
};
const parseDayPeriodPatterns$D = {
  any: {
    am: /^/i,
    pm: /^/i,
    midnight: /^ /i,
    noon: /^/i,
    morning: //i,
    afternoon: //i,
    evening: //i,
    night: //i
  }
};
const match$D = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$D,
    parsePattern: parseOrdinalNumberPattern$D,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$D,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$D,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$D,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$D,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$D,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$D,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$D,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$D,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$D,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$D,
    defaultParseWidth: "any"
  })
};
const kk = {
  code: "kk",
  formatDistance: formatDistance$D,
  formatLong: formatLong$D,
  formatRelative: formatRelative$D,
  localize: localize$D,
  match: match$D,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$C = {
  lessThanXSeconds: " {{count}} ",
  xSeconds: "{{count}} ",
  halfAMinute: "",
  lessThanXMinutes: " {{count}} ",
  xMinutes: "{{count}} ",
  aboutXHours: " {{count}} ",
  xHours: "{{count}} ",
  xDays: "{{count}} ",
  aboutXWeeks: " {{count}} ",
  xWeeks: "{{count}} ",
  aboutXMonths: " {{count}} ",
  xMonths: "{{count}} ",
  aboutXYears: " {{count}} ",
  xYears: "{{count}} ",
  overXYears: " {{count}} ",
  almostXYears: " {{count}} "
};
const formatDistance$C = (token, count, options) => {
  const tokenValue = formatDistanceLocale$C[token];
  let result = tokenValue;
  if (typeof count === "number") {
    result = result.replace("{{count}}", count.toString());
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return " " + result;
    } else {
      return result + "";
    }
  }
  return result;
};
const dateFormats$C = {
  full: "EEEE do MMMM y",
  long: "do MMMM y",
  medium: "d MMM y",
  short: "dd/MM/yyyy"
};
const timeFormats$C = {
  full: "h:mm:ss a",
  long: "h:mm:ss a",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$C = {
  full: "{{date}} '' {{time}}",
  long: "{{date}} '' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$C = {
  date: buildFormatLongFn({
    formats: dateFormats$C,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$C,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$C,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$C = {
  lastWeek: "''eeee'' p",
  yesterday: "'' p",
  today: "'' p",
  tomorrow: "'' p",
  nextWeek: "''eeee'' p",
  other: "P"
};
const formatRelative$C = (token, _date, _baseDate, _options) => formatRelativeLocale$C[token];
const eraValues$C = {
  narrow: [".", ""],
  abbreviated: [".", "."],
  wide: ["", ""]
};
const quarterValues$C = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: [" 1", " 2", " 3", " 4"]
};
const monthValues$C = {
  narrow: [
    ".",
    ".",
    "",
    ".",
    ".",
    ".",
    ".",
    "",
    "",
    "",
    "",
    ""
  ],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$C = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: ["", "", "", "", "", "", ""]
};
const dayPeriodValues$C = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$u = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$C = (dirtyNumber, _) => {
  const number2 = Number(dirtyNumber);
  return number2.toString();
};
const localize$C = {
  ordinalNumber: ordinalNumber$C,
  era: buildLocalizeFn({
    values: eraValues$C,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$C,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$C,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$C,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$C,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$u,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$C = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$C = /\d+/i;
const matchEraPatterns$C = {
  narrow: /^(\.)?/i,
  abbreviated: /^()?\./i,
  wide: /^(|)/i
};
const parseEraPatterns$C = {
  any: [/^(|)\.?/i, /^()?\.?/i]
};
const matchQuarterPatterns$C = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^()()?\s?[1234]/i
};
const parseQuarterPatterns$C = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$C = {
  narrow: /^(\.|\.||\.|\.|\.|\.|||||)/i,
  abbreviated: /^(|||||||||||)/i,
  wide: /^(|||||||||||)/i
};
const parseMonthPatterns$C = {
  narrow: [
    /^\./i,
    /^\./i,
    /^/i,
    /^\./i,
    /^\./i,
    /^\./i,
    /^\./i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$C = {
  narrow: /^(||||||)/i,
  short: /^(||||||)/i,
  abbreviated: /^(||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$C = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$C = {
  narrow: /^(|||||||)/i,
  any: /^(|||||||)/i
};
const parseDayPeriodPatterns$C = {
  any: {
    am: /^/i,
    pm: /^/i,
    midnight: /^/i,
    noon: /^/i,
    morning: //i,
    afternoon: //i,
    evening: //i,
    night: //i
  }
};
const match$C = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$C,
    parsePattern: parseOrdinalNumberPattern$C,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$C,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$C,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$C,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$C,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$C,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$C,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$C,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$C,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$C,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$C,
    defaultParseWidth: "any"
  })
};
const km = {
  code: "km",
  formatDistance: formatDistance$C,
  formatLong: formatLong$C,
  formatRelative: formatRelative$C,
  localize: localize$C,
  match: match$C,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$B = {
  lessThanXSeconds: {
    one: {
      default: "1  ",
      future: "1  ",
      past: "1  "
    },
    other: {
      default: "{{count}}  ",
      future: "{{count}}  ",
      past: "{{count}}  "
    }
  },
  xSeconds: {
    one: {
      default: "1 ",
      future: "1 ",
      past: "1  "
    },
    other: {
      default: "{{count}} ",
      future: "{{count}} ",
      past: "{{count}}  "
    }
  },
  halfAMinute: {
    other: {
      default: " ",
      future: " ",
      past: "  "
    }
  },
  lessThanXMinutes: {
    one: {
      default: "1  ",
      future: "1  ",
      past: "1  "
    },
    other: {
      default: "{{count}}  ",
      future: "{{count}}  ",
      past: "{{count}}  "
    }
  },
  xMinutes: {
    one: {
      default: "1 ",
      future: "1 ",
      past: "1  "
    },
    other: {
      default: "{{count}} ",
      future: "{{count}} ",
      past: "{{count}}  "
    }
  },
  aboutXHours: {
    one: {
      default: " 1 ",
      future: " 1 ",
      past: " 1  "
    },
    other: {
      default: " {{count}} ",
      future: " {{count}} ",
      past: " {{count}}  "
    }
  },
  xHours: {
    one: {
      default: "1 ",
      future: "1 ",
      past: "1  "
    },
    other: {
      default: "{{count}} ",
      future: "{{count}} ",
      past: "{{count}}  "
    }
  },
  xDays: {
    one: {
      default: "1 ",
      future: "1 ",
      past: "1  "
    },
    other: {
      default: "{{count}} ",
      future: "{{count}} ",
      past: "{{count}}  "
    }
  },
  // TODO
  // aboutXWeeks: {},
  // TODO
  // xWeeks: {},
  aboutXMonths: {
    one: {
      default: " 1 ",
      future: " 1 ",
      past: " 1  "
    },
    other: {
      default: " {{count}} ",
      future: " {{count}} ",
      past: " {{count}}  "
    }
  },
  xMonths: {
    one: {
      default: "1 ",
      future: "1 ",
      past: "1  "
    },
    other: {
      default: "{{count}} ",
      future: "{{count}} ",
      past: "{{count}}  "
    }
  },
  aboutXYears: {
    one: {
      default: " 1 ",
      future: " 1 ",
      past: " 1  "
    },
    other: {
      default: " {{count}} ",
      future: " {{count}} ",
      past: " {{count}}  "
    }
  },
  xYears: {
    one: {
      default: "1 ",
      future: "1 ",
      past: "1  "
    },
    other: {
      default: "{{count}} ",
      future: "{{count}} ",
      past: "{{count}}  "
    }
  },
  overXYears: {
    one: {
      default: "1  ",
      future: "1  ",
      past: "1  "
    },
    other: {
      default: "{{count}}  ",
      future: "{{count}}  ",
      past: "{{count}}  "
    }
  },
  almostXYears: {
    one: {
      default: " 1 ",
      future: " 1 ",
      past: " 1 "
    },
    other: {
      default: " {{count}} ",
      future: " {{count}} ",
      past: " {{count}} "
    }
  }
};
function getResultByTense(parentToken2, options) {
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return parentToken2.future;
    } else {
      return parentToken2.past;
    }
  }
  return parentToken2.default;
}
const formatDistance$B = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$B[token];
  if (tokenValue.one && count === 1) {
    result = getResultByTense(tokenValue.one, options);
  } else {
    result = getResultByTense(tokenValue.other, options);
  }
  return result.replace("{{count}}", String(count));
};
const dateFormats$B = {
  full: "EEEE, MMMM d, y",
  // CLDR 1816
  long: "MMMM d, y",
  // CLDR 1817
  medium: "MMM d, y",
  // CLDR 1818
  short: "d/M/yy"
  // CLDR 1819
};
const timeFormats$B = {
  full: "hh:mm:ss a zzzz",
  // CLDR 1820
  long: "hh:mm:ss a z",
  // CLDR 1821
  medium: "hh:mm:ss a",
  // CLDR 1822
  short: "hh:mm a"
  // CLDR 1823
};
const dateTimeFormats$B = {
  full: "{{date}} {{time}}",
  // CLDR 1824
  long: "{{date}} {{time}}",
  // CLDR 1825
  medium: "{{date}} {{time}}",
  // CLDR 1826
  short: "{{date}} {{time}}"
  // CLDR 1827
};
const formatLong$B = {
  date: buildFormatLongFn({
    formats: dateFormats$B,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$B,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$B,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$B = {
  lastWeek: "'' eeee p ''",
  yesterday: "'' p ''",
  today: "'' p ''",
  tomorrow: "'' p ''",
  nextWeek: "eeee p ''",
  other: "P"
};
const formatRelative$B = (token, _date, _baseDate, _options) => formatRelativeLocale$B[token];
const eraValues$B = {
  narrow: [".", "."],
  abbreviated: [".", "."],
  // CLDR #1618, #1620
  wide: [" ", " "]
  // CLDR #1614, #1616
};
const quarterValues$B = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: [" 1", " 2", " 3", " 4"],
  // CLDR #1630 - #1638
  wide: ["1 ", "2 ", "3 ", "4 "]
  // CLDR #1622 - #1629
};
const monthValues$B = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$B = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$B = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$t = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$B = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "";
};
const localize$B = {
  ordinalNumber: ordinalNumber$B,
  era: buildLocalizeFn({
    values: eraValues$B,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$B,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$B,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$B,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$B,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$t,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$B = /^(\d+)(|)?/i;
const parseOrdinalNumberPattern$B = /\d+/i;
const matchEraPatterns$B = {
  narrow: /^(.|.)/i,
  abbreviated: /^(\.?\s?\.?|\.?\s?\.?|\.?\s?\.?)/i,
  wide: /^( | | )/i
};
const parseEraPatterns$B = {
  any: [/^/i, /^(|)/i]
};
const matchQuarterPatterns$B = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]| [1234]| [1234]/i,
  wide: /^[1234]()? /i
};
const parseQuarterPatterns$B = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$B = {
  narrow: /^(|||||||||||)/i,
  abbreviated: /^(|||||||||||)/i,
  wide: /^(|||||||||||)/i
};
const parseMonthPatterns$B = {
  narrow: [
    /^$/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^$/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$B = {
  narrow: /^(||||||)/i,
  short: /^(||||||)/i,
  abbreviated: /^(||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$B = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$B = {
  narrow: /^(||||||)/i,
  any: /^(||||||)/i
};
const parseDayPeriodPatterns$B = {
  any: {
    am: /^/i,
    pm: /^/i,
    midnight: //i,
    noon: //i,
    morning: //i,
    afternoon: //i,
    evening: //i,
    night: //i
  }
};
const match$B = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$B,
    parsePattern: parseOrdinalNumberPattern$B,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$B,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$B,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$B,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$B,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$B,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$B,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$B,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$B,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$B,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$B,
    defaultParseWidth: "any"
  })
};
const kn = {
  code: "kn",
  formatDistance: formatDistance$B,
  formatLong: formatLong$B,
  formatRelative: formatRelative$B,
  localize: localize$B,
  match: match$B,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$A = {
  lessThanXSeconds: {
    one: "1 ",
    other: "{{count}} "
  },
  xSeconds: {
    one: "1",
    other: "{{count}}"
  },
  halfAMinute: "30",
  lessThanXMinutes: {
    one: "1 ",
    other: "{{count}} "
  },
  xMinutes: {
    one: "1",
    other: "{{count}}"
  },
  aboutXHours: {
    one: " 1",
    other: " {{count}}"
  },
  xHours: {
    one: "1",
    other: "{{count}}"
  },
  xDays: {
    one: "1",
    other: "{{count}}"
  },
  aboutXWeeks: {
    one: " 1",
    other: " {{count}}"
  },
  xWeeks: {
    one: "1",
    other: "{{count}}"
  },
  aboutXMonths: {
    one: " 1",
    other: " {{count}}"
  },
  xMonths: {
    one: "1",
    other: "{{count}}"
  },
  aboutXYears: {
    one: " 1",
    other: " {{count}}"
  },
  xYears: {
    one: "1",
    other: "{{count}}"
  },
  overXYears: {
    one: "1 ",
    other: "{{count}} "
  },
  almostXYears: {
    one: " 1",
    other: " {{count}}"
  }
};
const formatDistance$A = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$A[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + " ";
    } else {
      return result + " ";
    }
  }
  return result;
};
const dateFormats$A = {
  full: "y M d EEEE",
  long: "y M d",
  medium: "y.MM.dd",
  short: "y.MM.dd"
};
const timeFormats$A = {
  full: "a H mm ss zzzz",
  long: "a H:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$A = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$A = {
  date: buildFormatLongFn({
    formats: dateFormats$A,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$A,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$A,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$A = {
  lastWeek: "'' eeee p",
  yesterday: "'' p",
  today: "'' p",
  tomorrow: "'' p",
  nextWeek: "'' eeee p",
  other: "P"
};
const formatRelative$A = (token, _date, _baseDate, _options) => formatRelativeLocale$A[token];
const eraValues$A = {
  narrow: ["BC", "AD"],
  abbreviated: ["BC", "AD"],
  wide: ["", ""]
};
const quarterValues$A = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1", "2", "3", "4"]
};
const monthValues$A = {
  narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
  abbreviated: [
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "10",
    "11",
    "12"
  ],
  wide: [
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "10",
    "11",
    "12"
  ]
};
const dayValues$A = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: ["", "", "", "", "", "", ""]
};
const dayPeriodValues$A = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$s = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$A = (dirtyNumber, options) => {
  const number2 = Number(dirtyNumber);
  const unit = String(options?.unit);
  switch (unit) {
    case "minute":
    case "second":
      return String(number2);
    case "date":
      return number2 + "";
    default:
      return number2 + "";
  }
};
const localize$A = {
  ordinalNumber: ordinalNumber$A,
  era: buildLocalizeFn({
    values: eraValues$A,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$A,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$A,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$A,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$A,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$s,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$A = /^(\d+)(|)?/i;
const parseOrdinalNumberPattern$A = /\d+/i;
const matchEraPatterns$A = {
  narrow: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(|)/i
};
const parseEraPatterns$A = {
  any: [/^(bc|)/i, /^(ad|)/i]
};
const matchQuarterPatterns$A = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234]?/i
};
const parseQuarterPatterns$A = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$A = {
  narrow: /^(1[012]|[123456789])/,
  abbreviated: /^(1[012]|[123456789])/i,
  wide: /^(1[012]|[123456789])/i
};
const parseMonthPatterns$A = {
  any: [
    /^1?$/,
    /^2/,
    /^3/,
    /^4/,
    /^5/,
    /^6/,
    /^7/,
    /^8/,
    /^9/,
    /^10/,
    /^11/,
    /^12/
  ]
};
const matchDayPatterns$A = {
  narrow: /^[]/,
  short: /^[]/,
  abbreviated: /^[]/,
  wide: /^[]/
};
const parseDayPatterns$A = {
  any: [/^/, /^/, /^/, /^/, /^/, /^/, /^/]
};
const matchDayPeriodPatterns$A = {
  any: /^(am|pm|||||||)/i
};
const parseDayPeriodPatterns$A = {
  any: {
    am: /^(am|)/i,
    pm: /^(pm|)/i,
    midnight: /^/i,
    noon: /^/i,
    morning: /^/i,
    afternoon: /^/i,
    evening: /^/i,
    night: /^/i
  }
};
const match$A = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$A,
    parsePattern: parseOrdinalNumberPattern$A,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$A,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$A,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$A,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$A,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$A,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$A,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$A,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$A,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$A,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$A,
    defaultParseWidth: "any"
  })
};
const ko = {
  code: "ko",
  formatDistance: formatDistance$A,
  formatLong: formatLong$A,
  formatRelative: formatRelative$A,
  localize: localize$A,
  match: match$A,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$z = {
  lessThanXSeconds: {
    standalone: {
      one: "manner wi eng Sekonn",
      other: "manner wi {{count}} Sekonnen"
    },
    withPreposition: {
      one: "manner wi enger Sekonn",
      other: "manner wi {{count}} Sekonnen"
    }
  },
  xSeconds: {
    standalone: {
      one: "eng Sekonn",
      other: "{{count}} Sekonnen"
    },
    withPreposition: {
      one: "enger Sekonn",
      other: "{{count}} Sekonnen"
    }
  },
  halfAMinute: {
    standalone: "eng hallef Minutt",
    withPreposition: "enger hallwer Minutt"
  },
  lessThanXMinutes: {
    standalone: {
      one: "manner wi eng Minutt",
      other: "manner wi {{count}} Minutten"
    },
    withPreposition: {
      one: "manner wi enger Minutt",
      other: "manner wi {{count}} Minutten"
    }
  },
  xMinutes: {
    standalone: {
      one: "eng Minutt",
      other: "{{count}} Minutten"
    },
    withPreposition: {
      one: "enger Minutt",
      other: "{{count}} Minutten"
    }
  },
  aboutXHours: {
    standalone: {
      one: "ongefier eng Stonn",
      other: "ongefier {{count}} Stonnen"
    },
    withPreposition: {
      one: "ongefier enger Stonn",
      other: "ongefier {{count}} Stonnen"
    }
  },
  xHours: {
    standalone: {
      one: "eng Stonn",
      other: "{{count}} Stonnen"
    },
    withPreposition: {
      one: "enger Stonn",
      other: "{{count}} Stonnen"
    }
  },
  xDays: {
    standalone: {
      one: "een Dag",
      other: "{{count}} Deeg"
    },
    withPreposition: {
      one: "engem Dag",
      other: "{{count}} Deeg"
    }
  },
  aboutXWeeks: {
    standalone: {
      one: "ongefier eng Woch",
      other: "ongefier {{count}} Wochen"
    },
    withPreposition: {
      one: "ongefier enger Woche",
      other: "ongefier {{count}} Wochen"
    }
  },
  xWeeks: {
    standalone: {
      one: "eng Woch",
      other: "{{count}} Wochen"
    },
    withPreposition: {
      one: "enger Woch",
      other: "{{count}} Wochen"
    }
  },
  aboutXMonths: {
    standalone: {
      one: "ongefier ee Mount",
      other: "ongefier {{count}} Mint"
    },
    withPreposition: {
      one: "ongefier engem Mount",
      other: "ongefier {{count}} Mint"
    }
  },
  xMonths: {
    standalone: {
      one: "ee Mount",
      other: "{{count}} Mint"
    },
    withPreposition: {
      one: "engem Mount",
      other: "{{count}} Mint"
    }
  },
  aboutXYears: {
    standalone: {
      one: "ongefier ee Joer",
      other: "ongefier {{count}} Joer"
    },
    withPreposition: {
      one: "ongefier engem Joer",
      other: "ongefier {{count}} Joer"
    }
  },
  xYears: {
    standalone: {
      one: "ee Joer",
      other: "{{count}} Joer"
    },
    withPreposition: {
      one: "engem Joer",
      other: "{{count}} Joer"
    }
  },
  overXYears: {
    standalone: {
      one: "mi wi ee Joer",
      other: "mi wi {{count}} Joer"
    },
    withPreposition: {
      one: "mi wi engem Joer",
      other: "mi wi {{count}} Joer"
    }
  },
  almostXYears: {
    standalone: {
      one: "bal ee Joer",
      other: "bal {{count}} Joer"
    },
    withPreposition: {
      one: "bal engem Joer",
      other: "bal {{count}} Joer"
    }
  }
};
const EXCEPTION_CONSONANTS = ["d", "h", "n", "t", "z"];
const VOWELS = ["a,", "e", "i", "o", "u"];
const DIGITS_SPOKEN_N_NEEDED = [0, 1, 2, 3, 8, 9];
const FIRST_TWO_DIGITS_SPOKEN_NO_N_NEEDED = [40, 50, 60, 70];
function isFinalNNeeded(nextWords) {
  const firstLetter = nextWords.charAt(0).toLowerCase();
  if (VOWELS.indexOf(firstLetter) != -1 || EXCEPTION_CONSONANTS.indexOf(firstLetter) != -1) {
    return true;
  }
  const firstWord = nextWords.split(" ")[0];
  const number2 = parseInt(firstWord);
  if (!isNaN(number2) && DIGITS_SPOKEN_N_NEEDED.indexOf(number2 % 10) != -1 && FIRST_TWO_DIGITS_SPOKEN_NO_N_NEEDED.indexOf(
    parseInt(firstWord.substring(0, 2))
  ) == -1) {
    return true;
  }
  return false;
}
const formatDistance$z = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$z[token];
  const usageGroup = options?.addSuffix ? tokenValue.withPreposition : tokenValue.standalone;
  if (typeof usageGroup === "string") {
    result = usageGroup;
  } else if (count === 1) {
    result = usageGroup.one;
  } else {
    result = usageGroup.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "a" + (isFinalNNeeded(result) ? "n" : "") + " " + result;
    } else {
      return "viru" + (isFinalNNeeded(result) ? "n" : "") + " " + result;
    }
  }
  return result;
};
const dateFormats$z = {
  full: "EEEE, do MMMM y",
  // Mindeg, 7. Januar 2018
  long: "do MMMM y",
  // 7. Januar 2018
  medium: "do MMM y",
  // 7. Jan 2018
  short: "dd.MM.yy"
  // 07.01.18
};
const timeFormats$z = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$z = {
  full: "{{date}} 'um' {{time}}",
  long: "{{date}} 'um' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$z = {
  date: buildFormatLongFn({
    formats: dateFormats$z,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$z,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$z,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$z = {
  lastWeek: (date2) => {
    const day = date2.getDay();
    let result = "'lschte";
    if (day === 2 || day === 4) {
      result += "n";
    }
    result += "' eeee 'um' p";
    return result;
  },
  yesterday: "'gschter um' p",
  today: "'haut um' p",
  tomorrow: "'moien um' p",
  nextWeek: "eeee 'um' p",
  other: "P"
};
const formatRelative$z = (token, date2, _baseDate, _options) => {
  const format2 = formatRelativeLocale$z[token];
  if (typeof format2 === "function") {
    return format2(date2);
  }
  return format2;
};
const eraValues$z = {
  narrow: ["v.Chr.", "n.Chr."],
  abbreviated: ["v.Chr.", "n.Chr."],
  wide: ["viru Christus", "no Christus"]
};
const quarterValues$z = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. Quartal", "2. Quartal", "3. Quartal", "4. Quartal"]
};
const monthValues$z = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Me",
    "Abr",
    "Mee",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Okt",
    "Nov",
    "Dez"
  ],
  wide: [
    "Januar",
    "Februar",
    "Merz",
    "Abrll",
    "Mee",
    "Juni",
    "Juli",
    "August",
    "September",
    "Oktober",
    "November",
    "Dezember"
  ]
};
const dayValues$z = {
  narrow: ["S", "M", "D", "M", "D", "F", "S"],
  short: ["So", "M", "D", "M", "Do", "Fr", "Sa"],
  abbreviated: ["So.", "M.", "D.", "M.", "Do.", "Fr.", "Sa."],
  wide: [
    "Sonndeg",
    "Mindeg",
    "Dnschdeg",
    "Mttwoch",
    "Donneschdeg",
    "Freideg",
    "Samschdeg"
  ]
};
const dayPeriodValues$z = {
  narrow: {
    am: "mo.",
    pm: "nom.",
    midnight: "Mtternuecht",
    noon: "Mtteg",
    morning: "Moien",
    afternoon: "Nomtteg",
    evening: "Owend",
    night: "Nuecht"
  },
  abbreviated: {
    am: "moies",
    pm: "nomttes",
    midnight: "Mtternuecht",
    noon: "Mtteg",
    morning: "Moien",
    afternoon: "Nomtteg",
    evening: "Owend",
    night: "Nuecht"
  },
  wide: {
    am: "moies",
    pm: "nomttes",
    midnight: "Mtternuecht",
    noon: "Mtteg",
    morning: "Moien",
    afternoon: "Nomtteg",
    evening: "Owend",
    night: "Nuecht"
  }
};
const formattingDayPeriodValues$r = {
  narrow: {
    am: "mo.",
    pm: "nom.",
    midnight: "Mtternuecht",
    noon: "mttes",
    morning: "moies",
    afternoon: "nomttes",
    evening: "owes",
    night: "nuets"
  },
  abbreviated: {
    am: "moies",
    pm: "nomttes",
    midnight: "Mtternuecht",
    noon: "mttes",
    morning: "moies",
    afternoon: "nomttes",
    evening: "owes",
    night: "nuets"
  },
  wide: {
    am: "moies",
    pm: "nomttes",
    midnight: "Mtternuecht",
    noon: "mttes",
    morning: "moies",
    afternoon: "nomttes",
    evening: "owes",
    night: "nuets"
  }
};
const ordinalNumber$z = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$z = {
  ordinalNumber: ordinalNumber$z,
  era: buildLocalizeFn({
    values: eraValues$z,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$z,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$z,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$z,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$z,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$r,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$z = /^(\d+)(\.)?/i;
const parseOrdinalNumberPattern$z = /\d+/i;
const matchEraPatterns$z = {
  narrow: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  abbreviated: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  wide: /^(viru Christus|virun eiser Zitrechnung|no Christus|eiser Zitrechnung)/i
};
const parseEraPatterns$z = {
  any: [/^v/i, /^n/i]
};
const matchQuarterPatterns$z = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? Quartal/i
};
const parseQuarterPatterns$z = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$z = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|me|abr|mee|jun|jul|aug|sep|okt|nov|dez)/i,
  wide: /^(januar|februar|merz|abrll|mee|juni|juli|august|september|oktober|november|dezember)/i
};
const parseMonthPatterns$z = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^m/i,
    /^ab/i,
    /^me/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$z = {
  narrow: /^[smdf]/i,
  short: /^(so|m|d|m|do|fr|sa)/i,
  abbreviated: /^(son?|mi?|dn?|mt?|don?|fre?|sam?)\.?/i,
  wide: /^(sonndeg|mindeg|dnschdeg|mttwoch|donneschdeg|freideg|samschdeg)/i
};
const parseDayPatterns$z = {
  any: [/^so/i, /^m/i, /^d/i, /^m/i, /^do/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns$z = {
  narrow: /^(mo\.?|nom\.?|Mtternuecht|mttes|moies|nomttes|owes|nuets)/i,
  abbreviated: /^(moi\.?|nomt\.?|Mtternuecht|mttes|moies|nomttes|owes|nuets)/i,
  wide: /^(moies|nomttes|Mtternuecht|mttes|moies|nomttes|owes|nuets)/i
};
const parseDayPeriodPatterns$z = {
  any: {
    am: /^m/i,
    pm: /^n/i,
    midnight: /^Mtter/i,
    noon: /^mttes/i,
    morning: /moies/i,
    afternoon: /nomttes/i,
    // will never be matched. Afternoon is matched by `pm`
    evening: /owes/i,
    night: /nuets/i
    // will never be matched. Night is matched by `pm`
  }
};
const match$z = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$z,
    parsePattern: parseOrdinalNumberPattern$z,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$z,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$z,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$z,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$z,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$z,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$z,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$z,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$z,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$z,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$z,
    defaultParseWidth: "any"
  })
};
const lb = {
  code: "lb",
  formatDistance: formatDistance$z,
  formatLong: formatLong$z,
  formatRelative: formatRelative$z,
  localize: localize$z,
  match: match$z,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const translations = {
  xseconds_other: "sekund_sekundi_sekundes",
  xminutes_one: "minut_minuts_minut",
  xminutes_other: "minuts_minui_minutes",
  xhours_one: "valanda_valandos_valand",
  xhours_other: "valandos_valand_valandas",
  xdays_one: "diena_dienos_dien",
  xdays_other: "dienos_dien_dienas",
  xweeks_one: "savait_savaits_savait",
  xweeks_other: "savaits_savaii_savaites",
  xmonths_one: "mnuo_mnesio_mnes",
  xmonths_other: "mnesiai_mnesi_mnesius",
  xyears_one: "metai_met_metus",
  xyears_other: "metai_met_metus",
  about: "apie",
  over: "daugiau nei",
  almost: "beveik",
  lessthan: "maiau nei"
};
const translateSeconds = (_number, addSuffix, _key, isFuture) => {
  if (!addSuffix) {
    return "kelios sekunds";
  } else {
    return isFuture ? "keli sekundi" : "kelias sekundes";
  }
};
const translateSingular = (_number, addSuffix, key, isFuture) => {
  return !addSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
};
const translate = (number2, addSuffix, key, isFuture) => {
  const result = number2 + " ";
  if (number2 === 1) {
    return result + translateSingular(number2, addSuffix, key, isFuture);
  } else if (!addSuffix) {
    return result + (special(number2) ? forms(key)[1] : forms(key)[0]);
  } else {
    if (isFuture) {
      return result + forms(key)[1];
    } else {
      return result + (special(number2) ? forms(key)[1] : forms(key)[2]);
    }
  }
};
function special(number2) {
  return number2 % 10 === 0 || number2 > 10 && number2 < 20;
}
function forms(key) {
  return translations[key].split("_");
}
const formatDistanceLocale$y = {
  lessThanXSeconds: {
    one: translateSeconds,
    other: translate
  },
  xSeconds: {
    one: translateSeconds,
    other: translate
  },
  halfAMinute: "pus minuts",
  lessThanXMinutes: {
    one: translateSingular,
    other: translate
  },
  xMinutes: {
    one: translateSingular,
    other: translate
  },
  aboutXHours: {
    one: translateSingular,
    other: translate
  },
  xHours: {
    one: translateSingular,
    other: translate
  },
  xDays: {
    one: translateSingular,
    other: translate
  },
  aboutXWeeks: {
    one: translateSingular,
    other: translate
  },
  xWeeks: {
    one: translateSingular,
    other: translate
  },
  aboutXMonths: {
    one: translateSingular,
    other: translate
  },
  xMonths: {
    one: translateSingular,
    other: translate
  },
  aboutXYears: {
    one: translateSingular,
    other: translate
  },
  xYears: {
    one: translateSingular,
    other: translate
  },
  overXYears: {
    one: translateSingular,
    other: translate
  },
  almostXYears: {
    one: translateSingular,
    other: translate
  }
};
const formatDistance$y = (token, count, options) => {
  const adverb = token.match(/about|over|almost|lessthan/i);
  const unit = adverb ? token.replace(adverb[0], "") : token;
  const isFuture = options?.comparison !== void 0 && options.comparison > 0;
  let result;
  const tokenValue = formatDistanceLocale$y[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one(
      count,
      options?.addSuffix === true,
      unit.toLowerCase() + "_one",
      isFuture
    );
  } else {
    result = tokenValue.other(
      count,
      options?.addSuffix === true,
      unit.toLowerCase() + "_other",
      isFuture
    );
  }
  if (adverb) {
    const key = adverb[0].toLowerCase();
    result = translations[key] + " " + result;
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "po " + result;
    } else {
      return "prie " + result;
    }
  }
  return result;
};
const dateFormats$y = {
  full: "y 'm'. MMMM d 'd'., EEEE",
  long: "y 'm'. MMMM d 'd'.",
  medium: "y-MM-dd",
  short: "y-MM-dd"
};
const timeFormats$y = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$y = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$y = {
  date: buildFormatLongFn({
    formats: dateFormats$y,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$y,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$y,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$y = {
  lastWeek: "'Prajus' eeee p",
  yesterday: "'Vakar' p",
  today: "'iandien' p",
  tomorrow: "'Rytoj' p",
  nextWeek: "eeee p",
  other: "P"
};
const formatRelative$y = (token, _date, _baseDate, _options) => formatRelativeLocale$y[token];
const eraValues$y = {
  narrow: ["pr. Kr.", "po Kr."],
  abbreviated: ["pr. Kr.", "po Kr."],
  wide: ["prie Krist", "po Kristaus"]
};
const quarterValues$y = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["I ketv.", "II ketv.", "III ketv.", "IV ketv."],
  wide: ["I ketvirtis", "II ketvirtis", "III ketvirtis", "IV ketvirtis"]
};
const formattingQuarterValues$2 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["I k.", "II k.", "III k.", "IV k."],
  wide: ["I ketvirtis", "II ketvirtis", "III ketvirtis", "IV ketvirtis"]
};
const monthValues$y = {
  narrow: ["S", "V", "K", "B", "G", "B", "L", "R", "R", "S", "L", "G"],
  abbreviated: [
    "saus.",
    "vas.",
    "kov.",
    "bal.",
    "geg.",
    "bir.",
    "liep.",
    "rugp.",
    "rugs.",
    "spal.",
    "lapkr.",
    "gruod."
  ],
  wide: [
    "sausis",
    "vasaris",
    "kovas",
    "balandis",
    "gegu",
    "birelis",
    "liepa",
    "rugpjtis",
    "rugsjis",
    "spalis",
    "lapkritis",
    "gruodis"
  ]
};
const formattingMonthValues$8 = {
  narrow: ["S", "V", "K", "B", "G", "B", "L", "R", "R", "S", "L", "G"],
  abbreviated: [
    "saus.",
    "vas.",
    "kov.",
    "bal.",
    "geg.",
    "bir.",
    "liep.",
    "rugp.",
    "rugs.",
    "spal.",
    "lapkr.",
    "gruod."
  ],
  wide: [
    "sausio",
    "vasario",
    "kovo",
    "balandio",
    "gegus",
    "birelio",
    "liepos",
    "rugpjio",
    "rugsjo",
    "spalio",
    "lapkriio",
    "gruodio"
  ]
};
const dayValues$y = {
  narrow: ["S", "P", "A", "T", "K", "P", ""],
  short: ["Sk", "Pr", "An", "Tr", "Kt", "Pn", "t"],
  abbreviated: ["sk", "pr", "an", "tr", "kt", "pn", "t"],
  wide: [
    "sekmadienis",
    "pirmadienis",
    "antradienis",
    "treiadienis",
    "ketvirtadienis",
    "penktadienis",
    "etadienis"
  ]
};
const formattingDayValues$2 = {
  narrow: ["S", "P", "A", "T", "K", "P", ""],
  short: ["Sk", "Pr", "An", "Tr", "Kt", "Pn", "t"],
  abbreviated: ["sk", "pr", "an", "tr", "kt", "pn", "t"],
  wide: [
    "sekmadien",
    "pirmadien",
    "antradien",
    "treiadien",
    "ketvirtadien",
    "penktadien",
    "etadien"
  ]
};
const dayPeriodValues$y = {
  narrow: {
    am: "pr. p.",
    pm: "pop.",
    midnight: "vidurnaktis",
    noon: "vidurdienis",
    morning: "rytas",
    afternoon: "diena",
    evening: "vakaras",
    night: "naktis"
  },
  abbreviated: {
    am: "priepiet",
    pm: "popiet",
    midnight: "vidurnaktis",
    noon: "vidurdienis",
    morning: "rytas",
    afternoon: "diena",
    evening: "vakaras",
    night: "naktis"
  },
  wide: {
    am: "priepiet",
    pm: "popiet",
    midnight: "vidurnaktis",
    noon: "vidurdienis",
    morning: "rytas",
    afternoon: "diena",
    evening: "vakaras",
    night: "naktis"
  }
};
const formattingDayPeriodValues$q = {
  narrow: {
    am: "pr. p.",
    pm: "pop.",
    midnight: "vidurnaktis",
    noon: "perpiet",
    morning: "rytas",
    afternoon: "popiet",
    evening: "vakaras",
    night: "naktis"
  },
  abbreviated: {
    am: "priepiet",
    pm: "popiet",
    midnight: "vidurnaktis",
    noon: "perpiet",
    morning: "rytas",
    afternoon: "popiet",
    evening: "vakaras",
    night: "naktis"
  },
  wide: {
    am: "priepiet",
    pm: "popiet",
    midnight: "vidurnaktis",
    noon: "perpiet",
    morning: "rytas",
    afternoon: "popiet",
    evening: "vakaras",
    night: "naktis"
  }
};
const ordinalNumber$y = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "-oji";
};
const localize$y = {
  ordinalNumber: ordinalNumber$y,
  era: buildLocalizeFn({
    values: eraValues$y,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$y,
    defaultWidth: "wide",
    formattingValues: formattingQuarterValues$2,
    defaultFormattingWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$y,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$8,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$y,
    defaultWidth: "wide",
    formattingValues: formattingDayValues$2,
    defaultFormattingWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$y,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$q,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$y = /^(\d+)(-oji)?/i;
const parseOrdinalNumberPattern$y = /\d+/i;
const matchEraPatterns$y = {
  narrow: /^p(r|o)\.?\s?(kr\.?|me)/i,
  abbreviated: /^(pr\.\s?(kr\.|m\.\s?e\.)|po\s?kr\.|ms eroje)/i,
  wide: /^(prie Krist|prie ms er|po Kristaus|ms eroje)/i
};
const parseEraPatterns$y = {
  wide: [/prie/i, /(po|ms)/i],
  any: [/^pr/i, /^(po|m)/i]
};
const matchQuarterPatterns$y = {
  narrow: /^([1234])/i,
  abbreviated: /^(I|II|III|IV)\s?ketv?\.?/i,
  wide: /^(I|II|III|IV)\s?ketvirtis/i
};
const parseQuarterPatterns$y = {
  narrow: [/1/i, /2/i, /3/i, /4/i],
  any: [/I$/i, /II$/i, /III/i, /IV/i]
};
const matchMonthPatterns$y = {
  narrow: /^[svkbglr]/i,
  abbreviated: /^(saus\.|vas\.|kov\.|bal\.|geg\.|bir\.|liep\.|rugp\.|rugs\.|spal\.|lapkr\.|gruod\.)/i,
  wide: /^(sausi(s|o)|vasari(s|o)|kov(a|o)s|baland?i(s|o)|gegus?|bireli(s|o)|liep(a|os)|rugpj(t|)i(s|o)|rugsj(is|o)|spali(s|o)|lapkri(t|)i(s|o)|gruod?i(s|o))/i
};
const parseMonthPatterns$y = {
  narrow: [
    /^s/i,
    /^v/i,
    /^k/i,
    /^b/i,
    /^g/i,
    /^b/i,
    /^l/i,
    /^r/i,
    /^r/i,
    /^s/i,
    /^l/i,
    /^g/i
  ],
  any: [
    /^saus/i,
    /^vas/i,
    /^kov/i,
    /^bal/i,
    /^geg/i,
    /^bir/i,
    /^liep/i,
    /^rugp/i,
    /^rugs/i,
    /^spal/i,
    /^lapkr/i,
    /^gruod/i
  ]
};
const matchDayPatterns$y = {
  narrow: /^[spatk]/i,
  short: /^(sk|pr|an|tr|kt|pn|t)/i,
  abbreviated: /^(sk|pr|an|tr|kt|pn|t)/i,
  wide: /^(sekmadien(is|)|pirmadien(is|)|antradien(is|)|treiadien(is|)|ketvirtadien(is|)|penktadien(is|)|etadien(is|))/i
};
const parseDayPatterns$y = {
  narrow: [/^s/i, /^p/i, /^a/i, /^t/i, /^k/i, /^p/i, /^/i],
  wide: [/^se/i, /^pi/i, /^an/i, /^tr/i, /^ke/i, /^pe/i, /^e/i],
  any: [/^sk/i, /^pr/i, /^an/i, /^tr/i, /^kt/i, /^pn/i, /^t/i]
};
const matchDayPeriodPatterns$y = {
  narrow: /^(pr.\s?p.|pop.|vidurnaktis|(vidurdienis|perpiet)|rytas|(diena|popiet)|vakaras|naktis)/i,
  any: /^(priepiet|popiet$|vidurnaktis|(vidurdienis|perpiet)|rytas|(diena|popiet)|vakaras|naktis)/i
};
const parseDayPeriodPatterns$y = {
  narrow: {
    am: /^pr/i,
    pm: /^pop./i,
    midnight: /^vidurnaktis/i,
    noon: /^(vidurdienis|perp)/i,
    morning: /rytas/i,
    afternoon: /(die|popiet)/i,
    evening: /vakaras/i,
    night: /naktis/i
  },
  any: {
    am: /^pr/i,
    pm: /^popiet$/i,
    midnight: /^vidurnaktis/i,
    noon: /^(vidurdienis|perp)/i,
    morning: /rytas/i,
    afternoon: /(die|popiet)/i,
    evening: /vakaras/i,
    night: /naktis/i
  }
};
const match$y = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$y,
    parsePattern: parseOrdinalNumberPattern$y,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$y,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$y,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$y,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$y,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$y,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$y,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$y,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$y,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$y,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$y,
    defaultParseWidth: "any"
  })
};
const lt = {
  code: "lt",
  formatDistance: formatDistance$y,
  formatLong: formatLong$y,
  formatRelative: formatRelative$y,
  localize: localize$y,
  match: match$y,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
function buildLocalizeTokenFn$2(schema2) {
  return (count, options) => {
    if (count === 1) {
      if (options?.addSuffix) {
        return schema2.one[0].replace("{{time}}", schema2.one[2]);
      } else {
        return schema2.one[0].replace("{{time}}", schema2.one[1]);
      }
    } else {
      const rem = count % 10 === 1 && count % 100 !== 11;
      if (options?.addSuffix) {
        return schema2.other[0].replace("{{time}}", rem ? schema2.other[3] : schema2.other[4]).replace("{{count}}", String(count));
      } else {
        return schema2.other[0].replace("{{time}}", rem ? schema2.other[1] : schema2.other[2]).replace("{{count}}", String(count));
      }
    }
  };
}
const formatDistanceLocale$x = {
  lessThanXSeconds: buildLocalizeTokenFn$2({
    one: ["mazk par {{time}}", "sekundi", "sekundi"],
    other: [
      "mazk nek {{count}} {{time}}",
      "sekunde",
      "sekundes",
      "sekundes",
      "sekundm"
    ]
  }),
  xSeconds: buildLocalizeTokenFn$2({
    one: ["1 {{time}}", "sekunde", "sekundes"],
    other: [
      "{{count}} {{time}}",
      "sekunde",
      "sekundes",
      "sekundes",
      "sekundm"
    ]
  }),
  halfAMinute: (_count, options) => {
    if (options?.addSuffix) {
      return "pusmintes";
    } else {
      return "pusminte";
    }
  },
  lessThanXMinutes: buildLocalizeTokenFn$2({
    one: ["mazk par {{time}}", "minti", "minti"],
    other: [
      "mazk nek {{count}} {{time}}",
      "minte",
      "mintes",
      "mintes",
      "mintm"
    ]
  }),
  xMinutes: buildLocalizeTokenFn$2({
    one: ["1 {{time}}", "minte", "mintes"],
    other: ["{{count}} {{time}}", "minte", "mintes", "mintes", "mintm"]
  }),
  aboutXHours: buildLocalizeTokenFn$2({
    one: ["apmram 1 {{time}}", "stunda", "stundas"],
    other: [
      "apmram {{count}} {{time}}",
      "stunda",
      "stundas",
      "stundas",
      "stundm"
    ]
  }),
  xHours: buildLocalizeTokenFn$2({
    one: ["1 {{time}}", "stunda", "stundas"],
    other: ["{{count}} {{time}}", "stunda", "stundas", "stundas", "stundm"]
  }),
  xDays: buildLocalizeTokenFn$2({
    one: ["1 {{time}}", "diena", "dienas"],
    other: ["{{count}} {{time}}", "diena", "dienas", "dienas", "dienm"]
  }),
  aboutXWeeks: buildLocalizeTokenFn$2({
    one: ["apmram 1 {{time}}", "neda", "nedas"],
    other: [
      "apmram {{count}} {{time}}",
      "neda",
      "nedu",
      "nedas",
      "nedm"
    ]
  }),
  xWeeks: buildLocalizeTokenFn$2({
    one: ["1 {{time}}", "neda", "nedas"],
    other: [
      "{{count}} {{time}}",
      // TODO
      "neda",
      "nedu",
      "nedas",
      "nedm"
    ]
  }),
  aboutXMonths: buildLocalizeTokenFn$2({
    one: ["apmram 1 {{time}}", "mnesis", "mnea"],
    other: [
      "apmram {{count}} {{time}}",
      "mnesis",
      "mnei",
      "mnea",
      "mneiem"
    ]
  }),
  xMonths: buildLocalizeTokenFn$2({
    one: ["1 {{time}}", "mnesis", "mnea"],
    other: ["{{count}} {{time}}", "mnesis", "mnei", "mnea", "mneiem"]
  }),
  aboutXYears: buildLocalizeTokenFn$2({
    one: ["apmram 1 {{time}}", "gads", "gada"],
    other: ["apmram {{count}} {{time}}", "gads", "gadi", "gada", "gadiem"]
  }),
  xYears: buildLocalizeTokenFn$2({
    one: ["1 {{time}}", "gads", "gada"],
    other: ["{{count}} {{time}}", "gads", "gadi", "gada", "gadiem"]
  }),
  overXYears: buildLocalizeTokenFn$2({
    one: ["ilgk par 1 {{time}}", "gadu", "gadu"],
    other: ["vairk nek {{count}} {{time}}", "gads", "gadi", "gada", "gadiem"]
  }),
  almostXYears: buildLocalizeTokenFn$2({
    one: ["gandrz 1 {{time}}", "gads", "gada"],
    other: ["vairk nek {{count}} {{time}}", "gads", "gadi", "gada", "gadiem"]
  })
};
const formatDistance$x = (token, count, options) => {
  const result = formatDistanceLocale$x[token](count, options);
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "pc " + result;
    } else {
      return "pirms " + result;
    }
  }
  return result;
};
const dateFormats$x = {
  full: "EEEE, y. 'gada' d. MMMM",
  long: "y. 'gada' d. MMMM",
  medium: "dd.MM.y.",
  short: "dd.MM.y."
};
const timeFormats$x = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$x = {
  full: "{{date}} 'plkst.' {{time}}",
  long: "{{date}} 'plkst.' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$x = {
  date: buildFormatLongFn({
    formats: dateFormats$x,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$x,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$x,
    defaultWidth: "full"
  })
};
const weekdays$1 = [
  "svtdien",
  "pirmdien",
  "otrdien",
  "tredien",
  "ceturtdien",
  "piektdien",
  "sestdien"
];
const formatRelativeLocale$x = {
  lastWeek: (date2, baseDate, options) => {
    if (isSameWeek(date2, baseDate, options)) {
      return "eeee 'plkst.' p";
    }
    const weekday = weekdays$1[date2.getDay()];
    return "'Pagju " + weekday + " plkst.' p";
  },
  yesterday: "'Vakar plkst.' p",
  today: "'odien plkst.' p",
  tomorrow: "'Rt plkst.' p",
  nextWeek: (date2, baseDate, options) => {
    if (isSameWeek(date2, baseDate, options)) {
      return "eeee 'plkst.' p";
    }
    const weekday = weekdays$1[date2.getDay()];
    return "'Nkamaj " + weekday + " plkst.' p";
  },
  other: "P"
};
const formatRelative$x = (token, date2, baseDate, options) => {
  const format2 = formatRelativeLocale$x[token];
  if (typeof format2 === "function") {
    return format2(date2, baseDate, options);
  }
  return format2;
};
const eraValues$x = {
  narrow: ["p.m.", "m."],
  abbreviated: ["p. m. .", "m. ."],
  wide: ["pirms msu ras", "msu r"]
};
const quarterValues$x = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1. cet.", "2. cet.", "3. cet.", "4. cet."],
  wide: [
    "pirmais ceturksnis",
    "otrais ceturksnis",
    "treais ceturksnis",
    "ceturtais ceturksnis"
  ]
};
const formattingQuarterValues$1 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1. cet.", "2. cet.", "3. cet.", "4. cet."],
  wide: [
    "pirmaj ceturksn",
    "otraj ceturksn",
    "treaj ceturksn",
    "ceturtaj ceturksn"
  ]
};
const monthValues$x = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "janv.",
    "febr.",
    "marts",
    "apr.",
    "maijs",
    "jn.",
    "jl.",
    "aug.",
    "sept.",
    "okt.",
    "nov.",
    "dec."
  ],
  wide: [
    "janvris",
    "februris",
    "marts",
    "aprlis",
    "maijs",
    "jnijs",
    "jlijs",
    "augusts",
    "septembris",
    "oktobris",
    "novembris",
    "decembris"
  ]
};
const formattingMonthValues$7 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "janv.",
    "febr.",
    "mart",
    "apr.",
    "maijs",
    "jn.",
    "jl.",
    "aug.",
    "sept.",
    "okt.",
    "nov.",
    "dec."
  ],
  wide: [
    "janvr",
    "februr",
    "mart",
    "aprl",
    "maij",
    "jnij",
    "jlij",
    "august",
    "septembr",
    "oktobr",
    "novembr",
    "decembr"
  ]
};
const dayValues$x = {
  narrow: ["S", "P", "O", "T", "C", "P", "S"],
  short: ["Sv", "P", "O", "T", "C", "Pk", "S"],
  abbreviated: [
    "svtd.",
    "pirmd.",
    "otrd.",
    "tred.",
    "ceturtd.",
    "piektd.",
    "sestd."
  ],
  wide: [
    "svtdiena",
    "pirmdiena",
    "otrdiena",
    "trediena",
    "ceturtdiena",
    "piektdiena",
    "sestdiena"
  ]
};
const formattingDayValues$1 = {
  narrow: ["S", "P", "O", "T", "C", "P", "S"],
  short: ["Sv", "P", "O", "T", "C", "Pk", "S"],
  abbreviated: [
    "svtd.",
    "pirmd.",
    "otrd.",
    "tred.",
    "ceturtd.",
    "piektd.",
    "sestd."
  ],
  wide: [
    "svtdien",
    "pirmdien",
    "otrdien",
    "tredien",
    "ceturtdien",
    "piektdien",
    "sestdien"
  ]
};
const dayPeriodValues$x = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "pusn.",
    noon: "pusd.",
    morning: "rts",
    afternoon: "diena",
    evening: "vakars",
    night: "nakts"
  },
  abbreviated: {
    am: "am",
    pm: "pm",
    midnight: "pusn.",
    noon: "pusd.",
    morning: "rts",
    afternoon: "pcpusd.",
    evening: "vakars",
    night: "nakts"
  },
  wide: {
    am: "am",
    pm: "pm",
    midnight: "pusnakts",
    noon: "pusdienlaiks",
    morning: "rts",
    afternoon: "pcpusdiena",
    evening: "vakars",
    night: "nakts"
  }
};
const formattingDayPeriodValues$p = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "pusn.",
    noon: "pusd.",
    morning: "rt",
    afternoon: "dien",
    evening: "vakar",
    night: "nakt"
  },
  abbreviated: {
    am: "am",
    pm: "pm",
    midnight: "pusn.",
    noon: "pusd.",
    morning: "rt",
    afternoon: "pcpusd.",
    evening: "vakar",
    night: "nakt"
  },
  wide: {
    am: "am",
    pm: "pm",
    midnight: "pusnakt",
    noon: "pusdienlaik",
    morning: "rt",
    afternoon: "pcpusdien",
    evening: "vakar",
    night: "nakt"
  }
};
const ordinalNumber$x = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$x = {
  ordinalNumber: ordinalNumber$x,
  era: buildLocalizeFn({
    values: eraValues$x,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$x,
    defaultWidth: "wide",
    formattingValues: formattingQuarterValues$1,
    defaultFormattingWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$x,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$7,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$x,
    defaultWidth: "wide",
    formattingValues: formattingDayValues$1,
    defaultFormattingWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$x,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$p,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$x = /^(\d+)\./i;
const parseOrdinalNumberPattern$x = /\d+/i;
const matchEraPatterns$x = {
  narrow: /^(p\.m\.|m\.)/i,
  abbreviated: /^(p\. m\. \.|m\. \.)/i,
  wide: /^(pirms msu ras|msu r)/i
};
const parseEraPatterns$x = {
  any: [/^p/i, /^m/i]
};
const matchQuarterPatterns$x = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](\. cet\.)/i,
  wide: /^(pirma(is|j)|otra(is|j)|trea(is|j)|ceturta(is|j)) ceturksn(is|)/i
};
const parseQuarterPatterns$x = {
  narrow: [/^1/i, /^2/i, /^3/i, /^4/i],
  abbreviated: [/^1/i, /^2/i, /^3/i, /^4/i],
  wide: [/^p/i, /^o/i, /^t/i, /^c/i]
};
const matchMonthPatterns$x = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(janv\.|febr\.|marts|apr\.|maijs|jn\.|jl\.|aug\.|sept\.|okt\.|nov\.|dec\.)/i,
  wide: /^(janvr(is|)|februr(is|)|mart[s]|aprl(is|)|maij[s]|jnij[s]|jlij[s]|august[s]|septembr(is|)|oktobr(is|)|novembr(is|)|decembr(is|))/i
};
const parseMonthPatterns$x = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^mai/i,
    /^jn/i,
    /^jl/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$x = {
  narrow: /^[spotc]/i,
  short: /^(sv|pi|o|t|c|pk|s)/i,
  abbreviated: /^(svtd\.|pirmd\.|otrd.\|tred\.|ceturtd\.|piektd\.|sestd\.)/i,
  wide: /^(svtdien(a|)|pirmdien(a|)|otrdien(a|)|tredien(a|)|ceturtdien(a|)|piektdien(a|)|sestdien(a|))/i
};
const parseDayPatterns$x = {
  narrow: [/^s/i, /^p/i, /^o/i, /^t/i, /^c/i, /^p/i, /^s/i],
  any: [/^sv/i, /^pi/i, /^o/i, /^t/i, /^c/i, /^p/i, /^se/i]
};
const matchDayPeriodPatterns$x = {
  narrow: /^(am|pm|pusn\.|pusd\.|rt(s|)|dien(a|)|vakar(s|)|nakt(s|))/,
  abbreviated: /^(am|pm|pusn\.|pusd\.|rt(s|)|pcpusd\.|vakar(s|)|nakt(s|))/,
  wide: /^(am|pm|pusnakt(s|)|pusdienlaik(s|)|rt(s|)|pcpusdien(a|)|vakar(s|)|nakt(s|))/i
};
const parseDayPeriodPatterns$x = {
  any: {
    am: /^am/i,
    pm: /^pm/i,
    midnight: /^pusn/i,
    noon: /^pusd/i,
    morning: /^r/i,
    afternoon: /^(d|pc)/i,
    evening: /^v/i,
    night: /^n/i
  }
};
const match$x = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$x,
    parsePattern: parseOrdinalNumberPattern$x,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$x,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$x,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$x,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$x,
    defaultParseWidth: "wide",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$x,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$x,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$x,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$x,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$x,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$x,
    defaultParseWidth: "any"
  })
};
const lv = {
  code: "lv",
  formatDistance: formatDistance$x,
  formatLong: formatLong$x,
  formatRelative: formatRelative$x,
  localize: localize$x,
  match: match$x,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$w = {
  lessThanXSeconds: {
    one: "  ",
    other: "  {{count}} "
  },
  xSeconds: {
    one: "1 ",
    other: "{{count}} "
  },
  halfAMinute: " ",
  lessThanXMinutes: {
    one: "  ",
    other: "  {{count}} "
  },
  xMinutes: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: " 1 ",
    other: " {{count}} "
  },
  xHours: {
    one: "1 ",
    other: "{{count}} "
  },
  xDays: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: " 1 ",
    other: " {{count}} "
  },
  xWeeks: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: " 1 ",
    other: " {{count}} "
  },
  xMonths: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: " 1 ",
    other: " {{count}} "
  },
  xYears: {
    one: "1 ",
    other: "{{count}} "
  },
  overXYears: {
    one: "  1 ",
    other: "  {{count}} "
  },
  almostXYears: {
    one: " 1 ",
    other: " {{count}} "
  }
};
const formatDistance$w = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$w[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return " " + result;
    } else {
      return " " + result;
    }
  }
  return result;
};
const dateFormats$w = {
  full: "EEEE, dd MMMM yyyy",
  long: "dd MMMM yyyy",
  medium: "dd MMM yyyy",
  short: "dd/MM/yyyy"
};
const timeFormats$w = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "H:mm"
};
const dateTimeFormats$w = {
  any: "{{date}} {{time}}"
};
const formatLong$w = {
  date: buildFormatLongFn({
    formats: dateFormats$w,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$w,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$w,
    defaultWidth: "any"
  })
};
const weekdays = [
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];
function lastWeek$3(day) {
  const weekday = weekdays[day];
  switch (day) {
    case 0:
    case 3:
    case 6:
      return "' " + weekday + " ' p";
    case 1:
    case 2:
    case 4:
    case 5:
      return "' " + weekday + " ' p";
  }
}
function thisWeek$3(day) {
  const weekday = weekdays[day];
  switch (day) {
    case 0:
    case 3:
    case 6:
      return "' " + weekday + " o' p";
    case 1:
    case 2:
    case 4:
    case 5:
      return "' " + weekday + " o' p";
  }
}
function nextWeek$3(day) {
  const weekday = weekdays[day];
  switch (day) {
    case 0:
    case 3:
    case 6:
      return "' " + weekday + " o' p";
    case 1:
    case 2:
    case 4:
    case 5:
      return "' " + weekday + " o' p";
  }
}
const formatRelativeLocale$w = {
  lastWeek: (date2, baseDate, options) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options)) {
      return thisWeek$3(day);
    } else {
      return lastWeek$3(day);
    }
  },
  yesterday: "' ' p",
  today: "' ' p",
  tomorrow: "' ' p",
  nextWeek: (date2, baseDate, options) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options)) {
      return thisWeek$3(day);
    } else {
      return nextWeek$3(day);
    }
  },
  other: "P"
};
const formatRelative$w = (token, date2, baseDate, options) => {
  const format2 = formatRelativeLocale$w[token];
  if (typeof format2 === "function") {
    return format2(date2, baseDate, options);
  }
  return format2;
};
const eraValues$w = {
  narrow: ["...", ".."],
  abbreviated: [" . .", ". ."],
  wide: ["  ", " "]
};
const quarterValues$w = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1- .", "2- .", "3- .", "4- ."],
  wide: ["1- ", "2- ", "3- ", "4- "]
};
const monthValues$w = {
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$w = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$w = {
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$w = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  const rem100 = number2 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number2 + "-";
      case 2:
        return number2 + "-";
      case 7:
      case 8:
        return number2 + "-";
    }
  }
  return number2 + "-";
};
const localize$w = {
  ordinalNumber: ordinalNumber$w,
  era: buildLocalizeFn({
    values: eraValues$w,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$w,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$w,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$w,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$w,
    defaultWidth: "wide"
  })
};
const matchOrdinalNumberPattern$w = /^(\d+)(-?[][])?/i;
const parseOrdinalNumberPattern$w = /\d+/i;
const matchEraPatterns$w = {
  narrow: /^(()?\.?\s?\.?)/i,
  abbreviated: /^(()?\.?\s?\.?)/i,
  wide: /^(  | )/i
};
const parseEraPatterns$w = {
  any: [/^/i, /^/i]
};
const matchQuarterPatterns$w = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?[]??)? .?/i,
  wide: /^[1234](-?[]??)? /i
};
const parseQuarterPatterns$w = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchDayPatterns$w = {
  narrow: /^[]/i,
  short: /^(||||||)/i,
  abbreviated: /^(||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$w = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^[]/i, /^[]/i, /^/i, /^/i, /^[]/i, /^[]/i, /^[]/i]
};
const matchMonthPatterns$w = {
  abbreviated: /^(|||||||||||)/i,
  wide: /^(|||||||||||)/i
};
const parseMonthPatterns$w = {
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPeriodPatterns$w = {
  any: /^(||||||)/i
};
const parseDayPeriodPatterns$w = {
  any: {
    am: //i,
    pm: //i,
    midnight: //i,
    noon: //i,
    morning: //i,
    afternoon: //i,
    evening: //i,
    night: //i
  }
};
const match$w = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$w,
    parsePattern: parseOrdinalNumberPattern$w,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$w,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$w,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$w,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$w,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$w,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$w,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$w,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$w,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$w,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$w,
    defaultParseWidth: "any"
  })
};
const mk = {
  code: "mk",
  formatDistance: formatDistance$w,
  formatLong: formatLong$w,
  formatRelative: formatRelative$w,
  localize: localize$w,
  match: match$w,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$v = {
  lessThanXSeconds: {
    one: " ",
    other: "{{count}}  "
  },
  xSeconds: {
    one: "1 ",
    other: "{{count}} "
  },
  halfAMinute: " ",
  lessThanXMinutes: {
    one: " ",
    other: "{{count}}  "
  },
  xMinutes: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: " 1 ",
    other: " {{count}} "
  },
  xHours: {
    one: "1 ",
    other: "{{count}} "
  },
  xDays: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: " 1  ",
    other: " {{count}}  "
  },
  xWeeks: {
    one: "1  ",
    other: "{{count}}  "
  },
  aboutXMonths: {
    one: " 1 ",
    other: " {{count}} "
  },
  xMonths: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: " 1 ",
    other: " {{count}} "
  },
  xYears: {
    one: "1 ",
    other: "{{count}} "
  },
  overXYears: {
    one: "1  ",
    other: "{{count}}  "
  },
  almostXYears: {
    one: " 1 ",
    other: " {{count}} "
  }
};
const formatDistance$v = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$v[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    const words2 = result.split(" ");
    const lastword = words2.pop();
    result = words2.join(" ");
    switch (lastword) {
      case "":
        result += " ";
        break;
      case "":
        result += " ";
        break;
      case "":
        result += " ";
        break;
      case "":
        result += " ";
        break;
      case "":
        result += " ";
        break;
      case "":
        result += " ";
        break;
      case "":
        result += " ";
        break;
      case "":
        result += " ";
        break;
      case "":
        result += "  ";
        break;
      default:
        result += lastword + "-";
    }
    if (options.comparison && options.comparison > 0) {
      return result + " ";
    } else {
      return result + " ";
    }
  }
  return result;
};
const dateFormats$v = {
  full: "y '' MMMM'' d, EEEE ''",
  long: "y '' MMMM'' d",
  medium: "y '' MMM'' d",
  short: "y.MM.dd"
};
const timeFormats$v = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
const dateTimeFormats$v = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$v = {
  date: buildFormatLongFn({
    formats: dateFormats$v,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$v,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$v,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$v = {
  lastWeek: "'' eeee '' p ''",
  yesterday: "'' p ''",
  today: "'' p ''",
  tomorrow: "'' p ''",
  nextWeek: "'' eeee '' p ''",
  other: "P"
};
const formatRelative$v = (token, _date, _baseDate, _options) => formatRelativeLocale$v[token];
const eraValues$v = {
  narrow: ["", ""],
  abbreviated: ["", ""],
  wide: ["  ", " "]
};
const quarterValues$v = {
  narrow: ["I", "II", "III", "IV"],
  abbreviated: ["I ", "II ", "III ", "IV "],
  wide: ["1- ", "2- ", "3- ", "4- "]
};
const monthValues$v = {
  narrow: [
    "I",
    "II",
    "III",
    "IV",
    "V",
    "VI",
    "VII",
    "VIII",
    "IX",
    "X",
    "XI",
    "XII"
  ],
  abbreviated: [
    "1- ",
    "2- ",
    "3- ",
    "4- ",
    "5- ",
    "6- ",
    "7- ",
    "8- ",
    "9- ",
    "10- ",
    "11- ",
    "12- "
  ],
  wide: [
    " ",
    " ",
    " ",
    " ",
    " ",
    " ",
    " ",
    " ",
    " ",
    " ",
    " ",
    "  "
  ]
};
const formattingMonthValues$6 = {
  narrow: [
    "I",
    "II",
    "III",
    "IV",
    "V",
    "VI",
    "VII",
    "VIII",
    "IX",
    "X",
    "XI",
    "XII"
  ],
  abbreviated: [
    "1- ",
    "2- ",
    "3- ",
    "4- ",
    "5- ",
    "6- ",
    "7- ",
    "8- ",
    "9- ",
    "10- ",
    "11- ",
    "12- "
  ],
  wide: [
    " ",
    " ",
    " ",
    " ",
    " ",
    " ",
    " ",
    " ",
    " ",
    " ",
    " ",
    "  "
  ]
};
const dayValues$v = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: ["", "", "", "", "", "", ""]
};
const formattingDayValues = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: ["", "", "", "", "", "", ""]
};
const dayPeriodValues$v = {
  narrow: {
    am: "..",
    pm: "..",
    midnight: " ",
    noon: " ",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "..",
    pm: "..",
    midnight: " ",
    noon: " ",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "..",
    pm: "..",
    midnight: " ",
    noon: " ",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$v = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
const localize$v = {
  ordinalNumber: ordinalNumber$v,
  era: buildLocalizeFn({
    values: eraValues$v,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$v,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$v,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$6,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$v,
    defaultWidth: "wide",
    formattingValues: formattingDayValues,
    defaultFormattingWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$v,
    defaultWidth: "wide"
  })
};
const matchOrdinalNumberPattern$v = /\d+/i;
const parseOrdinalNumberPattern$v = /\d+/i;
const matchEraPatterns$v = {
  narrow: /^(|)/i,
  abbreviated: /^(|)/i,
  wide: /^(  | )/i
};
const parseEraPatterns$v = {
  any: [/^(|  )/i, /^(| )/i]
};
const matchQuarterPatterns$v = {
  narrow: /^(iv|iii|ii|i)/i,
  abbreviated: /^(iv|iii|ii|i) /i,
  wide: /^[1-4]- /i
};
const parseQuarterPatterns$v = {
  any: [/^(i(\s|$)|1)/i, /^(ii(\s|$)|2)/i, /^(iii(\s|$)|3)/i, /^(iv(\s|$)|4)/i]
};
const matchMonthPatterns$v = {
  narrow: /^(xii|xi|x|ix|viii|vii|vi|v|iv|iii|ii|i)/i,
  abbreviated: /^(1- |2- |3- |4- |5- |6- |7- |8- |9- |10- |11- |12- )/i,
  wide: /^( | | | | | | | | | |  |  )/i
};
const parseMonthPatterns$v = {
  narrow: [
    /^i$/i,
    /^ii$/i,
    /^iii$/i,
    /^iv$/i,
    /^v$/i,
    /^vi$/i,
    /^vii$/i,
    /^viii$/i,
    /^ix$/i,
    /^x$/i,
    /^xi$/i,
    /^xii$/i
  ],
  any: [
    /^(1|)/i,
    /^(2|)/i,
    /^(3|)/i,
    /^(4|)/i,
    /^(5|)/i,
    /^(6|)/i,
    /^(7|)/i,
    /^(8|)/i,
    /^(9|)/i,
    /^(10|)/i,
    /^(11| )/i,
    /^(12| )/i
  ]
};
const matchDayPatterns$v = {
  narrow: /^[]/i,
  short: /^(||||||)/i,
  abbreviated: /^(||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$v = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$v = {
  narrow: /^(\.\.|\.\.| | ||||)/i,
  any: /^(\.\.|\.\.| | ||||)/i
};
const parseDayPeriodPatterns$v = {
  any: {
    am: /^\.\./i,
    pm: /^\.\./i,
    midnight: /^ /i,
    noon: /^ /i,
    morning: //i,
    afternoon: //i,
    evening: //i,
    night: //i
  }
};
const match$v = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$v,
    parsePattern: parseOrdinalNumberPattern$v,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$v,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$v,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$v,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$v,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$v,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$v,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$v,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$v,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$v,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$v,
    defaultParseWidth: "any"
  })
};
const mn = {
  code: "mn",
  formatDistance: formatDistance$v,
  formatLong: formatLong$v,
  formatRelative: formatRelative$v,
  localize: localize$v,
  match: match$v,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$u = {
  lessThanXSeconds: {
    one: "kurang dari 1 saat",
    other: "kurang dari {{count}} saat"
  },
  xSeconds: {
    one: "1 saat",
    other: "{{count}} saat"
  },
  halfAMinute: "setengah minit",
  lessThanXMinutes: {
    one: "kurang dari 1 minit",
    other: "kurang dari {{count}} minit"
  },
  xMinutes: {
    one: "1 minit",
    other: "{{count}} minit"
  },
  aboutXHours: {
    one: "sekitar 1 jam",
    other: "sekitar {{count}} jam"
  },
  xHours: {
    one: "1 jam",
    other: "{{count}} jam"
  },
  xDays: {
    one: "1 hari",
    other: "{{count}} hari"
  },
  aboutXWeeks: {
    one: "sekitar 1 minggu",
    other: "sekitar {{count}} minggu"
  },
  xWeeks: {
    one: "1 minggu",
    other: "{{count}} minggu"
  },
  aboutXMonths: {
    one: "sekitar 1 bulan",
    other: "sekitar {{count}} bulan"
  },
  xMonths: {
    one: "1 bulan",
    other: "{{count}} bulan"
  },
  aboutXYears: {
    one: "sekitar 1 tahun",
    other: "sekitar {{count}} tahun"
  },
  xYears: {
    one: "1 tahun",
    other: "{{count}} tahun"
  },
  overXYears: {
    one: "lebih dari 1 tahun",
    other: "lebih dari {{count}} tahun"
  },
  almostXYears: {
    one: "hampir 1 tahun",
    other: "hampir {{count}} tahun"
  }
};
const formatDistance$u = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$u[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "dalam masa " + result;
    } else {
      return result + " yang lalu";
    }
  }
  return result;
};
const dateFormats$u = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "d/M/yyyy"
};
const timeFormats$u = {
  full: "HH.mm.ss",
  long: "HH.mm.ss",
  medium: "HH.mm",
  short: "HH.mm"
};
const dateTimeFormats$u = {
  full: "{{date}} 'pukul' {{time}}",
  long: "{{date}} 'pukul' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$u = {
  date: buildFormatLongFn({
    formats: dateFormats$u,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$u,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$u,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$u = {
  lastWeek: "eeee 'lepas pada jam' p",
  yesterday: "'Semalam pada jam' p",
  today: "'Hari ini pada jam' p",
  tomorrow: "'Esok pada jam' p",
  nextWeek: "eeee 'pada jam' p",
  other: "P"
};
const formatRelative$u = (token, _date, _baseDate, _options) => formatRelativeLocale$u[token];
const eraValues$u = {
  narrow: ["SM", "M"],
  abbreviated: ["SM", "M"],
  wide: ["Sebelum Masihi", "Masihi"]
};
const quarterValues$u = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["S1", "S2", "S3", "S4"],
  wide: ["Suku pertama", "Suku kedua", "Suku ketiga", "Suku keempat"]
};
const monthValues$u = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "O", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mac",
    "Apr",
    "Mei",
    "Jun",
    "Jul",
    "Ogo",
    "Sep",
    "Okt",
    "Nov",
    "Dis"
  ],
  wide: [
    "Januari",
    "Februari",
    "Mac",
    "April",
    "Mei",
    "Jun",
    "Julai",
    "Ogos",
    "September",
    "Oktober",
    "November",
    "Disember"
  ]
};
const dayValues$u = {
  narrow: ["A", "I", "S", "R", "K", "J", "S"],
  short: ["Ahd", "Isn", "Sel", "Rab", "Kha", "Jum", "Sab"],
  abbreviated: ["Ahd", "Isn", "Sel", "Rab", "Kha", "Jum", "Sab"],
  wide: ["Ahad", "Isnin", "Selasa", "Rabu", "Khamis", "Jumaat", "Sabtu"]
};
const dayPeriodValues$u = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "tgh malam",
    noon: "tgh hari",
    morning: "pagi",
    afternoon: "tengah hari",
    evening: "petang",
    night: "malam"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "tengah hari",
    evening: "petang",
    night: "malam"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "tengah hari",
    evening: "petang",
    night: "malam"
  }
};
const formattingDayPeriodValues$o = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "tengah hari",
    evening: "petang",
    night: "malam"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "tengah hari",
    evening: "petang",
    night: "malam"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "tengah hari",
    evening: "petang",
    night: "malam"
  }
};
const ordinalNumber$u = (dirtyNumber, _options) => {
  return "ke-" + Number(dirtyNumber);
};
const localize$u = {
  ordinalNumber: ordinalNumber$u,
  era: buildLocalizeFn({
    values: eraValues$u,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$u,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$u,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$u,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$u,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$o,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$u = /^ke-(\d+)?/i;
const parseOrdinalNumberPattern$u = /petama|\d+/i;
const matchEraPatterns$u = {
  narrow: /^(sm|m)/i,
  abbreviated: /^(s\.?\s?m\.?|m\.?)/i,
  wide: /^(sebelum masihi|masihi)/i
};
const parseEraPatterns$u = {
  any: [/^s/i, /^(m)/i]
};
const matchQuarterPatterns$u = {
  narrow: /^[1234]/i,
  abbreviated: /^S[1234]/i,
  wide: /Suku (pertama|kedua|ketiga|keempat)/i
};
const parseQuarterPatterns$u = {
  any: [/pertama|1/i, /kedua|2/i, /ketiga|3/i, /keempat|4/i]
};
const matchMonthPatterns$u = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mac|apr|mei|jun|jul|ogo|sep|okt|nov|dis)/i,
  wide: /^(januari|februari|mac|april|mei|jun|julai|ogos|september|oktober|november|disember)/i
};
const parseMonthPatterns$u = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^o/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^ma/i,
    /^ap/i,
    /^me/i,
    /^jun/i,
    /^jul/i,
    /^og/i,
    /^s/i,
    /^ok/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$u = {
  narrow: /^[aisrkj]/i,
  short: /^(ahd|isn|sel|rab|kha|jum|sab)/i,
  abbreviated: /^(ahd|isn|sel|rab|kha|jum|sab)/i,
  wide: /^(ahad|isnin|selasa|rabu|khamis|jumaat|sabtu)/i
};
const parseDayPatterns$u = {
  narrow: [/^a/i, /^i/i, /^s/i, /^r/i, /^k/i, /^j/i, /^s/i],
  any: [/^a/i, /^i/i, /^se/i, /^r/i, /^k/i, /^j/i, /^sa/i]
};
const matchDayPeriodPatterns$u = {
  narrow: /^(am|pm|tengah malam|tengah hari|pagi|petang|malam)/i,
  any: /^([ap]\.?\s?m\.?|tengah malam|tengah hari|pagi|petang|malam)/i
};
const parseDayPeriodPatterns$u = {
  any: {
    am: /^a/i,
    pm: /^pm/i,
    midnight: /^tengah m/i,
    noon: /^tengah h/i,
    morning: /pa/i,
    afternoon: /tengah h/i,
    evening: /pe/i,
    night: /m/i
  }
};
const match$u = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$u,
    parsePattern: parseOrdinalNumberPattern$u,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$u,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$u,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$u,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$u,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$u,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$u,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$u,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$u,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$u,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$u,
    defaultParseWidth: "any"
  })
};
const ms = {
  code: "ms",
  formatDistance: formatDistance$u,
  formatLong: formatLong$u,
  formatRelative: formatRelative$u,
  localize: localize$u,
  match: match$u,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$t = {
  lessThanXSeconds: {
    one: "inqas minn sekonda",
    other: "inqas minn {{count}} sekondi"
  },
  xSeconds: {
    one: "sekonda",
    other: "{{count}} sekondi"
  },
  halfAMinute: "nofs minuta",
  lessThanXMinutes: {
    one: "inqas minn minuta",
    other: "inqas minn {{count}} minuti"
  },
  xMinutes: {
    one: "minuta",
    other: "{{count}} minuti"
  },
  aboutXHours: {
    one: "madwar siega",
    other: "madwar {{count}} siegat"
  },
  xHours: {
    one: "siega",
    other: "{{count}} siegat"
  },
  xDays: {
    one: "urnata",
    other: "{{count}} ranet"
  },
  aboutXWeeks: {
    one: "madwar imga",
    other: "madwar {{count}} imgat"
  },
  xWeeks: {
    one: "imga",
    other: "{{count}} imgat"
  },
  aboutXMonths: {
    one: "madwar xahar",
    other: "madwar {{count}} xhur"
  },
  xMonths: {
    one: "xahar",
    other: "{{count}} xhur"
  },
  aboutXYears: {
    one: "madwar sena",
    two: "madwar sentejn",
    other: "madwar {{count}} snin"
  },
  xYears: {
    one: "sena",
    two: "sentejn",
    other: "{{count}} snin"
  },
  overXYears: {
    one: "aktar minn sena",
    two: "aktar minn sentejn",
    other: "aktar minn {{count}} snin"
  },
  almostXYears: {
    one: "kwai sena",
    two: "kwai sentejn",
    other: "kwai {{count}} snin"
  }
};
const formatDistance$t = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$t[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 2 && tokenValue.two) {
    result = tokenValue.two;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "f'" + result;
    } else {
      return result + " ilu";
    }
  }
  return result;
};
const dateFormats$t = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd/MM/yyyy"
};
const timeFormats$t = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$t = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$t = {
  date: buildFormatLongFn({
    formats: dateFormats$t,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$t,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$t,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$t = {
  lastWeek: "eeee 'li gadda' 'fil-'p",
  yesterday: "'Il-biera fil-'p",
  today: "'Illum fil-'p",
  tomorrow: "'Gada fil-'p",
  nextWeek: "eeee 'fil-'p",
  other: "P"
};
const formatRelative$t = (token, _date, _baseDate, _options) => formatRelativeLocale$t[token];
const eraValues$t = {
  narrow: ["Q", "W"],
  abbreviated: ["QK", "WK"],
  wide: ["qabel Kristu", "wara Kristu"]
};
const quarterValues$t = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1. kwart", "2. kwart", "3. kwart", "4. kwart"]
};
const monthValues$t = {
  narrow: ["J", "F", "M", "A", "M", "", "L", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Fra",
    "Mar",
    "Apr",
    "Mej",
    "un",
    "Lul",
    "Aww",
    "Set",
    "Ott",
    "Nov",
    "Di"
  ],
  wide: [
    "Jannar",
    "Frar",
    "Marzu",
    "April",
    "Mejju",
    "unju",
    "Lulju",
    "Awwissu",
    "Settembru",
    "Ottubru",
    "Novembru",
    "Diembru"
  ]
};
const dayValues$t = {
  narrow: ["", "T", "T", "E", "", "", "S"],
  short: ["a", "Tn", "Tl", "Er", "a", "i", "Si"],
  abbreviated: ["ad", "Tne", "Tli", "Erb", "am", "im", "Sib"],
  wide: [
    "Il-add",
    "It-Tnejn",
    "It-Tlieta",
    "L-Erbga",
    "Il-amis",
    "Il-imga",
    "Is-Sibt"
  ]
};
const dayPeriodValues$t = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "nofsillejl",
    noon: "nofsinhar",
    morning: "godwa",
    afternoon: "wara nofsinhar",
    evening: "filgaxija",
    night: "lejl"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "nofsillejl",
    noon: "nofsinhar",
    morning: "godwa",
    afternoon: "wara nofsinhar",
    evening: "filgaxija",
    night: "lejl"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "nofsillejl",
    noon: "nofsinhar",
    morning: "godwa",
    afternoon: "wara nofsinhar",
    evening: "filgaxija",
    night: "lejl"
  }
};
const formattingDayPeriodValues$n = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "f'nofsillejl",
    noon: "f'nofsinhar",
    morning: "filgodu",
    afternoon: "wara nofsinhar",
    evening: "filgaxija",
    night: "billejl"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "f'nofsillejl",
    noon: "f'nofsinhar",
    morning: "filgodu",
    afternoon: "wara nofsinhar",
    evening: "filgaxija",
    night: "billejl"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "f'nofsillejl",
    noon: "f'nofsinhar",
    morning: "filgodu",
    afternoon: "wara nofsinhar",
    evening: "filgaxija",
    night: "billejl"
  }
};
const ordinalNumber$t = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "";
};
const localize$t = {
  ordinalNumber: ordinalNumber$t,
  era: buildLocalizeFn({
    values: eraValues$t,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$t,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$t,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$t,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$t,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$n,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$t = /^(\d+)()?/i;
const parseOrdinalNumberPattern$t = /\d+/i;
const matchEraPatterns$t = {
  narrow: /^(q|w)/i,
  abbreviated: /^(q\.?\s?k\.?|b\.?\s?c\.?\s?e\.?|w\.?\s?k\.?)/i,
  wide: /^(qabel kristu|before common era|wara kristu|common era)/i
};
const parseEraPatterns$t = {
  any: [/^(q|b)/i, /^(w|c)/i]
};
const matchQuarterPatterns$t = {
  narrow: /^[1234]/i,
  abbreviated: /^k[1234]/i,
  wide: /^[1234](\.)? kwart/i
};
const parseQuarterPatterns$t = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$t = {
  narrow: /^[jfmaglsond]/i,
  abbreviated: /^(jan|fra|mar|apr|mej|un|lul|aww|set|ott|nov|di)/i,
  wide: /^(jannar|frar|marzu|april|mejju|unju|lulju|awwissu|settembru|ottubru|novembru|diembru)/i
};
const parseMonthPatterns$t = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^/i,
    /^l/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^mej/i,
    /^/i,
    /^l/i,
    /^aw/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$t = {
  narrow: /^[tes]/i,
  short: /^(a|tn|tl|er|a|i|si)/i,
  abbreviated: /^(ad|tne|tli|erb|am|im|sib)/i,
  wide: /^(il-add|it-tnejn|it-tlieta|l-erbga|il-amis|il-imga|is-sibt)/i
};
const parseDayPatterns$t = {
  narrow: [/^/i, /^t/i, /^t/i, /^e/i, /^/i, /^/i, /^s/i],
  any: [
    /^(il-)?ad/i,
    /^(it-)?tn/i,
    /^(it-)?tl/i,
    /^(l-)?er/i,
    /^(il-)?ham/i,
    /^(il-)?i/i,
    /^(is-)?si/i
  ]
};
const matchDayPeriodPatterns$t = {
  narrow: /^(a|p|f'nofsillejl|f'nofsinhar|(ta') (godwa|wara nofsinhar|filgaxija|lejl))/i,
  any: /^([ap]\.?\s?m\.?|f'nofsillejl|f'nofsinhar|(ta') (godwa|wara nofsinhar|filgaxija|lejl))/i
};
const parseDayPeriodPatterns$t = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^f'nofsillejl/i,
    noon: /^f'nofsinhar/i,
    morning: /godwa/i,
    afternoon: /wara(\s.*)nofsinhar/i,
    evening: /filgaxija/i,
    night: /lejl/i
  }
};
const match$t = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$t,
    parsePattern: parseOrdinalNumberPattern$t,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$t,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$t,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$t,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$t,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$t,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$t,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$t,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$t,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$t,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$t,
    defaultParseWidth: "any"
  })
};
const mt = {
  code: "mt",
  formatDistance: formatDistance$t,
  formatLong: formatLong$t,
  formatRelative: formatRelative$t,
  localize: localize$t,
  match: match$t,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$s = {
  lessThanXSeconds: {
    one: "mindre enn ett sekund",
    other: "mindre enn {{count}} sekunder"
  },
  xSeconds: {
    one: "ett sekund",
    other: "{{count}} sekunder"
  },
  halfAMinute: "et halvt minutt",
  lessThanXMinutes: {
    one: "mindre enn ett minutt",
    other: "mindre enn {{count}} minutter"
  },
  xMinutes: {
    one: "ett minutt",
    other: "{{count}} minutter"
  },
  aboutXHours: {
    one: "omtrent en time",
    other: "omtrent {{count}} timer"
  },
  xHours: {
    one: "en time",
    other: "{{count}} timer"
  },
  xDays: {
    one: "en dag",
    other: "{{count}} dager"
  },
  aboutXWeeks: {
    one: "omtrent en uke",
    other: "omtrent {{count}} uker"
  },
  xWeeks: {
    one: "en uke",
    other: "{{count}} uker"
  },
  aboutXMonths: {
    one: "omtrent en mned",
    other: "omtrent {{count}} mneder"
  },
  xMonths: {
    one: "en mned",
    other: "{{count}} mneder"
  },
  aboutXYears: {
    one: "omtrent ett r",
    other: "omtrent {{count}} r"
  },
  xYears: {
    one: "ett r",
    other: "{{count}} r"
  },
  overXYears: {
    one: "over ett r",
    other: "over {{count}} r"
  },
  almostXYears: {
    one: "nesten ett r",
    other: "nesten {{count}} r"
  }
};
const formatDistance$s = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$s[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "om " + result;
    } else {
      return result + " siden";
    }
  }
  return result;
};
const dateFormats$s = {
  full: "EEEE d. MMMM y",
  long: "d. MMMM y",
  medium: "d. MMM y",
  short: "dd.MM.y"
};
const timeFormats$s = {
  full: "'kl'. HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$s = {
  full: "{{date}} 'kl.' {{time}}",
  long: "{{date}} 'kl.' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$s = {
  date: buildFormatLongFn({
    formats: dateFormats$s,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$s,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$s,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$s = {
  lastWeek: "'forrige' eeee 'kl.' p",
  yesterday: "'i gr kl.' p",
  today: "'i dag kl.' p",
  tomorrow: "'i morgen kl.' p",
  nextWeek: "EEEE 'kl.' p",
  other: "P"
};
const formatRelative$s = (token, _date, _baseDate, _options) => formatRelativeLocale$s[token];
const eraValues$s = {
  narrow: ["f.Kr.", "e.Kr."],
  abbreviated: ["f.Kr.", "e.Kr."],
  wide: ["fr Kristus", "etter Kristus"]
};
const quarterValues$s = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
const monthValues$s = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mars",
    "apr.",
    "mai",
    "juni",
    "juli",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "des."
  ],
  wide: [
    "januar",
    "februar",
    "mars",
    "april",
    "mai",
    "juni",
    "juli",
    "august",
    "september",
    "oktober",
    "november",
    "desember"
  ]
};
const dayValues$s = {
  narrow: ["S", "M", "T", "O", "T", "F", "L"],
  short: ["s", "ma", "ti", "on", "to", "fr", "l"],
  abbreviated: ["sn", "man", "tir", "ons", "tor", "fre", "lr"],
  wide: [
    "sndag",
    "mandag",
    "tirsdag",
    "onsdag",
    "torsdag",
    "fredag",
    "lrdag"
  ]
};
const dayPeriodValues$s = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "midnatt",
    noon: "middag",
    morning: "p morg.",
    afternoon: "p etterm.",
    evening: "p kvelden",
    night: "p natten"
  },
  abbreviated: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnatt",
    noon: "middag",
    morning: "p morg.",
    afternoon: "p etterm.",
    evening: "p kvelden",
    night: "p natten"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnatt",
    noon: "middag",
    morning: "p morgenen",
    afternoon: "p ettermiddagen",
    evening: "p kvelden",
    night: "p natten"
  }
};
const ordinalNumber$s = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$s = {
  ordinalNumber: ordinalNumber$s,
  era: buildLocalizeFn({
    values: eraValues$s,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$s,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$s,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$s,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$s,
    defaultWidth: "wide"
  })
};
const matchOrdinalNumberPattern$s = /^(\d+)\.?/i;
const parseOrdinalNumberPattern$s = /\d+/i;
const matchEraPatterns$s = {
  narrow: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
  abbreviated: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
  wide: /^(fr Kristus|fr vr tid|etter Kristus|vr tid)/i
};
const parseEraPatterns$s = {
  any: [/^f/i, /^e/i]
};
const matchQuarterPatterns$s = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? kvartal/i
};
const parseQuarterPatterns$s = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$s = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mars?|apr|mai|juni?|juli?|aug|sep|okt|nov|des)\.?/i,
  wide: /^(januar|februar|mars|april|mai|juni|juli|august|september|oktober|november|desember)/i
};
const parseMonthPatterns$s = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^mai/i,
    /^jun/i,
    /^jul/i,
    /^aug/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$s = {
  narrow: /^[smtofl]/i,
  short: /^(s|ma|ti|on|to|fr|l)/i,
  abbreviated: /^(sn|man|tir|ons|tor|fre|lr)/i,
  wide: /^(sndag|mandag|tirsdag|onsdag|torsdag|fredag|lrdag)/i
};
const parseDayPatterns$s = {
  any: [/^s/i, /^m/i, /^ti/i, /^o/i, /^to/i, /^f/i, /^l/i]
};
const matchDayPeriodPatterns$s = {
  narrow: /^(midnatt|middag|(p) (morgenen|ettermiddagen|kvelden|natten)|[ap])/i,
  any: /^([ap]\.?\s?m\.?|midnatt|middag|(p) (morgenen|ettermiddagen|kvelden|natten))/i
};
const parseDayPeriodPatterns$s = {
  any: {
    am: /^a(\.?\s?m\.?)?$/i,
    pm: /^p(\.?\s?m\.?)?$/i,
    midnight: /^midn/i,
    noon: /^midd/i,
    morning: /morgen/i,
    afternoon: /ettermiddag/i,
    evening: /kveld/i,
    night: /natt/i
  }
};
const match$s = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$s,
    parsePattern: parseOrdinalNumberPattern$s,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$s,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$s,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$s,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$s,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$s,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$s,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$s,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$s,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$s,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$s,
    defaultParseWidth: "any"
  })
};
const nb = {
  code: "nb",
  formatDistance: formatDistance$s,
  formatLong: formatLong$s,
  formatRelative: formatRelative$s,
  localize: localize$s,
  match: match$s,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$r = {
  lessThanXSeconds: {
    one: "minder dan een seconde",
    other: "minder dan {{count}} seconden"
  },
  xSeconds: {
    one: "1 seconde",
    other: "{{count}} seconden"
  },
  halfAMinute: "een halve minuut",
  lessThanXMinutes: {
    one: "minder dan een minuut",
    other: "minder dan {{count}} minuten"
  },
  xMinutes: {
    one: "een minuut",
    other: "{{count}} minuten"
  },
  aboutXHours: {
    one: "ongeveer 1 uur",
    other: "ongeveer {{count}} uur"
  },
  xHours: {
    one: "1 uur",
    other: "{{count}} uur"
  },
  xDays: {
    one: "1 dag",
    other: "{{count}} dagen"
  },
  aboutXWeeks: {
    one: "ongeveer 1 week",
    other: "ongeveer {{count}} weken"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weken"
  },
  aboutXMonths: {
    one: "ongeveer 1 maand",
    other: "ongeveer {{count}} maanden"
  },
  xMonths: {
    one: "1 maand",
    other: "{{count}} maanden"
  },
  aboutXYears: {
    one: "ongeveer 1 jaar",
    other: "ongeveer {{count}} jaar"
  },
  xYears: {
    one: "1 jaar",
    other: "{{count}} jaar"
  },
  overXYears: {
    one: "meer dan 1 jaar",
    other: "meer dan {{count}} jaar"
  },
  almostXYears: {
    one: "bijna 1 jaar",
    other: "bijna {{count}} jaar"
  }
};
const formatDistance$r = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$r[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "over " + result;
    } else {
      return result + " geleden";
    }
  }
  return result;
};
const dateFormats$r = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd-MM-y"
};
const timeFormats$r = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$r = {
  full: "{{date}} 'om' {{time}}",
  long: "{{date}} 'om' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$r = {
  date: buildFormatLongFn({
    formats: dateFormats$r,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$r,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$r,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$r = {
  lastWeek: "'afgelopen' eeee 'om' p",
  yesterday: "'gisteren om' p",
  today: "'vandaag om' p",
  tomorrow: "'morgen om' p",
  nextWeek: "eeee 'om' p",
  other: "P"
};
const formatRelative$r = (token, _date, _baseDate, _options) => formatRelativeLocale$r[token];
const eraValues$r = {
  narrow: ["v.C.", "n.C."],
  abbreviated: ["v.Chr.", "n.Chr."],
  wide: ["voor Christus", "na Christus"]
};
const quarterValues$r = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1e kwartaal", "2e kwartaal", "3e kwartaal", "4e kwartaal"]
};
const monthValues$r = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mrt.",
    "apr.",
    "mei",
    "jun.",
    "jul.",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "dec."
  ],
  wide: [
    "januari",
    "februari",
    "maart",
    "april",
    "mei",
    "juni",
    "juli",
    "augustus",
    "september",
    "oktober",
    "november",
    "december"
  ]
};
const dayValues$r = {
  narrow: ["Z", "M", "D", "W", "D", "V", "Z"],
  short: ["zo", "ma", "di", "wo", "do", "vr", "za"],
  abbreviated: ["zon", "maa", "din", "woe", "don", "vri", "zat"],
  wide: [
    "zondag",
    "maandag",
    "dinsdag",
    "woensdag",
    "donderdag",
    "vrijdag",
    "zaterdag"
  ]
};
const dayPeriodValues$r = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "het middaguur",
    morning: "'s ochtends",
    afternoon: "'s middags",
    evening: "'s avonds",
    night: "'s nachts"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "het middaguur",
    morning: "'s ochtends",
    afternoon: "'s middags",
    evening: "'s avonds",
    night: "'s nachts"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "het middaguur",
    morning: "'s ochtends",
    afternoon: "'s middags",
    evening: "'s avonds",
    night: "'s nachts"
  }
};
const ordinalNumber$r = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "e";
};
const localize$r = {
  ordinalNumber: ordinalNumber$r,
  era: buildLocalizeFn({
    values: eraValues$r,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$r,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$r,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$r,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$r,
    defaultWidth: "wide"
  })
};
const matchOrdinalNumberPattern$r = /^(\d+)e?/i;
const parseOrdinalNumberPattern$r = /\d+/i;
const matchEraPatterns$r = {
  narrow: /^([vn]\.? ?C\.?)/,
  abbreviated: /^([vn]\. ?Chr\.?)/,
  wide: /^((voor|na) Christus)/
};
const parseEraPatterns$r = {
  any: [/^v/, /^n/]
};
const matchQuarterPatterns$r = {
  narrow: /^[1234]/i,
  abbreviated: /^K[1234]/i,
  wide: /^[1234]e kwartaal/i
};
const parseQuarterPatterns$r = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$r = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan.|feb.|mrt.|apr.|mei|jun.|jul.|aug.|sep.|okt.|nov.|dec.)/i,
  wide: /^(januari|februari|maart|april|mei|juni|juli|augustus|september|oktober|november|december)/i
};
const parseMonthPatterns$r = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^jan/i,
    /^feb/i,
    /^m(r|a)/i,
    /^apr/i,
    /^mei/i,
    /^jun/i,
    /^jul/i,
    /^aug/i,
    /^sep/i,
    /^okt/i,
    /^nov/i,
    /^dec/i
  ]
};
const matchDayPatterns$r = {
  narrow: /^[zmdwv]/i,
  short: /^(zo|ma|di|wo|do|vr|za)/i,
  abbreviated: /^(zon|maa|din|woe|don|vri|zat)/i,
  wide: /^(zondag|maandag|dinsdag|woensdag|donderdag|vrijdag|zaterdag)/i
};
const parseDayPatterns$r = {
  narrow: [/^z/i, /^m/i, /^d/i, /^w/i, /^d/i, /^v/i, /^z/i],
  any: [/^zo/i, /^ma/i, /^di/i, /^wo/i, /^do/i, /^vr/i, /^za/i]
};
const matchDayPeriodPatterns$r = {
  any: /^(am|pm|middernacht|het middaguur|'s (ochtends|middags|avonds|nachts))/i
};
const parseDayPeriodPatterns$r = {
  any: {
    am: /^am/i,
    pm: /^pm/i,
    midnight: /^middernacht/i,
    noon: /^het middaguur/i,
    morning: /ochtend/i,
    afternoon: /middag/i,
    evening: /avond/i,
    night: /nacht/i
  }
};
const match$r = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$r,
    parsePattern: parseOrdinalNumberPattern$r,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$r,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$r,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$r,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$r,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$r,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$r,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$r,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$r,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$r,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$r,
    defaultParseWidth: "any"
  })
};
const nl = {
  code: "nl",
  formatDistance: formatDistance$r,
  formatLong: formatLong$r,
  formatRelative: formatRelative$r,
  localize: localize$r,
  match: match$r,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$q = {
  lessThanXSeconds: {
    one: "minder dan een seconde",
    other: "minder dan {{count}} seconden"
  },
  xSeconds: {
    one: "1 seconde",
    other: "{{count}} seconden"
  },
  halfAMinute: "een halve minuut",
  lessThanXMinutes: {
    one: "minder dan een minuut",
    other: "minder dan {{count}} minuten"
  },
  xMinutes: {
    one: "een minuut",
    other: "{{count}} minuten"
  },
  aboutXHours: {
    one: "ongeveer 1 uur",
    other: "ongeveer {{count}} uur"
  },
  xHours: {
    one: "1 uur",
    other: "{{count}} uur"
  },
  xDays: {
    one: "1 dag",
    other: "{{count}} dagen"
  },
  aboutXWeeks: {
    one: "ongeveer 1 week",
    other: "ongeveer {{count}} weken"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weken"
  },
  aboutXMonths: {
    one: "ongeveer 1 maand",
    other: "ongeveer {{count}} maanden"
  },
  xMonths: {
    one: "1 maand",
    other: "{{count}} maanden"
  },
  aboutXYears: {
    one: "ongeveer 1 jaar",
    other: "ongeveer {{count}} jaar"
  },
  xYears: {
    one: "1 jaar",
    other: "{{count}} jaar"
  },
  overXYears: {
    one: "meer dan 1 jaar",
    other: "meer dan {{count}} jaar"
  },
  almostXYears: {
    one: "bijna 1 jaar",
    other: "bijna {{count}} jaar"
  }
};
const formatDistance$q = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$q[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "over " + result;
    } else {
      return result + " geleden";
    }
  }
  return result;
};
const dateFormats$q = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd.MM.y"
};
const timeFormats$q = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$q = {
  full: "{{date}} 'om' {{time}}",
  long: "{{date}} 'om' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$q = {
  date: buildFormatLongFn({
    formats: dateFormats$q,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$q,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$q,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$q = {
  lastWeek: "'vorige' eeee 'om' p",
  yesterday: "'gisteren om' p",
  today: "'vandaag om' p",
  tomorrow: "'morgen om' p",
  nextWeek: "eeee 'om' p",
  other: "P"
};
const formatRelative$q = (token, _date, _baseDate, _options) => formatRelativeLocale$q[token];
const eraValues$q = {
  narrow: ["v.C.", "n.C."],
  abbreviated: ["v.Chr.", "n.Chr."],
  wide: ["voor Christus", "na Christus"]
};
const quarterValues$q = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1e kwartaal", "2e kwartaal", "3e kwartaal", "4e kwartaal"]
};
const monthValues$q = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mrt.",
    "apr.",
    "mei",
    "jun.",
    "jul.",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "dec."
  ],
  wide: [
    "januari",
    "februari",
    "maart",
    "april",
    "mei",
    "juni",
    "juli",
    "augustus",
    "september",
    "oktober",
    "november",
    "december"
  ]
};
const dayValues$q = {
  narrow: ["Z", "M", "D", "W", "D", "V", "Z"],
  short: ["zo", "ma", "di", "wo", "do", "vr", "za"],
  abbreviated: ["zon", "maa", "din", "woe", "don", "vri", "zat"],
  wide: [
    "zondag",
    "maandag",
    "dinsdag",
    "woensdag",
    "donderdag",
    "vrijdag",
    "zaterdag"
  ]
};
const dayPeriodValues$q = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "het middag",
    morning: "'s ochtends",
    afternoon: "'s namiddags",
    evening: "'s avonds",
    night: "'s nachts"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "het middag",
    morning: "'s ochtends",
    afternoon: "'s namiddags",
    evening: "'s avonds",
    night: "'s nachts"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "het middag",
    morning: "'s ochtends",
    afternoon: "'s namiddags",
    evening: "'s avonds",
    night: "'s nachts"
  }
};
const ordinalNumber$q = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "e";
};
const localize$q = {
  ordinalNumber: ordinalNumber$q,
  era: buildLocalizeFn({
    values: eraValues$q,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$q,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$q,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$q,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$q,
    defaultWidth: "wide"
  })
};
const matchOrdinalNumberPattern$q = /^(\d+)e?/i;
const parseOrdinalNumberPattern$q = /\d+/i;
const matchEraPatterns$q = {
  narrow: /^([vn]\.? ?C\.?)/,
  abbreviated: /^([vn]\. ?Chr\.?)/,
  wide: /^((voor|na) Christus)/
};
const parseEraPatterns$q = {
  any: [/^v/, /^n/]
};
const matchQuarterPatterns$q = {
  narrow: /^[1234]/i,
  abbreviated: /^K[1234]/i,
  wide: /^[1234]e kwartaal/i
};
const parseQuarterPatterns$q = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$q = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan.|feb.|mrt.|apr.|mei|jun.|jul.|aug.|sep.|okt.|nov.|dec.)/i,
  wide: /^(januari|februari|maart|april|mei|juni|juli|augustus|september|oktober|november|december)/i
};
const parseMonthPatterns$q = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^jan/i,
    /^feb/i,
    /^m(r|a)/i,
    /^apr/i,
    /^mei/i,
    /^jun/i,
    /^jul/i,
    /^aug/i,
    /^sep/i,
    /^okt/i,
    /^nov/i,
    /^dec/i
  ]
};
const matchDayPatterns$q = {
  narrow: /^[zmdwv]/i,
  short: /^(zo|ma|di|wo|do|vr|za)/i,
  abbreviated: /^(zon|maa|din|woe|don|vri|zat)/i,
  wide: /^(zondag|maandag|dinsdag|woensdag|donderdag|vrijdag|zaterdag)/i
};
const parseDayPatterns$q = {
  narrow: [/^z/i, /^m/i, /^d/i, /^w/i, /^d/i, /^v/i, /^z/i],
  any: [/^zo/i, /^ma/i, /^di/i, /^wo/i, /^do/i, /^vr/i, /^za/i]
};
const matchDayPeriodPatterns$q = {
  any: /^(am|pm|middernacht|het middaguur|'s (ochtends|middags|avonds|nachts))/i
};
const parseDayPeriodPatterns$q = {
  any: {
    am: /^am/i,
    pm: /^pm/i,
    midnight: /^middernacht/i,
    noon: /^het middaguur/i,
    morning: /ochtend/i,
    afternoon: /middag/i,
    evening: /avond/i,
    night: /nacht/i
  }
};
const match$q = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$q,
    parsePattern: parseOrdinalNumberPattern$q,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$q,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$q,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$q,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$q,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$q,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$q,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$q,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$q,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$q,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$q,
    defaultParseWidth: "any"
  })
};
const nlBE = {
  code: "nl-BE",
  formatDistance: formatDistance$q,
  formatLong: formatLong$q,
  formatRelative: formatRelative$q,
  localize: localize$q,
  match: match$q,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$p = {
  lessThanXSeconds: {
    one: "mindre enn eitt sekund",
    other: "mindre enn {{count}} sekund"
  },
  xSeconds: {
    one: "eitt sekund",
    other: "{{count}} sekund"
  },
  halfAMinute: "eit halvt minutt",
  lessThanXMinutes: {
    one: "mindre enn eitt minutt",
    other: "mindre enn {{count}} minutt"
  },
  xMinutes: {
    one: "eitt minutt",
    other: "{{count}} minutt"
  },
  aboutXHours: {
    one: "omtrent ein time",
    other: "omtrent {{count}} timar"
  },
  xHours: {
    one: "ein time",
    other: "{{count}} timar"
  },
  xDays: {
    one: "ein dag",
    other: "{{count}} dagar"
  },
  aboutXWeeks: {
    one: "omtrent ei veke",
    other: "omtrent {{count}} veker"
  },
  xWeeks: {
    one: "ei veke",
    other: "{{count}} veker"
  },
  aboutXMonths: {
    one: "omtrent ein mnad",
    other: "omtrent {{count}} mnader"
  },
  xMonths: {
    one: "ein mnad",
    other: "{{count}} mnader"
  },
  aboutXYears: {
    one: "omtrent eitt r",
    other: "omtrent {{count}} r"
  },
  xYears: {
    one: "eitt r",
    other: "{{count}} r"
  },
  overXYears: {
    one: "over eitt r",
    other: "over {{count}} r"
  },
  almostXYears: {
    one: "nesten eitt r",
    other: "nesten {{count}} r"
  }
};
const wordMapping$1 = [
  "null",
  "ein",
  "to",
  "tre",
  "fire",
  "fem",
  "seks",
  "sju",
  "tte",
  "ni",
  "ti",
  "elleve",
  "tolv"
];
const formatDistance$p = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$p[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace(
      "{{count}}",
      count < 13 ? wordMapping$1[count] : String(count)
    );
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "om " + result;
    } else {
      return result + " sidan";
    }
  }
  return result;
};
const dateFormats$p = {
  full: "EEEE d. MMMM y",
  long: "d. MMMM y",
  medium: "d. MMM y",
  short: "dd.MM.y"
};
const timeFormats$p = {
  full: "'kl'. HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$p = {
  full: "{{date}} 'kl.' {{time}}",
  long: "{{date}} 'kl.' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$p = {
  date: buildFormatLongFn({
    formats: dateFormats$p,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$p,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$p,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$p = {
  lastWeek: "'frre' eeee 'kl.' p",
  yesterday: "'i gr kl.' p",
  today: "'i dag kl.' p",
  tomorrow: "'i morgon kl.' p",
  nextWeek: "EEEE 'kl.' p",
  other: "P"
};
const formatRelative$p = (token, _date, _baseDate, _options) => formatRelativeLocale$p[token];
const eraValues$p = {
  narrow: ["f.Kr.", "e.Kr."],
  abbreviated: ["f.Kr.", "e.Kr."],
  wide: ["fr Kristus", "etter Kristus"]
};
const quarterValues$p = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
const monthValues$p = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mars",
    "apr.",
    "mai",
    "juni",
    "juli",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "des."
  ],
  wide: [
    "januar",
    "februar",
    "mars",
    "april",
    "mai",
    "juni",
    "juli",
    "august",
    "september",
    "oktober",
    "november",
    "desember"
  ]
};
const dayValues$p = {
  narrow: ["S", "M", "T", "O", "T", "F", "L"],
  short: ["su", "m", "ty", "on", "to", "fr", "lau"],
  abbreviated: ["sun", "mn", "tys", "ons", "tor", "fre", "laur"],
  wide: [
    "sundag",
    "mndag",
    "tysdag",
    "onsdag",
    "torsdag",
    "fredag",
    "laurdag"
  ]
};
const dayPeriodValues$p = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "midnatt",
    noon: "middag",
    morning: "p morg.",
    afternoon: "p etterm.",
    evening: "p kvelden",
    night: "p natta"
  },
  abbreviated: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnatt",
    noon: "middag",
    morning: "p morg.",
    afternoon: "p etterm.",
    evening: "p kvelden",
    night: "p natta"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnatt",
    noon: "middag",
    morning: "p morgonen",
    afternoon: "p ettermiddagen",
    evening: "p kvelden",
    night: "p natta"
  }
};
const ordinalNumber$p = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$p = {
  ordinalNumber: ordinalNumber$p,
  era: buildLocalizeFn({
    values: eraValues$p,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$p,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$p,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$p,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$p,
    defaultWidth: "wide"
  })
};
const matchOrdinalNumberPattern$p = /^(\d+)\.?/i;
const parseOrdinalNumberPattern$p = /\d+/i;
const matchEraPatterns$p = {
  narrow: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
  abbreviated: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
  wide: /^(fr Kristus|fr vr tid|etter Kristus|vr tid)/i
};
const parseEraPatterns$p = {
  any: [/^f/i, /^e/i]
};
const matchQuarterPatterns$p = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? kvartal/i
};
const parseQuarterPatterns$p = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$p = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mars?|apr|mai|juni?|juli?|aug|sep|okt|nov|des)\.?/i,
  wide: /^(januar|februar|mars|april|mai|juni|juli|august|september|oktober|november|desember)/i
};
const parseMonthPatterns$p = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^mai/i,
    /^jun/i,
    /^jul/i,
    /^aug/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$p = {
  narrow: /^[smtofl]/i,
  short: /^(su|m|ty|on|to|fr|la)/i,
  abbreviated: /^(sun|mn|tys|ons|tor|fre|laur)/i,
  wide: /^(sundag|mndag|tysdag|onsdag|torsdag|fredag|laurdag)/i
};
const parseDayPatterns$p = {
  any: [/^s/i, /^m/i, /^ty/i, /^o/i, /^to/i, /^f/i, /^l/i]
};
const matchDayPeriodPatterns$p = {
  narrow: /^(midnatt|middag|(p) (morgonen|ettermiddagen|kvelden|natta)|[ap])/i,
  any: /^([ap]\.?\s?m\.?|midnatt|middag|(p) (morgonen|ettermiddagen|kvelden|natta))/i
};
const parseDayPeriodPatterns$p = {
  any: {
    am: /^a(\.?\s?m\.?)?$/i,
    pm: /^p(\.?\s?m\.?)?$/i,
    midnight: /^midn/i,
    noon: /^midd/i,
    morning: /morgon/i,
    afternoon: /ettermiddag/i,
    evening: /kveld/i,
    night: /natt/i
  }
};
const match$p = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$p,
    parsePattern: parseOrdinalNumberPattern$p,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$p,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$p,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$p,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$p,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$p,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$p,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$p,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$p,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$p,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$p,
    defaultParseWidth: "any"
  })
};
const nn = {
  code: "nn",
  formatDistance: formatDistance$p,
  formatLong: formatLong$p,
  formatRelative: formatRelative$p,
  localize: localize$p,
  match: match$p,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$o = {
  lessThanXSeconds: {
    one: "mens duna segonda",
    other: "mens de {{count}} segondas"
  },
  xSeconds: {
    one: "1 segonda",
    other: "{{count}} segondas"
  },
  halfAMinute: "30 segondas",
  lessThanXMinutes: {
    one: "mens duna minuta",
    other: "mens de {{count}} minutas"
  },
  xMinutes: {
    one: "1 minuta",
    other: "{{count}} minutas"
  },
  aboutXHours: {
    one: "environ 1 ora",
    other: "environ {{count}} oras"
  },
  xHours: {
    one: "1 ora",
    other: "{{count}} oras"
  },
  xDays: {
    one: "1 jorn",
    other: "{{count}} jorns"
  },
  aboutXWeeks: {
    one: "environ 1 setmana",
    other: "environ {{count}} setmanas"
  },
  xWeeks: {
    one: "1 setmana",
    other: "{{count}} setmanas"
  },
  aboutXMonths: {
    one: "environ 1 mes",
    other: "environ {{count}} meses"
  },
  xMonths: {
    one: "1 mes",
    other: "{{count}} meses"
  },
  aboutXYears: {
    one: "environ 1 an",
    other: "environ {{count}} ans"
  },
  xYears: {
    one: "1 an",
    other: "{{count}} ans"
  },
  overXYears: {
    one: "mai dun an",
    other: "mai de {{count}} ans"
  },
  almostXYears: {
    one: "gaireben un an",
    other: "gaireben {{count}} ans"
  }
};
const formatDistance$o = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$o[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "daqu " + result;
    } else {
      return "fa " + result;
    }
  }
  return result;
};
const dateFormats$o = {
  full: "EEEE d 'de' MMMM y",
  long: "d 'de' MMMM y",
  medium: "d MMM y",
  short: "dd/MM/y"
};
const timeFormats$o = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$o = {
  full: "{{date}} 'a' {{time}}",
  long: "{{date}} 'a' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$o = {
  date: buildFormatLongFn({
    formats: dateFormats$o,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$o,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$o,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$o = {
  lastWeek: "eeee 'passat a' p",
  yesterday: "'ir a' p",
  today: "'ui a' p",
  tomorrow: "'deman a' p",
  nextWeek: "eeee 'a' p",
  other: "P"
};
const formatRelative$o = (token, _date, _baseDate, _options) => formatRelativeLocale$o[token];
const eraValues$o = {
  narrow: ["ab. J.C.", "apr. J.C."],
  abbreviated: ["ab. J.C.", "apr. J.C."],
  wide: ["abans Jsus-Crist", "aprs Jsus-Crist"]
};
const quarterValues$o = {
  narrow: ["T1", "T2", "T3", "T4"],
  abbreviated: ["1r trim.", "2nd trim.", "3en trim.", "4en trim."],
  wide: ["1r trimstre", "2nd trimstre", "3en trimstre", "4en trimstre"]
};
const monthValues$o = {
  narrow: [
    "GN",
    "FB",
    "M",
    "AB",
    "MA",
    "JN",
    "JL",
    "AG",
    "ST",
    "OC",
    "NV",
    "DC"
  ],
  abbreviated: [
    "gen.",
    "febr.",
    "mar",
    "abr.",
    "mai",
    "junh",
    "jul.",
    "ag.",
    "set.",
    "oct.",
    "nov.",
    "dec."
  ],
  wide: [
    "genir",
    "febrir",
    "mar",
    "abril",
    "mai",
    "junh",
    "julhet",
    "agost",
    "setembre",
    "octbre",
    "novembre",
    "decembre"
  ]
};
const dayValues$o = {
  narrow: ["dg.", "dl.", "dm.", "dc.", "dj.", "dv.", "ds."],
  short: ["dg.", "dl.", "dm.", "dc.", "dj.", "dv.", "ds."],
  abbreviated: ["dg.", "dl.", "dm.", "dc.", "dj.", "dv.", "ds."],
  wide: [
    "dimenge",
    "diluns",
    "dimars",
    "dimcres",
    "dijus",
    "divendres",
    "dissabte"
  ]
};
const dayPeriodValues$o = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "mijanuch",
    noon: "migjorn",
    morning: "matin",
    afternoon: "aprp-migjorn",
    evening: "vspre",
    night: "nuch"
  },
  abbreviated: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "mijanuch",
    noon: "migjorn",
    morning: "matin",
    afternoon: "aprp-migjorn",
    evening: "vspre",
    night: "nuch"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "mijanuch",
    noon: "migjorn",
    morning: "matin",
    afternoon: "aprp-migjorn",
    evening: "vspre",
    night: "nuch"
  }
};
const formattingDayPeriodValues$m = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "mijanuch",
    noon: "migjorn",
    morning: "del matin",
    afternoon: "de laprp-migjorn",
    evening: "del ser",
    night: "de la nuch"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "mijanuch",
    noon: "migjorn",
    morning: "del matin",
    afternoon: "de laprp-migjorn",
    evening: "del ser",
    night: "de la nuch"
  },
  wide: {
    am: "ante meridiem",
    pm: "post meridiem",
    midnight: "mijanuch",
    noon: "migjorn",
    morning: "del matin",
    afternoon: "de laprp-migjorn",
    evening: "del ser",
    night: "de la nuch"
  }
};
const ordinalNumber$o = (dirtyNumber, options) => {
  const number2 = Number(dirtyNumber);
  const unit = options?.unit;
  let ordinal;
  switch (number2) {
    case 1:
      ordinal = "r";
      break;
    case 2:
      ordinal = "nd";
      break;
    default:
      ordinal = "en";
  }
  if (unit === "year" || unit === "week" || unit === "hour" || unit === "minute" || unit === "second") {
    ordinal += "a";
  }
  return number2 + ordinal;
};
const localize$o = {
  ordinalNumber: ordinalNumber$o,
  era: buildLocalizeFn({
    values: eraValues$o,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$o,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$o,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$o,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$o,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$m,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$o = /^(\d+)(r|nd|en)?[a]?/i;
const parseOrdinalNumberPattern$o = /\d+/i;
const matchEraPatterns$o = {
  narrow: /^(ab\.J\.C|apr\.J\.C|apr\.J\.-C)/i,
  abbreviated: /^(ab\.J\.-C|ab\.J-C|apr\.J\.-C|apr\.J-C|ap\.J-C)/i,
  wide: /^(abans Jsus-Crist|aprs Jsus-Crist)/i
};
const parseEraPatterns$o = {
  any: [/^ab/i, /^ap/i]
};
const matchQuarterPatterns$o = {
  narrow: /^T[1234]/i,
  abbreviated: /^[1234](r|nd|en)? trim\.?/i,
  wide: /^[1234](r|nd|en)? trimstre/i
};
const parseQuarterPatterns$o = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$o = {
  narrow: /^(GN|FB|M|AB|MA|JN|JL|AG|ST|OC|NV|DC)/i,
  abbreviated: /^(gen|febr|mar|abr|mai|junh|jul|ag|set|oct|nov|dec)\.?/i,
  wide: /^(genir|febrir|mar|abril|mai|junh|julhet|agost|setembre|octbre|novembre|decembre)/i
};
const parseMonthPatterns$o = {
  any: [
    /^g/i,
    /^f/i,
    /^ma[r?]|M/i,
    /^ab/i,
    /^ma[i?]/i,
    /^ju[n?]|JN/i,
    /^ju[l?]|JL/i,
    /^ag/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$o = {
  narrow: /^d[glmcjvs]\.?/i,
  short: /^d[glmcjvs]\.?/i,
  abbreviated: /^d[glmcjvs]\.?/i,
  wide: /^(dimenge|diluns|dimars|dimcres|dijus|divendres|dissabte)/i
};
const parseDayPatterns$o = {
  narrow: [/^dg/i, /^dl/i, /^dm/i, /^dc/i, /^dj/i, /^dv/i, /^ds/i],
  short: [/^dg/i, /^dl/i, /^dm/i, /^dc/i, /^dj/i, /^dv/i, /^ds/i],
  abbreviated: [/^dg/i, /^dl/i, /^dm/i, /^dc/i, /^dj/i, /^dv/i, /^ds/i],
  any: [
    /^dg|dime/i,
    /^dl|dil/i,
    /^dm|dima/i,
    /^dc|dim/i,
    /^dj|dij/i,
    /^dv|div/i,
    /^ds|dis/i
  ]
};
const matchDayPeriodPatterns$o = {
  any: /(^(a\.?m|p\.?m))|(ante meridiem|post meridiem)|((del |de la |de l)(matin|aprp-migjorn|vspre|ser|nuch))/i
};
const parseDayPeriodPatterns$o = {
  any: {
    am: /(^a)|ante meridiem/i,
    pm: /(^p)|post meridiem/i,
    midnight: /^mij/i,
    noon: /^mig/i,
    morning: /matin/i,
    afternoon: /aprp-migjorn/i,
    evening: /vspre|ser/i,
    night: /nuch/i
  }
};
const match$o = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$o,
    parsePattern: parseOrdinalNumberPattern$o,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$o,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$o,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$o,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$o,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$o,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$o,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$o,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$o,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$o,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$o,
    defaultParseWidth: "any"
  })
};
const oc = {
  code: "oc",
  formatDistance: formatDistance$o,
  formatLong: formatLong$o,
  formatRelative: formatRelative$o,
  localize: localize$o,
  match: match$o,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$n = {
  lessThanXSeconds: {
    one: {
      regular: "mniej ni sekunda",
      past: "mniej ni sekund",
      future: "mniej ni sekund"
    },
    twoFour: "mniej ni {{count}} sekundy",
    other: "mniej ni {{count}} sekund"
  },
  xSeconds: {
    one: {
      regular: "sekunda",
      past: "sekund",
      future: "sekund"
    },
    twoFour: "{{count}} sekundy",
    other: "{{count}} sekund"
  },
  halfAMinute: {
    one: "p minuty",
    twoFour: "p minuty",
    other: "p minuty"
  },
  lessThanXMinutes: {
    one: {
      regular: "mniej ni minuta",
      past: "mniej ni minut",
      future: "mniej ni minut"
    },
    twoFour: "mniej ni {{count}} minuty",
    other: "mniej ni {{count}} minut"
  },
  xMinutes: {
    one: {
      regular: "minuta",
      past: "minut",
      future: "minut"
    },
    twoFour: "{{count}} minuty",
    other: "{{count}} minut"
  },
  aboutXHours: {
    one: {
      regular: "okoo godziny",
      past: "okoo godziny",
      future: "okoo godzin"
    },
    twoFour: "okoo {{count}} godziny",
    other: "okoo {{count}} godzin"
  },
  xHours: {
    one: {
      regular: "godzina",
      past: "godzin",
      future: "godzin"
    },
    twoFour: "{{count}} godziny",
    other: "{{count}} godzin"
  },
  xDays: {
    one: {
      regular: "dzie",
      past: "dzie",
      future: "1 dzie"
    },
    twoFour: "{{count}} dni",
    other: "{{count}} dni"
  },
  aboutXWeeks: {
    one: "okoo tygodnia",
    twoFour: "okoo {{count}} tygodni",
    other: "okoo {{count}} tygodni"
  },
  xWeeks: {
    one: "tydzie",
    twoFour: "{{count}} tygodnie",
    other: "{{count}} tygodni"
  },
  aboutXMonths: {
    one: "okoo miesic",
    twoFour: "okoo {{count}} miesice",
    other: "okoo {{count}} miesicy"
  },
  xMonths: {
    one: "miesic",
    twoFour: "{{count}} miesice",
    other: "{{count}} miesicy"
  },
  aboutXYears: {
    one: "okoo rok",
    twoFour: "okoo {{count}} lata",
    other: "okoo {{count}} lat"
  },
  xYears: {
    one: "rok",
    twoFour: "{{count}} lata",
    other: "{{count}} lat"
  },
  overXYears: {
    one: "ponad rok",
    twoFour: "ponad {{count}} lata",
    other: "ponad {{count}} lat"
  },
  almostXYears: {
    one: "prawie rok",
    twoFour: "prawie {{count}} lata",
    other: "prawie {{count}} lat"
  }
};
function declensionGroup$1(scheme2, count) {
  if (count === 1) {
    return scheme2.one;
  }
  const rem100 = count % 100;
  if (rem100 <= 20 && rem100 > 10) {
    return scheme2.other;
  }
  const rem10 = rem100 % 10;
  if (rem10 >= 2 && rem10 <= 4) {
    return scheme2.twoFour;
  }
  return scheme2.other;
}
function declension$3(scheme2, count, time) {
  const group = declensionGroup$1(scheme2, count);
  const finalText = typeof group === "string" ? group : group[time];
  return finalText.replace("{{count}}", String(count));
}
const formatDistance$n = (token, count, options) => {
  const scheme2 = formatDistanceLocale$n[token];
  if (!options?.addSuffix) {
    return declension$3(scheme2, count, "regular");
  }
  if (options.comparison && options.comparison > 0) {
    return "za " + declension$3(scheme2, count, "future");
  } else {
    return declension$3(scheme2, count, "past") + " temu";
  }
};
const dateFormats$n = {
  full: "EEEE, do MMMM y",
  long: "do MMMM y",
  medium: "do MMM y",
  short: "dd.MM.y"
};
const timeFormats$n = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$n = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$n = {
  date: buildFormatLongFn({
    formats: dateFormats$n,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$n,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$n,
    defaultWidth: "full"
  })
};
const adjectivesLastWeek = {
  masculine: "ostatni",
  feminine: "ostatnia"
};
const adjectivesThisWeek = {
  masculine: "ten",
  feminine: "ta"
};
const adjectivesNextWeek = {
  masculine: "nastpny",
  feminine: "nastpna"
};
const dayGrammaticalGender = {
  0: "feminine",
  1: "masculine",
  2: "masculine",
  3: "feminine",
  4: "masculine",
  5: "masculine",
  6: "feminine"
};
function dayAndTimeWithAdjective(token, date2, baseDate, options) {
  let adjectives;
  if (isSameWeek(date2, baseDate, options)) {
    adjectives = adjectivesThisWeek;
  } else if (token === "lastWeek") {
    adjectives = adjectivesLastWeek;
  } else if (token === "nextWeek") {
    adjectives = adjectivesNextWeek;
  } else {
    throw new Error(`Cannot determine adjectives for token ${token}`);
  }
  const day = date2.getDay();
  const grammaticalGender = dayGrammaticalGender[day];
  const adjective = adjectives[grammaticalGender];
  return `'${adjective}' eeee 'o' p`;
}
const formatRelativeLocale$n = {
  lastWeek: dayAndTimeWithAdjective,
  yesterday: "'wczoraj o' p",
  today: "'dzisiaj o' p",
  tomorrow: "'jutro o' p",
  nextWeek: dayAndTimeWithAdjective,
  other: "P"
};
const formatRelative$n = (token, date2, baseDate, options) => {
  const format2 = formatRelativeLocale$n[token];
  if (typeof format2 === "function") {
    return format2(token, date2, baseDate, options);
  }
  return format2;
};
const eraValues$n = {
  narrow: ["p.n.e.", "n.e."],
  abbreviated: ["p.n.e.", "n.e."],
  wide: ["przed nasz er", "naszej ery"]
};
const quarterValues$n = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["I kw.", "II kw.", "III kw.", "IV kw."],
  wide: ["I kwarta", "II kwarta", "III kwarta", "IV kwarta"]
};
const monthValues$n = {
  narrow: ["S", "L", "M", "K", "M", "C", "L", "S", "W", "P", "L", "G"],
  abbreviated: [
    "sty",
    "lut",
    "mar",
    "kwi",
    "maj",
    "cze",
    "lip",
    "sie",
    "wrz",
    "pa",
    "lis",
    "gru"
  ],
  wide: [
    "stycze",
    "luty",
    "marzec",
    "kwiecie",
    "maj",
    "czerwiec",
    "lipiec",
    "sierpie",
    "wrzesie",
    "padziernik",
    "listopad",
    "grudzie"
  ]
};
const monthFormattingValues = {
  narrow: ["s", "l", "m", "k", "m", "c", "l", "s", "w", "p", "l", "g"],
  abbreviated: [
    "sty",
    "lut",
    "mar",
    "kwi",
    "maj",
    "cze",
    "lip",
    "sie",
    "wrz",
    "pa",
    "lis",
    "gru"
  ],
  wide: [
    "stycznia",
    "lutego",
    "marca",
    "kwietnia",
    "maja",
    "czerwca",
    "lipca",
    "sierpnia",
    "wrzenia",
    "padziernika",
    "listopada",
    "grudnia"
  ]
};
const dayValues$n = {
  narrow: ["N", "P", "W", "", "C", "P", "S"],
  short: ["nie", "pon", "wto", "ro", "czw", "pi", "sob"],
  abbreviated: ["niedz.", "pon.", "wt.", "r.", "czw.", "pt.", "sob."],
  wide: [
    "niedziela",
    "poniedziaek",
    "wtorek",
    "roda",
    "czwartek",
    "pitek",
    "sobota"
  ]
};
const dayFormattingValues = {
  narrow: ["n", "p", "w", "", "c", "p", "s"],
  short: ["nie", "pon", "wto", "ro", "czw", "pi", "sob"],
  abbreviated: ["niedz.", "pon.", "wt.", "r.", "czw.", "pt.", "sob."],
  wide: [
    "niedziela",
    "poniedziaek",
    "wtorek",
    "roda",
    "czwartek",
    "pitek",
    "sobota"
  ]
};
const dayPeriodValues$n = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "pn.",
    noon: "po",
    morning: "rano",
    afternoon: "popo.",
    evening: "wiecz.",
    night: "noc"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "pnoc",
    noon: "poudnie",
    morning: "rano",
    afternoon: "popoudnie",
    evening: "wieczr",
    night: "noc"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "pnoc",
    noon: "poudnie",
    morning: "rano",
    afternoon: "popoudnie",
    evening: "wieczr",
    night: "noc"
  }
};
const dayPeriodFormattingValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "o pn.",
    noon: "w po.",
    morning: "rano",
    afternoon: "po po.",
    evening: "wiecz.",
    night: "w nocy"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "o pnocy",
    noon: "w poudnie",
    morning: "rano",
    afternoon: "po poudniu",
    evening: "wieczorem",
    night: "w nocy"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "o pnocy",
    noon: "w poudnie",
    morning: "rano",
    afternoon: "po poudniu",
    evening: "wieczorem",
    night: "w nocy"
  }
};
const ordinalNumber$n = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
const localize$n = {
  ordinalNumber: ordinalNumber$n,
  era: buildLocalizeFn({
    values: eraValues$n,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$n,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$n,
    defaultWidth: "wide",
    formattingValues: monthFormattingValues,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$n,
    defaultWidth: "wide",
    formattingValues: dayFormattingValues,
    defaultFormattingWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$n,
    defaultWidth: "wide",
    formattingValues: dayPeriodFormattingValues,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$n = /^(\d+)?/i;
const parseOrdinalNumberPattern$n = /\d+/i;
const matchEraPatterns$n = {
  narrow: /^(p\.?\s*n\.?\s*e\.?\s*|n\.?\s*e\.?\s*)/i,
  abbreviated: /^(p\.?\s*n\.?\s*e\.?\s*|n\.?\s*e\.?\s*)/i,
  wide: /^(przed\s*nasz(|a)\s*er(|a)|naszej\s*ery)/i
};
const parseEraPatterns$n = {
  any: [/^p/i, /^n/i]
};
const matchQuarterPatterns$n = {
  narrow: /^[1234]/i,
  abbreviated: /^(I|II|III|IV)\s*kw\.?/i,
  wide: /^(I|II|III|IV)\s*kwarta(|l)/i
};
const parseQuarterPatterns$n = {
  narrow: [/1/i, /2/i, /3/i, /4/i],
  any: [/^I kw/i, /^II kw/i, /^III kw/i, /^IV kw/i]
};
const matchMonthPatterns$n = {
  narrow: /^[slmkcwpg]/i,
  abbreviated: /^(sty|lut|mar|kwi|maj|cze|lip|sie|wrz|pa(|z)|lis|gru)/i,
  wide: /^(stycznia|stycze(|n)|lutego|luty|marca|marzec|kwietnia|kwiecie(|n)|maja|maj|czerwca|czerwiec|lipca|lipiec|sierpnia|sierpie(|n)|wrze(|s)nia|wrzesie(|n)|pa(|z)dziernika|pa(|z)dziernik|listopada|listopad|grudnia|grudzie(|n))/i
};
const parseMonthPatterns$n = {
  narrow: [
    /^s/i,
    /^l/i,
    /^m/i,
    /^k/i,
    /^m/i,
    /^c/i,
    /^l/i,
    /^s/i,
    /^w/i,
    /^p/i,
    /^l/i,
    /^g/i
  ],
  any: [
    /^st/i,
    /^lu/i,
    /^mar/i,
    /^k/i,
    /^maj/i,
    /^c/i,
    /^lip/i,
    /^si/i,
    /^w/i,
    /^p/i,
    /^lis/i,
    /^g/i
  ]
};
const matchDayPatterns$n = {
  narrow: /^[npwcs]/i,
  short: /^(nie|pon|wto|(|s)ro|czw|pi(|a)|sob)/i,
  abbreviated: /^(niedz|pon|wt|(|s)r|czw|pt|sob)\.?/i,
  wide: /^(niedziela|poniedzia(|l)ek|wtorek|(|s)roda|czwartek|pi(|a)tek|sobota)/i
};
const parseDayPatterns$n = {
  narrow: [/^n/i, /^p/i, /^w/i, /^/i, /^c/i, /^p/i, /^s/i],
  abbreviated: [/^n/i, /^po/i, /^w/i, /^(|s)r/i, /^c/i, /^pt/i, /^so/i],
  any: [/^n/i, /^po/i, /^w/i, /^(|s)r/i, /^c/i, /^pi/i, /^so/i]
};
const matchDayPeriodPatterns$n = {
  narrow: /^(^a$|^p$|p(|l)n\.?|o\s*p(|l)n\.?|po(|l)\.?|w\s*po(|l)\.?|po\s*po(|l)\.?|rano|wiecz\.?|noc|w\s*nocy)/i,
  any: /^(am|pm|p(|l)noc|o\s*p(|l)nocy|po(|l)udnie|w\s*po(|l)udnie|popo(|l)udnie|po\s*po(|l)udniu|rano|wieczr|wieczorem|noc|w\s*nocy)/i
};
const parseDayPeriodPatterns$n = {
  narrow: {
    am: /^a$/i,
    pm: /^p$/i,
    midnight: /p(|l)n/i,
    noon: /po(|l)/i,
    morning: /rano/i,
    afternoon: /po\s*po(|l)/i,
    evening: /wiecz/i,
    night: /noc/i
  },
  any: {
    am: /^am/i,
    pm: /^pm/i,
    midnight: /p(|l)n/i,
    noon: /po(|l)/i,
    morning: /rano/i,
    afternoon: /po\s*po(|l)/i,
    evening: /wiecz/i,
    night: /noc/i
  }
};
const match$n = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$n,
    parsePattern: parseOrdinalNumberPattern$n,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$n,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$n,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$n,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$n,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$n,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$n,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$n,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$n,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$n,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$n,
    defaultParseWidth: "any"
  })
};
const pl = {
  code: "pl",
  formatDistance: formatDistance$n,
  formatLong: formatLong$n,
  formatRelative: formatRelative$n,
  localize: localize$n,
  match: match$n,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$m = {
  lessThanXSeconds: {
    one: "menos de um segundo",
    other: "menos de {{count}} segundos"
  },
  xSeconds: {
    one: "1 segundo",
    other: "{{count}} segundos"
  },
  halfAMinute: "meio minuto",
  lessThanXMinutes: {
    one: "menos de um minuto",
    other: "menos de {{count}} minutos"
  },
  xMinutes: {
    one: "1 minuto",
    other: "{{count}} minutos"
  },
  aboutXHours: {
    one: "aproximadamente 1 hora",
    other: "aproximadamente {{count}} horas"
  },
  xHours: {
    one: "1 hora",
    other: "{{count}} horas"
  },
  xDays: {
    one: "1 dia",
    other: "{{count}} dias"
  },
  aboutXWeeks: {
    one: "aproximadamente 1 semana",
    other: "aproximadamente {{count}} semanas"
  },
  xWeeks: {
    one: "1 semana",
    other: "{{count}} semanas"
  },
  aboutXMonths: {
    one: "aproximadamente 1 ms",
    other: "aproximadamente {{count}} meses"
  },
  xMonths: {
    one: "1 ms",
    other: "{{count}} meses"
  },
  aboutXYears: {
    one: "aproximadamente 1 ano",
    other: "aproximadamente {{count}} anos"
  },
  xYears: {
    one: "1 ano",
    other: "{{count}} anos"
  },
  overXYears: {
    one: "mais de 1 ano",
    other: "mais de {{count}} anos"
  },
  almostXYears: {
    one: "quase 1 ano",
    other: "quase {{count}} anos"
  }
};
const formatDistance$m = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$m[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "daqui a " + result;
    } else {
      return "h " + result;
    }
  }
  return result;
};
const dateFormats$m = {
  full: "EEEE, d 'de' MMMM 'de' y",
  long: "d 'de' MMMM 'de' y",
  medium: "d 'de' MMM 'de' y",
  short: "dd/MM/y"
};
const timeFormats$m = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$m = {
  full: "{{date}} 's' {{time}}",
  long: "{{date}} 's' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$m = {
  date: buildFormatLongFn({
    formats: dateFormats$m,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$m,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$m,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$m = {
  lastWeek: (date2) => {
    const weekday = date2.getDay();
    const last = weekday === 0 || weekday === 6 ? "ltimo" : "ltima";
    return "'" + last + "' eeee 's' p";
  },
  yesterday: "'ontem s' p",
  today: "'hoje s' p",
  tomorrow: "'amanh s' p",
  nextWeek: "eeee 's' p",
  other: "P"
};
const formatRelative$m = (token, date2, _baseDate, _options) => {
  const format2 = formatRelativeLocale$m[token];
  if (typeof format2 === "function") {
    return format2(date2);
  }
  return format2;
};
const eraValues$m = {
  narrow: ["aC", "dC"],
  abbreviated: ["a.C.", "d.C."],
  wide: ["antes de Cristo", "depois de Cristo"]
};
const quarterValues$m = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1 trimestre", "2 trimestre", "3 trimestre", "4 trimestre"]
};
const monthValues$m = {
  narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "jan",
    "fev",
    "mar",
    "abr",
    "mai",
    "jun",
    "jul",
    "ago",
    "set",
    "out",
    "nov",
    "dez"
  ],
  wide: [
    "janeiro",
    "fevereiro",
    "maro",
    "abril",
    "maio",
    "junho",
    "julho",
    "agosto",
    "setembro",
    "outubro",
    "novembro",
    "dezembro"
  ]
};
const dayValues$m = {
  narrow: ["d", "s", "t", "q", "q", "s", "s"],
  short: ["dom", "seg", "ter", "qua", "qui", "sex", "sb"],
  abbreviated: ["dom", "seg", "ter", "qua", "qui", "sex", "sb"],
  wide: [
    "domingo",
    "segunda-feira",
    "tera-feira",
    "quarta-feira",
    "quinta-feira",
    "sexta-feira",
    "sbado"
  ]
};
const dayPeriodValues$m = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "manh",
    afternoon: "tarde",
    evening: "noite",
    night: "madrugada"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "manh",
    afternoon: "tarde",
    evening: "noite",
    night: "madrugada"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "manh",
    afternoon: "tarde",
    evening: "noite",
    night: "madrugada"
  }
};
const formattingDayPeriodValues$l = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "da manh",
    afternoon: "da tarde",
    evening: "da noite",
    night: "da madrugada"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "da manh",
    afternoon: "da tarde",
    evening: "da noite",
    night: "da madrugada"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "da manh",
    afternoon: "da tarde",
    evening: "da noite",
    night: "da madrugada"
  }
};
const ordinalNumber$m = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "";
};
const localize$m = {
  ordinalNumber: ordinalNumber$m,
  era: buildLocalizeFn({
    values: eraValues$m,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$m,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$m,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$m,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$m,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$l,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$m = /^(\d+)(|)?/i;
const parseOrdinalNumberPattern$m = /\d+/i;
const matchEraPatterns$m = {
  narrow: /^(ac|dc|a|d)/i,
  abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
  wide: /^(antes de cristo|antes da era comum|depois de cristo|era comum)/i
};
const parseEraPatterns$m = {
  any: [/^ac/i, /^dc/i],
  wide: [
    /^(antes de cristo|antes da era comum)/i,
    /^(depois de cristo|era comum)/i
  ]
};
const matchQuarterPatterns$m = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^[1234](|)? trimestre/i
};
const parseQuarterPatterns$m = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$m = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|fev|mar|abr|mai|jun|jul|ago|set|out|nov|dez)/i,
  wide: /^(janeiro|fevereiro|maro|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)/i
};
const parseMonthPatterns$m = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ab/i,
    /^mai/i,
    /^jun/i,
    /^jul/i,
    /^ag/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$m = {
  narrow: /^[dstq]/i,
  short: /^(dom|seg|ter|qua|qui|sex|s[a]b)/i,
  abbreviated: /^(dom|seg|ter|qua|qui|sex|s[a]b)/i,
  wide: /^(domingo|segunda-?\s?feira|tera-?\s?feira|quarta-?\s?feira|quinta-?\s?feira|sexta-?\s?feira|s[a]bado)/i
};
const parseDayPatterns$m = {
  narrow: [/^d/i, /^s/i, /^t/i, /^q/i, /^q/i, /^s/i, /^s/i],
  any: [/^d/i, /^seg/i, /^t/i, /^qua/i, /^qui/i, /^sex/i, /^s[a]/i]
};
const matchDayPeriodPatterns$m = {
  narrow: /^(a|p|meia-?\s?noite|meio-?\s?dia|(da) (manh[a]|tarde|noite|madrugada))/i,
  any: /^([ap]\.?\s?m\.?|meia-?\s?noite|meio-?\s?dia|(da) (manh[a]|tarde|noite|madrugada))/i
};
const parseDayPeriodPatterns$m = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^meia/i,
    noon: /^meio/i,
    morning: /manh[a]/i,
    afternoon: /tarde/i,
    evening: /noite/i,
    night: /madrugada/i
  }
};
const match$m = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$m,
    parsePattern: parseOrdinalNumberPattern$m,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$m,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$m,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$m,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$m,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$m,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$m,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$m,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$m,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$m,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$m,
    defaultParseWidth: "any"
  })
};
const pt = {
  code: "pt",
  formatDistance: formatDistance$m,
  formatLong: formatLong$m,
  formatRelative: formatRelative$m,
  localize: localize$m,
  match: match$m,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$l = {
  lessThanXSeconds: {
    one: "menos de um segundo",
    other: "menos de {{count}} segundos"
  },
  xSeconds: {
    one: "1 segundo",
    other: "{{count}} segundos"
  },
  halfAMinute: "meio minuto",
  lessThanXMinutes: {
    one: "menos de um minuto",
    other: "menos de {{count}} minutos"
  },
  xMinutes: {
    one: "1 minuto",
    other: "{{count}} minutos"
  },
  aboutXHours: {
    one: "cerca de 1 hora",
    other: "cerca de {{count}} horas"
  },
  xHours: {
    one: "1 hora",
    other: "{{count}} horas"
  },
  xDays: {
    one: "1 dia",
    other: "{{count}} dias"
  },
  aboutXWeeks: {
    one: "cerca de 1 semana",
    other: "cerca de {{count}} semanas"
  },
  xWeeks: {
    one: "1 semana",
    other: "{{count}} semanas"
  },
  aboutXMonths: {
    one: "cerca de 1 ms",
    other: "cerca de {{count}} meses"
  },
  xMonths: {
    one: "1 ms",
    other: "{{count}} meses"
  },
  aboutXYears: {
    one: "cerca de 1 ano",
    other: "cerca de {{count}} anos"
  },
  xYears: {
    one: "1 ano",
    other: "{{count}} anos"
  },
  overXYears: {
    one: "mais de 1 ano",
    other: "mais de {{count}} anos"
  },
  almostXYears: {
    one: "quase 1 ano",
    other: "quase {{count}} anos"
  }
};
const formatDistance$l = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$l[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "em " + result;
    } else {
      return "h " + result;
    }
  }
  return result;
};
const dateFormats$l = {
  full: "EEEE, d 'de' MMMM 'de' y",
  long: "d 'de' MMMM 'de' y",
  medium: "d MMM y",
  short: "dd/MM/yyyy"
};
const timeFormats$l = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$l = {
  full: "{{date}} 's' {{time}}",
  long: "{{date}} 's' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$l = {
  date: buildFormatLongFn({
    formats: dateFormats$l,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$l,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$l,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$l = {
  lastWeek: (date2) => {
    const weekday = date2.getDay();
    const last = weekday === 0 || weekday === 6 ? "ltimo" : "ltima";
    return "'" + last + "' eeee 's' p";
  },
  yesterday: "'ontem s' p",
  today: "'hoje s' p",
  tomorrow: "'amanh s' p",
  nextWeek: "eeee 's' p",
  other: "P"
};
const formatRelative$l = (token, date2, _baseDate, _options) => {
  const format2 = formatRelativeLocale$l[token];
  if (typeof format2 === "function") {
    return format2(date2);
  }
  return format2;
};
const eraValues$l = {
  narrow: ["AC", "DC"],
  abbreviated: ["AC", "DC"],
  wide: ["antes de cristo", "depois de cristo"]
};
const quarterValues$l = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1 trimestre", "2 trimestre", "3 trimestre", "4 trimestre"]
};
const monthValues$l = {
  narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "jan",
    "fev",
    "mar",
    "abr",
    "mai",
    "jun",
    "jul",
    "ago",
    "set",
    "out",
    "nov",
    "dez"
  ],
  wide: [
    "janeiro",
    "fevereiro",
    "maro",
    "abril",
    "maio",
    "junho",
    "julho",
    "agosto",
    "setembro",
    "outubro",
    "novembro",
    "dezembro"
  ]
};
const dayValues$l = {
  narrow: ["D", "S", "T", "Q", "Q", "S", "S"],
  short: ["dom", "seg", "ter", "qua", "qui", "sex", "sab"],
  abbreviated: [
    "domingo",
    "segunda",
    "tera",
    "quarta",
    "quinta",
    "sexta",
    "sbado"
  ],
  wide: [
    "domingo",
    "segunda-feira",
    "tera-feira",
    "quarta-feira",
    "quinta-feira",
    "sexta-feira",
    "sbado"
  ]
};
const dayPeriodValues$l = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "manh",
    afternoon: "tarde",
    evening: "tarde",
    night: "noite"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "manh",
    afternoon: "tarde",
    evening: "tarde",
    night: "noite"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "manh",
    afternoon: "tarde",
    evening: "tarde",
    night: "noite"
  }
};
const formattingDayPeriodValues$k = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "da manh",
    afternoon: "da tarde",
    evening: "da tarde",
    night: "da noite"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "da manh",
    afternoon: "da tarde",
    evening: "da tarde",
    night: "da noite"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "da manh",
    afternoon: "da tarde",
    evening: "da tarde",
    night: "da noite"
  }
};
const ordinalNumber$l = (dirtyNumber, options) => {
  const number2 = Number(dirtyNumber);
  if (options?.unit === "week") {
    return number2 + "";
  }
  return number2 + "";
};
const localize$l = {
  ordinalNumber: ordinalNumber$l,
  era: buildLocalizeFn({
    values: eraValues$l,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$l,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$l,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$l,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$l,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$k,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$l = /^(\d+)[o]?/i;
const parseOrdinalNumberPattern$l = /\d+/i;
const matchEraPatterns$l = {
  narrow: /^(ac|dc|a|d)/i,
  abbreviated: /^(a\.?\s?c\.?|d\.?\s?c\.?)/i,
  wide: /^(antes de cristo|depois de cristo)/i
};
const parseEraPatterns$l = {
  any: [/^ac/i, /^dc/i],
  wide: [/^antes de cristo/i, /^depois de cristo/i]
};
const matchQuarterPatterns$l = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^[1234]()? trimestre/i
};
const parseQuarterPatterns$l = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$l = {
  narrow: /^[jfmajsond]/i,
  abbreviated: /^(jan|fev|mar|abr|mai|jun|jul|ago|set|out|nov|dez)/i,
  wide: /^(janeiro|fevereiro|maro|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)/i
};
const parseMonthPatterns$l = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^fev/i,
    /^mar/i,
    /^abr/i,
    /^mai/i,
    /^jun/i,
    /^jul/i,
    /^ago/i,
    /^set/i,
    /^out/i,
    /^nov/i,
    /^dez/i
  ]
};
const matchDayPatterns$l = {
  narrow: /^(dom|[23456]?|s[a]b)/i,
  short: /^(dom|[23456]?|s[a]b)/i,
  abbreviated: /^(dom|seg|ter|qua|qui|sex|s[a]b)/i,
  wide: /^(domingo|(segunda|ter[c]a|quarta|quinta|sexta)([- ]feira)?|s[a]bado)/i
};
const parseDayPatterns$l = {
  short: [/^d/i, /^2/i, /^3/i, /^4/i, /^5/i, /^6/i, /^s[a]/i],
  narrow: [/^d/i, /^2/i, /^3/i, /^4/i, /^5/i, /^6/i, /^s[a]/i],
  any: [/^d/i, /^seg/i, /^t/i, /^qua/i, /^qui/i, /^sex/i, /^s[a]b/i]
};
const matchDayPeriodPatterns$l = {
  narrow: /^(a|p|mn|md|(da) (manh|tarde|noite))/i,
  any: /^([ap]\.?\s?m\.?|meia[-\s]noite|meio[-\s]dia|(da) (manh|tarde|noite))/i
};
const parseDayPeriodPatterns$l = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mn|^meia[-\s]noite/i,
    noon: /^md|^meio[-\s]dia/i,
    morning: /manh/i,
    afternoon: /tarde/i,
    evening: /tarde/i,
    night: /noite/i
  }
};
const match$l = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$l,
    parsePattern: parseOrdinalNumberPattern$l,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$l,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$l,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$l,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$l,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$l,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$l,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$l,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$l,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$l,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$l,
    defaultParseWidth: "any"
  })
};
const ptBR = {
  code: "pt-BR",
  formatDistance: formatDistance$l,
  formatLong: formatLong$l,
  formatRelative: formatRelative$l,
  localize: localize$l,
  match: match$l,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$k = {
  lessThanXSeconds: {
    one: "mai puin de o secund",
    other: "mai puin de {{count}} secunde"
  },
  xSeconds: {
    one: "1 secund",
    other: "{{count}} secunde"
  },
  halfAMinute: "jumtate de minut",
  lessThanXMinutes: {
    one: "mai puin de un minut",
    other: "mai puin de {{count}} minute"
  },
  xMinutes: {
    one: "1 minut",
    other: "{{count}} minute"
  },
  aboutXHours: {
    one: "circa 1 or",
    other: "circa {{count}} ore"
  },
  xHours: {
    one: "1 or",
    other: "{{count}} ore"
  },
  xDays: {
    one: "1 zi",
    other: "{{count}} zile"
  },
  aboutXWeeks: {
    one: "circa o sptmn",
    other: "circa {{count}} sptmni"
  },
  xWeeks: {
    one: "1 sptmn",
    other: "{{count}} sptmni"
  },
  aboutXMonths: {
    one: "circa 1 lun",
    other: "circa {{count}} luni"
  },
  xMonths: {
    one: "1 lun",
    other: "{{count}} luni"
  },
  aboutXYears: {
    one: "circa 1 an",
    other: "circa {{count}} ani"
  },
  xYears: {
    one: "1 an",
    other: "{{count}} ani"
  },
  overXYears: {
    one: "peste 1 an",
    other: "peste {{count}} ani"
  },
  almostXYears: {
    one: "aproape 1 an",
    other: "aproape {{count}} ani"
  }
};
const formatDistance$k = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$k[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "n " + result;
    } else {
      return result + " n urm";
    }
  }
  return result;
};
const dateFormats$k = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd.MM.yyyy"
};
const timeFormats$k = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$k = {
  full: "{{date}} 'la' {{time}}",
  long: "{{date}} 'la' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$k = {
  date: buildFormatLongFn({
    formats: dateFormats$k,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$k,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$k,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$k = {
  lastWeek: "eeee 'trecut la' p",
  yesterday: "'ieri la' p",
  today: "'astzi la' p",
  tomorrow: "'mine la' p",
  nextWeek: "eeee 'viitoare la' p",
  other: "P"
};
const formatRelative$k = (token, _date, _baseDate, _options) => formatRelativeLocale$k[token];
const eraValues$k = {
  narrow: ["", "D"],
  abbreviated: [".d.C.", "D.C."],
  wide: ["nainte de Cristos", "Dup Cristos"]
};
const quarterValues$k = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: [
    "primul trimestru",
    "al doilea trimestru",
    "al treilea trimestru",
    "al patrulea trimestru"
  ]
};
const monthValues$k = {
  narrow: ["I", "F", "M", "A", "M", "I", "I", "A", "S", "O", "N", "D"],
  abbreviated: [
    "ian",
    "feb",
    "mar",
    "apr",
    "mai",
    "iun",
    "iul",
    "aug",
    "sep",
    "oct",
    "noi",
    "dec"
  ],
  wide: [
    "ianuarie",
    "februarie",
    "martie",
    "aprilie",
    "mai",
    "iunie",
    "iulie",
    "august",
    "septembrie",
    "octombrie",
    "noiembrie",
    "decembrie"
  ]
};
const dayValues$k = {
  narrow: ["d", "l", "m", "m", "j", "v", "s"],
  short: ["du", "lu", "ma", "mi", "jo", "vi", "s"],
  abbreviated: ["dum", "lun", "mar", "mie", "joi", "vin", "sm"],
  wide: ["duminic", "luni", "mari", "miercuri", "joi", "vineri", "smbt"]
};
const dayPeriodValues$k = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "ami",
    morning: "dim",
    afternoon: "da",
    evening: "s",
    night: "n"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "miezul nopii",
    noon: "amiaz",
    morning: "diminea",
    afternoon: "dup-amiaz",
    evening: "sear",
    night: "noapte"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "miezul nopii",
    noon: "amiaz",
    morning: "diminea",
    afternoon: "dup-amiaz",
    evening: "sear",
    night: "noapte"
  }
};
const formattingDayPeriodValues$j = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "amiaz",
    morning: "diminea",
    afternoon: "dup-amiaz",
    evening: "sear",
    night: "noapte"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "miezul nopii",
    noon: "amiaz",
    morning: "diminea",
    afternoon: "dup-amiaz",
    evening: "sear",
    night: "noapte"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "miezul nopii",
    noon: "amiaz",
    morning: "diminea",
    afternoon: "dup-amiaz",
    evening: "sear",
    night: "noapte"
  }
};
const ordinalNumber$k = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
const localize$k = {
  ordinalNumber: ordinalNumber$k,
  era: buildLocalizeFn({
    values: eraValues$k,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$k,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$k,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$k,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$k,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$j,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$k = /^(\d+)?/i;
const parseOrdinalNumberPattern$k = /\d+/i;
const matchEraPatterns$k = {
  narrow: /^(|D)/i,
  abbreviated: /^(\.?\s?d\.?\s?C\.?|\.?\s?e\.?\s?n\.?|D\.?\s?C\.?|e\.?\s?n\.?)/i,
  wide: /^(nainte de Cristos|naintea erei noastre|Dup Cristos|Era noastr)/i
};
const parseEraPatterns$k = {
  any: [/^C/i, /^DC/i],
  wide: [
    /^(nainte de Cristos|naintea erei noastre)/i,
    /^(Dup Cristos|Era noastr)/i
  ]
};
const matchQuarterPatterns$k = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^trimestrul [1234]/i
};
const parseQuarterPatterns$k = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$k = {
  narrow: /^[ifmaasond]/i,
  abbreviated: /^(ian|feb|mar|apr|mai|iun|iul|aug|sep|oct|noi|dec)/i,
  wide: /^(ianuarie|februarie|martie|aprilie|mai|iunie|iulie|august|septembrie|octombrie|noiembrie|decembrie)/i
};
const parseMonthPatterns$k = {
  narrow: [
    /^i/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^i/i,
    /^i/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ia/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^mai/i,
    /^iun/i,
    /^iul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$k = {
  narrow: /^[dlmjvs]/i,
  short: /^(d|l|ma|mi|j|v|s)/i,
  abbreviated: /^(dum|lun|mar|mie|jo|vi|s)/i,
  wide: /^(duminica|luni|mari|miercuri|joi|vineri|smbt)/i
};
const parseDayPatterns$k = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
  any: [/^d/i, /^l/i, /^ma/i, /^mi/i, /^j/i, /^v/i, /^s/i]
};
const matchDayPeriodPatterns$k = {
  narrow: /^(a|p|mn|a|(dimineaa|dup-amiaza|seara|noaptea))/i,
  any: /^([ap]\.?\s?m\.?|miezul nopii|amiaza|(dimineaa|dup-amiaza|seara|noaptea))/i
};
const parseDayPeriodPatterns$k = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mn/i,
    noon: /amiaza/i,
    morning: /dimineaa/i,
    afternoon: /dup-amiaza/i,
    evening: /seara/i,
    night: /noaptea/i
  }
};
const match$k = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$k,
    parsePattern: parseOrdinalNumberPattern$k,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$k,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$k,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$k,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$k,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$k,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$k,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$k,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$k,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$k,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$k,
    defaultParseWidth: "any"
  })
};
const ro = {
  code: "ro",
  formatDistance: formatDistance$k,
  formatLong: formatLong$k,
  formatRelative: formatRelative$k,
  localize: localize$k,
  match: match$k,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
function declension$2(scheme2, count) {
  if (scheme2.one !== void 0 && count === 1) {
    return scheme2.one;
  }
  const rem10 = count % 10;
  const rem100 = count % 100;
  if (rem10 === 1 && rem100 !== 11) {
    return scheme2.singularNominative.replace("{{count}}", String(count));
  } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
    return scheme2.singularGenitive.replace("{{count}}", String(count));
  } else {
    return scheme2.pluralGenitive.replace("{{count}}", String(count));
  }
}
function buildLocalizeTokenFn$1(scheme2) {
  return (count, options) => {
    if (options?.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        if (scheme2.future) {
          return declension$2(scheme2.future, count);
        } else {
          return " " + declension$2(scheme2.regular, count);
        }
      } else {
        if (scheme2.past) {
          return declension$2(scheme2.past, count);
        } else {
          return declension$2(scheme2.regular, count) + " ";
        }
      }
    } else {
      return declension$2(scheme2.regular, count);
    }
  };
}
const formatDistanceLocale$j = {
  lessThanXSeconds: buildLocalizeTokenFn$1({
    regular: {
      one: " ",
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      one: ",   ",
      singularNominative: ",   {{count}} ",
      singularGenitive: ",   {{count}} ",
      pluralGenitive: ",   {{count}} "
    }
  }),
  xSeconds: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    },
    past: {
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    },
    future: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    }
  }),
  halfAMinute: (_count, options) => {
    if (options?.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        return " ";
      } else {
        return " ";
      }
    }
    return "";
  },
  lessThanXMinutes: buildLocalizeTokenFn$1({
    regular: {
      one: " ",
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      one: ",   ",
      singularNominative: ",   {{count}} ",
      singularGenitive: ",   {{count}} ",
      pluralGenitive: ",   {{count}} "
    }
  }),
  xMinutes: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    },
    past: {
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    },
    future: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    }
  }),
  aboutXHours: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    }
  }),
  xHours: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    }
  }),
  xDays: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    }
  }),
  aboutXWeeks: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    }
  }),
  xWeeks: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    }
  }),
  aboutXMonths: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    }
  }),
  xMonths: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    }
  }),
  aboutXYears: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    }
  }),
  xYears: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    }
  }),
  overXYears: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: ",   {{count}} ",
      singularGenitive: ",   {{count}} ",
      pluralGenitive: ",   {{count}} "
    }
  }),
  almostXYears: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    }
  })
};
const formatDistance$j = (token, count, options) => {
  return formatDistanceLocale$j[token](count, options);
};
const dateFormats$j = {
  full: "EEEE, d MMMM y '.'",
  long: "d MMMM y '.'",
  medium: "d MMM y '.'",
  short: "dd.MM.y"
};
const timeFormats$j = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
const dateTimeFormats$j = {
  any: "{{date}}, {{time}}"
};
const formatLong$j = {
  date: buildFormatLongFn({
    formats: dateFormats$j,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$j,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$j,
    defaultWidth: "any"
  })
};
const accusativeWeekdays$2 = [
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];
function lastWeek$2(day) {
  const weekday = accusativeWeekdays$2[day];
  switch (day) {
    case 0:
      return "'  " + weekday + " ' p";
    case 1:
    case 2:
    case 4:
      return "'  " + weekday + " ' p";
    case 3:
    case 5:
    case 6:
      return "'  " + weekday + " ' p";
  }
}
function thisWeek$2(day) {
  const weekday = accusativeWeekdays$2[day];
  if (day === 2) {
    return "' " + weekday + " ' p";
  } else {
    return "' " + weekday + " ' p";
  }
}
function nextWeek$2(day) {
  const weekday = accusativeWeekdays$2[day];
  switch (day) {
    case 0:
      return "'  " + weekday + " ' p";
    case 1:
    case 2:
    case 4:
      return "'  " + weekday + " ' p";
    case 3:
    case 5:
    case 6:
      return "'  " + weekday + " ' p";
  }
}
const formatRelativeLocale$j = {
  lastWeek: (date2, baseDate, options) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options)) {
      return thisWeek$2(day);
    } else {
      return lastWeek$2(day);
    }
  },
  yesterday: "' ' p",
  today: "' ' p",
  tomorrow: "' ' p",
  nextWeek: (date2, baseDate, options) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options)) {
      return thisWeek$2(day);
    } else {
      return nextWeek$2(day);
    }
  },
  other: "P"
};
const formatRelative$j = (token, date2, baseDate, options) => {
  const format2 = formatRelativeLocale$j[token];
  if (typeof format2 === "function") {
    return format2(date2, baseDate, options);
  }
  return format2;
};
const eraValues$j = {
  narrow: [" ..", ".."],
  abbreviated: [" . .", ". ."],
  wide: ["  ", " "]
};
const quarterValues$j = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1- .", "2- .", "3- .", "4- ."],
  wide: ["1- ", "2- ", "3- ", "4- "]
};
const monthValues$j = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    ".",
    ".",
    "",
    ".",
    "",
    "",
    "",
    ".",
    ".",
    ".",
    ".",
    "."
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const formattingMonthValues$5 = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    ".",
    ".",
    ".",
    ".",
    "",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    "."
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$j = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$j = {
  narrow: {
    am: "",
    pm: "",
    midnight: ".",
    noon: ".",
    morning: "",
    afternoon: "",
    evening: ".",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: ".",
    noon: ".",
    morning: "",
    afternoon: "",
    evening: ".",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$i = {
  narrow: {
    am: "",
    pm: "",
    midnight: ".",
    noon: ".",
    morning: "",
    afternoon: "",
    evening: ".",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: ".",
    noon: ".",
    morning: "",
    afternoon: "",
    evening: ".",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$j = (dirtyNumber, options) => {
  const number2 = Number(dirtyNumber);
  const unit = options?.unit;
  let suffix;
  if (unit === "date") {
    suffix = "-";
  } else if (unit === "week" || unit === "minute" || unit === "second") {
    suffix = "-";
  } else {
    suffix = "-";
  }
  return number2 + suffix;
};
const localize$j = {
  ordinalNumber: ordinalNumber$j,
  era: buildLocalizeFn({
    values: eraValues$j,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$j,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$j,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$5,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$j,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$j,
    defaultWidth: "any",
    formattingValues: formattingDayPeriodValues$i,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$j = /^(\d+)(-?(||||||||||))?/i;
const parseOrdinalNumberPattern$j = /\d+/i;
const matchEraPatterns$j = {
  narrow: /^(( )?\.?\s?\.?)/i,
  abbreviated: /^(( )?\.?\s?\.?)/i,
  wide: /^(  | | )/i
};
const parseEraPatterns$j = {
  any: [/^/i, /^/i]
};
const matchQuarterPatterns$j = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?[]??)? .?/i,
  wide: /^[1234](-?[]??)? /i
};
const parseQuarterPatterns$j = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$j = {
  narrow: /^[]/i,
  abbreviated: /^(||?||[]|[]?|[]?||?||?|)\.?/i,
  wide: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[]|[])/i
};
const parseMonthPatterns$j = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^[]/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$j = {
  narrow: /^[]/i,
  short: /^(|||||||||||)\.?/i,
  abbreviated: /^(||||||||||||).?/i,
  wide: /^([]|?|?|[]|?|[]|[])/i
};
const parseDayPatterns$j = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^[]/i, /^[]/i, /^/i, /^/i, /^/i, /^[]/i, /^[]/i]
};
const matchDayPeriodPatterns$j = {
  narrow: /^([]|\.?|\.?|[]|||\.?|[])/i,
  abbreviated: /^([]|\.?|\.?|[]|||\.?|[])/i,
  wide: /^([]|||[]|||?|[])/i
};
const parseDayPeriodPatterns$j = {
  any: {
    am: /^/i,
    pm: /^/i,
    midnight: /^/i,
    noon: /^/i,
    morning: /^/i,
    afternoon: /^[]/i,
    evening: /^/i,
    night: /^/i
  }
};
const match$j = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$j,
    parsePattern: parseOrdinalNumberPattern$j,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$j,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$j,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$j,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$j,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$j,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$j,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$j,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$j,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$j,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$j,
    defaultParseWidth: "any"
  })
};
const ru = {
  code: "ru",
  formatDistance: formatDistance$j,
  formatLong: formatLong$j,
  formatRelative: formatRelative$j,
  localize: localize$j,
  match: match$j,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$i = {
  lessThanXSeconds: {
    one: "unnit go ovtta sekundda",
    other: "unnit go {{count}} sekundda"
  },
  xSeconds: {
    one: "sekundda",
    other: "{{count}} sekundda"
  },
  halfAMinute: "bealle minuhta",
  lessThanXMinutes: {
    one: "unnit go bealle minuhta",
    other: "unnit go {{count}} minuhta"
  },
  xMinutes: {
    one: "minuhta",
    other: "{{count}} minuhta"
  },
  aboutXHours: {
    one: "sullii ovtta diimmu",
    other: "sullii {{count}} diimmu"
  },
  xHours: {
    one: "diimmu",
    other: "{{count}} diimmu"
  },
  xDays: {
    one: "beaivvi",
    other: "{{count}} beaivvi"
  },
  aboutXWeeks: {
    one: "sullii ovtta vahku",
    other: "sullii {{count}} vahku"
  },
  xWeeks: {
    one: "vahku",
    other: "{{count}} vahku"
  },
  aboutXMonths: {
    one: "sullii ovtta mnu",
    other: "sullii {{count}} mnu"
  },
  xMonths: {
    one: "mnu",
    other: "{{count}} mnu"
  },
  aboutXYears: {
    one: "sullii ovtta jagi",
    other: "sullii {{count}} jagi"
  },
  xYears: {
    one: "jagi",
    other: "{{count}} jagi"
  },
  overXYears: {
    one: "guhkit go jagi",
    other: "guhkit go {{count}} jagi"
  },
  almostXYears: {
    one: "measta jagi",
    other: "measta {{count}} jagi"
  }
};
const formatDistance$i = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$i[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "geahen " + result;
    } else {
      return result + " igi";
    }
  }
  return result;
};
const dateFormats$i = {
  full: "EEEE MMMM d. 'b.' y",
  long: "MMMM d. 'b.' y",
  medium: "MMM d. 'b.' y",
  short: "dd.MM.y"
};
const timeFormats$i = {
  full: "'dii.' HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$i = {
  full: "{{date}} 'dii.' {{time}}",
  long: "{{date}} 'dii.' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$i = {
  date: buildFormatLongFn({
    formats: dateFormats$i,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$i,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$i,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$i = {
  lastWeek: "'ovddit' eeee 'dii.' p",
  yesterday: "'ikte dii.' p",
  today: "'odne dii.' p",
  tomorrow: "'ihtin dii.' p",
  nextWeek: "EEEE 'dii.' p",
  other: "P"
};
const formatRelative$i = (token, _date, _baseDate, _options) => formatRelativeLocale$i[token];
const eraValues$i = {
  narrow: ["o.Kr.", "m.Kr."],
  abbreviated: ["o.Kr.", "m.Kr."],
  wide: ["ovdal Kristusa", "mael Kristusa"]
};
const quarterValues$i = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. kvartla", "2. kvartla", "3. kvartla", "4. kvartla"]
};
const monthValues$i = {
  narrow: ["O", "G", "N", "C", "M", "G", "S", "B", "", "G", "S", "J"],
  abbreviated: [
    "oa",
    "guov",
    "njuk",
    "cuo",
    "mies",
    "geas",
    "suoi",
    "borg",
    "ak",
    "golg",
    "skb",
    "juov"
  ],
  wide: [
    "oajagemnnu",
    "guovvamnnu",
    "njukamnnu",
    "cuoomnnu",
    "miessemnnu",
    "geassemnnu",
    "suoidnemnnu",
    "borgemnnu",
    "akamnnu",
    "golggotmnnu",
    "skbmamnnu",
    "juovlamnnu"
  ]
};
const dayValues$i = {
  narrow: ["S", "V", "M", "G", "D", "B", "L"],
  short: ["sotn", "vuos", "ma", "gask", "duor", "bear", "lv"],
  abbreviated: ["sotn", "vuos", "ma", "gask", "duor", "bear", "lv"],
  wide: [
    "sotnabeaivi",
    "vuossrga",
    "maebrga",
    "gaskavahkku",
    "duorastat",
    "bearjadat",
    "lvvardat"
  ]
};
const dayPeriodValues$i = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "gaskaidja",
    noon: "gaskabeaivi",
    morning: "ies",
    afternoon: "mael gaska.",
    evening: "eahkes",
    night: "ihkku"
  },
  abbreviated: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "gaskaidja",
    noon: "gaskabeaivvi",
    morning: "ies",
    afternoon: "mael gaskabea.",
    evening: "eahkes",
    night: "ihkku"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "gaskaidja",
    noon: "gaskabeavvi",
    morning: "ies",
    afternoon: "mael gaskabeaivvi",
    evening: "eahkes",
    night: "ihkku"
  }
};
const ordinalNumber$i = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$i = {
  ordinalNumber: ordinalNumber$i,
  era: buildLocalizeFn({
    values: eraValues$i,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$i,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$i,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$i,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$i,
    defaultWidth: "wide"
  })
};
const matchOrdinalNumberPattern$i = /^(\d+)\.?/i;
const parseOrdinalNumberPattern$i = /\d+/i;
const matchEraPatterns$i = {
  narrow: /^(o\.? ?Kr\.?|m\.? ?Kr\.?)/i,
  abbreviated: /^(o\.? ?Kr\.?|m\.? ?Kr\.?)/i,
  wide: /^(ovdal Kristusa|ovdal min iggi|mael Kristusa|min igi)/i
};
const parseEraPatterns$i = {
  any: [/^o/i, /^m/i]
};
const matchQuarterPatterns$i = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? kvartla/i
};
const parseQuarterPatterns$i = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$i = {
  narrow: /^[ogncmsbj]/i,
  abbreviated: /^(oa|guov|njuk|cuo|mies|geas|suoi|borg|ak|golg|skb|juov)\.?/i,
  wide: /^(oajagemnnu|guovvamnnu|njukamnnu|cuoomnnu|miessemnnu|geassemnnu|suoidnemnnu|borgemnnu|akamnnu|golggotmnnu|skbmamnnu|juovlamnnu)/i
};
const parseMonthPatterns$i = {
  narrow: [
    /^o/i,
    /^g/i,
    /^n/i,
    /^c/i,
    /^m/i,
    /^g/i,
    /^s/i,
    /^b/i,
    /^/i,
    /^g/i,
    /^s/i,
    /^j/i
  ],
  any: [
    /^o/i,
    /^gu/i,
    /^n/i,
    /^c/i,
    /^m/i,
    /^ge/i,
    /^su/i,
    /^b/i,
    /^/i,
    /^go/i,
    /^sk/i,
    /^j/i
  ]
};
const matchDayPatterns$i = {
  narrow: /^[svmgdbl]/i,
  short: /^(sotn|vuos|ma|gask|duor|bear|lv)/i,
  abbreviated: /^(sotn|vuos|ma|gask|duor|bear|lv)/i,
  wide: /^(sotnabeaivi|vuossrga|maebrga|gaskavahkku|duorastat|bearjadat|lvvardat)/i
};
const parseDayPatterns$i = {
  any: [/^s/i, /^v/i, /^m/i, /^g/i, /^d/i, /^b/i, /^l/i]
};
const matchDayPeriodPatterns$i = {
  narrow: /^(gaskaidja|gaskabeaivvi|(p) (ies|mael gaskabeaivvi|eahkes|ihkku)|[ap])/i,
  any: /^([ap]\.?\s?m\.?|gaskaidja|gaskabeaivvi|(p) (ies|mael gaskabeaivvi|eahkes|ihkku))/i
};
const parseDayPeriodPatterns$i = {
  any: {
    am: /^a(\.?\s?m\.?)?$/i,
    pm: /^p(\.?\s?m\.?)?$/i,
    midnight: /^gaskai/i,
    noon: /^gaskab/i,
    morning: /ies/i,
    afternoon: /mael gaskabeaivvi/i,
    evening: /eahkes/i,
    night: /ihkku/i
  }
};
const match$i = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$i,
    parsePattern: parseOrdinalNumberPattern$i,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$i,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$i,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$i,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$i,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$i,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$i,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$i,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$i,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$i,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$i,
    defaultParseWidth: "any"
  })
};
const se = {
  code: "se",
  formatDistance: formatDistance$i,
  formatLong: formatLong$i,
  formatRelative: formatRelative$i,
  localize: localize$i,
  match: match$i,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
function declensionGroup(scheme2, count) {
  if (count === 1 && scheme2.one) {
    return scheme2.one;
  }
  if (count >= 2 && count <= 4 && scheme2.twoFour) {
    return scheme2.twoFour;
  }
  return scheme2.other;
}
function declension$1(scheme2, count, time) {
  const group = declensionGroup(scheme2, count);
  const finalText = group[time];
  return finalText.replace("{{count}}", String(count));
}
function extractPreposition(token) {
  const result = ["lessThan", "about", "over", "almost"].filter(
    function(preposition) {
      return !!token.match(new RegExp("^" + preposition));
    }
  );
  return result[0];
}
function prefixPreposition(preposition) {
  let translation = "";
  if (preposition === "almost") {
    translation = "takmer";
  }
  if (preposition === "about") {
    translation = "pribline";
  }
  return translation.length > 0 ? translation + " " : "";
}
function suffixPreposition(preposition) {
  let translation = "";
  if (preposition === "lessThan") {
    translation = "menej ne";
  }
  if (preposition === "over") {
    translation = "viac ne";
  }
  return translation.length > 0 ? translation + " " : "";
}
function lowercaseFirstLetter(string2) {
  return string2.charAt(0).toLowerCase() + string2.slice(1);
}
const formatDistanceLocale$h = {
  xSeconds: {
    one: {
      present: "sekunda",
      past: "sekundou",
      future: "sekundu"
    },
    twoFour: {
      present: "{{count}} sekundy",
      past: "{{count}} sekundami",
      future: "{{count}} sekundy"
    },
    other: {
      present: "{{count}} seknd",
      past: "{{count}} sekundami",
      future: "{{count}} seknd"
    }
  },
  halfAMinute: {
    other: {
      present: "pol minty",
      past: "pol mintou",
      future: "pol minty"
    }
  },
  xMinutes: {
    one: {
      present: "minta",
      past: "mintou",
      future: "mintu"
    },
    twoFour: {
      present: "{{count}} minty",
      past: "{{count}} mintami",
      future: "{{count}} minty"
    },
    other: {
      present: "{{count}} mint",
      past: "{{count}} mintami",
      future: "{{count}} mint"
    }
  },
  xHours: {
    one: {
      present: "hodina",
      past: "hodinou",
      future: "hodinu"
    },
    twoFour: {
      present: "{{count}} hodiny",
      past: "{{count}} hodinami",
      future: "{{count}} hodiny"
    },
    other: {
      present: "{{count}} hodn",
      past: "{{count}} hodinami",
      future: "{{count}} hodn"
    }
  },
  xDays: {
    one: {
      present: "de",
      past: "dom",
      future: "de"
    },
    twoFour: {
      present: "{{count}} dni",
      past: "{{count}} dami",
      future: "{{count}} dni"
    },
    other: {
      present: "{{count}} dn",
      past: "{{count}} dami",
      future: "{{count}} dn"
    }
  },
  xWeeks: {
    one: {
      present: "tde",
      past: "tdom",
      future: "tde"
    },
    twoFour: {
      present: "{{count}} tdne",
      past: "{{count}} tdami",
      future: "{{count}} tdne"
    },
    other: {
      present: "{{count}} tdov",
      past: "{{count}} tdami",
      future: "{{count}} tdov"
    }
  },
  xMonths: {
    one: {
      present: "mesiac",
      past: "mesiacom",
      future: "mesiac"
    },
    twoFour: {
      present: "{{count}} mesiace",
      past: "{{count}} mesiacmi",
      future: "{{count}} mesiace"
    },
    other: {
      present: "{{count}} mesiacov",
      past: "{{count}} mesiacmi",
      future: "{{count}} mesiacov"
    }
  },
  xYears: {
    one: {
      present: "rok",
      past: "rokom",
      future: "rok"
    },
    twoFour: {
      present: "{{count}} roky",
      past: "{{count}} rokmi",
      future: "{{count}} roky"
    },
    other: {
      present: "{{count}} rokov",
      past: "{{count}} rokmi",
      future: "{{count}} rokov"
    }
  }
};
const formatDistance$h = (token, count, options) => {
  const preposition = extractPreposition(token) || "";
  const key = lowercaseFirstLetter(token.substring(preposition.length));
  const scheme2 = formatDistanceLocale$h[key];
  if (!options?.addSuffix) {
    return prefixPreposition(preposition) + suffixPreposition(preposition) + declension$1(scheme2, count, "present");
  }
  if (options.comparison && options.comparison > 0) {
    return prefixPreposition(preposition) + "o " + suffixPreposition(preposition) + declension$1(scheme2, count, "future");
  } else {
    return prefixPreposition(preposition) + "pred " + suffixPreposition(preposition) + declension$1(scheme2, count, "past");
  }
};
const dateFormats$h = {
  full: "EEEE d. MMMM y",
  long: "d. MMMM y",
  medium: "d. M. y",
  short: "d. M. y"
};
const timeFormats$h = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
const dateTimeFormats$h = {
  full: "{{date}}, {{time}}",
  long: "{{date}}, {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$h = {
  date: buildFormatLongFn({
    formats: dateFormats$h,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$h,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$h,
    defaultWidth: "full"
  })
};
const accusativeWeekdays$1 = [
  "nedeu",
  "pondelok",
  "utorok",
  "stredu",
  "tvrtok",
  "piatok",
  "sobotu"
];
function lastWeek$1(day) {
  const weekday = accusativeWeekdays$1[day];
  switch (day) {
    case 0:
    case 3:
    case 6:
      return "'minul " + weekday + " o' p";
    default:
      return "'minul' eeee 'o' p";
  }
}
function thisWeek$1(day) {
  const weekday = accusativeWeekdays$1[day];
  if (day === 4) {
    return "'vo' eeee 'o' p";
  } else {
    return "'v " + weekday + " o' p";
  }
}
function nextWeek$1(day) {
  const weekday = accusativeWeekdays$1[day];
  switch (day) {
    case 0:
    case 4:
    case 6:
      return "'budcu " + weekday + " o' p";
    default:
      return "'budci' eeee 'o' p";
  }
}
const formatRelativeLocale$h = {
  lastWeek: (date2, baseDate, options) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options)) {
      return thisWeek$1(day);
    } else {
      return lastWeek$1(day);
    }
  },
  yesterday: "'vera o' p",
  today: "'dnes o' p",
  tomorrow: "'zajtra o' p",
  nextWeek: (date2, baseDate, options) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options)) {
      return thisWeek$1(day);
    } else {
      return nextWeek$1(day);
    }
  },
  other: "P"
};
const formatRelative$h = (token, date2, baseDate, options) => {
  const format2 = formatRelativeLocale$h[token];
  if (typeof format2 === "function") {
    return format2(date2, baseDate, options);
  }
  return format2;
};
const eraValues$h = {
  narrow: ["pred Kr.", "po Kr."],
  abbreviated: ["pred Kr.", "po Kr."],
  wide: ["pred Kristom", "po Kristovi"]
};
const quarterValues$h = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. tvrrok", "2. tvrrok", "3. tvrrok", "4. tvrrok"]
};
const monthValues$h = {
  narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "mj",
    "jn",
    "jl",
    "aug",
    "sep",
    "okt",
    "nov",
    "dec"
  ],
  wide: [
    "janur",
    "februr",
    "marec",
    "aprl",
    "mj",
    "jn",
    "jl",
    "august",
    "september",
    "oktber",
    "november",
    "december"
  ]
};
const formattingMonthValues$4 = {
  narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "mj",
    "jn",
    "jl",
    "aug",
    "sep",
    "okt",
    "nov",
    "dec"
  ],
  wide: [
    "janura",
    "februra",
    "marca",
    "aprla",
    "mja",
    "jna",
    "jla",
    "augusta",
    "septembra",
    "oktbra",
    "novembra",
    "decembra"
  ]
};
const dayValues$h = {
  narrow: ["n", "p", "u", "s", "", "p", "s"],
  short: ["ne", "po", "ut", "st", "t", "pi", "so"],
  abbreviated: ["ne", "po", "ut", "st", "t", "pi", "so"],
  wide: [
    "nedea",
    "pondelok",
    "utorok",
    "streda",
    "tvrtok",
    "piatok",
    "sobota"
  ]
};
const dayPeriodValues$h = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "poln.",
    noon: "pol.",
    morning: "rno",
    afternoon: "pop.",
    evening: "ve.",
    night: "noc"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "poln.",
    noon: "pol.",
    morning: "rno",
    afternoon: "popol.",
    evening: "veer",
    night: "noc"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "polnoc",
    noon: "poludnie",
    morning: "rno",
    afternoon: "popoludnie",
    evening: "veer",
    night: "noc"
  }
};
const formattingDayPeriodValues$h = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "o poln.",
    noon: "nap.",
    morning: "rno",
    afternoon: "pop.",
    evening: "ve.",
    night: "v n."
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "o poln.",
    noon: "napol.",
    morning: "rno",
    afternoon: "popol.",
    evening: "veer",
    night: "v noci"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "o polnoci",
    noon: "napoludnie",
    morning: "rno",
    afternoon: "popoludn",
    evening: "veer",
    night: "v noci"
  }
};
const ordinalNumber$h = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$h = {
  ordinalNumber: ordinalNumber$h,
  era: buildLocalizeFn({
    values: eraValues$h,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$h,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$h,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$4,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$h,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$h,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$h,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$h = /^(\d+)\.?/i;
const parseOrdinalNumberPattern$h = /\d+/i;
const matchEraPatterns$h = {
  narrow: /^(pred Kr\.|pred n\. l\.|po Kr\.|n\. l\.)/i,
  abbreviated: /^(pred Kr\.|pred n\. l\.|po Kr\.|n\. l\.)/i,
  wide: /^(pred Kristom|pred na[s][i]m letopo[c]tom|po Kristovi|n[a][s]ho letopo[c]tu)/i
};
const parseEraPatterns$h = {
  any: [/^pr/i, /^(po|n)/i]
};
const matchQuarterPatterns$h = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234]\. [s]tvr[t]rok/i
};
const parseQuarterPatterns$h = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$h = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|m[a]j|j[u]n|j[u]l|aug|sep|okt|nov|dec)/i,
  wide: /^(janu[a]ra?|febru[a]ra?|(marec|marca)|apr[i]la?|m[a]ja?|j[u]na?|j[u]la?|augusta?|(september|septembra)|(okt[o]ber|okt[o]bra)|(november|novembra)|(december|decembra))/i
};
const parseMonthPatterns$h = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^m[a]j/i,
    /^j[u]n/i,
    /^j[u]l/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$h = {
  narrow: /^[npusp]/i,
  short: /^(ne|po|ut|st|t|pi|so)/i,
  abbreviated: /^(ne|po|ut|st|t|pi|so)/i,
  wide: /^(nede[l]a|pondelok|utorok|streda|[s]tvrtok|piatok|sobota])/i
};
const parseDayPatterns$h = {
  narrow: [/^n/i, /^p/i, /^u/i, /^s/i, /^/i, /^p/i, /^s/i],
  any: [/^n/i, /^po/i, /^u/i, /^st/i, /^(t|stv)/i, /^pi/i, /^so/i]
};
const matchDayPeriodPatterns$h = {
  narrow: /^(am|pm|(o )?poln\.?|(nap\.?|pol\.?)|r[a]no|pop\.?|ve[c]\.?|(v n\.?|noc))/i,
  abbreviated: /^(am|pm|(o )?poln\.?|(napol\.?|pol\.?)|r[a]no|pop\.?|ve[c]er|(v )?noci?)/i,
  any: /^(am|pm|(o )?polnoci?|(na)?poludnie|r[a]no|popoludn(ie||i)|ve[c]er|(v )?noci?)/i
};
const parseDayPeriodPatterns$h = {
  any: {
    am: /^am/i,
    pm: /^pm/i,
    midnight: /poln/i,
    noon: /^(nap|(na)?pol(\.|u))/i,
    morning: /^r[a]no/i,
    afternoon: /^pop/i,
    evening: /^ve[c]/i,
    night: /^(noc|v n\.)/i
  }
};
const match$h = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$h,
    parsePattern: parseOrdinalNumberPattern$h,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$h,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$h,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$h,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$h,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$h,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$h,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$h,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$h,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$h,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$h,
    defaultParseWidth: "any"
  })
};
const sk = {
  code: "sk",
  formatDistance: formatDistance$h,
  formatLong: formatLong$h,
  formatRelative: formatRelative$h,
  localize: localize$h,
  match: match$h,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
function isPluralType$1(val) {
  return val.one !== void 0;
}
const formatDistanceLocale$g = {
  lessThanXSeconds: {
    present: {
      one: "manj kot {{count}} sekunda",
      two: "manj kot {{count}} sekundi",
      few: "manj kot {{count}} sekunde",
      other: "manj kot {{count}} sekund"
    },
    past: {
      one: "manj kot {{count}} sekundo",
      two: "manj kot {{count}} sekundama",
      few: "manj kot {{count}} sekundami",
      other: "manj kot {{count}} sekundami"
    },
    future: {
      one: "manj kot {{count}} sekundo",
      two: "manj kot {{count}} sekundi",
      few: "manj kot {{count}} sekunde",
      other: "manj kot {{count}} sekund"
    }
  },
  xSeconds: {
    present: {
      one: "{{count}} sekunda",
      two: "{{count}} sekundi",
      few: "{{count}} sekunde",
      other: "{{count}} sekund"
    },
    past: {
      one: "{{count}} sekundo",
      two: "{{count}} sekundama",
      few: "{{count}} sekundami",
      other: "{{count}} sekundami"
    },
    future: {
      one: "{{count}} sekundo",
      two: "{{count}} sekundi",
      few: "{{count}} sekunde",
      other: "{{count}} sekund"
    }
  },
  halfAMinute: "pol minute",
  lessThanXMinutes: {
    present: {
      one: "manj kot {{count}} minuta",
      two: "manj kot {{count}} minuti",
      few: "manj kot {{count}} minute",
      other: "manj kot {{count}} minut"
    },
    past: {
      one: "manj kot {{count}} minuto",
      two: "manj kot {{count}} minutama",
      few: "manj kot {{count}} minutami",
      other: "manj kot {{count}} minutami"
    },
    future: {
      one: "manj kot {{count}} minuto",
      two: "manj kot {{count}} minuti",
      few: "manj kot {{count}} minute",
      other: "manj kot {{count}} minut"
    }
  },
  xMinutes: {
    present: {
      one: "{{count}} minuta",
      two: "{{count}} minuti",
      few: "{{count}} minute",
      other: "{{count}} minut"
    },
    past: {
      one: "{{count}} minuto",
      two: "{{count}} minutama",
      few: "{{count}} minutami",
      other: "{{count}} minutami"
    },
    future: {
      one: "{{count}} minuto",
      two: "{{count}} minuti",
      few: "{{count}} minute",
      other: "{{count}} minut"
    }
  },
  aboutXHours: {
    present: {
      one: "priblino {{count}} ura",
      two: "priblino {{count}} uri",
      few: "priblino {{count}} ure",
      other: "priblino {{count}} ur"
    },
    past: {
      one: "priblino {{count}} uro",
      two: "priblino {{count}} urama",
      few: "priblino {{count}} urami",
      other: "priblino {{count}} urami"
    },
    future: {
      one: "priblino {{count}} uro",
      two: "priblino {{count}} uri",
      few: "priblino {{count}} ure",
      other: "priblino {{count}} ur"
    }
  },
  xHours: {
    present: {
      one: "{{count}} ura",
      two: "{{count}} uri",
      few: "{{count}} ure",
      other: "{{count}} ur"
    },
    past: {
      one: "{{count}} uro",
      two: "{{count}} urama",
      few: "{{count}} urami",
      other: "{{count}} urami"
    },
    future: {
      one: "{{count}} uro",
      two: "{{count}} uri",
      few: "{{count}} ure",
      other: "{{count}} ur"
    }
  },
  xDays: {
    present: {
      one: "{{count}} dan",
      two: "{{count}} dni",
      few: "{{count}} dni",
      other: "{{count}} dni"
    },
    past: {
      one: "{{count}} dnem",
      two: "{{count}} dnevoma",
      few: "{{count}} dnevi",
      other: "{{count}} dnevi"
    },
    future: {
      one: "{{count}} dan",
      two: "{{count}} dni",
      few: "{{count}} dni",
      other: "{{count}} dni"
    }
  },
  // no tenses for weeks?
  aboutXWeeks: {
    one: "priblino {{count}} teden",
    two: "priblino {{count}} tedna",
    few: "priblino {{count}} tedne",
    other: "priblino {{count}} tednov"
  },
  // no tenses for weeks?
  xWeeks: {
    one: "{{count}} teden",
    two: "{{count}} tedna",
    few: "{{count}} tedne",
    other: "{{count}} tednov"
  },
  aboutXMonths: {
    present: {
      one: "priblino {{count}} mesec",
      two: "priblino {{count}} meseca",
      few: "priblino {{count}} mesece",
      other: "priblino {{count}} mesecev"
    },
    past: {
      one: "priblino {{count}} mesecem",
      two: "priblino {{count}} mesecema",
      few: "priblino {{count}} meseci",
      other: "priblino {{count}} meseci"
    },
    future: {
      one: "priblino {{count}} mesec",
      two: "priblino {{count}} meseca",
      few: "priblino {{count}} mesece",
      other: "priblino {{count}} mesecev"
    }
  },
  xMonths: {
    present: {
      one: "{{count}} mesec",
      two: "{{count}} meseca",
      few: "{{count}} meseci",
      other: "{{count}} mesecev"
    },
    past: {
      one: "{{count}} mesecem",
      two: "{{count}} mesecema",
      few: "{{count}} meseci",
      other: "{{count}} meseci"
    },
    future: {
      one: "{{count}} mesec",
      two: "{{count}} meseca",
      few: "{{count}} mesece",
      other: "{{count}} mesecev"
    }
  },
  aboutXYears: {
    present: {
      one: "priblino {{count}} leto",
      two: "priblino {{count}} leti",
      few: "priblino {{count}} leta",
      other: "priblino {{count}} let"
    },
    past: {
      one: "priblino {{count}} letom",
      two: "priblino {{count}} letoma",
      few: "priblino {{count}} leti",
      other: "priblino {{count}} leti"
    },
    future: {
      one: "priblino {{count}} leto",
      two: "priblino {{count}} leti",
      few: "priblino {{count}} leta",
      other: "priblino {{count}} let"
    }
  },
  xYears: {
    present: {
      one: "{{count}} leto",
      two: "{{count}} leti",
      few: "{{count}} leta",
      other: "{{count}} let"
    },
    past: {
      one: "{{count}} letom",
      two: "{{count}} letoma",
      few: "{{count}} leti",
      other: "{{count}} leti"
    },
    future: {
      one: "{{count}} leto",
      two: "{{count}} leti",
      few: "{{count}} leta",
      other: "{{count}} let"
    }
  },
  overXYears: {
    present: {
      one: "ve kot {{count}} leto",
      two: "ve kot {{count}} leti",
      few: "ve kot {{count}} leta",
      other: "ve kot {{count}} let"
    },
    past: {
      one: "ve kot {{count}} letom",
      two: "ve kot {{count}} letoma",
      few: "ve kot {{count}} leti",
      other: "ve kot {{count}} leti"
    },
    future: {
      one: "ve kot {{count}} leto",
      two: "ve kot {{count}} leti",
      few: "ve kot {{count}} leta",
      other: "ve kot {{count}} let"
    }
  },
  almostXYears: {
    present: {
      one: "skoraj {{count}} leto",
      two: "skoraj {{count}} leti",
      few: "skoraj {{count}} leta",
      other: "skoraj {{count}} let"
    },
    past: {
      one: "skoraj {{count}} letom",
      two: "skoraj {{count}} letoma",
      few: "skoraj {{count}} leti",
      other: "skoraj {{count}} leti"
    },
    future: {
      one: "skoraj {{count}} leto",
      two: "skoraj {{count}} leti",
      few: "skoraj {{count}} leta",
      other: "skoraj {{count}} let"
    }
  }
};
function getFormFromCount(count) {
  switch (count % 100) {
    case 1:
      return "one";
    case 2:
      return "two";
    case 3:
    case 4:
      return "few";
    default:
      return "other";
  }
}
const formatDistance$g = (token, count, options) => {
  let result = "";
  let tense = "present";
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      tense = "future";
      result = "ez ";
    } else {
      tense = "past";
      result = "pred ";
    }
  }
  const tokenValue = formatDistanceLocale$g[token];
  if (typeof tokenValue === "string") {
    result += tokenValue;
  } else {
    const form = getFormFromCount(count);
    if (isPluralType$1(tokenValue)) {
      result += tokenValue[form].replace("{{count}}", String(count));
    } else {
      result += tokenValue[tense][form].replace("{{count}}", String(count));
    }
  }
  return result;
};
const dateFormats$g = {
  full: "EEEE, dd. MMMM y",
  long: "dd. MMMM y",
  medium: "d. MMM y",
  short: "d. MM. yy"
};
const timeFormats$g = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$g = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$g = {
  date: buildFormatLongFn({
    formats: dateFormats$g,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$g,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$g,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$g = {
  lastWeek: (date2) => {
    const day = date2.getDay();
    switch (day) {
      case 0:
        return "'prejnjo nedeljo ob' p";
      case 3:
        return "'prejnjo sredo ob' p";
      case 6:
        return "'prejnjo soboto ob' p";
      default:
        return "'prejnji' EEEE 'ob' p";
    }
  },
  yesterday: "'veraj ob' p",
  today: "'danes ob' p",
  tomorrow: "'jutri ob' p",
  nextWeek: (date2) => {
    const day = date2.getDay();
    switch (day) {
      case 0:
        return "'naslednjo nedeljo ob' p";
      case 3:
        return "'naslednjo sredo ob' p";
      case 6:
        return "'naslednjo soboto ob' p";
      default:
        return "'naslednji' EEEE 'ob' p";
    }
  },
  other: "P"
};
const formatRelative$g = (token, date2, _baseDate, _options) => {
  const format2 = formatRelativeLocale$g[token];
  if (typeof format2 === "function") {
    return format2(date2);
  }
  return format2;
};
const eraValues$g = {
  narrow: ["pr. n. t.", "po n. t."],
  abbreviated: ["pr. n. t.", "po n. t."],
  wide: ["pred naim tetjem", "po naem tetju"]
};
const quarterValues$g = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1. et.", "2. et.", "3. et.", "4. et."],
  wide: ["1. etrtletje", "2. etrtletje", "3. etrtletje", "4. etrtletje"]
};
const monthValues$g = {
  narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "jan.",
    "feb.",
    "mar.",
    "apr.",
    "maj",
    "jun.",
    "jul.",
    "avg.",
    "sep.",
    "okt.",
    "nov.",
    "dec."
  ],
  wide: [
    "januar",
    "februar",
    "marec",
    "april",
    "maj",
    "junij",
    "julij",
    "avgust",
    "september",
    "oktober",
    "november",
    "december"
  ]
};
const dayValues$g = {
  narrow: ["n", "p", "t", "s", "", "p", "s"],
  short: ["ned.", "pon.", "tor.", "sre.", "et.", "pet.", "sob."],
  abbreviated: ["ned.", "pon.", "tor.", "sre.", "et.", "pet.", "sob."],
  wide: [
    "nedelja",
    "ponedeljek",
    "torek",
    "sreda",
    "etrtek",
    "petek",
    "sobota"
  ]
};
const dayPeriodValues$g = {
  narrow: {
    am: "d",
    pm: "p",
    midnight: "24.00",
    noon: "12.00",
    morning: "j",
    afternoon: "p",
    evening: "v",
    night: "n"
  },
  abbreviated: {
    am: "dop.",
    pm: "pop.",
    midnight: "poln.",
    noon: "pold.",
    morning: "jut.",
    afternoon: "pop.",
    evening: "ve.",
    night: "no"
  },
  wide: {
    am: "dop.",
    pm: "pop.",
    midnight: "polno",
    noon: "poldne",
    morning: "jutro",
    afternoon: "popoldne",
    evening: "veer",
    night: "no"
  }
};
const formattingDayPeriodValues$g = {
  narrow: {
    am: "d",
    pm: "p",
    midnight: "24.00",
    noon: "12.00",
    morning: "zj",
    afternoon: "p",
    evening: "zv",
    night: "po"
  },
  abbreviated: {
    am: "dop.",
    pm: "pop.",
    midnight: "opoln.",
    noon: "opold.",
    morning: "zjut.",
    afternoon: "pop.",
    evening: "zve.",
    night: "ponoi"
  },
  wide: {
    am: "dop.",
    pm: "pop.",
    midnight: "opolnoi",
    noon: "opoldne",
    morning: "zjutraj",
    afternoon: "popoldan",
    evening: "zveer",
    night: "ponoi"
  }
};
const ordinalNumber$g = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$g = {
  ordinalNumber: ordinalNumber$g,
  era: buildLocalizeFn({
    values: eraValues$g,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$g,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$g,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$g,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$g,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$g,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$g = /^(\d+)\./i;
const parseOrdinalNumberPattern$g = /\d+/i;
const matchEraPatterns$g = {
  abbreviated: /^(pr\. n\. t\.|po n\. t\.)/i,
  wide: /^(pred Kristusom|pred na[s]im [s]tetjem|po Kristusu|po na[s]em [s]tetju|na[s]ega [s]tetja)/i
};
const parseEraPatterns$g = {
  any: [/^pr/i, /^(po|na[s]em)/i]
};
const matchQuarterPatterns$g = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]\.\s?[c]et\.?/i,
  wide: /^[1234]\. [c]etrtletje/i
};
const parseQuarterPatterns$g = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$g = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan\.|feb\.|mar\.|apr\.|maj|jun\.|jul\.|avg\.|sep\.|okt\.|nov\.|dec\.)/i,
  wide: /^(januar|februar|marec|april|maj|junij|julij|avgust|september|oktober|november|december)/i
};
const parseMonthPatterns$g = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  abbreviated: [
    /^ja/i,
    /^fe/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^av/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  wide: [
    /^ja/i,
    /^fe/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^av/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$g = {
  narrow: /^[nptsc]/i,
  short: /^(ned\.|pon\.|tor\.|sre\.|[c]et\.|pet\.|sob\.)/i,
  abbreviated: /^(ned\.|pon\.|tor\.|sre\.|[c]et\.|pet\.|sob\.)/i,
  wide: /^(nedelja|ponedeljek|torek|sreda|[c]etrtek|petek|sobota)/i
};
const parseDayPatterns$g = {
  narrow: [/^n/i, /^p/i, /^t/i, /^s/i, /^[c]/i, /^p/i, /^s/i],
  any: [/^n/i, /^po/i, /^t/i, /^sr/i, /^[c]/i, /^pe/i, /^so/i]
};
const matchDayPeriodPatterns$g = {
  narrow: /^(d|po?|z?v|n|z?j|24\.00|12\.00)/i,
  any: /^(dop\.|pop\.|o?poln(\.|o[c]i?)|o?pold(\.|ne)|z?ve[c](\.|er)|(po)?no[c]i?|popold(ne|an)|jut(\.|ro)|zjut(\.|raj))/i
};
const parseDayPeriodPatterns$g = {
  narrow: {
    am: /^d/i,
    pm: /^p/i,
    midnight: /^24/i,
    noon: /^12/i,
    morning: /^(z?j)/i,
    afternoon: /^p/i,
    evening: /^(z?v)/i,
    night: /^(n|po)/i
  },
  any: {
    am: /^dop\./i,
    pm: /^pop\./i,
    midnight: /^o?poln/i,
    noon: /^o?pold/i,
    morning: /j/i,
    afternoon: /^pop\./i,
    evening: /^z?ve/i,
    night: /(po)?no/i
  }
};
const match$g = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$g,
    parsePattern: parseOrdinalNumberPattern$g,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$g,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$g,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$g,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$g,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$g,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$g,
    defaultParseWidth: "wide"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$g,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$g,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$g,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$g,
    defaultParseWidth: "any"
  })
};
const sl = {
  code: "sl",
  formatDistance: formatDistance$g,
  formatLong: formatLong$g,
  formatRelative: formatRelative$g,
  localize: localize$g,
  match: match$g,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$f = {
  lessThanXSeconds: {
    one: "m pak se nj sekond",
    other: "m pak se {{count}} sekonda"
  },
  xSeconds: {
    one: "1 sekond",
    other: "{{count}} sekonda"
  },
  halfAMinute: "gjysm minuti",
  lessThanXMinutes: {
    one: "m pak se nj minute",
    other: "m pak se {{count}} minuta"
  },
  xMinutes: {
    one: "1 minut",
    other: "{{count}} minuta"
  },
  aboutXHours: {
    one: "rreth 1 or",
    other: "rreth {{count}} or"
  },
  xHours: {
    one: "1 or",
    other: "{{count}} or"
  },
  xDays: {
    one: "1 dit",
    other: "{{count}} dit"
  },
  aboutXWeeks: {
    one: "rreth 1 jav",
    other: "rreth {{count}} jav"
  },
  xWeeks: {
    one: "1 jav",
    other: "{{count}} jav"
  },
  aboutXMonths: {
    one: "rreth 1 muaj",
    other: "rreth {{count}} muaj"
  },
  xMonths: {
    one: "1 muaj",
    other: "{{count}} muaj"
  },
  aboutXYears: {
    one: "rreth 1 vit",
    other: "rreth {{count}} vite"
  },
  xYears: {
    one: "1 vit",
    other: "{{count}} vite"
  },
  overXYears: {
    one: "mbi 1 vit",
    other: "mbi {{count}} vite"
  },
  almostXYears: {
    one: "pothuajse 1 vit",
    other: "pothuajse {{count}} vite"
  }
};
const formatDistance$f = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$f[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "n " + result;
    } else {
      return result + " m par";
    }
  }
  return result;
};
const dateFormats$f = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
const timeFormats$f = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$f = {
  full: "{{date}} 'n' {{time}}",
  long: "{{date}} 'n' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$f = {
  date: buildFormatLongFn({
    formats: dateFormats$f,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$f,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$f,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$f = {
  lastWeek: "'t' eeee 'e shkuar n' p",
  yesterday: "'dje n' p",
  today: "'sot n' p",
  tomorrow: "'nesr n' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
const formatRelative$f = (token, _date, _baseDate, _options) => formatRelativeLocale$f[token];
const eraValues$f = {
  narrow: ["P", "M"],
  abbreviated: ["PK", "MK"],
  wide: ["Para Krishtit", "Mbas Krishtit"]
};
const quarterValues$f = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["4-mujori I", "4-mujori II", "4-mujori III", "4-mujori IV"]
};
const monthValues$f = {
  narrow: ["J", "S", "M", "P", "M", "Q", "K", "G", "S", "T", "N", "D"],
  abbreviated: [
    "Jan",
    "Shk",
    "Mar",
    "Pri",
    "Maj",
    "Qer",
    "Kor",
    "Gus",
    "Sht",
    "Tet",
    "Nn",
    "Dhj"
  ],
  wide: [
    "Janar",
    "Shkurt",
    "Mars",
    "Prill",
    "Maj",
    "Qershor",
    "Korrik",
    "Gusht",
    "Shtator",
    "Tetor",
    "Nntor",
    "Dhjetor"
  ]
};
const dayValues$f = {
  narrow: ["D", "H", "M", "M", "E", "P", "S"],
  short: ["Di", "H", "Ma", "M", "En", "Pr", "Sh"],
  abbreviated: ["Die", "Hn", "Mar", "Mr", "Enj", "Pre", "Sht"],
  wide: ["Diel", "Hn", "Mart", "Mrkur", "Enjte", "Premte", "Shtun"]
};
const dayPeriodValues$f = {
  narrow: {
    am: "p",
    pm: "m",
    midnight: "m",
    noon: "d",
    morning: "mngjes",
    afternoon: "dite",
    evening: "mbrmje",
    night: "nat"
  },
  abbreviated: {
    am: "PD",
    pm: "MD",
    midnight: "mesnt",
    noon: "drek",
    morning: "mngjes",
    afternoon: "mbasdite",
    evening: "mbrmje",
    night: "nat"
  },
  wide: {
    am: "p.d.",
    pm: "m.d.",
    midnight: "mesnt",
    noon: "drek",
    morning: "mngjes",
    afternoon: "mbasdite",
    evening: "mbrmje",
    night: "nat"
  }
};
const formattingDayPeriodValues$f = {
  narrow: {
    am: "p",
    pm: "m",
    midnight: "m",
    noon: "d",
    morning: "n mngjes",
    afternoon: "n mbasdite",
    evening: "n mbrmje",
    night: "n mesnat"
  },
  abbreviated: {
    am: "PD",
    pm: "MD",
    midnight: "mesnat",
    noon: "drek",
    morning: "n mngjes",
    afternoon: "n mbasdite",
    evening: "n mbrmje",
    night: "n mesnat"
  },
  wide: {
    am: "p.d.",
    pm: "m.d.",
    midnight: "mesnat",
    noon: "drek",
    morning: "n mngjes",
    afternoon: "n mbasdite",
    evening: "n mbrmje",
    night: "n mesnat"
  }
};
const ordinalNumber$f = (dirtyNumber, options) => {
  const number2 = Number(dirtyNumber);
  if (options?.unit === "hour") return String(number2);
  if (number2 === 1) return number2 + "-r";
  if (number2 === 4) return number2 + "t";
  return number2 + "-t";
};
const localize$f = {
  ordinalNumber: ordinalNumber$f,
  era: buildLocalizeFn({
    values: eraValues$f,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$f,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$f,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$f,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$f,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$f,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$f = /^(\d+)(-r|-t|t|)?/i;
const parseOrdinalNumberPattern$f = /\d+/i;
const matchEraPatterns$f = {
  narrow: /^(p|m)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(para krishtit|mbas krishtit)/i
};
const parseEraPatterns$f = {
  any: [/^b/i, /^(p|m)/i]
};
const matchQuarterPatterns$f = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234]-mujori (i{1,3}|iv)/i
};
const parseQuarterPatterns$f = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$f = {
  narrow: /^[jsmpqkftnd]/i,
  abbreviated: /^(jan|shk|mar|pri|maj|qer|kor|gus|sht|tet|nn|dhj)/i,
  wide: /^(janar|shkurt|mars|prill|maj|qershor|korrik|gusht|shtator|tetor|nntor|dhjetor)/i
};
const parseMonthPatterns$f = {
  narrow: [
    /^j/i,
    /^s/i,
    /^m/i,
    /^p/i,
    /^m/i,
    /^q/i,
    /^k/i,
    /^g/i,
    /^s/i,
    /^t/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^shk/i,
    /^mar/i,
    /^pri/i,
    /^maj/i,
    /^qer/i,
    /^kor/i,
    /^gu/i,
    /^sht/i,
    /^tet/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$f = {
  narrow: /^[dhmeps]/i,
  short: /^(di|h|ma|m|en|pr|sh)/i,
  abbreviated: /^(die|hn|mar|mr|enj|pre|sht)/i,
  wide: /^(diel|hn|mart|mrkur|enjte|premte|shtun)/i
};
const parseDayPatterns$f = {
  narrow: [/^d/i, /^h/i, /^m/i, /^m/i, /^e/i, /^p/i, /^s/i],
  any: [/^d/i, /^h/i, /^ma/i, /^m/i, /^e/i, /^p/i, /^s/i]
};
const matchDayPeriodPatterns$f = {
  narrow: /^(p|m|me|n (mngjes|mbasdite|mbrmje|mesnat))/i,
  any: /^([pm]\.?\s?d\.?|drek|n (mngjes|mbasdite|mbrmje|mesnat))/i
};
const parseDayPeriodPatterns$f = {
  any: {
    am: /^p/i,
    pm: /^m/i,
    midnight: /^me/i,
    noon: /^dr/i,
    morning: /mngjes/i,
    afternoon: /mbasdite/i,
    evening: /mbrmje/i,
    night: /nat/i
  }
};
const match$f = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$f,
    parsePattern: parseOrdinalNumberPattern$f,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$f,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$f,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$f,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$f,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$f,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$f,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$f,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$f,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$f,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$f,
    defaultParseWidth: "any"
  })
};
const sq = {
  code: "sq",
  formatDistance: formatDistance$f,
  formatLong: formatLong$f,
  formatRelative: formatRelative$f,
  localize: localize$f,
  match: match$f,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$e = {
  lessThanXSeconds: {
    one: {
      standalone: "  1 ",
      withPrepositionAgo: "  1 ",
      withPrepositionIn: "  1 "
    },
    dual: "  {{count}} ",
    other: "  {{count}} "
  },
  xSeconds: {
    one: {
      standalone: "1 ",
      withPrepositionAgo: "1 ",
      withPrepositionIn: "1 "
    },
    dual: "{{count}} ",
    other: "{{count}} "
  },
  halfAMinute: " ",
  lessThanXMinutes: {
    one: {
      standalone: "  1 ",
      withPrepositionAgo: "  1 ",
      withPrepositionIn: "  1 "
    },
    dual: "  {{count}} ",
    other: "  {{count}} "
  },
  xMinutes: {
    one: {
      standalone: "1 ",
      withPrepositionAgo: "1 ",
      withPrepositionIn: "1 "
    },
    dual: "{{count}} ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: {
      standalone: " 1 ",
      withPrepositionAgo: " 1 ",
      withPrepositionIn: " 1 "
    },
    dual: " {{count}} ",
    other: " {{count}} "
  },
  xHours: {
    one: {
      standalone: "1 ",
      withPrepositionAgo: "1 ",
      withPrepositionIn: "1 "
    },
    dual: "{{count}} ",
    other: "{{count}} "
  },
  xDays: {
    one: {
      standalone: "1 ",
      withPrepositionAgo: "1 ",
      withPrepositionIn: "1 "
    },
    dual: "{{count}} ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: {
      standalone: " 1 ",
      withPrepositionAgo: " 1 ",
      withPrepositionIn: " 1 "
    },
    dual: " {{count}} ",
    other: " {{count}} "
  },
  xWeeks: {
    one: {
      standalone: "1 ",
      withPrepositionAgo: "1 ",
      withPrepositionIn: "1 "
    },
    dual: "{{count}} ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: {
      standalone: " 1 ",
      withPrepositionAgo: " 1 ",
      withPrepositionIn: " 1 "
    },
    dual: " {{count}} ",
    other: " {{count}} "
  },
  xMonths: {
    one: {
      standalone: "1 ",
      withPrepositionAgo: "1 ",
      withPrepositionIn: "1 "
    },
    dual: "{{count}} ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: {
      standalone: " 1 ",
      withPrepositionAgo: " 1 ",
      withPrepositionIn: " 1 "
    },
    dual: " {{count}} ",
    other: " {{count}} "
  },
  xYears: {
    one: {
      standalone: "1 ",
      withPrepositionAgo: "1 ",
      withPrepositionIn: "1 "
    },
    dual: "{{count}} ",
    other: "{{count}} "
  },
  overXYears: {
    one: {
      standalone: " 1 ",
      withPrepositionAgo: " 1 ",
      withPrepositionIn: " 1 "
    },
    dual: " {{count}} ",
    other: " {{count}} "
  },
  almostXYears: {
    one: {
      standalone: " 1 ",
      withPrepositionAgo: " 1 ",
      withPrepositionIn: " 1 "
    },
    dual: " {{count}} ",
    other: " {{count}} "
  }
};
const formatDistance$e = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$e[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    if (options?.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        result = tokenValue.one.withPrepositionIn;
      } else {
        result = tokenValue.one.withPrepositionAgo;
      }
    } else {
      result = tokenValue.one.standalone;
    }
  } else if (count % 10 > 1 && count % 10 < 5 && // if last digit is between 2 and 4
  String(count).substr(-2, 1) !== "1") {
    result = tokenValue.dual.replace("{{count}}", String(count));
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return " " + result;
    } else {
      return " " + result;
    }
  }
  return result;
};
const dateFormats$e = {
  full: "EEEE, d. MMMM yyyy.",
  long: "d. MMMM yyyy.",
  medium: "d. MMM yy.",
  short: "dd. MM. yy."
};
const timeFormats$e = {
  full: "HH:mm:ss (zzzz)",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$e = {
  full: "{{date}} '' {{time}}",
  long: "{{date}} '' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$e = {
  date: buildFormatLongFn({
    formats: dateFormats$e,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$e,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$e,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$e = {
  lastWeek: (date2) => {
    const day = date2.getDay();
    switch (day) {
      case 0:
        return "'  ' p";
      case 3:
        return "'  ' p";
      case 6:
        return "'  ' p";
      default:
        return "'' EEEE '' p";
    }
  },
  yesterday: "' ' p",
  today: "' ' p",
  tomorrow: "' ' p",
  nextWeek: (date2) => {
    const day = date2.getDay();
    switch (day) {
      case 0:
        return "'  ' p";
      case 3:
        return "'  ' p";
      case 6:
        return "'  ' p";
      default:
        return "'' EEEE '' p";
    }
  },
  other: "P"
};
const formatRelative$e = (token, date2, _baseDate, _options) => {
  const format2 = formatRelativeLocale$e[token];
  if (typeof format2 === "function") {
    return format2(date2);
  }
  return format2;
};
const eraValues$e = {
  narrow: ["...", ""],
  abbreviated: [". .", ". ."],
  wide: [" ", " "]
};
const quarterValues$e = {
  narrow: ["1.", "2.", "3.", "4."],
  abbreviated: ["1. .", "2. .", "3. .", "4. ."],
  wide: ["1. ", "2. ", "3. ", "4. "]
};
const monthValues$e = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12."
  ],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const formattingMonthValues$3 = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12."
  ],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$e = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const formattingDayPeriodValues$e = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  }
};
const dayPeriodValues$e = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  }
};
const ordinalNumber$e = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$e = {
  ordinalNumber: ordinalNumber$e,
  era: buildLocalizeFn({
    values: eraValues$e,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$e,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$e,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$3,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$e,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$e,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$e,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$e = /^(\d+)\./i;
const parseOrdinalNumberPattern$e = /\d+/i;
const matchEraPatterns$e = {
  narrow: /^(\.\.\.|)/i,
  abbreviated: /^(\.\s?\.|\.\s?\.)/i,
  wide: /^( |  | | )/i
};
const parseEraPatterns$e = {
  any: [/^/i, /^(|)/i]
};
const matchQuarterPatterns$e = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]\.\s?\.?/i,
  wide: /^[1234]\. /i
};
const parseQuarterPatterns$e = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$e = {
  narrow: /^(10|11|12|[123456789])\./i,
  abbreviated: /^(|||||||||||)/i,
  wide: /^((|)|(|)|(|)|(|)|(|)|(|)|(|)|(|)|(|)|(|)|(|)|(|))/i
};
const parseMonthPatterns$e = {
  narrow: [
    /^1/i,
    /^2/i,
    /^3/i,
    /^4/i,
    /^5/i,
    /^6/i,
    /^7/i,
    /^8/i,
    /^9/i,
    /^10/i,
    /^11/i,
    /^12/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$e = {
  narrow: /^[]/i,
  short: /^(||||||)/i,
  abbreviated: /^(||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$e = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$e = {
  any: /^(|||()?||| |)/i
};
const parseDayPeriodPatterns$e = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^/i,
    noon: /^/i,
    morning: //i,
    afternoon: /(\s|)+/i,
    evening: /()/i,
    night: /()/i
  }
};
const match$e = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$e,
    parsePattern: parseOrdinalNumberPattern$e,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$e,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$e,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$e,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$e,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$e,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$e,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$e,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$e,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$e,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$e,
    defaultParseWidth: "any"
  })
};
const sr = {
  code: "sr",
  formatDistance: formatDistance$e,
  formatLong: formatLong$e,
  formatRelative: formatRelative$e,
  localize: localize$e,
  match: match$e,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$d = {
  lessThanXSeconds: {
    one: {
      standalone: "manje od 1 sekunde",
      withPrepositionAgo: "manje od 1 sekunde",
      withPrepositionIn: "manje od 1 sekundu"
    },
    dual: "manje od {{count}} sekunde",
    other: "manje od {{count}} sekundi"
  },
  xSeconds: {
    one: {
      standalone: "1 sekunda",
      withPrepositionAgo: "1 sekunde",
      withPrepositionIn: "1 sekundu"
    },
    dual: "{{count}} sekunde",
    other: "{{count}} sekundi"
  },
  halfAMinute: "pola minute",
  lessThanXMinutes: {
    one: {
      standalone: "manje od 1 minute",
      withPrepositionAgo: "manje od 1 minute",
      withPrepositionIn: "manje od 1 minutu"
    },
    dual: "manje od {{count}} minute",
    other: "manje od {{count}} minuta"
  },
  xMinutes: {
    one: {
      standalone: "1 minuta",
      withPrepositionAgo: "1 minute",
      withPrepositionIn: "1 minutu"
    },
    dual: "{{count}} minute",
    other: "{{count}} minuta"
  },
  aboutXHours: {
    one: {
      standalone: "oko 1 sat",
      withPrepositionAgo: "oko 1 sat",
      withPrepositionIn: "oko 1 sat"
    },
    dual: "oko {{count}} sata",
    other: "oko {{count}} sati"
  },
  xHours: {
    one: {
      standalone: "1 sat",
      withPrepositionAgo: "1 sat",
      withPrepositionIn: "1 sat"
    },
    dual: "{{count}} sata",
    other: "{{count}} sati"
  },
  xDays: {
    one: {
      standalone: "1 dan",
      withPrepositionAgo: "1 dan",
      withPrepositionIn: "1 dan"
    },
    dual: "{{count}} dana",
    other: "{{count}} dana"
  },
  aboutXWeeks: {
    one: {
      standalone: "oko 1 nedelju",
      withPrepositionAgo: "oko 1 nedelju",
      withPrepositionIn: "oko 1 nedelju"
    },
    dual: "oko {{count}} nedelje",
    other: "oko {{count}} nedelje"
  },
  xWeeks: {
    one: {
      standalone: "1 nedelju",
      withPrepositionAgo: "1 nedelju",
      withPrepositionIn: "1 nedelju"
    },
    dual: "{{count}} nedelje",
    other: "{{count}} nedelje"
  },
  aboutXMonths: {
    one: {
      standalone: "oko 1 mesec",
      withPrepositionAgo: "oko 1 mesec",
      withPrepositionIn: "oko 1 mesec"
    },
    dual: "oko {{count}} meseca",
    other: "oko {{count}} meseci"
  },
  xMonths: {
    one: {
      standalone: "1 mesec",
      withPrepositionAgo: "1 mesec",
      withPrepositionIn: "1 mesec"
    },
    dual: "{{count}} meseca",
    other: "{{count}} meseci"
  },
  aboutXYears: {
    one: {
      standalone: "oko 1 godinu",
      withPrepositionAgo: "oko 1 godinu",
      withPrepositionIn: "oko 1 godinu"
    },
    dual: "oko {{count}} godine",
    other: "oko {{count}} godina"
  },
  xYears: {
    one: {
      standalone: "1 godina",
      withPrepositionAgo: "1 godine",
      withPrepositionIn: "1 godinu"
    },
    dual: "{{count}} godine",
    other: "{{count}} godina"
  },
  overXYears: {
    one: {
      standalone: "preko 1 godinu",
      withPrepositionAgo: "preko 1 godinu",
      withPrepositionIn: "preko 1 godinu"
    },
    dual: "preko {{count}} godine",
    other: "preko {{count}} godina"
  },
  almostXYears: {
    one: {
      standalone: "gotovo 1 godinu",
      withPrepositionAgo: "gotovo 1 godinu",
      withPrepositionIn: "gotovo 1 godinu"
    },
    dual: "gotovo {{count}} godine",
    other: "gotovo {{count}} godina"
  }
};
const formatDistance$d = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$d[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    if (options?.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        result = tokenValue.one.withPrepositionIn;
      } else {
        result = tokenValue.one.withPrepositionAgo;
      }
    } else {
      result = tokenValue.one.standalone;
    }
  } else if (count % 10 > 1 && count % 10 < 5 && // if last digit is between 2 and 4
  String(count).substr(-2, 1) !== "1") {
    result = tokenValue.dual.replace("{{count}}", String(count));
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "za " + result;
    } else {
      return "pre " + result;
    }
  }
  return result;
};
const dateFormats$d = {
  full: "EEEE, d. MMMM yyyy.",
  long: "d. MMMM yyyy.",
  medium: "d. MMM yy.",
  short: "dd. MM. yy."
};
const timeFormats$d = {
  full: "HH:mm:ss (zzzz)",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$d = {
  full: "{{date}} 'u' {{time}}",
  long: "{{date}} 'u' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$d = {
  date: buildFormatLongFn({
    formats: dateFormats$d,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$d,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$d,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$d = {
  lastWeek: (date2) => {
    switch (date2.getDay()) {
      case 0:
        return "'prole nedelje u' p";
      case 3:
        return "'prole srede u' p";
      case 6:
        return "'prole subote u' p";
      default:
        return "'proli' EEEE 'u' p";
    }
  },
  yesterday: "'jue u' p",
  today: "'danas u' p",
  tomorrow: "'sutra u' p",
  nextWeek: (date2) => {
    switch (date2.getDay()) {
      case 0:
        return "'sledee nedelje u' p";
      case 3:
        return "'sledeu sredu u' p";
      case 6:
        return "'sledeu subotu u' p";
      default:
        return "'sledei' EEEE 'u' p";
    }
  },
  other: "P"
};
const formatRelative$d = (token, date2, _baseDate, _options) => {
  const format2 = formatRelativeLocale$d[token];
  if (typeof format2 === "function") {
    return format2(date2);
  }
  return format2;
};
const eraValues$d = {
  narrow: ["pr.n.e.", "AD"],
  abbreviated: ["pr. Hr.", "po. Hr."],
  wide: ["Pre Hrista", "Posle Hrista"]
};
const quarterValues$d = {
  narrow: ["1.", "2.", "3.", "4."],
  abbreviated: ["1. kv.", "2. kv.", "3. kv.", "4. kv."],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
const monthValues$d = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12."
  ],
  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "maj",
    "jun",
    "jul",
    "avg",
    "sep",
    "okt",
    "nov",
    "dec"
  ],
  wide: [
    "januar",
    "februar",
    "mart",
    "april",
    "maj",
    "jun",
    "jul",
    "avgust",
    "septembar",
    "oktobar",
    "novembar",
    "decembar"
  ]
};
const formattingMonthValues$2 = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12."
  ],
  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "maj",
    "jun",
    "jul",
    "avg",
    "sep",
    "okt",
    "nov",
    "dec"
  ],
  wide: [
    "januar",
    "februar",
    "mart",
    "april",
    "maj",
    "jun",
    "jul",
    "avgust",
    "septembar",
    "oktobar",
    "novembar",
    "decembar"
  ]
};
const dayValues$d = {
  narrow: ["N", "P", "U", "S", "", "P", "S"],
  short: ["ned", "pon", "uto", "sre", "et", "pet", "sub"],
  abbreviated: ["ned", "pon", "uto", "sre", "et", "pet", "sub"],
  wide: [
    "nedelja",
    "ponedeljak",
    "utorak",
    "sreda",
    "etvrtak",
    "petak",
    "subota"
  ]
};
const formattingDayPeriodValues$d = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "pono",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uvee",
    night: "nou"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "pono",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uvee",
    night: "nou"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "pono",
    noon: "podne",
    morning: "ujutru",
    afternoon: "posle podne",
    evening: "uvee",
    night: "nou"
  }
};
const dayPeriodValues$d = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "pono",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uvee",
    night: "nou"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "pono",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uvee",
    night: "nou"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "pono",
    noon: "podne",
    morning: "ujutru",
    afternoon: "posle podne",
    evening: "uvee",
    night: "nou"
  }
};
const ordinalNumber$d = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$d = {
  ordinalNumber: ordinalNumber$d,
  era: buildLocalizeFn({
    values: eraValues$d,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$d,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$d,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$2,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$d,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$d,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$d,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$d = /^(\d+)\./i;
const parseOrdinalNumberPattern$d = /\d+/i;
const matchEraPatterns$d = {
  narrow: /^(pr\.n\.e\.|AD)/i,
  abbreviated: /^(pr\.\s?Hr\.|po\.\s?Hr\.)/i,
  wide: /^(Pre Hrista|pre nove ere|Posle Hrista|nova era)/i
};
const parseEraPatterns$d = {
  any: [/^pr/i, /^(po|nova)/i]
};
const matchQuarterPatterns$d = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]\.\s?kv\.?/i,
  wide: /^[1234]\. kvartal/i
};
const parseQuarterPatterns$d = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$d = {
  narrow: /^(10|11|12|[123456789])\./i,
  abbreviated: /^(jan|feb|mar|apr|maj|jun|jul|avg|sep|okt|nov|dec)/i,
  wide: /^((januar|januara)|(februar|februara)|(mart|marta)|(april|aprila)|(maj|maja)|(jun|juna)|(jul|jula)|(avgust|avgusta)|(septembar|septembra)|(oktobar|oktobra)|(novembar|novembra)|(decembar|decembra))/i
};
const parseMonthPatterns$d = {
  narrow: [
    /^1/i,
    /^2/i,
    /^3/i,
    /^4/i,
    /^5/i,
    /^6/i,
    /^7/i,
    /^8/i,
    /^9/i,
    /^10/i,
    /^11/i,
    /^12/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^avg/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$d = {
  narrow: /^[npusc]/i,
  short: /^(ned|pon|uto|sre|(et|cet)|pet|sub)/i,
  abbreviated: /^(ned|pon|uto|sre|(et|cet)|pet|sub)/i,
  wide: /^(nedelja|ponedeljak|utorak|sreda|(etvrtak|cetvrtak)|petak|subota)/i
};
const parseDayPatterns$d = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns$d = {
  any: /^(am|pm|ponoc|pono|(po)?podne|uvece|uvee|nou|posle podne|ujutru)/i
};
const parseDayPeriodPatterns$d = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^pono/i,
    noon: /^pod/i,
    morning: /jutro/i,
    afternoon: /(posle\s|po)+podne/i,
    evening: /(uvece|uvee)/i,
    night: /(nocu|nou)/i
  }
};
const match$d = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$d,
    parsePattern: parseOrdinalNumberPattern$d,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$d,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$d,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$d,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$d,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$d,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$d,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$d,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$d,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$d,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$d,
    defaultParseWidth: "any"
  })
};
const srLatn = {
  code: "sr-Latn",
  formatDistance: formatDistance$d,
  formatLong: formatLong$d,
  formatRelative: formatRelative$d,
  localize: localize$d,
  match: match$d,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$c = {
  lessThanXSeconds: {
    one: "mindre n en sekund",
    other: "mindre n {{count}} sekunder"
  },
  xSeconds: {
    one: "en sekund",
    other: "{{count}} sekunder"
  },
  halfAMinute: "en halv minut",
  lessThanXMinutes: {
    one: "mindre n en minut",
    other: "mindre n {{count}} minuter"
  },
  xMinutes: {
    one: "en minut",
    other: "{{count}} minuter"
  },
  aboutXHours: {
    one: "ungefr en timme",
    other: "ungefr {{count}} timmar"
  },
  xHours: {
    one: "en timme",
    other: "{{count}} timmar"
  },
  xDays: {
    one: "en dag",
    other: "{{count}} dagar"
  },
  aboutXWeeks: {
    one: "ungefr en vecka",
    other: "ungefr {{count}} veckor"
  },
  xWeeks: {
    one: "en vecka",
    other: "{{count}} veckor"
  },
  aboutXMonths: {
    one: "ungefr en mnad",
    other: "ungefr {{count}} mnader"
  },
  xMonths: {
    one: "en mnad",
    other: "{{count}} mnader"
  },
  aboutXYears: {
    one: "ungefr ett r",
    other: "ungefr {{count}} r"
  },
  xYears: {
    one: "ett r",
    other: "{{count}} r"
  },
  overXYears: {
    one: "ver ett r",
    other: "ver {{count}} r"
  },
  almostXYears: {
    one: "nstan ett r",
    other: "nstan {{count}} r"
  }
};
const wordMapping = [
  "noll",
  "en",
  "tv",
  "tre",
  "fyra",
  "fem",
  "sex",
  "sju",
  "tta",
  "nio",
  "tio",
  "elva",
  "tolv"
];
const formatDistance$c = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$c[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace(
      "{{count}}",
      count < 13 ? wordMapping[count] : String(count)
    );
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "om " + result;
    } else {
      return result + " sedan";
    }
  }
  return result;
};
const dateFormats$c = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "y-MM-dd"
};
const timeFormats$c = {
  full: "'kl'. HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$c = {
  full: "{{date}} 'kl.' {{time}}",
  long: "{{date}} 'kl.' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$c = {
  date: buildFormatLongFn({
    formats: dateFormats$c,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$c,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$c,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$c = {
  lastWeek: "'i' EEEE's kl.' p",
  yesterday: "'igr kl.' p",
  today: "'idag kl.' p",
  tomorrow: "'imorgon kl.' p",
  nextWeek: "EEEE 'kl.' p",
  other: "P"
};
const formatRelative$c = (token, _date, _baseDate, _options) => formatRelativeLocale$c[token];
const eraValues$c = {
  narrow: ["f.Kr.", "e.Kr."],
  abbreviated: ["f.Kr.", "e.Kr."],
  wide: ["fre Kristus", "efter Kristus"]
};
const quarterValues$c = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1:a kvartalet", "2:a kvartalet", "3:e kvartalet", "4:e kvartalet"]
};
const monthValues$c = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mars",
    "apr.",
    "maj",
    "juni",
    "juli",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "dec."
  ],
  wide: [
    "januari",
    "februari",
    "mars",
    "april",
    "maj",
    "juni",
    "juli",
    "augusti",
    "september",
    "oktober",
    "november",
    "december"
  ]
};
const dayValues$c = {
  narrow: ["S", "M", "T", "O", "T", "F", "L"],
  short: ["s", "m", "ti", "on", "to", "fr", "l"],
  abbreviated: ["sn", "mn", "tis", "ons", "tors", "fre", "lr"],
  wide: ["sndag", "mndag", "tisdag", "onsdag", "torsdag", "fredag", "lrdag"]
};
const dayPeriodValues$c = {
  narrow: {
    am: "fm",
    pm: "em",
    midnight: "midnatt",
    noon: "middag",
    morning: "morg.",
    afternoon: "efterm.",
    evening: "kvll",
    night: "natt"
  },
  abbreviated: {
    am: "f.m.",
    pm: "e.m.",
    midnight: "midnatt",
    noon: "middag",
    morning: "morgon",
    afternoon: "efterm.",
    evening: "kvll",
    night: "natt"
  },
  wide: {
    am: "frmiddag",
    pm: "eftermiddag",
    midnight: "midnatt",
    noon: "middag",
    morning: "morgon",
    afternoon: "eftermiddag",
    evening: "kvll",
    night: "natt"
  }
};
const formattingDayPeriodValues$c = {
  narrow: {
    am: "fm",
    pm: "em",
    midnight: "midnatt",
    noon: "middag",
    morning: "p morg.",
    afternoon: "p efterm.",
    evening: "p kvllen",
    night: "p natten"
  },
  abbreviated: {
    am: "fm",
    pm: "em",
    midnight: "midnatt",
    noon: "middag",
    morning: "p morg.",
    afternoon: "p efterm.",
    evening: "p kvllen",
    night: "p natten"
  },
  wide: {
    am: "fm",
    pm: "em",
    midnight: "midnatt",
    noon: "middag",
    morning: "p morgonen",
    afternoon: "p eftermiddagen",
    evening: "p kvllen",
    night: "p natten"
  }
};
const ordinalNumber$c = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  const rem100 = number2 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
      case 2:
        return number2 + ":a";
    }
  }
  return number2 + ":e";
};
const localize$c = {
  ordinalNumber: ordinalNumber$c,
  era: buildLocalizeFn({
    values: eraValues$c,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$c,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$c,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$c,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$c,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$c,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$c = /^(\d+)(:a|:e)?/i;
const parseOrdinalNumberPattern$c = /\d+/i;
const matchEraPatterns$c = {
  narrow: /^(f\.? ?Kr\.?|f\.? ?v\.? ?t\.?|e\.? ?Kr\.?|v\.? ?t\.?)/i,
  abbreviated: /^(f\.? ?Kr\.?|f\.? ?v\.? ?t\.?|e\.? ?Kr\.?|v\.? ?t\.?)/i,
  wide: /^(fre Kristus|fre vr tid|efter Kristus|vr tid)/i
};
const parseEraPatterns$c = {
  any: [/^f/i, /^[ev]/i]
};
const matchQuarterPatterns$c = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](:a|:e)? kvartalet/i
};
const parseQuarterPatterns$c = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$c = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar[s]?|apr|maj|jun[i]?|jul[i]?|aug|sep|okt|nov|dec)\.?/i,
  wide: /^(januari|februari|mars|april|maj|juni|juli|augusti|september|oktober|november|december)/i
};
const parseMonthPatterns$c = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$c = {
  narrow: /^[smtofl]/i,
  short: /^(s|m|ti|on|to|fr|l)/i,
  abbreviated: /^(sn|mn|tis|ons|tors|fre|lr)/i,
  wide: /^(sndag|mndag|tisdag|onsdag|torsdag|fredag|lrdag)/i
};
const parseDayPatterns$c = {
  any: [/^s/i, /^m/i, /^ti/i, /^o/i, /^to/i, /^f/i, /^l/i]
};
const matchDayPeriodPatterns$c = {
  any: /^([fe]\.?\s?m\.?|midn(att)?|midd(ag)?|(p) (morgonen|eftermiddagen|kvllen|natten))/i
};
const parseDayPeriodPatterns$c = {
  any: {
    am: /^f/i,
    pm: /^e/i,
    midnight: /^midn/i,
    noon: /^midd/i,
    morning: /morgon/i,
    afternoon: /eftermiddag/i,
    evening: /kvll/i,
    night: /natt/i
  }
};
const match$c = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$c,
    parsePattern: parseOrdinalNumberPattern$c,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$c,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$c,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$c,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$c,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$c,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$c,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$c,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$c,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$c,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$c,
    defaultParseWidth: "any"
  })
};
const sv = {
  code: "sv",
  formatDistance: formatDistance$c,
  formatLong: formatLong$c,
  formatRelative: formatRelative$c,
  localize: localize$c,
  match: match$c,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
function isPluralType(val) {
  return val.one !== void 0;
}
const formatDistanceLocale$b = {
  lessThanXSeconds: {
    one: {
      default: "  ",
      in: " ",
      ago: "  "
    },
    other: {
      default: "{{count}}  ",
      in: "{{count}} ",
      ago: "{{count}}  "
    }
  },
  xSeconds: {
    one: {
      default: "1 ",
      in: "1 ",
      ago: "1  "
    },
    other: {
      default: "{{count}} ",
      in: "{{count}} ",
      ago: "{{count}}  "
    }
  },
  halfAMinute: {
    default: " ",
    in: " ",
    ago: "  "
  },
  lessThanXMinutes: {
    one: {
      default: "  ",
      in: " ",
      ago: "  "
    },
    other: {
      default: "{{count}}  ",
      in: "{{count}} ",
      ago: "{{count}}  "
    }
  },
  xMinutes: {
    one: {
      default: "1 ",
      in: "1 ",
      ago: "1  "
    },
    other: {
      default: "{{count}} ",
      in: "{{count}} ",
      ago: "{{count}}  "
    }
  },
  aboutXHours: {
    one: {
      default: " 1  ",
      in: " 1  ",
      ago: " 1   "
    },
    other: {
      default: " {{count}}  ",
      in: " {{count}}   ",
      ago: " {{count}}  "
    }
  },
  xHours: {
    one: {
      default: "1  ",
      in: "1  ",
      ago: "1   "
    },
    other: {
      default: "{{count}}  ",
      in: "{{count}}  ",
      ago: "{{count}}   "
    }
  },
  xDays: {
    one: {
      default: "1 ",
      in: "1 ",
      ago: "1  "
    },
    other: {
      default: "{{count}} ",
      in: "{{count}} ",
      ago: "{{count}}  "
    }
  },
  aboutXWeeks: {
    one: {
      default: " 1 ",
      in: " 1 ",
      ago: " 1  "
    },
    other: {
      default: " {{count}} ",
      in: " {{count}} ",
      ago: " {{count}}  "
    }
  },
  xWeeks: {
    one: {
      default: "1 ",
      in: "1 ",
      ago: "1  "
    },
    other: {
      default: "{{count}} ",
      in: "{{count}} ",
      ago: "{{count}}  "
    }
  },
  aboutXMonths: {
    one: {
      default: " 1 ",
      in: " 1 ",
      ago: " 1  "
    },
    other: {
      default: " {{count}} ",
      in: " {{count}} ",
      ago: " {{count}}  "
    }
  },
  xMonths: {
    one: {
      default: "1 ",
      in: "1 ",
      ago: "1  "
    },
    other: {
      default: "{{count}} ",
      in: "{{count}} ",
      ago: "{{count}}  "
    }
  },
  aboutXYears: {
    one: {
      default: " 1 ",
      in: " 1 ",
      ago: " 1  "
    },
    other: {
      default: " {{count}} ",
      in: " {{count}} ",
      ago: " {{count}}  "
    }
  },
  xYears: {
    one: {
      default: "1 ",
      in: "1 ",
      ago: "1  "
    },
    other: {
      default: "{{count}} ",
      in: "{{count}} ",
      ago: "{{count}}  "
    }
  },
  overXYears: {
    one: {
      default: "1  ",
      in: "1  ",
      ago: "1  "
    },
    other: {
      default: "{{count}}  ",
      in: "{{count}} ",
      ago: "{{count}}  "
    }
  },
  almostXYears: {
    one: {
      default: " 1 ",
      in: " 1 ",
      ago: " 1  "
    },
    other: {
      default: " {{count}} ",
      in: " {{count}} ",
      ago: " {{count}}  "
    }
  }
};
const formatDistance$b = (token, count, options) => {
  const tense = options?.addSuffix ? options.comparison && options.comparison > 0 ? "in" : "ago" : "default";
  const tokenValue = formatDistanceLocale$b[token];
  if (!isPluralType(tokenValue)) return tokenValue[tense];
  if (count === 1) {
    return tokenValue.one[tense];
  } else {
    return tokenValue.other[tense].replace("{{count}}", String(count));
  }
};
const dateFormats$b = {
  full: "EEEE, d MMMM, y",
  long: "d MMMM, y",
  medium: "d MMM, y",
  short: "d/M/yy"
};
const timeFormats$b = {
  full: "a h:mm:ss zzzz",
  long: "a h:mm:ss z",
  medium: "a h:mm:ss",
  short: "a h:mm"
};
const dateTimeFormats$b = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$b = {
  date: buildFormatLongFn({
    formats: dateFormats$b,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$b,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$b,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$b = {
  lastWeek: "'' eeee p ''",
  yesterday: "' ' p ''",
  today: "' ' p ''",
  tomorrow: "' ' p ''",
  nextWeek: "eeee p ''",
  other: "P"
};
const formatRelative$b = (token, _date, _baseDate, _options) => formatRelativeLocale$b[token];
const eraValues$b = {
  narrow: ["..", ".."],
  abbreviated: ["..", ".."],
  // CLDR #1624, #1626
  wide: [" ", " "]
  // CLDR #1620, #1622
};
const quarterValues$b = {
  // CLDR #1644 - #1647
  narrow: ["1", "2", "3", "4"],
  // CLDR #1636 - #1639
  abbreviated: [".1", ".2", ".3", ".4"],
  // CLDR #1628 - #1631
  wide: [
    " ",
    " ",
    " ",
    " "
  ]
};
const monthValues$b = {
  // CLDR #700 - #711
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  // CLDR #1676 - #1687
  abbreviated: [
    ".",
    ".",
    ".",
    ".",
    "",
    "",
    "",
    ".",
    ".",
    ".",
    ".",
    "."
  ],
  // CLDR #1652 - #1663
  wide: [
    "",
    // January
    "",
    // February
    "",
    // March
    "",
    // April
    "",
    // May
    "",
    // June
    "",
    // July
    "",
    // August
    "",
    // September
    "",
    // October
    "",
    // November
    ""
    // December
  ]
};
const dayValues$b = {
  // CLDR #1766 - #1772
  narrow: ["", "", "", "", "", "", ""],
  // CLDR #1752 - #1758
  short: ["", "", "", "", "", "", ""],
  // CLDR #1738 - #1744
  abbreviated: [".", ".", ".", ".", ".", ".", ""],
  // CLDR #1724 - #1730
  wide: [
    "",
    // Sunday
    "",
    // Monday
    "",
    // Tuesday
    "",
    // Wednesday
    "",
    // Thursday
    "",
    // Friday
    ""
    // Saturday
  ]
};
const dayPeriodValues$b = {
  narrow: {
    am: ".",
    pm: ".",
    midnight: ".",
    noon: ".",
    morning: ".",
    afternoon: ".",
    evening: ".",
    night: "."
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$b = {
  narrow: {
    am: ".",
    pm: ".",
    midnight: ".",
    noon: ".",
    morning: ".",
    afternoon: ".",
    evening: ".",
    night: "."
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$b = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
const localize$b = {
  ordinalNumber: ordinalNumber$b,
  era: buildLocalizeFn({
    values: eraValues$b,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$b,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$b,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$b,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$b,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$b,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$b = /^(\d+)()?/i;
const parseOrdinalNumberPattern$b = /\d+/i;
const matchEraPatterns$b = {
  narrow: /^(..|..)/i,
  abbreviated: /^(\.?\s?\.?|\.?\s?\.?)/,
  wide: /^(\s|\s)/i
};
const parseEraPatterns$b = {
  any: [/\.?\s?\.?/, /\.?\s?\.?/]
};
const matchQuarterPatterns$b = {
  narrow: /^[1234]/i,
  abbreviated: /^.[1234]/i,
  wide: /^(|||) /i
};
const parseQuarterPatterns$b = {
  narrow: [/1/i, /2/i, /3/i, /4/i],
  any: [
    /(1|.1|)/i,
    /(2|.2|)/i,
    /(3|.3|)/i,
    /(4|.4|)/i
  ]
};
const matchMonthPatterns$b = {
  narrow: /^(||||||||||)$/i,
  abbreviated: /^(.|.|.|.||||.|.|.|.|.)/i,
  wide: /^(|||||||||||)/i
};
const parseMonthPatterns$b = {
  narrow: [
    /^$/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$b = {
  narrow: /^(||||||)/i,
  short: /^(||||||)/i,
  abbreviated: /^(.|.|.|.|.|.|)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$b = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$b = {
  narrow: /^(.|.||||||)/i,
  any: /^(.|.||||||||)/i
};
const parseDayPeriodPatterns$b = {
  any: {
    am: /^/i,
    pm: /^/i,
    midnight: /^/i,
    noon: /^/i,
    morning: //i,
    afternoon: //i,
    evening: //i,
    night: //i
  }
};
const match$b = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$b,
    parsePattern: parseOrdinalNumberPattern$b,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$b,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$b,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$b,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$b,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$b,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$b,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$b,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$b,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$b,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$b,
    defaultParseWidth: "any"
  })
};
const ta$1 = {
  code: "ta",
  formatDistance: formatDistance$b,
  formatLong: formatLong$b,
  formatRelative: formatRelative$b,
  localize: localize$b,
  match: match$b,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$a = {
  lessThanXSeconds: {
    standalone: {
      one: "  ",
      other: "{{count}}   "
    },
    withPreposition: {
      one: "",
      other: "{{count}} "
    }
  },
  xSeconds: {
    standalone: {
      one: " ",
      // CLDR #1314
      other: "{{count}} "
    },
    withPreposition: {
      one: " ",
      other: "{{count}} "
    }
  },
  halfAMinute: {
    standalone: " ",
    withPreposition: " "
  },
  lessThanXMinutes: {
    standalone: {
      one: "   ",
      other: "{{count}}   "
    },
    withPreposition: {
      one: " ",
      other: "{{count}} "
    }
  },
  xMinutes: {
    standalone: {
      one: " ",
      // CLDR #1311
      other: "{{count}} "
    },
    withPreposition: {
      one: " ",
      // CLDR #1311
      other: "{{count}} "
    }
  },
  aboutXHours: {
    standalone: {
      one: "  ",
      other: " {{count}} "
    },
    withPreposition: {
      one: "  ",
      other: " {{count}} "
    }
  },
  xHours: {
    standalone: {
      one: " ",
      // CLDR #1308
      other: "{{count}} "
    },
    withPreposition: {
      one: " ",
      other: "{{count}} "
    }
  },
  xDays: {
    standalone: {
      one: " ",
      // CLDR #1292
      other: "{{count}} "
    },
    withPreposition: {
      one: " ",
      other: "{{count}} "
    }
  },
  aboutXWeeks: {
    standalone: {
      one: "  ",
      other: " {{count}} "
    },
    withPreposition: {
      one: "  ",
      other: " {{count}} "
    }
  },
  xWeeks: {
    standalone: {
      one: " ",
      other: "{{count}} "
    },
    withPreposition: {
      one: " ",
      other: "{{count}} "
    }
  },
  aboutXMonths: {
    standalone: {
      one: "  ",
      other: " {{count}} "
    },
    withPreposition: {
      one: "  ",
      other: " {{count}} "
    }
  },
  xMonths: {
    standalone: {
      one: " ",
      // CLDR #1281
      other: "{{count}} "
    },
    withPreposition: {
      one: " ",
      other: "{{count}} "
    }
  },
  aboutXYears: {
    standalone: {
      one: "  ",
      other: " {{count}} "
    },
    withPreposition: {
      one: "  ",
      other: " {{count}} "
    }
  },
  xYears: {
    standalone: {
      one: " ",
      // CLDR #1275
      other: "{{count}} "
    },
    withPreposition: {
      one: " ",
      other: "{{count}} "
    }
  },
  overXYears: {
    standalone: {
      one: "  ",
      other: "{{count}}  "
    },
    withPreposition: {
      one: " ",
      other: "{{count}} "
    }
  },
  almostXYears: {
    standalone: {
      one: "  ",
      other: " {{count}} "
    },
    withPreposition: {
      one: "  ",
      other: " {{count}} "
    }
  }
};
const formatDistance$a = (token, count, options) => {
  let result;
  const tokenValue = options?.addSuffix ? formatDistanceLocale$a[token].withPreposition : formatDistanceLocale$a[token].standalone;
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "";
    } else {
      return result + " ";
    }
  }
  return result;
};
const dateFormats$a = {
  full: "d, MMMM y, EEEE",
  long: "d MMMM, y",
  medium: "d MMM, y",
  short: "dd-MM-yy"
};
const timeFormats$a = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$a = {
  full: "{{date}} {{time}}''",
  long: "{{date}} {{time}}''",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$a = {
  date: buildFormatLongFn({
    formats: dateFormats$a,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$a,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$a,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$a = {
  lastWeek: "'' eeee p",
  // CLDR #1384
  yesterday: "'' p",
  // CLDR #1393
  today: "' ' p",
  // CLDR #1394
  tomorrow: "'' p",
  // CLDR #1395
  nextWeek: "'' eeee p",
  // CLDR #1386
  other: "P"
};
const formatRelative$a = (token, _date, _baseDate, _options) => formatRelativeLocale$a[token];
const eraValues$a = {
  narrow: ["..", ".."],
  abbreviated: ["..", ".."],
  wide: [" ", ""]
};
const quarterValues$a = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1", "2", "3", "4"],
  wide: ["1 ", "2 ", "3 ", "4 "]
};
const monthValues$a = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$a = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$a = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$a = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$a = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "";
};
const localize$a = {
  ordinalNumber: ordinalNumber$a,
  era: buildLocalizeFn({
    values: eraValues$a,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$a,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$a,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$a,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$a,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$a,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$a = /^(\d+)()?/i;
const parseOrdinalNumberPattern$a = /\d+/i;
const matchEraPatterns$a = {
  narrow: /^(\.\.|\.\.)/i,
  abbreviated: /^(\.?\s?\.?|\.?\s?\.?\s?\.?|\.?\s?\.?|\.?\s?\.?)/i,
  wide: /^( |  | | )/i
};
const parseEraPatterns$a = {
  any: [/^(|)/i, /^/i]
};
const matchQuarterPatterns$a = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]/i,
  wide: /^[1234]()? /i
};
const parseQuarterPatterns$a = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$a = {
  narrow: /^(|||||||||||)/i,
  abbreviated: /^(|||||||||||)/i,
  wide: /^(|||||||||||)/i
};
const parseMonthPatterns$a = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$a = {
  narrow: /^(||||||)/i,
  short: /^(||||||)/i,
  abbreviated: /^(||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$a = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$a = {
  narrow: /^(|||||||)/i,
  any: /^(|||||||)/i
};
const parseDayPeriodPatterns$a = {
  any: {
    am: /^/i,
    pm: /^/i,
    midnight: /^/i,
    noon: /^/i,
    morning: //i,
    afternoon: //i,
    evening: //i,
    night: //i
  }
};
const match$a = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$a,
    parsePattern: parseOrdinalNumberPattern$a,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$a,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$a,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$a,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$a,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$a,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$a,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$a,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$a,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$a,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$a,
    defaultParseWidth: "any"
  })
};
const te = {
  code: "te",
  formatDistance: formatDistance$a,
  formatLong: formatLong$a,
  formatRelative: formatRelative$a,
  localize: localize$a,
  match: match$a,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$9 = {
  lessThanXSeconds: {
    one: " 1 ",
    other: " {{count}} "
  },
  xSeconds: {
    one: "1 ",
    other: "{{count}} "
  },
  halfAMinute: "",
  lessThanXMinutes: {
    one: " 1 ",
    other: " {{count}} "
  },
  xMinutes: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: " 1 ",
    other: " {{count}} "
  },
  xHours: {
    one: "1 ",
    other: "{{count}} "
  },
  xDays: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: " 1 ",
    other: " {{count}} "
  },
  xWeeks: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: " 1 ",
    other: " {{count}} "
  },
  xMonths: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: " 1 ",
    other: " {{count}} "
  },
  xYears: {
    one: "1 ",
    other: "{{count}} "
  },
  overXYears: {
    one: " 1 ",
    other: " {{count}} "
  },
  almostXYears: {
    one: " 1 ",
    other: " {{count}} "
  }
};
const formatDistance$9 = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$9[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      if (token === "halfAMinute") {
        return "" + result;
      } else {
        return " " + result;
      }
    } else {
      return result + "";
    }
  }
  return result;
};
const dateFormats$9 = {
  full: "EEEE do MMMM y",
  long: "do MMMM y",
  medium: "d MMM y",
  short: "dd/MM/yyyy"
};
const timeFormats$9 = {
  full: "H:mm:ss . zzzz",
  long: "H:mm:ss . z",
  medium: "H:mm:ss .",
  short: "H:mm ."
};
const dateTimeFormats$9 = {
  full: "{{date}} '' {{time}}",
  long: "{{date}} '' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$9 = {
  date: buildFormatLongFn({
    formats: dateFormats$9,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$9,
    defaultWidth: "medium"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$9,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$9 = {
  lastWeek: "eeee'' p",
  yesterday: "'' p",
  today: "'' p",
  tomorrow: "'' p",
  nextWeek: "eeee '' p",
  other: "P"
};
const formatRelative$9 = (token, _date, _baseDate, _options) => formatRelativeLocale$9[token];
const eraValues$9 = {
  narrow: ["B", ""],
  abbreviated: ["BC", ".."],
  wide: ["", ""]
};
const quarterValues$9 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["", "", "", ""]
};
const dayValues$9 = {
  narrow: [".", ".", ".", ".", ".", ".", "."],
  short: [".", ".", ".", ".", ".", ".", "."],
  abbreviated: [".", ".", ".", ".", ".", ".", "."],
  wide: ["", "", "", "", "", "", ""]
};
const monthValues$9 = {
  narrow: [
    "..",
    "..",
    "..",
    "..",
    "..",
    "..",
    "..",
    "..",
    "..",
    "..",
    "..",
    ".."
  ],
  abbreviated: [
    "..",
    "..",
    "..",
    "..",
    "..",
    "..",
    "..",
    "..",
    "..",
    "..",
    "..",
    ".."
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$9 = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$9 = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$9 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
const localize$9 = {
  ordinalNumber: ordinalNumber$9,
  era: buildLocalizeFn({
    values: eraValues$9,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$9,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$9,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$9,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$9,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$9,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$9 = /^\d+/i;
const parseOrdinalNumberPattern$9 = /\d+/i;
const matchEraPatterns$9 = {
  narrow: /^([bB]|[aA]|)/i,
  abbreviated: /^([bB]\.?\s?[cC]\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?|\.?\.?)/i,
  wide: /^(||)/i
};
const parseEraPatterns$9 = {
  any: [/^[bB]/i, /^(^[aA]|\.?\.?|||)/i]
};
const matchQuarterPatterns$9 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^()? ?[1234]/i
};
const parseQuarterPatterns$9 = {
  any: [/(1||)/i, /(2|)/i, /(3|)/i, /(4|)/i]
};
const matchMonthPatterns$9 = {
  narrow: /^(\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?)/i,
  abbreviated: /^(\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?')/i,
  wide: /^(|||||||||||)/i
};
const parseMonthPatterns$9 = {
  wide: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^\.?\.?/i,
    /^\.?\.?/i,
    /^\.?\.?/i,
    /^\.?\.?/i,
    /^\.?\.?/i,
    /^\.?\.?/i,
    /^\.?\.?/i,
    /^\.?\.?/i,
    /^\.?\.?/i,
    /^\.?\.?/i,
    /^\.?\.?/i,
    /^\.?\.?/i
  ]
};
const matchDayPatterns$9 = {
  narrow: /^(\.?|\.?|\.?|\.?|\.?|\.?|\.?)/i,
  short: /^(\.?|\.?|\.?|\.?|\.?|\.?|\.?)/i,
  abbreviated: /^(\.?|\.?|\.?|\.?|\.?|\.?|\.?)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$9 = {
  wide: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^/i, /^/i, /^/i, /^(?!)/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$9 = {
  any: /^(||||(.*?)?.*(||||))/i
};
const parseDayPeriodPatterns$9 = {
  any: {
    am: /^/i,
    pm: /^/i,
    midnight: /^/i,
    noon: /^/i,
    morning: //i,
    afternoon: //i,
    evening: //i,
    night: //i
  }
};
const match$9 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$9,
    parsePattern: parseOrdinalNumberPattern$9,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$9,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$9,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$9,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$9,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$9,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$9,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$9,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$9,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$9,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$9,
    defaultParseWidth: "any"
  })
};
const th = {
  code: "th",
  formatDistance: formatDistance$9,
  formatLong: formatLong$9,
  formatRelative: formatRelative$9,
  localize: localize$9,
  match: match$9,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$8 = {
  lessThanXSeconds: {
    one: "bir saniyeden az",
    other: "{{count}} saniyeden az"
  },
  xSeconds: {
    one: "1 saniye",
    other: "{{count}} saniye"
  },
  halfAMinute: "yarm dakika",
  lessThanXMinutes: {
    one: "bir dakikadan az",
    other: "{{count}} dakikadan az"
  },
  xMinutes: {
    one: "1 dakika",
    other: "{{count}} dakika"
  },
  aboutXHours: {
    one: "yaklak 1 saat",
    other: "yaklak {{count}} saat"
  },
  xHours: {
    one: "1 saat",
    other: "{{count}} saat"
  },
  xDays: {
    one: "1 gn",
    other: "{{count}} gn"
  },
  aboutXWeeks: {
    one: "yaklak 1 hafta",
    other: "yaklak {{count}} hafta"
  },
  xWeeks: {
    one: "1 hafta",
    other: "{{count}} hafta"
  },
  aboutXMonths: {
    one: "yaklak 1 ay",
    other: "yaklak {{count}} ay"
  },
  xMonths: {
    one: "1 ay",
    other: "{{count}} ay"
  },
  aboutXYears: {
    one: "yaklak 1 yl",
    other: "yaklak {{count}} yl"
  },
  xYears: {
    one: "1 yl",
    other: "{{count}} yl"
  },
  overXYears: {
    one: "1 yldan fazla",
    other: "{{count}} yldan fazla"
  },
  almostXYears: {
    one: "neredeyse 1 yl",
    other: "neredeyse {{count}} yl"
  }
};
const formatDistance$8 = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$8[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + " sonra";
    } else {
      return result + " nce";
    }
  }
  return result;
};
const dateFormats$8 = {
  full: "d MMMM y EEEE",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd.MM.yyyy"
};
const timeFormats$8 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$8 = {
  full: "{{date}} 'saat' {{time}}",
  long: "{{date}} 'saat' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$8 = {
  date: buildFormatLongFn({
    formats: dateFormats$8,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$8,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$8,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$8 = {
  lastWeek: "'geen hafta' eeee 'saat' p",
  yesterday: "'dn saat' p",
  today: "'bugn saat' p",
  tomorrow: "'yarn saat' p",
  nextWeek: "eeee 'saat' p",
  other: "P"
};
const formatRelative$8 = (token, _date, _baseDate, _options) => formatRelativeLocale$8[token];
const eraValues$8 = {
  narrow: ["M", "MS"],
  abbreviated: ["M", "MS"],
  wide: ["Milattan nce", "Milattan Sonra"]
};
const quarterValues$8 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1", "2", "3", "4"],
  wide: ["lk eyrek", "kinci eyrek", "nc eyrek", "Son eyrek"]
};
const monthValues$8 = {
  narrow: ["O", "", "M", "N", "M", "H", "T", "A", "E", "E", "K", "A"],
  abbreviated: [
    "Oca",
    "ub",
    "Mar",
    "Nis",
    "May",
    "Haz",
    "Tem",
    "Au",
    "Eyl",
    "Eki",
    "Kas",
    "Ara"
  ],
  wide: [
    "Ocak",
    "ubat",
    "Mart",
    "Nisan",
    "Mays",
    "Haziran",
    "Temmuz",
    "Austos",
    "Eyll",
    "Ekim",
    "Kasm",
    "Aralk"
  ]
};
const dayValues$8 = {
  narrow: ["P", "P", "S", "", "P", "C", "C"],
  short: ["Pz", "Pt", "Sa", "a", "Pe", "Cu", "Ct"],
  abbreviated: ["Paz", "Pzt", "Sal", "ar", "Per", "Cum", "Cts"],
  wide: [
    "Pazar",
    "Pazartesi",
    "Sal",
    "aramba",
    "Perembe",
    "Cuma",
    "Cumartesi"
  ]
};
const dayPeriodValues$8 = {
  narrow: {
    am: "",
    pm: "s",
    midnight: "gy",
    noon: "",
    morning: "sa",
    afternoon: "s",
    evening: "ak",
    night: "ge"
  },
  abbreviated: {
    am: "",
    pm: "S",
    midnight: "gece yars",
    noon: "le",
    morning: "sabah",
    afternoon: "leden sonra",
    evening: "akam",
    night: "gece"
  },
  wide: {
    am: "..",
    pm: ".S.",
    midnight: "gece yars",
    noon: "le",
    morning: "sabah",
    afternoon: "leden sonra",
    evening: "akam",
    night: "gece"
  }
};
const formattingDayPeriodValues$8 = {
  narrow: {
    am: "",
    pm: "s",
    midnight: "gy",
    noon: "",
    morning: "sa",
    afternoon: "s",
    evening: "ak",
    night: "ge"
  },
  abbreviated: {
    am: "",
    pm: "S",
    midnight: "gece yars",
    noon: "len",
    morning: "sabahleyin",
    afternoon: "leden sonra",
    evening: "akamleyin",
    night: "geceleyin"
  },
  wide: {
    am: "..",
    pm: ".s.",
    midnight: "gece yars",
    noon: "len",
    morning: "sabahleyin",
    afternoon: "leden sonra",
    evening: "akamleyin",
    night: "geceleyin"
  }
};
const ordinalNumber$8 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$8 = {
  ordinalNumber: ordinalNumber$8,
  era: buildLocalizeFn({
    values: eraValues$8,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$8,
    defaultWidth: "wide",
    argumentCallback: (quarter) => Number(quarter) - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$8,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$8,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$8,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$8,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$8 = /^(\d+)(\.)?/i;
const parseOrdinalNumberPattern$8 = /\d+/i;
const matchEraPatterns$8 = {
  narrow: /^(m|ms)/i,
  abbreviated: /^(m|ms)/i,
  wide: /^(milattan nce|milattan sonra)/i
};
const parseEraPatterns$8 = {
  any: [/(^m|^milattan nce)/i, /(^ms|^milattan sonra)/i]
};
const matchQuarterPatterns$8 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]/i,
  wide: /^((i|)lk|(i|)kinci|nc|son) eyrek/i
};
const parseQuarterPatterns$8 = {
  any: [/1/i, /2/i, /3/i, /4/i],
  abbreviated: [/1/i, /2/i, /3/i, /4/i],
  wide: [
    /^(i|)lk eyrek/i,
    /(i|)kinci eyrek/i,
    /nc eyrek/i,
    /son eyrek/i
  ]
};
const matchMonthPatterns$8 = {
  narrow: /^[omnhtaek]/i,
  abbreviated: /^(oca|ub|mar|nis|may|haz|tem|au|eyl|eki|kas|ara)/i,
  wide: /^(ocak|ubat|mart|nisan|mays|haziran|temmuz|austos|eyll|ekim|kasm|aralk)/i
};
const parseMonthPatterns$8 = {
  narrow: [
    /^o/i,
    /^/i,
    /^m/i,
    /^n/i,
    /^m/i,
    /^h/i,
    /^t/i,
    /^a/i,
    /^e/i,
    /^e/i,
    /^k/i,
    /^a/i
  ],
  any: [
    /^o/i,
    /^/i,
    /^mar/i,
    /^n/i,
    /^may/i,
    /^h/i,
    /^t/i,
    /^a/i,
    /^ey/i,
    /^ek/i,
    /^k/i,
    /^ar/i
  ]
};
const matchDayPatterns$8 = {
  narrow: /^[psc]/i,
  short: /^(pz|pt|sa|a|pe|cu|ct)/i,
  abbreviated: /^(paz|pzt|sal|ar|per|cum|cts)/i,
  wide: /^(pazar(?!tesi)|pazartesi|sal|aramba|perembe|cuma(?!rtesi)|cumartesi)/i
};
const parseDayPatterns$8 = {
  narrow: [/^p/i, /^p/i, /^s/i, /^/i, /^p/i, /^c/i, /^c/i],
  any: [/^pz/i, /^pt/i, /^sa/i, /^a/i, /^pe/i, /^cu/i, /^ct/i],
  wide: [
    /^pazar(?!tesi)/i,
    /^pazartesi/i,
    /^sal/i,
    /^aramba/i,
    /^perembe/i,
    /^cuma(?!rtesi)/i,
    /^cumartesi/i
  ]
};
const matchDayPeriodPatterns$8 = {
  narrow: /^(|s|gy||sa|s|ak|ge)/i,
  any: /^(\.?\s?[s]\.?|leden sonra|gece yars|le|(sabah||akam|gece)(leyin))/i
};
const parseDayPeriodPatterns$8 = {
  any: {
    am: /^\.?\.?/i,
    pm: /^\.?s\.?/i,
    midnight: /^(gy|gece yars)/i,
    noon: /^/i,
    morning: /^sa/i,
    afternoon: /^leden sonra/i,
    evening: /^ak/i,
    night: /^ge/i
  }
};
const match$8 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$8,
    parsePattern: parseOrdinalNumberPattern$8,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$8,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$8,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$8,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$8,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$8,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$8,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$8,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$8,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$8,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$8,
    defaultParseWidth: "any"
  })
};
const tr$1 = {
  code: "tr",
  formatDistance: formatDistance$8,
  formatLong: formatLong$8,
  formatRelative: formatRelative$8,
  localize: localize$8,
  match: match$8,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$7 = {
  lessThanXSeconds: {
    one: "  ",
    other: "  {{count}}"
  },
  xSeconds: {
    one: " ",
    other: " {{count}}"
  },
  halfAMinute: " ",
  lessThanXMinutes: {
    one: "  ",
    other: "  {{count}}"
  },
  xMinutes: {
    one: " ",
    other: " {{count}}"
  },
  aboutXHours: {
    one: "  ",
    other: " {{count}} "
  },
  xHours: {
    one: " ",
    other: " {{count}}"
  },
  xDays: {
    one: " ",
    other: " {{count}}"
  },
  aboutXWeeks: {
    one: " ",
    other: " {{count}} "
  },
  xWeeks: {
    one: "",
    other: " {{count}}"
  },
  aboutXMonths: {
    one: "  ",
    other: " {{count}} "
  },
  xMonths: {
    one: " ",
    other: " {{count}}"
  },
  aboutXYears: {
    one: "  ",
    other: " {{count}} "
  },
  xYears: {
    one: " ",
    other: " {{count}}"
  },
  overXYears: {
    one: "  ",
    other: "  {{count}}"
  },
  almostXYears: {
    one: "  ",
    other: " {{count}} "
  }
};
const formatDistance$7 = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$7[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result;
    } else {
      return result + " ";
    }
  }
  return result;
};
const dateFormats$7 = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
const timeFormats$7 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$7 = {
  full: "{{date}} '' {{time}}",
  long: "{{date}} '' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$7 = {
  date: buildFormatLongFn({
    formats: dateFormats$7,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$7,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$7,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$7 = {
  lastWeek: "'' eeee '' p",
  yesterday: "' ' p",
  today: "' ' p",
  tomorrow: "' ' p",
  nextWeek: "eeee '' p",
  other: "P"
};
const formatRelative$7 = (token, _date, _baseDate, _options) => formatRelativeLocale$7[token];
const eraValues$7 = {
  narrow: ["", ""],
  abbreviated: ["", ""],
  wide: [" ", " "]
};
const quarterValues$7 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1", "2", "3", "4"],
  wide: [" ", " ", " ", " "]
};
const monthValues$7 = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$7 = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$7 = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$7 = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  }
};
const ordinalNumber$7 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
const localize$7 = {
  ordinalNumber: ordinalNumber$7,
  era: buildLocalizeFn({
    values: eraValues$7,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$7,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$7,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$7,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$7,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$7,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$7 = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$7 = /\d+/i;
const matchEraPatterns$7 = {
  narrow: /^(|)/i,
  wide: /^( | )/i
};
const parseEraPatterns$7 = {
  any: [/^/i, /^/i]
};
const matchQuarterPatterns$7 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]/i,
  wide: /^ [1234]/i
};
const parseQuarterPatterns$7 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$7 = {
  // eslint-disable-next-line no-misleading-character-class
  narrow: /^[]/i,
  abbreviated: /^(|||||||||||)/i,
  wide: /^(|||||||||||)/i
};
const parseMonthPatterns$7 = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$7 = {
  narrow: /^[]/i,
  short: /^(||||||)/i,
  abbreviated: /^(||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$7 = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$7 = {
  narrow: /^(||||(|) ( | ||))/i,
  any: /^(||||(|) ( | ||))/i
};
const parseDayPeriodPatterns$7 = {
  any: {
    am: /^/i,
    pm: /^/i,
    midnight: /^/i,
    noon: /^/i,
    morning: //i,
    afternoon: / /i,
    evening: //i,
    night: //i
  }
};
const match$7 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$7,
    parsePattern: parseOrdinalNumberPattern$7,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$7,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$7,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$7,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$7,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$7,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$7,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$7,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$7,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$7,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$7,
    defaultParseWidth: "any"
  })
};
const ug = {
  code: "ug",
  formatDistance: formatDistance$7,
  formatLong: formatLong$7,
  formatRelative: formatRelative$7,
  localize: localize$7,
  match: match$7,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function declension(scheme2, count) {
  if (scheme2.one !== void 0 && count === 1) {
    return scheme2.one;
  }
  const rem10 = count % 10;
  const rem100 = count % 100;
  if (rem10 === 1 && rem100 !== 11) {
    return scheme2.singularNominative.replace("{{count}}", String(count));
  } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
    return scheme2.singularGenitive.replace("{{count}}", String(count));
  } else {
    return scheme2.pluralGenitive.replace("{{count}}", String(count));
  }
}
function buildLocalizeTokenFn(scheme2) {
  return (count, options) => {
    if (options && options.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        if (scheme2.future) {
          return declension(scheme2.future, count);
        } else {
          return " " + declension(scheme2.regular, count);
        }
      } else {
        if (scheme2.past) {
          return declension(scheme2.past, count);
        } else {
          return declension(scheme2.regular, count) + " ";
        }
      }
    } else {
      return declension(scheme2.regular, count);
    }
  };
}
const halfAtMinute = (_, options) => {
  if (options && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return " ";
    } else {
      return " ";
    }
  }
  return "";
};
const formatDistanceLocale$6 = {
  lessThanXSeconds: buildLocalizeTokenFn({
    regular: {
      one: " ",
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      one: ",   ",
      singularNominative: ",   {{count}} ",
      singularGenitive: ",   {{count}} ",
      pluralGenitive: ",   {{count}} "
    }
  }),
  xSeconds: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    },
    past: {
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    },
    future: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    }
  }),
  halfAMinute: halfAtMinute,
  lessThanXMinutes: buildLocalizeTokenFn({
    regular: {
      one: " ",
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      one: ",   ",
      singularNominative: ",   {{count}} ",
      singularGenitive: ",   {{count}} ",
      pluralGenitive: ",   {{count}} "
    }
  }),
  xMinutes: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    },
    past: {
      singularNominative: "{{count}}  ",
      singularGenitive: "{{count}}  ",
      pluralGenitive: "{{count}}  "
    },
    future: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    }
  }),
  aboutXHours: buildLocalizeTokenFn({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    }
  }),
  xHours: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    }
  }),
  xDays: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} i",
      pluralGenitive: "{{count}} "
    }
  }),
  aboutXWeeks: buildLocalizeTokenFn({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    }
  }),
  xWeeks: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    }
  }),
  aboutXMonths: buildLocalizeTokenFn({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    }
  }),
  xMonths: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    }
  }),
  aboutXYears: buildLocalizeTokenFn({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    }
  }),
  xYears: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} ",
      singularGenitive: "{{count}} ",
      pluralGenitive: "{{count}} "
    }
  }),
  overXYears: buildLocalizeTokenFn({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: ",   {{count}} ",
      singularGenitive: ",   {{count}} ",
      pluralGenitive: ",   {{count}} "
    }
  }),
  almostXYears: buildLocalizeTokenFn({
    regular: {
      singularNominative: " {{count}} ",
      singularGenitive: " {{count}} ",
      pluralGenitive: " {{count}} "
    },
    future: {
      singularNominative: "  {{count}} ",
      singularGenitive: "  {{count}} ",
      pluralGenitive: "  {{count}} "
    }
  })
};
const formatDistance$6 = (token, count, options) => {
  options = options || {};
  return formatDistanceLocale$6[token](count, options);
};
const dateFormats$6 = {
  full: "EEEE, do MMMM y '.'",
  long: "do MMMM y '.'",
  medium: "d MMM y '.'",
  short: "dd.MM.y"
};
const timeFormats$6 = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
const dateTimeFormats$6 = {
  full: "{{date}} '' {{time}}",
  long: "{{date}} '' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$6 = {
  date: buildFormatLongFn({
    formats: dateFormats$6,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$6,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$6,
    defaultWidth: "full"
  })
};
const accusativeWeekdays = [
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];
function lastWeek(day) {
  const weekday = accusativeWeekdays[day];
  switch (day) {
    case 0:
    case 3:
    case 5:
    case 6:
      return "'  " + weekday + " ' p";
    case 1:
    case 2:
    case 4:
      return "'  " + weekday + " ' p";
  }
}
function thisWeek(day) {
  const weekday = accusativeWeekdays[day];
  return "' " + weekday + " ' p";
}
function nextWeek(day) {
  const weekday = accusativeWeekdays[day];
  switch (day) {
    case 0:
    case 3:
    case 5:
    case 6:
      return "'  " + weekday + " ' p";
    case 1:
    case 2:
    case 4:
      return "'  " + weekday + " ' p";
  }
}
const lastWeekFormat = (dirtyDate, baseDate, options) => {
  const date2 = toDate(dirtyDate);
  const day = date2.getDay();
  if (isSameWeek(date2, baseDate, options)) {
    return thisWeek(day);
  } else {
    return lastWeek(day);
  }
};
const nextWeekFormat = (dirtyDate, baseDate, options) => {
  const date2 = toDate(dirtyDate);
  const day = date2.getDay();
  if (isSameWeek(date2, baseDate, options)) {
    return thisWeek(day);
  } else {
    return nextWeek(day);
  }
};
const formatRelativeLocale$6 = {
  lastWeek: lastWeekFormat,
  yesterday: "' ' p",
  today: "' ' p",
  tomorrow: "' ' p",
  nextWeek: nextWeekFormat,
  other: "P"
};
const formatRelative$6 = (token, date2, baseDate, options) => {
  const format2 = formatRelativeLocale$6[token];
  if (typeof format2 === "function") {
    return format2(date2, baseDate, options);
  }
  return format2;
};
const eraValues$6 = {
  narrow: [" ..", ".."],
  abbreviated: [" . .", ". ."],
  wide: ["  ", " "]
};
const quarterValues$6 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1- .", "2- .", "3- .", "4- ."],
  wide: ["1- ", "2- ", "3- ", "4- "]
};
const monthValues$6 = {
  //  3582:2013
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    "."
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const formattingMonthValues$1 = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    ".",
    "."
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$6 = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$6 = {
  narrow: {
    am: "",
    pm: "",
    midnight: ".",
    noon: ".",
    morning: "",
    afternoon: "",
    evening: ".",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: ".",
    noon: ".",
    morning: "",
    afternoon: "",
    evening: ".",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$6 = {
  narrow: {
    am: "",
    pm: "",
    midnight: ".",
    noon: ".",
    morning: "",
    afternoon: "",
    evening: ".",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: ".",
    noon: ".",
    morning: "",
    afternoon: "",
    evening: ".",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: ".",
    night: ""
  }
};
const ordinalNumber$6 = (dirtyNumber, options) => {
  const unit = String(options?.unit);
  const number2 = Number(dirtyNumber);
  let suffix;
  if (unit === "date") {
    if (number2 === 3 || number2 === 23) {
      suffix = "-";
    } else {
      suffix = "-";
    }
  } else if (unit === "minute" || unit === "second" || unit === "hour") {
    suffix = "-";
  } else {
    suffix = "-";
  }
  return number2 + suffix;
};
const localize$6 = {
  ordinalNumber: ordinalNumber$6,
  era: buildLocalizeFn({
    values: eraValues$6,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$6,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$6,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$1,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$6,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$6,
    defaultWidth: "any",
    formattingValues: formattingDayPeriodValues$6,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$6 = /^(\d+)(-?(||||))?/i;
const parseOrdinalNumberPattern$6 = /\d+/i;
const matchEraPatterns$6 = {
  narrow: /^(( )?\.?\s?\.?)/i,
  abbreviated: /^(( )?\.?\s?\.?)/i,
  wide: /^(  | | )/i
};
const parseEraPatterns$6 = {
  any: [/^/i, /^/i]
};
const matchQuarterPatterns$6 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?[]??)? .?/i,
  wide: /^[1234](-?[]??)? /i
};
const parseQuarterPatterns$6 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$6 = {
  narrow: /^[]/i,
  abbreviated: /^(||()?||||||()?||()?|)\.?/i,
  wide: /^(||||||||||||||||||||[]?||)/i
};
const parseMonthPatterns$6 = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$6 = {
  narrow: /^[]/i,
  short: /^(||||||)\.?/i,
  abbreviated: /^(||||?|?|)\.?/i,
  wide: /^([]|[][]|[][]|[]|()?|\W*?[]|[])/i
};
const parseDayPatterns$6 = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^/i, /^[]/i, /^/i, /^[]/i, /^/i, /^\W*?[]/i, /^[]/i]
};
const matchDayPeriodPatterns$6 = {
  narrow: /^([]|\.?|\.?|||||\.?||)/i,
  abbreviated: /^([]|\.?|\.?|||||\.?||)/i,
  wide: /^([]||||||||||)/i
};
const parseDayPeriodPatterns$6 = {
  any: {
    am: /^/i,
    pm: /^/i,
    midnight: /^/i,
    noon: /^/i,
    morning: /^/i,
    afternoon: /^[]/i,
    evening: /^/i,
    night: /^/i
  }
};
const match$6 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$6,
    parsePattern: parseOrdinalNumberPattern$6,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$6,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$6,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$6,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$6,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$6,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$6,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$6,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$6,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$6,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$6,
    defaultParseWidth: "any"
  })
};
const uk = {
  code: "uk",
  formatDistance: formatDistance$6,
  formatLong: formatLong$6,
  formatRelative: formatRelative$6,
  localize: localize$6,
  match: match$6,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$5 = {
  lessThanXSeconds: {
    one: "sekunddan kam",
    other: "{{count}} sekunddan kam"
  },
  xSeconds: {
    one: "1 sekund",
    other: "{{count}} sekund"
  },
  halfAMinute: "yarim minut",
  lessThanXMinutes: {
    one: "bir minutdan kam",
    other: "{{count}} minutdan kam"
  },
  xMinutes: {
    one: "1 minut",
    other: "{{count}} minut"
  },
  aboutXHours: {
    one: "tahminan 1 soat",
    other: "tahminan {{count}} soat"
  },
  xHours: {
    one: "1 soat",
    other: "{{count}} soat"
  },
  xDays: {
    one: "1 kun",
    other: "{{count}} kun"
  },
  aboutXWeeks: {
    one: "tahminan 1 hafta",
    other: "tahminan {{count}} hafta"
  },
  xWeeks: {
    one: "1 hafta",
    other: "{{count}} hafta"
  },
  aboutXMonths: {
    one: "tahminan 1 oy",
    other: "tahminan {{count}} oy"
  },
  xMonths: {
    one: "1 oy",
    other: "{{count}} oy"
  },
  aboutXYears: {
    one: "tahminan 1 yil",
    other: "tahminan {{count}} yil"
  },
  xYears: {
    one: "1 yil",
    other: "{{count}} yil"
  },
  overXYears: {
    one: "1 yildan ko'p",
    other: "{{count}} yildan ko'p"
  },
  almostXYears: {
    one: "deyarli 1 yil",
    other: "deyarli {{count}} yil"
  }
};
const formatDistance$5 = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$5[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + " dan keyin";
    } else {
      return result + " oldin";
    }
  }
  return result;
};
const dateFormats$5 = {
  full: "EEEE, do MMMM, y",
  long: "do MMMM, y",
  medium: "d MMM, y",
  short: "dd/MM/yyyy"
};
const timeFormats$5 = {
  full: "h:mm:ss zzzz",
  long: "h:mm:ss z",
  medium: "h:mm:ss",
  short: "h:mm"
};
const dateTimeFormats$5 = {
  any: "{{date}}, {{time}}"
};
const formatLong$5 = {
  date: buildFormatLongFn({
    formats: dateFormats$5,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$5,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$5,
    defaultWidth: "any"
  })
};
const formatRelativeLocale$5 = {
  lastWeek: "'oldingi' eeee p 'da'",
  yesterday: "'kecha' p 'da'",
  today: "'bugun' p 'da'",
  tomorrow: "'ertaga' p 'da'",
  nextWeek: "eeee p 'da'",
  other: "P"
};
const formatRelative$5 = (token, _date, _baseDate, _options) => formatRelativeLocale$5[token];
const eraValues$5 = {
  narrow: ["M.A", "M."],
  abbreviated: ["M.A", "M."],
  wide: ["Miloddan Avvalgi", "Milodiy"]
};
const quarterValues$5 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["CH.1", "CH.2", "CH.3", "CH.4"],
  wide: ["1-chi chorak", "2-chi chorak", "3-chi chorak", "4-chi chorak"]
};
const monthValues$5 = {
  narrow: ["Y", "F", "M", "A", "M", "I", "I", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Yan",
    "Fev",
    "Mar",
    "Apr",
    "May",
    "Iyun",
    "Iyul",
    "Avg",
    "Sen",
    "Okt",
    "Noy",
    "Dek"
  ],
  wide: [
    "Yanvar",
    "Fevral",
    "Mart",
    "Aprel",
    "May",
    "Iyun",
    "Iyul",
    "Avgust",
    "Sentabr",
    "Oktabr",
    "Noyabr",
    "Dekabr"
  ]
};
const dayValues$5 = {
  narrow: ["Y", "D", "S", "CH", "P", "J", "SH"],
  short: ["Ya", "Du", "Se", "Cho", "Pa", "Ju", "Sha"],
  abbreviated: ["Yak", "Dush", "Sesh", "Chor", "Pay", "Jum", "Shan"],
  wide: [
    "Yakshanba",
    "Dushanba",
    "Seshanba",
    "Chorshanba",
    "Payshanba",
    "Juma",
    "Shanba"
  ]
};
const dayPeriodValues$5 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "y.t",
    noon: "p.",
    morning: "ertalab",
    afternoon: "tushdan keyin",
    evening: "kechqurun",
    night: "tun"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "yarim tun",
    noon: "peshin",
    morning: "ertalab",
    afternoon: "tushdan keyin",
    evening: "kechqurun",
    night: "tun"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "yarim tun",
    noon: "peshin",
    morning: "ertalab",
    afternoon: "tushdan keyin",
    evening: "kechqurun",
    night: "tun"
  }
};
const formattingDayPeriodValues$5 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "y.t",
    noon: "p.",
    morning: "ertalab",
    afternoon: "tushdan keyin",
    evening: "kechqurun",
    night: "tun"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "yarim tun",
    noon: "peshin",
    morning: "ertalab",
    afternoon: "tushdan keyin",
    evening: "kechqurun",
    night: "tun"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "yarim tun",
    noon: "peshin",
    morning: "ertalab",
    afternoon: "tushdan keyin",
    evening: "kechqurun",
    night: "tun"
  }
};
const ordinalNumber$5 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
const localize$5 = {
  ordinalNumber: ordinalNumber$5,
  era: buildLocalizeFn({
    values: eraValues$5,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$5,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$5,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$5,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$5,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$5,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$5 = /^(\d+)(chi)?/i;
const parseOrdinalNumberPattern$5 = /\d+/i;
const matchEraPatterns$5 = {
  narrow: /^(m\.a|m\.)/i,
  abbreviated: /^(m\.a\.?\s?m\.?)/i,
  wide: /^(miloddan avval|miloddan keyin)/i
};
const parseEraPatterns$5 = {
  any: [/^b/i, /^(a|c)/i]
};
const matchQuarterPatterns$5 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](chi)? chorak/i
};
const parseQuarterPatterns$5 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$5 = {
  narrow: /^[yfmasond]/i,
  abbreviated: /^(yan|fev|mar|apr|may|iyun|iyul|avg|sen|okt|noy|dek)/i,
  wide: /^(yanvar|fevral|mart|aprel|may|iyun|iyul|avgust|sentabr|oktabr|noyabr|dekabr)/i
};
const parseMonthPatterns$5 = {
  narrow: [
    /^y/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^i/i,
    /^i/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ya/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^iyun/i,
    /^iyul/i,
    /^av/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$5 = {
  narrow: /^[ydschj]/i,
  short: /^(ya|du|se|cho|pa|ju|sha)/i,
  abbreviated: /^(yak|dush|sesh|chor|pay|jum|shan)/i,
  wide: /^(yakshanba|dushanba|seshanba|chorshanba|payshanba|juma|shanba)/i
};
const parseDayPatterns$5 = {
  narrow: [/^y/i, /^d/i, /^s/i, /^ch/i, /^p/i, /^j/i, /^sh/i],
  any: [/^ya/i, /^d/i, /^se/i, /^ch/i, /^p/i, /^j/i, /^sh/i]
};
const matchDayPeriodPatterns$5 = {
  narrow: /^(a|p|y\.t|p| (ertalab|tushdan keyin|kechqurun|tun))/i,
  any: /^([ap]\.?\s?m\.?|yarim tun|peshin| (ertalab|tushdan keyin|kechqurun|tun))/i
};
const parseDayPeriodPatterns$5 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^y\.t/i,
    noon: /^pe/i,
    morning: /ertalab/i,
    afternoon: /tushdan keyin/i,
    evening: /kechqurun/i,
    night: /tun/i
  }
};
const match$5 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$5,
    parsePattern: parseOrdinalNumberPattern$5,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$5,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$5,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$5,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$5,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$5,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$5,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$5,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$5,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$5,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$5,
    defaultParseWidth: "any"
  })
};
const uz = {
  code: "uz",
  formatDistance: formatDistance$5,
  formatLong: formatLong$5,
  formatRelative: formatRelative$5,
  localize: localize$5,
  match: match$5,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$4 = {
  lessThanXSeconds: {
    one: "1  ",
    other: "{{count}}  "
  },
  xSeconds: {
    one: "1 ",
    other: "{{count}} "
  },
  halfAMinute: " ",
  lessThanXMinutes: {
    one: "1  ",
    other: "{{count}}  "
  },
  xMinutes: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: " 1 ",
    other: " {{count}} "
  },
  xHours: {
    one: "1 ",
    other: "{{count}} "
  },
  xDays: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: " 1 ",
    other: " {{count}} "
  },
  xWeeks: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: " 1 ",
    other: " {{count}} "
  },
  xMonths: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: " 1 ",
    other: " {{count}} "
  },
  xYears: {
    one: "1 ",
    other: "{{count}} "
  },
  overXYears: {
    one: "1  ",
    other: "{{count}}  "
  },
  almostXYears: {
    one: " 1 ",
    other: " {{count}} "
  }
};
const formatDistance$4 = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$4[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + " ";
    } else {
      return result + " ";
    }
  }
  return result;
};
const dateFormats$4 = {
  full: "EEEE, do MMMM, y",
  long: "do MMMM, y",
  medium: "d MMM, y",
  short: "dd/MM/yyyy"
};
const timeFormats$4 = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
const dateTimeFormats$4 = {
  any: "{{date}}, {{time}}"
};
const formatLong$4 = {
  date: buildFormatLongFn({
    formats: dateFormats$4,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$4,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$4,
    defaultWidth: "any"
  })
};
const formatRelativeLocale$4 = {
  lastWeek: "'' eeee p ''",
  yesterday: "'' p ''",
  today: "'' p ''",
  tomorrow: "'' p ''",
  nextWeek: "eeee p ''",
  other: "P"
};
const formatRelative$4 = (token, _date, _baseDate, _options) => formatRelativeLocale$4[token];
const eraValues$4 = {
  narrow: [".", ""],
  abbreviated: [".", ""],
  wide: [" ", ""]
};
const quarterValues$4 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-.", "2-.", "3-.", "4-."],
  wide: ["1-", "2-", "3-", "4-"]
};
const monthValues$4 = {
  narrow: ["", "", "", "", "", "", "", "", "", "", "", ""],
  abbreviated: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$4 = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayPeriodValues$4 = {
  any: {
    am: "..",
    pm: "..",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$4 = {
  any: {
    am: "..",
    pm: "..",
    midnight: " ",
    noon: "",
    morning: "",
    afternoon: " ",
    evening: "",
    night: ""
  }
};
const ordinalNumber$4 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
const localize$4 = {
  ordinalNumber: ordinalNumber$4,
  era: buildLocalizeFn({
    values: eraValues$4,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$4,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$4,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$4,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$4,
    defaultWidth: "any",
    formattingValues: formattingDayPeriodValues$4,
    defaultFormattingWidth: "any"
  })
};
const matchOrdinalNumberPattern$4 = /^(\d+)()?/i;
const parseOrdinalNumberPattern$4 = /\d+/i;
const matchEraPatterns$4 = {
  narrow: /^(\.|\.)/i,
  abbreviated: /^(\.|\.)/i,
  wide: /^( | )/i
};
const parseEraPatterns$4 = {
  any: [/^/i, /^/i]
};
const matchQuarterPatterns$4 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]-./i,
  wide: /^[1234]-/i
};
const parseQuarterPatterns$4 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$4 = {
  narrow: /^[]/i,
  abbreviated: /^(|||||||||||)/i,
  wide: /^(|||||||||||)/i
};
const parseMonthPatterns$4 = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ],
  any: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i
  ]
};
const matchDayPatterns$4 = {
  narrow: /^[]/i,
  short: /^(||||||)/i,
  abbreviated: /^(||||||)/i,
  wide: /^(||||||)/i
};
const parseDayPatterns$4 = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
const matchDayPeriodPatterns$4 = {
  any: /^(\.\.|\.\.| | |(| ||))/i
};
const parseDayPeriodPatterns$4 = {
  any: {
    am: /^\.\./i,
    pm: /^\.\./i,
    midnight: /^ /i,
    noon: /^ /i,
    morning: //i,
    afternoon: / /i,
    evening: //i,
    night: //i
  }
};
const match$4 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$4,
    parsePattern: parseOrdinalNumberPattern$4,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$4,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$4,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$4,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$4,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$4,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$4,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$4,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$4,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$4,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$4,
    defaultParseWidth: "any"
  })
};
const uzCyrl = {
  code: "uz-Cyrl",
  formatDistance: formatDistance$4,
  formatLong: formatLong$4,
  formatRelative: formatRelative$4,
  localize: localize$4,
  match: match$4,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$3 = {
  lessThanXSeconds: {
    one: "di 1 giy",
    other: "di {{count}} giy"
  },
  xSeconds: {
    one: "1 giy",
    other: "{{count}} giy"
  },
  halfAMinute: "na pht",
  lessThanXMinutes: {
    one: "di 1 pht",
    other: "di {{count}} pht"
  },
  xMinutes: {
    one: "1 pht",
    other: "{{count}} pht"
  },
  aboutXHours: {
    one: "khong 1 gi",
    other: "khong {{count}} gi"
  },
  xHours: {
    one: "1 gi",
    other: "{{count}} gi"
  },
  xDays: {
    one: "1 ngy",
    other: "{{count}} ngy"
  },
  aboutXWeeks: {
    one: "khong 1 tun",
    other: "khong {{count}} tun"
  },
  xWeeks: {
    one: "1 tun",
    other: "{{count}} tun"
  },
  aboutXMonths: {
    one: "khong 1 thng",
    other: "khong {{count}} thng"
  },
  xMonths: {
    one: "1 thng",
    other: "{{count}} thng"
  },
  aboutXYears: {
    one: "khong 1 nm",
    other: "khong {{count}} nm"
  },
  xYears: {
    one: "1 nm",
    other: "{{count}} nm"
  },
  overXYears: {
    one: "hn 1 nm",
    other: "hn {{count}} nm"
  },
  almostXYears: {
    one: "gn 1 nm",
    other: "gn {{count}} nm"
  }
};
const formatDistance$3 = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$3[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + " na";
    } else {
      return result + " trc";
    }
  }
  return result;
};
const dateFormats$3 = {
  // th Su, ngy 25 thng 08 nm 2017
  full: "EEEE, 'ngy' d MMMM 'nm' y",
  // ngy 25 thng 08 nm 2017
  long: "'ngy' d MMMM 'nm' y",
  // 25 thg 08 nm 2017
  medium: "d MMM 'nm' y",
  // 25/08/2017
  short: "dd/MM/y"
};
const timeFormats$3 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$3 = {
  // th Su, ngy 25 thng 08 nm 2017 23:25:59
  full: "{{date}} {{time}}",
  // ngy 25 thng 08 nm 2017 23:25
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$3 = {
  date: buildFormatLongFn({
    formats: dateFormats$3,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$3,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$3,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$3 = {
  lastWeek: "eeee 'tun trc vo lc' p",
  yesterday: "'hm qua vo lc' p",
  today: "'hm nay vo lc' p",
  tomorrow: "'ngy mai vo lc' p",
  nextWeek: "eeee 'ti vo lc' p",
  other: "P"
};
const formatRelative$3 = (token, _date, _baseDate, _options) => formatRelativeLocale$3[token];
const eraValues$3 = {
  narrow: ["TCN", "SCN"],
  abbreviated: ["trc CN", "sau CN"],
  wide: ["trc Cng Nguyn", "sau Cng Nguyn"]
};
const quarterValues$3 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["Qu 1", "Qu 2", "Qu 3", "Qu 4"]
};
const formattingQuarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  // I notice many news outlet use this "qu II/2018"
  wide: ["qu I", "qu II", "qu III", "qu IV"]
};
const monthValues$3 = {
  narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
  abbreviated: [
    "Thg 1",
    "Thg 2",
    "Thg 3",
    "Thg 4",
    "Thg 5",
    "Thg 6",
    "Thg 7",
    "Thg 8",
    "Thg 9",
    "Thg 10",
    "Thg 11",
    "Thg 12"
  ],
  wide: [
    "Thng Mt",
    "Thng Hai",
    "Thng Ba",
    "Thng T",
    "Thng Nm",
    "Thng Su",
    "Thng By",
    "Thng Tm",
    "Thng Chn",
    "Thng Mi",
    "Thng Mi Mt",
    "Thng Mi Hai"
  ]
};
const formattingMonthValues = {
  narrow: [
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "10",
    "11",
    "12"
  ],
  abbreviated: [
    "thg 1",
    "thg 2",
    "thg 3",
    "thg 4",
    "thg 5",
    "thg 6",
    "thg 7",
    "thg 8",
    "thg 9",
    "thg 10",
    "thg 11",
    "thg 12"
  ],
  wide: [
    "thng 01",
    "thng 02",
    "thng 03",
    "thng 04",
    "thng 05",
    "thng 06",
    "thng 07",
    "thng 08",
    "thng 09",
    "thng 10",
    "thng 11",
    "thng 12"
  ]
};
const dayValues$3 = {
  narrow: ["CN", "T2", "T3", "T4", "T5", "T6", "T7"],
  short: ["CN", "Th 2", "Th 3", "Th 4", "Th 5", "Th 6", "Th 7"],
  abbreviated: ["CN", "Th 2", "Th 3", "Th 4", "Th 5", "Th 6", "Th 7"],
  wide: [
    "Ch Nht",
    "Th Hai",
    "Th Ba",
    "Th T",
    "Th Nm",
    "Th Su",
    "Th By"
  ]
};
const dayPeriodValues$3 = {
  // narrow date period is extremely rare in Vietnamese
  // I used abbreviated form for noon, morning and afternoon
  // which are regconizable by Vietnamese, others cannot be any shorter
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "na m",
    noon: "tr",
    morning: "sg",
    afternoon: "ch",
    evening: "ti",
    night: "m"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "na m",
    noon: "tra",
    morning: "sng",
    afternoon: "chiu",
    evening: "ti",
    night: "m"
  },
  wide: {
    am: "SA",
    pm: "CH",
    midnight: "na m",
    noon: "tra",
    morning: "sng",
    afternoon: "chiu",
    evening: "ti",
    night: "m"
  }
};
const formattingDayPeriodValues$3 = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "na m",
    noon: "tr",
    morning: "sg",
    afternoon: "ch",
    evening: "ti",
    night: "m"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "na m",
    noon: "tra",
    morning: "sng",
    afternoon: "chiu",
    evening: "ti",
    night: "m"
  },
  wide: {
    am: "SA",
    pm: "CH",
    midnight: "na m",
    noon: "gia tra",
    morning: "vo bui sng",
    afternoon: "vo bui chiu",
    evening: "vo bui ti",
    night: "vo ban m"
  }
};
const ordinalNumber$3 = (dirtyNumber, options) => {
  const number2 = Number(dirtyNumber);
  const unit = options?.unit;
  if (unit === "quarter") {
    switch (number2) {
      case 1:
        return "I";
      case 2:
        return "II";
      case 3:
        return "III";
      case 4:
        return "IV";
    }
  } else if (unit === "day") {
    switch (number2) {
      case 1:
        return "th 2";
      case 2:
        return "th 3";
      case 3:
        return "th 4";
      case 4:
        return "th 5";
      case 5:
        return "th 6";
      case 6:
        return "th 7";
      case 7:
        return "ch nht";
    }
  } else if (unit === "week") {
    if (number2 === 1) {
      return "th nht";
    } else {
      return "th " + number2;
    }
  } else if (unit === "dayOfYear") {
    if (number2 === 1) {
      return "u tin";
    } else {
      return "th " + number2;
    }
  }
  return String(number2);
};
const localize$3 = {
  ordinalNumber: ordinalNumber$3,
  era: buildLocalizeFn({
    values: eraValues$3,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$3,
    defaultWidth: "wide",
    formattingValues: formattingQuarterValues,
    defaultFormattingWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$3,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$3,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$3,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$3,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$3 = /^(\d+)/i;
const parseOrdinalNumberPattern$3 = /\d+/i;
const matchEraPatterns$3 = {
  narrow: /^(tcn|scn)/i,
  abbreviated: /^(trc CN|sau CN)/i,
  wide: /^(trc Cng Nguyn|sau Cng Nguyn)/i
};
const parseEraPatterns$3 = {
  any: [/^t/i, /^s/i]
};
const matchQuarterPatterns$3 = {
  narrow: /^([1234]|i{1,3}v?)/i,
  abbreviated: /^q([1234]|i{1,3}v?)/i,
  wide: /^qu ([1234]|i{1,3}v?)/i
};
const parseQuarterPatterns$3 = {
  any: [/(1|i)$/i, /(2|ii)$/i, /(3|iii)$/i, /(4|iv)$/i]
};
const matchMonthPatterns$3 = {
  // month number may contain leading 0, 'thg' prefix may have space, underscore or empty before number
  // note the order of '1' since it is a sub-string of '10', so must be lower priority
  narrow: /^(0?[2-9]|10|11|12|0?1)/i,
  // note the order of 'thg 1' since it is sub-string of 'thg 10', so must be lower priority
  abbreviated: /^thg[ _]?(0?[1-9](?!\d)|10|11|12)/i,
  // note the order of 'Mi' since it is sub-string of Mi Mt, so must be lower priority
  wide: /^thng ?(Mt|Hai|Ba|T|Nm|Su|By|Tm|Chn|Mi|Mi ?Mt|Mi ?Hai|0?[1-9](?!\d)|10|11|12)/i
};
const parseMonthPatterns$3 = {
  narrow: [
    /0?1$/i,
    /0?2/i,
    /3/,
    /4/,
    /5/,
    /6/,
    /7/,
    /8/,
    /9/,
    /10/,
    /11/,
    /12/
  ],
  abbreviated: [
    /^thg[ _]?0?1(?!\d)/i,
    /^thg[ _]?0?2/i,
    /^thg[ _]?0?3/i,
    /^thg[ _]?0?4/i,
    /^thg[ _]?0?5/i,
    /^thg[ _]?0?6/i,
    /^thg[ _]?0?7/i,
    /^thg[ _]?0?8/i,
    /^thg[ _]?0?9/i,
    /^thg[ _]?10/i,
    /^thg[ _]?11/i,
    /^thg[ _]?12/i
  ],
  wide: [
    /^thng ?(Mt|0?1(?!\d))/i,
    /^thng ?(Hai|0?2)/i,
    /^thng ?(Ba|0?3)/i,
    /^thng ?(T|0?4)/i,
    /^thng ?(Nm|0?5)/i,
    /^thng ?(Su|0?6)/i,
    /^thng ?(By|0?7)/i,
    /^thng ?(Tm|0?8)/i,
    /^thng ?(Chn|0?9)/i,
    /^thng ?(Mi|10)/i,
    /^thng ?(Mi ?Mt|11)/i,
    /^thng ?(Mi ?Hai|12)/i
  ]
};
const matchDayPatterns$3 = {
  narrow: /^(CN|T2|T3|T4|T5|T6|T7)/i,
  short: /^(CN|Th ?2|Th ?3|Th ?4|Th ?5|Th ?6|Th ?7)/i,
  abbreviated: /^(CN|Th ?2|Th ?3|Th ?4|Th ?5|Th ?6|Th ?7)/i,
  wide: /^(Ch ?Nht|Cha ?Nht|th ?Hai|th ?Ba|th ?T|th ?Nm|th ?Su|th ?By)/i
};
const parseDayPatterns$3 = {
  narrow: [/CN/i, /2/i, /3/i, /4/i, /5/i, /6/i, /7/i],
  short: [/CN/i, /2/i, /3/i, /4/i, /5/i, /6/i, /7/i],
  abbreviated: [/CN/i, /2/i, /3/i, /4/i, /5/i, /6/i, /7/i],
  wide: [/(Ch|Cha) ?Nht/i, /Hai/i, /Ba/i, /T/i, /Nm/i, /Su/i, /By/i]
};
const matchDayPeriodPatterns$3 = {
  narrow: /^(a|p|na m|tra|(gi) (sng|chiu|ti|m))/i,
  abbreviated: /^(am|pm|na m|tra|(gi) (sng|chiu|ti|m))/i,
  wide: /^(ch[^i]*|sa|na m|tra|(gi) (sng|chiu|ti|m))/i
};
const parseDayPeriodPatterns$3 = {
  any: {
    am: /^(a|sa)/i,
    pm: /^(p|ch[^i]*)/i,
    midnight: /na m/i,
    noon: /tra/i,
    morning: /sng/i,
    afternoon: /chiu/i,
    evening: /ti/i,
    night: /^m/i
  }
};
const match$3 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$3,
    parsePattern: parseOrdinalNumberPattern$3,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$3,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$3,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$3,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$3,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$3,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$3,
    defaultParseWidth: "wide"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$3,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$3,
    defaultParseWidth: "wide"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$3,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$3,
    defaultParseWidth: "any"
  })
};
const vi = {
  code: "vi",
  formatDistance: formatDistance$3,
  formatLong: formatLong$3,
  formatRelative: formatRelative$3,
  localize: localize$3,
  match: match$3,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale$2 = {
  lessThanXSeconds: {
    one: " 1 ",
    other: " {{count}} "
  },
  xSeconds: {
    one: "1 ",
    other: "{{count}} "
  },
  halfAMinute: "",
  lessThanXMinutes: {
    one: " 1 ",
    other: " {{count}} "
  },
  xMinutes: {
    one: "1 ",
    other: "{{count}} "
  },
  xHours: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: " 1 ",
    other: " {{count}} "
  },
  xDays: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: " 1 ",
    other: " {{count}} "
  },
  xWeeks: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: " 1 ",
    other: " {{count}} "
  },
  xMonths: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: " 1 ",
    other: " {{count}} "
  },
  xYears: {
    one: "1 ",
    other: "{{count}} "
  },
  overXYears: {
    one: " 1 ",
    other: " {{count}} "
  },
  almostXYears: {
    one: " 1 ",
    other: " {{count}} "
  }
};
const formatDistance$2 = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$2[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "";
    } else {
      return result + "";
    }
  }
  return result;
};
const dateFormats$2 = {
  full: "y''M''d'' EEEE",
  long: "y''M''d''",
  medium: "yyyy-MM-dd",
  short: "yy-MM-dd"
};
const timeFormats$2 = {
  full: "zzzz a h:mm:ss",
  long: "z a h:mm:ss",
  medium: "a h:mm:ss",
  short: "a h:mm"
};
const dateTimeFormats$2 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$2 = {
  date: buildFormatLongFn({
    formats: dateFormats$2,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$2,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$2,
    defaultWidth: "full"
  })
};
function checkWeek(date2, baseDate, options) {
  const baseFormat = "eeee p";
  if (isSameWeek(date2, baseDate, options)) {
    return baseFormat;
  } else if (date2.getTime() > baseDate.getTime()) {
    return "''" + baseFormat;
  }
  return "''" + baseFormat;
}
const formatRelativeLocale$2 = {
  lastWeek: checkWeek,
  // days before yesterday, maybe in this week or last week
  yesterday: "'' p",
  today: "'' p",
  tomorrow: "'' p",
  nextWeek: checkWeek,
  // days after tomorrow, maybe in this week or next week
  other: "PP p"
};
const formatRelative$2 = (token, date2, baseDate, options) => {
  const format2 = formatRelativeLocale$2[token];
  if (typeof format2 === "function") {
    return format2(date2, baseDate, options);
  }
  return format2;
};
const eraValues$2 = {
  narrow: ["", ""],
  abbreviated: ["", ""],
  wide: ["", ""]
};
const quarterValues$2 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["", "", "", ""],
  wide: ["", "", "", ""]
};
const monthValues$2 = {
  narrow: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  abbreviated: [
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "10",
    "11",
    "12"
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$2 = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: ["", "", "", "", "", "", ""]
};
const dayPeriodValues$2 = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$2 = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$2 = (dirtyNumber, options) => {
  const number2 = Number(dirtyNumber);
  switch (options?.unit) {
    case "date":
      return number2.toString() + "";
    case "hour":
      return number2.toString() + "";
    case "minute":
      return number2.toString() + "";
    case "second":
      return number2.toString() + "";
    default:
      return " " + number2.toString();
  }
};
const localize$2 = {
  ordinalNumber: ordinalNumber$2,
  era: buildLocalizeFn({
    values: eraValues$2,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$2,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$2,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$2,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$2,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$2,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$2 = /^(\s*)?\d+(|||)?/i;
const parseOrdinalNumberPattern$2 = /\d+/i;
const matchEraPatterns$2 = {
  narrow: /^()/i,
  abbreviated: /^()/i,
  wide: /^(|)/i
};
const parseEraPatterns$2 = {
  any: [/^()/i, /^()/i]
};
const matchQuarterPatterns$2 = {
  narrow: /^[1234]/i,
  abbreviated: /^[]/i,
  wide: /^[]/i
};
const parseQuarterPatterns$2 = {
  any: [/(1|)/i, /(2|)/i, /(3|)/i, /(4|)/i]
};
const matchMonthPatterns$2 = {
  narrow: /^(|||||||||[])/i,
  abbreviated: /^(|||||||||[]|\d|1[12])/i,
  wide: /^(|||||||||[])/i
};
const parseMonthPatterns$2 = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^(?!(|))/i,
    /^/i,
    /^/i
  ],
  any: [
    /^|1/i,
    /^|2/i,
    /^|3/i,
    /^|4/i,
    /^|5/i,
    /^|6/i,
    /^|7/i,
    /^|8/i,
    /^|9/i,
    /^(?!(|))|10/i,
    /^|11/i,
    /^|12/i
  ]
};
const matchDayPatterns$2 = {
  narrow: /^[]/i,
  short: /^[]/i,
  abbreviated: /^[]/i,
  wide: /^[]/i
};
const parseDayPatterns$2 = {
  any: [//i, //i, //i, //i, //i, //i, //i]
};
const matchDayPeriodPatterns$2 = {
  any: /^(?|?||[]|?||?||)/i
};
const parseDayPeriodPatterns$2 = {
  any: {
    am: /^?/i,
    pm: /^?/i,
    midnight: /^/i,
    noon: /^[]/i,
    morning: /^/i,
    afternoon: /^/i,
    evening: /^?/i,
    night: /^/i
  }
};
const match$2 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$2,
    parsePattern: parseOrdinalNumberPattern$2,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$2,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$2,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$2,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$2,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$2,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$2,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$2,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$2,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$2,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$2,
    defaultParseWidth: "any"
  })
};
const zhCN = {
  code: "zh-CN",
  formatDistance: formatDistance$2,
  formatLong: formatLong$2,
  formatRelative: formatRelative$2,
  localize: localize$2,
  match: match$2,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$1 = {
  lessThanXSeconds: {
    one: " 1 ",
    other: " {{count}} "
  },
  xSeconds: {
    one: "1 ",
    other: "{{count}} "
  },
  halfAMinute: "",
  lessThanXMinutes: {
    one: " 1 ",
    other: " {{count}} "
  },
  xMinutes: {
    one: "1 ",
    other: "{{count}} "
  },
  xHours: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: " 1 ",
    other: " {{count}} "
  },
  xDays: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: " 1 ",
    other: " {{count}} "
  },
  xWeeks: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: " 1 ",
    other: " {{count}} "
  },
  xMonths: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: " 1 ",
    other: " {{count}} "
  },
  xYears: {
    one: "1 ",
    other: "{{count}} "
  },
  overXYears: {
    one: " 1 ",
    other: " {{count}} "
  },
  almostXYears: {
    one: " 1 ",
    other: " {{count}} "
  }
};
const formatDistance$1 = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale$1[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "";
    } else {
      return result + "";
    }
  }
  return result;
};
const dateFormats$1 = {
  full: "y''M''d'' EEEE",
  long: "y''M''d''",
  medium: "yyyy-MM-dd",
  short: "yy-MM-dd"
};
const timeFormats$1 = {
  full: "zzzz a h:mm:ss",
  long: "z a h:mm:ss",
  medium: "a h:mm:ss",
  short: "a h:mm"
};
const dateTimeFormats$1 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$1 = {
  date: buildFormatLongFn({
    formats: dateFormats$1,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$1 = {
  lastWeek: "''eeee p",
  yesterday: "'' p",
  today: "'' p",
  tomorrow: "'' p",
  nextWeek: "''eeee p",
  other: "P"
};
const formatRelative$1 = (token, _date, _baseDate, _options) => formatRelativeLocale$1[token];
const eraValues$1 = {
  narrow: ["", ""],
  abbreviated: ["", ""],
  wide: ["", ""]
};
const quarterValues$1 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["", "", "", ""],
  wide: ["", "", "", ""]
};
const monthValues$1 = {
  narrow: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  abbreviated: [
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "10",
    "11",
    "12"
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues$1 = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: ["", "", "", "", "", "", ""]
};
const dayPeriodValues$1 = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues$1 = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber$1 = (dirtyNumber, options) => {
  const number2 = Number(dirtyNumber);
  switch (options?.unit) {
    case "date":
      return number2 + "";
    case "hour":
      return number2 + "";
    case "minute":
      return number2 + "";
    case "second":
      return number2 + "";
    default:
      return " " + number2;
  }
};
const localize$1 = {
  ordinalNumber: ordinalNumber$1,
  era: buildLocalizeFn({
    values: eraValues$1,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$1,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$1,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$1,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$1,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$1,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$1 = /^(\s*)?\d+(|||)?/i;
const parseOrdinalNumberPattern$1 = /\d+/i;
const matchEraPatterns$1 = {
  narrow: /^()/i,
  abbreviated: /^()/i,
  wide: /^(|)/i
};
const parseEraPatterns$1 = {
  any: [/^()/i, /^()/i]
};
const matchQuarterPatterns$1 = {
  narrow: /^[1234]/i,
  abbreviated: /^[]/i,
  wide: /^[]/i
};
const parseQuarterPatterns$1 = {
  any: [/(1|)/i, /(2|)/i, /(3|)/i, /(4|)/i]
};
const matchMonthPatterns$1 = {
  narrow: /^(|||||||||[])/i,
  abbreviated: /^(|||||||||[]|\d|1[12])/i,
  wide: /^(|||||||||[])/i
};
const parseMonthPatterns$1 = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^(?!(|))/i,
    /^/i,
    /^/i
  ],
  any: [
    /^|1/i,
    /^|2/i,
    /^|3/i,
    /^|4/i,
    /^|5/i,
    /^|6/i,
    /^|7/i,
    /^|8/i,
    /^|9/i,
    /^(?!(|))|10/i,
    /^|11/i,
    /^|12/i
  ]
};
const matchDayPatterns$1 = {
  narrow: /^[]/i,
  short: /^[]/i,
  abbreviated: /^[]/i,
  wide: /^[]/i
};
const parseDayPatterns$1 = {
  any: [//i, //i, //i, //i, //i, //i, //i]
};
const matchDayPeriodPatterns$1 = {
  any: /^(?|?||[]|?||?|)/i
};
const parseDayPeriodPatterns$1 = {
  any: {
    am: /^?/i,
    pm: /^?/i,
    midnight: /^/i,
    noon: /^[]/i,
    morning: /^/i,
    afternoon: /^/i,
    evening: /^?/i,
    night: /^/i
  }
};
const match$1 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$1,
    parsePattern: parseOrdinalNumberPattern$1,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$1,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1,
    defaultParseWidth: "any"
  })
};
const zhHK = {
  code: "zh-HK",
  formatDistance: formatDistance$1,
  formatLong: formatLong$1,
  formatRelative: formatRelative$1,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale = {
  lessThanXSeconds: {
    one: " 1 ",
    other: " {{count}} "
  },
  xSeconds: {
    one: "1 ",
    other: "{{count}} "
  },
  halfAMinute: "",
  lessThanXMinutes: {
    one: " 1 ",
    other: " {{count}} "
  },
  xMinutes: {
    one: "1 ",
    other: "{{count}} "
  },
  xHours: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXHours: {
    one: " 1 ",
    other: " {{count}} "
  },
  xDays: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXWeeks: {
    one: " 1 ",
    other: " {{count}} "
  },
  xWeeks: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXMonths: {
    one: " 1 ",
    other: " {{count}} "
  },
  xMonths: {
    one: "1 ",
    other: "{{count}} "
  },
  aboutXYears: {
    one: " 1 ",
    other: " {{count}} "
  },
  xYears: {
    one: "1 ",
    other: "{{count}} "
  },
  overXYears: {
    one: " 1 ",
    other: " {{count}} "
  },
  almostXYears: {
    one: " 1 ",
    other: " {{count}} "
  }
};
const formatDistance = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "";
    } else {
      return result + "";
    }
  }
  return result;
};
const dateFormats = {
  full: "y''M''d'' EEEE",
  long: "y''M''d''",
  medium: "yyyy-MM-dd",
  short: "yy-MM-dd"
};
const timeFormats = {
  full: "zzzz a h:mm:ss",
  long: "z a h:mm:ss",
  medium: "a h:mm:ss",
  short: "a h:mm"
};
const dateTimeFormats = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
const formatRelativeLocale = {
  lastWeek: "''eeee p",
  yesterday: "'' p",
  today: "'' p",
  tomorrow: "'' p",
  nextWeek: "''eeee p",
  other: "P"
};
const formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];
const eraValues = {
  narrow: ["", ""],
  abbreviated: ["", ""],
  wide: ["", ""]
};
const quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["", "", "", ""],
  wide: ["", "", "", ""]
};
const monthValues = {
  narrow: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  abbreviated: [
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "10",
    "11",
    "12"
  ],
  wide: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
const dayValues = {
  narrow: ["", "", "", "", "", "", ""],
  short: ["", "", "", "", "", "", ""],
  abbreviated: ["", "", "", "", "", "", ""],
  wide: ["", "", "", "", "", "", ""]
};
const dayPeriodValues = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const formattingDayPeriodValues = {
  narrow: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  abbreviated: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  },
  wide: {
    am: "",
    pm: "",
    midnight: "",
    noon: "",
    morning: "",
    afternoon: "",
    evening: "",
    night: ""
  }
};
const ordinalNumber = (dirtyNumber, options) => {
  const number2 = Number(dirtyNumber);
  switch (options?.unit) {
    case "date":
      return number2 + "";
    case "hour":
      return number2 + "";
    case "minute":
      return number2 + "";
    case "second":
      return number2 + "";
    default:
      return " " + number2;
  }
};
const localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern = /^(\s*)?\d+(|||)?/i;
const parseOrdinalNumberPattern = /\d+/i;
const matchEraPatterns = {
  narrow: /^()/i,
  abbreviated: /^()/i,
  wide: /^(|)/i
};
const parseEraPatterns = {
  any: [/^()/i, /^()/i]
};
const matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^[]/i,
  wide: /^[]/i
};
const parseQuarterPatterns = {
  any: [/(1|)/i, /(2|)/i, /(3|)/i, /(4|)/i]
};
const matchMonthPatterns = {
  narrow: /^(|||||||||[])/i,
  abbreviated: /^(|||||||||[]|\d|1[12])/i,
  wide: /^(|||||||||[])/i
};
const parseMonthPatterns = {
  narrow: [
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^/i,
    /^(?!(|))/i,
    /^/i,
    /^/i
  ],
  any: [
    /^|1/i,
    /^|2/i,
    /^|3/i,
    /^|4/i,
    /^|5/i,
    /^|6/i,
    /^|7/i,
    /^|8/i,
    /^|9/i,
    /^(?!(|))|10/i,
    /^|11/i,
    /^|12/i
  ]
};
const matchDayPatterns = {
  narrow: /^[]/i,
  short: /^[]/i,
  abbreviated: /^[]/i,
  wide: /^[]/i
};
const parseDayPatterns = {
  any: [//i, //i, //i, //i, //i, //i, //i]
};
const matchDayPeriodPatterns = {
  any: /^(?|?||[]|?||?|)/i
};
const parseDayPeriodPatterns = {
  any: {
    am: /^?/i,
    pm: /^?/i,
    midnight: /^/i,
    noon: /^[]/i,
    morning: /^/i,
    afternoon: /^/i,
    evening: /^?/i,
    night: /^/i
  }
};
const match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
const zhTW = {
  code: "zh-TW",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const locales = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  af,
  ar,
  arDZ,
  arEG,
  arMA,
  arSA,
  arTN,
  az,
  be,
  beTarask,
  bg,
  bn,
  bs,
  ca,
  ckb,
  cs,
  cy,
  da,
  de,
  deAT,
  el,
  enAU,
  enCA,
  enGB,
  enIE,
  enIN,
  enNZ,
  enUS,
  enZA,
  eo,
  es,
  et,
  eu,
  faIR,
  fi,
  fr,
  frCA,
  frCH,
  fy,
  gd,
  gl,
  gu,
  he,
  hi,
  hr,
  ht,
  hu,
  hy,
  id,
  is: is$2,
  it,
  itCH,
  ja,
  jaHira,
  ka,
  kk,
  km,
  kn,
  ko,
  lb,
  lt,
  lv,
  mk,
  mn,
  ms,
  mt,
  nb,
  nl,
  nlBE,
  nn,
  oc,
  pl,
  pt,
  ptBR,
  ro,
  ru,
  se,
  sk,
  sl,
  sq,
  sr,
  srLatn,
  sv,
  ta: ta$1,
  te,
  th,
  tr: tr$1,
  ug,
  uk,
  uz,
  uzCyrl,
  vi,
  zhCN,
  zhHK,
  zhTW
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @remix-run/router v1.21.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash: hash2
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash: hash2
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function invariant$2(value, message2) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message2);
  }
}
function warning(cond, message2) {
  if (!cond) {
    if (typeof console !== "undefined") console.warn(message2);
    try {
      throw new Error(message2);
    } catch (e2) {
    }
  }
}
function createKey$1() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location, index2) {
  return {
    usr: location.state,
    key: location.key,
    idx: index2
  };
}
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends$3({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey$1()
  });
  return location;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash: hash2 = ""
  } = _ref;
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#") pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener = null;
  let index2 = getIndex();
  if (index2 == null) {
    index2 = 0;
    globalHistory.replaceState(_extends$3({}, globalHistory.state, {
      idx: index2
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index2;
    index2 = nextIndex;
    if (listener) {
      listener({
        action,
        location: history2.location,
        delta
      });
    }
  }
  function push(to, state) {
    action = Action.Push;
    let location = createLocation(history2.location, to, state);
    index2 = getIndex() + 1;
    let historyState = getHistoryState(location, index2);
    let url = history2.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history2.location,
        delta: 1
      });
    }
  }
  function replace2(to, state) {
    action = Action.Replace;
    let location = createLocation(history2.location, to, state);
    index2 = getIndex();
    let historyState = getHistoryState(location, index2);
    let url = history2.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history2.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    let base2 = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    href = href.replace(/ $/, "%20");
    invariant$2(base2, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base2);
  }
  let history2 = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn2) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn2;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace: replace2,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history2;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  return matchRoutesImpl(routes, locationArg, basename);
}
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches2 = null;
  for (let i = 0; matches2 == null && i < branches.length; ++i) {
    let decoded = decodePath(pathname);
    matches2 = matchRouteBranch(branches[i], decoded);
  }
  return matches2;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index2, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant$2(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant$2(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index2) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index2);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index2, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first2, ...rest] = segments;
  let isOptional = first2.endsWith("?");
  let required = first2.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a2, b) => a2.score !== b.score ? b.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:[\w-]+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s2) => s2 === "*";
function computeScore(path, index2) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a2, b) {
  let siblings = a2.length === b.length && a2.slice(0, -1).every((n2, i) => n2 === b[i]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b[b.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname, allowPartial) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches2 = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end2 = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match2 = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end: end2
    }, remainingPathname);
    let route = meta.route;
    if (!match2) {
      return null;
    }
    Object.assign(matchedParams, match2.params);
    matches2.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match2.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
      route
    });
    if (match2.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
    }
  }
  return matches2;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match2 = pathname.match(matcher);
  if (!match2) return null;
  let matchedPathname = match2[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match2.slice(1);
  let params = compiledParams.reduce((memo2, _ref, index2) => {
    let {
      paramName,
      isOptional
    } = _ref;
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    const value = captureGroups[index2];
    if (isOptional && !value) {
      memo2[paramName] = void 0;
    } else {
      memo2[paramName] = (value || "").replace(/%2F/g, "/");
    }
    return memo2;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end2) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end2 === void 0) {
    end2 = true;
  }
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_, paramName, isOptional) => {
    params.push({
      paramName,
      isOptional: isOptional != null
    });
    return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    params.push({
      paramName: "*"
    });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end2) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map((v) => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    warning(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash: hash2 = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash2)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches2) {
  return matches2.filter((match2, index2) => index2 === 0 || match2.route.path && match2.route.path.length > 0);
}
function getResolveToMatches(matches2, v7_relativeSplatPath) {
  let pathMatches = getPathContributingMatches(matches2);
  if (v7_relativeSplatPath) {
    return pathMatches.map((match2, idx) => idx === pathMatches.length - 1 ? match2.pathname : match2.pathnameBase);
  }
  return pathMatches.map((match2) => match2.pathnameBase);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends$3({}, toArg);
    invariant$2(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant$2(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant$2(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from2;
  if (toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
class AbortedDeferredError extends Error {
}
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.28.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
const React$7 = await importShared("react");
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
const DataRouterContext = /* @__PURE__ */ React$7.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ React$7.createContext(null);
const AwaitContext = /* @__PURE__ */ React$7.createContext(null);
const NavigationContext$1 = /* @__PURE__ */ React$7.createContext(null);
const LocationContext = /* @__PURE__ */ React$7.createContext(null);
const RouteContext = /* @__PURE__ */ React$7.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
const RouteErrorContext = /* @__PURE__ */ React$7.createContext(null);
function useHref(to, _temp11) {
  let {
    relative
  } = _temp11 === void 0 ? {} : _temp11;
  !useInRouterContext() ? invariant$2(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = React$7.useContext(NavigationContext$1);
  let {
    hash: hash2,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash: hash2
  });
}
function useInRouterContext() {
  return React$7.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant$2(false) : void 0;
  return React$7.useContext(LocationContext).location;
}
function useIsomorphicLayoutEffect$3(cb) {
  let isStatic = React$7.useContext(NavigationContext$1).static;
  if (!isStatic) {
    React$7.useLayoutEffect(cb);
  }
}
function useNavigate() {
  let {
    isDataRoute
  } = React$7.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  !useInRouterContext() ? invariant$2(false) : void 0;
  let dataRouterContext = React$7.useContext(DataRouterContext);
  let {
    basename,
    future,
    navigator: navigator2
  } = React$7.useContext(NavigationContext$1);
  let {
    matches: matches2
  } = React$7.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches2, future.v7_relativeSplatPath));
  let activeRef = React$7.useRef(false);
  useIsomorphicLayoutEffect$3(() => {
    activeRef.current = true;
  });
  let navigate = React$7.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current) return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (dataRouterContext == null && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
function useParams() {
  let {
    matches: matches2
  } = React$7.useContext(RouteContext);
  let routeMatch = matches2[matches2.length - 1];
  return routeMatch ? routeMatch.params : {};
}
function useResolvedPath(to, _temp22) {
  let {
    relative
  } = _temp22 === void 0 ? {} : _temp22;
  let {
    future
  } = React$7.useContext(NavigationContext$1);
  let {
    matches: matches2
  } = React$7.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches2, future.v7_relativeSplatPath));
  return React$7.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  !useInRouterContext() ? invariant$2(false) : void 0;
  let {
    navigator: navigator2
  } = React$7.useContext(NavigationContext$1);
  let {
    matches: parentMatches
  } = React$7.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant$2(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches2 = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches2 && matches2.map((match2) => Object.assign({}, match2, {
    params: Object.assign({}, parentParams, match2.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathname).pathname : match2.pathname
    ]),
    pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathnameBase).pathname : match2.pathnameBase
    ])
  })), parentMatches, dataRouterState, future);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ React$7.createElement(LocationContext.Provider, {
      value: {
        location: _extends$2({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message2 = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  return /* @__PURE__ */ React$7.createElement(React$7.Fragment, null, /* @__PURE__ */ React$7.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ React$7.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message2), stack ? /* @__PURE__ */ React$7.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
const defaultErrorElement = /* @__PURE__ */ React$7.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends React$7.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ React$7.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ React$7.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match: match2,
    children
  } = _ref;
  let dataRouterContext = React$7.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match2.route.errorElement || match2.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match2.route.id;
  }
  return /* @__PURE__ */ React$7.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches2, parentMatches, dataRouterState, future) {
  var _dataRouterState;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (future === void 0) {
    future = null;
  }
  if (matches2 == null) {
    var _future;
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches2 = dataRouterState.matches;
    } else if ((_future = future) != null && _future.v7_partialHydration && parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches2 = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches2;
  let errors = (_dataRouterState = dataRouterState) == null ? void 0 : _dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m) => m.route.id && (errors == null ? void 0 : errors[m.route.id]) !== void 0);
    !(errorIndex >= 0) ? invariant$2(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState && future && future.v7_partialHydration) {
    for (let i = 0; i < renderedMatches.length; i++) {
      let match2 = renderedMatches[i];
      if (match2.route.HydrateFallback || match2.route.hydrateFallbackElement) {
        fallbackIndex = i;
      }
      if (match2.route.id) {
        let {
          loaderData,
          errors: errors2
        } = dataRouterState;
        let needsToRunLoader = match2.route.loader && loaderData[match2.route.id] === void 0 && (!errors2 || errors2[match2.route.id] === void 0);
        if (match2.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match2, index2) => {
    let error;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error = errors && match2.route.id ? errors[match2.route.id] : void 0;
      errorElement = match2.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index2 === 0) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index2) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match2.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches22 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
    let getChildren2 = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match2.route.Component) {
        children = /* @__PURE__ */ React$7.createElement(match2.route.Component, null);
      } else if (match2.route.element) {
        children = match2.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ React$7.createElement(RenderedRoute, {
        match: match2,
        routeContext: {
          outlet,
          matches: matches22,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match2.route.ErrorBoundary || match2.route.errorElement || index2 === 0) ? /* @__PURE__ */ React$7.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error,
      children: getChildren2(),
      routeContext: {
        outlet: null,
        matches: matches22,
        isDataRoute: true
      }
    }) : getChildren2();
  }, null);
}
var DataRouterHook$1 = /* @__PURE__ */ function(DataRouterHook2) {
  DataRouterHook2["UseBlocker"] = "useBlocker";
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
  DataRouterHook2["UseNavigateStable"] = "useNavigate";
  return DataRouterHook2;
}(DataRouterHook$1 || {});
var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
  DataRouterStateHook2["UseBlocker"] = "useBlocker";
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook2["UseRouteId"] = "useRouteId";
  return DataRouterStateHook2;
}(DataRouterStateHook$1 || {});
function useDataRouterContext$1(hookName) {
  let ctx = React$7.useContext(DataRouterContext);
  !ctx ? invariant$2(false) : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = React$7.useContext(DataRouterStateContext);
  !state ? invariant$2(false) : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = React$7.useContext(RouteContext);
  !route ? invariant$2(false) : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext();
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? invariant$2(false) : void 0;
  return thisRoute.route.id;
}
function useRouteError() {
  var _state$errors;
  let error = React$7.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
  if (error !== void 0) {
    return error;
  }
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext$1(DataRouterHook$1.UseNavigateStable);
  let id2 = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
  let activeRef = React$7.useRef(false);
  useIsomorphicLayoutEffect$3(() => {
    activeRef.current = true;
  });
  let navigate = React$7.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current) return;
    if (typeof to === "number") {
      router.navigate(to);
    } else {
      router.navigate(to, _extends$2({
        fromRouteId: id2
      }, options));
    }
  }, [router, id2]);
  return navigate;
}
const alreadyWarned = {};
function warnOnce(key, message2) {
  if (!alreadyWarned[message2]) {
    alreadyWarned[message2] = true;
    console.warn(message2);
  }
}
const logDeprecation = (flag, msg, link) => warnOnce(flag, " React Router Future Flag Warning: " + msg + ". " + ("You can use the `" + flag + "` future flag to opt-in early. ") + ("For more information, see " + link + "."));
function logV6DeprecationWarnings(renderFuture, routerFuture) {
  if ((renderFuture == null ? void 0 : renderFuture.v7_startTransition) === void 0) {
    logDeprecation("v7_startTransition", "React Router will begin wrapping state updates in `React.startTransition` in v7", "https://reactrouter.com/v6/upgrading/future#v7_starttransition");
  }
  if ((renderFuture == null ? void 0 : renderFuture.v7_relativeSplatPath) === void 0 && !routerFuture) {
    logDeprecation("v7_relativeSplatPath", "Relative route resolution within Splat routes is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath");
  }
}
const START_TRANSITION$1 = "startTransition";
React$7[START_TRANSITION$1];
function Route(_props) {
  invariant$2(false);
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false,
    future
  } = _ref5;
  !!useInRouterContext() ? invariant$2(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = React$7.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp,
    future: _extends$2({
      v7_relativeSplatPath: false
    }, future)
  }), [basename, future, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash: hash2 = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = React$7.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash: hash2,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash2, state, key, navigationType]);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ React$7.createElement(NavigationContext$1.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ React$7.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes(_ref6) {
  let {
    children,
    location
  } = _ref6;
  return useRoutes(createRoutesFromChildren(children), location);
}
var AwaitRenderStatus = /* @__PURE__ */ function(AwaitRenderStatus2) {
  AwaitRenderStatus2[AwaitRenderStatus2["pending"] = 0] = "pending";
  AwaitRenderStatus2[AwaitRenderStatus2["success"] = 1] = "success";
  AwaitRenderStatus2[AwaitRenderStatus2["error"] = 2] = "error";
  return AwaitRenderStatus2;
}(AwaitRenderStatus || {});
const neverSettledPromise = new Promise(() => {
});
class AwaitErrorBoundary extends React$7.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: null
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("<Await> caught the following error during render", error, errorInfo);
  }
  render() {
    let {
      children,
      errorElement,
      resolve
    } = this.props;
    let promise = null;
    let status = AwaitRenderStatus.pending;
    if (!(resolve instanceof Promise)) {
      status = AwaitRenderStatus.success;
      promise = Promise.resolve();
      Object.defineProperty(promise, "_tracked", {
        get: () => true
      });
      Object.defineProperty(promise, "_data", {
        get: () => resolve
      });
    } else if (this.state.error) {
      status = AwaitRenderStatus.error;
      let renderError = this.state.error;
      promise = Promise.reject().catch(() => {
      });
      Object.defineProperty(promise, "_tracked", {
        get: () => true
      });
      Object.defineProperty(promise, "_error", {
        get: () => renderError
      });
    } else if (resolve._tracked) {
      promise = resolve;
      status = "_error" in promise ? AwaitRenderStatus.error : "_data" in promise ? AwaitRenderStatus.success : AwaitRenderStatus.pending;
    } else {
      status = AwaitRenderStatus.pending;
      Object.defineProperty(resolve, "_tracked", {
        get: () => true
      });
      promise = resolve.then((data) => Object.defineProperty(resolve, "_data", {
        get: () => data
      }), (error) => Object.defineProperty(resolve, "_error", {
        get: () => error
      }));
    }
    if (status === AwaitRenderStatus.error && promise._error instanceof AbortedDeferredError) {
      throw neverSettledPromise;
    }
    if (status === AwaitRenderStatus.error && !errorElement) {
      throw promise._error;
    }
    if (status === AwaitRenderStatus.error) {
      return /* @__PURE__ */ React$7.createElement(AwaitContext.Provider, {
        value: promise,
        children: errorElement
      });
    }
    if (status === AwaitRenderStatus.success) {
      return /* @__PURE__ */ React$7.createElement(AwaitContext.Provider, {
        value: promise,
        children
      });
    }
    throw promise;
  }
}
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  React$7.Children.forEach(children, (element, index2) => {
    if (!/* @__PURE__ */ React$7.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index2];
    if (element.type === React$7.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    !(element.type === Route) ? invariant$2(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant$2(false) : void 0;
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
/**
 * React Router DOM v6.28.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
const React$6 = await importShared("react");
const ReactDOM$2 = await importShared("react-dom");
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"], _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"];
const REACT_ROUTER_VERSION = "6";
try {
  window.__reactRouterVersion = REACT_ROUTER_VERSION;
} catch (e2) {
}
const ViewTransitionContext = /* @__PURE__ */ React$6.createContext({
  isTransitioning: false
});
const START_TRANSITION = "startTransition";
const startTransitionImpl = React$6[START_TRANSITION];
const FLUSH_SYNC = "flushSync";
ReactDOM$2[FLUSH_SYNC];
const USE_ID = "useId";
React$6[USE_ID];
function BrowserRouter(_ref4) {
  let {
    basename,
    children,
    future,
    window: window2
  } = _ref4;
  let historyRef = React$6.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history2 = historyRef.current;
  let [state, setStateImpl] = React$6.useState({
    action: history2.action,
    location: history2.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = React$6.useCallback((newState) => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  React$6.useLayoutEffect(() => history2.listen(setState), [history2, setState]);
  React$6.useEffect(() => logV6DeprecationWarnings(future), [future]);
  return /* @__PURE__ */ React$6.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history2,
    future
  });
}
const isBrowser$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const Link$2 = /* @__PURE__ */ React$6.forwardRef(function LinkWithRef(_ref7, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to,
    preventScrollReset,
    viewTransition
  } = _ref7, rest = _objectWithoutPropertiesLoose$1(_ref7, _excluded);
  let {
    basename
  } = React$6.useContext(NavigationContext$1);
  let absoluteHref;
  let isExternal = false;
  if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {
    absoluteHref = to;
    if (isBrowser$1) {
      try {
        let currentUrl = new URL(window.location.href);
        let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
        let path = stripBasename(targetUrl.pathname, basename);
        if (targetUrl.origin === currentUrl.origin && path != null) {
          to = path + targetUrl.search + targetUrl.hash;
        } else {
          isExternal = true;
        }
      } catch (e2) {
      }
    }
  }
  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace: replace2,
    state,
    target,
    preventScrollReset,
    relative,
    viewTransition
  });
  function handleClick2(event) {
    if (onClick) onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ React$6.createElement("a", _extends$1({}, rest, {
      href: absoluteHref || href,
      onClick: isExternal || reloadDocument ? onClick : handleClick2,
      ref,
      target
    }))
  );
});
const NavLink = /* @__PURE__ */ React$6.forwardRef(function NavLinkWithRef(_ref8, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end: end2 = false,
    style: styleProp,
    to,
    viewTransition,
    children
  } = _ref8, rest = _objectWithoutPropertiesLoose$1(_ref8, _excluded2);
  let path = useResolvedPath(to, {
    relative: rest.relative
  });
  let location = useLocation();
  let routerState = React$6.useContext(DataRouterStateContext);
  let {
    navigator: navigator2,
    basename
  } = React$6.useContext(NavigationContext$1);
  let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  useViewTransitionState(path) && viewTransition === true;
  let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }
  if (nextLocationPathname && basename) {
    nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
  }
  const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
  let isActive2 = locationPathname === toPathname || !end2 && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end2 && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let renderProps2 = {
    isActive: isActive2,
    isPending,
    isTransitioning
  };
  let ariaCurrent = isActive2 ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp(renderProps2);
  } else {
    className = [classNameProp, isActive2 ? "active" : null, isPending ? "pending" : null, isTransitioning ? "transitioning" : null].filter(Boolean).join(" ");
  }
  let style2 = typeof styleProp === "function" ? styleProp(renderProps2) : styleProp;
  return /* @__PURE__ */ React$6.createElement(Link$2, _extends$1({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style: style2,
    to,
    viewTransition
  }), typeof children === "function" ? children(renderProps2) : children);
});
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmit"] = "useSubmit";
  DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook2["UseFetcher"] = "useFetcher";
  DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetcher"] = "useFetcher";
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function useDataRouterContext(hookName) {
  let ctx = React$6.useContext(DataRouterContext);
  !ctx ? invariant$2(false) : void 0;
  return ctx;
}
function useLinkClickHandler(to, _temp11) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative,
    viewTransition
  } = _temp11 === void 0 ? {} : _temp11;
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, {
    relative
  });
  return React$6.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
      navigate(to, {
        replace: replace2,
        state,
        preventScrollReset,
        relative,
        viewTransition
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, viewTransition]);
}
function useViewTransitionState(to, opts) {
  if (opts === void 0) {
    opts = {};
  }
  let vtContext = React$6.useContext(ViewTransitionContext);
  !(vtContext != null) ? invariant$2(false) : void 0;
  let {
    basename
  } = useDataRouterContext(DataRouterHook.useViewTransitionState);
  let path = useResolvedPath(to, {
    relative: opts.relative
  });
  if (!vtContext.isTransitioning) {
    return false;
  }
  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
}
function r(e2) {
  var t2, f, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
  else if ("object" == typeof e2) if (Array.isArray(e2)) for (t2 = 0; t2 < e2.length; t2++) e2[t2] && (f = r(e2[t2])) && (n2 && (n2 += " "), n2 += f);
  else for (t2 in e2) e2[t2] && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
function clsx() {
  for (var e2, t2, f = 0, n2 = ""; f < arguments.length; ) (e2 = arguments[f++]) && (t2 = r(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
let e = { data: "" }, t = (t2) => "object" == typeof window ? ((t2 ? t2.querySelector("#_goober") : window._goober) || Object.assign((t2 || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : t2 || e, l = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, a = /\/\*[^]*?\*\/|  +/g, n = /\n+/g, o = (e2, t2) => {
  let r2 = "", l2 = "", a2 = "";
  for (let n2 in e2) {
    let c2 = e2[n2];
    "@" == n2[0] ? "i" == n2[1] ? r2 = n2 + " " + c2 + ";" : l2 += "f" == n2[1] ? o(c2, n2) : n2 + "{" + o(c2, "k" == n2[1] ? "" : t2) + "}" : "object" == typeof c2 ? l2 += o(c2, t2 ? t2.replace(/([^,])+/g, (e3) => n2.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (t3) => /&/.test(t3) ? t3.replace(/&/g, e3) : e3 ? e3 + " " + t3 : t3)) : n2) : null != c2 && (n2 = /^--/.test(n2) ? n2 : n2.replace(/[A-Z]/g, "-$&").toLowerCase(), a2 += o.p ? o.p(n2, c2) : n2 + ":" + c2 + ";");
  }
  return r2 + (t2 && a2 ? t2 + "{" + a2 + "}" : a2) + l2;
}, c = {}, s = (e2) => {
  if ("object" == typeof e2) {
    let t2 = "";
    for (let r2 in e2) t2 += r2 + s(e2[r2]);
    return t2;
  }
  return e2;
}, i$1 = (e2, t2, r2, i, p2) => {
  let u2 = s(e2), d = c[u2] || (c[u2] = ((e3) => {
    let t3 = 0, r3 = 11;
    for (; t3 < e3.length; ) r3 = 101 * r3 + e3.charCodeAt(t3++) >>> 0;
    return "go" + r3;
  })(u2));
  if (!c[d]) {
    let t3 = u2 !== e2 ? e2 : ((e3) => {
      let t4, r3, o2 = [{}];
      for (; t4 = l.exec(e3.replace(a, "")); ) t4[4] ? o2.shift() : t4[3] ? (r3 = t4[3].replace(n, " ").trim(), o2.unshift(o2[0][r3] = o2[0][r3] || {})) : o2[0][t4[1]] = t4[2].replace(n, " ").trim();
      return o2[0];
    })(e2);
    c[d] = o(p2 ? { ["@keyframes " + d]: t3 } : t3, r2 ? "" : "." + d);
  }
  let f = r2 && c.g ? c.g : null;
  return r2 && (c.g = c[d]), ((e3, t3, r3, l2) => {
    l2 ? t3.data = t3.data.replace(l2, e3) : -1 === t3.data.indexOf(e3) && (t3.data = r3 ? e3 + t3.data : t3.data + e3);
  })(c[d], t2, i, f), d;
}, p = (e2, t2, r2) => e2.reduce((e3, l2, a2) => {
  let n2 = t2[a2];
  if (n2 && n2.call) {
    let e4 = n2(r2), t3 = e4 && e4.props && e4.props.className || /^go/.test(e4) && e4;
    n2 = t3 ? "." + t3 : e4 && "object" == typeof e4 ? e4.props ? "" : o(e4, "") : false === e4 ? "" : e4;
  }
  return e3 + l2 + (null == n2 ? "" : n2);
}, "");
function u(e2) {
  let r2 = this || {}, l2 = e2.call ? e2(r2.p) : e2;
  return i$1(l2.unshift ? l2.raw ? p(l2, [].slice.call(arguments, 1), r2.p) : l2.reduce((e3, t2) => Object.assign(e3, t2 && t2.call ? t2(r2.p) : t2), {}) : l2, t(r2.target), r2.g, r2.o, r2.k);
}
u.bind({ g: 1 });
u.bind({ k: 1 });
const React__default$1 = await importShared("react");
const { useMemo: useMemo$5, forwardRef: forwardRef$3, useRef: useRef$7, useCallback: useCallback$2, useEffect: useEffect$7, createElement: createElement$2, cloneElement, useLayoutEffect: useLayoutEffect$3, memo, useState: useState$6, Component, isValidElement, useContext: useContext$3 } = React__default$1;
const { createPortal } = await importShared("react-dom");
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  return Constructor;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose$1(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var noOp$1 = function noOp2() {
  return "";
};
var SnackbarContext = /* @__PURE__ */ React__default$1.createContext({
  enqueueSnackbar: noOp$1,
  closeSnackbar: noOp$1
});
var breakpoints$1 = {
  downXs: "@media (max-width:599.95px)",
  upSm: "@media (min-width:600px)"
};
var capitalise = function capitalise2(text) {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
var originKeyExtractor = function originKeyExtractor2(anchor) {
  return "" + capitalise(anchor.vertical) + capitalise(anchor.horizontal);
};
var isDefined = function isDefined2(value) {
  return !!value || value === 0;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(Transition2, _React$Component);
  function Transition2(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    var appear = props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props["in"]) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else if (props.unmountOnExit || props.mountOnEnter) {
      initialStatus = UNMOUNTED;
    } else {
      initialStatus = EXITED;
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref["in"];
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props["in"]) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else if (status === ENTERING || status === ENTERED) {
        nextStatus = EXITING;
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var enter2 = timeout2;
    var exit = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number" && typeof timeout2 !== "string") {
      exit = timeout2.exit;
      enter2 = timeout2.enter;
    }
    return {
      exit,
      enter: enter2
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter2 = this.props.enter;
    var isAppearing = mounting;
    var timeouts = this.getTimeouts();
    if (!mounting && !enter2) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        if (_this2.props.onEntered) {
          _this2.props.onEntered(_this2.node, isAppearing);
        }
      });
      return;
    }
    if (this.props.onEnter) {
      this.props.onEnter(this.node, isAppearing);
    }
    this.safeSetState({
      status: ENTERING
    }, function() {
      if (_this2.props.onEntering) {
        _this2.props.onEntering(_this2.node, isAppearing);
      }
      _this2.onTransitionEnd(timeouts.enter, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          if (_this2.props.onEntered) {
            _this2.props.onEntered(_this2.node, isAppearing);
          }
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    if (!exit) {
      this.safeSetState({
        status: EXITED
      }, function() {
        if (_this3.props.onExited) {
          _this3.props.onExited(_this3.node);
        }
      });
      return;
    }
    if (this.props.onExit) {
      this.props.onExit(this.node);
    }
    this.safeSetState({
      status: EXITING
    }, function() {
      if (_this3.props.onExiting) {
        _this3.props.onExiting(_this3.node);
      }
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          if (_this3.props.onExited) {
            _this3.props.onExited(_this3.node);
          }
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null && this.nextCallback.cancel) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function() {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback();
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!this.node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      this.props.addEndListener(this.node, this.nextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render2() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children, childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return children(status, childProps);
  };
  _createClass(Transition2, [{
    key: "node",
    get: function get3() {
      var _this$props$nodeRef;
      var node = (_this$props$nodeRef = this.props.nodeRef) === null || _this$props$nodeRef === void 0 ? void 0 : _this$props$nodeRef.current;
      if (!node) {
        throw new Error("notistack - Custom snackbar is not refForwarding");
      }
      return node;
    }
  }]);
  return Transition2;
}(React__default$1.Component);
function noop$4() {
}
Transition.defaultProps = {
  "in": false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$4,
  onEntering: noop$4,
  onEntered: noop$4,
  onExit: noop$4,
  onExiting: noop$4,
  onExited: noop$4
};
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
function useForkRef(refA, refB) {
  return useMemo$5(function() {
    if (refA == null && refB == null) {
      return null;
    }
    return function(refValue) {
      setRef(refA, refValue);
      setRef(refB, refValue);
    };
  }, [refA, refB]);
}
function getTransitionProps(props) {
  var timeout2 = props.timeout, _props$style = props.style, style2 = _props$style === void 0 ? {} : _props$style, mode = props.mode;
  return {
    duration: typeof timeout2 === "object" ? timeout2[mode] || 0 : timeout2,
    easing: style2.transitionTimingFunction,
    delay: style2.transitionDelay
  };
}
var defaultEasing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
var reflow = function reflow2(node) {
  node.scrollTop = node.scrollTop;
};
var formatMs = function formatMs2(milliseconds) {
  return Math.round(milliseconds) + "ms";
};
function createTransition(props, options) {
  if (props === void 0) {
    props = ["all"];
  }
  var _ref = options || {}, _ref$duration = _ref.duration, duration = _ref$duration === void 0 ? 300 : _ref$duration, _ref$easing = _ref.easing, easing = _ref$easing === void 0 ? defaultEasing.easeInOut : _ref$easing, _ref$delay = _ref.delay, delay = _ref$delay === void 0 ? 0 : _ref$delay;
  var properties = Array.isArray(props) ? props : [props];
  return properties.map(function(animatedProp) {
    var formattedDuration = typeof duration === "string" ? duration : formatMs(duration);
    var formattedDelay = typeof delay === "string" ? delay : formatMs(delay);
    return animatedProp + " " + formattedDuration + " " + easing + " " + formattedDelay;
  }).join(",");
}
function ownerDocument(node) {
  return node && node.ownerDocument || document;
}
function ownerWindow(node) {
  var doc2 = ownerDocument(node);
  return doc2.defaultView || window;
}
function debounce$4(func, wait) {
  if (wait === void 0) {
    wait = 166;
  }
  var timeout2;
  function debounced() {
    var _this = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var later = function later2() {
      func.apply(_this, args);
    };
    clearTimeout(timeout2);
    timeout2 = setTimeout(later, wait);
  }
  debounced.clear = function() {
    clearTimeout(timeout2);
  };
  return debounced;
}
function getTranslateValue(direction2, node) {
  var rect = node.getBoundingClientRect();
  var containerWindow = ownerWindow(node);
  var transform;
  if (node.fakeTransform) {
    transform = node.fakeTransform;
  } else {
    var computedStyle = containerWindow.getComputedStyle(node);
    transform = computedStyle.getPropertyValue("-webkit-transform") || computedStyle.getPropertyValue("transform");
  }
  var offsetX = 0;
  var offsetY = 0;
  if (transform && transform !== "none" && typeof transform === "string") {
    var transformValues = transform.split("(")[1].split(")")[0].split(",");
    offsetX = parseInt(transformValues[4], 10);
    offsetY = parseInt(transformValues[5], 10);
  }
  switch (direction2) {
    case "left":
      return "translateX(" + (containerWindow.innerWidth + offsetX - rect.left) + "px)";
    case "right":
      return "translateX(-" + (rect.left + rect.width - offsetX) + "px)";
    case "up":
      return "translateY(" + (containerWindow.innerHeight + offsetY - rect.top) + "px)";
    default:
      return "translateY(-" + (rect.top + rect.height - offsetY) + "px)";
  }
}
function setTranslateValue(direction2, node) {
  if (!node) return;
  var transform = getTranslateValue(direction2, node);
  if (transform) {
    node.style.webkitTransform = transform;
    node.style.transform = transform;
  }
}
var Slide = /* @__PURE__ */ forwardRef$3(function(props, ref) {
  var children = props.children, _props$direction = props.direction, direction2 = _props$direction === void 0 ? "down" : _props$direction, inProp = props["in"], style2 = props.style, _props$timeout = props.timeout, timeout2 = _props$timeout === void 0 ? 0 : _props$timeout, onEnter = props.onEnter, onEntered = props.onEntered, onExit = props.onExit, onExited = props.onExited, other = _objectWithoutPropertiesLoose(props, ["children", "direction", "in", "style", "timeout", "onEnter", "onEntered", "onExit", "onExited"]);
  var nodeRef = useRef$7(null);
  var handleRefIntermediary = useForkRef(children.ref, nodeRef);
  var handleRef = useForkRef(handleRefIntermediary, ref);
  var handleEnter = function handleEnter2(node, isAppearing) {
    setTranslateValue(direction2, node);
    reflow(node);
    if (onEnter) {
      onEnter(node, isAppearing);
    }
  };
  var handleEntering = function handleEntering2(node) {
    var easing = (style2 === null || style2 === void 0 ? void 0 : style2.transitionTimingFunction) || defaultEasing.easeOut;
    var transitionProps = getTransitionProps({
      timeout: timeout2,
      mode: "enter",
      style: _extends({}, style2, {
        transitionTimingFunction: easing
      })
    });
    node.style.webkitTransition = createTransition("-webkit-transform", transitionProps);
    node.style.transition = createTransition("transform", transitionProps);
    node.style.webkitTransform = "none";
    node.style.transform = "none";
  };
  var handleExit = function handleExit2(node) {
    var easing = (style2 === null || style2 === void 0 ? void 0 : style2.transitionTimingFunction) || defaultEasing.sharp;
    var transitionProps = getTransitionProps({
      timeout: timeout2,
      mode: "exit",
      style: _extends({}, style2, {
        transitionTimingFunction: easing
      })
    });
    node.style.webkitTransition = createTransition("-webkit-transform", transitionProps);
    node.style.transition = createTransition("transform", transitionProps);
    setTranslateValue(direction2, node);
    if (onExit) {
      onExit(node);
    }
  };
  var handleExited = function handleExited2(node) {
    node.style.webkitTransition = "";
    node.style.transition = "";
    if (onExited) {
      onExited(node);
    }
  };
  var updatePosition = useCallback$2(function() {
    if (nodeRef.current) {
      setTranslateValue(direction2, nodeRef.current);
    }
  }, [direction2]);
  useEffect$7(function() {
    if (inProp || direction2 === "down" || direction2 === "right") {
      return void 0;
    }
    var handleResize = debounce$4(function() {
      if (nodeRef.current) {
        setTranslateValue(direction2, nodeRef.current);
      }
    });
    var containerWindow = ownerWindow(nodeRef.current);
    containerWindow.addEventListener("resize", handleResize);
    return function() {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [direction2, inProp]);
  useEffect$7(function() {
    if (!inProp) {
      updatePosition();
    }
  }, [inProp, updatePosition]);
  return createElement$2(Transition, Object.assign({
    appear: true,
    nodeRef,
    onEnter: handleEnter,
    onEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    "in": inProp,
    timeout: timeout2
  }, other), function(state, childProps) {
    return cloneElement(children, _extends({
      ref: handleRef,
      style: _extends({
        visibility: state === "exited" && !inProp ? "hidden" : void 0
      }, style2, {}, children.props.style)
    }, childProps));
  });
});
Slide.displayName = "Slide";
var SvgIcon = function SvgIcon2(props) {
  return React__default$1.createElement("svg", Object.assign({
    viewBox: "0 0 24 24",
    focusable: "false",
    style: {
      fontSize: 20,
      marginInlineEnd: 8,
      userSelect: "none",
      width: "1em",
      height: "1em",
      display: "inline-block",
      fill: "currentColor",
      flexShrink: 0
    }
  }, props));
};
var CheckIcon$1 = function CheckIcon2() {
  return React__default$1.createElement(SvgIcon, null, React__default$1.createElement("path", {
    d: "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41\n        10.59L10 14.17L17.59 6.58L19 8L10 17Z"
  }));
};
var WarningIcon = function WarningIcon2() {
  return React__default$1.createElement(SvgIcon, null, React__default$1.createElement("path", {
    d: "M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z"
  }));
};
var ErrorIcon$1 = function ErrorIcon2() {
  return React__default$1.createElement(SvgIcon, null, React__default$1.createElement("path", {
    d: "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,\n        6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,\n        13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z"
  }));
};
var InfoIcon$1 = function InfoIcon2() {
  return React__default$1.createElement(SvgIcon, null, React__default$1.createElement("path", {
    d: "M13,9H11V7H13M13,17H11V11H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,\n        0 22,12A10,10 0 0,0 12,2Z"
  }));
};
var defaultIconVariants = {
  "default": void 0,
  success: /* @__PURE__ */ React__default$1.createElement(CheckIcon$1, null),
  warning: /* @__PURE__ */ React__default$1.createElement(WarningIcon, null),
  error: /* @__PURE__ */ React__default$1.createElement(ErrorIcon$1, null),
  info: /* @__PURE__ */ React__default$1.createElement(InfoIcon$1, null)
};
var defaults$2 = {
  maxSnack: 3,
  persist: false,
  hideIconVariant: false,
  disableWindowBlurListener: false,
  variant: "default",
  autoHideDuration: 5e3,
  iconVariant: defaultIconVariants,
  anchorOrigin: {
    vertical: "bottom",
    horizontal: "left"
  },
  TransitionComponent: Slide,
  transitionDuration: {
    enter: 225,
    exit: 195
  }
};
var getAutoHideDuration = function getAutoHideDuration2(optionsDuration, propsDuration) {
  var isNumberOrNull = function isNumberOrNull2(numberish) {
    return typeof numberish === "number" || numberish === null;
  };
  if (isNumberOrNull(optionsDuration)) return optionsDuration;
  if (isNumberOrNull(propsDuration)) return propsDuration;
  return defaults$2.autoHideDuration;
};
var getTransitionDuration = function getTransitionDuration2(optionsDuration, propsDuration) {
  var is2 = function is22(item, types) {
    return types.some(function(t2) {
      return typeof item === t2;
    });
  };
  if (is2(optionsDuration, ["string", "number"])) {
    return optionsDuration;
  }
  if (is2(optionsDuration, ["object"])) {
    return _extends({}, defaults$2.transitionDuration, {}, is2(propsDuration, ["object"]) && propsDuration, {}, optionsDuration);
  }
  if (is2(propsDuration, ["string", "number"])) {
    return propsDuration;
  }
  if (is2(propsDuration, ["object"])) {
    return _extends({}, defaults$2.transitionDuration, {}, propsDuration);
  }
  return defaults$2.transitionDuration;
};
var merge = function merge2(options, props) {
  return function(name, shouldObjectMerge) {
    if (shouldObjectMerge === void 0) {
      shouldObjectMerge = false;
    }
    if (shouldObjectMerge) {
      return _extends({}, defaults$2[name], {}, props[name], {}, options[name]);
    }
    if (name === "autoHideDuration") {
      return getAutoHideDuration(options.autoHideDuration, props.autoHideDuration);
    }
    if (name === "transitionDuration") {
      return getTransitionDuration(options.transitionDuration, props.transitionDuration);
    }
    return options[name] || props[name] || defaults$2[name];
  };
};
function makeStyles(styles2) {
  return Object.entries(styles2).reduce(function(acc, _ref) {
    var _extends2;
    var key = _ref[0], value = _ref[1];
    return _extends({}, acc, (_extends2 = {}, _extends2[key] = u(value), _extends2));
  }, {});
}
var ComponentClasses = {
  SnackbarContainer: "notistack-SnackbarContainer",
  Snackbar: "notistack-Snackbar",
  CollapseWrapper: "notistack-CollapseWrapper",
  MuiContent: "notistack-MuiContent",
  MuiContentVariant: function MuiContentVariant(variant) {
    return "notistack-MuiContent-" + variant;
  }
};
var classes = /* @__PURE__ */ makeStyles({
  root: {
    height: 0
  },
  entered: {
    height: "auto"
  }
});
var collapsedSize = "0px";
var timeout = 175;
var Collapse$1 = /* @__PURE__ */ forwardRef$3(function(props, ref) {
  var children = props.children, inProp = props["in"], onExited = props.onExited;
  var wrapperRef = useRef$7(null);
  var nodeRef = useRef$7(null);
  var handleRef = useForkRef(ref, nodeRef);
  var getWrapperSize = function getWrapperSize2() {
    return wrapperRef.current ? wrapperRef.current.clientHeight : 0;
  };
  var handleEnter = function handleEnter2(node) {
    node.style.height = collapsedSize;
  };
  var handleEntering = function handleEntering2(node) {
    var wrapperSize = getWrapperSize();
    var _getTransitionProps = getTransitionProps({
      timeout,
      mode: "enter"
    }), transitionDuration = _getTransitionProps.duration, easing = _getTransitionProps.easing;
    node.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : transitionDuration + "ms";
    node.style.height = wrapperSize + "px";
    node.style.transitionTimingFunction = easing || "";
  };
  var handleEntered = function handleEntered2(node) {
    node.style.height = "auto";
  };
  var handleExit = function handleExit2(node) {
    node.style.height = getWrapperSize() + "px";
  };
  var handleExiting = function handleExiting2(node) {
    reflow(node);
    var _getTransitionProps2 = getTransitionProps({
      timeout,
      mode: "exit"
    }), transitionDuration = _getTransitionProps2.duration, easing = _getTransitionProps2.easing;
    node.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : transitionDuration + "ms";
    node.style.height = collapsedSize;
    node.style.transitionTimingFunction = easing || "";
  };
  return createElement$2(Transition, {
    "in": inProp,
    unmountOnExit: true,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited,
    onExiting: handleExiting,
    nodeRef,
    timeout
  }, function(state, childProps) {
    return createElement$2("div", Object.assign({
      ref: handleRef,
      className: clsx(classes.root, state === "entered" && classes.entered),
      style: _extends({
        pointerEvents: "all",
        overflow: "hidden",
        minHeight: collapsedSize,
        transition: createTransition("height")
      }, state === "entered" && {
        overflow: "visible"
      }, {}, state === "exited" && !inProp && {
        visibility: "hidden"
      })
    }, childProps), createElement$2("div", {
      ref: wrapperRef,
      className: ComponentClasses.CollapseWrapper,
      // Hack to get children with a negative margin to not falsify the height computation.
      style: {
        display: "flex",
        width: "100%"
      }
    }, children));
  });
});
Collapse$1.displayName = "Collapse";
var direction = {
  right: "left",
  left: "right",
  bottom: "up",
  top: "down"
};
var getSlideDirection = function getSlideDirection2(anchorOrigin) {
  if (anchorOrigin.horizontal !== "center") {
    return direction[anchorOrigin.horizontal];
  }
  return direction[anchorOrigin.vertical];
};
var toSnackbarAnchorOrigin = function toSnackbarAnchorOrigin2(anchorOrigin) {
  return "anchorOrigin" + originKeyExtractor(anchorOrigin);
};
var keepSnackbarClassKeys = function keepSnackbarClassKeys2(classes2) {
  if (classes2 === void 0) {
    classes2 = {};
  }
  var containerClasses = {
    containerRoot: true,
    containerAnchorOriginTopCenter: true,
    containerAnchorOriginBottomCenter: true,
    containerAnchorOriginTopRight: true,
    containerAnchorOriginBottomRight: true,
    containerAnchorOriginTopLeft: true,
    containerAnchorOriginBottomLeft: true
  };
  return Object.keys(classes2).filter(function(key) {
    return !containerClasses[key];
  }).reduce(function(obj, key) {
    var _extends2;
    return _extends({}, obj, (_extends2 = {}, _extends2[key] = classes2[key], _extends2));
  }, {});
};
var noOp$1$1 = function noOp3() {
};
function createChainedFunction(funcs, snackbarId) {
  return funcs.reduce(function(acc, func) {
    if (func === null || func === void 0) {
      return acc;
    }
    return function chainedFunction() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var argums = [].concat(args);
      if (snackbarId && argums.indexOf(snackbarId) === -1) {
        argums.push(snackbarId);
      }
      acc.apply(this, argums);
      func.apply(this, argums);
    };
  }, noOp$1$1);
}
var useEnhancedEffect = typeof window !== "undefined" ? useLayoutEffect$3 : useEffect$7;
function useEventCallback(fn2) {
  var ref = useRef$7(fn2);
  useEnhancedEffect(function() {
    ref.current = fn2;
  });
  return useCallback$2(function() {
    return (
      // @ts-expect-error hide `this`
      ref.current.apply(void 0, arguments)
    );
  }, []);
}
var Snackbar = /* @__PURE__ */ forwardRef$3(function(props, ref) {
  var children = props.children, className = props.className, autoHideDuration = props.autoHideDuration, _props$disableWindowB = props.disableWindowBlurListener, disableWindowBlurListener = _props$disableWindowB === void 0 ? false : _props$disableWindowB, onClose = props.onClose, id2 = props.id, open = props.open, _props$SnackbarProps = props.SnackbarProps, SnackbarProps = _props$SnackbarProps === void 0 ? {} : _props$SnackbarProps;
  var timerAutoHide = useRef$7();
  var handleClose = useEventCallback(function() {
    if (onClose) {
      onClose.apply(void 0, arguments);
    }
  });
  var setAutoHideTimer = useEventCallback(function(autoHideDurationParam) {
    if (!onClose || autoHideDurationParam == null) {
      return;
    }
    if (timerAutoHide.current) {
      clearTimeout(timerAutoHide.current);
    }
    timerAutoHide.current = setTimeout(function() {
      handleClose(null, "timeout", id2);
    }, autoHideDurationParam);
  });
  useEffect$7(function() {
    if (open) {
      setAutoHideTimer(autoHideDuration);
    }
    return function() {
      if (timerAutoHide.current) {
        clearTimeout(timerAutoHide.current);
      }
    };
  }, [open, autoHideDuration, setAutoHideTimer]);
  var handlePause = function handlePause2() {
    if (timerAutoHide.current) {
      clearTimeout(timerAutoHide.current);
    }
  };
  var handleResume = useCallback$2(function() {
    if (autoHideDuration != null) {
      setAutoHideTimer(autoHideDuration * 0.5);
    }
  }, [autoHideDuration, setAutoHideTimer]);
  var handleMouseEnter = function handleMouseEnter2(event) {
    if (SnackbarProps.onMouseEnter) {
      SnackbarProps.onMouseEnter(event);
    }
    handlePause();
  };
  var handleMouseLeave = function handleMouseLeave2(event) {
    if (SnackbarProps.onMouseLeave) {
      SnackbarProps.onMouseLeave(event);
    }
    handleResume();
  };
  useEffect$7(function() {
    if (!disableWindowBlurListener && open) {
      window.addEventListener("focus", handleResume);
      window.addEventListener("blur", handlePause);
      return function() {
        window.removeEventListener("focus", handleResume);
        window.removeEventListener("blur", handlePause);
      };
    }
    return void 0;
  }, [disableWindowBlurListener, handleResume, open]);
  return createElement$2("div", Object.assign({
    ref
  }, SnackbarProps, {
    className: clsx(ComponentClasses.Snackbar, className),
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave
  }), children);
});
Snackbar.displayName = "Snackbar";
var _root;
var classes$1 = /* @__PURE__ */ makeStyles({
  root: (_root = {
    display: "flex",
    flexWrap: "wrap",
    flexGrow: 1
  }, _root[breakpoints$1.upSm] = {
    flexGrow: "initial",
    minWidth: "288px"
  }, _root)
});
var SnackbarContent = /* @__PURE__ */ forwardRef$3(function(_ref, ref) {
  var className = _ref.className, props = _objectWithoutPropertiesLoose(_ref, ["className"]);
  return React__default$1.createElement("div", Object.assign({
    ref,
    className: clsx(classes$1.root, className)
  }, props));
});
SnackbarContent.displayName = "SnackbarContent";
var classes$2 = /* @__PURE__ */ makeStyles({
  root: {
    backgroundColor: "#313131",
    fontSize: "0.875rem",
    lineHeight: 1.43,
    letterSpacing: "0.01071em",
    color: "#fff",
    alignItems: "center",
    padding: "6px 16px",
    borderRadius: "4px",
    boxShadow: "0px 3px 5px -1px rgba(0,0,0,0.2),0px 6px 10px 0px rgba(0,0,0,0.14),0px 1px 18px 0px rgba(0,0,0,0.12)"
  },
  lessPadding: {
    paddingLeft: 8 * 2.5 + "px"
  },
  "default": {
    backgroundColor: "#313131"
  },
  success: {
    backgroundColor: "#43a047"
  },
  error: {
    backgroundColor: "#d32f2f"
  },
  warning: {
    backgroundColor: "#ff9800"
  },
  info: {
    backgroundColor: "#2196f3"
  },
  message: {
    display: "flex",
    alignItems: "center",
    padding: "8px 0"
  },
  action: {
    display: "flex",
    alignItems: "center",
    marginLeft: "auto",
    paddingLeft: "16px",
    marginRight: "-8px"
  }
});
var ariaDescribedby = "notistack-snackbar";
var MaterialDesignContent = /* @__PURE__ */ forwardRef$3(function(props, forwardedRef) {
  var id2 = props.id, message2 = props.message, componentOrFunctionAction = props.action, iconVariant = props.iconVariant, variant = props.variant, hideIconVariant = props.hideIconVariant, style2 = props.style, className = props.className;
  var icon = iconVariant[variant];
  var action = componentOrFunctionAction;
  if (typeof action === "function") {
    action = action(id2);
  }
  return React__default$1.createElement(SnackbarContent, {
    ref: forwardedRef,
    role: "alert",
    "aria-describedby": ariaDescribedby,
    style: style2,
    className: clsx(ComponentClasses.MuiContent, ComponentClasses.MuiContentVariant(variant), classes$2.root, classes$2[variant], className, !hideIconVariant && icon && classes$2.lessPadding)
  }, React__default$1.createElement("div", {
    id: ariaDescribedby,
    className: classes$2.message
  }, !hideIconVariant ? icon : null, message2), action && React__default$1.createElement("div", {
    className: classes$2.action
  }, action));
});
MaterialDesignContent.displayName = "MaterialDesignContent";
var MaterialDesignContent$1 = /* @__PURE__ */ memo(MaterialDesignContent);
var styles = /* @__PURE__ */ makeStyles({
  wrappedRoot: {
    width: "100%",
    position: "relative",
    transform: "translateX(0)",
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    minWidth: "288px"
  }
});
var SnackbarItem = function SnackbarItem2(props) {
  var timeout2 = useRef$7();
  var _useState = useState$6(true), collapsed = _useState[0], setCollapsed = _useState[1];
  var handleClose = createChainedFunction([props.snack.onClose, props.onClose]);
  var handleEntered = function handleEntered2() {
    if (props.snack.requestClose) {
      handleClose(null, "instructed", props.snack.id);
    }
  };
  var handleExitedScreen = useCallback$2(function() {
    timeout2.current = setTimeout(function() {
      setCollapsed(function(col) {
        return !col;
      });
    }, 125);
  }, []);
  useEffect$7(function() {
    return function() {
      if (timeout2.current) {
        clearTimeout(timeout2.current);
      }
    };
  }, []);
  var snack = props.snack, allClasses = props.classes, _props$Component = props.Component, Component2 = _props$Component === void 0 ? MaterialDesignContent$1 : _props$Component;
  var classes2 = useMemo$5(function() {
    return keepSnackbarClassKeys(allClasses);
  }, [allClasses]);
  var open = snack.open, SnackbarProps = snack.SnackbarProps, TransitionComponent = snack.TransitionComponent, TransitionProps = snack.TransitionProps, transitionDuration = snack.transitionDuration, disableWindowBlurListener = snack.disableWindowBlurListener, componentOrFunctionContent = snack.content, otherSnack = _objectWithoutPropertiesLoose(snack, ["open", "SnackbarProps", "TransitionComponent", "TransitionProps", "transitionDuration", "disableWindowBlurListener", "content", "entered", "requestClose", "onEnter", "onEntered", "onExit", "onExited"]);
  var transitionProps = _extends({
    direction: getSlideDirection(otherSnack.anchorOrigin),
    timeout: transitionDuration
  }, TransitionProps);
  var content = componentOrFunctionContent;
  if (typeof content === "function") {
    content = content(otherSnack.id, otherSnack.message);
  }
  var callbacks = ["onEnter", "onEntered", "onExit", "onExited"].reduce(function(acc, cbName) {
    var _extends2;
    return _extends({}, acc, (_extends2 = {}, _extends2[cbName] = createChainedFunction([props.snack[cbName], props[cbName]], otherSnack.id), _extends2));
  }, {});
  return React__default$1.createElement(Collapse$1, {
    "in": collapsed,
    onExited: callbacks.onExited
  }, React__default$1.createElement(Snackbar, {
    open,
    id: otherSnack.id,
    disableWindowBlurListener,
    autoHideDuration: otherSnack.autoHideDuration,
    className: clsx(styles.wrappedRoot, classes2.root, classes2[toSnackbarAnchorOrigin(otherSnack.anchorOrigin)]),
    SnackbarProps,
    onClose: handleClose
  }, React__default$1.createElement(TransitionComponent, Object.assign({}, transitionProps, {
    appear: true,
    "in": open,
    onExit: callbacks.onExit,
    onExited: handleExitedScreen,
    onEnter: callbacks.onEnter,
    // order matters. first callbacks.onEntered to set entered: true,
    // then handleEntered to check if there's a request for closing
    onEntered: createChainedFunction([callbacks.onEntered, handleEntered], otherSnack.id)
  }), content || React__default$1.createElement(Component2, Object.assign({}, otherSnack)))));
};
var _root$1, _rootDense, _left, _right, _center;
var indents = {
  view: {
    "default": 20,
    dense: 4
  },
  snackbar: {
    "default": 6,
    dense: 2
  }
};
var collapseWrapper = "." + ComponentClasses.CollapseWrapper;
var xsWidthMargin = 16;
var styles$1 = /* @__PURE__ */ makeStyles({
  root: (_root$1 = {
    boxSizing: "border-box",
    display: "flex",
    maxHeight: "100%",
    position: "fixed",
    zIndex: 1400,
    height: "auto",
    width: "auto",
    transition: /* @__PURE__ */ createTransition(["top", "right", "bottom", "left", "max-width"], {
      duration: 300,
      easing: "ease"
    }),
    // container itself is invisible and should not block clicks, clicks should be passed to its children
    // a pointerEvents: all is applied in the collapse component
    pointerEvents: "none"
  }, _root$1[collapseWrapper] = {
    padding: indents.snackbar["default"] + "px 0px",
    transition: "padding 300ms ease 0ms"
  }, _root$1.maxWidth = "calc(100% - " + indents.view["default"] * 2 + "px)", _root$1[breakpoints$1.downXs] = {
    width: "100%",
    maxWidth: "calc(100% - " + xsWidthMargin * 2 + "px)"
  }, _root$1),
  rootDense: (_rootDense = {}, _rootDense[collapseWrapper] = {
    padding: indents.snackbar.dense + "px 0px"
  }, _rootDense),
  top: {
    top: indents.view["default"] - indents.snackbar["default"] + "px",
    flexDirection: "column"
  },
  bottom: {
    bottom: indents.view["default"] - indents.snackbar["default"] + "px",
    flexDirection: "column-reverse"
  },
  left: (_left = {
    left: indents.view["default"] + "px"
  }, _left[breakpoints$1.upSm] = {
    alignItems: "flex-start"
  }, _left[breakpoints$1.downXs] = {
    left: xsWidthMargin + "px"
  }, _left),
  right: (_right = {
    right: indents.view["default"] + "px"
  }, _right[breakpoints$1.upSm] = {
    alignItems: "flex-end"
  }, _right[breakpoints$1.downXs] = {
    right: xsWidthMargin + "px"
  }, _right),
  center: (_center = {
    left: "50%",
    transform: "translateX(-50%)"
  }, _center[breakpoints$1.upSm] = {
    alignItems: "center"
  }, _center)
});
var SnackbarContainer = function SnackbarContainer2(props) {
  var _props$classes = props.classes, classes2 = _props$classes === void 0 ? {} : _props$classes, anchorOrigin = props.anchorOrigin, dense = props.dense, children = props.children;
  var combinedClassname = clsx(
    ComponentClasses.SnackbarContainer,
    styles$1[anchorOrigin.vertical],
    styles$1[anchorOrigin.horizontal],
    styles$1.root,
    // root should come after others to override maxWidth
    classes2.containerRoot,
    classes2["containerAnchorOrigin" + originKeyExtractor(anchorOrigin)],
    dense && styles$1.rootDense
  );
  return React__default$1.createElement("div", {
    className: combinedClassname
  }, children);
};
var SnackbarContainer$1 = /* @__PURE__ */ memo(SnackbarContainer);
var isOptions = function isOptions2(messageOrOptions) {
  var isMessage = typeof messageOrOptions === "string" || isValidElement(messageOrOptions);
  return !isMessage;
};
var SnackbarProvider$1 = /* @__PURE__ */ function(_Component) {
  _inheritsLoose$1(SnackbarProvider2, _Component);
  function SnackbarProvider2(props) {
    var _this;
    _this = _Component.call(this, props) || this;
    _this.enqueueSnackbar = function(messageOrOptions, optsOrUndefined) {
      if (optsOrUndefined === void 0) {
        optsOrUndefined = {};
      }
      if (messageOrOptions === void 0 || messageOrOptions === null) {
        throw new Error("enqueueSnackbar called with invalid argument");
      }
      var opts = isOptions(messageOrOptions) ? messageOrOptions : optsOrUndefined;
      var message2 = isOptions(messageOrOptions) ? messageOrOptions.message : messageOrOptions;
      var key = opts.key, preventDuplicate = opts.preventDuplicate, options = _objectWithoutPropertiesLoose(opts, ["key", "preventDuplicate"]);
      var hasSpecifiedKey = isDefined(key);
      var id2 = hasSpecifiedKey ? key : (/* @__PURE__ */ new Date()).getTime() + Math.random();
      var merger = merge(options, _this.props);
      var snack = _extends({
        id: id2
      }, options, {
        message: message2,
        open: true,
        entered: false,
        requestClose: false,
        persist: merger("persist"),
        action: merger("action"),
        content: merger("content"),
        variant: merger("variant"),
        anchorOrigin: merger("anchorOrigin"),
        disableWindowBlurListener: merger("disableWindowBlurListener"),
        autoHideDuration: merger("autoHideDuration"),
        hideIconVariant: merger("hideIconVariant"),
        TransitionComponent: merger("TransitionComponent"),
        transitionDuration: merger("transitionDuration"),
        TransitionProps: merger("TransitionProps", true),
        iconVariant: merger("iconVariant", true),
        style: merger("style", true),
        SnackbarProps: merger("SnackbarProps", true),
        className: clsx(_this.props.className, options.className)
      });
      if (snack.persist) {
        snack.autoHideDuration = void 0;
      }
      _this.setState(function(state) {
        if (preventDuplicate === void 0 && _this.props.preventDuplicate || preventDuplicate) {
          var compareFunction = function compareFunction2(item) {
            return hasSpecifiedKey ? item.id === id2 : item.message === message2;
          };
          var inQueue = state.queue.findIndex(compareFunction) > -1;
          var inView = state.snacks.findIndex(compareFunction) > -1;
          if (inQueue || inView) {
            return state;
          }
        }
        return _this.handleDisplaySnack(_extends({}, state, {
          queue: [].concat(state.queue, [snack])
        }));
      });
      return id2;
    };
    _this.handleDisplaySnack = function(state) {
      var snacks = state.snacks;
      if (snacks.length >= _this.maxSnack) {
        return _this.handleDismissOldest(state);
      }
      return _this.processQueue(state);
    };
    _this.processQueue = function(state) {
      var queue = state.queue, snacks = state.snacks;
      if (queue.length > 0) {
        return _extends({}, state, {
          snacks: [].concat(snacks, [queue[0]]),
          queue: queue.slice(1, queue.length)
        });
      }
      return state;
    };
    _this.handleDismissOldest = function(state) {
      if (state.snacks.some(function(item) {
        return !item.open || item.requestClose;
      })) {
        return state;
      }
      var popped = false;
      var ignore = false;
      var persistentCount = state.snacks.reduce(function(acc, current) {
        return acc + (current.open && current.persist ? 1 : 0);
      }, 0);
      if (persistentCount === _this.maxSnack) {
        ignore = true;
      }
      var snacks = state.snacks.map(function(item) {
        if (!popped && (!item.persist || ignore)) {
          popped = true;
          if (!item.entered) {
            return _extends({}, item, {
              requestClose: true
            });
          }
          if (item.onClose) {
            item.onClose(null, "maxsnack", item.id);
          }
          if (_this.props.onClose) {
            _this.props.onClose(null, "maxsnack", item.id);
          }
          return _extends({}, item, {
            open: false
          });
        }
        return _extends({}, item);
      });
      return _extends({}, state, {
        snacks
      });
    };
    _this.handleEnteredSnack = function(node, isAppearing, key) {
      if (!isDefined(key)) {
        throw new Error("handleEnteredSnack Cannot be called with undefined key");
      }
      _this.setState(function(_ref) {
        var snacks = _ref.snacks;
        return {
          snacks: snacks.map(function(item) {
            return item.id === key ? _extends({}, item, {
              entered: true
            }) : _extends({}, item);
          })
        };
      });
    };
    _this.handleCloseSnack = function(event, reason, key) {
      if (_this.props.onClose) {
        _this.props.onClose(event, reason, key);
      }
      var shouldCloseAll = key === void 0;
      _this.setState(function(_ref2) {
        var snacks = _ref2.snacks, queue = _ref2.queue;
        return {
          snacks: snacks.map(function(item) {
            if (!shouldCloseAll && item.id !== key) {
              return _extends({}, item);
            }
            return item.entered ? _extends({}, item, {
              open: false
            }) : _extends({}, item, {
              requestClose: true
            });
          }),
          queue: queue.filter(function(item) {
            return item.id !== key;
          })
        };
      });
    };
    _this.closeSnackbar = function(key) {
      var toBeClosed = _this.state.snacks.find(function(item) {
        return item.id === key;
      });
      if (isDefined(key) && toBeClosed && toBeClosed.onClose) {
        toBeClosed.onClose(null, "instructed", key);
      }
      _this.handleCloseSnack(null, "instructed", key);
    };
    _this.handleExitedSnack = function(node, key) {
      if (!isDefined(key)) {
        throw new Error("handleExitedSnack Cannot be called with undefined key");
      }
      _this.setState(function(state) {
        var newState = _this.processQueue(_extends({}, state, {
          snacks: state.snacks.filter(function(item) {
            return item.id !== key;
          })
        }));
        if (newState.queue.length === 0) {
          return newState;
        }
        return _this.handleDismissOldest(newState);
      });
    };
    _this.enqueueSnackbar;
    _this.closeSnackbar;
    _this.state = {
      snacks: [],
      queue: [],
      contextValue: {
        enqueueSnackbar: _this.enqueueSnackbar.bind(_assertThisInitialized$1(_this)),
        closeSnackbar: _this.closeSnackbar.bind(_assertThisInitialized$1(_this))
      }
    };
    return _this;
  }
  var _proto = SnackbarProvider2.prototype;
  _proto.render = function render2() {
    var _this2 = this;
    var contextValue = this.state.contextValue;
    var _this$props = this.props, domRoot = _this$props.domRoot, children = _this$props.children, _this$props$dense = _this$props.dense, dense = _this$props$dense === void 0 ? false : _this$props$dense, _this$props$Component = _this$props.Components, Components = _this$props$Component === void 0 ? {} : _this$props$Component, classes2 = _this$props.classes;
    var categ = this.state.snacks.reduce(function(acc, current) {
      var _extends2;
      var category = originKeyExtractor(current.anchorOrigin);
      var existingOfCategory = acc[category] || [];
      return _extends({}, acc, (_extends2 = {}, _extends2[category] = [].concat(existingOfCategory, [current]), _extends2));
    }, {});
    var snackbars = Object.keys(categ).map(function(origin2) {
      var snacks = categ[origin2];
      var nomineeSnack = snacks[0];
      return React__default$1.createElement(SnackbarContainer$1, {
        key: origin2,
        dense,
        anchorOrigin: nomineeSnack.anchorOrigin,
        classes: classes2
      }, snacks.map(function(snack) {
        return React__default$1.createElement(SnackbarItem, {
          key: snack.id,
          snack,
          classes: classes2,
          Component: Components[snack.variant],
          onClose: _this2.handleCloseSnack,
          onEnter: _this2.props.onEnter,
          onExit: _this2.props.onExit,
          onExited: createChainedFunction([_this2.handleExitedSnack, _this2.props.onExited], snack.id),
          onEntered: createChainedFunction([_this2.handleEnteredSnack, _this2.props.onEntered], snack.id)
        });
      }));
    });
    return React__default$1.createElement(SnackbarContext.Provider, {
      value: contextValue
    }, children, domRoot ? createPortal(snackbars, domRoot) : snackbars);
  };
  _createClass(SnackbarProvider2, [{
    key: "maxSnack",
    get: function get3() {
      return this.props.maxSnack || defaults$2.maxSnack;
    }
  }]);
  return SnackbarProvider2;
}(Component);
var useSnackbar = function() {
  return useContext$3(SnackbarContext);
};
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var object_hash = { exports: {} };
(function(module, exports) {
  !function(e2) {
    module.exports = e2();
  }(function() {
    return function r2(o2, i, u2) {
      function s2(n2, e3) {
        if (!i[n2]) {
          if (!o2[n2]) {
            var t2 = "function" == typeof commonjsRequire && commonjsRequire;
            if (!e3 && t2) return t2(n2, true);
            if (a2) return a2(n2, true);
            throw new Error("Cannot find module '" + n2 + "'");
          }
          e3 = i[n2] = { exports: {} };
          o2[n2][0].call(e3.exports, function(e4) {
            var t3 = o2[n2][1][e4];
            return s2(t3 || e4);
          }, e3, e3.exports, r2, o2, i, u2);
        }
        return i[n2].exports;
      }
      for (var a2 = "function" == typeof commonjsRequire && commonjsRequire, e2 = 0; e2 < u2.length; e2++) s2(u2[e2]);
      return s2;
    }({ 1: [function(w, b, m) {
      !function(e2, n2, s2, c2, d, h, p2, g, y) {
        var r2 = w("crypto");
        function t2(e3, t3) {
          t3 = u2(e3, t3);
          var n3;
          return void 0 === (n3 = "passthrough" !== t3.algorithm ? r2.createHash(t3.algorithm) : new l2()).write && (n3.write = n3.update, n3.end = n3.update), f(t3, n3).dispatch(e3), n3.update || n3.end(""), n3.digest ? n3.digest("buffer" === t3.encoding ? void 0 : t3.encoding) : (e3 = n3.read(), "buffer" !== t3.encoding ? e3.toString(t3.encoding) : e3);
        }
        (m = b.exports = t2).sha1 = function(e3) {
          return t2(e3);
        }, m.keys = function(e3) {
          return t2(e3, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
        }, m.MD5 = function(e3) {
          return t2(e3, { algorithm: "md5", encoding: "hex" });
        }, m.keysMD5 = function(e3) {
          return t2(e3, { algorithm: "md5", encoding: "hex", excludeValues: true });
        };
        var o2 = r2.getHashes ? r2.getHashes().slice() : ["sha1", "md5"], i = (o2.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
        function u2(e3, t3) {
          var n3 = {};
          if (n3.algorithm = (t3 = t3 || {}).algorithm || "sha1", n3.encoding = t3.encoding || "hex", n3.excludeValues = !!t3.excludeValues, n3.algorithm = n3.algorithm.toLowerCase(), n3.encoding = n3.encoding.toLowerCase(), n3.ignoreUnknown = true === t3.ignoreUnknown, n3.respectType = false !== t3.respectType, n3.respectFunctionNames = false !== t3.respectFunctionNames, n3.respectFunctionProperties = false !== t3.respectFunctionProperties, n3.unorderedArrays = true === t3.unorderedArrays, n3.unorderedSets = false !== t3.unorderedSets, n3.unorderedObjects = false !== t3.unorderedObjects, n3.replacer = t3.replacer || void 0, n3.excludeKeys = t3.excludeKeys || void 0, void 0 === e3) throw new Error("Object argument required.");
          for (var r3 = 0; r3 < o2.length; ++r3) o2[r3].toLowerCase() === n3.algorithm.toLowerCase() && (n3.algorithm = o2[r3]);
          if (-1 === o2.indexOf(n3.algorithm)) throw new Error('Algorithm "' + n3.algorithm + '"  not supported. supported values: ' + o2.join(", "));
          if (-1 === i.indexOf(n3.encoding) && "passthrough" !== n3.algorithm) throw new Error('Encoding "' + n3.encoding + '"  not supported. supported values: ' + i.join(", "));
          return n3;
        }
        function a2(e3) {
          if ("function" == typeof e3) return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e3));
        }
        function f(o3, t3, i2) {
          i2 = i2 || [];
          function u3(e3) {
            return t3.update ? t3.update(e3, "utf8") : t3.write(e3, "utf8");
          }
          return { dispatch: function(e3) {
            return this["_" + (null === (e3 = o3.replacer ? o3.replacer(e3) : e3) ? "null" : typeof e3)](e3);
          }, _object: function(t4) {
            var n3, e3 = Object.prototype.toString.call(t4), r3 = /\[object (.*)\]/i.exec(e3);
            r3 = (r3 = r3 ? r3[1] : "unknown:[" + e3 + "]").toLowerCase();
            if (0 <= (e3 = i2.indexOf(t4))) return this.dispatch("[CIRCULAR:" + e3 + "]");
            if (i2.push(t4), void 0 !== s2 && s2.isBuffer && s2.isBuffer(t4)) return u3("buffer:"), u3(t4);
            if ("object" === r3 || "function" === r3 || "asyncfunction" === r3) return e3 = Object.keys(t4), o3.unorderedObjects && (e3 = e3.sort()), false === o3.respectType || a2(t4) || e3.splice(0, 0, "prototype", "__proto__", "constructor"), o3.excludeKeys && (e3 = e3.filter(function(e4) {
              return !o3.excludeKeys(e4);
            })), u3("object:" + e3.length + ":"), n3 = this, e3.forEach(function(e4) {
              n3.dispatch(e4), u3(":"), o3.excludeValues || n3.dispatch(t4[e4]), u3(",");
            });
            if (!this["_" + r3]) {
              if (o3.ignoreUnknown) return u3("[" + r3 + "]");
              throw new Error('Unknown object type "' + r3 + '"');
            }
            this["_" + r3](t4);
          }, _array: function(e3, t4) {
            t4 = void 0 !== t4 ? t4 : false !== o3.unorderedArrays;
            var n3 = this;
            if (u3("array:" + e3.length + ":"), !t4 || e3.length <= 1) return e3.forEach(function(e4) {
              return n3.dispatch(e4);
            });
            var r3 = [], t4 = e3.map(function(e4) {
              var t5 = new l2(), n4 = i2.slice();
              return f(o3, t5, n4).dispatch(e4), r3 = r3.concat(n4.slice(i2.length)), t5.read().toString();
            });
            return i2 = i2.concat(r3), t4.sort(), this._array(t4, false);
          }, _date: function(e3) {
            return u3("date:" + e3.toJSON());
          }, _symbol: function(e3) {
            return u3("symbol:" + e3.toString());
          }, _error: function(e3) {
            return u3("error:" + e3.toString());
          }, _boolean: function(e3) {
            return u3("bool:" + e3.toString());
          }, _string: function(e3) {
            u3("string:" + e3.length + ":"), u3(e3.toString());
          }, _function: function(e3) {
            u3("fn:"), a2(e3) ? this.dispatch("[native]") : this.dispatch(e3.toString()), false !== o3.respectFunctionNames && this.dispatch("function-name:" + String(e3.name)), o3.respectFunctionProperties && this._object(e3);
          }, _number: function(e3) {
            return u3("number:" + e3.toString());
          }, _xml: function(e3) {
            return u3("xml:" + e3.toString());
          }, _null: function() {
            return u3("Null");
          }, _undefined: function() {
            return u3("Undefined");
          }, _regexp: function(e3) {
            return u3("regex:" + e3.toString());
          }, _uint8array: function(e3) {
            return u3("uint8array:"), this.dispatch(Array.prototype.slice.call(e3));
          }, _uint8clampedarray: function(e3) {
            return u3("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e3));
          }, _int8array: function(e3) {
            return u3("int8array:"), this.dispatch(Array.prototype.slice.call(e3));
          }, _uint16array: function(e3) {
            return u3("uint16array:"), this.dispatch(Array.prototype.slice.call(e3));
          }, _int16array: function(e3) {
            return u3("int16array:"), this.dispatch(Array.prototype.slice.call(e3));
          }, _uint32array: function(e3) {
            return u3("uint32array:"), this.dispatch(Array.prototype.slice.call(e3));
          }, _int32array: function(e3) {
            return u3("int32array:"), this.dispatch(Array.prototype.slice.call(e3));
          }, _float32array: function(e3) {
            return u3("float32array:"), this.dispatch(Array.prototype.slice.call(e3));
          }, _float64array: function(e3) {
            return u3("float64array:"), this.dispatch(Array.prototype.slice.call(e3));
          }, _arraybuffer: function(e3) {
            return u3("arraybuffer:"), this.dispatch(new Uint8Array(e3));
          }, _url: function(e3) {
            return u3("url:" + e3.toString());
          }, _map: function(e3) {
            u3("map:");
            e3 = Array.from(e3);
            return this._array(e3, false !== o3.unorderedSets);
          }, _set: function(e3) {
            u3("set:");
            e3 = Array.from(e3);
            return this._array(e3, false !== o3.unorderedSets);
          }, _file: function(e3) {
            return u3("file:"), this.dispatch([e3.name, e3.size, e3.type, e3.lastModfied]);
          }, _blob: function() {
            if (o3.ignoreUnknown) return u3("[blob]");
            throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
          }, _domwindow: function() {
            return u3("domwindow");
          }, _bigint: function(e3) {
            return u3("bigint:" + e3.toString());
          }, _process: function() {
            return u3("process");
          }, _timer: function() {
            return u3("timer");
          }, _pipe: function() {
            return u3("pipe");
          }, _tcp: function() {
            return u3("tcp");
          }, _udp: function() {
            return u3("udp");
          }, _tty: function() {
            return u3("tty");
          }, _statwatcher: function() {
            return u3("statwatcher");
          }, _securecontext: function() {
            return u3("securecontext");
          }, _connection: function() {
            return u3("connection");
          }, _zlib: function() {
            return u3("zlib");
          }, _context: function() {
            return u3("context");
          }, _nodescript: function() {
            return u3("nodescript");
          }, _httpparser: function() {
            return u3("httpparser");
          }, _dataview: function() {
            return u3("dataview");
          }, _signal: function() {
            return u3("signal");
          }, _fsevent: function() {
            return u3("fsevent");
          }, _tlswrap: function() {
            return u3("tlswrap");
          } };
        }
        function l2() {
          return { buf: "", write: function(e3) {
            this.buf += e3;
          }, end: function(e3) {
            this.buf += e3;
          }, read: function() {
            return this.buf;
          } };
        }
        m.writeToStream = function(e3, t3, n3) {
          return void 0 === n3 && (n3 = t3, t3 = {}), f(t3 = u2(e3, t3), n3).dispatch(e3);
        };
      }.call(this, w("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
    }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(e2, t2, f) {
      !function(e3, t3, n2, r2, o2, i, u2, s2, a2) {
        !function(e4) {
          var a3 = "undefined" != typeof Uint8Array ? Uint8Array : Array, t4 = "+".charCodeAt(0), n3 = "/".charCodeAt(0), r3 = "0".charCodeAt(0), o3 = "a".charCodeAt(0), i2 = "A".charCodeAt(0), u3 = "-".charCodeAt(0), s3 = "_".charCodeAt(0);
          function f2(e5) {
            e5 = e5.charCodeAt(0);
            return e5 === t4 || e5 === u3 ? 62 : e5 === n3 || e5 === s3 ? 63 : e5 < r3 ? -1 : e5 < r3 + 10 ? e5 - r3 + 26 + 26 : e5 < i2 + 26 ? e5 - i2 : e5 < o3 + 26 ? e5 - o3 + 26 : void 0;
          }
          e4.toByteArray = function(e5) {
            var t5, n4;
            if (0 < e5.length % 4) throw new Error("Invalid string. Length must be a multiple of 4");
            var r4 = e5.length, r4 = "=" === e5.charAt(r4 - 2) ? 2 : "=" === e5.charAt(r4 - 1) ? 1 : 0, o4 = new a3(3 * e5.length / 4 - r4), i3 = 0 < r4 ? e5.length - 4 : e5.length, u4 = 0;
            function s4(e6) {
              o4[u4++] = e6;
            }
            for (t5 = 0; t5 < i3; t5 += 4, 0) s4((16711680 & (n4 = f2(e5.charAt(t5)) << 18 | f2(e5.charAt(t5 + 1)) << 12 | f2(e5.charAt(t5 + 2)) << 6 | f2(e5.charAt(t5 + 3)))) >> 16), s4((65280 & n4) >> 8), s4(255 & n4);
            return 2 == r4 ? s4(255 & (n4 = f2(e5.charAt(t5)) << 2 | f2(e5.charAt(t5 + 1)) >> 4)) : 1 == r4 && (s4((n4 = f2(e5.charAt(t5)) << 10 | f2(e5.charAt(t5 + 1)) << 4 | f2(e5.charAt(t5 + 2)) >> 2) >> 8 & 255), s4(255 & n4)), o4;
          }, e4.fromByteArray = function(e5) {
            var t5, n4, r4, o4, i3 = e5.length % 3, u4 = "";
            function s4(e6) {
              return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e6);
            }
            for (t5 = 0, r4 = e5.length - i3; t5 < r4; t5 += 3) n4 = (e5[t5] << 16) + (e5[t5 + 1] << 8) + e5[t5 + 2], u4 += s4((o4 = n4) >> 18 & 63) + s4(o4 >> 12 & 63) + s4(o4 >> 6 & 63) + s4(63 & o4);
            switch (i3) {
              case 1:
                u4 = (u4 += s4((n4 = e5[e5.length - 1]) >> 2)) + s4(n4 << 4 & 63) + "==";
                break;
              case 2:
                u4 = (u4 = (u4 += s4((n4 = (e5[e5.length - 2] << 8) + e5[e5.length - 1]) >> 10)) + s4(n4 >> 4 & 63)) + s4(n4 << 2 & 63) + "=";
            }
            return u4;
          };
        }(void 0 === f ? this.base64js = {} : f);
      }.call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
    }, { buffer: 3, lYpoI2: 11 }], 3: [function(O, e2, H) {
      !function(e3, n2, f, r2, h, p2, g, y, w) {
        var a2 = O("base64-js"), i = O("ieee754");
        function f(e4, t3, n3) {
          if (!(this instanceof f)) return new f(e4, t3, n3);
          var r3, o3, i2, u3, s3 = typeof e4;
          if ("base64" === t3 && "string" == s3) for (e4 = (u3 = e4).trim ? u3.trim() : u3.replace(/^\s+|\s+$/g, ""); e4.length % 4 != 0; ) e4 += "=";
          if ("number" == s3) r3 = j(e4);
          else if ("string" == s3) r3 = f.byteLength(e4, t3);
          else {
            if ("object" != s3) throw new Error("First argument needs to be a number, array or string.");
            r3 = j(e4.length);
          }
          if (f._useTypedArrays ? o3 = f._augment(new Uint8Array(r3)) : ((o3 = this).length = r3, o3._isBuffer = true), f._useTypedArrays && "number" == typeof e4.byteLength) o3._set(e4);
          else if (C(u3 = e4) || f.isBuffer(u3) || u3 && "object" == typeof u3 && "number" == typeof u3.length) for (i2 = 0; i2 < r3; i2++) f.isBuffer(e4) ? o3[i2] = e4.readUInt8(i2) : o3[i2] = e4[i2];
          else if ("string" == s3) o3.write(e4, 0, t3);
          else if ("number" == s3 && !f._useTypedArrays && !n3) for (i2 = 0; i2 < r3; i2++) o3[i2] = 0;
          return o3;
        }
        function b(e4, t3, n3, r3) {
          return f._charsWritten = c2(function(e5) {
            for (var t4 = [], n4 = 0; n4 < e5.length; n4++) t4.push(255 & e5.charCodeAt(n4));
            return t4;
          }(t3), e4, n3, r3);
        }
        function m(e4, t3, n3, r3) {
          return f._charsWritten = c2(function(e5) {
            for (var t4, n4, r4 = [], o3 = 0; o3 < e5.length; o3++) n4 = e5.charCodeAt(o3), t4 = n4 >> 8, n4 = n4 % 256, r4.push(n4), r4.push(t4);
            return r4;
          }(t3), e4, n3, r3);
        }
        function v(e4, t3, n3) {
          var r3 = "";
          n3 = Math.min(e4.length, n3);
          for (var o3 = t3; o3 < n3; o3++) r3 += String.fromCharCode(e4[o3]);
          return r3;
        }
        function o2(e4, t3, n3, r3) {
          r3 || (d("boolean" == typeof n3, "missing or invalid endian"), d(null != t3, "missing offset"), d(t3 + 1 < e4.length, "Trying to read beyond buffer length"));
          var o3, r3 = e4.length;
          if (!(r3 <= t3)) return n3 ? (o3 = e4[t3], t3 + 1 < r3 && (o3 |= e4[t3 + 1] << 8)) : (o3 = e4[t3] << 8, t3 + 1 < r3 && (o3 |= e4[t3 + 1])), o3;
        }
        function u2(e4, t3, n3, r3) {
          r3 || (d("boolean" == typeof n3, "missing or invalid endian"), d(null != t3, "missing offset"), d(t3 + 3 < e4.length, "Trying to read beyond buffer length"));
          var o3, r3 = e4.length;
          if (!(r3 <= t3)) return n3 ? (t3 + 2 < r3 && (o3 = e4[t3 + 2] << 16), t3 + 1 < r3 && (o3 |= e4[t3 + 1] << 8), o3 |= e4[t3], t3 + 3 < r3 && (o3 += e4[t3 + 3] << 24 >>> 0)) : (t3 + 1 < r3 && (o3 = e4[t3 + 1] << 16), t3 + 2 < r3 && (o3 |= e4[t3 + 2] << 8), t3 + 3 < r3 && (o3 |= e4[t3 + 3]), o3 += e4[t3] << 24 >>> 0), o3;
        }
        function _(e4, t3, n3, r3) {
          if (r3 || (d("boolean" == typeof n3, "missing or invalid endian"), d(null != t3, "missing offset"), d(t3 + 1 < e4.length, "Trying to read beyond buffer length")), !(e4.length <= t3)) return r3 = o2(e4, t3, n3, true), 32768 & r3 ? -1 * (65535 - r3 + 1) : r3;
        }
        function E(e4, t3, n3, r3) {
          if (r3 || (d("boolean" == typeof n3, "missing or invalid endian"), d(null != t3, "missing offset"), d(t3 + 3 < e4.length, "Trying to read beyond buffer length")), !(e4.length <= t3)) return r3 = u2(e4, t3, n3, true), 2147483648 & r3 ? -1 * (4294967295 - r3 + 1) : r3;
        }
        function I(e4, t3, n3, r3) {
          return r3 || (d("boolean" == typeof n3, "missing or invalid endian"), d(t3 + 3 < e4.length, "Trying to read beyond buffer length")), i.read(e4, t3, n3, 23, 4);
        }
        function A(e4, t3, n3, r3) {
          return r3 || (d("boolean" == typeof n3, "missing or invalid endian"), d(t3 + 7 < e4.length, "Trying to read beyond buffer length")), i.read(e4, t3, n3, 52, 8);
        }
        function s2(e4, t3, n3, r3, o3) {
          o3 || (d(null != t3, "missing value"), d("boolean" == typeof r3, "missing or invalid endian"), d(null != n3, "missing offset"), d(n3 + 1 < e4.length, "trying to write beyond buffer length"), Y(t3, 65535));
          o3 = e4.length;
          if (!(o3 <= n3)) for (var i2 = 0, u3 = Math.min(o3 - n3, 2); i2 < u3; i2++) e4[n3 + i2] = (t3 & 255 << 8 * (r3 ? i2 : 1 - i2)) >>> 8 * (r3 ? i2 : 1 - i2);
        }
        function l2(e4, t3, n3, r3, o3) {
          o3 || (d(null != t3, "missing value"), d("boolean" == typeof r3, "missing or invalid endian"), d(null != n3, "missing offset"), d(n3 + 3 < e4.length, "trying to write beyond buffer length"), Y(t3, 4294967295));
          o3 = e4.length;
          if (!(o3 <= n3)) for (var i2 = 0, u3 = Math.min(o3 - n3, 4); i2 < u3; i2++) e4[n3 + i2] = t3 >>> 8 * (r3 ? i2 : 3 - i2) & 255;
        }
        function B(e4, t3, n3, r3, o3) {
          o3 || (d(null != t3, "missing value"), d("boolean" == typeof r3, "missing or invalid endian"), d(null != n3, "missing offset"), d(n3 + 1 < e4.length, "Trying to write beyond buffer length"), F(t3, 32767, -32768)), e4.length <= n3 || s2(e4, 0 <= t3 ? t3 : 65535 + t3 + 1, n3, r3, o3);
        }
        function L(e4, t3, n3, r3, o3) {
          o3 || (d(null != t3, "missing value"), d("boolean" == typeof r3, "missing or invalid endian"), d(null != n3, "missing offset"), d(n3 + 3 < e4.length, "Trying to write beyond buffer length"), F(t3, 2147483647, -2147483648)), e4.length <= n3 || l2(e4, 0 <= t3 ? t3 : 4294967295 + t3 + 1, n3, r3, o3);
        }
        function U(e4, t3, n3, r3, o3) {
          o3 || (d(null != t3, "missing value"), d("boolean" == typeof r3, "missing or invalid endian"), d(null != n3, "missing offset"), d(n3 + 3 < e4.length, "Trying to write beyond buffer length"), D(t3, 34028234663852886e22, -34028234663852886e22)), e4.length <= n3 || i.write(e4, t3, n3, r3, 23, 4);
        }
        function x(e4, t3, n3, r3, o3) {
          o3 || (d(null != t3, "missing value"), d("boolean" == typeof r3, "missing or invalid endian"), d(null != n3, "missing offset"), d(n3 + 7 < e4.length, "Trying to write beyond buffer length"), D(t3, 17976931348623157e292, -17976931348623157e292)), e4.length <= n3 || i.write(e4, t3, n3, r3, 52, 8);
        }
        H.Buffer = f, H.SlowBuffer = f, H.INSPECT_MAX_BYTES = 50, f.poolSize = 8192, f._useTypedArrays = function() {
          try {
            var e4 = new ArrayBuffer(0), t3 = new Uint8Array(e4);
            return t3.foo = function() {
              return 42;
            }, 42 === t3.foo() && "function" == typeof t3.subarray;
          } catch (e5) {
            return false;
          }
        }(), f.isEncoding = function(e4) {
          switch (String(e4).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "raw":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        }, f.isBuffer = function(e4) {
          return !(null == e4 || !e4._isBuffer);
        }, f.byteLength = function(e4, t3) {
          var n3;
          switch (e4 += "", t3 || "utf8") {
            case "hex":
              n3 = e4.length / 2;
              break;
            case "utf8":
            case "utf-8":
              n3 = T(e4).length;
              break;
            case "ascii":
            case "binary":
            case "raw":
              n3 = e4.length;
              break;
            case "base64":
              n3 = M(e4).length;
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              n3 = 2 * e4.length;
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return n3;
        }, f.concat = function(e4, t3) {
          if (d(C(e4), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === e4.length) return new f(0);
          if (1 === e4.length) return e4[0];
          if ("number" != typeof t3) for (o3 = t3 = 0; o3 < e4.length; o3++) t3 += e4[o3].length;
          for (var n3 = new f(t3), r3 = 0, o3 = 0; o3 < e4.length; o3++) {
            var i2 = e4[o3];
            i2.copy(n3, r3), r3 += i2.length;
          }
          return n3;
        }, f.prototype.write = function(e4, t3, n3, r3) {
          isFinite(t3) ? isFinite(n3) || (r3 = n3, n3 = void 0) : (a3 = r3, r3 = t3, t3 = n3, n3 = a3), t3 = Number(t3) || 0;
          var o3, i2, u3, s3, a3 = this.length - t3;
          switch ((!n3 || a3 < (n3 = Number(n3))) && (n3 = a3), r3 = String(r3 || "utf8").toLowerCase()) {
            case "hex":
              o3 = function(e5, t4, n4, r4) {
                n4 = Number(n4) || 0;
                var o4 = e5.length - n4;
                (!r4 || o4 < (r4 = Number(r4))) && (r4 = o4), d((o4 = t4.length) % 2 == 0, "Invalid hex string"), o4 / 2 < r4 && (r4 = o4 / 2);
                for (var i3 = 0; i3 < r4; i3++) {
                  var u4 = parseInt(t4.substr(2 * i3, 2), 16);
                  d(!isNaN(u4), "Invalid hex string"), e5[n4 + i3] = u4;
                }
                return f._charsWritten = 2 * i3, i3;
              }(this, e4, t3, n3);
              break;
            case "utf8":
            case "utf-8":
              i2 = this, u3 = t3, s3 = n3, o3 = f._charsWritten = c2(T(e4), i2, u3, s3);
              break;
            case "ascii":
            case "binary":
              o3 = b(this, e4, t3, n3);
              break;
            case "base64":
              i2 = this, u3 = t3, s3 = n3, o3 = f._charsWritten = c2(M(e4), i2, u3, s3);
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              o3 = m(this, e4, t3, n3);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return o3;
        }, f.prototype.toString = function(e4, t3, n3) {
          var r3, o3, i2, u3, s3 = this;
          if (e4 = String(e4 || "utf8").toLowerCase(), t3 = Number(t3) || 0, (n3 = void 0 !== n3 ? Number(n3) : s3.length) === t3) return "";
          switch (e4) {
            case "hex":
              r3 = function(e5, t4, n4) {
                var r4 = e5.length;
                (!t4 || t4 < 0) && (t4 = 0);
                (!n4 || n4 < 0 || r4 < n4) && (n4 = r4);
                for (var o4 = "", i3 = t4; i3 < n4; i3++) o4 += k(e5[i3]);
                return o4;
              }(s3, t3, n3);
              break;
            case "utf8":
            case "utf-8":
              r3 = function(e5, t4, n4) {
                var r4 = "", o4 = "";
                n4 = Math.min(e5.length, n4);
                for (var i3 = t4; i3 < n4; i3++) e5[i3] <= 127 ? (r4 += N(o4) + String.fromCharCode(e5[i3]), o4 = "") : o4 += "%" + e5[i3].toString(16);
                return r4 + N(o4);
              }(s3, t3, n3);
              break;
            case "ascii":
            case "binary":
              r3 = v(s3, t3, n3);
              break;
            case "base64":
              o3 = s3, u3 = n3, r3 = 0 === (i2 = t3) && u3 === o3.length ? a2.fromByteArray(o3) : a2.fromByteArray(o3.slice(i2, u3));
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              r3 = function(e5, t4, n4) {
                for (var r4 = e5.slice(t4, n4), o4 = "", i3 = 0; i3 < r4.length; i3 += 2) o4 += String.fromCharCode(r4[i3] + 256 * r4[i3 + 1]);
                return o4;
              }(s3, t3, n3);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return r3;
        }, f.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        }, f.prototype.copy = function(e4, t3, n3, r3) {
          if (t3 = t3 || 0, (r3 = r3 || 0 === r3 ? r3 : this.length) !== (n3 = n3 || 0) && 0 !== e4.length && 0 !== this.length) {
            d(n3 <= r3, "sourceEnd < sourceStart"), d(0 <= t3 && t3 < e4.length, "targetStart out of bounds"), d(0 <= n3 && n3 < this.length, "sourceStart out of bounds"), d(0 <= r3 && r3 <= this.length, "sourceEnd out of bounds"), r3 > this.length && (r3 = this.length);
            var o3 = (r3 = e4.length - t3 < r3 - n3 ? e4.length - t3 + n3 : r3) - n3;
            if (o3 < 100 || !f._useTypedArrays) for (var i2 = 0; i2 < o3; i2++) e4[i2 + t3] = this[i2 + n3];
            else e4._set(this.subarray(n3, n3 + o3), t3);
          }
        }, f.prototype.slice = function(e4, t3) {
          var n3 = this.length;
          if (e4 = S(e4, n3, 0), t3 = S(t3, n3, n3), f._useTypedArrays) return f._augment(this.subarray(e4, t3));
          for (var r3 = t3 - e4, o3 = new f(r3, void 0, true), i2 = 0; i2 < r3; i2++) o3[i2] = this[i2 + e4];
          return o3;
        }, f.prototype.get = function(e4) {
          return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e4);
        }, f.prototype.set = function(e4, t3) {
          return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e4, t3);
        }, f.prototype.readUInt8 = function(e4, t3) {
          if (t3 || (d(null != e4, "missing offset"), d(e4 < this.length, "Trying to read beyond buffer length")), !(e4 >= this.length)) return this[e4];
        }, f.prototype.readUInt16LE = function(e4, t3) {
          return o2(this, e4, true, t3);
        }, f.prototype.readUInt16BE = function(e4, t3) {
          return o2(this, e4, false, t3);
        }, f.prototype.readUInt32LE = function(e4, t3) {
          return u2(this, e4, true, t3);
        }, f.prototype.readUInt32BE = function(e4, t3) {
          return u2(this, e4, false, t3);
        }, f.prototype.readInt8 = function(e4, t3) {
          if (t3 || (d(null != e4, "missing offset"), d(e4 < this.length, "Trying to read beyond buffer length")), !(e4 >= this.length)) return 128 & this[e4] ? -1 * (255 - this[e4] + 1) : this[e4];
        }, f.prototype.readInt16LE = function(e4, t3) {
          return _(this, e4, true, t3);
        }, f.prototype.readInt16BE = function(e4, t3) {
          return _(this, e4, false, t3);
        }, f.prototype.readInt32LE = function(e4, t3) {
          return E(this, e4, true, t3);
        }, f.prototype.readInt32BE = function(e4, t3) {
          return E(this, e4, false, t3);
        }, f.prototype.readFloatLE = function(e4, t3) {
          return I(this, e4, true, t3);
        }, f.prototype.readFloatBE = function(e4, t3) {
          return I(this, e4, false, t3);
        }, f.prototype.readDoubleLE = function(e4, t3) {
          return A(this, e4, true, t3);
        }, f.prototype.readDoubleBE = function(e4, t3) {
          return A(this, e4, false, t3);
        }, f.prototype.writeUInt8 = function(e4, t3, n3) {
          n3 || (d(null != e4, "missing value"), d(null != t3, "missing offset"), d(t3 < this.length, "trying to write beyond buffer length"), Y(e4, 255)), t3 >= this.length || (this[t3] = e4);
        }, f.prototype.writeUInt16LE = function(e4, t3, n3) {
          s2(this, e4, t3, true, n3);
        }, f.prototype.writeUInt16BE = function(e4, t3, n3) {
          s2(this, e4, t3, false, n3);
        }, f.prototype.writeUInt32LE = function(e4, t3, n3) {
          l2(this, e4, t3, true, n3);
        }, f.prototype.writeUInt32BE = function(e4, t3, n3) {
          l2(this, e4, t3, false, n3);
        }, f.prototype.writeInt8 = function(e4, t3, n3) {
          n3 || (d(null != e4, "missing value"), d(null != t3, "missing offset"), d(t3 < this.length, "Trying to write beyond buffer length"), F(e4, 127, -128)), t3 >= this.length || (0 <= e4 ? this.writeUInt8(e4, t3, n3) : this.writeUInt8(255 + e4 + 1, t3, n3));
        }, f.prototype.writeInt16LE = function(e4, t3, n3) {
          B(this, e4, t3, true, n3);
        }, f.prototype.writeInt16BE = function(e4, t3, n3) {
          B(this, e4, t3, false, n3);
        }, f.prototype.writeInt32LE = function(e4, t3, n3) {
          L(this, e4, t3, true, n3);
        }, f.prototype.writeInt32BE = function(e4, t3, n3) {
          L(this, e4, t3, false, n3);
        }, f.prototype.writeFloatLE = function(e4, t3, n3) {
          U(this, e4, t3, true, n3);
        }, f.prototype.writeFloatBE = function(e4, t3, n3) {
          U(this, e4, t3, false, n3);
        }, f.prototype.writeDoubleLE = function(e4, t3, n3) {
          x(this, e4, t3, true, n3);
        }, f.prototype.writeDoubleBE = function(e4, t3, n3) {
          x(this, e4, t3, false, n3);
        }, f.prototype.fill = function(e4, t3, n3) {
          if (t3 = t3 || 0, n3 = n3 || this.length, d("number" == typeof (e4 = "string" == typeof (e4 = e4 || 0) ? e4.charCodeAt(0) : e4) && !isNaN(e4), "value is not a number"), d(t3 <= n3, "end < start"), n3 !== t3 && 0 !== this.length) {
            d(0 <= t3 && t3 < this.length, "start out of bounds"), d(0 <= n3 && n3 <= this.length, "end out of bounds");
            for (var r3 = t3; r3 < n3; r3++) this[r3] = e4;
          }
        }, f.prototype.inspect = function() {
          for (var e4 = [], t3 = this.length, n3 = 0; n3 < t3; n3++) if (e4[n3] = k(this[n3]), n3 === H.INSPECT_MAX_BYTES) {
            e4[n3 + 1] = "...";
            break;
          }
          return "<Buffer " + e4.join(" ") + ">";
        }, f.prototype.toArrayBuffer = function() {
          if ("undefined" == typeof Uint8Array) throw new Error("Buffer.toArrayBuffer not supported in this browser");
          if (f._useTypedArrays) return new f(this).buffer;
          for (var e4 = new Uint8Array(this.length), t3 = 0, n3 = e4.length; t3 < n3; t3 += 1) e4[t3] = this[t3];
          return e4.buffer;
        };
        var t2 = f.prototype;
        function S(e4, t3, n3) {
          return "number" != typeof e4 ? n3 : t3 <= (e4 = ~~e4) ? t3 : 0 <= e4 || 0 <= (e4 += t3) ? e4 : 0;
        }
        function j(e4) {
          return (e4 = ~~Math.ceil(+e4)) < 0 ? 0 : e4;
        }
        function C(e4) {
          return (Array.isArray || function(e5) {
            return "[object Array]" === Object.prototype.toString.call(e5);
          })(e4);
        }
        function k(e4) {
          return e4 < 16 ? "0" + e4.toString(16) : e4.toString(16);
        }
        function T(e4) {
          for (var t3 = [], n3 = 0; n3 < e4.length; n3++) {
            var r3 = e4.charCodeAt(n3);
            if (r3 <= 127) t3.push(e4.charCodeAt(n3));
            else for (var o3 = n3, i2 = (55296 <= r3 && r3 <= 57343 && n3++, encodeURIComponent(e4.slice(o3, n3 + 1)).substr(1).split("%")), u3 = 0; u3 < i2.length; u3++) t3.push(parseInt(i2[u3], 16));
          }
          return t3;
        }
        function M(e4) {
          return a2.toByteArray(e4);
        }
        function c2(e4, t3, n3, r3) {
          for (var o3 = 0; o3 < r3 && !(o3 + n3 >= t3.length || o3 >= e4.length); o3++) t3[o3 + n3] = e4[o3];
          return o3;
        }
        function N(e4) {
          try {
            return decodeURIComponent(e4);
          } catch (e5) {
            return String.fromCharCode(65533);
          }
        }
        function Y(e4, t3) {
          d("number" == typeof e4, "cannot write a non-number as a number"), d(0 <= e4, "specified a negative value for writing an unsigned value"), d(e4 <= t3, "value is larger than maximum value for type"), d(Math.floor(e4) === e4, "value has a fractional component");
        }
        function F(e4, t3, n3) {
          d("number" == typeof e4, "cannot write a non-number as a number"), d(e4 <= t3, "value larger than maximum allowed value"), d(n3 <= e4, "value smaller than minimum allowed value"), d(Math.floor(e4) === e4, "value has a fractional component");
        }
        function D(e4, t3, n3) {
          d("number" == typeof e4, "cannot write a non-number as a number"), d(e4 <= t3, "value larger than maximum allowed value"), d(n3 <= e4, "value smaller than minimum allowed value");
        }
        function d(e4, t3) {
          if (!e4) throw new Error(t3 || "Failed assertion");
        }
        f._augment = function(e4) {
          return e4._isBuffer = true, e4._get = e4.get, e4._set = e4.set, e4.get = t2.get, e4.set = t2.set, e4.write = t2.write, e4.toString = t2.toString, e4.toLocaleString = t2.toString, e4.toJSON = t2.toJSON, e4.copy = t2.copy, e4.slice = t2.slice, e4.readUInt8 = t2.readUInt8, e4.readUInt16LE = t2.readUInt16LE, e4.readUInt16BE = t2.readUInt16BE, e4.readUInt32LE = t2.readUInt32LE, e4.readUInt32BE = t2.readUInt32BE, e4.readInt8 = t2.readInt8, e4.readInt16LE = t2.readInt16LE, e4.readInt16BE = t2.readInt16BE, e4.readInt32LE = t2.readInt32LE, e4.readInt32BE = t2.readInt32BE, e4.readFloatLE = t2.readFloatLE, e4.readFloatBE = t2.readFloatBE, e4.readDoubleLE = t2.readDoubleLE, e4.readDoubleBE = t2.readDoubleBE, e4.writeUInt8 = t2.writeUInt8, e4.writeUInt16LE = t2.writeUInt16LE, e4.writeUInt16BE = t2.writeUInt16BE, e4.writeUInt32LE = t2.writeUInt32LE, e4.writeUInt32BE = t2.writeUInt32BE, e4.writeInt8 = t2.writeInt8, e4.writeInt16LE = t2.writeInt16LE, e4.writeInt16BE = t2.writeInt16BE, e4.writeInt32LE = t2.writeInt32LE, e4.writeInt32BE = t2.writeInt32BE, e4.writeFloatLE = t2.writeFloatLE, e4.writeFloatBE = t2.writeFloatBE, e4.writeDoubleLE = t2.writeDoubleLE, e4.writeDoubleBE = t2.writeDoubleBE, e4.fill = t2.fill, e4.inspect = t2.inspect, e4.toArrayBuffer = t2.toArrayBuffer, e4;
        };
      }.call(this, O("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, O("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
    }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(c2, d, e2) {
      !function(e3, t2, a2, n2, r2, o2, i, u2, s2) {
        var a2 = c2("buffer").Buffer, f = 4, l2 = new a2(f);
        l2.fill(0);
        d.exports = { hash: function(e4, t3, n3, r3) {
          for (var o3 = t3(function(e5, t4) {
            e5.length % f != 0 && (n4 = e5.length + (f - e5.length % f), e5 = a2.concat([e5, l2], n4));
            for (var n4, r4 = [], o4 = t4 ? e5.readInt32BE : e5.readInt32LE, i3 = 0; i3 < e5.length; i3 += f) r4.push(o4.call(e5, i3));
            return r4;
          }(e4 = a2.isBuffer(e4) ? e4 : new a2(e4), r3), 8 * e4.length), t3 = r3, i2 = new a2(n3), u3 = t3 ? i2.writeInt32BE : i2.writeInt32LE, s3 = 0; s3 < o3.length; s3++) u3.call(i2, o3[s3], 4 * s3, true);
          return i2;
        } };
      }.call(this, c2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 11 }], 5: [function(v, e2, _) {
      !function(l2, c2, u2, d, h, p2, g, y, w) {
        var u2 = v("buffer").Buffer, e3 = v("./sha"), t2 = v("./sha256"), n2 = v("./rng"), b = { sha1: e3, sha256: t2, md5: v("./md5") }, s2 = 64, a2 = new u2(s2);
        function r2(e4, n3) {
          var r3 = b[e4 = e4 || "sha1"], o3 = [];
          return r3 || i("algorithm:", e4, "is not yet supported"), { update: function(e5) {
            return u2.isBuffer(e5) || (e5 = new u2(e5)), o3.push(e5), e5.length, this;
          }, digest: function(e5) {
            var t3 = u2.concat(o3), t3 = n3 ? function(e6, t4, n4) {
              u2.isBuffer(t4) || (t4 = new u2(t4)), u2.isBuffer(n4) || (n4 = new u2(n4)), t4.length > s2 ? t4 = e6(t4) : t4.length < s2 && (t4 = u2.concat([t4, a2], s2));
              for (var r4 = new u2(s2), o4 = new u2(s2), i2 = 0; i2 < s2; i2++) r4[i2] = 54 ^ t4[i2], o4[i2] = 92 ^ t4[i2];
              return n4 = e6(u2.concat([r4, n4])), e6(u2.concat([o4, n4]));
            }(r3, n3, t3) : r3(t3);
            return o3 = null, e5 ? t3.toString(e5) : t3;
          } };
        }
        function i() {
          var e4 = [].slice.call(arguments).join(" ");
          throw new Error([e4, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
        }
        a2.fill(0), _.createHash = function(e4) {
          return r2(e4);
        }, _.createHmac = r2, _.randomBytes = function(e4, t3) {
          if (!t3 || !t3.call) return new u2(n2(e4));
          try {
            t3.call(this, void 0, new u2(n2(e4)));
          } catch (e5) {
            t3(e5);
          }
        };
        var o2, f = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], m = function(e4) {
          _[e4] = function() {
            i("sorry,", e4, "is not implemented yet");
          };
        };
        for (o2 in f) m(f[o2]);
      }.call(this, v("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, v("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(w, b, e2) {
      !function(e3, r2, o2, i, u2, a2, f, l2, y) {
        var t2 = w("./helpers");
        function n2(e4, t3) {
          e4[t3 >> 5] |= 128 << t3 % 32, e4[14 + (t3 + 64 >>> 9 << 4)] = t3;
          for (var n3 = 1732584193, r3 = -271733879, o3 = -1732584194, i2 = 271733878, u3 = 0; u3 < e4.length; u3 += 16) {
            var s3 = n3, a3 = r3, f2 = o3, l3 = i2, n3 = c2(n3, r3, o3, i2, e4[u3 + 0], 7, -680876936), i2 = c2(i2, n3, r3, o3, e4[u3 + 1], 12, -389564586), o3 = c2(o3, i2, n3, r3, e4[u3 + 2], 17, 606105819), r3 = c2(r3, o3, i2, n3, e4[u3 + 3], 22, -1044525330);
            n3 = c2(n3, r3, o3, i2, e4[u3 + 4], 7, -176418897), i2 = c2(i2, n3, r3, o3, e4[u3 + 5], 12, 1200080426), o3 = c2(o3, i2, n3, r3, e4[u3 + 6], 17, -1473231341), r3 = c2(r3, o3, i2, n3, e4[u3 + 7], 22, -45705983), n3 = c2(n3, r3, o3, i2, e4[u3 + 8], 7, 1770035416), i2 = c2(i2, n3, r3, o3, e4[u3 + 9], 12, -1958414417), o3 = c2(o3, i2, n3, r3, e4[u3 + 10], 17, -42063), r3 = c2(r3, o3, i2, n3, e4[u3 + 11], 22, -1990404162), n3 = c2(n3, r3, o3, i2, e4[u3 + 12], 7, 1804603682), i2 = c2(i2, n3, r3, o3, e4[u3 + 13], 12, -40341101), o3 = c2(o3, i2, n3, r3, e4[u3 + 14], 17, -1502002290), n3 = d(n3, r3 = c2(r3, o3, i2, n3, e4[u3 + 15], 22, 1236535329), o3, i2, e4[u3 + 1], 5, -165796510), i2 = d(i2, n3, r3, o3, e4[u3 + 6], 9, -1069501632), o3 = d(o3, i2, n3, r3, e4[u3 + 11], 14, 643717713), r3 = d(r3, o3, i2, n3, e4[u3 + 0], 20, -373897302), n3 = d(n3, r3, o3, i2, e4[u3 + 5], 5, -701558691), i2 = d(i2, n3, r3, o3, e4[u3 + 10], 9, 38016083), o3 = d(o3, i2, n3, r3, e4[u3 + 15], 14, -660478335), r3 = d(r3, o3, i2, n3, e4[u3 + 4], 20, -405537848), n3 = d(n3, r3, o3, i2, e4[u3 + 9], 5, 568446438), i2 = d(i2, n3, r3, o3, e4[u3 + 14], 9, -1019803690), o3 = d(o3, i2, n3, r3, e4[u3 + 3], 14, -187363961), r3 = d(r3, o3, i2, n3, e4[u3 + 8], 20, 1163531501), n3 = d(n3, r3, o3, i2, e4[u3 + 13], 5, -1444681467), i2 = d(i2, n3, r3, o3, e4[u3 + 2], 9, -51403784), o3 = d(o3, i2, n3, r3, e4[u3 + 7], 14, 1735328473), n3 = h(n3, r3 = d(r3, o3, i2, n3, e4[u3 + 12], 20, -1926607734), o3, i2, e4[u3 + 5], 4, -378558), i2 = h(i2, n3, r3, o3, e4[u3 + 8], 11, -2022574463), o3 = h(o3, i2, n3, r3, e4[u3 + 11], 16, 1839030562), r3 = h(r3, o3, i2, n3, e4[u3 + 14], 23, -35309556), n3 = h(n3, r3, o3, i2, e4[u3 + 1], 4, -1530992060), i2 = h(i2, n3, r3, o3, e4[u3 + 4], 11, 1272893353), o3 = h(o3, i2, n3, r3, e4[u3 + 7], 16, -155497632), r3 = h(r3, o3, i2, n3, e4[u3 + 10], 23, -1094730640), n3 = h(n3, r3, o3, i2, e4[u3 + 13], 4, 681279174), i2 = h(i2, n3, r3, o3, e4[u3 + 0], 11, -358537222), o3 = h(o3, i2, n3, r3, e4[u3 + 3], 16, -722521979), r3 = h(r3, o3, i2, n3, e4[u3 + 6], 23, 76029189), n3 = h(n3, r3, o3, i2, e4[u3 + 9], 4, -640364487), i2 = h(i2, n3, r3, o3, e4[u3 + 12], 11, -421815835), o3 = h(o3, i2, n3, r3, e4[u3 + 15], 16, 530742520), n3 = p2(n3, r3 = h(r3, o3, i2, n3, e4[u3 + 2], 23, -995338651), o3, i2, e4[u3 + 0], 6, -198630844), i2 = p2(i2, n3, r3, o3, e4[u3 + 7], 10, 1126891415), o3 = p2(o3, i2, n3, r3, e4[u3 + 14], 15, -1416354905), r3 = p2(r3, o3, i2, n3, e4[u3 + 5], 21, -57434055), n3 = p2(n3, r3, o3, i2, e4[u3 + 12], 6, 1700485571), i2 = p2(i2, n3, r3, o3, e4[u3 + 3], 10, -1894986606), o3 = p2(o3, i2, n3, r3, e4[u3 + 10], 15, -1051523), r3 = p2(r3, o3, i2, n3, e4[u3 + 1], 21, -2054922799), n3 = p2(n3, r3, o3, i2, e4[u3 + 8], 6, 1873313359), i2 = p2(i2, n3, r3, o3, e4[u3 + 15], 10, -30611744), o3 = p2(o3, i2, n3, r3, e4[u3 + 6], 15, -1560198380), r3 = p2(r3, o3, i2, n3, e4[u3 + 13], 21, 1309151649), n3 = p2(n3, r3, o3, i2, e4[u3 + 4], 6, -145523070), i2 = p2(i2, n3, r3, o3, e4[u3 + 11], 10, -1120210379), o3 = p2(o3, i2, n3, r3, e4[u3 + 2], 15, 718787259), r3 = p2(r3, o3, i2, n3, e4[u3 + 9], 21, -343485551), n3 = g(n3, s3), r3 = g(r3, a3), o3 = g(o3, f2), i2 = g(i2, l3);
          }
          return Array(n3, r3, o3, i2);
        }
        function s2(e4, t3, n3, r3, o3, i2) {
          return g((t3 = g(g(t3, e4), g(r3, i2))) << o3 | t3 >>> 32 - o3, n3);
        }
        function c2(e4, t3, n3, r3, o3, i2, u3) {
          return s2(t3 & n3 | ~t3 & r3, e4, t3, o3, i2, u3);
        }
        function d(e4, t3, n3, r3, o3, i2, u3) {
          return s2(t3 & r3 | n3 & ~r3, e4, t3, o3, i2, u3);
        }
        function h(e4, t3, n3, r3, o3, i2, u3) {
          return s2(t3 ^ n3 ^ r3, e4, t3, o3, i2, u3);
        }
        function p2(e4, t3, n3, r3, o3, i2, u3) {
          return s2(n3 ^ (t3 | ~r3), e4, t3, o3, i2, u3);
        }
        function g(e4, t3) {
          var n3 = (65535 & e4) + (65535 & t3);
          return (e4 >> 16) + (t3 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
        }
        b.exports = function(e4) {
          return t2.hash(e4, n2, 16);
        };
      }.call(this, w("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(e2, l2, t2) {
      !function(e3, t3, n2, r2, o2, i, u2, s2, f) {
        l2.exports = function(e4) {
          for (var t4, n3 = new Array(e4), r3 = 0; r3 < e4; r3++) 0 == (3 & r3) && (t4 = 4294967296 * Math.random()), n3[r3] = t4 >>> ((3 & r3) << 3) & 255;
          return n3;
        };
      }.call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 11 }], 8: [function(c2, d, e2) {
      !function(e3, t2, n2, r2, o2, s2, a2, f, l2) {
        var i = c2("./helpers");
        function u2(l3, c3) {
          l3[c3 >> 5] |= 128 << 24 - c3 % 32, l3[15 + (c3 + 64 >> 9 << 4)] = c3;
          for (var e4, t3, n3, r3 = Array(80), o3 = 1732584193, i2 = -271733879, u3 = -1732584194, s3 = 271733878, d2 = -1009589776, h = 0; h < l3.length; h += 16) {
            for (var p2 = o3, g = i2, y = u3, w = s3, b = d2, a3 = 0; a3 < 80; a3++) {
              r3[a3] = a3 < 16 ? l3[h + a3] : v(r3[a3 - 3] ^ r3[a3 - 8] ^ r3[a3 - 14] ^ r3[a3 - 16], 1);
              var f2 = m(m(v(o3, 5), (f2 = i2, t3 = u3, n3 = s3, (e4 = a3) < 20 ? f2 & t3 | ~f2 & n3 : !(e4 < 40) && e4 < 60 ? f2 & t3 | f2 & n3 | t3 & n3 : f2 ^ t3 ^ n3)), m(m(d2, r3[a3]), (e4 = a3) < 20 ? 1518500249 : e4 < 40 ? 1859775393 : e4 < 60 ? -1894007588 : -899497514)), d2 = s3, s3 = u3, u3 = v(i2, 30), i2 = o3, o3 = f2;
            }
            o3 = m(o3, p2), i2 = m(i2, g), u3 = m(u3, y), s3 = m(s3, w), d2 = m(d2, b);
          }
          return Array(o3, i2, u3, s3, d2);
        }
        function m(e4, t3) {
          var n3 = (65535 & e4) + (65535 & t3);
          return (e4 >> 16) + (t3 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
        }
        function v(e4, t3) {
          return e4 << t3 | e4 >>> 32 - t3;
        }
        d.exports = function(e4) {
          return i.hash(e4, u2, 20, true);
        };
      }.call(this, c2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(c2, d, e2) {
      !function(e3, t2, n2, r2, u2, s2, a2, f, l2) {
        function b(e4, t3) {
          var n3 = (65535 & e4) + (65535 & t3);
          return (e4 >> 16) + (t3 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
        }
        function o2(e4, l3) {
          var c3, d2 = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), t3 = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), n3 = new Array(64);
          e4[l3 >> 5] |= 128 << 24 - l3 % 32, e4[15 + (l3 + 64 >> 9 << 4)] = l3;
          for (var r3, o3, h = 0; h < e4.length; h += 16) {
            for (var i2 = t3[0], u3 = t3[1], s3 = t3[2], p2 = t3[3], a3 = t3[4], g = t3[5], y = t3[6], w = t3[7], f2 = 0; f2 < 64; f2++) n3[f2] = f2 < 16 ? e4[f2 + h] : b(b(b((o3 = n3[f2 - 2], m(o3, 17) ^ m(o3, 19) ^ v(o3, 10)), n3[f2 - 7]), (o3 = n3[f2 - 15], m(o3, 7) ^ m(o3, 18) ^ v(o3, 3))), n3[f2 - 16]), c3 = b(b(b(b(w, m(o3 = a3, 6) ^ m(o3, 11) ^ m(o3, 25)), a3 & g ^ ~a3 & y), d2[f2]), n3[f2]), r3 = b(m(r3 = i2, 2) ^ m(r3, 13) ^ m(r3, 22), i2 & u3 ^ i2 & s3 ^ u3 & s3), w = y, y = g, g = a3, a3 = b(p2, c3), p2 = s3, s3 = u3, u3 = i2, i2 = b(c3, r3);
            t3[0] = b(i2, t3[0]), t3[1] = b(u3, t3[1]), t3[2] = b(s3, t3[2]), t3[3] = b(p2, t3[3]), t3[4] = b(a3, t3[4]), t3[5] = b(g, t3[5]), t3[6] = b(y, t3[6]), t3[7] = b(w, t3[7]);
          }
          return t3;
        }
        var i = c2("./helpers"), m = function(e4, t3) {
          return e4 >>> t3 | e4 << 32 - t3;
        }, v = function(e4, t3) {
          return e4 >>> t3;
        };
        d.exports = function(e4) {
          return i.hash(e4, o2, 32, true);
        };
      }.call(this, c2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(e2, t2, f) {
      !function(e3, t3, n2, r2, o2, i, u2, s2, a2) {
        f.read = function(e4, t4, n3, r3, o3) {
          var i2, u3, l2 = 8 * o3 - r3 - 1, c2 = (1 << l2) - 1, d = c2 >> 1, s3 = -7, a3 = n3 ? o3 - 1 : 0, f2 = n3 ? -1 : 1, o3 = e4[t4 + a3];
          for (a3 += f2, i2 = o3 & (1 << -s3) - 1, o3 >>= -s3, s3 += l2; 0 < s3; i2 = 256 * i2 + e4[t4 + a3], a3 += f2, s3 -= 8) ;
          for (u3 = i2 & (1 << -s3) - 1, i2 >>= -s3, s3 += r3; 0 < s3; u3 = 256 * u3 + e4[t4 + a3], a3 += f2, s3 -= 8) ;
          if (0 === i2) i2 = 1 - d;
          else {
            if (i2 === c2) return u3 ? NaN : 1 / 0 * (o3 ? -1 : 1);
            u3 += Math.pow(2, r3), i2 -= d;
          }
          return (o3 ? -1 : 1) * u3 * Math.pow(2, i2 - r3);
        }, f.write = function(e4, t4, l2, n3, r3, c2) {
          var o3, i2, u3 = 8 * c2 - r3 - 1, s3 = (1 << u3) - 1, a3 = s3 >> 1, d = 23 === r3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n3 ? 0 : c2 - 1, h = n3 ? 1 : -1, c2 = t4 < 0 || 0 === t4 && 1 / t4 < 0 ? 1 : 0;
          for (t4 = Math.abs(t4), isNaN(t4) || t4 === 1 / 0 ? (i2 = isNaN(t4) ? 1 : 0, o3 = s3) : (o3 = Math.floor(Math.log(t4) / Math.LN2), t4 * (n3 = Math.pow(2, -o3)) < 1 && (o3--, n3 *= 2), 2 <= (t4 += 1 <= o3 + a3 ? d / n3 : d * Math.pow(2, 1 - a3)) * n3 && (o3++, n3 /= 2), s3 <= o3 + a3 ? (i2 = 0, o3 = s3) : 1 <= o3 + a3 ? (i2 = (t4 * n3 - 1) * Math.pow(2, r3), o3 += a3) : (i2 = t4 * Math.pow(2, a3 - 1) * Math.pow(2, r3), o3 = 0)); 8 <= r3; e4[l2 + f2] = 255 & i2, f2 += h, i2 /= 256, r3 -= 8) ;
          for (o3 = o3 << r3 | i2, u3 += r3; 0 < u3; e4[l2 + f2] = 255 & o3, f2 += h, o3 /= 256, u3 -= 8) ;
          e4[l2 + f2 - h] |= 128 * c2;
        };
      }.call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
    }, { buffer: 3, lYpoI2: 11 }], 11: [function(e2, h, t2) {
      !function(e3, t3, n2, r2, o2, f, l2, c2, d) {
        var i, u2, s2;
        function a2() {
        }
        (e3 = h.exports = {}).nextTick = (u2 = "undefined" != typeof window && window.setImmediate, s2 = "undefined" != typeof window && window.postMessage && window.addEventListener, u2 ? function(e4) {
          return window.setImmediate(e4);
        } : s2 ? (i = [], window.addEventListener("message", function(e4) {
          var t4 = e4.source;
          t4 !== window && null !== t4 || "process-tick" !== e4.data || (e4.stopPropagation(), 0 < i.length && i.shift()());
        }, true), function(e4) {
          i.push(e4), window.postMessage("process-tick", "*");
        }) : function(e4) {
          setTimeout(e4, 0);
        }), e3.title = "browser", e3.browser = true, e3.env = {}, e3.argv = [], e3.on = a2, e3.addListener = a2, e3.once = a2, e3.off = a2, e3.removeListener = a2, e3.removeAllListeners = a2, e3.emit = a2, e3.binding = function(e4) {
          throw new Error("process.binding is not supported");
        }, e3.cwd = function() {
          return "/";
        }, e3.chdir = function(e4) {
          throw new Error("process.chdir is not supported");
        };
      }.call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
    }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
  });
})(object_hash);
var object_hashExports = object_hash.exports;
const hash$2 = /* @__PURE__ */ getDefaultExportFromCjs$1(object_hashExports);
function debounce$3(func, wait, immediate2) {
  var timeout2, args, context, timestamp, result;
  if (null == wait) wait = 100;
  function later() {
    var last = Date.now() - timestamp;
    if (last < wait && last >= 0) {
      timeout2 = setTimeout(later, wait - last);
    } else {
      timeout2 = null;
      if (!immediate2) {
        result = func.apply(context, args);
        context = args = null;
      }
    }
  }
  var debounced = function() {
    context = this;
    args = arguments;
    timestamp = Date.now();
    var callNow = immediate2 && !timeout2;
    if (!timeout2) timeout2 = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }
    return result;
  };
  debounced.clear = function() {
    if (timeout2) {
      clearTimeout(timeout2);
      timeout2 = null;
    }
  };
  debounced.flush = function() {
    if (timeout2) {
      result = func.apply(context, args);
      context = args = null;
      clearTimeout(timeout2);
      timeout2 = null;
    }
  };
  return debounced;
}
debounce$3.debounce = debounce$3;
var debounce_1 = debounce$3;
const createDebounce = /* @__PURE__ */ getDefaultExportFromCjs$1(debounce_1);
const { useState: useState$5, useRef: useRef$6, useEffect: useEffect$6, useMemo: useMemo$4 } = await importShared("react");
function useMeasure(_temp11) {
  let {
    debounce: debounce2,
    scroll: scroll2,
    polyfill,
    offsetSize
  } = {
    debounce: 0,
    scroll: false,
    offsetSize: false
  };
  const ResizeObserver = polyfill || (typeof window === "undefined" ? class ResizeObserver {
  } : window.ResizeObserver);
  if (!ResizeObserver) {
    throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  }
  const [bounds, set2] = useState$5({
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    bottom: 0,
    right: 0,
    x: 0,
    y: 0
  });
  const state = useRef$6({
    element: null,
    scrollContainers: null,
    resizeObserver: null,
    lastBounds: bounds
  });
  const scrollDebounce = debounce2 ? typeof debounce2 === "number" ? debounce2 : debounce2.scroll : null;
  const resizeDebounce = debounce2 ? typeof debounce2 === "number" ? debounce2 : debounce2.resize : null;
  const mounted = useRef$6(false);
  useEffect$6(() => {
    mounted.current = true;
    return () => void (mounted.current = false);
  });
  const [forceRefresh, resizeChange, scrollChange] = useMemo$4(() => {
    const callback = () => {
      if (!state.current.element) return;
      const {
        left: left2,
        top: top2,
        width,
        height,
        bottom: bottom2,
        right: right2,
        x,
        y
      } = state.current.element.getBoundingClientRect();
      const size2 = {
        left: left2,
        top: top2,
        width,
        height,
        bottom: bottom2,
        right: right2,
        x,
        y
      };
      if (state.current.element instanceof HTMLElement && offsetSize) {
        size2.height = state.current.element.offsetHeight;
        size2.width = state.current.element.offsetWidth;
      }
      Object.freeze(size2);
      if (mounted.current && !areBoundsEqual(state.current.lastBounds, size2)) set2(state.current.lastBounds = size2);
    };
    return [callback, resizeDebounce ? createDebounce(callback, resizeDebounce) : callback, scrollDebounce ? createDebounce(callback, scrollDebounce) : callback];
  }, [set2, offsetSize, scrollDebounce, resizeDebounce]);
  function removeListeners() {
    if (state.current.scrollContainers) {
      state.current.scrollContainers.forEach((element) => element.removeEventListener("scroll", scrollChange, true));
      state.current.scrollContainers = null;
    }
    if (state.current.resizeObserver) {
      state.current.resizeObserver.disconnect();
      state.current.resizeObserver = null;
    }
  }
  function addListeners() {
    if (!state.current.element) return;
    state.current.resizeObserver = new ResizeObserver(scrollChange);
    state.current.resizeObserver.observe(state.current.element);
    if (scroll2 && state.current.scrollContainers) {
      state.current.scrollContainers.forEach((scrollContainer2) => scrollContainer2.addEventListener("scroll", scrollChange, {
        capture: true,
        passive: true
      }));
    }
  }
  const ref = (node) => {
    if (!node || node === state.current.element) return;
    removeListeners();
    state.current.element = node;
    state.current.scrollContainers = findScrollContainers(node);
    addListeners();
  };
  useOnWindowScroll(scrollChange, Boolean(scroll2));
  useOnWindowResize(resizeChange);
  useEffect$6(() => {
    removeListeners();
    addListeners();
  }, [scroll2, scrollChange, resizeChange]);
  useEffect$6(() => removeListeners, []);
  return [ref, bounds, forceRefresh];
}
function useOnWindowResize(onWindowResize) {
  useEffect$6(() => {
    const cb = onWindowResize;
    window.addEventListener("resize", cb);
    return () => void window.removeEventListener("resize", cb);
  }, [onWindowResize]);
}
function useOnWindowScroll(onScroll, enabled) {
  useEffect$6(() => {
    if (enabled) {
      const cb = onScroll;
      window.addEventListener("scroll", cb, {
        capture: true,
        passive: true
      });
      return () => void window.removeEventListener("scroll", cb, true);
    }
  }, [onScroll, enabled]);
}
function findScrollContainers(element) {
  const result = [];
  if (!element || element === document.body) return result;
  const {
    overflow,
    overflowX,
    overflowY
  } = window.getComputedStyle(element);
  if ([overflow, overflowX, overflowY].some((prop) => prop === "auto" || prop === "scroll")) result.push(element);
  return [...result, ...findScrollContainers(element.parentElement)];
}
const keys$1 = ["x", "y", "top", "bottom", "left", "right", "width", "height"];
const areBoundsEqual = (a2, b) => keys$1.every((key) => a2[key] === b[key]);
function formatProdErrorMessage(code2) {
  return `Minified Redux error #${code2}; visit https://redux.js.org/Errors?code=${code2} for the full message or use the non-minified dev environment for full errors. `;
}
var $$observable = /* @__PURE__ */ (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
var symbol_observable_default = $$observable;
var randomString$1 = () => Math.random().toString(36).substring(7).split("").join(".");
var ActionTypes = {
  INIT: `@@redux/INIT${/* @__PURE__ */ randomString$1()}`,
  REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString$1()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString$1()}`
};
var actionTypes_default = ActionTypes;
function isPlainObject$2(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  let proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
}
function createStore$1(reducer2, preloadedState, enhancer) {
  if (typeof reducer2 !== "function") {
    throw new Error(formatProdErrorMessage(2));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(formatProdErrorMessage(0));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(formatProdErrorMessage(1));
    }
    return enhancer(createStore$1)(reducer2, preloadedState);
  }
  let currentReducer = reducer2;
  let currentState = preloadedState;
  let currentListeners = /* @__PURE__ */ new Map();
  let nextListeners = currentListeners;
  let listenerIdCounter = 0;
  let isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = /* @__PURE__ */ new Map();
      currentListeners.forEach((listener, key) => {
        nextListeners.set(key, listener);
      });
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(3));
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(formatProdErrorMessage(4));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(5));
    }
    let isSubscribed = true;
    ensureCanMutateNextListeners();
    const listenerId = listenerIdCounter++;
    nextListeners.set(listenerId, listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage(6));
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      nextListeners.delete(listenerId);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject$2(action)) {
      throw new Error(formatProdErrorMessage(7));
    }
    if (typeof action.type === "undefined") {
      throw new Error(formatProdErrorMessage(8));
    }
    if (typeof action.type !== "string") {
      throw new Error(formatProdErrorMessage(17));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(9));
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    const listeners2 = currentListeners = nextListeners;
    listeners2.forEach((listener) => {
      listener();
    });
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(formatProdErrorMessage(10));
    }
    currentReducer = nextReducer;
    dispatch({
      type: actionTypes_default.REPLACE
    });
  }
  function observable() {
    const outerSubscribe = subscribe;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(formatProdErrorMessage(11));
        }
        function observeState() {
          const observerAsObserver = observer;
          if (observerAsObserver.next) {
            observerAsObserver.next(getState());
          }
        }
        observeState();
        const unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      },
      [symbol_observable_default]() {
        return this;
      }
    };
  }
  dispatch({
    type: actionTypes_default.INIT
  });
  const store = {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [symbol_observable_default]: observable
  };
  return store;
}
function bindActionCreator(actionCreator, dispatch) {
  return function(...args) {
    return dispatch(actionCreator.apply(this, args));
  };
}
function bindActionCreators$1(actionCreators, dispatch) {
  if (typeof actionCreators === "function") {
    return bindActionCreator(actionCreators, dispatch);
  }
  if (typeof actionCreators !== "object" || actionCreators === null) {
    throw new Error(formatProdErrorMessage(16));
  }
  const boundActionCreators = {};
  for (const key in actionCreators) {
    const actionCreator = actionCreators[key];
    if (typeof actionCreator === "function") {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}
function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce((a2, b) => (...args) => a2(b(...args)));
}
function applyMiddleware(...middlewares) {
  return (createStore2) => (reducer2, preloadedState) => {
    const store = createStore2(reducer2, preloadedState);
    let dispatch = () => {
      throw new Error(formatProdErrorMessage(15));
    };
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (action, ...args) => dispatch(action, ...args)
    };
    const chain = middlewares.map((middleware) => middleware(middlewareAPI));
    dispatch = compose(...chain)(store.dispatch);
    return {
      ...store,
      dispatch
    };
  };
}
var useSyncExternalStoreWithSelector_production = {};
/**
 * @license React
 * use-sync-external-store-with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var React$5 = reactExports;
function is$1(x, y) {
  return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
}
var objectIs = "function" === typeof Object.is ? Object.is : is$1, useSyncExternalStore = React$5.useSyncExternalStore, useRef$5 = React$5.useRef, useEffect$5 = React$5.useEffect, useMemo$3 = React$5.useMemo, useDebugValue$1 = React$5.useDebugValue;
useSyncExternalStoreWithSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual2) {
  var instRef = useRef$5(null);
  if (null === instRef.current) {
    var inst = { hasValue: false, value: null };
    instRef.current = inst;
  } else inst = instRef.current;
  instRef = useMemo$3(
    function() {
      function memoizedSelector(nextSnapshot) {
        if (!hasMemo) {
          hasMemo = true;
          memoizedSnapshot = nextSnapshot;
          nextSnapshot = selector(nextSnapshot);
          if (void 0 !== isEqual2 && inst.hasValue) {
            var currentSelection = inst.value;
            if (isEqual2(currentSelection, nextSnapshot))
              return memoizedSelection = currentSelection;
          }
          return memoizedSelection = nextSnapshot;
        }
        currentSelection = memoizedSelection;
        if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
        var nextSelection = selector(nextSnapshot);
        if (void 0 !== isEqual2 && isEqual2(currentSelection, nextSelection))
          return memoizedSnapshot = nextSnapshot, currentSelection;
        memoizedSnapshot = nextSnapshot;
        return memoizedSelection = nextSelection;
      }
      var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
      return [
        function() {
          return memoizedSelector(getSnapshot());
        },
        null === maybeGetServerSnapshot ? void 0 : function() {
          return memoizedSelector(maybeGetServerSnapshot());
        }
      ];
    },
    [getSnapshot, getServerSnapshot, selector, isEqual2]
  );
  var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
  useEffect$5(
    function() {
      inst.hasValue = true;
      inst.value = value;
    },
    [value]
  );
  useDebugValue$1(value);
  return value;
};
const React$4 = await importShared("react");
var IS_REACT_19 = /* @__PURE__ */ React$4.version.startsWith("19");
var REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for(
  IS_REACT_19 ? "react.transitional.element" : "react.element"
);
var REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal");
var REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment");
var REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode");
var REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for("react.profiler");
var REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for("react.consumer");
var REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.context");
var REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref");
var REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for("react.suspense");
var REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for(
  "react.suspense_list"
);
var REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo");
var REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for("react.lazy");
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Memo = REACT_MEMO_TYPE;
function typeOf(object2) {
  if (typeof object2 === "object" && object2 !== null) {
    const { $$typeof } = object2;
    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        switch (object2 = object2.type, object2) {
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
          case REACT_SUSPENSE_LIST_TYPE:
            return object2;
          default:
            switch (object2 = object2 && object2.$$typeof, object2) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
                return object2;
              case REACT_CONSUMER_TYPE:
                return object2;
              default:
                return $$typeof;
            }
        }
      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }
}
function isMemo(object2) {
  return typeOf(object2) === REACT_MEMO_TYPE;
}
function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps2, mergeProps, dispatch, {
  areStatesEqual,
  areOwnPropsEqual,
  areStatePropsEqual
}) {
  let hasRunAtLeastOnce = false;
  let state;
  let ownProps;
  let stateProps;
  let dispatchProps;
  let mergedProps;
  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps2(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }
  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps2.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps2(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps)
      stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps2.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps2(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewState() {
    const nextStateProps = mapStateToProps(state, ownProps);
    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;
    if (statePropsChanged)
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleSubsequentCalls(nextState, nextOwnProps) {
    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    const stateChanged = !areStatesEqual(
      nextState,
      state,
      nextOwnProps,
      ownProps
    );
    state = nextState;
    ownProps = nextOwnProps;
    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
    if (propsChanged) return handleNewProps();
    if (stateChanged) return handleNewState();
    return mergedProps;
  }
  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}
function finalPropsSelectorFactory(dispatch, {
  initMapStateToProps,
  initMapDispatchToProps,
  initMergeProps,
  ...options
}) {
  const mapStateToProps = initMapStateToProps(dispatch, options);
  const mapDispatchToProps2 = initMapDispatchToProps(dispatch, options);
  const mergeProps = initMergeProps(dispatch, options);
  return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps2, mergeProps, dispatch, options);
}
function bindActionCreators(actionCreators, dispatch) {
  const boundActionCreators = {};
  for (const key in actionCreators) {
    const actionCreator = actionCreators[key];
    if (typeof actionCreator === "function") {
      boundActionCreators[key] = (...args) => dispatch(actionCreator(...args));
    }
  }
  return boundActionCreators;
}
function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch) {
    const constant = getConstant(dispatch);
    function constantSelector() {
      return constant;
    }
    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
}
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, { displayName }) {
    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);
    };
    proxy.dependsOnOwnProps = true;
    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      let props = proxy(stateOrDispatch, ownProps);
      if (typeof props === "function") {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }
      return props;
    };
    return proxy;
  };
}
function createInvalidArgFactory(arg, name) {
  return (dispatch, options) => {
    throw new Error(
      `Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`
    );
  };
}
function mapDispatchToPropsFactory(mapDispatchToProps2) {
  return mapDispatchToProps2 && typeof mapDispatchToProps2 === "object" ? wrapMapToPropsConstant(
    (dispatch) => (
      // @ts-ignore
      bindActionCreators(mapDispatchToProps2, dispatch)
    )
  ) : !mapDispatchToProps2 ? wrapMapToPropsConstant((dispatch) => ({
    dispatch
  })) : typeof mapDispatchToProps2 === "function" ? (
    // @ts-ignore
    wrapMapToPropsFunc(mapDispatchToProps2)
  ) : createInvalidArgFactory(mapDispatchToProps2, "mapDispatchToProps");
}
function mapStateToPropsFactory(mapStateToProps) {
  return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : typeof mapStateToProps === "function" ? (
    // @ts-ignore
    wrapMapToPropsFunc(mapStateToProps)
  ) : createInvalidArgFactory(mapStateToProps, "mapStateToProps");
}
function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return { ...ownProps, ...stateProps, ...dispatchProps };
}
function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(dispatch, { displayName, areMergedPropsEqual }) {
    let hasRunOnce = false;
    let mergedProps;
    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      if (hasRunOnce) {
        if (!areMergedPropsEqual(nextMergedProps, mergedProps))
          mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;
      }
      return mergedProps;
    };
  };
}
function mergePropsFactory(mergeProps) {
  return !mergeProps ? () => defaultMergeProps : typeof mergeProps === "function" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, "mergeProps");
}
function defaultNoopBatch(callback) {
  callback();
}
function createListenerCollection() {
  let first2 = null;
  let last = null;
  return {
    clear() {
      first2 = null;
      last = null;
    },
    notify() {
      defaultNoopBatch(() => {
        let listener = first2;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get() {
      const listeners2 = [];
      let listener = first2;
      while (listener) {
        listeners2.push(listener);
        listener = listener.next;
      }
      return listeners2;
    },
    subscribe(callback) {
      let isSubscribed = true;
      const listener = last = {
        callback,
        next: null,
        prev: last
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first2 = listener;
      }
      return function unsubscribe() {
        if (!isSubscribed || first2 === null) return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first2 = listener.next;
        }
      };
    }
  };
}
var nullListeners = {
  notify() {
  },
  get: () => []
};
function createSubscription(store, parentSub) {
  let unsubscribe;
  let listeners2 = nullListeners;
  let subscriptionsAmount = 0;
  let selfSubscribed = false;
  function addNestedSub(listener) {
    trySubscribe();
    const cleanupListener = listeners2.subscribe(listener);
    let removed = false;
    return () => {
      if (!removed) {
        removed = true;
        cleanupListener();
        tryUnsubscribe();
      }
    };
  }
  function notifyNestedSubs() {
    listeners2.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return selfSubscribed;
  }
  function trySubscribe() {
    subscriptionsAmount++;
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
      listeners2 = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    subscriptionsAmount--;
    if (unsubscribe && subscriptionsAmount === 0) {
      unsubscribe();
      unsubscribe = void 0;
      listeners2.clear();
      listeners2 = nullListeners;
    }
  }
  function trySubscribeSelf() {
    if (!selfSubscribed) {
      selfSubscribed = true;
      trySubscribe();
    }
  }
  function tryUnsubscribeSelf() {
    if (selfSubscribed) {
      selfSubscribed = false;
      tryUnsubscribe();
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe: trySubscribeSelf,
    tryUnsubscribe: tryUnsubscribeSelf,
    getListeners: () => listeners2
  };
  return subscription;
}
var canUseDOM = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var isDOM = /* @__PURE__ */ canUseDOM();
var isRunningInReactNative = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
var isReactNative = /* @__PURE__ */ isRunningInReactNative();
var getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? React$4.useLayoutEffect : React$4.useEffect;
var useIsomorphicLayoutEffect$2 = /* @__PURE__ */ getUseIsomorphicLayoutEffect();
function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function shallowEqual(objA, objB) {
  if (is(objA, objB)) return true;
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) return false;
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  $$typeof: true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  $$typeof: true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {
  [ForwardRef]: FORWARD_REF_STATICS,
  [Memo]: MEMO_STATICS
};
function getStatics(component) {
  if (isMemo(component)) {
    return MEMO_STATICS;
  }
  return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
}
var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent) {
  if (typeof sourceComponent !== "string") {
    if (objectPrototype) {
      const inheritedComponent = getPrototypeOf(sourceComponent);
      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent);
      }
    }
    let keys2 = getOwnPropertyNames(sourceComponent);
    if (getOwnPropertySymbols) {
      keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent));
    }
    const targetStatics = getStatics(targetComponent);
    const sourceStatics = getStatics(sourceComponent);
    for (let i = 0; i < keys2.length; ++i) {
      const key = keys2[i];
      if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        const descriptor = getOwnPropertyDescriptor(sourceComponent, key);
        try {
          defineProperty(targetComponent, key, descriptor);
        } catch (e2) {
        }
      }
    }
  }
  return targetComponent;
}
var ContextKey = /* @__PURE__ */ Symbol.for(`react-redux-context`);
var gT = typeof globalThis !== "undefined" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function getContext() {
  if (!React$4.createContext) return {};
  const contextMap = gT[ContextKey] ??= /* @__PURE__ */ new Map();
  let realContext = contextMap.get(React$4.createContext);
  if (!realContext) {
    realContext = React$4.createContext(
      null
    );
    contextMap.set(React$4.createContext, realContext);
  }
  return realContext;
}
var ReactReduxContext = /* @__PURE__ */ getContext();
var NO_SUBSCRIPTION_ARRAY = [null, null];
function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
  useIsomorphicLayoutEffect$2(() => effectFunc(...effectArgs), dependencies);
}
function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {
  lastWrapperProps.current = wrapperProps;
  renderIsScheduled.current = false;
  if (childPropsFromStoreUpdate.current) {
    childPropsFromStoreUpdate.current = null;
    notifyNestedSubs();
  }
}
function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {
  if (!shouldHandleStateChanges) return () => {
  };
  let didUnsubscribe = false;
  let lastThrownError = null;
  const checkForUpdates = () => {
    if (didUnsubscribe || !isMounted.current) {
      return;
    }
    const latestStoreState = store.getState();
    let newChildProps, error;
    try {
      newChildProps = childPropsSelector(
        latestStoreState,
        lastWrapperProps.current
      );
    } catch (e2) {
      error = e2;
      lastThrownError = e2;
    }
    if (!error) {
      lastThrownError = null;
    }
    if (newChildProps === lastChildProps.current) {
      if (!renderIsScheduled.current) {
        notifyNestedSubs();
      }
    } else {
      lastChildProps.current = newChildProps;
      childPropsFromStoreUpdate.current = newChildProps;
      renderIsScheduled.current = true;
      additionalSubscribeListener();
    }
  };
  subscription.onStateChange = checkForUpdates;
  subscription.trySubscribe();
  checkForUpdates();
  const unsubscribeWrapper = () => {
    didUnsubscribe = true;
    subscription.tryUnsubscribe();
    subscription.onStateChange = null;
    if (lastThrownError) {
      throw lastThrownError;
    }
  };
  return unsubscribeWrapper;
}
function strictEqual(a2, b) {
  return a2 === b;
}
function connect(mapStateToProps, mapDispatchToProps2, mergeProps, {
  // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.
  // @ts-ignore
  pure,
  areStatesEqual = strictEqual,
  areOwnPropsEqual = shallowEqual,
  areStatePropsEqual = shallowEqual,
  areMergedPropsEqual = shallowEqual,
  // use React's forwardRef to expose a ref of the wrapped component
  forwardRef: forwardRef2 = false,
  // the context consumer to use
  context = ReactReduxContext
} = {}) {
  const Context = context;
  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);
  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps2);
  const initMergeProps = mergePropsFactory(mergeProps);
  const shouldHandleStateChanges = Boolean(mapStateToProps);
  const wrapWithConnect = (WrappedComponent) => {
    const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
    const displayName = `Connect(${wrappedComponentName})`;
    const selectorFactoryOptions = {
      shouldHandleStateChanges,
      displayName,
      wrappedComponentName,
      WrappedComponent,
      // @ts-ignore
      initMapStateToProps,
      initMapDispatchToProps,
      initMergeProps,
      areStatesEqual,
      areStatePropsEqual,
      areOwnPropsEqual,
      areMergedPropsEqual
    };
    function ConnectFunction(props) {
      const [propsContext, reactReduxForwardedRef, wrapperProps] = React$4.useMemo(() => {
        const { reactReduxForwardedRef: reactReduxForwardedRef2, ...wrapperProps2 } = props;
        return [props.context, reactReduxForwardedRef2, wrapperProps2];
      }, [props]);
      const ContextToUse = React$4.useMemo(() => {
        let ResultContext = Context;
        if (propsContext?.Consumer) ;
        return ResultContext;
      }, [propsContext, Context]);
      const contextValue = React$4.useContext(ContextToUse);
      const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
      const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);
      const store = didStoreComeFromProps ? props.store : contextValue.store;
      const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;
      const childPropsSelector = React$4.useMemo(() => {
        return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);
      }, [store]);
      const [subscription, notifyNestedSubs] = React$4.useMemo(() => {
        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;
        const subscription2 = createSubscription(
          store,
          didStoreComeFromProps ? void 0 : contextValue.subscription
        );
        const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);
        return [subscription2, notifyNestedSubs2];
      }, [store, didStoreComeFromProps, contextValue]);
      const overriddenContextValue = React$4.useMemo(() => {
        if (didStoreComeFromProps) {
          return contextValue;
        }
        return {
          ...contextValue,
          subscription
        };
      }, [didStoreComeFromProps, contextValue, subscription]);
      const lastChildProps = React$4.useRef(void 0);
      const lastWrapperProps = React$4.useRef(wrapperProps);
      const childPropsFromStoreUpdate = React$4.useRef(void 0);
      const renderIsScheduled = React$4.useRef(false);
      const isMounted = React$4.useRef(false);
      const latestSubscriptionCallbackError = React$4.useRef(
        void 0
      );
      useIsomorphicLayoutEffect$2(() => {
        isMounted.current = true;
        return () => {
          isMounted.current = false;
        };
      }, []);
      const actualChildPropsSelector = React$4.useMemo(() => {
        const selector = () => {
          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
            return childPropsFromStoreUpdate.current;
          }
          return childPropsSelector(store.getState(), wrapperProps);
        };
        return selector;
      }, [store, wrapperProps]);
      const subscribeForReact = React$4.useMemo(() => {
        const subscribe = (reactListener) => {
          if (!subscription) {
            return () => {
            };
          }
          return subscribeUpdates(
            shouldHandleStateChanges,
            store,
            subscription,
            // @ts-ignore
            childPropsSelector,
            lastWrapperProps,
            lastChildProps,
            renderIsScheduled,
            isMounted,
            childPropsFromStoreUpdate,
            notifyNestedSubs,
            reactListener
          );
        };
        return subscribe;
      }, [subscription]);
      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [
        lastWrapperProps,
        lastChildProps,
        renderIsScheduled,
        wrapperProps,
        childPropsFromStoreUpdate,
        notifyNestedSubs
      ]);
      let actualChildProps;
      try {
        actualChildProps = React$4.useSyncExternalStore(
          // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing
          subscribeForReact,
          // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,
          // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.
          actualChildPropsSelector,
          getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector
        );
      } catch (err) {
        if (latestSubscriptionCallbackError.current) {
          err.message += `
The error may be correlated with this previous error:
${latestSubscriptionCallbackError.current.stack}

`;
        }
        throw err;
      }
      useIsomorphicLayoutEffect$2(() => {
        latestSubscriptionCallbackError.current = void 0;
        childPropsFromStoreUpdate.current = void 0;
        lastChildProps.current = actualChildProps;
      });
      const renderedWrappedComponent = React$4.useMemo(() => {
        return (
          // @ts-ignore
          /* @__PURE__ */ React$4.createElement(
            WrappedComponent,
            {
              ...actualChildProps,
              ref: reactReduxForwardedRef
            }
          )
        );
      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);
      const renderedChild = React$4.useMemo(() => {
        if (shouldHandleStateChanges) {
          return /* @__PURE__ */ React$4.createElement(ContextToUse.Provider, { value: overriddenContextValue }, renderedWrappedComponent);
        }
        return renderedWrappedComponent;
      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
      return renderedChild;
    }
    const _Connect = React$4.memo(ConnectFunction);
    const Connect = _Connect;
    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = ConnectFunction.displayName = displayName;
    if (forwardRef2) {
      const _forwarded = React$4.forwardRef(
        function forwardConnectRef(props, ref) {
          return /* @__PURE__ */ React$4.createElement(Connect, { ...props, reactReduxForwardedRef: ref });
        }
      );
      const forwarded = _forwarded;
      forwarded.displayName = displayName;
      forwarded.WrappedComponent = WrappedComponent;
      return /* @__PURE__ */ hoistNonReactStatics(forwarded, WrappedComponent);
    }
    return /* @__PURE__ */ hoistNonReactStatics(Connect, WrappedComponent);
  };
  return wrapWithConnect;
}
var connect_default = connect;
function Provider(providerProps) {
  const { children, context, serverState, store } = providerProps;
  const contextValue = React$4.useMemo(() => {
    const subscription = createSubscription(store);
    const baseContextValue = {
      store,
      subscription,
      getServerState: serverState ? () => serverState : void 0
    };
    {
      return baseContextValue;
    }
  }, [store, serverState]);
  const previousState = React$4.useMemo(() => store.getState(), [store]);
  useIsomorphicLayoutEffect$2(() => {
    const { subscription } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context = context || ReactReduxContext;
  return /* @__PURE__ */ React$4.createElement(Context.Provider, { value: contextValue }, children);
}
var Provider_default = Provider;
const { useState: useState$4, useRef: useRef$4, useEffect: useEffect$4 } = await importShared("react");
function areInputsEqual$2(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (newInputs[i] !== lastInputs[i]) {
      return false;
    }
  }
  return true;
}
function useMemoOne(getResult, inputs) {
  var initial = useState$4(function() {
    return {
      inputs,
      result: getResult()
    };
  })[0];
  var isFirstRun = useRef$4(true);
  var committed = useRef$4(initial);
  var useCache = isFirstRun.current || Boolean(inputs && committed.current.inputs && areInputsEqual$2(inputs, committed.current.inputs));
  var cache = useCache ? committed.current : {
    inputs,
    result: getResult()
  };
  useEffect$4(function() {
    isFirstRun.current = false;
    committed.current = cache;
  }, [cache]);
  return cache.result;
}
function useCallbackOne(callback, inputs) {
  return useMemoOne(function() {
    return callback;
  }, inputs);
}
var useMemo$2 = useMemoOne;
var useCallback$1 = useCallbackOne;
var prefix$2 = "Invariant failed";
function invariant$1(condition, message2) {
  {
    throw new Error(prefix$2);
  }
}
var getRect = function getRect2(_ref) {
  var top2 = _ref.top, right2 = _ref.right, bottom2 = _ref.bottom, left2 = _ref.left;
  var width = right2 - left2;
  var height = bottom2 - top2;
  var rect = {
    top: top2,
    right: right2,
    bottom: bottom2,
    left: left2,
    width,
    height,
    x: left2,
    y: top2,
    center: {
      x: (right2 + left2) / 2,
      y: (bottom2 + top2) / 2
    }
  };
  return rect;
};
var expand = function expand2(target, expandBy) {
  return {
    top: target.top - expandBy.top,
    left: target.left - expandBy.left,
    bottom: target.bottom + expandBy.bottom,
    right: target.right + expandBy.right
  };
};
var shrink = function shrink2(target, shrinkBy) {
  return {
    top: target.top + shrinkBy.top,
    left: target.left + shrinkBy.left,
    bottom: target.bottom - shrinkBy.bottom,
    right: target.right - shrinkBy.right
  };
};
var shift$1 = function shift2(target, shiftBy) {
  return {
    top: target.top + shiftBy.y,
    left: target.left + shiftBy.x,
    bottom: target.bottom + shiftBy.y,
    right: target.right + shiftBy.x
  };
};
var noSpacing$1 = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
var createBox = function createBox2(_ref2) {
  var borderBox = _ref2.borderBox, _ref2$margin = _ref2.margin, margin = _ref2$margin === void 0 ? noSpacing$1 : _ref2$margin, _ref2$border = _ref2.border, border = _ref2$border === void 0 ? noSpacing$1 : _ref2$border, _ref2$padding = _ref2.padding, padding = _ref2$padding === void 0 ? noSpacing$1 : _ref2$padding;
  var marginBox = getRect(expand(borderBox, margin));
  var paddingBox = getRect(shrink(borderBox, border));
  var contentBox = getRect(shrink(paddingBox, padding));
  return {
    marginBox,
    borderBox: getRect(borderBox),
    paddingBox,
    contentBox,
    margin,
    border,
    padding
  };
};
var parse = function parse2(raw) {
  var value = raw.slice(0, -2);
  var suffix = raw.slice(-2);
  if (suffix !== "px") {
    return 0;
  }
  var result = Number(value);
  !!isNaN(result) ? invariant$1() : void 0;
  return result;
};
var getWindowScroll$2 = function getWindowScroll2() {
  return {
    x: window.pageXOffset,
    y: window.pageYOffset
  };
};
var offset$2 = function offset2(original, change) {
  var borderBox = original.borderBox, border = original.border, margin = original.margin, padding = original.padding;
  var shifted = shift$1(borderBox, change);
  return createBox({
    borderBox: shifted,
    border,
    margin,
    padding
  });
};
var withScroll = function withScroll2(original, scroll2) {
  if (scroll2 === void 0) {
    scroll2 = getWindowScroll$2();
  }
  return offset$2(original, scroll2);
};
var calculateBox = function calculateBox2(borderBox, styles2) {
  var margin = {
    top: parse(styles2.marginTop),
    right: parse(styles2.marginRight),
    bottom: parse(styles2.marginBottom),
    left: parse(styles2.marginLeft)
  };
  var padding = {
    top: parse(styles2.paddingTop),
    right: parse(styles2.paddingRight),
    bottom: parse(styles2.paddingBottom),
    left: parse(styles2.paddingLeft)
  };
  var border = {
    top: parse(styles2.borderTopWidth),
    right: parse(styles2.borderRightWidth),
    bottom: parse(styles2.borderBottomWidth),
    left: parse(styles2.borderLeftWidth)
  };
  return createBox({
    borderBox,
    margin,
    padding,
    border
  });
};
var getBox = function getBox2(el2) {
  var borderBox = el2.getBoundingClientRect();
  var styles2 = window.getComputedStyle(el2);
  return calculateBox(borderBox, styles2);
};
var safeIsNaN$1 = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual$3(first2, second) {
  if (first2 === second) {
    return true;
  }
  if (safeIsNaN$1(first2) && safeIsNaN$1(second)) {
    return true;
  }
  return false;
}
function areInputsEqual$1(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (!isEqual$3(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}
function memoizeOne$1(resultFn, isEqual2) {
  if (isEqual2 === void 0) {
    isEqual2 = areInputsEqual$1;
  }
  var cache = null;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (cache && cache.lastThis === this && isEqual2(newArgs, cache.lastArgs)) {
      return cache.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear() {
    cache = null;
  };
  return memoized;
}
var rafSchd = function rafSchd2(fn2) {
  var lastArgs = [];
  var frameId = null;
  var wrapperFn = function wrapperFn2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    lastArgs = args;
    if (frameId) {
      return;
    }
    frameId = requestAnimationFrame(function() {
      frameId = null;
      fn2.apply(void 0, lastArgs);
    });
  };
  wrapperFn.cancel = function() {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
  };
  return wrapperFn;
};
const React$3 = await importShared("react");
const { useLayoutEffect: useLayoutEffect$2, useEffect: useEffect$3, useRef: useRef$3, useState: useState$3, useContext: useContext$2 } = React$3;
const ReactDOM$1 = await importShared("react-dom");
const { flushSync: flushSync$1 } = ReactDOM$1;
function log(type, message2) {
  {
    return;
  }
}
log.bind(null, "warn");
log.bind(null, "error");
function noop$2() {
}
function getOptions(shared2, fromBinding) {
  return {
    ...shared2,
    ...fromBinding
  };
}
function bindEvents(el2, bindings, sharedOptions) {
  const unbindings = bindings.map((binding) => {
    const options = getOptions(sharedOptions, binding.options);
    el2.addEventListener(binding.eventName, binding.fn, options);
    return function unbind() {
      el2.removeEventListener(binding.eventName, binding.fn, options);
    };
  });
  return function unbindAll() {
    unbindings.forEach((unbind) => {
      unbind();
    });
  };
}
const prefix$1 = "Invariant failed";
class RbdInvariant extends Error {
}
RbdInvariant.prototype.toString = function toString2() {
  return this.message;
};
function invariant(condition, message2) {
  {
    throw new RbdInvariant(prefix$1);
  }
}
let ErrorBoundary$1 = class ErrorBoundary extends React$3.Component {
  constructor(...args) {
    super(...args);
    this.callbacks = null;
    this.unbind = noop$2;
    this.onWindowError = (event) => {
      const callbacks = this.getCallbacks();
      if (callbacks.isDragging()) {
        callbacks.tryAbort();
      }
      const err = event.error;
      if (err instanceof RbdInvariant) {
        event.preventDefault();
      }
    };
    this.getCallbacks = () => {
      if (!this.callbacks) {
        throw new Error("Unable to find AppCallbacks in <ErrorBoundary/>");
      }
      return this.callbacks;
    };
    this.setCallbacks = (callbacks) => {
      this.callbacks = callbacks;
    };
  }
  componentDidMount() {
    this.unbind = bindEvents(window, [{
      eventName: "error",
      fn: this.onWindowError
    }]);
  }
  componentDidCatch(err) {
    if (err instanceof RbdInvariant) {
      this.setState({});
      return;
    }
    throw err;
  }
  componentWillUnmount() {
    this.unbind();
  }
  render() {
    return this.props.children(this.setCallbacks);
  }
};
const dragHandleUsageInstructions = `
  Press space bar to start a drag.
  When dragging you can use the arrow keys to move the item around and escape to cancel.
  Some screen readers may require you to be in focus mode or to use your pass through key
`;
const position = (index2) => index2 + 1;
const onDragStart = (start2) => `
  You have lifted an item in position ${position(start2.source.index)}
`;
const withLocation = (source, destination) => {
  const isInHomeList = source.droppableId === destination.droppableId;
  const startPosition = position(source.index);
  const endPosition = position(destination.index);
  if (isInHomeList) {
    return `
      You have moved the item from position ${startPosition}
      to position ${endPosition}
    `;
  }
  return `
    You have moved the item from position ${startPosition}
    in list ${source.droppableId}
    to list ${destination.droppableId}
    in position ${endPosition}
  `;
};
const withCombine = (id2, source, combine2) => {
  const inHomeList = source.droppableId === combine2.droppableId;
  if (inHomeList) {
    return `
      The item ${id2}
      has been combined with ${combine2.draggableId}`;
  }
  return `
      The item ${id2}
      in list ${source.droppableId}
      has been combined with ${combine2.draggableId}
      in list ${combine2.droppableId}
    `;
};
const onDragUpdate = (update2) => {
  const location = update2.destination;
  if (location) {
    return withLocation(update2.source, location);
  }
  const combine2 = update2.combine;
  if (combine2) {
    return withCombine(update2.draggableId, update2.source, combine2);
  }
  return "You are over an area that cannot be dropped on";
};
const returnedToStart = (source) => `
  The item has returned to its starting position
  of ${position(source.index)}
`;
const onDragEnd = (result) => {
  if (result.reason === "CANCEL") {
    return `
      Movement cancelled.
      ${returnedToStart(result.source)}
    `;
  }
  const location = result.destination;
  const combine2 = result.combine;
  if (location) {
    return `
      You have dropped the item.
      ${withLocation(result.source, location)}
    `;
  }
  if (combine2) {
    return `
      You have dropped the item.
      ${withCombine(result.draggableId, result.source, combine2)}
    `;
  }
  return `
    The item has been dropped while not over a drop area.
    ${returnedToStart(result.source)}
  `;
};
const preset = {
  dragHandleUsageInstructions,
  onDragStart,
  onDragUpdate,
  onDragEnd
};
const origin = {
  x: 0,
  y: 0
};
const add = (point1, point2) => ({
  x: point1.x + point2.x,
  y: point1.y + point2.y
});
const subtract = (point1, point2) => ({
  x: point1.x - point2.x,
  y: point1.y - point2.y
});
const isEqual$1 = (point1, point2) => point1.x === point2.x && point1.y === point2.y;
const negate = (point) => ({
  x: point.x !== 0 ? -point.x : 0,
  y: point.y !== 0 ? -point.y : 0
});
const patch = (line, value, otherValue = 0) => {
  if (line === "x") {
    return {
      x: value,
      y: otherValue
    };
  }
  return {
    x: otherValue,
    y: value
  };
};
const distance = (point1, point2) => Math.sqrt((point2.x - point1.x) ** 2 + (point2.y - point1.y) ** 2);
const closest$1 = (target, points) => Math.min(...points.map((point) => distance(target, point)));
const apply$1 = (fn2) => (point) => ({
  x: fn2(point.x),
  y: fn2(point.y)
});
var executeClip = (frame, subject) => {
  const result = getRect({
    top: Math.max(subject.top, frame.top),
    right: Math.min(subject.right, frame.right),
    bottom: Math.min(subject.bottom, frame.bottom),
    left: Math.max(subject.left, frame.left)
  });
  if (result.width <= 0 || result.height <= 0) {
    return null;
  }
  return result;
};
const offsetByPosition = (spacing, point) => ({
  top: spacing.top + point.y,
  left: spacing.left + point.x,
  bottom: spacing.bottom + point.y,
  right: spacing.right + point.x
});
const getCorners = (spacing) => [{
  x: spacing.left,
  y: spacing.top
}, {
  x: spacing.right,
  y: spacing.top
}, {
  x: spacing.left,
  y: spacing.bottom
}, {
  x: spacing.right,
  y: spacing.bottom
}];
const noSpacing = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
const scroll$1 = (target, frame) => {
  if (!frame) {
    return target;
  }
  return offsetByPosition(target, frame.scroll.diff.displacement);
};
const increase = (target, axis, withPlaceholder) => {
  if (withPlaceholder && withPlaceholder.increasedBy) {
    return {
      ...target,
      [axis.end]: target[axis.end] + withPlaceholder.increasedBy[axis.line]
    };
  }
  return target;
};
const clip = (target, frame) => {
  if (frame && frame.shouldClipSubject) {
    return executeClip(frame.pageMarginBox, target);
  }
  return getRect(target);
};
var getSubject = ({
  page,
  withPlaceholder,
  axis,
  frame
}) => {
  const scrolled = scroll$1(page.marginBox, frame);
  const increased = increase(scrolled, axis, withPlaceholder);
  const clipped = clip(increased, frame);
  return {
    page,
    withPlaceholder,
    active: clipped
  };
};
var scrollDroppable = (droppable2, newScroll) => {
  !droppable2.frame ? invariant() : void 0;
  const scrollable = droppable2.frame;
  const scrollDiff = subtract(newScroll, scrollable.scroll.initial);
  const scrollDisplacement = negate(scrollDiff);
  const frame = {
    ...scrollable,
    scroll: {
      initial: scrollable.scroll.initial,
      current: newScroll,
      diff: {
        value: scrollDiff,
        displacement: scrollDisplacement
      },
      max: scrollable.scroll.max
    }
  };
  const subject = getSubject({
    page: droppable2.subject.page,
    withPlaceholder: droppable2.subject.withPlaceholder,
    axis: droppable2.axis,
    frame
  });
  const result = {
    ...droppable2,
    frame,
    subject
  };
  return result;
};
const toDroppableMap = memoizeOne$1((droppables) => droppables.reduce((previous, current) => {
  previous[current.descriptor.id] = current;
  return previous;
}, {}));
const toDraggableMap = memoizeOne$1((draggables) => draggables.reduce((previous, current) => {
  previous[current.descriptor.id] = current;
  return previous;
}, {}));
const toDroppableList = memoizeOne$1((droppables) => Object.values(droppables));
const toDraggableList = memoizeOne$1((draggables) => Object.values(draggables));
var getDraggablesInsideDroppable = memoizeOne$1((droppableId, draggables) => {
  const result = toDraggableList(draggables).filter((draggable2) => droppableId === draggable2.descriptor.droppableId).sort((a2, b) => a2.descriptor.index - b.descriptor.index);
  return result;
});
function tryGetDestination(impact) {
  if (impact.at && impact.at.type === "REORDER") {
    return impact.at.destination;
  }
  return null;
}
function tryGetCombine(impact) {
  if (impact.at && impact.at.type === "COMBINE") {
    return impact.at.combine;
  }
  return null;
}
var removeDraggableFromList = memoizeOne$1((remove, list) => list.filter((item) => item.descriptor.id !== remove.descriptor.id));
var moveToNextCombine = ({
  isMovingForward,
  draggable: draggable2,
  destination,
  insideDestination,
  previousImpact
}) => {
  if (!destination.isCombineEnabled) {
    return null;
  }
  const location = tryGetDestination(previousImpact);
  if (!location) {
    return null;
  }
  function getImpact(target) {
    const at = {
      type: "COMBINE",
      combine: {
        draggableId: target,
        droppableId: destination.descriptor.id
      }
    };
    return {
      ...previousImpact,
      at
    };
  }
  const all = previousImpact.displaced.all;
  const closestId = all.length ? all[0] : null;
  if (isMovingForward) {
    return closestId ? getImpact(closestId) : null;
  }
  const withoutDraggable = removeDraggableFromList(draggable2, insideDestination);
  if (!closestId) {
    if (!withoutDraggable.length) {
      return null;
    }
    const last = withoutDraggable[withoutDraggable.length - 1];
    return getImpact(last.descriptor.id);
  }
  const indexOfClosest = withoutDraggable.findIndex((d) => d.descriptor.id === closestId);
  !(indexOfClosest !== -1) ? invariant() : void 0;
  const proposedIndex = indexOfClosest - 1;
  if (proposedIndex < 0) {
    return null;
  }
  const before = withoutDraggable[proposedIndex];
  return getImpact(before.descriptor.id);
};
var isHomeOf = (draggable2, destination) => draggable2.descriptor.droppableId === destination.descriptor.id;
const noDisplacedBy = {
  point: origin,
  value: 0
};
const emptyGroups = {
  invisible: {},
  visible: {},
  all: []
};
const noImpact = {
  displaced: emptyGroups,
  displacedBy: noDisplacedBy,
  at: null
};
var isWithin = (lowerBound, upperBound) => (value) => lowerBound <= value && value <= upperBound;
var isPartiallyVisibleThroughFrame = (frame) => {
  const isWithinVertical = isWithin(frame.top, frame.bottom);
  const isWithinHorizontal = isWithin(frame.left, frame.right);
  return (subject) => {
    const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
    if (isContained) {
      return true;
    }
    const isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);
    const isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);
    const isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;
    if (isPartiallyContained) {
      return true;
    }
    const isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;
    const isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;
    const isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;
    if (isTargetBiggerThanFrame) {
      return true;
    }
    const isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;
    return isTargetBiggerOnOneAxis;
  };
};
var isTotallyVisibleThroughFrame = (frame) => {
  const isWithinVertical = isWithin(frame.top, frame.bottom);
  const isWithinHorizontal = isWithin(frame.left, frame.right);
  return (subject) => {
    const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
    return isContained;
  };
};
const vertical = {
  direction: "vertical",
  line: "y",
  crossAxisLine: "x",
  start: "top",
  end: "bottom",
  size: "height",
  crossAxisStart: "left",
  crossAxisEnd: "right",
  crossAxisSize: "width"
};
const horizontal = {
  direction: "horizontal",
  line: "x",
  crossAxisLine: "y",
  start: "left",
  end: "right",
  size: "width",
  crossAxisStart: "top",
  crossAxisEnd: "bottom",
  crossAxisSize: "height"
};
var isTotallyVisibleThroughFrameOnAxis = (axis) => (frame) => {
  const isWithinVertical = isWithin(frame.top, frame.bottom);
  const isWithinHorizontal = isWithin(frame.left, frame.right);
  return (subject) => {
    if (axis === vertical) {
      return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);
    }
    return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
  };
};
const getDroppableDisplaced = (target, destination) => {
  const displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;
  return offsetByPosition(target, displacement);
};
const isVisibleInDroppable = (target, destination, isVisibleThroughFrameFn) => {
  if (!destination.subject.active) {
    return false;
  }
  return isVisibleThroughFrameFn(destination.subject.active)(target);
};
const isVisibleInViewport = (target, viewport2, isVisibleThroughFrameFn) => isVisibleThroughFrameFn(viewport2)(target);
const isVisible$1 = ({
  target: toBeDisplaced,
  destination,
  viewport: viewport2,
  withDroppableDisplacement: withDroppableDisplacement2,
  isVisibleThroughFrameFn
}) => {
  const displacedTarget = withDroppableDisplacement2 ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;
  return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport2, isVisibleThroughFrameFn);
};
const isPartiallyVisible = (args) => isVisible$1({
  ...args,
  isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame
});
const isTotallyVisible = (args) => isVisible$1({
  ...args,
  isVisibleThroughFrameFn: isTotallyVisibleThroughFrame
});
const isTotallyVisibleOnAxis = (args) => isVisible$1({
  ...args,
  isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)
});
const getShouldAnimate = (id2, last, forceShouldAnimate) => {
  if (typeof forceShouldAnimate === "boolean") {
    return forceShouldAnimate;
  }
  if (!last) {
    return true;
  }
  const {
    invisible,
    visible
  } = last;
  if (invisible[id2]) {
    return false;
  }
  const previous = visible[id2];
  return previous ? previous.shouldAnimate : true;
};
function getTarget(draggable2, displacedBy) {
  const marginBox = draggable2.page.marginBox;
  const expandBy = {
    top: displacedBy.point.y,
    right: 0,
    bottom: 0,
    left: displacedBy.point.x
  };
  return getRect(expand(marginBox, expandBy));
}
function getDisplacementGroups({
  afterDragging,
  destination,
  displacedBy,
  viewport: viewport2,
  forceShouldAnimate,
  last
}) {
  return afterDragging.reduce(function process2(groups, draggable2) {
    const target = getTarget(draggable2, displacedBy);
    const id2 = draggable2.descriptor.id;
    groups.all.push(id2);
    const isVisible2 = isPartiallyVisible({
      target,
      destination,
      viewport: viewport2,
      withDroppableDisplacement: true
    });
    if (!isVisible2) {
      groups.invisible[draggable2.descriptor.id] = true;
      return groups;
    }
    const shouldAnimate = getShouldAnimate(id2, last, forceShouldAnimate);
    const displacement = {
      draggableId: id2,
      shouldAnimate
    };
    groups.visible[id2] = displacement;
    return groups;
  }, {
    all: [],
    visible: {},
    invisible: {}
  });
}
function getIndexOfLastItem(draggables, options) {
  if (!draggables.length) {
    return 0;
  }
  const indexOfLastItem = draggables[draggables.length - 1].descriptor.index;
  return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;
}
function goAtEnd({
  insideDestination,
  inHomeList,
  displacedBy,
  destination
}) {
  const newIndex = getIndexOfLastItem(insideDestination, {
    inHomeList
  });
  return {
    displaced: emptyGroups,
    displacedBy,
    at: {
      type: "REORDER",
      destination: {
        droppableId: destination.descriptor.id,
        index: newIndex
      }
    }
  };
}
function calculateReorderImpact({
  draggable: draggable2,
  insideDestination,
  destination,
  viewport: viewport2,
  displacedBy,
  last,
  index: index2,
  forceShouldAnimate
}) {
  const inHomeList = isHomeOf(draggable2, destination);
  if (index2 == null) {
    return goAtEnd({
      insideDestination,
      inHomeList,
      displacedBy,
      destination
    });
  }
  const match2 = insideDestination.find((item) => item.descriptor.index === index2);
  if (!match2) {
    return goAtEnd({
      insideDestination,
      inHomeList,
      displacedBy,
      destination
    });
  }
  const withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  const sliceFrom = insideDestination.indexOf(match2);
  const impacted = withoutDragging.slice(sliceFrom);
  const displaced = getDisplacementGroups({
    afterDragging: impacted,
    destination,
    displacedBy,
    last,
    viewport: viewport2.frame,
    forceShouldAnimate
  });
  return {
    displaced,
    displacedBy,
    at: {
      type: "REORDER",
      destination: {
        droppableId: destination.descriptor.id,
        index: index2
      }
    }
  };
}
function didStartAfterCritical(draggableId, afterCritical) {
  return Boolean(afterCritical.effected[draggableId]);
}
var fromCombine = ({
  isMovingForward,
  destination,
  draggables,
  combine: combine2,
  afterCritical
}) => {
  if (!destination.isCombineEnabled) {
    return null;
  }
  const combineId = combine2.draggableId;
  const combineWith = draggables[combineId];
  const combineWithIndex = combineWith.descriptor.index;
  const didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);
  if (didCombineWithStartAfterCritical) {
    if (isMovingForward) {
      return combineWithIndex;
    }
    return combineWithIndex - 1;
  }
  if (isMovingForward) {
    return combineWithIndex + 1;
  }
  return combineWithIndex;
};
var fromReorder = ({
  isMovingForward,
  isInHomeList,
  insideDestination,
  location
}) => {
  if (!insideDestination.length) {
    return null;
  }
  const currentIndex = location.index;
  const proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;
  const firstIndex = insideDestination[0].descriptor.index;
  const lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;
  const upperBound = isInHomeList ? lastIndex : lastIndex + 1;
  if (proposedIndex < firstIndex) {
    return null;
  }
  if (proposedIndex > upperBound) {
    return null;
  }
  return proposedIndex;
};
var moveToNextIndex = ({
  isMovingForward,
  isInHomeList,
  draggable: draggable2,
  draggables,
  destination,
  insideDestination,
  previousImpact,
  viewport: viewport2,
  afterCritical
}) => {
  const wasAt = previousImpact.at;
  !wasAt ? invariant() : void 0;
  if (wasAt.type === "REORDER") {
    const newIndex2 = fromReorder({
      isMovingForward,
      isInHomeList,
      location: wasAt.destination,
      insideDestination
    });
    if (newIndex2 == null) {
      return null;
    }
    return calculateReorderImpact({
      draggable: draggable2,
      insideDestination,
      destination,
      viewport: viewport2,
      last: previousImpact.displaced,
      displacedBy: previousImpact.displacedBy,
      index: newIndex2
    });
  }
  const newIndex = fromCombine({
    isMovingForward,
    destination,
    displaced: previousImpact.displaced,
    draggables,
    combine: wasAt.combine,
    afterCritical
  });
  if (newIndex == null) {
    return null;
  }
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport: viewport2,
    last: previousImpact.displaced,
    displacedBy: previousImpact.displacedBy,
    index: newIndex
  });
};
var getCombinedItemDisplacement = ({
  displaced,
  afterCritical,
  combineWith,
  displacedBy
}) => {
  const isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);
  if (didStartAfterCritical(combineWith, afterCritical)) {
    return isDisplaced ? origin : negate(displacedBy.point);
  }
  return isDisplaced ? displacedBy.point : origin;
};
var whenCombining = ({
  afterCritical,
  impact,
  draggables
}) => {
  const combine2 = tryGetCombine(impact);
  !combine2 ? invariant() : void 0;
  const combineWith = combine2.draggableId;
  const center = draggables[combineWith].page.borderBox.center;
  const displaceBy = getCombinedItemDisplacement({
    displaced: impact.displaced,
    afterCritical,
    combineWith,
    displacedBy: impact.displacedBy
  });
  return add(center, displaceBy);
};
const distanceFromStartToBorderBoxCenter = (axis, box) => box.margin[axis.start] + box.borderBox[axis.size] / 2;
const distanceFromEndToBorderBoxCenter = (axis, box) => box.margin[axis.end] + box.borderBox[axis.size] / 2;
const getCrossAxisBorderBoxCenter = (axis, target, isMoving) => target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;
const goAfter = ({
  axis,
  moveRelativeTo,
  isMoving
}) => patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
const goBefore = ({
  axis,
  moveRelativeTo,
  isMoving
}) => patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
const goIntoStart = ({
  axis,
  moveInto,
  isMoving
}) => patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));
var whenReordering = ({
  impact,
  draggable: draggable2,
  draggables,
  droppable: droppable2,
  afterCritical
}) => {
  const insideDestination = getDraggablesInsideDroppable(droppable2.descriptor.id, draggables);
  const draggablePage = draggable2.page;
  const axis = droppable2.axis;
  if (!insideDestination.length) {
    return goIntoStart({
      axis,
      moveInto: droppable2.page,
      isMoving: draggablePage
    });
  }
  const {
    displaced,
    displacedBy
  } = impact;
  const closestAfter = displaced.all[0];
  if (closestAfter) {
    const closest2 = draggables[closestAfter];
    if (didStartAfterCritical(closestAfter, afterCritical)) {
      return goBefore({
        axis,
        moveRelativeTo: closest2.page,
        isMoving: draggablePage
      });
    }
    const withDisplacement = offset$2(closest2.page, displacedBy.point);
    return goBefore({
      axis,
      moveRelativeTo: withDisplacement,
      isMoving: draggablePage
    });
  }
  const last = insideDestination[insideDestination.length - 1];
  if (last.descriptor.id === draggable2.descriptor.id) {
    return draggablePage.borderBox.center;
  }
  if (didStartAfterCritical(last.descriptor.id, afterCritical)) {
    const page = offset$2(last.page, negate(afterCritical.displacedBy.point));
    return goAfter({
      axis,
      moveRelativeTo: page,
      isMoving: draggablePage
    });
  }
  return goAfter({
    axis,
    moveRelativeTo: last.page,
    isMoving: draggablePage
  });
};
var withDroppableDisplacement = (droppable2, point) => {
  const frame = droppable2.frame;
  if (!frame) {
    return point;
  }
  return add(point, frame.scroll.diff.displacement);
};
const getResultWithoutDroppableDisplacement = ({
  impact,
  draggable: draggable2,
  droppable: droppable2,
  draggables,
  afterCritical
}) => {
  const original = draggable2.page.borderBox.center;
  const at = impact.at;
  if (!droppable2) {
    return original;
  }
  if (!at) {
    return original;
  }
  if (at.type === "REORDER") {
    return whenReordering({
      impact,
      draggable: draggable2,
      draggables,
      droppable: droppable2,
      afterCritical
    });
  }
  return whenCombining({
    impact,
    draggables,
    afterCritical
  });
};
var getPageBorderBoxCenterFromImpact = (args) => {
  const withoutDisplacement = getResultWithoutDroppableDisplacement(args);
  const droppable2 = args.droppable;
  const withDisplacement = droppable2 ? withDroppableDisplacement(droppable2, withoutDisplacement) : withoutDisplacement;
  return withDisplacement;
};
var scrollViewport = (viewport2, newScroll) => {
  const diff = subtract(newScroll, viewport2.scroll.initial);
  const displacement = negate(diff);
  const frame = getRect({
    top: newScroll.y,
    bottom: newScroll.y + viewport2.frame.height,
    left: newScroll.x,
    right: newScroll.x + viewport2.frame.width
  });
  const updated = {
    frame,
    scroll: {
      initial: viewport2.scroll.initial,
      max: viewport2.scroll.max,
      current: newScroll,
      diff: {
        value: diff,
        displacement
      }
    }
  };
  return updated;
};
function getDraggables$1(ids, draggables) {
  return ids.map((id2) => draggables[id2]);
}
function tryGetVisible(id2, groups) {
  for (let i = 0; i < groups.length; i++) {
    const displacement = groups[i].visible[id2];
    if (displacement) {
      return displacement;
    }
  }
  return null;
}
var speculativelyIncrease = ({
  impact,
  viewport: viewport2,
  destination,
  draggables,
  maxScrollChange
}) => {
  const scrolledViewport = scrollViewport(viewport2, add(viewport2.scroll.current, maxScrollChange));
  const scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;
  const last = impact.displaced;
  const withViewportScroll = getDisplacementGroups({
    afterDragging: getDraggables$1(last.all, draggables),
    destination,
    displacedBy: impact.displacedBy,
    viewport: scrolledViewport.frame,
    last,
    forceShouldAnimate: false
  });
  const withDroppableScroll2 = getDisplacementGroups({
    afterDragging: getDraggables$1(last.all, draggables),
    destination: scrolledDroppable,
    displacedBy: impact.displacedBy,
    viewport: viewport2.frame,
    last,
    forceShouldAnimate: false
  });
  const invisible = {};
  const visible = {};
  const groups = [last, withViewportScroll, withDroppableScroll2];
  last.all.forEach((id2) => {
    const displacement = tryGetVisible(id2, groups);
    if (displacement) {
      visible[id2] = displacement;
      return;
    }
    invisible[id2] = true;
  });
  const newImpact = {
    ...impact,
    displaced: {
      all: last.all,
      invisible,
      visible
    }
  };
  return newImpact;
};
var withViewportDisplacement = (viewport2, point) => add(viewport2.scroll.diff.displacement, point);
var getClientFromPageBorderBoxCenter = ({
  pageBorderBoxCenter,
  draggable: draggable2,
  viewport: viewport2
}) => {
  const withoutPageScrollChange = withViewportDisplacement(viewport2, pageBorderBoxCenter);
  const offset22 = subtract(withoutPageScrollChange, draggable2.page.borderBox.center);
  return add(draggable2.client.borderBox.center, offset22);
};
var isTotallyVisibleInNewLocation = ({
  draggable: draggable2,
  destination,
  newPageBorderBoxCenter,
  viewport: viewport2,
  withDroppableDisplacement: withDroppableDisplacement2,
  onlyOnMainAxis = false
}) => {
  const changeNeeded = subtract(newPageBorderBoxCenter, draggable2.page.borderBox.center);
  const shifted = offsetByPosition(draggable2.page.borderBox, changeNeeded);
  const args = {
    target: shifted,
    destination,
    withDroppableDisplacement: withDroppableDisplacement2,
    viewport: viewport2
  };
  return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);
};
var moveToNextPlace = ({
  isMovingForward,
  draggable: draggable2,
  destination,
  draggables,
  previousImpact,
  viewport: viewport2,
  previousPageBorderBoxCenter,
  previousClientSelection,
  afterCritical
}) => {
  if (!destination.isEnabled) {
    return null;
  }
  const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  const isInHomeList = isHomeOf(draggable2, destination);
  const impact = moveToNextCombine({
    isMovingForward,
    draggable: draggable2,
    destination,
    insideDestination,
    previousImpact
  }) || moveToNextIndex({
    isMovingForward,
    isInHomeList,
    draggable: draggable2,
    draggables,
    destination,
    insideDestination,
    previousImpact,
    viewport: viewport2,
    afterCritical
  });
  if (!impact) {
    return null;
  }
  const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    afterCritical
  });
  const isVisibleInNewLocation = isTotallyVisibleInNewLocation({
    draggable: draggable2,
    destination,
    newPageBorderBoxCenter: pageBorderBoxCenter,
    viewport: viewport2.frame,
    withDroppableDisplacement: false,
    onlyOnMainAxis: true
  });
  if (isVisibleInNewLocation) {
    const clientSelection = getClientFromPageBorderBoxCenter({
      pageBorderBoxCenter,
      draggable: draggable2,
      viewport: viewport2
    });
    return {
      clientSelection,
      impact,
      scrollJumpRequest: null
    };
  }
  const distance2 = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);
  const cautious = speculativelyIncrease({
    impact,
    viewport: viewport2,
    destination,
    draggables,
    maxScrollChange: distance2
  });
  return {
    clientSelection: previousClientSelection,
    impact: cautious,
    scrollJumpRequest: distance2
  };
};
const getKnownActive = (droppable2) => {
  const rect = droppable2.subject.active;
  !rect ? invariant() : void 0;
  return rect;
};
var getBestCrossAxisDroppable = ({
  isMovingForward,
  pageBorderBoxCenter,
  source,
  droppables,
  viewport: viewport2
}) => {
  const active = source.subject.active;
  if (!active) {
    return null;
  }
  const axis = source.axis;
  const isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);
  const candidates = toDroppableList(droppables).filter((droppable2) => droppable2 !== source).filter((droppable2) => droppable2.isEnabled).filter((droppable2) => Boolean(droppable2.subject.active)).filter((droppable2) => isPartiallyVisibleThroughFrame(viewport2.frame)(getKnownActive(droppable2))).filter((droppable2) => {
    const activeOfTarget = getKnownActive(droppable2);
    if (isMovingForward) {
      return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];
    }
    return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];
  }).filter((droppable2) => {
    const activeOfTarget = getKnownActive(droppable2);
    const isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);
    return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);
  }).sort((a2, b) => {
    const first2 = getKnownActive(a2)[axis.crossAxisStart];
    const second = getKnownActive(b)[axis.crossAxisStart];
    if (isMovingForward) {
      return first2 - second;
    }
    return second - first2;
  }).filter((droppable2, index2, array2) => getKnownActive(droppable2)[axis.crossAxisStart] === getKnownActive(array2[0])[axis.crossAxisStart]);
  if (!candidates.length) {
    return null;
  }
  if (candidates.length === 1) {
    return candidates[0];
  }
  const contains2 = candidates.filter((droppable2) => {
    const isWithinDroppable = isWithin(getKnownActive(droppable2)[axis.start], getKnownActive(droppable2)[axis.end]);
    return isWithinDroppable(pageBorderBoxCenter[axis.line]);
  });
  if (contains2.length === 1) {
    return contains2[0];
  }
  if (contains2.length > 1) {
    return contains2.sort((a2, b) => getKnownActive(a2)[axis.start] - getKnownActive(b)[axis.start])[0];
  }
  return candidates.sort((a2, b) => {
    const first2 = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(a2)));
    const second = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(b)));
    if (first2 !== second) {
      return first2 - second;
    }
    return getKnownActive(a2)[axis.start] - getKnownActive(b)[axis.start];
  })[0];
};
const getCurrentPageBorderBoxCenter = (draggable2, afterCritical) => {
  const original = draggable2.page.borderBox.center;
  return didStartAfterCritical(draggable2.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;
};
const getCurrentPageBorderBox = (draggable2, afterCritical) => {
  const original = draggable2.page.borderBox;
  return didStartAfterCritical(draggable2.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;
};
var getClosestDraggable = ({
  pageBorderBoxCenter,
  viewport: viewport2,
  destination,
  insideDestination,
  afterCritical
}) => {
  const sorted = insideDestination.filter((draggable2) => isTotallyVisible({
    target: getCurrentPageBorderBox(draggable2, afterCritical),
    destination,
    viewport: viewport2.frame,
    withDroppableDisplacement: true
  })).sort((a2, b) => {
    const distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a2, afterCritical)));
    const distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));
    if (distanceToA < distanceToB) {
      return -1;
    }
    if (distanceToB < distanceToA) {
      return 1;
    }
    return a2.descriptor.index - b.descriptor.index;
  });
  return sorted[0] || null;
};
var getDisplacedBy = memoizeOne$1(function getDisplacedBy2(axis, displaceBy) {
  const displacement = displaceBy[axis.line];
  return {
    value: displacement,
    point: patch(axis.line, displacement)
  };
});
const getRequiredGrowthForPlaceholder = (droppable2, placeholderSize, draggables) => {
  const axis = droppable2.axis;
  if (droppable2.descriptor.mode === "virtual") {
    return patch(axis.line, placeholderSize[axis.line]);
  }
  const availableSpace = droppable2.subject.page.contentBox[axis.size];
  const insideDroppable = getDraggablesInsideDroppable(droppable2.descriptor.id, draggables);
  const spaceUsed = insideDroppable.reduce((sum, dimension) => sum + dimension.client.marginBox[axis.size], 0);
  const requiredSpace = spaceUsed + placeholderSize[axis.line];
  const needsToGrowBy = requiredSpace - availableSpace;
  if (needsToGrowBy <= 0) {
    return null;
  }
  return patch(axis.line, needsToGrowBy);
};
const withMaxScroll = (frame, max2) => ({
  ...frame,
  scroll: {
    ...frame.scroll,
    max: max2
  }
});
const addPlaceholder = (droppable2, draggable2, draggables) => {
  const frame = droppable2.frame;
  !!isHomeOf(draggable2, droppable2) ? invariant() : void 0;
  !!droppable2.subject.withPlaceholder ? invariant() : void 0;
  const placeholderSize = getDisplacedBy(droppable2.axis, draggable2.displaceBy).point;
  const requiredGrowth = getRequiredGrowthForPlaceholder(droppable2, placeholderSize, draggables);
  const added = {
    placeholderSize,
    increasedBy: requiredGrowth,
    oldFrameMaxScroll: droppable2.frame ? droppable2.frame.scroll.max : null
  };
  if (!frame) {
    const subject2 = getSubject({
      page: droppable2.subject.page,
      withPlaceholder: added,
      axis: droppable2.axis,
      frame: droppable2.frame
    });
    return {
      ...droppable2,
      subject: subject2
    };
  }
  const maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;
  const newFrame = withMaxScroll(frame, maxScroll);
  const subject = getSubject({
    page: droppable2.subject.page,
    withPlaceholder: added,
    axis: droppable2.axis,
    frame: newFrame
  });
  return {
    ...droppable2,
    subject,
    frame: newFrame
  };
};
const removePlaceholder = (droppable2) => {
  const added = droppable2.subject.withPlaceholder;
  !added ? invariant() : void 0;
  const frame = droppable2.frame;
  if (!frame) {
    const subject2 = getSubject({
      page: droppable2.subject.page,
      axis: droppable2.axis,
      frame: null,
      withPlaceholder: null
    });
    return {
      ...droppable2,
      subject: subject2
    };
  }
  const oldMaxScroll = added.oldFrameMaxScroll;
  !oldMaxScroll ? invariant() : void 0;
  const newFrame = withMaxScroll(frame, oldMaxScroll);
  const subject = getSubject({
    page: droppable2.subject.page,
    axis: droppable2.axis,
    frame: newFrame,
    withPlaceholder: null
  });
  return {
    ...droppable2,
    subject,
    frame: newFrame
  };
};
var moveToNewDroppable = ({
  previousPageBorderBoxCenter,
  moveRelativeTo,
  insideDestination,
  draggable: draggable2,
  draggables,
  destination,
  viewport: viewport2,
  afterCritical
}) => {
  if (!moveRelativeTo) {
    if (insideDestination.length) {
      return null;
    }
    const proposed = {
      displaced: emptyGroups,
      displacedBy: noDisplacedBy,
      at: {
        type: "REORDER",
        destination: {
          droppableId: destination.descriptor.id,
          index: 0
        }
      }
    };
    const proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
      impact: proposed,
      draggable: draggable2,
      droppable: destination,
      draggables,
      afterCritical
    });
    const withPlaceholder = isHomeOf(draggable2, destination) ? destination : addPlaceholder(destination, draggable2, draggables);
    const isVisibleInNewLocation = isTotallyVisibleInNewLocation({
      draggable: draggable2,
      destination: withPlaceholder,
      newPageBorderBoxCenter: proposedPageBorderBoxCenter,
      viewport: viewport2.frame,
      withDroppableDisplacement: false,
      onlyOnMainAxis: true
    });
    return isVisibleInNewLocation ? proposed : null;
  }
  const isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);
  const proposedIndex = (() => {
    const relativeTo = moveRelativeTo.descriptor.index;
    if (moveRelativeTo.descriptor.id === draggable2.descriptor.id) {
      return relativeTo;
    }
    if (isGoingBeforeTarget) {
      return relativeTo;
    }
    return relativeTo + 1;
  })();
  const displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport: viewport2,
    displacedBy,
    last: emptyGroups,
    index: proposedIndex
  });
};
var moveCrossAxis = ({
  isMovingForward,
  previousPageBorderBoxCenter,
  draggable: draggable2,
  isOver,
  draggables,
  droppables,
  viewport: viewport2,
  afterCritical
}) => {
  const destination = getBestCrossAxisDroppable({
    isMovingForward,
    pageBorderBoxCenter: previousPageBorderBoxCenter,
    source: isOver,
    droppables,
    viewport: viewport2
  });
  if (!destination) {
    return null;
  }
  const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  const moveRelativeTo = getClosestDraggable({
    pageBorderBoxCenter: previousPageBorderBoxCenter,
    viewport: viewport2,
    destination,
    insideDestination,
    afterCritical
  });
  const impact = moveToNewDroppable({
    previousPageBorderBoxCenter,
    destination,
    draggable: draggable2,
    draggables,
    moveRelativeTo,
    insideDestination,
    viewport: viewport2,
    afterCritical
  });
  if (!impact) {
    return null;
  }
  const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    afterCritical
  });
  const clientSelection = getClientFromPageBorderBoxCenter({
    pageBorderBoxCenter,
    draggable: draggable2,
    viewport: viewport2
  });
  return {
    clientSelection,
    impact,
    scrollJumpRequest: null
  };
};
var whatIsDraggedOver = (impact) => {
  const at = impact.at;
  if (!at) {
    return null;
  }
  if (at.type === "REORDER") {
    return at.destination.droppableId;
  }
  return at.combine.droppableId;
};
const getDroppableOver$1 = (impact, droppables) => {
  const id2 = whatIsDraggedOver(impact);
  return id2 ? droppables[id2] : null;
};
var moveInDirection = ({
  state,
  type
}) => {
  const isActuallyOver = getDroppableOver$1(state.impact, state.dimensions.droppables);
  const isMainAxisMovementAllowed = Boolean(isActuallyOver);
  const home2 = state.dimensions.droppables[state.critical.droppable.id];
  const isOver = isActuallyOver || home2;
  const direction2 = isOver.axis.direction;
  const isMovingOnMainAxis = direction2 === "vertical" && (type === "MOVE_UP" || type === "MOVE_DOWN") || direction2 === "horizontal" && (type === "MOVE_LEFT" || type === "MOVE_RIGHT");
  if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {
    return null;
  }
  const isMovingForward = type === "MOVE_DOWN" || type === "MOVE_RIGHT";
  const draggable2 = state.dimensions.draggables[state.critical.draggable.id];
  const previousPageBorderBoxCenter = state.current.page.borderBoxCenter;
  const {
    draggables,
    droppables
  } = state.dimensions;
  return isMovingOnMainAxis ? moveToNextPlace({
    isMovingForward,
    previousPageBorderBoxCenter,
    draggable: draggable2,
    destination: isOver,
    draggables,
    viewport: state.viewport,
    previousClientSelection: state.current.client.selection,
    previousImpact: state.impact,
    afterCritical: state.afterCritical
  }) : moveCrossAxis({
    isMovingForward,
    previousPageBorderBoxCenter,
    draggable: draggable2,
    isOver,
    draggables,
    droppables,
    viewport: state.viewport,
    afterCritical: state.afterCritical
  });
};
function isMovementAllowed(state) {
  return state.phase === "DRAGGING" || state.phase === "COLLECTING";
}
function isPositionInFrame(frame) {
  const isWithinVertical = isWithin(frame.top, frame.bottom);
  const isWithinHorizontal = isWithin(frame.left, frame.right);
  return function run2(point) {
    return isWithinVertical(point.y) && isWithinHorizontal(point.x);
  };
}
function getHasOverlap(first2, second) {
  return first2.left < second.right && first2.right > second.left && first2.top < second.bottom && first2.bottom > second.top;
}
function getFurthestAway({
  pageBorderBox,
  draggable: draggable2,
  candidates
}) {
  const startCenter = draggable2.page.borderBox.center;
  const sorted = candidates.map((candidate) => {
    const axis = candidate.axis;
    const target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);
    return {
      id: candidate.descriptor.id,
      distance: distance(startCenter, target)
    };
  }).sort((a2, b) => b.distance - a2.distance);
  return sorted[0] ? sorted[0].id : null;
}
function getDroppableOver({
  pageBorderBox,
  draggable: draggable2,
  droppables
}) {
  const candidates = toDroppableList(droppables).filter((item) => {
    if (!item.isEnabled) {
      return false;
    }
    const active = item.subject.active;
    if (!active) {
      return false;
    }
    if (!getHasOverlap(pageBorderBox, active)) {
      return false;
    }
    if (isPositionInFrame(active)(pageBorderBox.center)) {
      return true;
    }
    const axis = item.axis;
    const childCenter = active.center[axis.crossAxisLine];
    const crossAxisStart = pageBorderBox[axis.crossAxisStart];
    const crossAxisEnd = pageBorderBox[axis.crossAxisEnd];
    const isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);
    const isStartContained = isContained(crossAxisStart);
    const isEndContained = isContained(crossAxisEnd);
    if (!isStartContained && !isEndContained) {
      return true;
    }
    if (isStartContained) {
      return crossAxisStart < childCenter;
    }
    return crossAxisEnd > childCenter;
  });
  if (!candidates.length) {
    return null;
  }
  if (candidates.length === 1) {
    return candidates[0].descriptor.id;
  }
  return getFurthestAway({
    pageBorderBox,
    draggable: draggable2,
    candidates
  });
}
const offsetRectByPosition = (rect, point) => getRect(offsetByPosition(rect, point));
var withDroppableScroll = (droppable2, area) => {
  const frame = droppable2.frame;
  if (!frame) {
    return area;
  }
  return offsetRectByPosition(area, frame.scroll.diff.value);
};
function getIsDisplaced({
  displaced,
  id: id2
}) {
  return Boolean(displaced.visible[id2] || displaced.invisible[id2]);
}
function atIndex({
  draggable: draggable2,
  closest: closest2,
  inHomeList
}) {
  if (!closest2) {
    return null;
  }
  if (!inHomeList) {
    return closest2.descriptor.index;
  }
  if (closest2.descriptor.index > draggable2.descriptor.index) {
    return closest2.descriptor.index - 1;
  }
  return closest2.descriptor.index;
}
var getReorderImpact = ({
  pageBorderBoxWithDroppableScroll: targetRect,
  draggable: draggable2,
  destination,
  insideDestination,
  last,
  viewport: viewport2,
  afterCritical
}) => {
  const axis = destination.axis;
  const displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  const displacement = displacedBy.value;
  const targetStart = targetRect[axis.start];
  const targetEnd = targetRect[axis.end];
  const withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  const closest2 = withoutDragging.find((child) => {
    const id2 = child.descriptor.id;
    const childCenter = child.page.borderBox.center[axis.line];
    const didStartAfterCritical$1 = didStartAfterCritical(id2, afterCritical);
    const isDisplaced = getIsDisplaced({
      displaced: last,
      id: id2
    });
    if (didStartAfterCritical$1) {
      if (isDisplaced) {
        return targetEnd <= childCenter;
      }
      return targetStart < childCenter - displacement;
    }
    if (isDisplaced) {
      return targetEnd <= childCenter + displacement;
    }
    return targetStart < childCenter;
  }) || null;
  const newIndex = atIndex({
    draggable: draggable2,
    closest: closest2,
    inHomeList: isHomeOf(draggable2, destination)
  });
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport: viewport2,
    last,
    displacedBy,
    index: newIndex
  });
};
const combineThresholdDivisor = 4;
var getCombineImpact = ({
  draggable: draggable2,
  pageBorderBoxWithDroppableScroll: targetRect,
  previousImpact,
  destination,
  insideDestination,
  afterCritical
}) => {
  if (!destination.isCombineEnabled) {
    return null;
  }
  const axis = destination.axis;
  const displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  const displacement = displacedBy.value;
  const targetStart = targetRect[axis.start];
  const targetEnd = targetRect[axis.end];
  const withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  const combineWith = withoutDragging.find((child) => {
    const id2 = child.descriptor.id;
    const childRect = child.page.borderBox;
    const childSize = childRect[axis.size];
    const threshold = childSize / combineThresholdDivisor;
    const didStartAfterCritical$1 = didStartAfterCritical(id2, afterCritical);
    const isDisplaced = getIsDisplaced({
      displaced: previousImpact.displaced,
      id: id2
    });
    if (didStartAfterCritical$1) {
      if (isDisplaced) {
        return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;
      }
      return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;
    }
    if (isDisplaced) {
      return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;
    }
    return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;
  });
  if (!combineWith) {
    return null;
  }
  const impact = {
    displacedBy,
    displaced: previousImpact.displaced,
    at: {
      type: "COMBINE",
      combine: {
        draggableId: combineWith.descriptor.id,
        droppableId: destination.descriptor.id
      }
    }
  };
  return impact;
};
var getDragImpact = ({
  pageOffset,
  draggable: draggable2,
  draggables,
  droppables,
  previousImpact,
  viewport: viewport2,
  afterCritical
}) => {
  const pageBorderBox = offsetRectByPosition(draggable2.page.borderBox, pageOffset);
  const destinationId = getDroppableOver({
    pageBorderBox,
    draggable: draggable2,
    droppables
  });
  if (!destinationId) {
    return noImpact;
  }
  const destination = droppables[destinationId];
  const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  const pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);
  return getCombineImpact({
    pageBorderBoxWithDroppableScroll,
    draggable: draggable2,
    previousImpact,
    destination,
    insideDestination,
    afterCritical
  }) || getReorderImpact({
    pageBorderBoxWithDroppableScroll,
    draggable: draggable2,
    destination,
    insideDestination,
    last: previousImpact.displaced,
    viewport: viewport2,
    afterCritical
  });
};
var patchDroppableMap = (droppables, updated) => ({
  ...droppables,
  [updated.descriptor.id]: updated
});
const clearUnusedPlaceholder = ({
  previousImpact,
  impact,
  droppables
}) => {
  const last = whatIsDraggedOver(previousImpact);
  const now2 = whatIsDraggedOver(impact);
  if (!last) {
    return droppables;
  }
  if (last === now2) {
    return droppables;
  }
  const lastDroppable = droppables[last];
  if (!lastDroppable.subject.withPlaceholder) {
    return droppables;
  }
  const updated = removePlaceholder(lastDroppable);
  return patchDroppableMap(droppables, updated);
};
var recomputePlaceholders = ({
  draggable: draggable2,
  draggables,
  droppables,
  previousImpact,
  impact
}) => {
  const cleaned = clearUnusedPlaceholder({
    previousImpact,
    impact,
    droppables
  });
  const isOver = whatIsDraggedOver(impact);
  if (!isOver) {
    return cleaned;
  }
  const droppable2 = droppables[isOver];
  if (isHomeOf(draggable2, droppable2)) {
    return cleaned;
  }
  if (droppable2.subject.withPlaceholder) {
    return cleaned;
  }
  const patched = addPlaceholder(droppable2, draggable2, draggables);
  return patchDroppableMap(cleaned, patched);
};
var update = ({
  state,
  clientSelection: forcedClientSelection,
  dimensions: forcedDimensions,
  viewport: forcedViewport,
  impact: forcedImpact,
  scrollJumpRequest
}) => {
  const viewport2 = forcedViewport || state.viewport;
  const dimensions = forcedDimensions || state.dimensions;
  const clientSelection = forcedClientSelection || state.current.client.selection;
  const offset22 = subtract(clientSelection, state.initial.client.selection);
  const client = {
    offset: offset22,
    selection: clientSelection,
    borderBoxCenter: add(state.initial.client.borderBoxCenter, offset22)
  };
  const page = {
    selection: add(client.selection, viewport2.scroll.current),
    borderBoxCenter: add(client.borderBoxCenter, viewport2.scroll.current),
    offset: add(client.offset, viewport2.scroll.diff.value)
  };
  const current = {
    client,
    page
  };
  if (state.phase === "COLLECTING") {
    return {
      ...state,
      dimensions,
      viewport: viewport2,
      current
    };
  }
  const draggable2 = dimensions.draggables[state.critical.draggable.id];
  const newImpact = forcedImpact || getDragImpact({
    pageOffset: page.offset,
    draggable: draggable2,
    draggables: dimensions.draggables,
    droppables: dimensions.droppables,
    previousImpact: state.impact,
    viewport: viewport2,
    afterCritical: state.afterCritical
  });
  const withUpdatedPlaceholders = recomputePlaceholders({
    draggable: draggable2,
    impact: newImpact,
    previousImpact: state.impact,
    draggables: dimensions.draggables,
    droppables: dimensions.droppables
  });
  const result = {
    ...state,
    current,
    dimensions: {
      draggables: dimensions.draggables,
      droppables: withUpdatedPlaceholders
    },
    impact: newImpact,
    viewport: viewport2,
    scrollJumpRequest: scrollJumpRequest || null,
    forceShouldAnimate: scrollJumpRequest ? false : null
  };
  return result;
};
function getDraggables(ids, draggables) {
  return ids.map((id2) => draggables[id2]);
}
var recompute = ({
  impact,
  viewport: viewport2,
  draggables,
  destination,
  forceShouldAnimate
}) => {
  const last = impact.displaced;
  const afterDragging = getDraggables(last.all, draggables);
  const displaced = getDisplacementGroups({
    afterDragging,
    destination,
    displacedBy: impact.displacedBy,
    viewport: viewport2.frame,
    forceShouldAnimate,
    last
  });
  return {
    ...impact,
    displaced
  };
};
var getClientBorderBoxCenter = ({
  impact,
  draggable: draggable2,
  droppable: droppable2,
  draggables,
  viewport: viewport2,
  afterCritical
}) => {
  const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    draggables,
    droppable: droppable2,
    afterCritical
  });
  return getClientFromPageBorderBoxCenter({
    pageBorderBoxCenter,
    draggable: draggable2,
    viewport: viewport2
  });
};
var refreshSnap = ({
  state,
  dimensions: forcedDimensions,
  viewport: forcedViewport
}) => {
  !(state.movementMode === "SNAP") ? invariant() : void 0;
  const needsVisibilityCheck = state.impact;
  const viewport2 = forcedViewport || state.viewport;
  const dimensions = forcedDimensions || state.dimensions;
  const {
    draggables,
    droppables
  } = dimensions;
  const draggable2 = draggables[state.critical.draggable.id];
  const isOver = whatIsDraggedOver(needsVisibilityCheck);
  !isOver ? invariant() : void 0;
  const destination = droppables[isOver];
  const impact = recompute({
    impact: needsVisibilityCheck,
    viewport: viewport2,
    destination,
    draggables
  });
  const clientSelection = getClientBorderBoxCenter({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    viewport: viewport2,
    afterCritical: state.afterCritical
  });
  return update({
    impact,
    clientSelection,
    state,
    dimensions,
    viewport: viewport2
  });
};
var getHomeLocation = (descriptor) => ({
  index: descriptor.index,
  droppableId: descriptor.droppableId
});
var getLiftEffect = ({
  draggable: draggable2,
  home: home2,
  draggables,
  viewport: viewport2
}) => {
  const displacedBy = getDisplacedBy(home2.axis, draggable2.displaceBy);
  const insideHome = getDraggablesInsideDroppable(home2.descriptor.id, draggables);
  const rawIndex = insideHome.indexOf(draggable2);
  !(rawIndex !== -1) ? invariant() : void 0;
  const afterDragging = insideHome.slice(rawIndex + 1);
  const effected = afterDragging.reduce((previous, item) => {
    previous[item.descriptor.id] = true;
    return previous;
  }, {});
  const afterCritical = {
    inVirtualList: home2.descriptor.mode === "virtual",
    displacedBy,
    effected
  };
  const displaced = getDisplacementGroups({
    afterDragging,
    destination: home2,
    displacedBy,
    last: null,
    viewport: viewport2.frame,
    forceShouldAnimate: false
  });
  const impact = {
    displaced,
    displacedBy,
    at: {
      type: "REORDER",
      destination: getHomeLocation(draggable2.descriptor)
    }
  };
  return {
    impact,
    afterCritical
  };
};
var patchDimensionMap = (dimensions, updated) => ({
  draggables: dimensions.draggables,
  droppables: patchDroppableMap(dimensions.droppables, updated)
});
var offsetDraggable = ({
  draggable: draggable2,
  offset: offset$12,
  initialWindowScroll
}) => {
  const client = offset$2(draggable2.client, offset$12);
  const page = withScroll(client, initialWindowScroll);
  const moved = {
    ...draggable2,
    placeholder: {
      ...draggable2.placeholder,
      client
    },
    client,
    page
  };
  return moved;
};
var getFrame = (droppable2) => {
  const frame = droppable2.frame;
  !frame ? invariant() : void 0;
  return frame;
};
var adjustAdditionsForScrollChanges = ({
  additions,
  updatedDroppables,
  viewport: viewport2
}) => {
  const windowScrollChange = viewport2.scroll.diff.value;
  return additions.map((draggable2) => {
    const droppableId = draggable2.descriptor.droppableId;
    const modified = updatedDroppables[droppableId];
    const frame = getFrame(modified);
    const droppableScrollChange = frame.scroll.diff.value;
    const totalChange = add(windowScrollChange, droppableScrollChange);
    const moved = offsetDraggable({
      draggable: draggable2,
      offset: totalChange,
      initialWindowScroll: viewport2.scroll.initial
    });
    return moved;
  });
};
var publishWhileDraggingInVirtual = ({
  state,
  published
}) => {
  const withScrollChange = published.modified.map((update2) => {
    const existing = state.dimensions.droppables[update2.droppableId];
    const scrolled = scrollDroppable(existing, update2.scroll);
    return scrolled;
  });
  const droppables = {
    ...state.dimensions.droppables,
    ...toDroppableMap(withScrollChange)
  };
  const updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({
    additions: published.additions,
    updatedDroppables: droppables,
    viewport: state.viewport
  }));
  const draggables = {
    ...state.dimensions.draggables,
    ...updatedAdditions
  };
  published.removals.forEach((id2) => {
    delete draggables[id2];
  });
  const dimensions = {
    droppables,
    draggables
  };
  const wasOverId = whatIsDraggedOver(state.impact);
  const wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;
  const draggable2 = dimensions.draggables[state.critical.draggable.id];
  const home2 = dimensions.droppables[state.critical.droppable.id];
  const {
    impact: onLiftImpact,
    afterCritical
  } = getLiftEffect({
    draggable: draggable2,
    home: home2,
    draggables,
    viewport: state.viewport
  });
  const previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;
  const impact = getDragImpact({
    pageOffset: state.current.page.offset,
    draggable: dimensions.draggables[state.critical.draggable.id],
    draggables: dimensions.draggables,
    droppables: dimensions.droppables,
    previousImpact,
    viewport: state.viewport,
    afterCritical
  });
  const draggingState = {
    ...state,
    phase: "DRAGGING",
    impact,
    onLiftImpact,
    dimensions,
    afterCritical,
    forceShouldAnimate: false
  };
  if (state.phase === "COLLECTING") {
    return draggingState;
  }
  const dropPending2 = {
    ...draggingState,
    phase: "DROP_PENDING",
    reason: state.reason,
    isWaiting: false
  };
  return dropPending2;
};
const isSnapping = (state) => state.movementMode === "SNAP";
const postDroppableChange = (state, updated, isEnabledChanging) => {
  const dimensions = patchDimensionMap(state.dimensions, updated);
  if (!isSnapping(state) || isEnabledChanging) {
    return update({
      state,
      dimensions
    });
  }
  return refreshSnap({
    state,
    dimensions
  });
};
function removeScrollJumpRequest(state) {
  if (state.isDragging && state.movementMode === "SNAP") {
    return {
      ...state,
      scrollJumpRequest: null
    };
  }
  return state;
}
const idle$2 = {
  phase: "IDLE",
  completed: null,
  shouldFlush: false
};
var reducer = (state = idle$2, action) => {
  if (action.type === "FLUSH") {
    return {
      ...idle$2,
      shouldFlush: true
    };
  }
  if (action.type === "INITIAL_PUBLISH") {
    !(state.phase === "IDLE") ? invariant() : void 0;
    const {
      critical,
      clientSelection,
      viewport: viewport2,
      dimensions,
      movementMode
    } = action.payload;
    const draggable2 = dimensions.draggables[critical.draggable.id];
    const home2 = dimensions.droppables[critical.droppable.id];
    const client = {
      selection: clientSelection,
      borderBoxCenter: draggable2.client.borderBox.center,
      offset: origin
    };
    const initial = {
      client,
      page: {
        selection: add(client.selection, viewport2.scroll.initial),
        borderBoxCenter: add(client.selection, viewport2.scroll.initial),
        offset: add(client.selection, viewport2.scroll.diff.value)
      }
    };
    const isWindowScrollAllowed = toDroppableList(dimensions.droppables).every((item) => !item.isFixedOnPage);
    const {
      impact,
      afterCritical
    } = getLiftEffect({
      draggable: draggable2,
      home: home2,
      draggables: dimensions.draggables,
      viewport: viewport2
    });
    const result = {
      phase: "DRAGGING",
      isDragging: true,
      critical,
      movementMode,
      dimensions,
      initial,
      current: initial,
      isWindowScrollAllowed,
      impact,
      afterCritical,
      onLiftImpact: impact,
      viewport: viewport2,
      scrollJumpRequest: null,
      forceShouldAnimate: null
    };
    return result;
  }
  if (action.type === "COLLECTION_STARTING") {
    if (state.phase === "COLLECTING" || state.phase === "DROP_PENDING") {
      return state;
    }
    !(state.phase === "DRAGGING") ? invariant() : void 0;
    const result = {
      ...state,
      phase: "COLLECTING"
    };
    return result;
  }
  if (action.type === "PUBLISH_WHILE_DRAGGING") {
    !(state.phase === "COLLECTING" || state.phase === "DROP_PENDING") ? invariant() : void 0;
    return publishWhileDraggingInVirtual({
      state,
      published: action.payload
    });
  }
  if (action.type === "MOVE") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? invariant() : void 0;
    const {
      client: clientSelection
    } = action.payload;
    if (isEqual$1(clientSelection, state.current.client.selection)) {
      return state;
    }
    return update({
      state,
      clientSelection,
      impact: isSnapping(state) ? state.impact : null
    });
  }
  if (action.type === "UPDATE_DROPPABLE_SCROLL") {
    if (state.phase === "DROP_PENDING") {
      return removeScrollJumpRequest(state);
    }
    if (state.phase === "COLLECTING") {
      return removeScrollJumpRequest(state);
    }
    !isMovementAllowed(state) ? invariant() : void 0;
    const {
      id: id2,
      newScroll
    } = action.payload;
    const target = state.dimensions.droppables[id2];
    if (!target) {
      return state;
    }
    const scrolled = scrollDroppable(target, newScroll);
    return postDroppableChange(state, scrolled, false);
  }
  if (action.type === "UPDATE_DROPPABLE_IS_ENABLED") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? invariant() : void 0;
    const {
      id: id2,
      isEnabled
    } = action.payload;
    const target = state.dimensions.droppables[id2];
    !target ? invariant() : void 0;
    !(target.isEnabled !== isEnabled) ? invariant() : void 0;
    const updated = {
      ...target,
      isEnabled
    };
    return postDroppableChange(state, updated, true);
  }
  if (action.type === "UPDATE_DROPPABLE_IS_COMBINE_ENABLED") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? invariant() : void 0;
    const {
      id: id2,
      isCombineEnabled
    } = action.payload;
    const target = state.dimensions.droppables[id2];
    !target ? invariant() : void 0;
    !(target.isCombineEnabled !== isCombineEnabled) ? invariant() : void 0;
    const updated = {
      ...target,
      isCombineEnabled
    };
    return postDroppableChange(state, updated, true);
  }
  if (action.type === "MOVE_BY_WINDOW_SCROLL") {
    if (state.phase === "DROP_PENDING" || state.phase === "DROP_ANIMATING") {
      return state;
    }
    !isMovementAllowed(state) ? invariant() : void 0;
    !state.isWindowScrollAllowed ? invariant() : void 0;
    const newScroll = action.payload.newScroll;
    if (isEqual$1(state.viewport.scroll.current, newScroll)) {
      return removeScrollJumpRequest(state);
    }
    const viewport2 = scrollViewport(state.viewport, newScroll);
    if (isSnapping(state)) {
      return refreshSnap({
        state,
        viewport: viewport2
      });
    }
    return update({
      state,
      viewport: viewport2
    });
  }
  if (action.type === "UPDATE_VIEWPORT_MAX_SCROLL") {
    if (!isMovementAllowed(state)) {
      return state;
    }
    const maxScroll = action.payload.maxScroll;
    if (isEqual$1(maxScroll, state.viewport.scroll.max)) {
      return state;
    }
    const withMaxScroll2 = {
      ...state.viewport,
      scroll: {
        ...state.viewport.scroll,
        max: maxScroll
      }
    };
    return {
      ...state,
      viewport: withMaxScroll2
    };
  }
  if (action.type === "MOVE_UP" || action.type === "MOVE_DOWN" || action.type === "MOVE_LEFT" || action.type === "MOVE_RIGHT") {
    if (state.phase === "COLLECTING" || state.phase === "DROP_PENDING") {
      return state;
    }
    !(state.phase === "DRAGGING") ? invariant() : void 0;
    const result = moveInDirection({
      state,
      type: action.type
    });
    if (!result) {
      return state;
    }
    return update({
      state,
      impact: result.impact,
      clientSelection: result.clientSelection,
      scrollJumpRequest: result.scrollJumpRequest
    });
  }
  if (action.type === "DROP_PENDING") {
    const reason = action.payload.reason;
    !(state.phase === "COLLECTING") ? invariant() : void 0;
    const newState = {
      ...state,
      phase: "DROP_PENDING",
      isWaiting: true,
      reason
    };
    return newState;
  }
  if (action.type === "DROP_ANIMATE") {
    const {
      completed,
      dropDuration,
      newHomeClientOffset
    } = action.payload;
    !(state.phase === "DRAGGING" || state.phase === "DROP_PENDING") ? invariant() : void 0;
    const result = {
      phase: "DROP_ANIMATING",
      completed,
      dropDuration,
      newHomeClientOffset,
      dimensions: state.dimensions
    };
    return result;
  }
  if (action.type === "DROP_COMPLETE") {
    const {
      completed
    } = action.payload;
    return {
      phase: "IDLE",
      completed,
      shouldFlush: false
    };
  }
  return state;
};
function guard(action, predicate) {
  return action instanceof Object && "type" in action && action.type === predicate;
}
const beforeInitialCapture = (args) => ({
  type: "BEFORE_INITIAL_CAPTURE",
  payload: args
});
const lift$1$1 = (args) => ({
  type: "LIFT",
  payload: args
});
const initialPublish = (args) => ({
  type: "INITIAL_PUBLISH",
  payload: args
});
const publishWhileDragging = (args) => ({
  type: "PUBLISH_WHILE_DRAGGING",
  payload: args
});
const collectionStarting = () => ({
  type: "COLLECTION_STARTING",
  payload: null
});
const updateDroppableScroll = (args) => ({
  type: "UPDATE_DROPPABLE_SCROLL",
  payload: args
});
const updateDroppableIsEnabled = (args) => ({
  type: "UPDATE_DROPPABLE_IS_ENABLED",
  payload: args
});
const updateDroppableIsCombineEnabled = (args) => ({
  type: "UPDATE_DROPPABLE_IS_COMBINE_ENABLED",
  payload: args
});
const move = (args) => ({
  type: "MOVE",
  payload: args
});
const moveByWindowScroll = (args) => ({
  type: "MOVE_BY_WINDOW_SCROLL",
  payload: args
});
const updateViewportMaxScroll = (args) => ({
  type: "UPDATE_VIEWPORT_MAX_SCROLL",
  payload: args
});
const moveUp = () => ({
  type: "MOVE_UP",
  payload: null
});
const moveDown = () => ({
  type: "MOVE_DOWN",
  payload: null
});
const moveRight = () => ({
  type: "MOVE_RIGHT",
  payload: null
});
const moveLeft = () => ({
  type: "MOVE_LEFT",
  payload: null
});
const flush = () => ({
  type: "FLUSH",
  payload: null
});
const animateDrop = (args) => ({
  type: "DROP_ANIMATE",
  payload: args
});
const completeDrop = (args) => ({
  type: "DROP_COMPLETE",
  payload: args
});
const drop = (args) => ({
  type: "DROP",
  payload: args
});
const dropPending = (args) => ({
  type: "DROP_PENDING",
  payload: args
});
const dropAnimationFinished = () => ({
  type: "DROP_ANIMATION_FINISHED",
  payload: null
});
var lift$4 = (marshal) => ({
  getState,
  dispatch
}) => (next) => (action) => {
  if (!guard(action, "LIFT")) {
    next(action);
    return;
  }
  const {
    id: id2,
    clientSelection,
    movementMode
  } = action.payload;
  const initial = getState();
  if (initial.phase === "DROP_ANIMATING") {
    dispatch(completeDrop({
      completed: initial.completed
    }));
  }
  !(getState().phase === "IDLE") ? invariant() : void 0;
  dispatch(flush());
  dispatch(beforeInitialCapture({
    draggableId: id2,
    movementMode
  }));
  const scrollOptions = {
    shouldPublishImmediately: movementMode === "SNAP"
  };
  const request = {
    draggableId: id2,
    scrollOptions
  };
  const {
    critical,
    dimensions,
    viewport: viewport2
  } = marshal.startPublishing(request);
  dispatch(initialPublish({
    critical,
    dimensions,
    clientSelection,
    movementMode,
    viewport: viewport2
  }));
};
var style$1 = (marshal) => () => (next) => (action) => {
  if (guard(action, "INITIAL_PUBLISH")) {
    marshal.dragging();
  }
  if (guard(action, "DROP_ANIMATE")) {
    marshal.dropping(action.payload.completed.result.reason);
  }
  if (guard(action, "FLUSH") || guard(action, "DROP_COMPLETE")) {
    marshal.resting();
  }
  next(action);
};
const curves = {
  outOfTheWay: "cubic-bezier(0.2, 0, 0, 1)",
  drop: "cubic-bezier(.2,1,.1,1)"
};
const combine = {
  opacity: {
    drop: 0,
    combining: 0.7
  },
  scale: {
    drop: 0.75
  }
};
const timings = {
  outOfTheWay: 0.2,
  minDropTime: 0.33,
  maxDropTime: 0.55
};
const outOfTheWayTiming = `${timings.outOfTheWay}s ${curves.outOfTheWay}`;
const transitions = {
  fluid: `opacity ${outOfTheWayTiming}`,
  snap: `transform ${outOfTheWayTiming}, opacity ${outOfTheWayTiming}`,
  drop: (duration) => {
    const timing = `${duration}s ${curves.drop}`;
    return `transform ${timing}, opacity ${timing}`;
  },
  outOfTheWay: `transform ${outOfTheWayTiming}`,
  placeholder: `height ${outOfTheWayTiming}, width ${outOfTheWayTiming}, margin ${outOfTheWayTiming}`
};
const moveTo = (offset22) => isEqual$1(offset22, origin) ? void 0 : `translate(${offset22.x}px, ${offset22.y}px)`;
const transforms = {
  moveTo,
  drop: (offset22, isCombining) => {
    const translate2 = moveTo(offset22);
    if (!translate2) {
      return void 0;
    }
    if (!isCombining) {
      return translate2;
    }
    return `${translate2} scale(${combine.scale.drop})`;
  }
};
const {
  minDropTime,
  maxDropTime
} = timings;
const dropTimeRange = maxDropTime - minDropTime;
const maxDropTimeAtDistance = 1500;
const cancelDropModifier = 0.6;
var getDropDuration = ({
  current,
  destination,
  reason
}) => {
  const distance$1 = distance(current, destination);
  if (distance$1 <= 0) {
    return minDropTime;
  }
  if (distance$1 >= maxDropTimeAtDistance) {
    return maxDropTime;
  }
  const percentage = distance$1 / maxDropTimeAtDistance;
  const duration = minDropTime + dropTimeRange * percentage;
  const withDuration = reason === "CANCEL" ? duration * cancelDropModifier : duration;
  return Number(withDuration.toFixed(2));
};
var getNewHomeClientOffset = ({
  impact,
  draggable: draggable2,
  dimensions,
  viewport: viewport2,
  afterCritical
}) => {
  const {
    draggables,
    droppables
  } = dimensions;
  const droppableId = whatIsDraggedOver(impact);
  const destination = droppableId ? droppables[droppableId] : null;
  const home2 = droppables[draggable2.descriptor.droppableId];
  const newClientCenter = getClientBorderBoxCenter({
    impact,
    draggable: draggable2,
    draggables,
    afterCritical,
    droppable: destination || home2,
    viewport: viewport2
  });
  const offset22 = subtract(newClientCenter, draggable2.client.borderBox.center);
  return offset22;
};
var getDropImpact = ({
  draggables,
  reason,
  lastImpact,
  home: home2,
  viewport: viewport2,
  onLiftImpact
}) => {
  if (!lastImpact.at || reason !== "DROP") {
    const recomputedHomeImpact = recompute({
      draggables,
      impact: onLiftImpact,
      destination: home2,
      viewport: viewport2,
      forceShouldAnimate: true
    });
    return {
      impact: recomputedHomeImpact,
      didDropInsideDroppable: false
    };
  }
  if (lastImpact.at.type === "REORDER") {
    return {
      impact: lastImpact,
      didDropInsideDroppable: true
    };
  }
  const withoutMovement = {
    ...lastImpact,
    displaced: emptyGroups
  };
  return {
    impact: withoutMovement,
    didDropInsideDroppable: true
  };
};
const dropMiddleware = ({
  getState,
  dispatch
}) => (next) => (action) => {
  if (!guard(action, "DROP")) {
    next(action);
    return;
  }
  const state = getState();
  const reason = action.payload.reason;
  if (state.phase === "COLLECTING") {
    dispatch(dropPending({
      reason
    }));
    return;
  }
  if (state.phase === "IDLE") {
    return;
  }
  const isWaitingForDrop = state.phase === "DROP_PENDING" && state.isWaiting;
  !!isWaitingForDrop ? invariant() : void 0;
  !(state.phase === "DRAGGING" || state.phase === "DROP_PENDING") ? invariant() : void 0;
  const critical = state.critical;
  const dimensions = state.dimensions;
  const draggable2 = dimensions.draggables[state.critical.draggable.id];
  const {
    impact,
    didDropInsideDroppable
  } = getDropImpact({
    reason,
    lastImpact: state.impact,
    afterCritical: state.afterCritical,
    onLiftImpact: state.onLiftImpact,
    home: state.dimensions.droppables[state.critical.droppable.id],
    viewport: state.viewport,
    draggables: state.dimensions.draggables
  });
  const destination = didDropInsideDroppable ? tryGetDestination(impact) : null;
  const combine2 = didDropInsideDroppable ? tryGetCombine(impact) : null;
  const source = {
    index: critical.draggable.index,
    droppableId: critical.droppable.id
  };
  const result = {
    draggableId: draggable2.descriptor.id,
    type: draggable2.descriptor.type,
    source,
    reason,
    mode: state.movementMode,
    destination,
    combine: combine2
  };
  const newHomeClientOffset = getNewHomeClientOffset({
    impact,
    draggable: draggable2,
    dimensions,
    viewport: state.viewport,
    afterCritical: state.afterCritical
  });
  const completed = {
    critical: state.critical,
    afterCritical: state.afterCritical,
    result,
    impact
  };
  const isAnimationRequired = !isEqual$1(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);
  if (!isAnimationRequired) {
    dispatch(completeDrop({
      completed
    }));
    return;
  }
  const dropDuration = getDropDuration({
    current: state.current.client.offset,
    destination: newHomeClientOffset,
    reason
  });
  const args = {
    newHomeClientOffset,
    dropDuration,
    completed
  };
  dispatch(animateDrop(args));
};
var getWindowScroll$1 = () => ({
  x: window.pageXOffset,
  y: window.pageYOffset
});
function getWindowScrollBinding(update2) {
  return {
    eventName: "scroll",
    options: {
      passive: true,
      capture: false
    },
    fn: (event) => {
      if (event.target !== window && event.target !== window.document) {
        return;
      }
      update2();
    }
  };
}
function getScrollListener({
  onWindowScroll
}) {
  function updateScroll() {
    onWindowScroll(getWindowScroll$1());
  }
  const scheduled = rafSchd(updateScroll);
  const binding = getWindowScrollBinding(scheduled);
  let unbind = noop$2;
  function isActive2() {
    return unbind !== noop$2;
  }
  function start2() {
    !!isActive2() ? invariant() : void 0;
    unbind = bindEvents(window, [binding]);
  }
  function stop() {
    !isActive2() ? invariant() : void 0;
    scheduled.cancel();
    unbind();
    unbind = noop$2;
  }
  return {
    start: start2,
    stop,
    isActive: isActive2
  };
}
const shouldStop$1 = (action) => guard(action, "DROP_COMPLETE") || guard(action, "DROP_ANIMATE") || guard(action, "FLUSH");
const scrollListener = (store) => {
  const listener = getScrollListener({
    onWindowScroll: (newScroll) => {
      store.dispatch(moveByWindowScroll({
        newScroll
      }));
    }
  });
  return (next) => (action) => {
    if (!listener.isActive() && guard(action, "INITIAL_PUBLISH")) {
      listener.start();
    }
    if (listener.isActive() && shouldStop$1(action)) {
      listener.stop();
    }
    next(action);
  };
};
var getExpiringAnnounce = (announce) => {
  let wasCalled = false;
  let isExpired = false;
  const timeoutId = setTimeout(() => {
    isExpired = true;
  });
  const result = (message2) => {
    if (wasCalled) {
      return;
    }
    if (isExpired) {
      return;
    }
    wasCalled = true;
    announce(message2);
    clearTimeout(timeoutId);
  };
  result.wasCalled = () => wasCalled;
  return result;
};
var getAsyncMarshal = () => {
  const entries = [];
  const execute2 = (timerId) => {
    const index2 = entries.findIndex((item) => item.timerId === timerId);
    !(index2 !== -1) ? invariant() : void 0;
    const [entry] = entries.splice(index2, 1);
    entry.callback();
  };
  const add2 = (fn2) => {
    const timerId = setTimeout(() => execute2(timerId));
    const entry = {
      timerId,
      callback: fn2
    };
    entries.push(entry);
  };
  const flush2 = () => {
    if (!entries.length) {
      return;
    }
    const shallow = [...entries];
    entries.length = 0;
    shallow.forEach((entry) => {
      clearTimeout(entry.timerId);
      entry.callback();
    });
  };
  return {
    add: add2,
    flush: flush2
  };
};
const areLocationsEqual = (first2, second) => {
  if (first2 == null && second == null) {
    return true;
  }
  if (first2 == null || second == null) {
    return false;
  }
  return first2.droppableId === second.droppableId && first2.index === second.index;
};
const isCombineEqual = (first2, second) => {
  if (first2 == null && second == null) {
    return true;
  }
  if (first2 == null || second == null) {
    return false;
  }
  return first2.draggableId === second.draggableId && first2.droppableId === second.droppableId;
};
const isCriticalEqual = (first2, second) => {
  if (first2 === second) {
    return true;
  }
  const isDraggableEqual = first2.draggable.id === second.draggable.id && first2.draggable.droppableId === second.draggable.droppableId && first2.draggable.type === second.draggable.type && first2.draggable.index === second.draggable.index;
  const isDroppableEqual = first2.droppable.id === second.droppable.id && first2.droppable.type === second.droppable.type;
  return isDraggableEqual && isDroppableEqual;
};
const withTimings = (key, fn2) => {
  fn2();
};
const getDragStart = (critical, mode) => ({
  draggableId: critical.draggable.id,
  type: critical.droppable.type,
  source: {
    droppableId: critical.droppable.id,
    index: critical.draggable.index
  },
  mode
});
function execute(responder, data, announce, getDefaultMessage) {
  if (!responder) {
    announce(getDefaultMessage(data));
    return;
  }
  const willExpire = getExpiringAnnounce(announce);
  const provided = {
    announce: willExpire
  };
  responder(data, provided);
  if (!willExpire.wasCalled()) {
    announce(getDefaultMessage(data));
  }
}
var getPublisher = (getResponders, announce) => {
  const asyncMarshal = getAsyncMarshal();
  let dragging = null;
  const beforeCapture = (draggableId, mode) => {
    !!dragging ? invariant() : void 0;
    withTimings("onBeforeCapture", () => {
      const fn2 = getResponders().onBeforeCapture;
      if (fn2) {
        const before = {
          draggableId,
          mode
        };
        fn2(before);
      }
    });
  };
  const beforeStart = (critical, mode) => {
    !!dragging ? invariant() : void 0;
    withTimings("onBeforeDragStart", () => {
      const fn2 = getResponders().onBeforeDragStart;
      if (fn2) {
        fn2(getDragStart(critical, mode));
      }
    });
  };
  const start2 = (critical, mode) => {
    !!dragging ? invariant() : void 0;
    const data = getDragStart(critical, mode);
    dragging = {
      mode,
      lastCritical: critical,
      lastLocation: data.source,
      lastCombine: null
    };
    asyncMarshal.add(() => {
      withTimings("onDragStart", () => execute(getResponders().onDragStart, data, announce, preset.onDragStart));
    });
  };
  const update2 = (critical, impact) => {
    const location = tryGetDestination(impact);
    const combine2 = tryGetCombine(impact);
    !dragging ? invariant() : void 0;
    const hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);
    if (hasCriticalChanged) {
      dragging.lastCritical = critical;
    }
    const hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);
    if (hasLocationChanged) {
      dragging.lastLocation = location;
    }
    const hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine2);
    if (hasGroupingChanged) {
      dragging.lastCombine = combine2;
    }
    if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {
      return;
    }
    const data = {
      ...getDragStart(critical, dragging.mode),
      combine: combine2,
      destination: location
    };
    asyncMarshal.add(() => {
      withTimings("onDragUpdate", () => execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate));
    });
  };
  const flush2 = () => {
    !dragging ? invariant() : void 0;
    asyncMarshal.flush();
  };
  const drop2 = (result) => {
    !dragging ? invariant() : void 0;
    dragging = null;
    withTimings("onDragEnd", () => execute(getResponders().onDragEnd, result, announce, preset.onDragEnd));
  };
  const abort = () => {
    if (!dragging) {
      return;
    }
    const result = {
      ...getDragStart(dragging.lastCritical, dragging.mode),
      combine: null,
      destination: null,
      reason: "CANCEL"
    };
    drop2(result);
  };
  return {
    beforeCapture,
    beforeStart,
    start: start2,
    update: update2,
    flush: flush2,
    drop: drop2,
    abort
  };
};
var responders = (getResponders, announce) => {
  const publisher = getPublisher(getResponders, announce);
  return (store) => (next) => (action) => {
    if (guard(action, "BEFORE_INITIAL_CAPTURE")) {
      publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);
      return;
    }
    if (guard(action, "INITIAL_PUBLISH")) {
      const critical = action.payload.critical;
      publisher.beforeStart(critical, action.payload.movementMode);
      next(action);
      publisher.start(critical, action.payload.movementMode);
      return;
    }
    if (guard(action, "DROP_COMPLETE")) {
      const result = action.payload.completed.result;
      publisher.flush();
      next(action);
      publisher.drop(result);
      return;
    }
    next(action);
    if (guard(action, "FLUSH")) {
      publisher.abort();
      return;
    }
    const state = store.getState();
    if (state.phase === "DRAGGING") {
      publisher.update(state.critical, state.impact);
    }
  };
};
const dropAnimationFinishMiddleware = (store) => (next) => (action) => {
  if (!guard(action, "DROP_ANIMATION_FINISHED")) {
    next(action);
    return;
  }
  const state = store.getState();
  !(state.phase === "DROP_ANIMATING") ? invariant() : void 0;
  store.dispatch(completeDrop({
    completed: state.completed
  }));
};
const dropAnimationFlushOnScrollMiddleware = (store) => {
  let unbind = null;
  let frameId = null;
  function clear() {
    if (frameId) {
      cancelAnimationFrame(frameId);
      frameId = null;
    }
    if (unbind) {
      unbind();
      unbind = null;
    }
  }
  return (next) => (action) => {
    if (guard(action, "FLUSH") || guard(action, "DROP_COMPLETE") || guard(action, "DROP_ANIMATION_FINISHED")) {
      clear();
    }
    next(action);
    if (!guard(action, "DROP_ANIMATE")) {
      return;
    }
    const binding = {
      eventName: "scroll",
      options: {
        capture: true,
        passive: false,
        once: true
      },
      fn: function flushDropAnimation() {
        const state = store.getState();
        if (state.phase === "DROP_ANIMATING") {
          store.dispatch(dropAnimationFinished());
        }
      }
    };
    frameId = requestAnimationFrame(() => {
      frameId = null;
      unbind = bindEvents(window, [binding]);
    });
  };
};
var dimensionMarshalStopper = (marshal) => () => (next) => (action) => {
  if (guard(action, "DROP_COMPLETE") || guard(action, "FLUSH") || guard(action, "DROP_ANIMATE")) {
    marshal.stopPublishing();
  }
  next(action);
};
var focus$2 = (marshal) => {
  let isWatching = false;
  return () => (next) => (action) => {
    if (guard(action, "INITIAL_PUBLISH")) {
      isWatching = true;
      marshal.tryRecordFocus(action.payload.critical.draggable.id);
      next(action);
      marshal.tryRestoreFocusRecorded();
      return;
    }
    next(action);
    if (!isWatching) {
      return;
    }
    if (guard(action, "FLUSH")) {
      isWatching = false;
      marshal.tryRestoreFocusRecorded();
      return;
    }
    if (guard(action, "DROP_COMPLETE")) {
      isWatching = false;
      const result = action.payload.completed.result;
      if (result.combine) {
        marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);
      }
      marshal.tryRestoreFocusRecorded();
    }
  };
};
const shouldStop = (action) => guard(action, "DROP_COMPLETE") || guard(action, "DROP_ANIMATE") || guard(action, "FLUSH");
var autoScroll = (autoScroller) => (store) => (next) => (action) => {
  if (shouldStop(action)) {
    autoScroller.stop();
    next(action);
    return;
  }
  if (guard(action, "INITIAL_PUBLISH")) {
    next(action);
    const state = store.getState();
    !(state.phase === "DRAGGING") ? invariant() : void 0;
    autoScroller.start(state);
    return;
  }
  next(action);
  autoScroller.scroll(store.getState());
};
const pendingDrop = (store) => (next) => (action) => {
  next(action);
  if (!guard(action, "PUBLISH_WHILE_DRAGGING")) {
    return;
  }
  const postActionState = store.getState();
  if (postActionState.phase !== "DROP_PENDING") {
    return;
  }
  if (postActionState.isWaiting) {
    return;
  }
  store.dispatch(drop({
    reason: postActionState.reason
  }));
};
const composeEnhancers = compose;
var createStore = ({
  dimensionMarshal,
  focusMarshal,
  styleMarshal,
  getResponders,
  announce,
  autoScroller
}) => createStore$1(reducer, composeEnhancers(applyMiddleware(style$1(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift$4(dimensionMarshal), dropMiddleware, dropAnimationFinishMiddleware, dropAnimationFlushOnScrollMiddleware, pendingDrop, autoScroll(autoScroller), scrollListener, focus$2(focusMarshal), responders(getResponders, announce))));
const clean$1 = () => ({
  additions: {},
  removals: {},
  modified: {}
});
function createPublisher({
  registry,
  callbacks
}) {
  let staging = clean$1();
  let frameId = null;
  const collect = () => {
    if (frameId) {
      return;
    }
    callbacks.collectionStarting();
    frameId = requestAnimationFrame(() => {
      frameId = null;
      const {
        additions,
        removals,
        modified
      } = staging;
      const added = Object.keys(additions).map((id2) => registry.draggable.getById(id2).getDimension(origin)).sort((a2, b) => a2.descriptor.index - b.descriptor.index);
      const updated = Object.keys(modified).map((id2) => {
        const entry = registry.droppable.getById(id2);
        const scroll2 = entry.callbacks.getScrollWhileDragging();
        return {
          droppableId: id2,
          scroll: scroll2
        };
      });
      const result = {
        additions: added,
        removals: Object.keys(removals),
        modified: updated
      };
      staging = clean$1();
      callbacks.publish(result);
    });
  };
  const add2 = (entry) => {
    const id2 = entry.descriptor.id;
    staging.additions[id2] = entry;
    staging.modified[entry.descriptor.droppableId] = true;
    if (staging.removals[id2]) {
      delete staging.removals[id2];
    }
    collect();
  };
  const remove = (entry) => {
    const descriptor = entry.descriptor;
    staging.removals[descriptor.id] = true;
    staging.modified[descriptor.droppableId] = true;
    if (staging.additions[descriptor.id]) {
      delete staging.additions[descriptor.id];
    }
    collect();
  };
  const stop = () => {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
    staging = clean$1();
  };
  return {
    add: add2,
    remove,
    stop
  };
}
var getMaxScroll = ({
  scrollHeight,
  scrollWidth,
  height,
  width
}) => {
  const maxScroll = subtract({
    x: scrollWidth,
    y: scrollHeight
  }, {
    x: width,
    y: height
  });
  const adjustedMaxScroll = {
    x: Math.max(0, maxScroll.x),
    y: Math.max(0, maxScroll.y)
  };
  return adjustedMaxScroll;
};
var getDocumentElement$1 = () => {
  const doc2 = document.documentElement;
  !doc2 ? invariant() : void 0;
  return doc2;
};
var getMaxWindowScroll = () => {
  const doc2 = getDocumentElement$1();
  const maxScroll = getMaxScroll({
    scrollHeight: doc2.scrollHeight,
    scrollWidth: doc2.scrollWidth,
    width: doc2.clientWidth,
    height: doc2.clientHeight
  });
  return maxScroll;
};
var getViewport = () => {
  const scroll2 = getWindowScroll$1();
  const maxScroll = getMaxWindowScroll();
  const top2 = scroll2.y;
  const left2 = scroll2.x;
  const doc2 = getDocumentElement$1();
  const width = doc2.clientWidth;
  const height = doc2.clientHeight;
  const right2 = left2 + width;
  const bottom2 = top2 + height;
  const frame = getRect({
    top: top2,
    left: left2,
    right: right2,
    bottom: bottom2
  });
  const viewport2 = {
    frame,
    scroll: {
      initial: scroll2,
      current: scroll2,
      max: maxScroll,
      diff: {
        value: origin,
        displacement: origin
      }
    }
  };
  return viewport2;
};
var getInitialPublish = ({
  critical,
  scrollOptions,
  registry
}) => {
  const viewport2 = getViewport();
  const windowScroll = viewport2.scroll.current;
  const home2 = critical.droppable;
  const droppables = registry.droppable.getAllByType(home2.type).map((entry) => entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions));
  const draggables = registry.draggable.getAllByType(critical.draggable.type).map((entry) => entry.getDimension(windowScroll));
  const dimensions = {
    draggables: toDraggableMap(draggables),
    droppables: toDroppableMap(droppables)
  };
  const result = {
    dimensions,
    critical,
    viewport: viewport2
  };
  return result;
};
function shouldPublishUpdate(registry, dragging, entry) {
  if (entry.descriptor.id === dragging.id) {
    return false;
  }
  if (entry.descriptor.type !== dragging.type) {
    return false;
  }
  const home2 = registry.droppable.getById(entry.descriptor.droppableId);
  if (home2.descriptor.mode !== "virtual") {
    return false;
  }
  return true;
}
var createDimensionMarshal = (registry, callbacks) => {
  let collection = null;
  const publisher = createPublisher({
    callbacks: {
      publish: callbacks.publishWhileDragging,
      collectionStarting: callbacks.collectionStarting
    },
    registry
  });
  const updateDroppableIsEnabled2 = (id2, isEnabled) => {
    !registry.droppable.exists(id2) ? invariant() : void 0;
    if (!collection) {
      return;
    }
    callbacks.updateDroppableIsEnabled({
      id: id2,
      isEnabled
    });
  };
  const updateDroppableIsCombineEnabled2 = (id2, isCombineEnabled) => {
    if (!collection) {
      return;
    }
    !registry.droppable.exists(id2) ? invariant() : void 0;
    callbacks.updateDroppableIsCombineEnabled({
      id: id2,
      isCombineEnabled
    });
  };
  const updateDroppableScroll2 = (id2, newScroll) => {
    if (!collection) {
      return;
    }
    !registry.droppable.exists(id2) ? invariant() : void 0;
    callbacks.updateDroppableScroll({
      id: id2,
      newScroll
    });
  };
  const scrollDroppable2 = (id2, change) => {
    if (!collection) {
      return;
    }
    registry.droppable.getById(id2).callbacks.scroll(change);
  };
  const stopPublishing = () => {
    if (!collection) {
      return;
    }
    publisher.stop();
    const home2 = collection.critical.droppable;
    registry.droppable.getAllByType(home2.type).forEach((entry) => entry.callbacks.dragStopped());
    collection.unsubscribe();
    collection = null;
  };
  const subscriber = (event) => {
    !collection ? invariant() : void 0;
    const dragging = collection.critical.draggable;
    if (event.type === "ADDITION") {
      if (shouldPublishUpdate(registry, dragging, event.value)) {
        publisher.add(event.value);
      }
    }
    if (event.type === "REMOVAL") {
      if (shouldPublishUpdate(registry, dragging, event.value)) {
        publisher.remove(event.value);
      }
    }
  };
  const startPublishing = (request) => {
    !!collection ? invariant() : void 0;
    const entry = registry.draggable.getById(request.draggableId);
    const home2 = registry.droppable.getById(entry.descriptor.droppableId);
    const critical = {
      draggable: entry.descriptor,
      droppable: home2.descriptor
    };
    const unsubscribe = registry.subscribe(subscriber);
    collection = {
      critical,
      unsubscribe
    };
    return getInitialPublish({
      critical,
      registry,
      scrollOptions: request.scrollOptions
    });
  };
  const marshal = {
    updateDroppableIsEnabled: updateDroppableIsEnabled2,
    updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled2,
    scrollDroppable: scrollDroppable2,
    updateDroppableScroll: updateDroppableScroll2,
    startPublishing,
    stopPublishing
  };
  return marshal;
};
var canStartDrag = (state, id2) => {
  if (state.phase === "IDLE") {
    return true;
  }
  if (state.phase !== "DROP_ANIMATING") {
    return false;
  }
  if (state.completed.result.draggableId === id2) {
    return false;
  }
  return state.completed.result.reason === "DROP";
};
var scrollWindow = (change) => {
  window.scrollBy(change.x, change.y);
};
const getScrollableDroppables = memoizeOne$1((droppables) => toDroppableList(droppables).filter((droppable2) => {
  if (!droppable2.isEnabled) {
    return false;
  }
  if (!droppable2.frame) {
    return false;
  }
  return true;
}));
const getScrollableDroppableOver = (target, droppables) => {
  const maybe = getScrollableDroppables(droppables).find((droppable2) => {
    !droppable2.frame ? invariant() : void 0;
    return isPositionInFrame(droppable2.frame.pageMarginBox)(target);
  }) || null;
  return maybe;
};
var getBestScrollableDroppable = ({
  center,
  destination,
  droppables
}) => {
  if (destination) {
    const dimension2 = droppables[destination];
    if (!dimension2.frame) {
      return null;
    }
    return dimension2;
  }
  const dimension = getScrollableDroppableOver(center, droppables);
  return dimension;
};
const defaultAutoScrollerOptions = {
  startFromPercentage: 0.25,
  maxScrollAtPercentage: 0.05,
  maxPixelScroll: 28,
  ease: (percentage) => percentage ** 2,
  durationDampening: {
    stopDampeningAt: 1200,
    accelerateAt: 360
  },
  disabled: false
};
var getDistanceThresholds = (container, axis, getAutoScrollerOptions = () => defaultAutoScrollerOptions) => {
  const autoScrollerOptions = getAutoScrollerOptions();
  const startScrollingFrom = container[axis.size] * autoScrollerOptions.startFromPercentage;
  const maxScrollValueAt = container[axis.size] * autoScrollerOptions.maxScrollAtPercentage;
  const thresholds = {
    startScrollingFrom,
    maxScrollValueAt
  };
  return thresholds;
};
var getPercentage = ({
  startOfRange,
  endOfRange,
  current
}) => {
  const range = endOfRange - startOfRange;
  if (range === 0) {
    return 0;
  }
  const currentInRange = current - startOfRange;
  const percentage = currentInRange / range;
  return percentage;
};
var minScroll = 1;
var getValueFromDistance = (distanceToEdge, thresholds, getAutoScrollerOptions = () => defaultAutoScrollerOptions) => {
  const autoScrollerOptions = getAutoScrollerOptions();
  if (distanceToEdge > thresholds.startScrollingFrom) {
    return 0;
  }
  if (distanceToEdge <= thresholds.maxScrollValueAt) {
    return autoScrollerOptions.maxPixelScroll;
  }
  if (distanceToEdge === thresholds.startScrollingFrom) {
    return minScroll;
  }
  const percentageFromMaxScrollValueAt = getPercentage({
    startOfRange: thresholds.maxScrollValueAt,
    endOfRange: thresholds.startScrollingFrom,
    current: distanceToEdge
  });
  const percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;
  const scroll2 = autoScrollerOptions.maxPixelScroll * autoScrollerOptions.ease(percentageFromStartScrollingFrom);
  return Math.ceil(scroll2);
};
var dampenValueByTime = (proposedScroll, dragStartTime, getAutoScrollerOptions) => {
  const autoScrollerOptions = getAutoScrollerOptions();
  const accelerateAt = autoScrollerOptions.durationDampening.accelerateAt;
  const stopAt = autoScrollerOptions.durationDampening.stopDampeningAt;
  const startOfRange = dragStartTime;
  const endOfRange = stopAt;
  const now2 = Date.now();
  const runTime = now2 - startOfRange;
  if (runTime >= stopAt) {
    return proposedScroll;
  }
  if (runTime < accelerateAt) {
    return minScroll;
  }
  const betweenAccelerateAtAndStopAtPercentage = getPercentage({
    startOfRange: accelerateAt,
    endOfRange,
    current: runTime
  });
  const scroll2 = proposedScroll * autoScrollerOptions.ease(betweenAccelerateAtAndStopAtPercentage);
  return Math.ceil(scroll2);
};
var getValue = ({
  distanceToEdge,
  thresholds,
  dragStartTime,
  shouldUseTimeDampening,
  getAutoScrollerOptions
}) => {
  const scroll2 = getValueFromDistance(distanceToEdge, thresholds, getAutoScrollerOptions);
  if (scroll2 === 0) {
    return 0;
  }
  if (!shouldUseTimeDampening) {
    return scroll2;
  }
  return Math.max(dampenValueByTime(scroll2, dragStartTime, getAutoScrollerOptions), minScroll);
};
var getScrollOnAxis = ({
  container,
  distanceToEdges,
  dragStartTime,
  axis,
  shouldUseTimeDampening,
  getAutoScrollerOptions
}) => {
  const thresholds = getDistanceThresholds(container, axis, getAutoScrollerOptions);
  const isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];
  if (isCloserToEnd) {
    return getValue({
      distanceToEdge: distanceToEdges[axis.end],
      thresholds,
      dragStartTime,
      shouldUseTimeDampening,
      getAutoScrollerOptions
    });
  }
  return -1 * getValue({
    distanceToEdge: distanceToEdges[axis.start],
    thresholds,
    dragStartTime,
    shouldUseTimeDampening,
    getAutoScrollerOptions
  });
};
var adjustForSizeLimits = ({
  container,
  subject,
  proposedScroll
}) => {
  const isTooBigVertically = subject.height > container.height;
  const isTooBigHorizontally = subject.width > container.width;
  if (!isTooBigHorizontally && !isTooBigVertically) {
    return proposedScroll;
  }
  if (isTooBigHorizontally && isTooBigVertically) {
    return null;
  }
  return {
    x: isTooBigHorizontally ? 0 : proposedScroll.x,
    y: isTooBigVertically ? 0 : proposedScroll.y
  };
};
const clean = apply$1((value) => value === 0 ? 0 : value);
var getScroll$1 = ({
  dragStartTime,
  container,
  subject,
  center,
  shouldUseTimeDampening,
  getAutoScrollerOptions
}) => {
  const distanceToEdges = {
    top: center.y - container.top,
    right: container.right - center.x,
    bottom: container.bottom - center.y,
    left: center.x - container.left
  };
  const y = getScrollOnAxis({
    container,
    distanceToEdges,
    dragStartTime,
    axis: vertical,
    shouldUseTimeDampening,
    getAutoScrollerOptions
  });
  const x = getScrollOnAxis({
    container,
    distanceToEdges,
    dragStartTime,
    axis: horizontal,
    shouldUseTimeDampening,
    getAutoScrollerOptions
  });
  const required2 = clean({
    x,
    y
  });
  if (isEqual$1(required2, origin)) {
    return null;
  }
  const limited = adjustForSizeLimits({
    container,
    subject,
    proposedScroll: required2
  });
  if (!limited) {
    return null;
  }
  return isEqual$1(limited, origin) ? null : limited;
};
const smallestSigned = apply$1((value) => {
  if (value === 0) {
    return 0;
  }
  return value > 0 ? 1 : -1;
});
const getOverlap = /* @__PURE__ */ (() => {
  const getRemainder = (target, max2) => {
    if (target < 0) {
      return target;
    }
    if (target > max2) {
      return target - max2;
    }
    return 0;
  };
  return ({
    current,
    max: max2,
    change
  }) => {
    const targetScroll = add(current, change);
    const overlap = {
      x: getRemainder(targetScroll.x, max2.x),
      y: getRemainder(targetScroll.y, max2.y)
    };
    if (isEqual$1(overlap, origin)) {
      return null;
    }
    return overlap;
  };
})();
const canPartiallyScroll = ({
  max: rawMax,
  current,
  change
}) => {
  const max2 = {
    x: Math.max(current.x, rawMax.x),
    y: Math.max(current.y, rawMax.y)
  };
  const smallestChange = smallestSigned(change);
  const overlap = getOverlap({
    max: max2,
    current,
    change: smallestChange
  });
  if (!overlap) {
    return true;
  }
  if (smallestChange.x !== 0 && overlap.x === 0) {
    return true;
  }
  if (smallestChange.y !== 0 && overlap.y === 0) {
    return true;
  }
  return false;
};
const canScrollWindow = (viewport2, change) => canPartiallyScroll({
  current: viewport2.scroll.current,
  max: viewport2.scroll.max,
  change
});
const getWindowOverlap = (viewport2, change) => {
  if (!canScrollWindow(viewport2, change)) {
    return null;
  }
  const max2 = viewport2.scroll.max;
  const current = viewport2.scroll.current;
  return getOverlap({
    current,
    max: max2,
    change
  });
};
const canScrollDroppable = (droppable2, change) => {
  const frame = droppable2.frame;
  if (!frame) {
    return false;
  }
  return canPartiallyScroll({
    current: frame.scroll.current,
    max: frame.scroll.max,
    change
  });
};
const getDroppableOverlap = (droppable2, change) => {
  const frame = droppable2.frame;
  if (!frame) {
    return null;
  }
  if (!canScrollDroppable(droppable2, change)) {
    return null;
  }
  return getOverlap({
    current: frame.scroll.current,
    max: frame.scroll.max,
    change
  });
};
var getWindowScrollChange = ({
  viewport: viewport2,
  subject,
  center,
  dragStartTime,
  shouldUseTimeDampening,
  getAutoScrollerOptions
}) => {
  const scroll2 = getScroll$1({
    dragStartTime,
    container: viewport2.frame,
    subject,
    center,
    shouldUseTimeDampening,
    getAutoScrollerOptions
  });
  return scroll2 && canScrollWindow(viewport2, scroll2) ? scroll2 : null;
};
var getDroppableScrollChange = ({
  droppable: droppable2,
  subject,
  center,
  dragStartTime,
  shouldUseTimeDampening,
  getAutoScrollerOptions
}) => {
  const frame = droppable2.frame;
  if (!frame) {
    return null;
  }
  const scroll2 = getScroll$1({
    dragStartTime,
    container: frame.pageMarginBox,
    subject,
    center,
    shouldUseTimeDampening,
    getAutoScrollerOptions
  });
  return scroll2 && canScrollDroppable(droppable2, scroll2) ? scroll2 : null;
};
var scroll = ({
  state,
  dragStartTime,
  shouldUseTimeDampening,
  scrollWindow: scrollWindow2,
  scrollDroppable: scrollDroppable2,
  getAutoScrollerOptions
}) => {
  const center = state.current.page.borderBoxCenter;
  const draggable2 = state.dimensions.draggables[state.critical.draggable.id];
  const subject = draggable2.page.marginBox;
  if (state.isWindowScrollAllowed) {
    const viewport2 = state.viewport;
    const change2 = getWindowScrollChange({
      dragStartTime,
      viewport: viewport2,
      subject,
      center,
      shouldUseTimeDampening,
      getAutoScrollerOptions
    });
    if (change2) {
      scrollWindow2(change2);
      return;
    }
  }
  const droppable2 = getBestScrollableDroppable({
    center,
    destination: whatIsDraggedOver(state.impact),
    droppables: state.dimensions.droppables
  });
  if (!droppable2) {
    return;
  }
  const change = getDroppableScrollChange({
    dragStartTime,
    droppable: droppable2,
    subject,
    center,
    shouldUseTimeDampening,
    getAutoScrollerOptions
  });
  if (change) {
    scrollDroppable2(droppable2.descriptor.id, change);
  }
};
var createFluidScroller = ({
  scrollWindow: scrollWindow2,
  scrollDroppable: scrollDroppable2,
  getAutoScrollerOptions = () => defaultAutoScrollerOptions
}) => {
  const scheduleWindowScroll = rafSchd(scrollWindow2);
  const scheduleDroppableScroll = rafSchd(scrollDroppable2);
  let dragging = null;
  const tryScroll = (state) => {
    !dragging ? invariant() : void 0;
    const {
      shouldUseTimeDampening,
      dragStartTime
    } = dragging;
    scroll({
      state,
      scrollWindow: scheduleWindowScroll,
      scrollDroppable: scheduleDroppableScroll,
      dragStartTime,
      shouldUseTimeDampening,
      getAutoScrollerOptions
    });
  };
  const start$1 = (state) => {
    !!dragging ? invariant() : void 0;
    const dragStartTime = Date.now();
    let wasScrollNeeded = false;
    const fakeScrollCallback = () => {
      wasScrollNeeded = true;
    };
    scroll({
      state,
      dragStartTime: 0,
      shouldUseTimeDampening: false,
      scrollWindow: fakeScrollCallback,
      scrollDroppable: fakeScrollCallback,
      getAutoScrollerOptions
    });
    dragging = {
      dragStartTime,
      shouldUseTimeDampening: wasScrollNeeded
    };
    if (wasScrollNeeded) {
      tryScroll(state);
    }
  };
  const stop = () => {
    if (!dragging) {
      return;
    }
    scheduleWindowScroll.cancel();
    scheduleDroppableScroll.cancel();
    dragging = null;
  };
  return {
    start: start$1,
    stop,
    scroll: tryScroll
  };
};
var createJumpScroller = ({
  move: move2,
  scrollDroppable: scrollDroppable2,
  scrollWindow: scrollWindow2
}) => {
  const moveByOffset = (state, offset22) => {
    const client = add(state.current.client.selection, offset22);
    move2({
      client
    });
  };
  const scrollDroppableAsMuchAsItCan = (droppable2, change) => {
    if (!canScrollDroppable(droppable2, change)) {
      return change;
    }
    const overlap = getDroppableOverlap(droppable2, change);
    if (!overlap) {
      scrollDroppable2(droppable2.descriptor.id, change);
      return null;
    }
    const whatTheDroppableCanScroll = subtract(change, overlap);
    scrollDroppable2(droppable2.descriptor.id, whatTheDroppableCanScroll);
    const remainder = subtract(change, whatTheDroppableCanScroll);
    return remainder;
  };
  const scrollWindowAsMuchAsItCan = (isWindowScrollAllowed, viewport2, change) => {
    if (!isWindowScrollAllowed) {
      return change;
    }
    if (!canScrollWindow(viewport2, change)) {
      return change;
    }
    const overlap = getWindowOverlap(viewport2, change);
    if (!overlap) {
      scrollWindow2(change);
      return null;
    }
    const whatTheWindowCanScroll = subtract(change, overlap);
    scrollWindow2(whatTheWindowCanScroll);
    const remainder = subtract(change, whatTheWindowCanScroll);
    return remainder;
  };
  const jumpScroller = (state) => {
    const request = state.scrollJumpRequest;
    if (!request) {
      return;
    }
    const destination = whatIsDraggedOver(state.impact);
    !destination ? invariant() : void 0;
    const droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);
    if (!droppableRemainder) {
      return;
    }
    const viewport2 = state.viewport;
    const windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport2, droppableRemainder);
    if (!windowRemainder) {
      return;
    }
    moveByOffset(state, windowRemainder);
  };
  return jumpScroller;
};
var createAutoScroller = ({
  scrollDroppable: scrollDroppable2,
  scrollWindow: scrollWindow2,
  move: move2,
  getAutoScrollerOptions
}) => {
  const fluidScroller = createFluidScroller({
    scrollWindow: scrollWindow2,
    scrollDroppable: scrollDroppable2,
    getAutoScrollerOptions
  });
  const jumpScroll = createJumpScroller({
    move: move2,
    scrollWindow: scrollWindow2,
    scrollDroppable: scrollDroppable2
  });
  const scroll2 = (state) => {
    const autoScrollerOptions = getAutoScrollerOptions();
    if (autoScrollerOptions.disabled || state.phase !== "DRAGGING") {
      return;
    }
    if (state.movementMode === "FLUID") {
      fluidScroller.scroll(state);
      return;
    }
    if (!state.scrollJumpRequest) {
      return;
    }
    jumpScroll(state);
  };
  const scroller = {
    scroll: scroll2,
    start: fluidScroller.start,
    stop: fluidScroller.stop
  };
  return scroller;
};
const prefix = "data-rfd";
const dragHandle = (() => {
  const base2 = `${prefix}-drag-handle`;
  return {
    base: base2,
    draggableId: `${base2}-draggable-id`,
    contextId: `${base2}-context-id`
  };
})();
const draggable = (() => {
  const base2 = `${prefix}-draggable`;
  return {
    base: base2,
    contextId: `${base2}-context-id`,
    id: `${base2}-id`
  };
})();
const droppable = (() => {
  const base2 = `${prefix}-droppable`;
  return {
    base: base2,
    contextId: `${base2}-context-id`,
    id: `${base2}-id`
  };
})();
const scrollContainer = {
  contextId: `${prefix}-scroll-container-context-id`
};
const makeGetSelector = (context) => (attribute) => `[${attribute}="${context}"]`;
const getStyles = (rules, property2) => rules.map((rule) => {
  const value = rule.styles[property2];
  if (!value) {
    return "";
  }
  return `${rule.selector} { ${value} }`;
}).join(" ");
const noPointerEvents = "pointer-events: none;";
var getStyles$1 = (contextId) => {
  const getSelector2 = makeGetSelector(contextId);
  const dragHandle$1 = (() => {
    const grabCursor = `
      cursor: -webkit-grab;
      cursor: grab;
    `;
    return {
      selector: getSelector2(dragHandle.contextId),
      styles: {
        always: `
          -webkit-touch-callout: none;
          -webkit-tap-highlight-color: rgba(0,0,0,0);
          touch-action: manipulation;
        `,
        resting: grabCursor,
        dragging: noPointerEvents,
        dropAnimating: grabCursor
      }
    };
  })();
  const draggable$1 = (() => {
    const transition = `
      transition: ${transitions.outOfTheWay};
    `;
    return {
      selector: getSelector2(draggable.contextId),
      styles: {
        dragging: transition,
        dropAnimating: transition,
        userCancel: transition
      }
    };
  })();
  const droppable$1 = {
    selector: getSelector2(droppable.contextId),
    styles: {
      always: `overflow-anchor: none;`
    }
  };
  const body = {
    selector: "body",
    styles: {
      dragging: `
        cursor: grabbing;
        cursor: -webkit-grabbing;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        overflow-anchor: none;
      `
    }
  };
  const rules = [draggable$1, dragHandle$1, droppable$1, body];
  return {
    always: getStyles(rules, "always"),
    resting: getStyles(rules, "resting"),
    dragging: getStyles(rules, "dragging"),
    dropAnimating: getStyles(rules, "dropAnimating"),
    userCancel: getStyles(rules, "userCancel")
  };
};
const useIsomorphicLayoutEffect$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? useLayoutEffect$2 : useEffect$3;
const getHead = () => {
  const head = document.querySelector("head");
  !head ? invariant() : void 0;
  return head;
};
const createStyleEl = (nonce) => {
  const el2 = document.createElement("style");
  if (nonce) {
    el2.setAttribute("nonce", nonce);
  }
  el2.type = "text/css";
  return el2;
};
function useStyleMarshal(contextId, nonce) {
  const styles2 = useMemo$2(() => getStyles$1(contextId), [contextId]);
  const alwaysRef = useRef$3(null);
  const dynamicRef = useRef$3(null);
  const setDynamicStyle = useCallback$1(memoizeOne$1((proposed) => {
    const el2 = dynamicRef.current;
    !el2 ? invariant() : void 0;
    el2.textContent = proposed;
  }), []);
  const setAlwaysStyle = useCallback$1((proposed) => {
    const el2 = alwaysRef.current;
    !el2 ? invariant() : void 0;
    el2.textContent = proposed;
  }, []);
  useIsomorphicLayoutEffect$1(() => {
    !(!alwaysRef.current && !dynamicRef.current) ? invariant() : void 0;
    const always = createStyleEl(nonce);
    const dynamic = createStyleEl(nonce);
    alwaysRef.current = always;
    dynamicRef.current = dynamic;
    always.setAttribute(`${prefix}-always`, contextId);
    dynamic.setAttribute(`${prefix}-dynamic`, contextId);
    getHead().appendChild(always);
    getHead().appendChild(dynamic);
    setAlwaysStyle(styles2.always);
    setDynamicStyle(styles2.resting);
    return () => {
      const remove = (ref2) => {
        const current = ref2.current;
        !current ? invariant() : void 0;
        getHead().removeChild(current);
        ref2.current = null;
      };
      remove(alwaysRef);
      remove(dynamicRef);
    };
  }, [nonce, setAlwaysStyle, setDynamicStyle, styles2.always, styles2.resting, contextId]);
  const dragging = useCallback$1(() => setDynamicStyle(styles2.dragging), [setDynamicStyle, styles2.dragging]);
  const dropping = useCallback$1((reason) => {
    if (reason === "DROP") {
      setDynamicStyle(styles2.dropAnimating);
      return;
    }
    setDynamicStyle(styles2.userCancel);
  }, [setDynamicStyle, styles2.dropAnimating, styles2.userCancel]);
  const resting = useCallback$1(() => {
    if (!dynamicRef.current) {
      return;
    }
    setDynamicStyle(styles2.resting);
  }, [setDynamicStyle, styles2.resting]);
  const marshal = useMemo$2(() => ({
    dragging,
    dropping,
    resting
  }), [dragging, dropping, resting]);
  return marshal;
}
function querySelectorAll(parentNode2, selector) {
  return Array.from(parentNode2.querySelectorAll(selector));
}
var getWindowFromEl = (el2) => {
  if (el2 && el2.ownerDocument && el2.ownerDocument.defaultView) {
    return el2.ownerDocument.defaultView;
  }
  return window;
};
function isHtmlElement(el2) {
  return el2 instanceof getWindowFromEl(el2).HTMLElement;
}
function findDragHandle(contextId, draggableId) {
  const selector = `[${dragHandle.contextId}="${contextId}"]`;
  const possible = querySelectorAll(document, selector);
  if (!possible.length) {
    return null;
  }
  const handle = possible.find((el2) => {
    return el2.getAttribute(dragHandle.draggableId) === draggableId;
  });
  if (!handle) {
    return null;
  }
  if (!isHtmlElement(handle)) {
    return null;
  }
  return handle;
}
function useFocusMarshal(contextId) {
  const entriesRef = useRef$3({});
  const recordRef = useRef$3(null);
  const restoreFocusFrameRef = useRef$3(null);
  const isMountedRef = useRef$3(false);
  const register = useCallback$1(function register2(id2, focus2) {
    const entry = {
      id: id2,
      focus: focus2
    };
    entriesRef.current[id2] = entry;
    return function unregister() {
      const entries = entriesRef.current;
      const current = entries[id2];
      if (current !== entry) {
        delete entries[id2];
      }
    };
  }, []);
  const tryGiveFocus = useCallback$1(function tryGiveFocus2(tryGiveFocusTo) {
    const handle = findDragHandle(contextId, tryGiveFocusTo);
    if (handle && handle !== document.activeElement) {
      handle.focus();
    }
  }, [contextId]);
  const tryShiftRecord = useCallback$1(function tryShiftRecord2(previous, redirectTo) {
    if (recordRef.current === previous) {
      recordRef.current = redirectTo;
    }
  }, []);
  const tryRestoreFocusRecorded = useCallback$1(function tryRestoreFocusRecorded2() {
    if (restoreFocusFrameRef.current) {
      return;
    }
    if (!isMountedRef.current) {
      return;
    }
    restoreFocusFrameRef.current = requestAnimationFrame(() => {
      restoreFocusFrameRef.current = null;
      const record = recordRef.current;
      if (record) {
        tryGiveFocus(record);
      }
    });
  }, [tryGiveFocus]);
  const tryRecordFocus = useCallback$1(function tryRecordFocus2(id2) {
    recordRef.current = null;
    const focused = document.activeElement;
    if (!focused) {
      return;
    }
    if (focused.getAttribute(dragHandle.draggableId) !== id2) {
      return;
    }
    recordRef.current = id2;
  }, []);
  useIsomorphicLayoutEffect$1(() => {
    isMountedRef.current = true;
    return function clearFrameOnUnmount() {
      isMountedRef.current = false;
      const frameId = restoreFocusFrameRef.current;
      if (frameId) {
        cancelAnimationFrame(frameId);
      }
    };
  }, []);
  const marshal = useMemo$2(() => ({
    register,
    tryRecordFocus,
    tryRestoreFocusRecorded,
    tryShiftRecord
  }), [register, tryRecordFocus, tryRestoreFocusRecorded, tryShiftRecord]);
  return marshal;
}
function createRegistry() {
  const entries = {
    draggables: {},
    droppables: {}
  };
  const subscribers = [];
  function subscribe(cb) {
    subscribers.push(cb);
    return function unsubscribe() {
      const index2 = subscribers.indexOf(cb);
      if (index2 === -1) {
        return;
      }
      subscribers.splice(index2, 1);
    };
  }
  function notify(event) {
    if (subscribers.length) {
      subscribers.forEach((cb) => cb(event));
    }
  }
  function findDraggableById(id2) {
    return entries.draggables[id2] || null;
  }
  function getDraggableById(id2) {
    const entry = findDraggableById(id2);
    !entry ? invariant() : void 0;
    return entry;
  }
  const draggableAPI = {
    register: (entry) => {
      entries.draggables[entry.descriptor.id] = entry;
      notify({
        type: "ADDITION",
        value: entry
      });
    },
    update: (entry, last) => {
      const current = entries.draggables[last.descriptor.id];
      if (!current) {
        return;
      }
      if (current.uniqueId !== entry.uniqueId) {
        return;
      }
      delete entries.draggables[last.descriptor.id];
      entries.draggables[entry.descriptor.id] = entry;
    },
    unregister: (entry) => {
      const draggableId = entry.descriptor.id;
      const current = findDraggableById(draggableId);
      if (!current) {
        return;
      }
      if (entry.uniqueId !== current.uniqueId) {
        return;
      }
      delete entries.draggables[draggableId];
      if (entries.droppables[entry.descriptor.droppableId]) {
        notify({
          type: "REMOVAL",
          value: entry
        });
      }
    },
    getById: getDraggableById,
    findById: findDraggableById,
    exists: (id2) => Boolean(findDraggableById(id2)),
    getAllByType: (type) => Object.values(entries.draggables).filter((entry) => entry.descriptor.type === type)
  };
  function findDroppableById(id2) {
    return entries.droppables[id2] || null;
  }
  function getDroppableById(id2) {
    const entry = findDroppableById(id2);
    !entry ? invariant() : void 0;
    return entry;
  }
  const droppableAPI = {
    register: (entry) => {
      entries.droppables[entry.descriptor.id] = entry;
    },
    unregister: (entry) => {
      const current = findDroppableById(entry.descriptor.id);
      if (!current) {
        return;
      }
      if (entry.uniqueId !== current.uniqueId) {
        return;
      }
      delete entries.droppables[entry.descriptor.id];
    },
    getById: getDroppableById,
    findById: findDroppableById,
    exists: (id2) => Boolean(findDroppableById(id2)),
    getAllByType: (type) => Object.values(entries.droppables).filter((entry) => entry.descriptor.type === type)
  };
  function clean2() {
    entries.draggables = {};
    entries.droppables = {};
    subscribers.length = 0;
  }
  return {
    draggable: draggableAPI,
    droppable: droppableAPI,
    subscribe,
    clean: clean2
  };
}
function useRegistry() {
  const registry = useMemo$2(createRegistry, []);
  useEffect$3(() => {
    return function unmount() {
      registry.clean();
    };
  }, [registry]);
  return registry;
}
var StoreContext = React$3.createContext(null);
var getBodyElement = () => {
  const body = document.body;
  !body ? invariant() : void 0;
  return body;
};
const visuallyHidden = {
  position: "absolute",
  width: "1px",
  height: "1px",
  margin: "-1px",
  border: "0",
  padding: "0",
  overflow: "hidden",
  clip: "rect(0 0 0 0)",
  "clip-path": "inset(100%)"
};
const getId = (contextId) => `rfd-announcement-${contextId}`;
function useAnnouncer(contextId) {
  const id2 = useMemo$2(() => getId(contextId), [contextId]);
  const ref2 = useRef$3(null);
  useEffect$3(function setup() {
    const el2 = document.createElement("div");
    ref2.current = el2;
    el2.id = id2;
    el2.setAttribute("aria-live", "assertive");
    el2.setAttribute("aria-atomic", "true");
    _extends$9(el2.style, visuallyHidden);
    getBodyElement().appendChild(el2);
    return function cleanup() {
      setTimeout(function remove() {
        const body = getBodyElement();
        if (body.contains(el2)) {
          body.removeChild(el2);
        }
        if (el2 === ref2.current) {
          ref2.current = null;
        }
      });
    };
  }, [id2]);
  const announce = useCallback$1((message2) => {
    const el2 = ref2.current;
    if (el2) {
      el2.textContent = message2;
      return;
    }
  }, []);
  return announce;
}
const defaults$1 = {
  separator: "::"
};
function useUniqueId(prefix2, options = defaults$1) {
  const id2 = React$3.useId();
  return useMemo$2(() => `${prefix2}${options.separator}${id2}`, [options.separator, prefix2, id2]);
}
function getElementId({
  contextId,
  uniqueId
}) {
  return `rfd-hidden-text-${contextId}-${uniqueId}`;
}
function useHiddenTextElement({
  contextId,
  text
}) {
  const uniqueId = useUniqueId("hidden-text", {
    separator: "-"
  });
  const id2 = useMemo$2(() => getElementId({
    contextId,
    uniqueId
  }), [uniqueId, contextId]);
  useEffect$3(function mount() {
    const el2 = document.createElement("div");
    el2.id = id2;
    el2.textContent = text;
    el2.style.display = "none";
    getBodyElement().appendChild(el2);
    return function unmount() {
      const body = getBodyElement();
      if (body.contains(el2)) {
        body.removeChild(el2);
      }
    };
  }, [id2, text]);
  return id2;
}
var AppContext$1 = React$3.createContext(null);
function usePrevious(current) {
  const ref2 = useRef$3(current);
  useEffect$3(() => {
    ref2.current = current;
  });
  return ref2;
}
function create() {
  let lock = null;
  function isClaimed() {
    return Boolean(lock);
  }
  function isActive2(value) {
    return value === lock;
  }
  function claim(abandon) {
    !!lock ? invariant() : void 0;
    const newLock = {
      abandon
    };
    lock = newLock;
    return newLock;
  }
  function release() {
    !lock ? invariant() : void 0;
    lock = null;
  }
  function tryAbandon() {
    if (lock) {
      lock.abandon();
      release();
    }
  }
  return {
    isClaimed,
    isActive: isActive2,
    claim,
    release,
    tryAbandon
  };
}
function isDragging(state) {
  if (state.phase === "IDLE" || state.phase === "DROP_ANIMATING") {
    return false;
  }
  return state.isDragging;
}
const tab = 9;
const enter$2 = 13;
const escape = 27;
const space = 32;
const pageUp = 33;
const pageDown = 34;
const end$1 = 35;
const home = 36;
const arrowLeft = 37;
const arrowUp = 38;
const arrowRight = 39;
const arrowDown = 40;
const preventedKeys = {
  [enter$2]: true,
  [tab]: true
};
var preventStandardKeyEvents = (event) => {
  if (preventedKeys[event.keyCode]) {
    event.preventDefault();
  }
};
const supportedEventName = (() => {
  const base2 = "visibilitychange";
  if (typeof document === "undefined") {
    return base2;
  }
  const candidates = [base2, `ms${base2}`, `webkit${base2}`, `moz${base2}`, `o${base2}`];
  const supported = candidates.find((eventName) => `on${eventName}` in document);
  return supported || base2;
})();
const primaryButton = 0;
const sloppyClickThreshold = 5;
function isSloppyClickThresholdExceeded(original, current) {
  return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;
}
const idle$1 = {
  type: "IDLE"
};
function getCaptureBindings({
  cancel,
  completed,
  getPhase,
  setPhase
}) {
  return [{
    eventName: "mousemove",
    fn: (event) => {
      const {
        button,
        clientX,
        clientY
      } = event;
      if (button !== primaryButton) {
        return;
      }
      const point = {
        x: clientX,
        y: clientY
      };
      const phase = getPhase();
      if (phase.type === "DRAGGING") {
        event.preventDefault();
        phase.actions.move(point);
        return;
      }
      !(phase.type === "PENDING") ? invariant() : void 0;
      const pending = phase.point;
      if (!isSloppyClickThresholdExceeded(pending, point)) {
        return;
      }
      event.preventDefault();
      const actions = phase.actions.fluidLift(point);
      setPhase({
        type: "DRAGGING",
        actions
      });
    }
  }, {
    eventName: "mouseup",
    fn: (event) => {
      const phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      phase.actions.drop({
        shouldBlockNextClick: true
      });
      completed();
    }
  }, {
    eventName: "mousedown",
    fn: (event) => {
      if (getPhase().type === "DRAGGING") {
        event.preventDefault();
      }
      cancel();
    }
  }, {
    eventName: "keydown",
    fn: (event) => {
      const phase = getPhase();
      if (phase.type === "PENDING") {
        cancel();
        return;
      }
      if (event.keyCode === escape) {
        event.preventDefault();
        cancel();
        return;
      }
      preventStandardKeyEvents(event);
    }
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "scroll",
    options: {
      passive: true,
      capture: false
    },
    fn: () => {
      if (getPhase().type === "PENDING") {
        cancel();
      }
    }
  }, {
    eventName: "webkitmouseforcedown",
    fn: (event) => {
      const phase = getPhase();
      !(phase.type !== "IDLE") ? invariant() : void 0;
      if (phase.actions.shouldRespectForcePress()) {
        cancel();
        return;
      }
      event.preventDefault();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useMouseSensor(api) {
  const phaseRef = useRef$3(idle$1);
  const unbindEventsRef = useRef$3(noop$2);
  const startCaptureBinding = useMemo$2(() => ({
    eventName: "mousedown",
    fn: function onMouseDown(event) {
      if (event.defaultPrevented) {
        return;
      }
      if (event.button !== primaryButton) {
        return;
      }
      if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {
        return;
      }
      const draggableId = api.findClosestDraggableId(event);
      if (!draggableId) {
        return;
      }
      const actions = api.tryGetLock(draggableId, stop, {
        sourceEvent: event
      });
      if (!actions) {
        return;
      }
      event.preventDefault();
      const point = {
        x: event.clientX,
        y: event.clientY
      };
      unbindEventsRef.current();
      startPendingDrag(actions, point);
    }
  }), [api]);
  const preventForcePressBinding = useMemo$2(() => ({
    eventName: "webkitmouseforcewillbegin",
    fn: (event) => {
      if (event.defaultPrevented) {
        return;
      }
      const id2 = api.findClosestDraggableId(event);
      if (!id2) {
        return;
      }
      const options = api.findOptionsForDraggable(id2);
      if (!options) {
        return;
      }
      if (options.shouldRespectForcePress) {
        return;
      }
      if (!api.canGetLock(id2)) {
        return;
      }
      event.preventDefault();
    }
  }), [api]);
  const listenForCapture = useCallback$1(function listenForCapture2() {
    const options = {
      passive: false,
      capture: true
    };
    unbindEventsRef.current = bindEvents(window, [preventForcePressBinding, startCaptureBinding], options);
  }, [preventForcePressBinding, startCaptureBinding]);
  const stop = useCallback$1(() => {
    const current = phaseRef.current;
    if (current.type === "IDLE") {
      return;
    }
    phaseRef.current = idle$1;
    unbindEventsRef.current();
    listenForCapture();
  }, [listenForCapture]);
  const cancel = useCallback$1(() => {
    const phase = phaseRef.current;
    stop();
    if (phase.type === "DRAGGING") {
      phase.actions.cancel({
        shouldBlockNextClick: true
      });
    }
    if (phase.type === "PENDING") {
      phase.actions.abort();
    }
  }, [stop]);
  const bindCapturingEvents = useCallback$1(function bindCapturingEvents2() {
    const options = {
      capture: true,
      passive: false
    };
    const bindings = getCaptureBindings({
      cancel,
      completed: stop,
      getPhase: () => phaseRef.current,
      setPhase: (phase) => {
        phaseRef.current = phase;
      }
    });
    unbindEventsRef.current = bindEvents(window, bindings, options);
  }, [cancel, stop]);
  const startPendingDrag = useCallback$1(function startPendingDrag2(actions, point) {
    !(phaseRef.current.type === "IDLE") ? invariant() : void 0;
    phaseRef.current = {
      type: "PENDING",
      point,
      actions
    };
    bindCapturingEvents();
  }, [bindCapturingEvents]);
  useIsomorphicLayoutEffect$1(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
    };
  }, [listenForCapture]);
}
function noop$1() {
}
const scrollJumpKeys = {
  [pageDown]: true,
  [pageUp]: true,
  [home]: true,
  [end$1]: true
};
function getDraggingBindings(actions, stop) {
  function cancel() {
    stop();
    actions.cancel();
  }
  function drop2() {
    stop();
    actions.drop();
  }
  return [{
    eventName: "keydown",
    fn: (event) => {
      if (event.keyCode === escape) {
        event.preventDefault();
        cancel();
        return;
      }
      if (event.keyCode === space) {
        event.preventDefault();
        drop2();
        return;
      }
      if (event.keyCode === arrowDown) {
        event.preventDefault();
        actions.moveDown();
        return;
      }
      if (event.keyCode === arrowUp) {
        event.preventDefault();
        actions.moveUp();
        return;
      }
      if (event.keyCode === arrowRight) {
        event.preventDefault();
        actions.moveRight();
        return;
      }
      if (event.keyCode === arrowLeft) {
        event.preventDefault();
        actions.moveLeft();
        return;
      }
      if (scrollJumpKeys[event.keyCode]) {
        event.preventDefault();
        return;
      }
      preventStandardKeyEvents(event);
    }
  }, {
    eventName: "mousedown",
    fn: cancel
  }, {
    eventName: "mouseup",
    fn: cancel
  }, {
    eventName: "click",
    fn: cancel
  }, {
    eventName: "touchstart",
    fn: cancel
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "wheel",
    fn: cancel,
    options: {
      passive: true
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useKeyboardSensor(api) {
  const unbindEventsRef = useRef$3(noop$1);
  const startCaptureBinding = useMemo$2(() => ({
    eventName: "keydown",
    fn: function onKeyDown(event) {
      if (event.defaultPrevented) {
        return;
      }
      if (event.keyCode !== space) {
        return;
      }
      const draggableId = api.findClosestDraggableId(event);
      if (!draggableId) {
        return;
      }
      const preDrag = api.tryGetLock(draggableId, stop, {
        sourceEvent: event
      });
      if (!preDrag) {
        return;
      }
      event.preventDefault();
      let isCapturing = true;
      const actions = preDrag.snapLift();
      unbindEventsRef.current();
      function stop() {
        !isCapturing ? invariant() : void 0;
        isCapturing = false;
        unbindEventsRef.current();
        listenForCapture();
      }
      unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {
        capture: true,
        passive: false
      });
    }
  }), [api]);
  const listenForCapture = useCallback$1(function tryStartCapture() {
    const options = {
      passive: false,
      capture: true
    };
    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);
  }, [startCaptureBinding]);
  useIsomorphicLayoutEffect$1(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
    };
  }, [listenForCapture]);
}
const idle = {
  type: "IDLE"
};
const timeForLongPress = 120;
const forcePressThreshold = 0.15;
function getWindowBindings({
  cancel,
  getPhase
}) {
  return [{
    eventName: "orientationchange",
    fn: cancel
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "contextmenu",
    fn: (event) => {
      event.preventDefault();
    }
  }, {
    eventName: "keydown",
    fn: (event) => {
      if (getPhase().type !== "DRAGGING") {
        cancel();
        return;
      }
      if (event.keyCode === escape) {
        event.preventDefault();
      }
      cancel();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function getHandleBindings({
  cancel,
  completed,
  getPhase
}) {
  return [{
    eventName: "touchmove",
    options: {
      capture: false
    },
    fn: (event) => {
      const phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      phase.hasMoved = true;
      const {
        clientX,
        clientY
      } = event.touches[0];
      const point = {
        x: clientX,
        y: clientY
      };
      event.preventDefault();
      phase.actions.move(point);
    }
  }, {
    eventName: "touchend",
    fn: (event) => {
      const phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      phase.actions.drop({
        shouldBlockNextClick: true
      });
      completed();
    }
  }, {
    eventName: "touchcancel",
    fn: (event) => {
      if (getPhase().type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      cancel();
    }
  }, {
    eventName: "touchforcechange",
    fn: (event) => {
      const phase = getPhase();
      !(phase.type !== "IDLE") ? invariant() : void 0;
      const touch = event.touches[0];
      if (!touch) {
        return;
      }
      const isForcePress = touch.force >= forcePressThreshold;
      if (!isForcePress) {
        return;
      }
      const shouldRespect = phase.actions.shouldRespectForcePress();
      if (phase.type === "PENDING") {
        if (shouldRespect) {
          cancel();
        }
        return;
      }
      if (shouldRespect) {
        if (phase.hasMoved) {
          event.preventDefault();
          return;
        }
        cancel();
        return;
      }
      event.preventDefault();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useTouchSensor(api) {
  const phaseRef = useRef$3(idle);
  const unbindEventsRef = useRef$3(noop$2);
  const getPhase = useCallback$1(function getPhase2() {
    return phaseRef.current;
  }, []);
  const setPhase = useCallback$1(function setPhase2(phase) {
    phaseRef.current = phase;
  }, []);
  const startCaptureBinding = useMemo$2(() => ({
    eventName: "touchstart",
    fn: function onTouchStart(event) {
      if (event.defaultPrevented) {
        return;
      }
      const draggableId = api.findClosestDraggableId(event);
      if (!draggableId) {
        return;
      }
      const actions = api.tryGetLock(draggableId, stop, {
        sourceEvent: event
      });
      if (!actions) {
        return;
      }
      const touch = event.touches[0];
      const {
        clientX,
        clientY
      } = touch;
      const point = {
        x: clientX,
        y: clientY
      };
      unbindEventsRef.current();
      startPendingDrag(actions, point);
    }
  }), [api]);
  const listenForCapture = useCallback$1(function listenForCapture2() {
    const options = {
      capture: true,
      passive: false
    };
    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);
  }, [startCaptureBinding]);
  const stop = useCallback$1(() => {
    const current = phaseRef.current;
    if (current.type === "IDLE") {
      return;
    }
    if (current.type === "PENDING") {
      clearTimeout(current.longPressTimerId);
    }
    setPhase(idle);
    unbindEventsRef.current();
    listenForCapture();
  }, [listenForCapture, setPhase]);
  const cancel = useCallback$1(() => {
    const phase = phaseRef.current;
    stop();
    if (phase.type === "DRAGGING") {
      phase.actions.cancel({
        shouldBlockNextClick: true
      });
    }
    if (phase.type === "PENDING") {
      phase.actions.abort();
    }
  }, [stop]);
  const bindCapturingEvents = useCallback$1(function bindCapturingEvents2() {
    const options = {
      capture: true,
      passive: false
    };
    const args = {
      cancel,
      completed: stop,
      getPhase
    };
    const unbindTarget = bindEvents(window, getHandleBindings(args), options);
    const unbindWindow = bindEvents(window, getWindowBindings(args), options);
    unbindEventsRef.current = function unbindAll() {
      unbindTarget();
      unbindWindow();
    };
  }, [cancel, getPhase, stop]);
  const startDragging = useCallback$1(function startDragging2() {
    const phase = getPhase();
    !(phase.type === "PENDING") ? invariant() : void 0;
    const actions = phase.actions.fluidLift(phase.point);
    setPhase({
      type: "DRAGGING",
      actions,
      hasMoved: false
    });
  }, [getPhase, setPhase]);
  const startPendingDrag = useCallback$1(function startPendingDrag2(actions, point) {
    !(getPhase().type === "IDLE") ? invariant() : void 0;
    const longPressTimerId = setTimeout(startDragging, timeForLongPress);
    setPhase({
      type: "PENDING",
      point,
      actions,
      longPressTimerId
    });
    bindCapturingEvents();
  }, [bindCapturingEvents, getPhase, setPhase, startDragging]);
  useIsomorphicLayoutEffect$1(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
      const phase = getPhase();
      if (phase.type === "PENDING") {
        clearTimeout(phase.longPressTimerId);
        setPhase(idle);
      }
    };
  }, [getPhase, listenForCapture, setPhase]);
  useIsomorphicLayoutEffect$1(function webkitHack() {
    const unbind = bindEvents(window, [{
      eventName: "touchmove",
      fn: () => {
      },
      options: {
        capture: false,
        passive: false
      }
    }]);
    return unbind;
  }, []);
}
const interactiveTagNames = ["input", "button", "textarea", "select", "option", "optgroup", "video", "audio"];
function isAnInteractiveElement(parent, current) {
  if (current == null) {
    return false;
  }
  const hasAnInteractiveTag = interactiveTagNames.includes(current.tagName.toLowerCase());
  if (hasAnInteractiveTag) {
    return true;
  }
  const attribute = current.getAttribute("contenteditable");
  if (attribute === "true" || attribute === "") {
    return true;
  }
  if (current === parent) {
    return false;
  }
  return isAnInteractiveElement(parent, current.parentElement);
}
function isEventInInteractiveElement(draggable2, event) {
  const target = event.target;
  if (!isHtmlElement(target)) {
    return false;
  }
  return isAnInteractiveElement(draggable2, target);
}
var getBorderBoxCenterPosition = (el2) => getRect(el2.getBoundingClientRect()).center;
function isElement$2(el2) {
  return el2 instanceof getWindowFromEl(el2).Element;
}
const supportedMatchesName = (() => {
  const base2 = "matches";
  if (typeof document === "undefined") {
    return base2;
  }
  const candidates = [base2, "msMatchesSelector", "webkitMatchesSelector"];
  const value = candidates.find((name) => name in Element.prototype);
  return value || base2;
})();
function closestPonyfill(el2, selector) {
  if (el2 == null) {
    return null;
  }
  if (el2[supportedMatchesName](selector)) {
    return el2;
  }
  return closestPonyfill(el2.parentElement, selector);
}
function closest(el2, selector) {
  if (el2.closest) {
    return el2.closest(selector);
  }
  return closestPonyfill(el2, selector);
}
function getSelector(contextId) {
  return `[${dragHandle.contextId}="${contextId}"]`;
}
function findClosestDragHandleFromEvent(contextId, event) {
  const target = event.target;
  if (!isElement$2(target)) {
    return null;
  }
  const selector = getSelector(contextId);
  const handle = closest(target, selector);
  if (!handle) {
    return null;
  }
  if (!isHtmlElement(handle)) {
    return null;
  }
  return handle;
}
function tryGetClosestDraggableIdFromEvent(contextId, event) {
  const handle = findClosestDragHandleFromEvent(contextId, event);
  if (!handle) {
    return null;
  }
  return handle.getAttribute(dragHandle.draggableId);
}
function findDraggable(contextId, draggableId) {
  const selector = `[${draggable.contextId}="${contextId}"]`;
  const possible = querySelectorAll(document, selector);
  const draggable$1 = possible.find((el2) => {
    return el2.getAttribute(draggable.id) === draggableId;
  });
  if (!draggable$1) {
    return null;
  }
  if (!isHtmlElement(draggable$1)) {
    return null;
  }
  return draggable$1;
}
function preventDefault(event) {
  event.preventDefault();
}
function isActive$1({
  expected,
  phase,
  isLockActive,
  shouldWarn
}) {
  if (!isLockActive()) {
    return false;
  }
  if (expected !== phase) {
    return false;
  }
  return true;
}
function canStart({
  lockAPI,
  store,
  registry,
  draggableId
}) {
  if (lockAPI.isClaimed()) {
    return false;
  }
  const entry = registry.draggable.findById(draggableId);
  if (!entry) {
    return false;
  }
  if (!entry.options.isEnabled) {
    return false;
  }
  if (!canStartDrag(store.getState(), draggableId)) {
    return false;
  }
  return true;
}
function tryStart({
  lockAPI,
  contextId,
  store,
  registry,
  draggableId,
  forceSensorStop,
  sourceEvent
}) {
  const shouldStart = canStart({
    lockAPI,
    store,
    registry,
    draggableId
  });
  if (!shouldStart) {
    return null;
  }
  const entry = registry.draggable.getById(draggableId);
  const el2 = findDraggable(contextId, entry.descriptor.id);
  if (!el2) {
    return null;
  }
  if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el2, sourceEvent)) {
    return null;
  }
  const lock = lockAPI.claim(forceSensorStop || noop$2);
  let phase = "PRE_DRAG";
  function getShouldRespectForcePress() {
    return entry.options.shouldRespectForcePress;
  }
  function isLockActive() {
    return lockAPI.isActive(lock);
  }
  function tryDispatch(expected, getAction) {
    if (isActive$1({
      expected,
      phase,
      isLockActive,
      shouldWarn: true
    })) {
      store.dispatch(getAction());
    }
  }
  const tryDispatchWhenDragging = tryDispatch.bind(null, "DRAGGING");
  function lift2(args) {
    function completed() {
      lockAPI.release();
      phase = "COMPLETED";
    }
    if (phase !== "PRE_DRAG") {
      completed();
      invariant();
    }
    store.dispatch(lift$1$1(args.liftActionArgs));
    phase = "DRAGGING";
    function finish2(reason, options = {
      shouldBlockNextClick: false
    }) {
      args.cleanup();
      if (options.shouldBlockNextClick) {
        const unbind = bindEvents(window, [{
          eventName: "click",
          fn: preventDefault,
          options: {
            once: true,
            passive: false,
            capture: true
          }
        }]);
        setTimeout(unbind);
      }
      completed();
      store.dispatch(drop({
        reason
      }));
    }
    return {
      isActive: () => isActive$1({
        expected: "DRAGGING",
        phase,
        isLockActive,
        shouldWarn: false
      }),
      shouldRespectForcePress: getShouldRespectForcePress,
      drop: (options) => finish2("DROP", options),
      cancel: (options) => finish2("CANCEL", options),
      ...args.actions
    };
  }
  function fluidLift(clientSelection) {
    const move$1 = rafSchd((client) => {
      tryDispatchWhenDragging(() => move({
        client
      }));
    });
    const api = lift2({
      liftActionArgs: {
        id: draggableId,
        clientSelection,
        movementMode: "FLUID"
      },
      cleanup: () => move$1.cancel(),
      actions: {
        move: move$1
      }
    });
    return {
      ...api,
      move: move$1
    };
  }
  function snapLift() {
    const actions = {
      moveUp: () => tryDispatchWhenDragging(moveUp),
      moveRight: () => tryDispatchWhenDragging(moveRight),
      moveDown: () => tryDispatchWhenDragging(moveDown),
      moveLeft: () => tryDispatchWhenDragging(moveLeft)
    };
    return lift2({
      liftActionArgs: {
        id: draggableId,
        clientSelection: getBorderBoxCenterPosition(el2),
        movementMode: "SNAP"
      },
      cleanup: noop$2,
      actions
    });
  }
  function abortPreDrag() {
    const shouldRelease = isActive$1({
      expected: "PRE_DRAG",
      phase,
      isLockActive,
      shouldWarn: true
    });
    if (shouldRelease) {
      lockAPI.release();
    }
  }
  const preDrag = {
    isActive: () => isActive$1({
      expected: "PRE_DRAG",
      phase,
      isLockActive,
      shouldWarn: false
    }),
    shouldRespectForcePress: getShouldRespectForcePress,
    fluidLift,
    snapLift,
    abort: abortPreDrag
  };
  return preDrag;
}
const defaultSensors = [useMouseSensor, useKeyboardSensor, useTouchSensor];
function useSensorMarshal({
  contextId,
  store,
  registry,
  customSensors,
  enableDefaultSensors
}) {
  const useSensors = [...enableDefaultSensors ? defaultSensors : [], ...customSensors || []];
  const lockAPI = useState$3(() => create())[0];
  const tryAbandonLock = useCallback$1(function tryAbandonLock2(previous, current) {
    if (isDragging(previous) && !isDragging(current)) {
      lockAPI.tryAbandon();
    }
  }, [lockAPI]);
  useIsomorphicLayoutEffect$1(function listenToStore() {
    let previous = store.getState();
    const unsubscribe = store.subscribe(() => {
      const current = store.getState();
      tryAbandonLock(previous, current);
      previous = current;
    });
    return unsubscribe;
  }, [lockAPI, store, tryAbandonLock]);
  useIsomorphicLayoutEffect$1(() => {
    return lockAPI.tryAbandon;
  }, [lockAPI.tryAbandon]);
  const canGetLock = useCallback$1((draggableId) => {
    return canStart({
      lockAPI,
      registry,
      store,
      draggableId
    });
  }, [lockAPI, registry, store]);
  const tryGetLock = useCallback$1((draggableId, forceStop, options) => tryStart({
    lockAPI,
    registry,
    contextId,
    store,
    draggableId,
    forceSensorStop: forceStop || null,
    sourceEvent: options && options.sourceEvent ? options.sourceEvent : null
  }), [contextId, lockAPI, registry, store]);
  const findClosestDraggableId = useCallback$1((event) => tryGetClosestDraggableIdFromEvent(contextId, event), [contextId]);
  const findOptionsForDraggable = useCallback$1((id2) => {
    const entry = registry.draggable.findById(id2);
    return entry ? entry.options : null;
  }, [registry.draggable]);
  const tryReleaseLock = useCallback$1(function tryReleaseLock2() {
    if (!lockAPI.isClaimed()) {
      return;
    }
    lockAPI.tryAbandon();
    if (store.getState().phase !== "IDLE") {
      store.dispatch(flush());
    }
  }, [lockAPI, store]);
  const isLockClaimed = useCallback$1(() => lockAPI.isClaimed(), [lockAPI]);
  const api = useMemo$2(() => ({
    canGetLock,
    tryGetLock,
    findClosestDraggableId,
    findOptionsForDraggable,
    tryReleaseLock,
    isLockClaimed
  }), [canGetLock, tryGetLock, findClosestDraggableId, findOptionsForDraggable, tryReleaseLock, isLockClaimed]);
  for (let i = 0; i < useSensors.length; i++) {
    useSensors[i](api);
  }
}
const createResponders = (props) => ({
  onBeforeCapture: (t2) => {
    const onBeforeCapureCallback = () => {
      if (props.onBeforeCapture) {
        props.onBeforeCapture(t2);
      }
    };
    flushSync$1(onBeforeCapureCallback);
  },
  onBeforeDragStart: props.onBeforeDragStart,
  onDragStart: props.onDragStart,
  onDragEnd: props.onDragEnd,
  onDragUpdate: props.onDragUpdate
});
const createAutoScrollerOptions = (props) => ({
  ...defaultAutoScrollerOptions,
  ...props.autoScrollerOptions,
  durationDampening: {
    ...defaultAutoScrollerOptions.durationDampening,
    ...props.autoScrollerOptions
  }
});
function getStore(lazyRef) {
  !lazyRef.current ? invariant() : void 0;
  return lazyRef.current;
}
function App(props) {
  const {
    contextId,
    setCallbacks,
    sensors,
    nonce,
    dragHandleUsageInstructions: dragHandleUsageInstructions2
  } = props;
  const lazyStoreRef = useRef$3(null);
  const lastPropsRef = usePrevious(props);
  const getResponders = useCallback$1(() => {
    return createResponders(lastPropsRef.current);
  }, [lastPropsRef]);
  const getAutoScrollerOptions = useCallback$1(() => {
    return createAutoScrollerOptions(lastPropsRef.current);
  }, [lastPropsRef]);
  const announce = useAnnouncer(contextId);
  const dragHandleUsageInstructionsId = useHiddenTextElement({
    contextId,
    text: dragHandleUsageInstructions2
  });
  const styleMarshal = useStyleMarshal(contextId, nonce);
  const lazyDispatch = useCallback$1((action) => {
    getStore(lazyStoreRef).dispatch(action);
  }, []);
  const marshalCallbacks = useMemo$2(() => bindActionCreators$1({
    publishWhileDragging,
    updateDroppableScroll,
    updateDroppableIsEnabled,
    updateDroppableIsCombineEnabled,
    collectionStarting
  }, lazyDispatch), [lazyDispatch]);
  const registry = useRegistry();
  const dimensionMarshal = useMemo$2(() => {
    return createDimensionMarshal(registry, marshalCallbacks);
  }, [registry, marshalCallbacks]);
  const autoScroller = useMemo$2(() => createAutoScroller({
    scrollWindow,
    scrollDroppable: dimensionMarshal.scrollDroppable,
    getAutoScrollerOptions,
    ...bindActionCreators$1({
      move
    }, lazyDispatch)
  }), [dimensionMarshal.scrollDroppable, lazyDispatch, getAutoScrollerOptions]);
  const focusMarshal = useFocusMarshal(contextId);
  const store = useMemo$2(() => createStore({
    announce,
    autoScroller,
    dimensionMarshal,
    focusMarshal,
    getResponders,
    styleMarshal
  }), [announce, autoScroller, dimensionMarshal, focusMarshal, getResponders, styleMarshal]);
  lazyStoreRef.current = store;
  const tryResetStore = useCallback$1(() => {
    const current = getStore(lazyStoreRef);
    const state = current.getState();
    if (state.phase !== "IDLE") {
      current.dispatch(flush());
    }
  }, []);
  const isDragging2 = useCallback$1(() => {
    const state = getStore(lazyStoreRef).getState();
    if (state.phase === "DROP_ANIMATING") {
      return true;
    }
    if (state.phase === "IDLE") {
      return false;
    }
    return state.isDragging;
  }, []);
  const appCallbacks = useMemo$2(() => ({
    isDragging: isDragging2,
    tryAbort: tryResetStore
  }), [isDragging2, tryResetStore]);
  setCallbacks(appCallbacks);
  const getCanLift = useCallback$1((id2) => canStartDrag(getStore(lazyStoreRef).getState(), id2), []);
  const getIsMovementAllowed = useCallback$1(() => isMovementAllowed(getStore(lazyStoreRef).getState()), []);
  const appContext = useMemo$2(() => ({
    marshal: dimensionMarshal,
    focus: focusMarshal,
    contextId,
    canLift: getCanLift,
    isMovementAllowed: getIsMovementAllowed,
    dragHandleUsageInstructionsId,
    registry
  }), [contextId, dimensionMarshal, dragHandleUsageInstructionsId, focusMarshal, getCanLift, getIsMovementAllowed, registry]);
  useSensorMarshal({
    contextId,
    store,
    registry,
    customSensors: sensors || null,
    enableDefaultSensors: props.enableDefaultSensors !== false
  });
  useEffect$3(() => {
    return tryResetStore;
  }, [tryResetStore]);
  return React$3.createElement(AppContext$1.Provider, {
    value: appContext
  }, React$3.createElement(Provider_default, {
    context: StoreContext,
    store
  }, props.children));
}
function useUniqueContextId() {
  return React$3.useId();
}
function DragDropContext(props) {
  const contextId = useUniqueContextId();
  const dragHandleUsageInstructions2 = props.dragHandleUsageInstructions || preset.dragHandleUsageInstructions;
  return React$3.createElement(ErrorBoundary$1, null, (setCallbacks) => React$3.createElement(App, {
    nonce: props.nonce,
    contextId,
    setCallbacks,
    dragHandleUsageInstructions: dragHandleUsageInstructions2,
    enableDefaultSensors: props.enableDefaultSensors,
    sensors: props.sensors,
    onBeforeCapture: props.onBeforeCapture,
    onBeforeDragStart: props.onBeforeDragStart,
    onDragStart: props.onDragStart,
    onDragUpdate: props.onDragUpdate,
    onDragEnd: props.onDragEnd,
    autoScrollerOptions: props.autoScrollerOptions
  }, props.children));
}
const zIndexOptions = {
  dragging: 5e3,
  dropAnimating: 4500
};
const getDraggingTransition = (shouldAnimateDragMovement, dropping) => {
  if (dropping) {
    return transitions.drop(dropping.duration);
  }
  if (shouldAnimateDragMovement) {
    return transitions.snap;
  }
  return transitions.fluid;
};
const getDraggingOpacity = (isCombining, isDropAnimating) => {
  if (!isCombining) {
    return void 0;
  }
  return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;
};
const getShouldDraggingAnimate = (dragging) => {
  if (dragging.forceShouldAnimate != null) {
    return dragging.forceShouldAnimate;
  }
  return dragging.mode === "SNAP";
};
function getDraggingStyle(dragging) {
  const dimension = dragging.dimension;
  const box = dimension.client;
  const {
    offset: offset22,
    combineWith,
    dropping
  } = dragging;
  const isCombining = Boolean(combineWith);
  const shouldAnimate = getShouldDraggingAnimate(dragging);
  const isDropAnimating = Boolean(dropping);
  const transform = isDropAnimating ? transforms.drop(offset22, isCombining) : transforms.moveTo(offset22);
  const style2 = {
    position: "fixed",
    top: box.marginBox.top,
    left: box.marginBox.left,
    boxSizing: "border-box",
    width: box.borderBox.width,
    height: box.borderBox.height,
    transition: getDraggingTransition(shouldAnimate, dropping),
    transform,
    opacity: getDraggingOpacity(isCombining, isDropAnimating),
    zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,
    pointerEvents: "none"
  };
  return style2;
}
function getSecondaryStyle(secondary) {
  return {
    transform: transforms.moveTo(secondary.offset),
    transition: secondary.shouldAnimateDisplacement ? void 0 : "none"
  };
}
function getStyle$1(mapped) {
  return mapped.type === "DRAGGING" ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);
}
function getDimension$1(descriptor, el2, windowScroll = origin) {
  const computedStyles = window.getComputedStyle(el2);
  const borderBox = el2.getBoundingClientRect();
  const client = calculateBox(borderBox, computedStyles);
  const page = withScroll(client, windowScroll);
  const placeholder2 = {
    client,
    tagName: el2.tagName.toLowerCase(),
    display: computedStyles.display
  };
  const displaceBy = {
    x: client.marginBox.width,
    y: client.marginBox.height
  };
  const dimension = {
    descriptor,
    placeholder: placeholder2,
    displaceBy,
    client,
    page
  };
  return dimension;
}
function useDraggablePublisher(args) {
  const uniqueId = useUniqueId("draggable");
  const {
    descriptor,
    registry,
    getDraggableRef,
    canDragInteractiveElements,
    shouldRespectForcePress,
    isEnabled
  } = args;
  const options = useMemo$2(() => ({
    canDragInteractiveElements,
    shouldRespectForcePress,
    isEnabled
  }), [canDragInteractiveElements, isEnabled, shouldRespectForcePress]);
  const getDimension2 = useCallback$1((windowScroll) => {
    const el2 = getDraggableRef();
    !el2 ? invariant() : void 0;
    return getDimension$1(descriptor, el2, windowScroll);
  }, [descriptor, getDraggableRef]);
  const entry = useMemo$2(() => ({
    uniqueId,
    descriptor,
    options,
    getDimension: getDimension2
  }), [descriptor, getDimension2, options, uniqueId]);
  const publishedRef = useRef$3(entry);
  const isFirstPublishRef = useRef$3(true);
  useIsomorphicLayoutEffect$1(() => {
    registry.draggable.register(publishedRef.current);
    return () => registry.draggable.unregister(publishedRef.current);
  }, [registry.draggable]);
  useIsomorphicLayoutEffect$1(() => {
    if (isFirstPublishRef.current) {
      isFirstPublishRef.current = false;
      return;
    }
    const last = publishedRef.current;
    publishedRef.current = entry;
    registry.draggable.update(entry, last);
  }, [entry, registry.draggable]);
}
var DroppableContext = React$3.createContext(null);
function useRequiredContext(Context) {
  const result = useContext$2(Context);
  !result ? invariant() : void 0;
  return result;
}
function preventHtml5Dnd(event) {
  event.preventDefault();
}
const Draggable = (props) => {
  const ref2 = useRef$3(null);
  const setRef2 = useCallback$1((el2 = null) => {
    ref2.current = el2;
  }, []);
  const getRef = useCallback$1(() => ref2.current, []);
  const {
    contextId,
    dragHandleUsageInstructionsId,
    registry
  } = useRequiredContext(AppContext$1);
  const {
    type,
    droppableId
  } = useRequiredContext(DroppableContext);
  const descriptor = useMemo$2(() => ({
    id: props.draggableId,
    index: props.index,
    type,
    droppableId
  }), [props.draggableId, props.index, type, droppableId]);
  const {
    children,
    draggableId,
    isEnabled,
    shouldRespectForcePress,
    canDragInteractiveElements,
    isClone,
    mapped,
    dropAnimationFinished: dropAnimationFinishedAction
  } = props;
  if (!isClone) {
    const forPublisher = useMemo$2(() => ({
      descriptor,
      registry,
      getDraggableRef: getRef,
      canDragInteractiveElements,
      shouldRespectForcePress,
      isEnabled
    }), [descriptor, registry, getRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled]);
    useDraggablePublisher(forPublisher);
  }
  const dragHandleProps = useMemo$2(() => isEnabled ? {
    tabIndex: 0,
    role: "button",
    "aria-describedby": dragHandleUsageInstructionsId,
    "data-rfd-drag-handle-draggable-id": draggableId,
    "data-rfd-drag-handle-context-id": contextId,
    draggable: false,
    onDragStart: preventHtml5Dnd
  } : null, [contextId, dragHandleUsageInstructionsId, draggableId, isEnabled]);
  const onMoveEnd = useCallback$1((event) => {
    if (mapped.type !== "DRAGGING") {
      return;
    }
    if (!mapped.dropping) {
      return;
    }
    if (event.propertyName !== "transform") {
      return;
    }
    flushSync$1(dropAnimationFinishedAction);
  }, [dropAnimationFinishedAction, mapped]);
  const provided = useMemo$2(() => {
    const style2 = getStyle$1(mapped);
    const onTransitionEnd = mapped.type === "DRAGGING" && mapped.dropping ? onMoveEnd : void 0;
    const result = {
      innerRef: setRef2,
      draggableProps: {
        "data-rfd-draggable-context-id": contextId,
        "data-rfd-draggable-id": draggableId,
        style: style2,
        onTransitionEnd
      },
      dragHandleProps
    };
    return result;
  }, [contextId, dragHandleProps, draggableId, mapped, onMoveEnd, setRef2]);
  const rubric = useMemo$2(() => ({
    draggableId: descriptor.id,
    type: descriptor.type,
    source: {
      index: descriptor.index,
      droppableId: descriptor.droppableId
    }
  }), [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type]);
  return React$3.createElement(React$3.Fragment, null, children(provided, mapped.snapshot, rubric));
};
var isStrictEqual = (a2, b) => a2 === b;
var whatIsDraggedOverFromResult = (result) => {
  const {
    combine: combine2,
    destination
  } = result;
  if (destination) {
    return destination.droppableId;
  }
  if (combine2) {
    return combine2.droppableId;
  }
  return null;
};
const getCombineWithFromResult = (result) => {
  return result.combine ? result.combine.draggableId : null;
};
const getCombineWithFromImpact = (impact) => {
  return impact.at && impact.at.type === "COMBINE" ? impact.at.combine.draggableId : null;
};
function getDraggableSelector() {
  const memoizedOffset = memoizeOne$1((x, y) => ({
    x,
    y
  }));
  const getMemoizedSnapshot = memoizeOne$1((mode, isClone, draggingOver = null, combineWith = null, dropping = null) => ({
    isDragging: true,
    isClone,
    isDropAnimating: Boolean(dropping),
    dropAnimation: dropping,
    mode,
    draggingOver,
    combineWith,
    combineTargetFor: null
  }));
  const getMemoizedProps = memoizeOne$1((offset22, mode, dimension, isClone, draggingOver = null, combineWith = null, forceShouldAnimate = null) => ({
    mapped: {
      type: "DRAGGING",
      dropping: null,
      draggingOver,
      combineWith,
      mode,
      offset: offset22,
      dimension,
      forceShouldAnimate,
      snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)
    }
  }));
  const selector = (state, ownProps) => {
    if (isDragging(state)) {
      if (state.critical.draggable.id !== ownProps.draggableId) {
        return null;
      }
      const offset22 = state.current.client.offset;
      const dimension = state.dimensions.draggables[ownProps.draggableId];
      const draggingOver = whatIsDraggedOver(state.impact);
      const combineWith = getCombineWithFromImpact(state.impact);
      const forceShouldAnimate = state.forceShouldAnimate;
      return getMemoizedProps(memoizedOffset(offset22.x, offset22.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);
    }
    if (state.phase === "DROP_ANIMATING") {
      const completed = state.completed;
      if (completed.result.draggableId !== ownProps.draggableId) {
        return null;
      }
      const isClone = ownProps.isClone;
      const dimension = state.dimensions.draggables[ownProps.draggableId];
      const result = completed.result;
      const mode = result.mode;
      const draggingOver = whatIsDraggedOverFromResult(result);
      const combineWith = getCombineWithFromResult(result);
      const duration = state.dropDuration;
      const dropping = {
        duration,
        curve: curves.drop,
        moveTo: state.newHomeClientOffset,
        opacity: combineWith ? combine.opacity.drop : null,
        scale: combineWith ? combine.scale.drop : null
      };
      return {
        mapped: {
          type: "DRAGGING",
          offset: state.newHomeClientOffset,
          dimension,
          dropping,
          draggingOver,
          combineWith,
          mode,
          forceShouldAnimate: null,
          snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, dropping)
        }
      };
    }
    return null;
  };
  return selector;
}
function getSecondarySnapshot(combineTargetFor = null) {
  return {
    isDragging: false,
    isDropAnimating: false,
    isClone: false,
    dropAnimation: null,
    mode: null,
    draggingOver: null,
    combineTargetFor,
    combineWith: null
  };
}
const atRest = {
  mapped: {
    type: "SECONDARY",
    offset: origin,
    combineTargetFor: null,
    shouldAnimateDisplacement: true,
    snapshot: getSecondarySnapshot(null)
  }
};
function getSecondarySelector() {
  const memoizedOffset = memoizeOne$1((x, y) => ({
    x,
    y
  }));
  const getMemoizedSnapshot = memoizeOne$1(getSecondarySnapshot);
  const getMemoizedProps = memoizeOne$1((offset22, combineTargetFor = null, shouldAnimateDisplacement) => ({
    mapped: {
      type: "SECONDARY",
      offset: offset22,
      combineTargetFor,
      shouldAnimateDisplacement,
      snapshot: getMemoizedSnapshot(combineTargetFor)
    }
  }));
  const getFallback = (combineTargetFor) => {
    return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;
  };
  const getProps = (ownId, draggingId, impact, afterCritical) => {
    const visualDisplacement = impact.displaced.visible[ownId];
    const isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);
    const combine2 = tryGetCombine(impact);
    const combineTargetFor = combine2 && combine2.draggableId === ownId ? draggingId : null;
    if (!visualDisplacement) {
      if (!isAfterCriticalInVirtualList) {
        return getFallback(combineTargetFor);
      }
      if (impact.displaced.invisible[ownId]) {
        return null;
      }
      const change = negate(afterCritical.displacedBy.point);
      const offset3 = memoizedOffset(change.x, change.y);
      return getMemoizedProps(offset3, combineTargetFor, true);
    }
    if (isAfterCriticalInVirtualList) {
      return getFallback(combineTargetFor);
    }
    const displaceBy = impact.displacedBy.point;
    const offset22 = memoizedOffset(displaceBy.x, displaceBy.y);
    return getMemoizedProps(offset22, combineTargetFor, visualDisplacement.shouldAnimate);
  };
  const selector = (state, ownProps) => {
    if (isDragging(state)) {
      if (state.critical.draggable.id === ownProps.draggableId) {
        return null;
      }
      return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);
    }
    if (state.phase === "DROP_ANIMATING") {
      const completed = state.completed;
      if (completed.result.draggableId === ownProps.draggableId) {
        return null;
      }
      return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);
    }
    return null;
  };
  return selector;
}
const makeMapStateToProps$1 = () => {
  const draggingSelector = getDraggableSelector();
  const secondarySelector = getSecondarySelector();
  const selector = (state, ownProps) => draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;
  return selector;
};
const mapDispatchToProps$1 = {
  dropAnimationFinished
};
const ConnectedDraggable = connect_default(makeMapStateToProps$1, mapDispatchToProps$1, null, {
  context: StoreContext,
  areStatePropsEqual: isStrictEqual
})(Draggable);
function PrivateDraggable(props) {
  const droppableContext = useRequiredContext(DroppableContext);
  const isUsingCloneFor = droppableContext.isUsingCloneFor;
  if (isUsingCloneFor === props.draggableId && !props.isClone) {
    return null;
  }
  return React$3.createElement(ConnectedDraggable, props);
}
function PublicDraggable(props) {
  const isEnabled = typeof props.isDragDisabled === "boolean" ? !props.isDragDisabled : true;
  const canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);
  const shouldRespectForcePress = Boolean(props.shouldRespectForcePress);
  return React$3.createElement(PrivateDraggable, _extends$9({}, props, {
    isClone: false,
    isEnabled,
    canDragInteractiveElements,
    shouldRespectForcePress
  }));
}
const isEqual$2 = (base2) => (value) => base2 === value;
const isScroll = isEqual$2("scroll");
const isAuto = isEqual$2("auto");
const isEither = (overflow, fn2) => fn2(overflow.overflowX) || fn2(overflow.overflowY);
const isElementScrollable = (el2) => {
  const style2 = window.getComputedStyle(el2);
  const overflow = {
    overflowX: style2.overflowX,
    overflowY: style2.overflowY
  };
  return isEither(overflow, isScroll) || isEither(overflow, isAuto);
};
const isBodyScrollable = () => {
  {
    return false;
  }
};
const getClosestScrollable = (el2) => {
  if (el2 == null) {
    return null;
  }
  if (el2 === document.body) {
    return isBodyScrollable() ? el2 : null;
  }
  if (el2 === document.documentElement) {
    return null;
  }
  if (!isElementScrollable(el2)) {
    return getClosestScrollable(el2.parentElement);
  }
  return el2;
};
var getScroll = (el2) => ({
  x: el2.scrollLeft,
  y: el2.scrollTop
});
const getIsFixed = (el2) => {
  if (!el2) {
    return false;
  }
  const style2 = window.getComputedStyle(el2);
  if (style2.position === "fixed") {
    return true;
  }
  return getIsFixed(el2.parentElement);
};
var getEnv = (start2) => {
  const closestScrollable = getClosestScrollable(start2);
  const isFixedOnPage = getIsFixed(start2);
  return {
    closestScrollable,
    isFixedOnPage
  };
};
var getDroppableDimension = ({
  descriptor,
  isEnabled,
  isCombineEnabled,
  isFixedOnPage,
  direction: direction2,
  client,
  page,
  closest: closest2
}) => {
  const frame = (() => {
    if (!closest2) {
      return null;
    }
    const {
      scrollSize,
      client: frameClient
    } = closest2;
    const maxScroll = getMaxScroll({
      scrollHeight: scrollSize.scrollHeight,
      scrollWidth: scrollSize.scrollWidth,
      height: frameClient.paddingBox.height,
      width: frameClient.paddingBox.width
    });
    return {
      pageMarginBox: closest2.page.marginBox,
      frameClient,
      scrollSize,
      shouldClipSubject: closest2.shouldClipSubject,
      scroll: {
        initial: closest2.scroll,
        current: closest2.scroll,
        max: maxScroll,
        diff: {
          value: origin,
          displacement: origin
        }
      }
    };
  })();
  const axis = direction2 === "vertical" ? vertical : horizontal;
  const subject = getSubject({
    page,
    withPlaceholder: null,
    axis,
    frame
  });
  const dimension = {
    descriptor,
    isCombineEnabled,
    isFixedOnPage,
    axis,
    isEnabled,
    client,
    page,
    frame,
    subject
  };
  return dimension;
};
const getClient = (targetRef, closestScrollable) => {
  const base2 = getBox(targetRef);
  if (!closestScrollable) {
    return base2;
  }
  if (targetRef !== closestScrollable) {
    return base2;
  }
  const top2 = base2.paddingBox.top - closestScrollable.scrollTop;
  const left2 = base2.paddingBox.left - closestScrollable.scrollLeft;
  const bottom2 = top2 + closestScrollable.scrollHeight;
  const right2 = left2 + closestScrollable.scrollWidth;
  const paddingBox = {
    top: top2,
    right: right2,
    bottom: bottom2,
    left: left2
  };
  const borderBox = expand(paddingBox, base2.border);
  const client = createBox({
    borderBox,
    margin: base2.margin,
    border: base2.border,
    padding: base2.padding
  });
  return client;
};
var getDimension = ({
  ref: ref2,
  descriptor,
  env,
  windowScroll,
  direction: direction2,
  isDropDisabled,
  isCombineEnabled,
  shouldClipSubject
}) => {
  const closestScrollable = env.closestScrollable;
  const client = getClient(ref2, closestScrollable);
  const page = withScroll(client, windowScroll);
  const closest2 = (() => {
    if (!closestScrollable) {
      return null;
    }
    const frameClient = getBox(closestScrollable);
    const scrollSize = {
      scrollHeight: closestScrollable.scrollHeight,
      scrollWidth: closestScrollable.scrollWidth
    };
    return {
      client: frameClient,
      page: withScroll(frameClient, windowScroll),
      scroll: getScroll(closestScrollable),
      scrollSize,
      shouldClipSubject
    };
  })();
  const dimension = getDroppableDimension({
    descriptor,
    isEnabled: !isDropDisabled,
    isCombineEnabled,
    isFixedOnPage: env.isFixedOnPage,
    direction: direction2,
    client,
    page,
    closest: closest2
  });
  return dimension;
};
const immediate = {
  passive: false
};
const delayed = {
  passive: true
};
var getListenerOptions = (options) => options.shouldPublishImmediately ? immediate : delayed;
const getClosestScrollableFromDrag = (dragging) => dragging && dragging.env.closestScrollable || null;
function useDroppablePublisher(args) {
  const whileDraggingRef = useRef$3(null);
  const appContext = useRequiredContext(AppContext$1);
  const uniqueId = useUniqueId("droppable");
  const {
    registry,
    marshal
  } = appContext;
  const previousRef = usePrevious(args);
  const descriptor = useMemo$2(() => ({
    id: args.droppableId,
    type: args.type,
    mode: args.mode
  }), [args.droppableId, args.mode, args.type]);
  const publishedDescriptorRef = useRef$3(descriptor);
  const memoizedUpdateScroll = useMemo$2(() => memoizeOne$1((x, y) => {
    !whileDraggingRef.current ? invariant() : void 0;
    const scroll3 = {
      x,
      y
    };
    marshal.updateDroppableScroll(descriptor.id, scroll3);
  }), [descriptor.id, marshal]);
  const getClosestScroll = useCallback$1(() => {
    const dragging = whileDraggingRef.current;
    if (!dragging || !dragging.env.closestScrollable) {
      return origin;
    }
    return getScroll(dragging.env.closestScrollable);
  }, []);
  const updateScroll = useCallback$1(() => {
    const scroll3 = getClosestScroll();
    memoizedUpdateScroll(scroll3.x, scroll3.y);
  }, [getClosestScroll, memoizedUpdateScroll]);
  const scheduleScrollUpdate = useMemo$2(() => rafSchd(updateScroll), [updateScroll]);
  const onClosestScroll = useCallback$1(() => {
    const dragging = whileDraggingRef.current;
    const closest2 = getClosestScrollableFromDrag(dragging);
    !(dragging && closest2) ? invariant() : void 0;
    const options = dragging.scrollOptions;
    if (options.shouldPublishImmediately) {
      updateScroll();
      return;
    }
    scheduleScrollUpdate();
  }, [scheduleScrollUpdate, updateScroll]);
  const getDimensionAndWatchScroll = useCallback$1((windowScroll, options) => {
    !!whileDraggingRef.current ? invariant() : void 0;
    const previous = previousRef.current;
    const ref2 = previous.getDroppableRef();
    !ref2 ? invariant() : void 0;
    const env = getEnv(ref2);
    const dragging = {
      ref: ref2,
      descriptor,
      env,
      scrollOptions: options
    };
    whileDraggingRef.current = dragging;
    const dimension = getDimension({
      ref: ref2,
      descriptor,
      env,
      windowScroll,
      direction: previous.direction,
      isDropDisabled: previous.isDropDisabled,
      isCombineEnabled: previous.isCombineEnabled,
      shouldClipSubject: !previous.ignoreContainerClipping
    });
    const scrollable = env.closestScrollable;
    if (scrollable) {
      scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);
      scrollable.addEventListener("scroll", onClosestScroll, getListenerOptions(dragging.scrollOptions));
    }
    return dimension;
  }, [appContext.contextId, descriptor, onClosestScroll, previousRef]);
  const getScrollWhileDragging = useCallback$1(() => {
    const dragging = whileDraggingRef.current;
    const closest2 = getClosestScrollableFromDrag(dragging);
    !(dragging && closest2) ? invariant() : void 0;
    return getScroll(closest2);
  }, []);
  const dragStopped = useCallback$1(() => {
    const dragging = whileDraggingRef.current;
    !dragging ? invariant() : void 0;
    const closest2 = getClosestScrollableFromDrag(dragging);
    whileDraggingRef.current = null;
    if (!closest2) {
      return;
    }
    scheduleScrollUpdate.cancel();
    closest2.removeAttribute(scrollContainer.contextId);
    closest2.removeEventListener("scroll", onClosestScroll, getListenerOptions(dragging.scrollOptions));
  }, [onClosestScroll, scheduleScrollUpdate]);
  const scroll2 = useCallback$1((change) => {
    const dragging = whileDraggingRef.current;
    !dragging ? invariant() : void 0;
    const closest2 = getClosestScrollableFromDrag(dragging);
    !closest2 ? invariant() : void 0;
    closest2.scrollTop += change.y;
    closest2.scrollLeft += change.x;
  }, []);
  const callbacks = useMemo$2(() => {
    return {
      getDimensionAndWatchScroll,
      getScrollWhileDragging,
      dragStopped,
      scroll: scroll2
    };
  }, [dragStopped, getDimensionAndWatchScroll, getScrollWhileDragging, scroll2]);
  const entry = useMemo$2(() => ({
    uniqueId,
    descriptor,
    callbacks
  }), [callbacks, descriptor, uniqueId]);
  useIsomorphicLayoutEffect$1(() => {
    publishedDescriptorRef.current = entry.descriptor;
    registry.droppable.register(entry);
    return () => {
      if (whileDraggingRef.current) {
        dragStopped();
      }
      registry.droppable.unregister(entry);
    };
  }, [callbacks, descriptor, dragStopped, entry, marshal, registry.droppable]);
  useIsomorphicLayoutEffect$1(() => {
    if (!whileDraggingRef.current) {
      return;
    }
    marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);
  }, [args.isDropDisabled, marshal]);
  useIsomorphicLayoutEffect$1(() => {
    if (!whileDraggingRef.current) {
      return;
    }
    marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);
  }, [args.isCombineEnabled, marshal]);
}
function noop$3() {
}
const empty$1 = {
  width: 0,
  height: 0,
  margin: noSpacing
};
const getSize = ({
  isAnimatingOpenOnMount,
  placeholder: placeholder2,
  animate
}) => {
  if (isAnimatingOpenOnMount) {
    return empty$1;
  }
  if (animate === "close") {
    return empty$1;
  }
  return {
    height: placeholder2.client.borderBox.height,
    width: placeholder2.client.borderBox.width,
    margin: placeholder2.client.margin
  };
};
const getStyle = ({
  isAnimatingOpenOnMount,
  placeholder: placeholder2,
  animate
}) => {
  const size2 = getSize({
    isAnimatingOpenOnMount,
    placeholder: placeholder2,
    animate
  });
  return {
    display: placeholder2.display,
    boxSizing: "border-box",
    width: size2.width,
    height: size2.height,
    marginTop: size2.margin.top,
    marginRight: size2.margin.right,
    marginBottom: size2.margin.bottom,
    marginLeft: size2.margin.left,
    flexShrink: "0",
    flexGrow: "0",
    pointerEvents: "none",
    transition: animate !== "none" ? transitions.placeholder : null
  };
};
const Placeholder$1 = (props) => {
  const animateOpenTimerRef = useRef$3(null);
  const tryClearAnimateOpenTimer = useCallback$1(() => {
    if (!animateOpenTimerRef.current) {
      return;
    }
    clearTimeout(animateOpenTimerRef.current);
    animateOpenTimerRef.current = null;
  }, []);
  const {
    animate,
    onTransitionEnd,
    onClose,
    contextId
  } = props;
  const [isAnimatingOpenOnMount, setIsAnimatingOpenOnMount] = useState$3(props.animate === "open");
  useEffect$3(() => {
    if (!isAnimatingOpenOnMount) {
      return noop$3;
    }
    if (animate !== "open") {
      tryClearAnimateOpenTimer();
      setIsAnimatingOpenOnMount(false);
      return noop$3;
    }
    if (animateOpenTimerRef.current) {
      return noop$3;
    }
    animateOpenTimerRef.current = setTimeout(() => {
      animateOpenTimerRef.current = null;
      setIsAnimatingOpenOnMount(false);
    });
    return tryClearAnimateOpenTimer;
  }, [animate, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);
  const onSizeChangeEnd = useCallback$1((event) => {
    if (event.propertyName !== "height") {
      return;
    }
    onTransitionEnd();
    if (animate === "close") {
      onClose();
    }
  }, [animate, onClose, onTransitionEnd]);
  const style2 = getStyle({
    isAnimatingOpenOnMount,
    animate: props.animate,
    placeholder: props.placeholder
  });
  return React$3.createElement(props.placeholder.tagName, {
    style: style2,
    "data-rfd-placeholder-context-id": contextId,
    onTransitionEnd: onSizeChangeEnd,
    ref: props.innerRef
  });
};
var Placeholder$1$1 = React$3.memo(Placeholder$1);
class AnimateInOut extends React$3.PureComponent {
  constructor(...args) {
    super(...args);
    this.state = {
      isVisible: Boolean(this.props.on),
      data: this.props.on,
      animate: this.props.shouldAnimate && this.props.on ? "open" : "none"
    };
    this.onClose = () => {
      if (this.state.animate !== "close") {
        return;
      }
      this.setState({
        isVisible: false
      });
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (!props.shouldAnimate) {
      return {
        isVisible: Boolean(props.on),
        data: props.on,
        animate: "none"
      };
    }
    if (props.on) {
      return {
        isVisible: true,
        data: props.on,
        animate: "open"
      };
    }
    if (state.isVisible) {
      return {
        isVisible: true,
        data: state.data,
        animate: "close"
      };
    }
    return {
      isVisible: false,
      animate: "close",
      data: null
    };
  }
  render() {
    if (!this.state.isVisible) {
      return null;
    }
    const provided = {
      onClose: this.onClose,
      data: this.state.data,
      animate: this.state.animate
    };
    return this.props.children(provided);
  }
}
const Droppable = (props) => {
  const appContext = useContext$2(AppContext$1);
  !appContext ? invariant() : void 0;
  const {
    contextId,
    isMovementAllowed: isMovementAllowed2
  } = appContext;
  const droppableRef = useRef$3(null);
  const placeholderRef = useRef$3(null);
  const {
    children,
    droppableId,
    type,
    mode,
    direction: direction2,
    ignoreContainerClipping,
    isDropDisabled,
    isCombineEnabled,
    snapshot,
    useClone,
    updateViewportMaxScroll: updateViewportMaxScroll2,
    getContainerForClone
  } = props;
  const getDroppableRef = useCallback$1(() => droppableRef.current, []);
  const setDroppableRef = useCallback$1((value = null) => {
    droppableRef.current = value;
  }, []);
  useCallback$1(() => placeholderRef.current, []);
  const setPlaceholderRef = useCallback$1((value = null) => {
    placeholderRef.current = value;
  }, []);
  const onPlaceholderTransitionEnd = useCallback$1(() => {
    if (isMovementAllowed2()) {
      updateViewportMaxScroll2({
        maxScroll: getMaxWindowScroll()
      });
    }
  }, [isMovementAllowed2, updateViewportMaxScroll2]);
  useDroppablePublisher({
    droppableId,
    type,
    mode,
    direction: direction2,
    isDropDisabled,
    isCombineEnabled,
    ignoreContainerClipping,
    getDroppableRef
  });
  const placeholder2 = useMemo$2(() => React$3.createElement(AnimateInOut, {
    on: props.placeholder,
    shouldAnimate: props.shouldAnimatePlaceholder
  }, ({
    onClose,
    data,
    animate
  }) => React$3.createElement(Placeholder$1$1, {
    placeholder: data,
    onClose,
    innerRef: setPlaceholderRef,
    animate,
    contextId,
    onTransitionEnd: onPlaceholderTransitionEnd
  })), [contextId, onPlaceholderTransitionEnd, props.placeholder, props.shouldAnimatePlaceholder, setPlaceholderRef]);
  const provided = useMemo$2(() => ({
    innerRef: setDroppableRef,
    placeholder: placeholder2,
    droppableProps: {
      "data-rfd-droppable-id": droppableId,
      "data-rfd-droppable-context-id": contextId
    }
  }), [contextId, droppableId, placeholder2, setDroppableRef]);
  const isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;
  const droppableContext = useMemo$2(() => ({
    droppableId,
    type,
    isUsingCloneFor
  }), [droppableId, isUsingCloneFor, type]);
  function getClone() {
    if (!useClone) {
      return null;
    }
    const {
      dragging,
      render: render2
    } = useClone;
    const node = React$3.createElement(PrivateDraggable, {
      draggableId: dragging.draggableId,
      index: dragging.source.index,
      isClone: true,
      isEnabled: true,
      shouldRespectForcePress: false,
      canDragInteractiveElements: true
    }, (draggableProvided, draggableSnapshot) => render2(draggableProvided, draggableSnapshot, dragging));
    return ReactDOM$1.createPortal(node, getContainerForClone());
  }
  return React$3.createElement(DroppableContext.Provider, {
    value: droppableContext
  }, children(provided, snapshot), getClone());
};
function getBody() {
  !document.body ? invariant() : void 0;
  return document.body;
}
const defaultProps$1 = {
  mode: "standard",
  type: "DEFAULT",
  direction: "vertical",
  isDropDisabled: false,
  isCombineEnabled: false,
  ignoreContainerClipping: false,
  renderClone: null,
  getContainerForClone: getBody
};
const attachDefaultPropsToOwnProps = (ownProps) => {
  let mergedProps = {
    ...ownProps
  };
  let defaultPropKey;
  for (defaultPropKey in defaultProps$1) {
    if (ownProps[defaultPropKey] === void 0) {
      mergedProps = {
        ...mergedProps,
        [defaultPropKey]: defaultProps$1[defaultPropKey]
      };
    }
  }
  return mergedProps;
};
const isMatchingType = (type, critical) => type === critical.droppable.type;
const getDraggable = (critical, dimensions) => dimensions.draggables[critical.draggable.id];
const makeMapStateToProps = () => {
  const idleWithAnimation = {
    placeholder: null,
    shouldAnimatePlaceholder: true,
    snapshot: {
      isDraggingOver: false,
      draggingOverWith: null,
      draggingFromThisWith: null,
      isUsingPlaceholder: false
    },
    useClone: null
  };
  const idleWithoutAnimation = {
    ...idleWithAnimation,
    shouldAnimatePlaceholder: false
  };
  const getDraggableRubric = memoizeOne$1((descriptor) => ({
    draggableId: descriptor.id,
    type: descriptor.type,
    source: {
      index: descriptor.index,
      droppableId: descriptor.droppableId
    }
  }));
  const getMapProps = memoizeOne$1((id2, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) => {
    const draggableId = dragging.descriptor.id;
    const isHome = dragging.descriptor.droppableId === id2;
    if (isHome) {
      const useClone = renderClone ? {
        render: renderClone,
        dragging: getDraggableRubric(dragging.descriptor)
      } : null;
      const snapshot2 = {
        isDraggingOver: isDraggingOverForConsumer,
        draggingOverWith: isDraggingOverForConsumer ? draggableId : null,
        draggingFromThisWith: draggableId,
        isUsingPlaceholder: true
      };
      return {
        placeholder: dragging.placeholder,
        shouldAnimatePlaceholder: false,
        snapshot: snapshot2,
        useClone
      };
    }
    if (!isEnabled) {
      return idleWithoutAnimation;
    }
    if (!isDraggingOverForImpact) {
      return idleWithAnimation;
    }
    const snapshot = {
      isDraggingOver: isDraggingOverForConsumer,
      draggingOverWith: draggableId,
      draggingFromThisWith: null,
      isUsingPlaceholder: true
    };
    return {
      placeholder: dragging.placeholder,
      shouldAnimatePlaceholder: true,
      snapshot,
      useClone: null
    };
  });
  const selector = (state, ownProps) => {
    const ownPropsWithDefaultProps = attachDefaultPropsToOwnProps(ownProps);
    const id2 = ownPropsWithDefaultProps.droppableId;
    const type = ownPropsWithDefaultProps.type;
    const isEnabled = !ownPropsWithDefaultProps.isDropDisabled;
    const renderClone = ownPropsWithDefaultProps.renderClone;
    if (isDragging(state)) {
      const critical = state.critical;
      if (!isMatchingType(type, critical)) {
        return idleWithoutAnimation;
      }
      const dragging = getDraggable(critical, state.dimensions);
      const isDraggingOver = whatIsDraggedOver(state.impact) === id2;
      return getMapProps(id2, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);
    }
    if (state.phase === "DROP_ANIMATING") {
      const completed = state.completed;
      if (!isMatchingType(type, completed.critical)) {
        return idleWithoutAnimation;
      }
      const dragging = getDraggable(completed.critical, state.dimensions);
      return getMapProps(id2, isEnabled, whatIsDraggedOverFromResult(completed.result) === id2, whatIsDraggedOver(completed.impact) === id2, dragging, renderClone);
    }
    if (state.phase === "IDLE" && state.completed && !state.shouldFlush) {
      const completed = state.completed;
      if (!isMatchingType(type, completed.critical)) {
        return idleWithoutAnimation;
      }
      const wasOver = whatIsDraggedOver(completed.impact) === id2;
      const wasCombining = Boolean(completed.impact.at && completed.impact.at.type === "COMBINE");
      const isHome = completed.critical.droppable.id === id2;
      if (wasOver) {
        return wasCombining ? idleWithAnimation : idleWithoutAnimation;
      }
      if (isHome) {
        return idleWithAnimation;
      }
      return idleWithoutAnimation;
    }
    return idleWithoutAnimation;
  };
  return selector;
};
const mapDispatchToProps = {
  updateViewportMaxScroll
};
const ConnectedDroppable = connect_default(makeMapStateToProps, mapDispatchToProps, (stateProps, dispatchProps, ownProps) => {
  return {
    ...attachDefaultPropsToOwnProps(ownProps),
    ...stateProps,
    ...dispatchProps
  };
}, {
  context: StoreContext,
  areStatePropsEqual: isStrictEqual
})(Droppable);
var ConnectedDroppable$1 = ConnectedDroppable;
var build = { exports: {} };
(() => {
  var e2 = { d: (t3, a3) => {
    for (var r3 in a3) e2.o(a3, r3) && !e2.o(t3, r3) && Object.defineProperty(t3, r3, { enumerable: true, get: a3[r3] });
  }, o: (e3, t3) => Object.prototype.hasOwnProperty.call(e3, t3), r: (e3) => {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
  } }, t2 = {};
  function a2(e3, t3) {
    for (var a3 = 0; a3 < t3.length; a3++) {
      var r3 = t3[a3];
      r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(e3, r3.key, r3);
    }
  }
  e2.r(t2), e2.d(t2, { default: () => n2 });
  var r2 = function() {
    function e3() {
      !function(e4, t4) {
        if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
      }(this, e3);
    }
    var t3, r3;
    return t3 = e3, r3 = [{ key: "changeHeightWidth", value: function(e4, t4, a3, r4, n3, i) {
      return a3 > r4 && (e4 = Math.round(e4 * r4 / a3), a3 = r4), e4 > t4 && (a3 = Math.round(a3 * t4 / e4), e4 = t4), n3 && a3 < n3 && (e4 = Math.round(e4 * n3 / a3), a3 = n3), i && e4 < i && (a3 = Math.round(a3 * i / e4), e4 = i), { height: e4, width: a3 };
    } }, { key: "resizeAndRotateImage", value: function(e4, t4, a3, r4, n3) {
      var i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "jpeg", o2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 100, l2 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, h = o2 / 100, g = document.createElement("canvas"), u2 = e4.width, d = e4.height, c2 = this.changeHeightWidth(d, a3, u2, t4, r4, n3);
      !l2 || 90 !== l2 && 270 !== l2 ? (g.width = c2.width, g.height = c2.height) : (g.width = c2.height, g.height = c2.width), u2 = c2.width, d = c2.height;
      var s2 = g.getContext("2d");
      return s2.fillStyle = "rgba(0, 0, 0, 0)", s2.fillRect(0, 0, u2, d), s2.imageSmoothingEnabled && s2.imageSmoothingQuality && (s2.imageSmoothingQuality = "high"), l2 && (s2.rotate(l2 * Math.PI / 180), 90 === l2 ? s2.translate(0, -g.width) : 180 === l2 ? s2.translate(-g.width, -g.height) : 270 === l2 ? s2.translate(-g.height, 0) : 0 !== l2 && 360 !== l2 || s2.translate(0, 0)), s2.drawImage(e4, 0, 0, u2, d), g.toDataURL("image/".concat(i), h);
    } }, { key: "b64toByteArrays", value: function(e4, t4) {
      for (var a3 = atob(e4.toString().replace(/^data:image\/(png|jpeg|jpg|webp);base64,/, "")), r4 = [], n3 = 0; n3 < a3.length; n3 += 512) {
        for (var i = a3.slice(n3, n3 + 512), o2 = new Array(i.length), l2 = 0; l2 < i.length; l2++) o2[l2] = i.charCodeAt(l2);
        var h = new Uint8Array(o2);
        r4.push(h);
      }
      return r4;
    } }, { key: "b64toBlob", value: function(e4, t4) {
      var a3 = this.b64toByteArrays(e4, t4);
      return new Blob(a3, { type: t4, lastModified: /* @__PURE__ */ new Date() });
    } }, { key: "b64toFile", value: function(e4, t4, a3) {
      var r4 = this.b64toByteArrays(e4, a3);
      return new File(r4, t4, { type: a3, lastModified: /* @__PURE__ */ new Date() });
    } }, { key: "createResizedImage", value: function(t4, a3, r4, n3, i, o2, l2) {
      var h = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : "base64", g = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null, u2 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : null, d = new FileReader();
      if (!t4) throw Error("File Not Found!");
      if (t4.type && !t4.type.includes("image")) throw Error("File Is NOT Image!");
      d.readAsDataURL(t4), d.onload = function() {
        var c2 = new Image();
        c2.src = d.result, c2.onload = function() {
          var d2 = e3.resizeAndRotateImage(c2, a3, r4, g, u2, n3, i, o2), s2 = "image/".concat(n3);
          switch (h) {
            case "blob":
              var f = e3.b64toBlob(d2, s2);
              l2(f);
              break;
            case "base64":
              l2(d2);
              break;
            case "file":
              var b = t4.name.toString().replace(/(png|jpeg|jpg|webp)$/i, "").concat(n3.toString()), v = e3.b64toFile(d2, b, s2);
              l2(v);
              break;
            default:
              l2(d2);
          }
        };
      }, d.onerror = function(e4) {
        throw Error(e4);
      };
    } }], r3 && a2(t3, r3), e3;
  }();
  const n2 = { imageFileResizer: function(e3, t3, a3, n3, i, o2, l2, h, g, u2) {
    return r2.createResizedImage(e3, t3, a3, n3, i, o2, l2, h, g, u2);
  } };
  build.exports = t2;
})();
var buildExports = build.exports;
const Resizer = /* @__PURE__ */ getDefaultExportFromCjs$1(buildExports);
function _assertThisInitialized(e2) {
  if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2;
}
function _setPrototypeOf(t2, e2) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, _setPrototypeOf(t2, e2);
}
function _inheritsLoose(t2, o2) {
  t2.prototype = Object.create(o2.prototype), t2.prototype.constructor = t2, _setPrototypeOf(t2, o2);
}
var safeIsNaN = Number.isNaN || function ponyfill2(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first2, second) {
  if (first2 === second) {
    return true;
  }
  if (safeIsNaN(first2) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual2) {
  if (isEqual2 === void 0) {
    isEqual2 = areInputsEqual;
  }
  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (calledOnce && lastThis === this && isEqual2(newArgs, lastArgs)) {
      return lastResult;
    }
    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  }
  return memoized;
}
const { createElement: createElement$1, PureComponent } = await importShared("react");
var hasNativePerformanceNow = typeof performance === "object" && typeof performance.now === "function";
var now = hasNativePerformanceNow ? function() {
  return performance.now();
} : function() {
  return Date.now();
};
function cancelTimeout(timeoutID) {
  cancelAnimationFrame(timeoutID.id);
}
function requestTimeout(callback, delay) {
  var start2 = now();
  function tick() {
    if (now() - start2 >= delay) {
      callback.call(null);
    } else {
      timeoutID.id = requestAnimationFrame(tick);
    }
  }
  var timeoutID = {
    id: requestAnimationFrame(tick)
  };
  return timeoutID;
}
var size = -1;
function getScrollbarSize(recalculate) {
  if (recalculate === void 0) {
    recalculate = false;
  }
  if (size === -1 || recalculate) {
    var div2 = document.createElement("div");
    var style2 = div2.style;
    style2.width = "50px";
    style2.height = "50px";
    style2.overflow = "scroll";
    document.body.appendChild(div2);
    size = div2.offsetWidth - div2.clientWidth;
    document.body.removeChild(div2);
  }
  return size;
}
var cachedRTLResult = null;
function getRTLOffsetType(recalculate) {
  if (recalculate === void 0) {
    recalculate = false;
  }
  if (cachedRTLResult === null || recalculate) {
    var outerDiv = document.createElement("div");
    var outerStyle = outerDiv.style;
    outerStyle.width = "50px";
    outerStyle.height = "50px";
    outerStyle.overflow = "scroll";
    outerStyle.direction = "rtl";
    var innerDiv = document.createElement("div");
    var innerStyle = innerDiv.style;
    innerStyle.width = "100px";
    innerStyle.height = "100px";
    outerDiv.appendChild(innerDiv);
    document.body.appendChild(outerDiv);
    if (outerDiv.scrollLeft > 0) {
      cachedRTLResult = "positive-descending";
    } else {
      outerDiv.scrollLeft = 1;
      if (outerDiv.scrollLeft === 0) {
        cachedRTLResult = "negative";
      } else {
        cachedRTLResult = "positive-ascending";
      }
    }
    document.body.removeChild(outerDiv);
    return cachedRTLResult;
  }
  return cachedRTLResult;
}
var IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;
var defaultItemKey$1 = function defaultItemKey3(index2, data) {
  return index2;
};
function createListComponent(_ref) {
  var _class;
  var getItemOffset3 = _ref.getItemOffset, getEstimatedTotalSize4 = _ref.getEstimatedTotalSize, getItemSize3 = _ref.getItemSize, getOffsetForIndexAndAlignment5 = _ref.getOffsetForIndexAndAlignment, getStartIndexForOffset3 = _ref.getStartIndexForOffset, getStopIndexForStartIndex3 = _ref.getStopIndexForStartIndex, initInstanceProps5 = _ref.initInstanceProps, shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange, validateProps5 = _ref.validateProps;
  return _class = /* @__PURE__ */ function(_PureComponent) {
    _inheritsLoose(List, _PureComponent);
    function List(props) {
      var _this;
      _this = _PureComponent.call(this, props) || this;
      _this._instanceProps = initInstanceProps5(_this.props, _assertThisInitialized(_this));
      _this._outerRef = void 0;
      _this._resetIsScrollingTimeoutId = null;
      _this.state = {
        instance: _assertThisInitialized(_this),
        isScrolling: false,
        scrollDirection: "forward",
        scrollOffset: typeof _this.props.initialScrollOffset === "number" ? _this.props.initialScrollOffset : 0,
        scrollUpdateWasRequested: false
      };
      _this._callOnItemsRendered = void 0;
      _this._callOnItemsRendered = memoizeOne(function(overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {
        return _this.props.onItemsRendered({
          overscanStartIndex,
          overscanStopIndex,
          visibleStartIndex,
          visibleStopIndex
        });
      });
      _this._callOnScroll = void 0;
      _this._callOnScroll = memoizeOne(function(scrollDirection, scrollOffset, scrollUpdateWasRequested) {
        return _this.props.onScroll({
          scrollDirection,
          scrollOffset,
          scrollUpdateWasRequested
        });
      });
      _this._getItemStyle = void 0;
      _this._getItemStyle = function(index2) {
        var _this$props = _this.props, direction2 = _this$props.direction, itemSize = _this$props.itemSize, layout = _this$props.layout;
        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction2);
        var style2;
        if (itemStyleCache.hasOwnProperty(index2)) {
          style2 = itemStyleCache[index2];
        } else {
          var _offset = getItemOffset3(_this.props, index2, _this._instanceProps);
          var size2 = getItemSize3(_this.props, index2, _this._instanceProps);
          var isHorizontal = direction2 === "horizontal" || layout === "horizontal";
          var isRtl = direction2 === "rtl";
          var offsetHorizontal = isHorizontal ? _offset : 0;
          itemStyleCache[index2] = style2 = {
            position: "absolute",
            left: isRtl ? void 0 : offsetHorizontal,
            right: isRtl ? offsetHorizontal : void 0,
            top: !isHorizontal ? _offset : 0,
            height: !isHorizontal ? size2 : "100%",
            width: isHorizontal ? size2 : "100%"
          };
        }
        return style2;
      };
      _this._getItemStyleCache = void 0;
      _this._getItemStyleCache = memoizeOne(function(_, __, ___) {
        return {};
      });
      _this._onScrollHorizontal = function(event) {
        var _event$currentTarget = event.currentTarget, clientWidth = _event$currentTarget.clientWidth, scrollLeft = _event$currentTarget.scrollLeft, scrollWidth = _event$currentTarget.scrollWidth;
        _this.setState(function(prevState) {
          if (prevState.scrollOffset === scrollLeft) {
            return null;
          }
          var direction2 = _this.props.direction;
          var scrollOffset = scrollLeft;
          if (direction2 === "rtl") {
            switch (getRTLOffsetType()) {
              case "negative":
                scrollOffset = -scrollLeft;
                break;
              case "positive-descending":
                scrollOffset = scrollWidth - clientWidth - scrollLeft;
                break;
            }
          }
          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
          return {
            isScrolling: true,
            scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
            scrollOffset,
            scrollUpdateWasRequested: false
          };
        }, _this._resetIsScrollingDebounced);
      };
      _this._onScrollVertical = function(event) {
        var _event$currentTarget2 = event.currentTarget, clientHeight = _event$currentTarget2.clientHeight, scrollHeight = _event$currentTarget2.scrollHeight, scrollTop = _event$currentTarget2.scrollTop;
        _this.setState(function(prevState) {
          if (prevState.scrollOffset === scrollTop) {
            return null;
          }
          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
          return {
            isScrolling: true,
            scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
            scrollOffset,
            scrollUpdateWasRequested: false
          };
        }, _this._resetIsScrollingDebounced);
      };
      _this._outerRefSetter = function(ref) {
        var outerRef = _this.props.outerRef;
        _this._outerRef = ref;
        if (typeof outerRef === "function") {
          outerRef(ref);
        } else if (outerRef != null && typeof outerRef === "object" && outerRef.hasOwnProperty("current")) {
          outerRef.current = ref;
        }
      };
      _this._resetIsScrollingDebounced = function() {
        if (_this._resetIsScrollingTimeoutId !== null) {
          cancelTimeout(_this._resetIsScrollingTimeoutId);
        }
        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);
      };
      _this._resetIsScrolling = function() {
        _this._resetIsScrollingTimeoutId = null;
        _this.setState({
          isScrolling: false
        }, function() {
          _this._getItemStyleCache(-1, null);
        });
      };
      return _this;
    }
    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
      validateSharedProps$1(nextProps, prevState);
      validateProps5(nextProps);
      return null;
    };
    var _proto = List.prototype;
    _proto.scrollTo = function scrollTo(scrollOffset) {
      scrollOffset = Math.max(0, scrollOffset);
      this.setState(function(prevState) {
        if (prevState.scrollOffset === scrollOffset) {
          return null;
        }
        return {
          scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
          scrollOffset,
          scrollUpdateWasRequested: true
        };
      }, this._resetIsScrollingDebounced);
    };
    _proto.scrollToItem = function scrollToItem(index2, align) {
      if (align === void 0) {
        align = "auto";
      }
      var _this$props2 = this.props, itemCount = _this$props2.itemCount, layout = _this$props2.layout;
      var scrollOffset = this.state.scrollOffset;
      index2 = Math.max(0, Math.min(index2, itemCount - 1));
      var scrollbarSize = 0;
      if (this._outerRef) {
        var outerRef = this._outerRef;
        if (layout === "vertical") {
          scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;
        } else {
          scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;
        }
      }
      this.scrollTo(getOffsetForIndexAndAlignment5(this.props, index2, align, scrollOffset, this._instanceProps, scrollbarSize));
    };
    _proto.componentDidMount = function componentDidMount() {
      var _this$props3 = this.props, direction2 = _this$props3.direction, initialScrollOffset = _this$props3.initialScrollOffset, layout = _this$props3.layout;
      if (typeof initialScrollOffset === "number" && this._outerRef != null) {
        var outerRef = this._outerRef;
        if (direction2 === "horizontal" || layout === "horizontal") {
          outerRef.scrollLeft = initialScrollOffset;
        } else {
          outerRef.scrollTop = initialScrollOffset;
        }
      }
      this._callPropsCallbacks();
    };
    _proto.componentDidUpdate = function componentDidUpdate() {
      var _this$props4 = this.props, direction2 = _this$props4.direction, layout = _this$props4.layout;
      var _this$state = this.state, scrollOffset = _this$state.scrollOffset, scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;
      if (scrollUpdateWasRequested && this._outerRef != null) {
        var outerRef = this._outerRef;
        if (direction2 === "horizontal" || layout === "horizontal") {
          if (direction2 === "rtl") {
            switch (getRTLOffsetType()) {
              case "negative":
                outerRef.scrollLeft = -scrollOffset;
                break;
              case "positive-ascending":
                outerRef.scrollLeft = scrollOffset;
                break;
              default:
                var clientWidth = outerRef.clientWidth, scrollWidth = outerRef.scrollWidth;
                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;
                break;
            }
          } else {
            outerRef.scrollLeft = scrollOffset;
          }
        } else {
          outerRef.scrollTop = scrollOffset;
        }
      }
      this._callPropsCallbacks();
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this._resetIsScrollingTimeoutId !== null) {
        cancelTimeout(this._resetIsScrollingTimeoutId);
      }
    };
    _proto.render = function render2() {
      var _this$props5 = this.props, children = _this$props5.children, className = _this$props5.className, direction2 = _this$props5.direction, height = _this$props5.height, innerRef = _this$props5.innerRef, innerElementType2 = _this$props5.innerElementType, innerTagName = _this$props5.innerTagName, itemCount = _this$props5.itemCount, itemData = _this$props5.itemData, _this$props5$itemKey = _this$props5.itemKey, itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey, layout = _this$props5.layout, outerElementType = _this$props5.outerElementType, outerTagName = _this$props5.outerTagName, style2 = _this$props5.style, useIsScrolling = _this$props5.useIsScrolling, width = _this$props5.width;
      var isScrolling = this.state.isScrolling;
      var isHorizontal = direction2 === "horizontal" || layout === "horizontal";
      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;
      var _this$_getRangeToRend = this._getRangeToRender(), startIndex = _this$_getRangeToRend[0], stopIndex = _this$_getRangeToRend[1];
      var items2 = [];
      if (itemCount > 0) {
        for (var _index = startIndex; _index <= stopIndex; _index++) {
          items2.push(createElement$1(children, {
            data: itemData,
            key: itemKey(_index, itemData),
            index: _index,
            isScrolling: useIsScrolling ? isScrolling : void 0,
            style: this._getItemStyle(_index)
          }));
        }
      }
      var estimatedTotalSize = getEstimatedTotalSize4(this.props, this._instanceProps);
      return createElement$1(outerElementType || outerTagName || "div", {
        className,
        onScroll,
        ref: this._outerRefSetter,
        style: _extends$9({
          position: "relative",
          height,
          width,
          overflow: "auto",
          WebkitOverflowScrolling: "touch",
          willChange: "transform",
          direction: direction2
        }, style2)
      }, createElement$1(innerElementType2 || innerTagName || "div", {
        children: items2,
        ref: innerRef,
        style: {
          height: isHorizontal ? "100%" : estimatedTotalSize,
          pointerEvents: isScrolling ? "none" : void 0,
          width: isHorizontal ? estimatedTotalSize : "100%"
        }
      }));
    };
    _proto._callPropsCallbacks = function _callPropsCallbacks() {
      if (typeof this.props.onItemsRendered === "function") {
        var itemCount = this.props.itemCount;
        if (itemCount > 0) {
          var _this$_getRangeToRend2 = this._getRangeToRender(), _overscanStartIndex = _this$_getRangeToRend2[0], _overscanStopIndex = _this$_getRangeToRend2[1], _visibleStartIndex = _this$_getRangeToRend2[2], _visibleStopIndex = _this$_getRangeToRend2[3];
          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);
        }
      }
      if (typeof this.props.onScroll === "function") {
        var _this$state2 = this.state, _scrollDirection = _this$state2.scrollDirection, _scrollOffset = _this$state2.scrollOffset, _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;
        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);
      }
    };
    _proto._getRangeToRender = function _getRangeToRender() {
      var _this$props6 = this.props, itemCount = _this$props6.itemCount, overscanCount = _this$props6.overscanCount;
      var _this$state3 = this.state, isScrolling = _this$state3.isScrolling, scrollDirection = _this$state3.scrollDirection, scrollOffset = _this$state3.scrollOffset;
      if (itemCount === 0) {
        return [0, 0, 0, 0];
      }
      var startIndex = getStartIndexForOffset3(this.props, scrollOffset, this._instanceProps);
      var stopIndex = getStopIndexForStartIndex3(this.props, startIndex, scrollOffset, this._instanceProps);
      var overscanBackward = !isScrolling || scrollDirection === "backward" ? Math.max(1, overscanCount) : 1;
      var overscanForward = !isScrolling || scrollDirection === "forward" ? Math.max(1, overscanCount) : 1;
      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
    };
    return List;
  }(PureComponent), _class.defaultProps = {
    direction: "ltr",
    itemData: void 0,
    layout: "vertical",
    overscanCount: 2,
    useIsScrolling: false
  }, _class;
}
var validateSharedProps$1 = function validateSharedProps3(_ref2, _ref3) {
  _ref2.children;
  _ref2.direction;
  _ref2.height;
  _ref2.layout;
  _ref2.innerTagName;
  _ref2.outerTagName;
  _ref2.width;
  _ref3.instance;
};
var FixedSizeList = /* @__PURE__ */ createListComponent({
  getItemOffset: function getItemOffset2(_ref, index2) {
    var itemSize = _ref.itemSize;
    return index2 * itemSize;
  },
  getItemSize: function getItemSize2(_ref2, index2) {
    var itemSize = _ref2.itemSize;
    return itemSize;
  },
  getEstimatedTotalSize: function getEstimatedTotalSize3(_ref3) {
    var itemCount = _ref3.itemCount, itemSize = _ref3.itemSize;
    return itemSize * itemCount;
  },
  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment4(_ref4, index2, align, scrollOffset, instanceProps, scrollbarSize) {
    var direction2 = _ref4.direction, height = _ref4.height, itemCount = _ref4.itemCount, itemSize = _ref4.itemSize, layout = _ref4.layout, width = _ref4.width;
    var isHorizontal = direction2 === "horizontal" || layout === "horizontal";
    var size2 = isHorizontal ? width : height;
    var lastItemOffset = Math.max(0, itemCount * itemSize - size2);
    var maxOffset = Math.min(lastItemOffset, index2 * itemSize);
    var minOffset = Math.max(0, index2 * itemSize - size2 + itemSize + scrollbarSize);
    if (align === "smart") {
      if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
        align = "auto";
      } else {
        align = "center";
      }
    }
    switch (align) {
      case "start":
        return maxOffset;
      case "end":
        return minOffset;
      case "center": {
        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
        if (middleOffset < Math.ceil(size2 / 2)) {
          return 0;
        } else if (middleOffset > lastItemOffset + Math.floor(size2 / 2)) {
          return lastItemOffset;
        } else {
          return middleOffset;
        }
      }
      case "auto":
      default:
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  },
  getStartIndexForOffset: function getStartIndexForOffset2(_ref5, offset3) {
    var itemCount = _ref5.itemCount, itemSize = _ref5.itemSize;
    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset3 / itemSize)));
  },
  getStopIndexForStartIndex: function getStopIndexForStartIndex2(_ref6, startIndex, scrollOffset) {
    var direction2 = _ref6.direction, height = _ref6.height, itemCount = _ref6.itemCount, itemSize = _ref6.itemSize, layout = _ref6.layout, width = _ref6.width;
    var isHorizontal = direction2 === "horizontal" || layout === "horizontal";
    var offset3 = startIndex * itemSize;
    var size2 = isHorizontal ? width : height;
    var numVisibleItems = Math.ceil((size2 + scrollOffset - offset3) / itemSize);
    return Math.max(0, Math.min(
      itemCount - 1,
      startIndex + numVisibleItems - 1
      // -1 is because stop index is inclusive
    ));
  },
  initInstanceProps: function initInstanceProps4(props) {
  },
  shouldResetStyleCacheOnItemSizeChange: true,
  validateProps: function validateProps4(_ref7) {
    _ref7.itemSize;
  }
});
function OrderedMap(content) {
  this.content = content;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key) return i;
    return -1;
  },
  // :: (string)  ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  // :: (string, any, ?string)  OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self2.find(key), content = self2.content.slice();
    if (found2 == -1) {
      content.push(newKey || key, value);
    } else {
      content[found2 + 1] = value;
      if (newKey) content[found2] = newKey;
    }
    return new OrderedMap(content);
  },
  // :: (string)  OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1) return this;
    var content = this.content.slice();
    content.splice(found2, 2);
    return new OrderedMap(content);
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content);
  },
  // :: (string, string, any)  OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found2 = without.find(place);
    content.splice(found2 == -1 ? content.length : found2, 0, key, value);
    return new OrderedMap(content);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map3) {
    map3 = OrderedMap.from(map3);
    if (!map3.size) return this;
    return new OrderedMap(map3.content.concat(this.subtract(map3).content));
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map3) {
    map3 = OrderedMap.from(map3);
    if (!map3.size) return this;
    return new OrderedMap(this.subtract(map3).content.concat(map3.content));
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map3) {
    var result = this;
    map3 = OrderedMap.from(map3);
    for (var i = 0; i < map3.content.length; i += 2)
      result = result.remove(map3.content[i]);
    return result;
  },
  // :: ()  Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var result = {};
    this.forEach(function(key, value) {
      result[key] = value;
    });
    return result;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap) return value;
  var content = [];
  if (value) for (var prop in value) content.push(prop, value[prop]);
  return new OrderedMap(content);
};
function findDiffStart(a2, b, pos) {
  for (let i = 0; ; i++) {
    if (i == a2.childCount || i == b.childCount)
      return a2.childCount == b.childCount ? null : pos;
    let childA = a2.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j = 0; childA.text[j] == childB.text[j]; j++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a2, b, posA, posB) {
  for (let iA = a2.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a2.child(--iA), childB = b.child(--iB), size2 = childA.nodeSize;
    if (childA == childB) {
      posA -= size2;
      posB -= size2;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size2;
    posB -= size2;
  }
}
class Fragment {
  /**
  @internal
  */
  constructor(content, size2) {
    this.content = content;
    this.size = size2 || 0;
    if (size2 == null)
      for (let i = 0; i < content.length; i++)
        this.size += content[i].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(from2, to, f, nodeStart = 0, parent) {
    for (let i = 0, pos = 0; pos < to; i++) {
      let child = this.content[i], end2 = pos + child.nodeSize;
      if (end2 > from2 && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
        let start2 = pos + 1;
        child.nodesBetween(Math.max(0, from2 - start2), Math.min(child.content.size, to - start2), f, nodeStart + start2);
      }
      pos = end2;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(from2, to, blockSeparator, leafText) {
    let text = "", first2 = true;
    this.nodesBetween(from2, to, (node, pos) => {
      let nodeText = node.isText ? node.text.slice(Math.max(from2, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
      if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
        if (first2)
          first2 = false;
        else
          text += blockSeparator;
      }
      text += nodeText;
    }, 0);
    return text;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i = 0;
    if (last.isText && last.sameMarkup(first2)) {
      content[content.length - 1] = last.withText(last.text + first2.text);
      i = 1;
    }
    for (; i < other.content.length; i++)
      content.push(other.content[i]);
    return new Fragment(content, this.size + other.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(from2, to = this.size) {
    if (from2 == 0 && to == this.size)
      return this;
    let result = [], size2 = 0;
    if (to > from2)
      for (let i = 0, pos = 0; pos < to; i++) {
        let child = this.content[i], end2 = pos + child.nodeSize;
        if (end2 > from2) {
          if (pos < from2 || end2 > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size2 += child.nodeSize;
        }
        pos = end2;
      }
    return new Fragment(result, size2);
  }
  /**
  @internal
  */
  cutByIndex(from2, to) {
    if (from2 == to)
      return Fragment.empty;
    if (from2 == 0 && to == this.content.length)
      return this;
    return new Fragment(this.content.slice(from2, to));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(index2, node) {
    let current = this.content[index2];
    if (current == node)
      return this;
    let copy2 = this.content.slice();
    let size2 = this.size + node.nodeSize - current.nodeSize;
    copy2[index2] = node;
    return new Fragment(copy2, size2);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(node) {
    return new Fragment([node].concat(this.content), this.size + node.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(node) {
    return new Fragment(this.content.concat(node), this.size + node.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i = 0; i < this.content.length; i++)
      if (!this.content[i].eq(other.content[i]))
        return false;
    return true;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(index2) {
    let found2 = this.content[index2];
    if (!found2)
      throw new RangeError("Index " + index2 + " out of range for " + this);
    return found2;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index2) {
    return this.content[index2] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    for (let i = 0, p2 = 0; i < this.content.length; i++) {
      let child = this.content[i];
      f(child, p2, i);
      p2 += child.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(pos, round2 = -1) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i = 0, curPos = 0; ; i++) {
      let cur = this.child(i), end2 = curPos + cur.nodeSize;
      if (end2 >= pos) {
        if (end2 == pos || round2 > 0)
          return retIndex(i + 1, end2);
        return retIndex(i, curPos);
      }
      curPos = end2;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((n2) => n2.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(schema2, value) {
    if (!value)
      return Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Fragment(value.map(schema2.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(array2) {
    if (!array2.length)
      return Fragment.empty;
    let joined, size2 = 0;
    for (let i = 0; i < array2.length; i++) {
      let node = array2[i];
      size2 += node.nodeSize;
      if (i && node.isText && array2[i - 1].sameMarkup(node)) {
        if (!joined)
          joined = array2.slice(0, i);
        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
      } else if (joined) {
        joined.push(node);
      }
    }
    return new Fragment(joined || array2, size2);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(nodes) {
    if (!nodes)
      return Fragment.empty;
    if (nodes instanceof Fragment)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new Fragment([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
Fragment.empty = new Fragment([], 0);
const found = { index: 0, offset: 0 };
function retIndex(index2, offset3) {
  found.index = index2;
  found.offset = offset3;
  return found;
}
function compareDeep(a2, b) {
  if (a2 === b)
    return true;
  if (!(a2 && typeof a2 == "object") || !(b && typeof b == "object"))
    return false;
  let array2 = Array.isArray(a2);
  if (Array.isArray(b) != array2)
    return false;
  if (array2) {
    if (a2.length != b.length)
      return false;
    for (let i = 0; i < a2.length; i++)
      if (!compareDeep(a2[i], b[i]))
        return false;
  } else {
    for (let p2 in a2)
      if (!(p2 in b) || !compareDeep(a2[p2], b[p2]))
        return false;
    for (let p2 in b)
      if (!(p2 in a2))
        return false;
  }
  return true;
}
let Mark$2 = class Mark {
  /**
  @internal
  */
  constructor(type, attrs2) {
    this.type = type;
    this.attrs = attrs2;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(set2) {
    let copy2, placed = false;
    for (let i = 0; i < set2.length; i++) {
      let other = set2[i];
      if (this.eq(other))
        return set2;
      if (this.type.excludes(other.type)) {
        if (!copy2)
          copy2 = set2.slice(0, i);
      } else if (other.type.excludes(this.type)) {
        return set2;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy2)
            copy2 = set2.slice(0, i);
          copy2.push(this);
          placed = true;
        }
        if (copy2)
          copy2.push(other);
      }
    }
    if (!copy2)
      copy2 = set2.slice();
    if (!placed)
      copy2.push(this);
    return copy2;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(set2) {
    for (let i = 0; i < set2.length; i++)
      if (this.eq(set2[i]))
        return set2.slice(0, i).concat(set2.slice(i + 1));
    return set2;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(set2) {
    for (let i = 0; i < set2.length; i++)
      if (this.eq(set2[i]))
        return true;
    return false;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(schema2, json) {
    if (!json)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type = schema2.marks[json.type];
    if (!type)
      throw new RangeError(`There is no mark type ${json.type} in this schema`);
    let mark = type.create(json.attrs);
    type.checkAttrs(mark.attrs);
    return mark;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(a2, b) {
    if (a2 == b)
      return true;
    if (a2.length != b.length)
      return false;
    for (let i = 0; i < a2.length; i++)
      if (!a2[i].eq(b[i]))
        return false;
    return true;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return Mark.none;
    if (marks instanceof Mark)
      return [marks];
    let copy2 = marks.slice();
    copy2.sort((a2, b) => a2.type.rank - b.type.rank);
    return copy2;
  }
};
Mark$2.none = [];
class ReplaceError extends Error {
}
class Slice {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragmenti.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(content, openStart, openEnd) {
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(pos, fragment) {
    let content = insertInto(this.content, pos + this.openStart, fragment);
    return content && new Slice(content, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(from2, to) {
    return new Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(schema2, json) {
    if (!json)
      return Slice.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Slice(Fragment.fromJSON(schema2, json.content), openStart, openEnd);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n2 = fragment.firstChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.firstChild)
      openStart++;
    for (let n2 = fragment.lastChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.lastChild)
      openEnd++;
    return new Slice(fragment, openStart, openEnd);
  }
}
Slice.empty = new Slice(Fragment.empty, 0, 0);
function removeRange(content, from2, to) {
  let { index: index2, offset: offset3 } = content.findIndex(from2), child = content.maybeChild(index2);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to);
  if (offset3 == from2 || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from2).append(content.cut(to));
  }
  if (index2 != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index2, child.copy(removeRange(child.content, from2 - offset3 - 1, to - offset3 - 1)));
}
function insertInto(content, dist, insert, parent) {
  let { index: index2, offset: offset3 } = content.findIndex(dist), child = content.maybeChild(index2);
  if (offset3 == dist || child.isText) {
    return content.cut(0, dist).append(insert).append(content.cut(dist));
  }
  let inner = insertInto(child.content, dist - offset3 - 1, insert);
  return inner && content.replaceChild(index2, child.copy(inner));
}
function replace($from, $to, slice2) {
  if (slice2.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice2, 0);
}
function replaceOuter($from, $to, slice2, depth) {
  let index2 = $from.index(depth), node = $from.node(depth);
  if (index2 == $to.index(depth) && depth < $from.depth - slice2.openStart) {
    let inner = replaceOuter($from, $to, slice2, depth + 1);
    return node.copy(node.content.replaceChild(index2, inner));
  } else if (!slice2.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));
  } else {
    let { start: start2, end: end2 } = prepareSliceForReplace(slice2, $from);
    return close(node, replaceThreeWay($from, start2, end2, $to, depth));
  }
}
function checkJoin(main2, sub) {
  if (!sub.type.compatibleContent(main2.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main2.type.name);
}
function joinable$1($before, $after, depth) {
  let node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}
function addNode(child, target) {
  let last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last]))
    target[last] = child.withText(target[last].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i = startIndex; i < endIndex; i++)
    addNode(node.child(i), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node, content) {
  node.type.checkContent(content);
  return node.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable$1($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable$1($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type = joinable$1($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function prepareSliceForReplace(slice2, $along) {
  let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
  let node = parent.copy(slice2.content);
  for (let i = extra - 1; i >= 0; i--)
    node = $along.node(i).copy(Fragment.from(node));
  return {
    start: node.resolveNoCache(slice2.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)
  };
}
class ResolvedPos {
  /**
  @internal
  */
  constructor(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parenttext nodes are flat in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let parent = this.parent, index2 = this.index(this.depth);
    if (index2 == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index2);
    return dOff ? parent.child(index2).cut(dOff) : child;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let index2 = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index2).cut(0, dOff);
    return index2 == 0 ? null : this.parent.child(index2 - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(index2, depth) {
    depth = this.resolveDepth(depth);
    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i = 0; i < index2; i++)
      pos += node.child(i).nodeSize;
    return pos;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let parent = this.parent, index2 = this.index();
    if (parent.content.size == 0)
      return Mark$2.none;
    if (this.textOffset)
      return parent.child(index2).marks;
    let main2 = parent.maybeChild(index2 - 1), other = parent.maybeChild(index2);
    if (!main2) {
      let tmp = main2;
      main2 = other;
      other = tmp;
    }
    let marks = main2.marks;
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross($end) {
    let after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline)
      return null;
    let marks = after.marks, next = $end.parent.maybeChild($end.index());
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
        return new NodeRange(this, other, d);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  /**
  @internal
  */
  toString() {
    let str = "";
    for (let i = 1; i <= this.depth; i++)
      str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
    return str + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(doc2, pos) {
    if (!(pos >= 0 && pos <= doc2.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path = [];
    let start2 = 0, parentOffset = pos;
    for (let node = doc2; ; ) {
      let { index: index2, offset: offset3 } = node.content.findIndex(parentOffset);
      let rem = parentOffset - offset3;
      path.push(node, index2, start2 + offset3);
      if (!rem)
        break;
      node = node.child(index2);
      if (node.isText)
        break;
      parentOffset = rem - 1;
      start2 += offset3 + 1;
    }
    return new ResolvedPos(pos, path, parentOffset);
  }
  /**
  @internal
  */
  static resolveCached(doc2, pos) {
    let cache = resolveCache.get(doc2);
    if (cache) {
      for (let i = 0; i < cache.elts.length; i++) {
        let elt = cache.elts[i];
        if (elt.pos == pos)
          return elt;
      }
    } else {
      resolveCache.set(doc2, cache = new ResolveCache());
    }
    let result = cache.elts[cache.i] = ResolvedPos.resolve(doc2, pos);
    cache.i = (cache.i + 1) % resolveCacheSize;
    return result;
  }
}
class ResolveCache {
  constructor() {
    this.elts = [];
    this.i = 0;
  }
}
const resolveCacheSize = 12, resolveCache = /* @__PURE__ */ new WeakMap();
class NodeRange {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const emptyAttrs = /* @__PURE__ */ Object.create(null);
let Node$3 = class Node2 {
  /**
  @internal
  */
  constructor(type, attrs2, content, marks = Mark$2.none) {
    this.type = type;
    this.attrs = attrs2;
    this.marks = marks;
    this.content = content || Fragment.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(index2) {
    return this.content.child(index2);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index2) {
    return this.content.maybeChild(index2);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    this.content.forEach(f);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(from2, to, f, startPos = 0) {
    this.content.nodesBetween(from2, to, f, startPos, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(f) {
    this.nodesBetween(0, this.content.size, f);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(from2, to, blockSeparator, leafText) {
    return this.content.textBetween(from2, to, blockSeparator, leafText);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(type, attrs2, marks) {
    return this.type == type && compareDeep(this.attrs, attrs2 || type.defaultAttrs || emptyAttrs) && Mark$2.sameSet(this.marks, marks || Mark$2.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(content = null) {
    if (content == this.content)
      return this;
    return new Node2(this.type, this.attrs, content, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(marks) {
    return marks == this.marks ? this : new Node2(this.type, this.attrs, this.content, marks);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(from2, to = this.content.size) {
    if (from2 == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from2, to));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(from2, to = this.content.size, includeParents = false) {
    if (from2 == to)
      return Slice.empty;
    let $from = this.resolve(from2), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start2 = $from.start(depth), node = $from.node(depth);
    let content = node.content.cut($from.pos - start2, $to.pos - start2);
    return new Slice(content, $from.depth - depth, $to.depth - depth);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(from2, to, slice2) {
    return replace(this.resolve(from2), this.resolve(to), slice2);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(pos) {
    for (let node = this; ; ) {
      let { index: index2, offset: offset3 } = node.content.findIndex(pos);
      node = node.maybeChild(index2);
      if (!node)
        return null;
      if (offset3 == pos || node.isText)
        return node;
      pos -= offset3 + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(pos) {
    let { index: index2, offset: offset3 } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index2), index: index2, offset: offset3 };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: index2, offset: offset3 } = this.content.findIndex(pos);
    if (offset3 < pos)
      return { node: this.content.child(index2), index: index2, offset: offset3 };
    let node = this.content.child(index2 - 1);
    return { node, index: index2 - 1, offset: offset3 - node.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(pos) {
    return ResolvedPos.resolveCached(this, pos);
  }
  /**
  @internal
  */
  resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(from2, to, type) {
    let found2 = false;
    if (to > from2)
      this.nodesBetween(from2, to, (node) => {
        if (type.isInSet(node.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(index2) {
    let match2 = this.type.contentMatch.matchFragment(this.content, 0, index2);
    if (!match2)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match2;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(from2, to, replacement = Fragment.empty, start2 = 0, end2 = replacement.childCount) {
    let one = this.contentMatchAt(from2).matchFragment(replacement, start2, end2);
    let two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (let i = start2; i < end2; i++)
      if (!this.type.allowsMarks(replacement.child(i).marks))
        return false;
    return true;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(from2, to, type, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    let start2 = this.contentMatchAt(from2).matchType(type);
    let end2 = start2 && start2.matchFragment(this.content, to);
    return end2 ? end2.validEnd : false;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    this.type.checkAttrs(this.attrs);
    let copy2 = Mark$2.none;
    for (let i = 0; i < this.marks.length; i++) {
      let mark = this.marks[i];
      mark.type.checkAttrs(mark.attrs);
      copy2 = mark.addToSet(copy2);
    }
    if (!Mark$2.sameSet(copy2, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
    this.content.forEach((node) => node.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n2) => n2.toJSON());
    return obj;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(schema2, json) {
    if (!json)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks = void 0;
    if (json.marks) {
      if (!Array.isArray(json.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json.marks.map(schema2.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema2.text(json.text, marks);
    }
    let content = Fragment.fromJSON(schema2, json.content);
    let node = schema2.nodeType(json.type).create(json.attrs, content, marks);
    node.type.checkAttrs(node.attrs);
    return node;
  }
};
Node$3.prototype.text = void 0;
class TextNode extends Node$3 {
  /**
  @internal
  */
  constructor(type, attrs2, content, marks) {
    super(type, attrs2, null, marks);
    if (!content)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from2, to) {
    return this.text.slice(from2, to);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks) {
    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);
  }
  withText(text) {
    if (text == this.text)
      return this;
    return new TextNode(this.type, this.attrs, text, this.marks);
  }
  cut(from2 = 0, to = this.text.length) {
    if (from2 == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from2, to));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base2 = super.toJSON();
    base2.text = this.text;
    return base2;
  }
}
function wrapMarks(marks, str) {
  for (let i = marks.length - 1; i >= 0; i--)
    str = marks[i].type.name + "(" + str + ")";
  return str;
}
class ContentMatch {
  /**
  @internal
  */
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(string2, nodeTypes) {
    let stream = new TokenStream(string2, nodeTypes);
    if (stream.next == null)
      return ContentMatch.empty;
    let expr = parseExpr(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    let match2 = dfa(nfa(expr));
    checkForDeadEnds(match2, stream);
    return match2;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(type) {
    for (let i = 0; i < this.next.length; i++)
      if (this.next[i].type == type)
        return this.next[i].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(frag, start2 = 0, end2 = frag.childCount) {
    let cur = this;
    for (let i = start2; cur && i < end2; i++)
      cur = cur.matchType(frag.child(i).type);
    return cur;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let i = 0; i < this.next.length; i++) {
      let { type } = this.next[i];
      if (!(type.isText || type.hasRequiredAttrs()))
        return type;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(other) {
    for (let i = 0; i < this.next.length; i++)
      for (let j = 0; j < other.next.length; j++)
        if (this.next[i].type == other.next[j].type)
          return true;
    return false;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(after, toEnd = false, startIndex = 0) {
    let seen = [this];
    function search(match2, types) {
      let finished = match2.matchFragment(after, startIndex);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment.from(types.map((tp) => tp.createAndFill()));
      for (let i = 0; i < match2.next.length; i++) {
        let { type, next } = match2.next[i];
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          let found2 = search(next, types.concat(type));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(target) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == target)
        return this.wrapCache[i + 1];
    let computed = this.computeWrapping(target);
    this.wrapCache.push(target, computed);
    return computed;
  }
  /**
  @internal
  */
  computeWrapping(target) {
    let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current = active.shift(), match2 = current.match;
      if (match2.matchType(target)) {
        let result = [];
        for (let obj = current; obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse();
      }
      for (let i = 0; i < match2.next.length; i++) {
        let { type, next } = match2.next[i];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
          active.push({ match: type.contentMatch, type, via: current });
          seen[type.name] = true;
        }
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(n2) {
    if (n2 >= this.next.length)
      throw new RangeError(`There's no ${n2}th edge in this content match`);
    return this.next[n2];
  }
  /**
  @internal
  */
  toString() {
    let seen = [];
    function scan(m) {
      seen.push(m);
      for (let i = 0; i < m.next.length; i++)
        if (seen.indexOf(m.next[i].next) == -1)
          scan(m.next[i].next);
    }
    scan(this);
    return seen.map((m, i) => {
      let out = i + (m.validEnd ? "*" : " ") + " ";
      for (let i2 = 0; i2 < m.next.length; i2++)
        out += (i2 ? ", " : "") + m.next[i2].type.name + "->" + seen.indexOf(m.next[i2].next);
      return out;
    }).join("\n");
  }
}
ContentMatch.empty = new ContentMatch(true);
class TokenStream {
  constructor(string2, nodeTypes) {
    this.string = string2;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string2.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  }
}
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  let min2 = parseNum(stream), max2 = min2;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max2 = parseNum(stream);
    else
      max2 = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min: min2, max: max2, expr };
}
function resolveName(stream, name) {
  let types = stream.nodeTypes, type = types[name];
  if (type)
    return [type];
  let result = [];
  for (let typeName in types) {
    let type2 = types[typeName];
    if (type2.isInGroup(name))
      result.push(type2);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type) => {
      if (stream.inline == null)
        stream.inline = type.isInline;
      else if (stream.inline != type.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect2(compile(expr, 0), node());
  return nfa2;
  function node() {
    return nfa2.push([]) - 1;
  }
  function edge(from2, to, term) {
    let edge2 = { term, to };
    nfa2[from2].push(edge2);
    return edge2;
  }
  function connect2(edges, to) {
    edges.forEach((edge2) => edge2.to = to);
  }
  function compile(expr2, from2) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from2)), []);
    } else if (expr2.type == "seq") {
      for (let i = 0; ; i++) {
        let next = compile(expr2.exprs[i], from2);
        if (i == expr2.exprs.length - 1)
          return next;
        connect2(next, from2 = node());
      }
    } else if (expr2.type == "star") {
      let loop = node();
      edge(from2, loop);
      connect2(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "plus") {
      let loop = node();
      connect2(compile(expr2.expr, from2), loop);
      connect2(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "opt") {
      return [edge(from2)].concat(compile(expr2.expr, from2));
    } else if (expr2.type == "range") {
      let cur = from2;
      for (let i = 0; i < expr2.min; i++) {
        let next = node();
        connect2(compile(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect2(compile(expr2.expr, cur), cur);
      } else {
        for (let i = expr2.min; i < expr2.max; i++) {
          let next = node();
          edge(cur, next);
          connect2(compile(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from2, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a2, b) {
  return b - a2;
}
function nullFrom(nfa2, node) {
  let result = [];
  scan(node);
  return result.sort(cmp);
  function scan(node2) {
    let edges = nfa2[node2];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node2);
    for (let i = 0; i < edges.length; i++) {
      let { term, to } = edges[i];
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node) => {
      nfa2[node].forEach(({ term, to }) => {
        if (!term)
          return;
        let set2;
        for (let i = 0; i < out.length; i++)
          if (out[i][0] == term)
            set2 = out[i][1];
        nullFrom(nfa2, to).forEach((node2) => {
          if (!set2)
            out.push([term, set2 = []]);
          if (set2.indexOf(node2) == -1)
            set2.push(node2);
        });
      });
    });
    let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i = 0; i < out.length; i++) {
      let states2 = out[i][1].sort(cmp);
      state.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state;
  }
}
function checkForDeadEnds(match2, stream) {
  for (let i = 0, work = [match2]; i < work.length; i++) {
    let state = work[i], dead = !state.validEnd, nodes = [];
    for (let j = 0; j < state.next.length; j++) {
      let { type, next } = state.next[j];
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs2) {
  let defaults2 = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs2) {
    let attr = attrs2[attrName];
    if (!attr.hasDefault)
      return null;
    defaults2[attrName] = attr.default;
  }
  return defaults2;
}
function computeAttrs(attrs2, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name in attrs2) {
    let given = value && value[name];
    if (given === void 0) {
      let attr = attrs2[name];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function checkAttrs(attrs2, values, type, name) {
  for (let name2 in values)
    if (!(name2 in attrs2))
      throw new RangeError(`Unsupported attribute ${name2} for ${type} of type ${name2}`);
  for (let name2 in attrs2) {
    let attr = attrs2[name2];
    if (attr.validate)
      attr.validate(values[name2]);
  }
}
function initAttrs(typeName, attrs2) {
  let result = /* @__PURE__ */ Object.create(null);
  if (attrs2)
    for (let name in attrs2)
      result[name] = new Attribute(typeName, name, attrs2[name]);
  return result;
}
let NodeType$1 = class NodeType {
  /**
  @internal
  */
  constructor(name, schema2, spec) {
    this.name = name;
    this.schema = schema2;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(name, spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(group) {
    return this.groups.indexOf(group) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let n2 in this.attrs)
      if (this.attrs[n2].isRequired)
        return true;
    return false;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(attrs2) {
    if (!attrs2 && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs(this.attrs, attrs2);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(attrs2 = null, content, marks) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node$3(this, this.computeAttrs(attrs2), Fragment.from(content), Mark$2.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(attrs2 = null, content, marks) {
    content = Fragment.from(content);
    this.checkContent(content);
    return new Node$3(this, this.computeAttrs(attrs2), content, Mark$2.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(attrs2 = null, content, marks) {
    attrs2 = this.computeAttrs(attrs2);
    content = Fragment.from(content);
    if (content.size) {
      let before = this.contentMatch.fillBefore(content);
      if (!before)
        return null;
      content = before.append(content);
    }
    let matched = this.contentMatch.matchFragment(content);
    let after = matched && matched.fillBefore(Fragment.empty, true);
    if (!after)
      return null;
    return new Node$3(this, attrs2, content.append(after), Mark$2.setFrom(marks));
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(content) {
    let result = this.contentMatch.matchFragment(content);
    if (!result || !result.validEnd)
      return false;
    for (let i = 0; i < content.childCount; i++)
      if (!this.allowsMarks(content.child(i).marks))
        return false;
    return true;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(content) {
    if (!this.validContent(content))
      throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(attrs2) {
    checkAttrs(this.attrs, attrs2, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (let i = 0; i < marks.length; i++)
      if (!this.allowsMarkType(marks[i].type))
        return false;
    return true;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    let copy2;
    for (let i = 0; i < marks.length; i++) {
      if (!this.allowsMarkType(marks[i].type)) {
        if (!copy2)
          copy2 = marks.slice(0, i);
      } else if (copy2) {
        copy2.push(marks[i]);
      }
    }
    return !copy2 ? marks : copy2.length ? copy2 : Mark$2.none;
  }
  /**
  @internal
  */
  static compile(nodes, schema2) {
    let result = /* @__PURE__ */ Object.create(null);
    nodes.forEach((name, spec) => result[name] = new NodeType(name, schema2, spec));
    let topType = schema2.spec.topNode || "doc";
    if (!result[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _ in result.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result;
  }
};
function validateType(typeName, attrName, type) {
  let types = type.split("|");
  return (value) => {
    let name = value === null ? "null" : typeof value;
    if (types.indexOf(name) < 0)
      throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);
  };
}
class Attribute {
  constructor(typeName, attrName, options) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this.default = options.default;
    this.validate = typeof options.validate == "string" ? validateType(typeName, attrName, options.validate) : options.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class MarkType {
  /**
  @internal
  */
  constructor(name, rank, schema2, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema2;
    this.spec = spec;
    this.attrs = initAttrs(name, spec.attrs);
    this.excluded = null;
    let defaults2 = defaultAttrs(this.attrs);
    this.instance = defaults2 ? new Mark$2(this, defaults2) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(attrs2 = null) {
    if (!attrs2 && this.instance)
      return this.instance;
    return new Mark$2(this, computeAttrs(this.attrs, attrs2));
  }
  /**
  @internal
  */
  static compile(marks, schema2) {
    let result = /* @__PURE__ */ Object.create(null), rank = 0;
    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema2, spec));
    return result;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(set2) {
    for (var i = 0; i < set2.length; i++)
      if (set2[i].type == this) {
        set2 = set2.slice(0, i).concat(set2.slice(i + 1));
        i--;
      }
    return set2;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(set2) {
    for (let i = 0; i < set2.length; i++)
      if (set2[i].type == this)
        return set2[i];
  }
  /**
  @internal
  */
  checkAttrs(attrs2) {
    checkAttrs(this.attrs, attrs2, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
}
class Schema {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(spec) {
    this.linebreakReplacement = null;
    this.cached = /* @__PURE__ */ Object.create(null);
    let instanceSpec = this.spec = {};
    for (let prop in spec)
      instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = OrderedMap.from(spec.nodes), instanceSpec.marks = OrderedMap.from(spec.marks || {}), this.nodes = NodeType$1.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    let contentExprCache = /* @__PURE__ */ Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark");
      let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      if (type.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!type.isInline || !type.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = type;
      }
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type = this.marks[prop], excl = type.spec.excludes;
      type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(type, attrs2 = null, content, marks) {
    if (typeof type == "string")
      type = this.nodeType(type);
    else if (!(type instanceof NodeType$1))
      throw new RangeError("Invalid node type: " + type);
    else if (type.schema != this)
      throw new RangeError("Node type from different schema used (" + type.name + ")");
    return type.createChecked(attrs2, content, marks);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(text, marks) {
    let type = this.nodes.text;
    return new TextNode(type, type.defaultAttrs, text, Mark$2.setFrom(marks));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(type, attrs2) {
    if (typeof type == "string")
      type = this.marks[type];
    return type.create(attrs2);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(json) {
    return Node$3.fromJSON(this, json);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(json) {
    return Mark$2.fromJSON(this, json);
  }
  /**
  @internal
  */
  nodeType(name) {
    let found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  }
}
function gatherMarks(schema2, marks) {
  let found2 = [];
  for (let i = 0; i < marks.length; i++) {
    let name = marks[i], mark = schema2.marks[name], ok = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop in schema2.marks) {
        let mark2 = schema2.marks[prop];
        if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok = mark2);
      }
    }
    if (!ok)
      throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
  }
  return found2;
}
function isTagRule(rule) {
  return rule.tag != null;
}
function isStyleRule(rule) {
  return rule.style != null;
}
class DOMParser {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(schema2, rules) {
    this.schema = schema2;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    let matchedStyles = this.matchedStyles = [];
    rules.forEach((rule) => {
      if (isTagRule(rule)) {
        this.tags.push(rule);
      } else if (isStyleRule(rule)) {
        let prop = /[^=]*/.exec(rule.style)[0];
        if (matchedStyles.indexOf(prop) < 0)
          matchedStyles.push(prop);
        this.styles.push(rule);
      }
    });
    this.normalizeLists = !this.tags.some((r2) => {
      if (!/^(ul|ol)\b/.test(r2.tag) || !r2.node)
        return false;
      let node = schema2.nodes[r2.node];
      return node.contentMatch.matchType(node);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(dom, options = {}) {
    let context = new ParseContext(this, options, false);
    context.addAll(dom, Mark$2.none, options.from, options.to);
    return context.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(dom, options = {}) {
    let context = new ParseContext(this, options, true);
    context.addAll(dom, Mark$2.none, options.from, options.to);
    return Slice.maxOpen(context.finish());
  }
  /**
  @internal
  */
  matchTag(dom, context, after) {
    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
      let rule = this.tags[i];
      if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result = rule.getAttrs(dom);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(prop, value, context, after) {
    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
      let rule = this.styles[i], style2 = rule.style;
      if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result = rule.getAttrs(value);
        if (result === false)
          continue;
        rule.attrs = result || void 0;
      }
      return rule;
    }
  }
  /**
  @internal
  */
  static schemaRules(schema2) {
    let result = [];
    function insert(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i = 0;
      for (; i < result.length; i++) {
        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority)
          break;
      }
      result.splice(i, 0, rule);
    }
    for (let name in schema2.marks) {
      let rules = schema2.marks[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark))
            rule.mark = name;
        });
    }
    for (let name in schema2.nodes) {
      let rules = schema2.nodes[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark))
            rule.node = name;
        });
    }
    return result;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(schema2) {
    return schema2.cached.domParser || (schema2.cached.domParser = new DOMParser(schema2, DOMParser.schemaRules(schema2)));
  }
}
const blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
const ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
const listTags = { ol: true, ul: true };
const OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base2) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
class NodeContext {
  constructor(type, attrs2, marks, solid, match2, options) {
    this.type = type;
    this.attrs = attrs2;
    this.marks = marks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    this.activeMarks = Mark$2.none;
    this.match = match2 || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  }
  findWrapping(node) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start2 = this.type.contentMatch, wrap2;
        if (wrap2 = start2.findWrapping(node.type)) {
          this.match = start2;
          return wrap2;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let last = this.content[this.content.length - 1], m;
      if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
        let text = last;
        if (last.text.length == m[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
      }
    }
    let content = Fragment.from(this.content);
    if (!openEnd && this.match)
      content = content.append(this.match.fillBefore(Fragment.empty, true));
    return this.type ? this.type.create(this.attrs, content, this.marks) : content;
  }
  inlineContext(node) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
  }
}
class ParseContext {
  constructor(parser, options, isOpen) {
    this.parser = parser;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    this.localPreserveWS = false;
    let topNode = options.topNode, topContext;
    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark$2.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark$2.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark$2.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(dom, marks) {
    if (dom.nodeType == 3)
      this.addTextNode(dom, marks);
    else if (dom.nodeType == 1)
      this.addElement(dom, marks);
  }
  addTextNode(dom, marks) {
    let value = dom.nodeValue;
    let top2 = this.top, preserveWS = top2.options & OPT_PRESERVE_WS_FULL ? "full" : this.localPreserveWS || (top2.options & OPT_PRESERVE_WS) > 0;
    if (preserveWS === "full" || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!preserveWS) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top2.content[top2.content.length - 1];
          let domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (preserveWS !== "full") {
        value = value.replace(/\r?\n|\r/g, " ");
      } else {
        value = value.replace(/\r\n?/g, "\n");
      }
      if (value)
        this.insertNode(this.parser.schema.text(value), marks);
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(dom, marks, matchAfter) {
    let outerWS = this.localPreserveWS, top2 = this.top;
    if (dom.tagName == "PRE" || /pre/.test(dom.style && dom.style.whiteSpace))
      this.localPreserveWS = true;
    let name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList(dom);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
      this.findInside(dom);
      this.ignoreFallback(dom, marks);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent)
        this.open = Math.max(0, this.open - 1);
      else if (rule && rule.skip.nodeType)
        dom = rule.skip;
      let sync, oldNeedsBlock = this.needsBlock;
      if (blockTags.hasOwnProperty(name)) {
        if (top2.content.length && top2.content[0].isInline && this.open) {
          this.open--;
          top2 = this.top;
        }
        sync = true;
        if (!top2.type)
          this.needsBlock = true;
      } else if (!dom.firstChild) {
        this.leafFallback(dom, marks);
        break out;
      }
      let innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);
      if (innerMarks)
        this.addAll(dom, innerMarks);
      if (sync)
        this.sync(top2);
      this.needsBlock = oldNeedsBlock;
    } else {
      let innerMarks = this.readStyles(dom, marks);
      if (innerMarks)
        this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : void 0);
    }
    this.localPreserveWS = outerWS;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(dom, marks) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom.ownerDocument.createTextNode("\n"), marks);
  }
  // Called for ignored nodes
  ignoreFallback(dom, marks) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"), marks);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(dom, marks) {
    let styles2 = dom.style;
    if (styles2 && styles2.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let name = this.parser.matchedStyles[i], value = styles2.getPropertyValue(name);
        if (value)
          for (let after = void 0; ; ) {
            let rule = this.parser.matchStyle(name, value, this, after);
            if (!rule)
              break;
            if (rule.ignore)
              return null;
            if (rule.clearMark)
              marks = marks.filter((m) => !rule.clearMark(m));
            else
              marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));
            if (rule.consuming === false)
              after = rule;
            else
              break;
          }
      }
    return marks;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(dom, rule, marks, continueAfter) {
    let sync, nodeType;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);
        if (inner) {
          sync = true;
          marks = inner;
        }
      } else if (!this.insertNode(nodeType.create(rule.attrs), marks)) {
        this.leafFallback(dom, marks);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      marks = marks.concat(markType.create(rule.attrs));
    }
    let startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, marks, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node, marks));
    } else {
      let contentDOM = dom;
      if (typeof rule.contentElement == "string")
        contentDOM = dom.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM, marks);
      this.findAround(dom, contentDOM, false);
    }
    if (sync && this.sync(startIn))
      this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(parent, marks, startIndex, endIndex) {
    let index2 = startIndex || 0;
    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end2 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end2; dom = dom.nextSibling, ++index2) {
      this.findAtPoint(parent, index2);
      this.addDOM(dom, marks);
    }
    this.findAtPoint(parent, index2);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(node, marks) {
    let route, sync;
    for (let depth = this.open; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node);
      if (found2 && (!route || route.length > found2.length)) {
        route = found2;
        sync = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid)
        break;
    }
    if (!route)
      return null;
    this.sync(sync);
    for (let i = 0; i < route.length; i++)
      marks = this.enterInner(route[i], null, marks, false);
    return marks;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(node, marks) {
    if (node.isInline && this.needsBlock && !this.top.type) {
      let block = this.textblockFromContext();
      if (block)
        marks = this.enterInner(block, null, marks);
    }
    let innerMarks = this.findPlace(node, marks);
    if (innerMarks) {
      this.closeExtra();
      let top2 = this.top;
      if (top2.match)
        top2.match = top2.match.matchType(node.type);
      let nodeMarks = Mark$2.none;
      for (let m of innerMarks.concat(node.marks))
        if (top2.type ? top2.type.allowsMarkType(m.type) : markMayApply(m.type, node.type))
          nodeMarks = m.addToSet(nodeMarks);
      top2.content.push(node.mark(nodeMarks));
      return true;
    }
    return false;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(type, attrs2, marks, preserveWS) {
    let innerMarks = this.findPlace(type.create(attrs2), marks);
    if (innerMarks)
      innerMarks = this.enterInner(type, attrs2, marks, true, preserveWS);
    return innerMarks;
  }
  // Open a node of the given type
  enterInner(type, attrs2, marks, solid = false, preserveWS) {
    this.closeExtra();
    let top2 = this.top;
    top2.match = top2.match && top2.match.matchType(type);
    let options = wsOptionsFor(type, preserveWS, top2.options);
    if (top2.options & OPT_OPEN_LEFT && top2.content.length == 0)
      options |= OPT_OPEN_LEFT;
    let applyMarks = Mark$2.none;
    marks = marks.filter((m) => {
      if (top2.type ? top2.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {
        applyMarks = m.addToSet(applyMarks);
        return false;
      }
      return true;
    });
    this.nodes.push(new NodeContext(type, attrs2, applyMarks, solid, null, options));
    this.open++;
    return marks;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(openEnd = false) {
    let i = this.nodes.length - 1;
    if (i > this.open) {
      for (; i > this.open; i--)
        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(to) {
    for (let i = this.open; i >= 0; i--) {
      if (this.nodes[i] == to) {
        this.open = i;
        return true;
      } else if (this.localPreserveWS) {
        this.nodes[i].options |= OPT_PRESERVE_WS;
      }
    }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i = this.open; i >= 0; i--) {
      let content = this.nodes[i].content;
      for (let j = content.length - 1; j >= 0; j--)
        pos += content[j].nodeSize;
      if (i)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset3) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset3)
          this.find[i].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
          this.find[i].pos = this.currentPos;
      }
  }
  findAround(parent, content, before) {
    if (parent != content && this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          let pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before ? 2 : 4))
            this.find[i].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode)
          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
  }
  // Determines whether the given context string matches this context.
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context.split("/");
    let option = this.options.context;
    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match2 = (i, depth) => {
      for (; i >= 0; i--) {
        let part = parts[i];
        if (part == "") {
          if (i == parts.length - 1 || i == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match2(i - 1, depth))
              return true;
          return false;
        } else {
          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next || next.name != part && !next.isInGroup(part))
            return false;
          depth--;
        }
      }
      return true;
    };
    return match2(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d = $context.depth; d >= 0; d--) {
        let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name in this.parser.schema.nodes) {
      let type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs)
        return type;
    }
  }
}
function normalizeList(dom) {
  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes = nodeType.schema.nodes;
  for (let name in nodes) {
    let parent = nodes[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match2) => {
      seen.push(match2);
      for (let i = 0; i < match2.edgeCount; i++) {
        let { type, next } = match2.edge(i);
        if (type == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
class DOMSerializer {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(nodes, marks) {
    this.nodes = nodes;
    this.marks = marks;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(fragment, options = {}, target) {
    if (!target)
      target = doc$1(options).createDocumentFragment();
    let top2 = target, active = [];
    fragment.forEach((node) => {
      if (active.length || node.marks.length) {
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node.marks.length) {
          let next = node.marks[rendered];
          if (!this.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top2 = active.pop()[1];
        while (rendered < node.marks.length) {
          let add2 = node.marks[rendered++];
          let markDOM = this.serializeMark(add2, node.isInline, options);
          if (markDOM) {
            active.push([add2, top2]);
            top2.appendChild(markDOM.dom);
            top2 = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top2.appendChild(this.serializeNodeInner(node, options));
    });
    return target;
  }
  /**
  @internal
  */
  serializeNodeInner(node, options) {
    let { dom, contentDOM } = renderSpec(doc$1(options), this.nodes[node.type.name](node), null, node.attrs);
    if (contentDOM) {
      if (node.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node.content, options, contentDOM);
    }
    return dom;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(node, options = {}) {
    let dom = this.serializeNodeInner(node, options);
    for (let i = node.marks.length - 1; i >= 0; i--) {
      let wrap2 = this.serializeMark(node.marks[i], node.isInline, options);
      if (wrap2) {
        (wrap2.contentDOM || wrap2.dom).appendChild(dom);
        dom = wrap2.dom;
      }
    }
    return dom;
  }
  /**
  @internal
  */
  serializeMark(mark, inline, options = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && renderSpec(doc$1(options), toDOM(mark, inline), null, mark.attrs);
  }
  static renderSpec(doc2, structure, xmlNS = null, blockArraysIn) {
    return renderSpec(doc2, structure, xmlNS, blockArraysIn);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(schema2) {
    return schema2.cached.domSerializer || (schema2.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema2), this.marksFromSchema(schema2)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(schema2) {
    let result = gatherToDOM(schema2.nodes);
    if (!result.text)
      result.text = (node) => node.text;
    return result;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(schema2) {
    return gatherToDOM(schema2.marks);
  }
}
function gatherToDOM(obj) {
  let result = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
function doc$1(options) {
  return options.document || window.document;
}
const suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();
function suspiciousAttributes(attrs2) {
  let value = suspiciousAttributeCache.get(attrs2);
  if (value === void 0)
    suspiciousAttributeCache.set(attrs2, value = suspiciousAttributesInner(attrs2));
  return value;
}
function suspiciousAttributesInner(attrs2) {
  let result = null;
  function scan(value) {
    if (value && typeof value == "object") {
      if (Array.isArray(value)) {
        if (typeof value[0] == "string") {
          if (!result)
            result = [];
          result.push(value);
        } else {
          for (let i = 0; i < value.length; i++)
            scan(value[i]);
        }
      } else {
        for (let prop in value)
          scan(value[prop]);
      }
    }
  }
  scan(attrs2);
  return result;
}
function renderSpec(doc2, structure, xmlNS, blockArraysIn) {
  if (typeof structure == "string")
    return { dom: doc2.createTextNode(structure) };
  if (structure.nodeType != null)
    return { dom: structure };
  if (structure.dom && structure.dom.nodeType != null)
    return structure;
  let tagName = structure[0], suspicious;
  if (typeof tagName != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let space2 = tagName.indexOf(" ");
  if (space2 > 0) {
    xmlNS = tagName.slice(0, space2);
    tagName = tagName.slice(space2 + 1);
  }
  let contentDOM;
  let dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
  let attrs2 = structure[1], start2 = 1;
  if (attrs2 && typeof attrs2 == "object" && attrs2.nodeType == null && !Array.isArray(attrs2)) {
    start2 = 2;
    for (let name in attrs2)
      if (attrs2[name] != null) {
        let space3 = name.indexOf(" ");
        if (space3 > 0)
          dom.setAttributeNS(name.slice(0, space3), name.slice(space3 + 1), attrs2[name]);
        else
          dom.setAttribute(name, attrs2[name]);
      }
  }
  for (let i = start2; i < structure.length; i++) {
    let child = structure[i];
    if (child === 0) {
      if (i < structure.length - 1 || i > start2)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom, contentDOM: dom };
    } else {
      let { dom: inner, contentDOM: innerContent } = renderSpec(doc2, child, xmlNS, blockArraysIn);
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM)
          throw new RangeError("Multiple content holes");
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
}
const lower16 = 65535;
const factor16 = Math.pow(2, 16);
function makeRecover(index2, offset3) {
  return index2 + offset3 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
const DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;
class MapResult {
  /**
  @internal
  */
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
}
class StepMap {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && StepMap.empty)
      return StepMap.empty;
  }
  /**
  @internal
  */
  recover(value) {
    let diff = 0, index2 = recoverIndex(value);
    if (!this.inverted)
      for (let i = 0; i < index2; i++)
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[index2 * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i] - (this.inverted ? diff : 0);
      if (start2 > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end2 = start2 + oldSize;
      if (pos <= end2) {
        let side = !oldSize ? assoc : pos == start2 ? -1 : pos == end2 ? 1 : assoc;
        let result = start2 + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        let recover = pos == (assoc < 0 ? start2 : end2) ? null : makeRecover(i / 3, pos - start2);
        let del = pos == start2 ? DEL_AFTER : pos == end2 ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start2 : pos != end2)
          del |= DEL_SIDE;
        return new MapResult(result, del, recover);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff, 0, null);
  }
  /**
  @internal
  */
  touches(pos, recover) {
    let diff = 0, index2 = recoverIndex(recover);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i] - (this.inverted ? diff : 0);
      if (start2 > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], end2 = start2 + oldSize;
      if (pos <= end2 && i == index2 * 3)
        return true;
      diff += this.ranges[i + newIndex] - oldSize;
    }
    return false;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(f) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i], oldStart = start2 - (this.inverted ? diff : 0), newStart = start2 + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new StepMap(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(n2) {
    return n2 == 0 ? StepMap.empty : new StepMap(n2 < 0 ? [0, -n2, 0] : [0, 0, n2]);
  }
}
StepMap.empty = new StepMap([]);
class Mapping {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(maps = [], mirror, from2 = 0, to = maps.length) {
    this.maps = maps;
    this.mirror = mirror;
    this.from = from2;
    this.to = to;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(from2 = 0, to = this.maps.length) {
    return new Mapping(this.maps, this.mirror, from2, to);
  }
  /**
  @internal
  */
  copy() {
    return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(map3, mirrors) {
    this.to = this.maps.push(map3);
    if (mirrors != null)
      this.setMirror(this.maps.length - 1, mirrors);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(mapping) {
    for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(n2) {
    if (this.mirror) {
      for (let i = 0; i < this.mirror.length; i++)
        if (this.mirror[i] == n2)
          return this.mirror[i + (i % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(n2, m) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n2, m);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(mapping) {
    for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let inverse = new Mapping();
    inverse.appendMappingInverted(this);
    return inverse;
  }
  /**
  Map a position through this mapping.
  */
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i = this.from; i < this.to; i++)
      pos = this.maps[i].map(pos, assoc);
    return pos;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i = this.from; i < this.to; i++) {
      let map3 = this.maps[i], result = map3.mapResult(pos, assoc);
      if (result.recover != null) {
        let corr = this.getMirror(i);
        if (corr != null && corr > i && corr < this.to) {
          i = corr;
          pos = this.maps[corr].recover(result.recover);
          continue;
        }
      }
      delInfo |= result.delInfo;
      pos = result.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  }
}
const stepsByID = /* @__PURE__ */ Object.create(null);
class Step {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return StepMap.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(other) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(schema2, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type = stepsByID[json.stepType];
    if (!type)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type.fromJSON(schema2, json);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(id2, stepClass) {
    if (id2 in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id2);
    stepsByID[id2] = stepClass;
    stepClass.prototype.jsonID = id2;
    return stepClass;
  }
}
class StepResult {
  /**
  @internal
  */
  constructor(doc2, failed) {
    this.doc = doc2;
    this.failed = failed;
  }
  /**
  Create a successful step result.
  */
  static ok(doc2) {
    return new StepResult(doc2, null);
  }
  /**
  Create a failed step result.
  */
  static fail(message2) {
    return new StepResult(null, message2);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(doc2, from2, to, slice2) {
    try {
      return StepResult.ok(doc2.replace(from2, to, slice2));
    } catch (e2) {
      if (e2 instanceof ReplaceError)
        return StepResult.fail(e2.message);
      throw e2;
    }
  }
}
function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i = 0; i < fragment.childCount; i++) {
    let child = fragment.child(i);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, i);
    mapped.push(child);
  }
  return Fragment.fromArray(mapped);
}
class AddMarkStep extends Step {
  /**
  Create a mark step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice2 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
      if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node;
      return node.mark(this.mark.addToSet(node.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice2);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new AddMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema2, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new AddMarkStep(json.from, json.to, schema2.markFromJSON(json.mark));
  }
}
Step.jsonID("addMark", AddMarkStep);
class RemoveMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to);
    let slice2 = new Slice(mapFragment(oldSlice.content, (node) => {
      return node.mark(this.mark.removeFromSet(node.marks));
    }, doc2), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice2);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new RemoveMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema2, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new RemoveMarkStep(json.from, json.to, schema2.markFromJSON(json.mark));
  }
}
Step.jsonID("removeMark", RemoveMarkStep);
class AddNodeMarkStep extends Step {
  /**
  Create a node mark step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (node) {
      let newSet = this.mark.addToSet(node.marks);
      if (newSet.length == node.marks.length) {
        for (let i = 0; i < node.marks.length; i++)
          if (!node.marks[i].isInSet(newSet))
            return new AddNodeMarkStep(this.pos, node.marks[i]);
        return new AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema2, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new AddNodeMarkStep(json.pos, schema2.markFromJSON(json.mark));
  }
}
Step.jsonID("addNodeMark", AddNodeMarkStep);
class RemoveNodeMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node || !this.mark.isInSet(node.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema2, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new RemoveNodeMarkStep(json.pos, schema2.markFromJSON(json.mark));
  }
}
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
class ReplaceStep extends Step {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(from2, to, slice2, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.slice = slice2;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && contentBetween(doc2, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc2) {
    return new ReplaceStep(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deletedAcross && to.deletedAcross)
      return null;
    return new ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice);
  }
  merge(other) {
    if (!(other instanceof ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep(other.from, this.to, slice2, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema2, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema2, json.slice), !!json.structure);
  }
}
Step.jsonID("replace", ReplaceStep);
class ReplaceAroundStep extends Step {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(from2, to, gapFrom, gapTo, slice2, insert, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice2;
    this.insert = insert;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap = doc2.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc2, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc2) {
    let gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = this.from == this.gapFrom ? from2.pos : mapping.map(this.gapFrom, -1);
    let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);
    if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)
      return null;
    return new ReplaceAroundStep(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema2, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema2, json.slice), json.insert, !!json.structure);
  }
}
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc2, from2, to) {
  let $from = doc2.resolve(from2), dist = to - from2, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function addMark(tr2, from2, to, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr2.doc.nodesBetween(from2, to, (node, pos, parent) => {
    if (!node.isInline)
      return;
    let marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start2 = Math.max(pos, from2), end2 = Math.min(pos + node.nodeSize, to);
      let newSet = mark.addToSet(marks);
      for (let i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start2 && removing.mark.eq(marks[i]))
            removing.to = end2;
          else
            removed.push(removing = new RemoveMarkStep(start2, end2, marks[i]));
        }
      }
      if (adding && adding.to == start2)
        adding.to = end2;
      else
        added.push(adding = new AddMarkStep(start2, end2, mark));
    }
  });
  removed.forEach((s2) => tr2.step(s2));
  added.forEach((s2) => tr2.step(s2));
}
function removeMark(tr2, from2, to, mark) {
  let matched = [], step = 0;
  tr2.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set2 = node.marks, found2;
      while (found2 = mark.isInSet(set2)) {
        (toRemove || (toRemove = [])).push(found2);
        set2 = found2.removeFromSet(set2);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks))
        toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      let end2 = Math.min(pos + node.nodeSize, to);
      for (let i = 0; i < toRemove.length; i++) {
        let style2 = toRemove[i], found2;
        for (let j = 0; j < matched.length; j++) {
          let m = matched[j];
          if (m.step == step - 1 && style2.eq(matched[j].style))
            found2 = m;
        }
        if (found2) {
          found2.to = end2;
          found2.step = step;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from2), to: end2, step });
        }
      }
    }
  });
  matched.forEach((m) => tr2.step(new RemoveMarkStep(m.from, m.to, m.style)));
}
function clearIncompatible(tr2, pos, parentType, match2 = parentType.contentMatch, clearNewlines = true) {
  let node = tr2.doc.nodeAt(pos);
  let replSteps = [], cur = pos + 1;
  for (let i = 0; i < node.childCount; i++) {
    let child = node.child(i), end2 = cur + child.nodeSize;
    let allowed = match2.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end2, Slice.empty));
    } else {
      match2 = allowed;
      for (let j = 0; j < child.marks.length; j++)
        if (!parentType.allowsMarkType(child.marks[j].type))
          tr2.step(new RemoveMarkStep(cur, end2, child.marks[j]));
      if (clearNewlines && child.isText && parentType.whitespace != "pre") {
        let m, newline = /\r?\n|\r/g, slice2;
        while (m = newline.exec(child.text)) {
          if (!slice2)
            slice2 = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));
        }
      }
    }
    cur = end2;
  }
  if (!match2.validEnd) {
    let fill = match2.fillBefore(Fragment.empty, true);
    tr2.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i = replSteps.length - 1; i >= 0; i--)
    tr2.step(replSteps[i]);
}
function canCut(node, start2, end2) {
  return (start2 == 0 || node.canReplace(start2, node.childCount)) && (end2 == node.childCount || node.canReplace(0, end2));
}
function liftTarget(range) {
  let parent = range.parent;
  let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (let depth = range.depth; ; --depth) {
    let node = range.$from.node(depth);
    let index2 = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index2, endIndex, content))
      return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index2, endIndex))
      break;
  }
  return null;
}
function lift$3(tr2, range, target) {
  let { $from, $to, depth } = range;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start2 = gapStart, end2 = gapEnd;
  let before = Fragment.empty, openStart = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = Fragment.from($from.node(d).copy(before));
      openStart++;
    } else {
      start2--;
    }
  let after = Fragment.empty, openEnd = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $to.after(d + 1) < $to.end(d)) {
      splitting = true;
      after = Fragment.from($to.node(d).copy(after));
      openEnd++;
    } else {
      end2++;
    }
  tr2.step(new ReplaceAroundStep(start2, end2, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range, nodeType, attrs2 = null, innerRange = range) {
  let around = findWrappingOutside(range, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs: attrs2 }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around)
    return null;
  let outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let inner = parent.child(startIndex);
  let inside = type.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type;
  let innerMatch = lastType.contentMatch;
  for (let i = startIndex; innerMatch && i < endIndex; i++)
    innerMatch = innerMatch.matchType(parent.child(i).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap(tr2, range, wrappers) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--) {
    if (content.size) {
      let match2 = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match2 || !match2.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }
  let start2 = range.start, end2 = range.end;
  tr2.step(new ReplaceAroundStep(start2, end2, start2, end2, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType$1(tr2, from2, to, type, attrs2) {
  if (!type.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr2.steps.length;
  tr2.doc.nodesBetween(from2, to, (node, pos) => {
    let attrsHere = typeof attrs2 == "function" ? attrs2(node) : attrs2;
    if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr2.doc, tr2.mapping.slice(mapFrom).map(pos), type)) {
      let convertNewlines = null;
      if (type.schema.linebreakReplacement) {
        let pre = type.whitespace == "pre", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);
        if (pre && !supportLinebreak)
          convertNewlines = false;
        else if (!pre && supportLinebreak)
          convertNewlines = true;
      }
      if (convertNewlines === false)
        replaceLinebreaks(tr2, node, pos, mapFrom);
      clearIncompatible(tr2, tr2.mapping.slice(mapFrom).map(pos, 1), type, void 0, convertNewlines === null);
      let mapping = tr2.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      tr2.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));
      if (convertNewlines === true)
        replaceNewlines(tr2, node, pos, mapFrom);
      return false;
    }
  });
}
function replaceNewlines(tr2, node, pos, mapFrom) {
  node.forEach((child, offset3) => {
    if (child.isText) {
      let m, newline = /\r?\n|\r/g;
      while (m = newline.exec(child.text)) {
        let start2 = tr2.mapping.slice(mapFrom).map(pos + 1 + offset3 + m.index);
        tr2.replaceWith(start2, start2 + 1, node.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function replaceLinebreaks(tr2, node, pos, mapFrom) {
  node.forEach((child, offset3) => {
    if (child.type == child.type.schema.linebreakReplacement) {
      let start2 = tr2.mapping.slice(mapFrom).map(pos + 1 + offset3);
      tr2.replaceWith(start2, start2 + 1, node.type.schema.text("\n"));
    }
  });
}
function canChangeType(doc2, pos, type) {
  let $pos = doc2.resolve(pos), index2 = $pos.index();
  return $pos.parent.canReplaceWith(index2, index2 + 1, type);
}
function setNodeMarkup(tr2, pos, type, attrs2, marks) {
  let node = tr2.doc.nodeAt(pos);
  if (!node)
    throw new RangeError("No node at given position");
  if (!type)
    type = node.type;
  let newNode = type.create(attrs2, null, marks || node.marks);
  if (node.isLeaf)
    return tr2.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type.validContent(node.content))
    throw new RangeError("Invalid content for node type " + type.name);
  tr2.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
}
function canSplit(doc2, pos, depth = 1, typesAfter) {
  let $pos = doc2.resolve(pos), base2 = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {
    let node = $pos.node(d), index3 = $pos.index(d);
    if (node.type.spec.isolating)
      return false;
    let rest = node.content.cutByIndex(index3, node.childCount);
    let overrideChild = typesAfter && typesAfter[i + 1];
    if (overrideChild)
      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    let after = typesAfter && typesAfter[i] || node;
    if (!node.canReplace(index3 + 1, node.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index2 = $pos.indexAfter(base2);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index2, index2, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
function split(tr2, pos, depth = 1, typesAfter) {
  let $pos = tr2.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
  for (let d = $pos.depth, e2 = $pos.depth - depth, i = depth - 1; d > e2; d--, i--) {
    before = Fragment.from($pos.node(d).copy(before));
    let typeAfter = typesAfter && typesAfter[i];
    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  tr2.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc2, pos) {
  let $pos = doc2.resolve(pos), index2 = $pos.index();
  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index2, index2 + 1);
}
function canAppendWithSubstitutedLinebreaks(a2, b) {
  if (!b.content.size)
    a2.type.compatibleContent(b.type);
  let match2 = a2.contentMatchAt(a2.childCount);
  let { linebreakReplacement } = a2.type.schema;
  for (let i = 0; i < b.childCount; i++) {
    let child = b.child(i);
    let type = child.type == linebreakReplacement ? a2.type.schema.nodes.text : child.type;
    match2 = match2.matchType(type);
    if (!match2)
      return false;
    if (!a2.type.allowsMarks(child.marks))
      return false;
  }
  return match2.validEnd;
}
function joinable(a2, b) {
  return !!(a2 && b && !a2.isLeaf && canAppendWithSubstitutedLinebreaks(a2, b));
}
function joinPoint(doc2, pos, dir = -1) {
  let $pos = doc2.resolve(pos);
  for (let d = $pos.depth; ; d--) {
    let before, after, index2 = $pos.index(d);
    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index2++;
      after = $pos.node(d).maybeChild(index2);
    } else {
      before = $pos.node(d).maybeChild(index2 - 1);
      after = $pos.node(d + 1);
    }
    if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index2, index2 + 1))
      return pos;
    if (d == 0)
      break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}
function join(tr2, pos, depth) {
  let convertNewlines = null;
  let { linebreakReplacement } = tr2.doc.type.schema;
  let $before = tr2.doc.resolve(pos - depth), beforeType = $before.node().type;
  if (linebreakReplacement && beforeType.inlineContent) {
    let pre = beforeType.whitespace == "pre";
    let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
    if (pre && !supportLinebreak)
      convertNewlines = false;
    else if (!pre && supportLinebreak)
      convertNewlines = true;
  }
  let mapFrom = tr2.steps.length;
  if (convertNewlines === false) {
    let $after = tr2.doc.resolve(pos + depth);
    replaceLinebreaks(tr2, $after.node(), $after.before(), mapFrom);
  }
  if (beforeType.inlineContent)
    clearIncompatible(tr2, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
  let mapping = tr2.mapping.slice(mapFrom), start2 = mapping.map(pos - depth);
  tr2.step(new ReplaceStep(start2, mapping.map(pos + depth, -1), Slice.empty, true));
  if (convertNewlines === true) {
    let $full = tr2.doc.resolve(start2);
    replaceNewlines(tr2, $full.node(), $full.before(), tr2.steps.length);
  }
  return tr2;
}
function insertPoint(doc2, pos, nodeType) {
  let $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index2 = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index2, index2, nodeType))
        return $pos.before(d + 1);
      if (index2 > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index2 = $pos.indexAfter(d);
      if ($pos.node(d).canReplaceWith(index2, index2, nodeType))
        return $pos.after(d + 1);
      if (index2 < $pos.node(d).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc2, pos, slice2) {
  let $pos = doc2.resolve(pos);
  if (!slice2.content.size)
    return pos;
  let content = slice2.content;
  for (let i = 0; i < slice2.openStart; i++)
    content = content.firstChild.content;
  for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
    for (let d = $pos.depth; d >= 0; d--) {
      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return null;
}
function replaceStep(doc2, from2, to = from2, slice2 = Slice.empty) {
  if (from2 == to && !slice2.size)
    return null;
  let $from = doc2.resolve(from2), $to = doc2.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return new ReplaceStep(from2, to, slice2);
  return new Fitter($from, $to, slice2).fit();
}
function fitsTrivially($from, $to, slice2) {
  return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
}
class Fitter {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment.empty;
    for (let i = 0; i <= $from.depth; i++) {
      let node = $from.node(i);
      this.frontier.push({
        type: node.type,
        match: node.contentMatchAt($from.indexAfter(i))
      });
    }
    for (let i = $from.depth; i > 0; i--)
      this.placed = Fragment.from($from.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit = this.findFittable();
      if (fit)
        this.placeNodes(fit);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content.childCount == 1) {
      content = content.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice2 = new Slice(content, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
    if (slice2.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice2);
    return null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let startDepth = this.unplaced.openStart;
    for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
      let node = cur.firstChild;
      if (cur.childCount > 1)
        openEnd = 0;
      if (node.type.spec.isolating && openEnd <= d) {
        startDepth = d;
        break;
      }
      cur = node.content;
    }
    for (let pass = 1; pass <= 2; pass++) {
      for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        let fragment, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        let first2 = fragment.firstChild;
        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          let { type, match: match2 } = this.frontier[frontierDepth], wrap2, inject = null;
          if (pass == 1 && (first2 ? match2.matchType(first2.type) || (inject = match2.fillBefore(Fragment.from(first2), false)) : parent && type.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject };
          else if (pass == 2 && first2 && (wrap2 = match2.findWrapping(first2.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
          if (parent && match2.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      let openAtEnd = content.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
    }
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap2)
      for (let i = 0; i < wrap2.length; i++)
        this.openFrontierNode(wrap2[i]);
    let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;
    let openStart = slice2.openStart - sliceDepth;
    let taken = 0, add2 = [];
    let { match: match2, type } = this.frontier[frontierDepth];
    if (inject) {
      for (let i = 0; i < inject.childCount; i++)
        add2.push(inject.child(i));
      match2 = match2.matchFragment(inject);
    }
    let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
    while (taken < fragment.childCount) {
      let next = fragment.child(taken), matches2 = match2.matchType(next.type);
      if (!matches2)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match2 = matches2;
        add2.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add2));
    this.frontier[frontierDepth].match = match2;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i = 0, cur = fragment; i < openEndCount; i++) {
      let node = cur.lastChild;
      this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
      cur = node.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top2 = this.frontier[this.depth], level;
    if (!top2.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after = this.$to.after(depth);
    while (depth > 1 && after == this.$to.end(--depth))
      ++after;
    return after;
  }
  findCloseLevel($to) {
    scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
      let { match: match2, type } = this.frontier[i];
      let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
      let fit = contentAfterFits($to, i, type, match2, dropInner);
      if (!fit)
        continue;
      for (let d = i - 1; d >= 0; d--) {
        let { match: match3, type: type2 } = this.frontier[d];
        let matches2 = contentAfterFits($to, d, type2, match3, true);
        if (!matches2 || matches2.childCount)
          continue scan;
      }
      return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
    }
  }
  close($to) {
    let close2 = this.findCloseLevel($to);
    if (!close2)
      return null;
    while (this.depth > close2.depth)
      this.closeFrontierNode();
    if (close2.fit.childCount)
      this.placed = addToFragment(this.placed, close2.depth, close2.fit);
    $to = close2.move;
    for (let d = close2.depth + 1; d <= $to.depth; d++) {
      let node = $to.node(d), add2 = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
      this.openFrontierNode(node.type, node.attrs, add2);
    }
    return $to;
  }
  openFrontierNode(type, attrs2 = null, content) {
    let top2 = this.frontier[this.depth];
    top2.match = top2.match.matchType(type);
    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs2, content)));
    this.frontier.push({ type, match: type.contentMatch });
  }
  closeFrontierNode() {
    let open = this.frontier.pop();
    let add2 = open.match.fillBefore(Fragment.empty, true);
    if (add2.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add2);
  }
}
function dropFromFragment(fragment, depth, count) {
  if (depth == 0)
    return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0)
    return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (let i = 0; i < depth; i++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0)
    return node;
  let frag = node.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
  }
  return node.copy(frag);
}
function contentAfterFits($to, depth, type, match2, open) {
  let node = $to.node(depth), index2 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index2 == node.childCount && !type.compatibleContent(node.type))
    return null;
  let fit = match2.fillBefore(node.content, true, index2);
  return fit && !invalidMarks(type, node.content, index2) ? fit : null;
}
function invalidMarks(type, fragment, start2) {
  for (let i = start2; i < fragment.childCount; i++)
    if (!type.allowsMarks(fragment.child(i).marks))
      return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function replaceRange(tr2, from2, to, slice2) {
  if (!slice2.size)
    return tr2.deleteRange(from2, to);
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return tr2.step(new ReplaceStep(from2, to, slice2));
  let targetDepths = coveredDepths($from, tr2.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    let spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d) > -1)
      preferredTarget = d;
    else if ($from.before(d) == pos)
      targetDepths.splice(1, 0, -d);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice2.openStart;
  for (let content = slice2.content, i = 0; ; i++) {
    let node = content.firstChild;
    leftNodes.push(node);
    if (i == slice2.openStart)
      break;
    content = node.content;
  }
  for (let d = preferredDepth - 1; d >= 0; d--) {
    let leftNode = leftNodes[d], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = d;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (let j = slice2.openStart; j >= 0; j--) {
    let openDepth = (j + preferredDepth + 1) % (slice2.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (let i = 0; i < targetDepths.length; i++) {
      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand3 = true;
      if (targetDepth < 0) {
        expand3 = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index2 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index2, index2, insert.type, insert.marks))
        return tr2.replace($from.before(targetDepth), expand3 ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
    }
  }
  let startSteps = tr2.steps.length;
  for (let i = targetDepths.length - 1; i >= 0; i--) {
    tr2.replace(from2, to, slice2);
    if (tr2.steps.length > startSteps)
      break;
    let depth = targetDepths[i];
    if (depth < 0)
      continue;
    from2 = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    let match2 = parent.contentMatchAt(0);
    let start2 = match2.fillBefore(fragment).append(fragment);
    fragment = start2.append(match2.matchFragment(start2).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr2, from2, to, node) {
  if (!node.isInline && from2 == to && tr2.doc.resolve(from2).parent.content.size) {
    let point = insertPoint(tr2.doc, from2, node.type);
    if (point != null)
      from2 = to = point;
  }
  tr2.replaceRange(from2, to, new Slice(Fragment.from(node), 0, 0));
}
function deleteRange$2(tr2, from2, to) {
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i = 0; i < covered.length; i++) {
    let depth = covered[i], last = i == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr2.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr2.delete($from.before(depth), $to.after(depth));
  }
  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from2 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1)))
      return tr2.delete($from.before(d), to);
  }
  tr2.delete(from2, to);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d = minDepth; d >= 0; d--) {
    let start2 = $from.start(d);
    if (start2 < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
      break;
    if (start2 == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start2 - 1)
      result.push(d);
  }
  return result;
}
class AttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(pos, attr, value) {
    super();
    this.pos = pos;
    this.attr = attr;
    this.value = value;
  }
  apply(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at attribute step's position");
    let attrs2 = /* @__PURE__ */ Object.create(null);
    for (let name in node.attrs)
      attrs2[name] = node.attrs[name];
    attrs2[this.attr] = this.value;
    let updated = node.type.create(attrs2, null, node.marks);
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc2) {
    return new AttrStep(this.pos, this.attr, doc2.nodeAt(this.pos).attrs[this.attr]);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(schema2, json) {
    if (typeof json.pos != "number" || typeof json.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new AttrStep(json.pos, json.attr, json.value);
  }
}
Step.jsonID("attr", AttrStep);
class DocAttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(attr, value) {
    super();
    this.attr = attr;
    this.value = value;
  }
  apply(doc2) {
    let attrs2 = /* @__PURE__ */ Object.create(null);
    for (let name in doc2.attrs)
      attrs2[name] = doc2.attrs[name];
    attrs2[this.attr] = this.value;
    let updated = doc2.type.create(attrs2, doc2.content, doc2.marks);
    return StepResult.ok(updated);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc2) {
    return new DocAttrStep(this.attr, doc2.attrs[this.attr]);
  }
  map(mapping) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(schema2, json) {
    if (typeof json.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new DocAttrStep(json.attr, json.value);
  }
}
Step.jsonID("docAttr", DocAttrStep);
let TransformError = class extends Error {
};
TransformError = function TransformError2(message2) {
  let err = Error.call(this, message2);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
class Transform {
  /**
  Create a transform that starts with the given document.
  */
  constructor(doc2) {
    this.doc = doc2;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(step) {
    let result = this.maybeStep(step);
    if (result.failed)
      throw new TransformError(result.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(step) {
    let result = step.apply(this.doc);
    if (!result.failed)
      this.addStep(step, result.doc);
    return result;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(step, doc2) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc2;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(from2, to = from2, slice2 = Slice.empty) {
    let step = replaceStep(this.doc, from2, to, slice2);
    if (step)
      this.step(step);
    return this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(from2, to, content) {
    return this.replace(from2, to, new Slice(Fragment.from(content), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(from2, to) {
    return this.replace(from2, to, Slice.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(pos, content) {
    return this.replaceWith(pos, pos, content);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(from2, to, slice2) {
    replaceRange(this, from2, to, slice2);
    return this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(from2, to, node) {
    replaceRangeWith(this, from2, to, node);
    return this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(from2, to) {
    deleteRange$2(this, from2, to);
    return this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(range, target) {
    lift$3(this, range, target);
    return this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(pos, depth = 1) {
    join(this, pos, depth);
    return this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(range, wrappers) {
    wrap(this, range, wrappers);
    return this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(from2, to = from2, type, attrs2 = null) {
    setBlockType$1(this, from2, to, type, attrs2);
    return this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(pos, type, attrs2 = null, marks) {
    setNodeMarkup(this, pos, type, attrs2, marks);
    return this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(pos, attr, value) {
    this.step(new AttrStep(pos, attr, value));
    return this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(attr, value) {
    this.step(new DocAttrStep(attr, value));
    return this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(pos, mark) {
    this.step(new AddNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(pos, mark) {
    if (!(mark instanceof Mark$2)) {
      let node = this.doc.nodeAt(pos);
      if (!node)
        throw new RangeError("No node at position " + pos);
      mark = mark.isInSet(node.marks);
      if (!mark)
        return this;
    }
    this.step(new RemoveNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(pos, depth = 1, typesAfter) {
    split(this, pos, depth, typesAfter);
    return this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(from2, to, mark) {
    addMark(this, from2, to, mark);
    return this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(from2, to, mark) {
    removeMark(this, from2, to, mark);
    return this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(pos, parentType, match2) {
    clearIncompatible(this, pos, parentType, match2);
    return this;
  }
}
const classesById = /* @__PURE__ */ Object.create(null);
class Selection {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++)
      if (ranges[i].$from.pos != ranges[i].$to.pos)
        return false;
    return true;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(tr2, content = Slice.empty) {
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i = 0; i < content.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
      tr2.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
      if (i == 0)
        selectionToInsertionEnd$2(tr2, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(tr2, node) {
    let mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
      let from2 = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr2.deleteRange(from2, to);
      } else {
        tr2.replaceRangeWith(from2, to, node);
        selectionToInsertionEnd$2(tr2, mapFrom, node.isInline ? -1 : 1);
      }
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(doc2) {
    return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(doc2) {
    return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(doc2, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls2 = classesById[json.type];
    if (!cls2)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls2.fromJSON(doc2, json);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(id2, selectionClass) {
    if (id2 in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id2);
    classesById[id2] = selectionClass;
    selectionClass.prototype.jsonID = id2;
    return selectionClass;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
}
Selection.prototype.visible = true;
class SelectionRange {
  /**
  Create a range.
  */
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
}
let warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
class TextSelection extends Selection {
  /**
  Construct a text selection between the given points.
  */
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc2, mapping) {
    let $head = doc2.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc2.resolve(mapping.map(this.anchor));
    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr2, content = Slice.empty) {
    super.replace(tr2, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr2.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new TextSelection(doc2.resolve(json.anchor), doc2.resolve(json.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(doc2, anchor, head = anchor) {
    let $anchor = doc2.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new TextSelection($anchor, $head);
  }
}
Selection.jsonID("text", TextSelection);
class TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc2) {
    return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
  }
}
class NodeSelection extends Selection {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor($pos) {
    let node = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    super($pos, $end);
    this.node = node;
  }
  map(doc2, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc2.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new NodeSelection(doc2.resolve(json.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(doc2, from2) {
    return new NodeSelection(doc2.resolve(from2));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(node) {
    return !node.isText && node.type.spec.selectable !== false;
  }
}
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
class NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
  }
  resolve(doc2) {
    let $pos = doc2.resolve(this.anchor), node = $pos.nodeAfter;
    if (node && NodeSelection.isSelectable(node))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
}
class AllSelection extends Selection {
  /**
  Create an all-selection over the given document.
  */
  constructor(doc2) {
    super(doc2.resolve(0), doc2.resolve(doc2.content.size));
  }
  replace(tr2, content = Slice.empty) {
    if (content == Slice.empty) {
      tr2.delete(0, tr2.doc.content.size);
      let sel = Selection.atStart(tr2.doc);
      if (!sel.eq(tr2.selection))
        tr2.setSelection(sel);
    } else {
      super.replace(tr2, content);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(doc2) {
    return new AllSelection(doc2);
  }
  map(doc2) {
    return new AllSelection(doc2);
  }
  eq(other) {
    return other instanceof AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
}
Selection.jsonID("all", AllSelection);
const AllBookmark = {
  map() {
    return this;
  },
  resolve(doc2) {
    return new AllSelection(doc2);
  }
};
function findSelectionIn(doc2, node, pos, index2, dir, text = false) {
  if (node.inlineContent)
    return TextSelection.create(doc2, pos);
  for (let i = index2 - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    let child = node.child(i);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc2, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner)
        return inner;
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc2, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd$2(tr2, startLen, bias) {
  let last = tr2.steps.length - 1;
  if (last < startLen)
    return;
  let step = tr2.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map3 = tr2.mapping.maps[last], end2;
  map3.forEach((_from, _to, _newFrom, newTo) => {
    if (end2 == null)
      end2 = newTo;
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end2), bias));
}
const UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
class Transaction extends Transform {
  /**
  @internal
  */
  constructor(state) {
    super(state.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.storedMarks = state.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(marks) {
    if (!Mark$2.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  /**
  @internal
  */
  addStep(step, doc2) {
    super.addStep(step, doc2);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(time) {
    this.time = time;
    return this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(slice2) {
    this.selection.replace(this, slice2);
    return this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(node, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark$2.none));
    selection.replaceWith(this, node);
    return this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(text, from2, to) {
    let schema2 = this.doc.type.schema;
    if (from2 == null) {
      if (!text)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema2.text(text), true);
    } else {
      if (to == null)
        to = from2;
      to = to == null ? from2 : to;
      if (!text)
        return this.deleteRange(from2, to);
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from2);
        marks = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from2, to, schema2.text(text, marks));
      if (!this.selection.empty)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let _ in this.meta)
      return false;
    return true;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
}
function bind(f, self2) {
  return !self2 || !f ? f : f.bind(self2);
}
class FieldDesc {
  constructor(name, desc, self2) {
    this.name = name;
    this.init = bind(desc.init, self2);
    this.apply = bind(desc.apply, self2);
  }
}
const baseFields = [
  new FieldDesc("doc", {
    init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply(tr2) {
      return tr2.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config, instance) {
      return config.selection || Selection.atStart(instance.doc);
    },
    apply(tr2) {
      return tr2.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config) {
      return config.storedMarks || null;
    },
    apply(tr2, _marks, _old, state) {
      return state.selection.$cursor ? tr2.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr2, prev) {
      return tr2.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
class Configuration {
  constructor(schema2, plugins) {
    this.schema = schema2;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    this.fields = baseFields.slice();
    if (plugins)
      plugins.forEach((plugin) => {
        if (this.pluginsByKey[plugin.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        this.plugins.push(plugin);
        this.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state)
          this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
      });
  }
}
class EditorState {
  /**
  @internal
  */
  constructor(config) {
    this.config = config;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(tr2) {
    return this.applyTransaction(tr2).state;
  }
  /**
  @internal
  */
  filterTransaction(tr2, ignore = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != ignore) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr2, this))
          return false;
      }
    return true;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      let haveNew = false;
      for (let i = 0; i < this.config.plugins.length; i++) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.appendTransaction) {
          let n2 = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
          let tr2 = n2 < trs.length && plugin.spec.appendTransaction.call(plugin, n2 ? trs.slice(n2) : trs, oldState, newState);
          if (tr2 && newState.filterTransaction(tr2, i)) {
            tr2.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j = 0; j < this.config.plugins.length; j++)
                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr2);
            newState = newState.applyInner(tr2);
            haveNew = true;
          }
          if (seen)
            seen[i] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  /**
  @internal
  */
  applyInner(tr2) {
    if (!tr2.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new EditorState(this.config), fields = this.config.fields;
    for (let i = 0; i < fields.length; i++) {
      let field = fields[i];
      newInstance[field.name] = field.apply(tr2, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Transaction(this);
  }
  /**
  Create a new state.
  */
  static create(config) {
    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    let instance = new EditorState($config);
    for (let i = 0; i < $config.fields.length; i++)
      instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
    return instance;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(config) {
    let $config = new Configuration(this.schema, config.plugins);
    let fields = $config.fields, instance = new EditorState($config);
    for (let i = 0; i < fields.length; i++) {
      let name = fields[i].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
    }
    return instance;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(pluginFields) {
    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result.storedMarks = this.storedMarks.map((m) => m.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin = pluginFields[prop], state = plugin.spec.state;
        if (state && state.toJSON)
          result[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    return result;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(config, json, pluginFields) {
    if (!json)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration(config.schema, config.plugins);
    let instance = new EditorState($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance.doc = Node$3.fromJSON(config.schema, json.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection.fromJSON(instance.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks)
          instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop in pluginFields) {
            let plugin = pluginFields[prop], state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
              return;
            }
          }
        instance[field.name] = field.init(config, instance);
      }
    });
    return instance;
  }
}
function bindProps(obj, self2, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self2);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self2, {});
    target[prop] = val;
  }
  return target;
}
class Plugin {
  /**
  Create a plugin.
  */
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
}
const keys = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
class PluginKey {
  /**
  Create a plugin key.
  */
  constructor(name = "key") {
    this.key = createKey(name);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(state) {
    return state.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
}
const domIndex = function(node) {
  for (var index2 = 0; ; index2++) {
    node = node.previousSibling;
    if (!node)
      return index2;
  }
};
const parentNode = function(node) {
  let parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
let reusedRange = null;
const textRange = function(node, from2, to) {
  let range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from2 || 0);
  return range;
};
const clearReusedRange = function() {
  reusedRange = null;
};
const isEquivalentPosition = function(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
};
const atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.contentEditable == "false")
        return false;
      off = dir < 0 ? nodeSize(node) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function textNodeBefore$1(node, offset3) {
  for (; ; ) {
    if (node.nodeType == 3 && offset3)
      return node;
    if (node.nodeType == 1 && offset3 > 0) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset3 - 1];
      offset3 = nodeSize(node);
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset3 = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter$1(node, offset3) {
  for (; ; ) {
    if (node.nodeType == 3 && offset3 < node.nodeValue.length)
      return node;
    if (node.nodeType == 1 && offset3 < node.childNodes.length) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset3];
      offset3 = 0;
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset3 = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function isOnEdge(node, offset3, parent) {
  for (let atStart = offset3 == 0, atEnd = offset3 == nodeSize(node); atStart || atEnd; ) {
    if (node == parent)
      return true;
    let index2 = domIndex(node);
    node = node.parentNode;
    if (!node)
      return false;
    atStart = atStart && index2 == 0;
    atEnd = atEnd && index2 == nodeSize(node);
  }
}
function hasBlockDesc(dom) {
  let desc;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
const selectionCollapsed = function(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function deepActiveElement(doc2) {
  let elt = doc2.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc2, x, y) {
  if (doc2.caretPositionFromPoint) {
    try {
      let pos = doc2.caretPositionFromPoint(x, y);
      if (pos)
        return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };
    } catch (_) {
    }
  }
  if (doc2.caretRangeFromPoint) {
    let range = doc2.caretRangeFromPoint(x, y);
    if (range)
      return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };
  }
}
const nav = typeof navigator != "undefined" ? navigator : null;
const doc = typeof document != "undefined" ? document : null;
const agent = nav && nav.userAgent || "";
const ie_edge = /Edge\/(\d+)/.exec(agent);
const ie_upto10 = /MSIE \d/.exec(agent);
const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
const ie$1 = !!(ie_upto10 || ie_11up || ie_edge);
const ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
const gecko = !ie$1 && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
const _chrome = !ie$1 && /Chrome\/(\d+)/.exec(agent);
const chrome = !!_chrome;
const chrome_version = _chrome ? +_chrome[1] : 0;
const safari = !ie$1 && !!nav && /Apple Computer/.test(nav.vendor);
const ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
const mac$2 = ios || (nav ? /Mac/.test(nav.platform) : false);
const windows = nav ? /Win/.test(nav.platform) : false;
const android = /Android \d/.test(agent);
const webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style;
const webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc2) {
  let vp = doc2.defaultView && doc2.defaultView.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: doc2.documentElement.clientWidth,
    top: 0,
    bottom: doc2.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
  let rect = node.getBoundingClientRect();
  let scaleX = rect.width / node.offsetWidth || 1;
  let scaleY = rect.height / node.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc2 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom; ; parent = parentNode(parent)) {
    if (!parent)
      break;
    if (parent.nodeType != 1)
      continue;
    let elt = parent;
    let atTop = elt == doc2.body;
    let bounding = atTop ? windowRect(doc2) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc2.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    if (atTop || /^(fixed|sticky)$/.test(getComputedStyle(parent).position))
      break;
  }
}
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    let dom = view.root.elementFromPoint(x, y);
    if (!dom || dom == view.dom || !view.dom.contains(dom))
      continue;
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  let stack = [], doc2 = dom.ownerDocument;
  for (let cur = dom; cur; cur = parentNode(cur)) {
    stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc2)
      break;
  }
  return stack;
}
function resetScrollPos({ refDOM, refTop, stack }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (let i = 0; i < stack.length; i++) {
    let { dom, top: top2, left: left2 } = stack[i];
    if (dom.scrollTop != top2 + dTop)
      dom.scrollTop = top2 + dTop;
    if (dom.scrollLeft != left2)
      dom.scrollLeft = left2;
  }
}
let preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node, coords) {
  let closest2, dxClosest = 2e8, coordsClosest, offset3 = 0;
  let rowBot = coords.top, rowTop = coords.top;
  let firstBelow, coordsBelow;
  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest2 = child;
          dxClosest = dx;
          coordsClosest = dx && closest2.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset3 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
      }
      if (!closest2 && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset3 = childIndex + 1;
    }
  }
  if (!closest2 && firstBelow) {
    closest2 = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest2 && closest2.nodeType == 3)
    return findOffsetInText(closest2, coordsClosest);
  if (!closest2 || dxClosest && closest2.nodeType == 1)
    return { node, offset: offset3 };
  return findOffsetInNode(closest2, coordsClosest);
}
function findOffsetInText(node, coords) {
  let len = node.nodeValue.length;
  let range = document.createRange();
  for (let i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    let rect = singleRect(range, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect))
      return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
  }
  return { node, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  let { node, offset: offset3 } = findOffsetInNode(elt, coords), bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    let rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset3, bias);
}
function posFromCaret(view, node, offset3, coords) {
  let outsideBlock = -1;
  for (let cur = node, sawBlock = false; ; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true), rect;
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {
      if (desc.node.isBlock && desc.parent) {
        if (!sawBlock && rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
        sawBlock = true;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset3, -1);
}
function elementFromPoint(element, coords, box) {
  let len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
      let child = element.childNodes[i];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j = 0; j < rects.length; j++) {
          let rect = rects[j];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((i = (i + 1) % len) == startI)
        break;
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  let doc2 = view.dom.ownerDocument, node, offset3 = 0;
  let caret = caretFromPoint(doc2, coords.left, coords.top);
  if (caret)
    ({ node, offset: offset3 } = caret);
  let elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari) {
    for (let p2 = elt; node && p2; p2 = parentNode(p2))
      if (p2.draggable)
        node = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (gecko && node.nodeType == 1) {
      offset3 = Math.min(offset3, node.childNodes.length);
      if (offset3 < node.childNodes.length) {
        let next = node.childNodes[offset3], box;
        if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset3++;
      }
    }
    let prev;
    if (webkit && offset3 && node.nodeType == 1 && (prev = node.childNodes[offset3 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
      offset3--;
    if (node == view.dom && offset3 == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset3 == 0 || node.nodeType != 1 || node.childNodes[offset3 - 1].nodeName != "BR")
      pos = posFromCaret(view, node, offset3, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  let rects = target.getClientRects();
  if (rects.length) {
    let first2 = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first2))
      return first2;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
const BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  let { node, offset: offset3, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko;
  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset3 : offset3 == node.nodeValue.length))) {
      let rect = singleRect(textRange(node, offset3, offset3), side);
      if (gecko && offset3 && /\s/.test(node.nodeValue[offset3 - 1]) && offset3 < node.nodeValue.length) {
        let rectBefore = singleRect(textRange(node, offset3 - 1, offset3 - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect(textRange(node, offset3, offset3 + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from2 = offset3, to = offset3, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset3) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset3 == node.nodeValue.length) {
        from2--;
        takeSide = 1;
      } else if (side < 0) {
        from2--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node, from2, to), takeSide), takeSide < 0);
    }
  }
  let $dom = view.state.doc.resolve(pos - (atom || 0));
  if (!$dom.parent.inlineContent) {
    if (atom == null && offset3 && (side < 0 || offset3 == nodeSize(node))) {
      let before = node.childNodes[offset3 - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom == null && offset3 < nodeSize(node)) {
      let after = node.childNodes[offset3];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node.getBoundingClientRect(), side >= 0);
  }
  if (atom == null && offset3 && (side < 0 || offset3 == nodeSize(node))) {
    let before = node.childNodes[offset3 - 1];
    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom == null && offset3 < nodeSize(node)) {
    let after = node.childNodes[offset3];
    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
      after = after.nextSibling;
    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
    if (target)
      return flattenV(singleRect(target, -1), true);
  }
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect, left2) {
  if (rect.width == 0)
    return rect;
  let x = left2 ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top2) {
  if (rect.height == 0)
    return rect;
  let y = top2 ? rect.top : rect.bottom;
  return { top: y, bottom: y, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state)
    view.updateState(state);
  if (active != view.dom)
    view.focus();
  try {
    return f();
  } finally {
    if (viewState != state)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state, dir) {
  let sel = state.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, () => {
    let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom.firstChild; child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i = 0; i < boxes.length; i++) {
        let box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
const maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  let { $head } = state.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset3 = $head.parentOffset, atStart = !offset3, atEnd = offset3 == $head.parent.content.size;
  let sel = view.domSelection();
  if (!sel)
    return $head.pos == $head.start() || $head.pos == $head.end();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, () => {
    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_) {
    }
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
let cachedState = null;
let cachedDir = null;
let cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir)
    return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
const NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;
class ViewDesc {
  constructor(parent, children, dom, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(widget) {
    return false;
  }
  matchesMark(mark) {
    return false;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(event) {
    return false;
  }
  // The size of the content represented by this desc.
  get size() {
    let size2 = 0;
    for (let i = 0; i < this.children.length; i++)
      size2 += this.children[i].size;
    return size2;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (let i = 0; i < this.children.length; i++)
      this.children[i].destroy();
  }
  posBeforeChild(child) {
    for (let i = 0, pos = this.posAtStart; ; i++) {
      let cur = this.children[i];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom, offset3, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset3 - 1];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset3];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd;
    if (dom == this.dom && this.contentDOM) {
      atEnd = offset3 > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset3 == 0)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = false;
            break;
          }
          if (search.previousSibling)
            break;
        }
      if (atEnd == null && offset3 == dom.childNodes.length)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = true;
            break;
          }
          if (search.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom, onlyNodes = false) {
    for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
          first2 = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom) {
    let desc = dom.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom, offset3, bias) {
    for (let scan = dom; scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom, offset3, bias);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(pos) {
    for (let i = 0, offset3 = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset3 + child.size;
      if (offset3 == pos && end2 != offset3) {
        while (!child.border && child.children.length)
          child = child.children[0];
        return child;
      }
      if (pos < end2)
        return child.descAt(pos - offset3 - child.border);
      offset3 = end2;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    let i = 0, offset3 = 0;
    for (let curPos = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = curPos + child.size;
      if (end2 > pos || child instanceof TrailingHackViewDesc) {
        offset3 = pos - curPos;
        break;
      }
      curPos = end2;
    }
    if (offset3)
      return this.children[i].domFromPos(offset3 - this.children[i].border, side);
    for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
    }
    if (side <= 0) {
      let prev, enter2 = true;
      for (; ; i--, enter2 = false) {
        prev = i ? this.children[i - 1] : null;
        if (!prev || prev.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev && side && enter2 && !prev.border && !prev.domAtom)
        return prev.domFromPos(prev.size, side);
      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
    } else {
      let next, enter2 = true;
      for (; ; i++, enter2 = false) {
        next = i < this.children.length ? this.children[i] : null;
        if (!next || next.dom.parentNode == this.contentDOM)
          break;
      }
      if (next && enter2 && !next.border && !next.domAtom)
        return next.domFromPos(0, side);
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(from2, to, base2 = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset3 = base2, i = 0; ; i++) {
      let child = this.children[i], end2 = offset3 + child.size;
      if (fromOffset == -1 && from2 <= end2) {
        let childBase = offset3 + child.border;
        if (from2 >= childBase && to <= end2 - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from2, to, childBase);
        from2 = offset3;
        for (let j = i; j > 0; j--) {
          let prev = this.children[j - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from2 -= prev.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end2 > to || i == this.children.length - 1)) {
        to = end2;
        for (let j = i + 1; j < this.children.length; j++) {
          let next = this.children[j];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to += next.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset3 = end2;
    }
    return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node, offset: offset3 } = this.domFromPos(pos, 0);
    if (node.nodeType != 1 || offset3 == node.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node.childNodes[offset3];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(anchor, head, view, force = false) {
    let from2 = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i = 0, offset3 = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset3 + child.size;
      if (from2 > offset3 && to < end2)
        return child.setSelection(anchor - offset3 - child.border, head - offset3 - child.border, view, force);
      offset3 = end2;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = view.root.getSelection();
    let selRange = view.domSelectionRange();
    let brKludge = false;
    if ((gecko || safari) && anchor == head) {
      let { node, offset: offset3 } = anchorDOM;
      if (node.nodeType == 3) {
        brKludge = !!(offset3 && node.nodeValue[offset3 - 1] == "\n");
        if (brKludge && offset3 == node.nodeValue.length) {
          for (let scan = node, after; scan; scan = scan.parentNode) {
            if (after = scan.nextSibling) {
              if (after.nodeName == "BR")
                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev = node.childNodes[offset3 - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {
      let after = selRange.focusNode.childNodes[selRange.focusOffset];
      if (after && after.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !brKludge) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (_) {
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range = document.createRange();
      range.setEnd(headDOM.node, headDOM.offset);
      range.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(from2, to) {
    for (let offset3 = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset3 + child.size;
      if (offset3 == end2 ? from2 <= end2 && to >= offset3 : from2 < end2 && to > offset3) {
        let startInside = offset3 + child.border, endInside = end2 - child.border;
        if (from2 >= startInside && to <= endInside) {
          this.dirty = from2 == offset3 || to == end2 ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from2 - startInside, to - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset3 = end2;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let level = 1;
    for (let node = this.parent; node; node = node.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node.dirty < dirty)
        node.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
  isText(text) {
    return false;
  }
}
class WidgetViewDesc extends ViewDesc {
  constructor(parent, widget, view, pos) {
    let self2, dom = widget.type.toDOM;
    if (typeof dom == "function")
      dom = dom(view, () => {
        if (!self2)
          return pos;
        if (self2.parent)
          return self2.parent.posBeforeChild(self2);
      });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        let wrap2 = document.createElement("span");
        wrap2.appendChild(dom);
        dom = wrap2;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom, null);
    this.widget = widget;
    this.widget = widget;
    self2 = this;
  }
  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get side() {
    return this.widget.type.side;
  }
}
class CompositionViewDesc extends ViewDesc {
  constructor(parent, dom, textDOM, text) {
    super(parent, [], dom, null);
    this.textDOM = textDOM;
    this.text = text;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom, offset3) {
    if (dom != this.textDOM)
      return this.posAtStart + (offset3 ? this.size : 0);
    return this.posAtStart + offset3;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
}
class MarkViewDesc extends ViewDesc {
  constructor(parent, mark, dom, contentDOM, spec) {
    super(parent, [], dom, contentDOM);
    this.mark = mark;
    this.spec = spec;
  }
  static create(parent, mark, inline, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);
    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }
  slice(from2, to, view) {
    let copy2 = MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes = this.children, size2 = this.size;
    if (to < size2)
      nodes = replaceNodes(nodes, to, size2, view);
    if (from2 > 0)
      nodes = replaceNodes(nodes, 0, from2, view);
    for (let i = 0; i < nodes.length; i++)
      nodes[i].parent = copy2;
    copy2.children = nodes;
    return copy2;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
}
class NodeViewDesc extends ViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    super(parent, [], dom, contentDOM);
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(parent, node, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node.type.name], descObj;
    let spec = custom && custom(node, view, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom)
        dom = document.createTextNode(node.text);
      else if (dom.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom) {
      let spec2 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);
      ({ dom, contentDOM } = spec2);
    }
    if (!contentDOM && !node.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable"))
        dom.contentEditable = "false";
      if (node.type.spec.draggable)
        dom.draggable = true;
    }
    let nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node.isText)
      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
    else
      return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i = this.children.length - 1; i >= 0; i--) {
        let child = this.children[i];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => Fragment.empty;
    }
    return rule;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(view, pos) {
    let inline = this.node.inlineContent, off = pos;
    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline, view);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i == this.node.childCount ? Mark$2.none : this.node.child(i).marks, inline, view);
      updater.placeWidget(widget, view, off);
    }, (child, outerDeco, innerDeco, i) => {
      updater.syncToMarks(child.marks, inline, view);
      let compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;
      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off);
      }
      off += child.nodeSize;
    });
    updater.syncToMarks([], inline, view);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  }
  localCompositionInfo(view, pos) {
    let { from: from2, to } = view.state.selection;
    if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size)
      return null;
    let textNode = view.input.compositionNode;
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text, from2 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view, { node, pos, text }) {
    if (this.getDesc(node))
      return;
    let topNode = node;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    let desc = new CompositionViewDesc(this, topNode, node, text);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
      return false;
    this.updateInner(node, outerDeco, innerDeco, view);
    return true;
  }
  updateInner(node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  // Mark this node as being the selected node.
  selectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.draggable = true;
  }
  // Remove selected node marking from this node.
  deselectNode() {
    if (this.nodeDOM.nodeType == 1) {
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.dom.removeAttribute("draggable");
    }
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function docViewDesc(doc2, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc2);
  let docView = new NodeViewDesc(void 0, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM)
    docView.updateChildren(view, 0);
  return docView;
}
class TextViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n2 = this.nodeDOM; n2; n2 = n2.parentNode)
      if (n2 == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom, offset3, bias) {
    if (dom == this.nodeDOM)
      return this.posAtStart + Math.min(offset3, this.node.text.length);
    return super.localPosFromDOM(dom, offset3, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from2, to, view) {
    let node = this.node.cut(from2, to), dom = document.createTextNode(node.text);
    return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  }
  get domAtom() {
    return false;
  }
  isText(text) {
    return this.node.text == text;
  }
}
class TrailingHackViewDesc extends ViewDesc {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class CustomNodeViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {
      let result = this.spec.update(node, outerDeco, innerDeco);
      if (result)
        this.updateInner(node, outerDeco, innerDeco, view);
      return result;
    } else if (!this.contentDOM && !node.isLeaf) {
      return false;
    } else {
      return super.update(node, outerDeco, innerDeco, view);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, view, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
}
function renderDescs(parentDOM, descs, view) {
  let dom = parentDOM.firstChild, written = false;
  for (let i = 0; i < descs.length; i++) {
    let desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
const OuterDecoLevel = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
const noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top2];
  for (let i = 0; i < outerDeco.length; i++) {
    let attrs2 = outerDeco[i].type.attrs;
    if (!attrs2)
      continue;
    if (attrs2.nodeName)
      result.push(top2 = new OuterDecoLevel(attrs2.nodeName));
    for (let name in attrs2) {
      let val = attrs2[name];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top2 = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class")
        top2.class = (top2.class ? top2.class + " " : "") + val;
      else if (name == "style")
        top2.style = (top2.style ? top2.style + ";" : "") + val;
      else if (name != "nodeName")
        top2[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i = 0; i < curComputed.length; i++) {
    let deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (let name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
      dom.setAttribute(name, cur[name]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < prevList.length; i++)
      if (curList.indexOf(prevList[i]) == -1)
        dom.classList.remove(prevList[i]);
    for (let i = 0; i < curList.length; i++)
      if (prevList.indexOf(curList[i]) == -1)
        dom.classList.add(curList[i]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        dom.style.removeProperty(m[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}
function sameOuterDeco(a2, b) {
  if (a2.length != b.length)
    return false;
  for (let i = 0; i < a2.length; i++)
    if (!a2[i].type.eq(b[i].type))
      return false;
  return true;
}
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
class ViewTreeUpdater {
  constructor(top2, lock, view) {
    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top2;
    this.preMatch = preMatch(top2.node.content, top2);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(start2, end2) {
    if (start2 == end2)
      return;
    for (let i = start2; i < end2; i++)
      this.top.children[i].destroy();
    this.top.children.splice(start2, end2 - start2);
    this.changed = true;
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(marks, inline, view) {
    let keep = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
      keep++;
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found2 = -1;
      for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
        let next = this.top.children[i];
        if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
          found2 = i;
          break;
        }
      }
      if (found2 > -1) {
        if (found2 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found2);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(node, outerDeco, innerDeco, index2) {
    let found2 = -1, targetDesc;
    if (index2 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index2 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
      found2 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i = this.index, e2 = Math.min(this.top.children.length, i + 5); i < e2; i++) {
        let child = this.top.children[i];
        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found2 = i;
          break;
        }
      }
    }
    if (found2 < 0)
      return false;
    this.destroyBetween(this.index, found2);
    this.index++;
    return true;
  }
  updateNodeAt(node, outerDeco, innerDeco, index2, view) {
    let child = this.top.children[index2];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index2);
    this.index++;
    return true;
  }
  findIndexWithChild(domNode) {
    for (; ; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc)
              return i;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(node, outerDeco, innerDeco, view, index2, pos) {
    for (let i = this.index; i < this.top.children.length; i++) {
      let next = this.top.children[i];
      if (next instanceof NodeViewDesc) {
        let preMatch2 = this.preMatch.matched.get(next);
        if (preMatch2 != null && preMatch2 != index2)
          return false;
        let nextDOM = next.dom, updated;
        let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i);
          if (next.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
          this.destroyBetween(this.index, i);
          this.top.children[this.index] = updated;
          if (updated.contentDOM) {
            updated.dirty = CONTENT_DIRTY;
            updated.updateChildren(view, pos + 1);
            updated.dirty = NOT_DIRTY;
          }
          this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
    if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))
      return null;
    let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (wrapper.contentDOM) {
      wrapper.children = next.children;
      next.children = [];
      for (let ch of wrapper.children)
        ch.parent = wrapper;
    }
    next.destroy();
    return wrapper;
  }
  // Insert the node as a newly created node desc.
  addNode(node, outerDeco, innerDeco, view, pos) {
    let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (desc.contentDOM)
      desc.updateChildren(view, pos + 1);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
  placeWidget(widget, view, pos) {
    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let lastChild = this.top.children[this.index - 1], parent = this.top;
    while (lastChild instanceof MarkViewDesc) {
      parent = lastChild;
      lastChild = parent.children[parent.children.length - 1];
    }
    if (!lastChild || // Empty textblock
    !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
      if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR")
        dom.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
  isLocked(node) {
    return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
  }
}
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
  outer: while (fI > 0) {
    let desc;
    for (; ; ) {
      if (descI) {
        let next = curDesc.children[descI - 1];
        if (next instanceof MarkViewDesc) {
          curDesc = next;
          descI = next.children.length;
        } else {
          desc = next;
          descI--;
          break;
        }
      } else if (curDesc == parentDesc) {
        break outer;
      } else {
        descI = curDesc.parent.children.indexOf(curDesc);
        curDesc = curDesc.parent;
      }
    }
    let node = desc.node;
    if (!node)
      continue;
    if (node != frag.child(fI - 1))
      break;
    --fI;
    matched.set(desc, fI);
    matches2.push(desc);
  }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide(a2, b) {
  return a2.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset3 = 0;
  if (locals.length == 0) {
    for (let i = 0; i < parent.childCount; i++) {
      let child = parent.child(i);
      onNode(child, locals, deco.forChild(offset3, child), i);
      offset3 += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    let widget, widgets;
    while (decoIndex < locals.length && locals[decoIndex].to == offset3) {
      let next = locals[decoIndex++];
      if (next.widget) {
        if (!widget)
          widget = next;
        else
          (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (let i = 0; i < widgets.length; i++)
          onWidget(widgets[i], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index2;
    if (restNode) {
      index2 = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index2 = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i = 0; i < active.length; i++)
      if (active[i].to <= offset3)
        active.splice(i--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset3 && locals[decoIndex].to > offset3)
      active.push(locals[decoIndex++]);
    let end2 = offset3 + child.nodeSize;
    if (child.isText) {
      let cutAt = end2;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i = 0; i < active.length; i++)
        if (active[i].to < cutAt)
          cutAt = active[i].to;
      if (cutAt < end2) {
        restNode = child.cut(cutAt - offset3);
        child = child.cut(0, cutAt - offset3);
        end2 = cutAt;
        index2 = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to < end2)
        decoIndex++;
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
    onNode(child, outerDeco, deco.forChild(offset3, child), index2);
    offset3 = end2;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function findTextInFragment(frag, text, from2, to) {
  for (let i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
    let child = frag.child(i++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str = child.text;
    while (i < frag.childCount) {
      let next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str += next.text;
    }
    if (pos >= from2) {
      if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text)
        return to - text.length;
      let found2 = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text.length + childStart >= from2)
        return childStart + found2;
      if (from2 == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes, from2, to, view, replacement) {
  let result = [];
  for (let i = 0, off = 0; i < nodes.length; i++) {
    let child = nodes[i], start2 = off, end2 = off += child.size;
    if (start2 >= to || end2 <= from2) {
      result.push(child);
    } else {
      if (start2 < from2)
        result.push(child.slice(0, from2 - start2, view));
      if (replacement) {
        result.push(replacement);
        replacement = void 0;
      }
      if (end2 > to)
        result.push(child.slice(to - start2, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin2 = null) {
  let domSel = view.domSelectionRange(), doc2 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc2.resolve(head), anchor, selection;
  if (selectionCollapsed(domSel)) {
    anchor = head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc2.resolve(pos));
    }
  } else {
    if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
      let min2 = head, max2 = head;
      for (let i = 0; i < domSel.rangeCount; i++) {
        let range = domSel.getRangeAt(i);
        min2 = Math.min(min2, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));
        max2 = Math.max(max2, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));
      }
      if (min2 < 0)
        return null;
      [anchor, head] = max2 == view.state.selection.anchor ? [max2, min2] : [min2, max2];
      $head = doc2.resolve(head);
    } else {
      anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    }
    if (anchor < 0)
      return null;
  }
  let $anchor = doc2.resolve(anchor);
  if (!selection) {
    let bias = origin2 == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
const brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node, offset: offset3 } = view.docView.domFromPos(pos, 0);
  let after = offset3 < node.childNodes.length ? node.childNodes[offset3] : null;
  let before = offset3 ? node.childNodes[offset3 - 1] : null;
  if (safari && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc2 = view.dom.ownerDocument;
  doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let node = domSel.anchorNode, offset3 = domSel.anchorOffset;
  doc2.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset3) {
      doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection(), range = document.createRange();
  if (!domSel)
    return;
  let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img)
    range.setStart(node.parentNode, domIndex(node) + 1);
  else
    range.setStart(node, 0);
  range.collapse(true);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!img && !view.state.selection.visible && ie$1 && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (mods.indexOf("s") > -1) {
      let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node || node.isText || !node.isLeaf)
        return false;
      let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
      return apply(view, new TextSelection(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
      return false;
    } else if (!(mac$2 && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply(view, next);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom, dir) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset3 = sel.focusOffset;
  if (!node)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node.nodeType == 1 && offset3 < nodeLen(node) && isIgnorable(node.childNodes[offset3], -1))
    force = true;
  for (; ; ) {
    if (offset3 > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        let before = node.childNodes[offset3 - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node;
          moveOffset = --offset3;
        } else if (before.nodeType == 3) {
          node = before;
          offset3 = node.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      let prev = node.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset3 = 0;
      } else {
        node = prev;
        offset3 = nodeLen(node);
      }
    }
  }
  if (force)
    setSelFocus(view, node, offset3);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset3 = sel.focusOffset;
  if (!node)
    return;
  let len = nodeLen(node);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset3 < len) {
      if (node.nodeType != 1)
        break;
      let after = node.childNodes[offset3];
      if (isIgnorable(after, 1)) {
        moveNode = node;
        moveOffset = ++offset3;
      } else
        break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      let next = node.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset3 = len = 0;
      } else {
        node = next;
        offset3 = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node, offset3) {
  while (node && offset3 == node.childNodes.length && !hasBlockDesc(node)) {
    offset3 = domIndex(node) + 1;
    node = node.parentNode;
  }
  while (node && offset3 < node.childNodes.length) {
    let next = node.childNodes[offset3];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset3 = 0;
  }
}
function textNodeBefore(node, offset3) {
  while (node && !offset3 && !hasBlockDesc(node)) {
    offset3 = domIndex(node);
    node = node.parentNode;
  }
  while (node && offset3) {
    let next = node.childNodes[offset3 - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset3 = node.childNodes.length;
  }
}
function setSelFocus(view, node, offset3) {
  if (node.nodeType != 3) {
    let before, after;
    if (after = textNodeAfter(node, offset3)) {
      node = after;
      offset3 = 0;
    } else if (before = textNodeBefore(node, offset3)) {
      node = before;
      offset3 = before.nodeValue.length;
    }
  }
  let sel = view.domSelection();
  if (!sel)
    return;
  if (selectionCollapsed(sel)) {
    let range = document.createRange();
    range.setEnd(node, offset3);
    range.setStart(node, offset3);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset3);
  }
  view.domObserver.setCurSelection();
  let { state } = view;
  setTimeout(() => {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  let $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows) && $pos.parent.inlineContent) {
    let coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      let before = view.coordsAtPos(pos - 1);
      let mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
        return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      let after = view.coordsAtPos(pos + 1);
      let mid = (after.top + after.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
        return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  let computed = getComputedStyle(view.dom).direction;
  return computed == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac$2 && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty: empty2 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty2)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr2 = view.state.tr;
    if (dir < 0)
      tr2.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr2.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr2);
    return true;
  }
  return false;
}
function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code2 = event.keyCode, mods = getMods(event);
  if (code2 == 8 || mac$2 && code2 == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code2 == 46 && !event.shiftKey || mac$2 && code2 == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code2 == 13 || code2 == 27) {
    return true;
  } else if (code2 == 37 || mac$2 && code2 == 66 && mods == "c") {
    let dir = code2 == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code2 == 39 || mac$2 && code2 == 70 && mods == "c") {
    let dir = code2 == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code2 == 38 || mac$2 && code2 == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code2 == 40 || mac$2 && code2 == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac$2 ? "m" : "c") && (code2 == 66 || code2 == 73 || code2 == 89 || code2 == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice2) {
  view.someProp("transformCopied", (f) => {
    slice2 = f(slice2, view);
  });
  let context = [], { content, openStart, openEnd } = slice2;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc2 = detachedDoc(), wrap2 = doc2.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content, { document: doc2 }));
  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1; i >= 0; i--) {
      let wrapper = doc2.createElement(needsWrap[i]);
      while (wrap2.firstChild)
        wrapper.appendChild(wrap2.firstChild);
      wrap2.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
  return { dom: wrap2, text, slice: slice2 };
}
function parseFromClipboard(view, text, html, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice2;
  if (!html && !text)
    return null;
  let asText = text && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", (f) => {
      text = f(text, inCode || plainText, view);
    });
    if (inCode)
      return text ? new Slice(Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
    let parsed = view.someProp("clipboardTextParser", (f) => f(text, $context, plainText, view));
    if (parsed) {
      slice2 = parsed;
    } else {
      let marks = $context.marks();
      let { schema: schema2 } = view.state, serializer = DOMSerializer.fromSchema(schema2);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p2 = dom.appendChild(document.createElement("p"));
        if (block)
          p2.appendChild(serializer.serializeNode(schema2.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f) => {
      html = f(html, view);
    });
    dom = readHTML(html);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i = +sliceData[3]; i > 0; i--) {
      let child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice2) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
    slice2 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
    if (slice2.openStart || slice2.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
      }
      for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
      }
      slice2 = closeSlice(slice2, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f) => {
    slice2 = f(slice2, view);
  });
  return slice2;
}
const inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d = $context.depth; d >= 0; d--) {
    let parent = $context.node(d);
    let match2 = parent.contentMatchAt($context.index(d));
    let lastWrap, result = [];
    fragment.forEach((node) => {
      if (!result)
        return;
      let wrap2 = match2.findWrapping(node.type), inLast;
      if (!wrap2)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node, wrap2);
        result.push(wrapped);
        match2 = match2.matchType(wrapped.type);
        lastWrap = wrap2;
      }
    });
    if (result)
      return Fragment.from(result);
  }
  return fragment;
}
function withWrappers(node, wrap2, from2 = 0) {
  for (let i = wrap2.length - 1; i >= from2; i--)
    node = wrap2[i].create(null, Fragment.from(node));
  return node;
}
function addToSibling(wrap2, lastWrap, node, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match2 = sibling.contentMatchAt(sibling.childCount);
    if (match2.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0)
    return node;
  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
  return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from2, to, depth, openEnd) {
  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to - 1)
    inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
  if (depth >= from2)
    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice2, openStart, openEnd) {
  if (openStart < slice2.openStart)
    slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
  if (openEnd < slice2.openEnd)
    slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
  return slice2;
}
const wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
let _policy = null;
function maybeWrapTrusted(html) {
  let trustedTypes = window.trustedTypes;
  if (!trustedTypes)
    return html;
  if (!_policy)
    _policy = trustedTypes.createPolicy("ProseMirrorClipboard", { createHTML: (s2) => s2 });
  return _policy.createHTML(html);
}
function readHTML(html) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas)
    html = html.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html = wrap2.map((n2) => "<" + n2 + ">").join("") + html + wrap2.map((n2) => "</" + n2 + ">").reverse().join("");
  elt.innerHTML = maybeWrapTrusted(html);
  if (wrap2)
    for (let i = 0; i < wrap2.length; i++)
      elt = elt.querySelector(wrap2[i]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i = 0; i < nodes.length; i++) {
    let node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == "" && node.parentNode)
      node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice2, context) {
  if (!slice2.size)
    return slice2;
  let schema2 = slice2.content.firstChild.type.schema, array2;
  try {
    array2 = JSON.parse(context);
  } catch (e2) {
    return slice2;
  }
  let { content, openStart, openEnd } = slice2;
  for (let i = array2.length - 2; i >= 0; i -= 2) {
    let type = schema2.nodes[array2[i]];
    if (!type || type.hasRequiredAttrs())
      break;
    content = Fragment.from(type.create(array2[i + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
const handlers = {};
const editHandlers = {};
const passiveHandlers = { touchstart: true, touchmove: true };
class InputState {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "" };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastChromeDelete = 0;
    this.composing = false;
    this.compositionNode = null;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.compositionID = 1;
    this.compositionPendingChanges = 0;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */ Object.create(null);
    this.hideSelectionGuard = null;
  }
}
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  }
  if (safari)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin2) {
  view.input.lastSelectionOrigin = origin2;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target; node != view.dom; node = node.parentNode)
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now2 = Date.now();
    view.input.lastIOSEnter = now2;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now2) {
        view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
  let event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac$2 && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f) => f(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text = String.fromCharCode(event.charCode);
    if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text)))
      view.dispatch(view.state.tr.insertText(text).scrollIntoView());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin2) {
  if (!view.focused)
    view.focus();
  if (view.state.selection.eq(selection))
    return;
  let tr2 = view.state.tr.setSelection(selection);
  tr2.setMeta("pointer", true);
  view.dispatch(tr2);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && NodeSelection.isSelectable(node)) {
    updateSelection(view, new NodeSelection($pos));
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt));
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc2 = view.state.doc;
  if (inside == -1) {
    if (doc2.inlineContent) {
      updateSelection(view, TextSelection.create(doc2, 0, doc2.content.size));
      return true;
    }
    return false;
  }
  let $pos = doc2.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    let nodePos = $pos.before(i);
    if (node.inlineContent)
      updateSelection(view, TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node.content.size));
    else if (NodeSelection.isSelectable(node))
      updateSelection(view, NodeSelection.create(doc2, nodePos));
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
const selectNodeModifier = mac$2 ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now2 = Date.now(), type = "singleClick";
  if (now2 - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
    if (view.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view.input.lastClick = { time: now2, x: event.clientX, y: event.clientY, type };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
class MouseDown {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc && targetDesc.dom.nodeType == 1 ? targetDesc.dom : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)));
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
  updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  }
}
handlers.touchstart = (view) => {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = (view) => {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
const timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state } = view, $pos = state.selection.$to;
    if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view, !state.selection.empty);
      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelectionRange();
        for (let node = sel.focusNode, offset3 = sel.focusOffset; node && node.nodeType == 1 && offset3 != 0; ) {
          let before = offset3 < 0 ? node.lastChild : node.childNodes[offset3 - 1];
          if (!before)
            break;
          if (before.nodeType == 3) {
            let sel2 = view.domSelection();
            if (sel2)
              sel2.collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            offset3 = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
    view.input.compositionNode = null;
    if (view.input.compositionPendingChanges)
      Promise.resolve().then(() => view.domObserver.flush());
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function findCompositionNode(view) {
  let sel = view.domSelectionRange();
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
  if (textBefore && textAfter && textBefore != textAfter) {
    let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
    if (textBefore == lastChanged || textAfter == lastChanged)
      return lastChanged;
    if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
      return textAfter;
    } else if (view.input.compositionNode == textAfter) {
      let descBefore = textBefore.pmViewDesc;
      if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
        return textAfter;
    }
  }
  return textBefore || textAfter;
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, restarting = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (restarting || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection))
      view.dispatch(view.state.tr.setSelection(sel));
    else if ((view.markCursor || restarting) && !view.state.selection.empty)
      view.dispatch(view.state.tr.deleteSelection());
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(() => {
    if (wrap2.parentNode)
      wrap2.parentNode.removeChild(wrap2);
    view.focus();
  }, 50);
}
const brokenClipboardAPI = ie$1 && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event) => {
  let event = _event;
  let sel = view.state.selection, cut2 = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let slice2 = sel.content(), { dom, text } = serializeForClipboard(view, slice2);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }
  if (cut2)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice2) {
  return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text, html, preferPlain, event) {
  let slice2 = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
    return true;
  if (!slice2)
    return false;
  let singleNode = sliceSingleNode(slice2);
  let tr2 = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
  view.dispatch(tr2.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText$1(clipboardData) {
  let text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text)
    return text;
  let uris = clipboardData.getData("text/uri-list");
  return uris ? uris.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = (view, _event) => {
  let event = _event;
  if (view.composing && !android)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  if (data && doPaste(view, getText$1(data), data.getData("text/html"), plain, event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
class Dragging {
  constructor(slice2, move2, node) {
    this.slice = slice2;
    this.move = move2;
    this.node = node;
  }
}
const dragCopyModifier = mac$2 ? "altKey" : "ctrlKey";
handlers.dragstart = (view, _event) => {
  let event = _event;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  let node;
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;
  else if (mouseDown && mouseDown.mightDrag) {
    node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      node = NodeSelection.create(view.state.doc, desc.posBefore);
  }
  let draggedSlice = (node || view.state.selection).content();
  let { dom, text, slice: slice2 } = serializeForClipboard(view, draggedSlice);
  if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)
    event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text);
  view.dragging = new Dragging(slice2, !event[dragCopyModifier], node);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_, e2) => e2.preventDefault();
editHandlers.drop = (view, _event) => {
  let event = _event;
  let dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  let slice2 = dragging && dragging.slice;
  if (slice2) {
    view.someProp("transformPasted", (f) => {
      slice2 = f(slice2, view);
    });
  } else {
    slice2 = parseFromClipboard(view, getText$1(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move2 = !!(dragging && !event[dragCopyModifier]);
  if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move2))) {
    event.preventDefault();
    return;
  }
  if (!slice2)
    return;
  event.preventDefault();
  let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr2 = view.state.tr;
  if (move2) {
    let { node } = dragging;
    if (node)
      node.replace(tr2);
    else
      tr2.deleteSelection();
  }
  let pos = tr2.mapping.map(insertPos);
  let isNode = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
  let beforeInsert = tr2.doc;
  if (isNode)
    tr2.replaceRangeWith(pos, pos, slice2.content.firstChild);
  else
    tr2.replaceRange(pos, pos, slice2);
  if (tr2.doc.eq(beforeInsert))
    return;
  let $pos = tr2.doc.resolve(pos);
  if (isNode && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
    tr2.setSelection(new NodeSelection($pos));
  } else {
    let end2 = tr2.mapping.map(insertPos);
    tr2.mapping.maps[tr2.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end2 = newTo);
    tr2.setSelection(selectionBetween(view, $pos, tr2.doc.resolve(end2)));
  }
  view.focus();
  view.dispatch(tr2.setMeta("uiEvent", "drop"));
};
handlers.focus = (view) => {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event) => {
  let event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event) => {
  let event = _event;
  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a2, b) {
  if (a2 == b)
    return true;
  for (let p2 in a2)
    if (a2[p2] !== b[p2])
      return false;
  for (let p2 in b)
    if (!(p2 in a2))
      return false;
  return true;
}
class WidgetType {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset3, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset3, pos - offset3, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node) {
    if (this.spec.destroy)
      this.spec.destroy(node);
  }
}
class InlineType {
  constructor(attrs2, spec) {
    this.attrs = attrs2;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset3, oldOffset) {
    let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset3;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset3;
    return from2 >= to ? null : new Decoration(from2, to, this);
  }
  valid(_, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof InlineType;
  }
  destroy() {
  }
}
class NodeType2 {
  constructor(attrs2, spec) {
    this.attrs = attrs2;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset3, oldOffset) {
    let from2 = mapping.mapResult(span.from + oldOffset, 1);
    if (from2.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from2.pos)
      return null;
    return new Decoration(from2.pos - offset3, to.pos - offset3, this);
  }
  valid(node, span) {
    let { index: index2, offset: offset3 } = node.content.findIndex(span.from), child;
    return offset3 == span.from && !(child = node.child(index2)).isText && offset3 + child.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof NodeType2 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {
  }
}
class Decoration {
  /**
  @internal
  */
  constructor(from2, to, type) {
    this.from = from2;
    this.to = to;
    this.type = type;
  }
  /**
  @internal
  */
  copy(from2, to) {
    return new Decoration(from2, to, this.type);
  }
  /**
  @internal
  */
  eq(other, offset3 = 0) {
    return this.type.eq(other.type) && this.from + offset3 == other.from && this.to + offset3 == other.to;
  }
  /**
  @internal
  */
  map(mapping, offset3, oldOffset) {
    return this.type.map(mapping, this, offset3, oldOffset);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(pos, toDOM, spec) {
    return new Decoration(pos, pos, new WidgetType(toDOM, spec));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(from2, to, attrs2, spec) {
    return new Decoration(from2, to, new InlineType(attrs2, spec));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(from2, to, attrs2, spec) {
    return new Decoration(from2, to, new NodeType2(attrs2, spec));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof InlineType;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof WidgetType;
  }
}
const none = [], noSpec = {};
class DecorationSet {
  /**
  @internal
  */
  constructor(local, children) {
    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(doc2, decorations) {
    return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(start2, end2, predicate) {
    let result = [];
    this.findInner(start2 == null ? 0 : start2, end2 == null ? 1e9 : end2, result, 0, predicate);
    return result;
  }
  findInner(start2, end2, result, offset3, predicate) {
    for (let i = 0; i < this.local.length; i++) {
      let span = this.local[i];
      if (span.from <= end2 && span.to >= start2 && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset3, span.to + offset3));
    }
    for (let i = 0; i < this.children.length; i += 3) {
      if (this.children[i] < end2 && this.children[i + 1] > start2) {
        let childOff = this.children[i] + 1;
        this.children[i + 2].findInner(start2 - childOff, end2 - childOff, result, offset3 + childOff, predicate);
      }
    }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(mapping, doc2, options) {
    if (this == empty || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
  }
  /**
  @internal
  */
  mapInner(mapping, node, offset3, oldOffset, options) {
    let newLocal;
    for (let i = 0; i < this.local.length; i++) {
      let mapped = this.local[i].map(mapping, offset3, oldOffset);
      if (mapped && mapped.type.valid(node, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options.onRemove)
        options.onRemove(this.local[i].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node, offset3, oldOffset, options);
    else
      return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(doc2, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty)
      return DecorationSet.create(doc2, decorations);
    return this.addInner(doc2, decorations, 0);
  }
  addInner(doc2, decorations, offset3) {
    let children, childIndex = 0;
    doc2.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset3, found2;
      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children)
        children = this.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset)
        childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset3);
    for (let i = 0; i < local.length; i++)
      if (!local[i].type.valid(doc2, local[i]))
        local.splice(i--, 1);
    return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(decorations) {
    if (decorations.length == 0 || this == empty)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset3) {
    let children = this.children, local = this.local;
    for (let i = 0; i < children.length; i += 3) {
      let found2;
      let from2 = children[i] + offset3, to = children[i + 1] + offset3;
      for (let j = 0, span; j < decorations.length; j++)
        if (span = decorations[j]) {
          if (span.from > from2 && span.to < to) {
            decorations[j] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
      if (!found2)
        continue;
      if (children == this.children)
        children = this.children.slice();
      let removed = children[i + 2].removeInner(found2, from2 + 1);
      if (removed != empty) {
        children[i + 2] = removed;
      } else {
        children.splice(i, 3);
        i -= 3;
      }
    }
    if (local.length) {
      for (let i = 0, span; i < decorations.length; i++)
        if (span = decorations[i]) {
          for (let j = 0; j < local.length; j++)
            if (local[j].eq(span, offset3)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j--, 1);
            }
        }
    }
    if (children == this.children && local == this.local)
      return this;
    return local.length || children.length ? new DecorationSet(local, children) : empty;
  }
  forChild(offset3, node) {
    if (this == empty)
      return this;
    if (node.isLeaf)
      return DecorationSet.empty;
    let child, local;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] >= offset3) {
        if (this.children[i] == offset3)
          child = this.children[i + 2];
        break;
      }
    let start2 = offset3 + 1, end2 = start2 + node.content.size;
    for (let i = 0; i < this.local.length; i++) {
      let dec = this.local[i];
      if (dec.from < end2 && dec.to > start2 && dec.type instanceof InlineType) {
        let from2 = Math.max(start2, dec.from) - start2, to = Math.min(end2, dec.to) - start2;
        if (from2 < to)
          (local || (local = [])).push(dec.copy(from2, to));
      }
    }
    if (local) {
      let localSet = new DecorationSet(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty;
  }
  /**
  @internal
  */
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i = 0; i < this.local.length; i++)
      if (!this.local[i].eq(other.local[i]))
        return false;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
        return false;
    return true;
  }
  /**
  @internal
  */
  locals(node) {
    return removeOverlap(this.localsInner(node));
  }
  /**
  @internal
  */
  localsInner(node) {
    if (this == empty)
      return none;
    if (node.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let result = [];
    for (let i = 0; i < this.local.length; i++) {
      if (!(this.local[i].type instanceof InlineType))
        result.push(this.local[i]);
    }
    return result;
  }
  forEachSet(f) {
    f(this);
  }
}
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
const empty = DecorationSet.empty;
class DecorationGroup {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc2) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc2, noSpec));
    return DecorationGroup.from(mappedDecos);
  }
  forChild(offset3, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    let found2 = [];
    for (let i = 0; i < this.members.length; i++) {
      let result = this.members[i].forChild(offset3, child);
      if (result == empty)
        continue;
      if (result instanceof DecorationGroup)
        found2 = found2.concat(result.members);
      else
        found2.push(result);
    }
    return DecorationGroup.from(found2);
  }
  eq(other) {
    if (!(other instanceof DecorationGroup) || other.members.length != this.members.length)
      return false;
    for (let i = 0; i < this.members.length; i++)
      if (!this.members[i].eq(other.members[i]))
        return false;
    return true;
  }
  locals(node) {
    let result, sorted = true;
    for (let i = 0; i < this.members.length; i++) {
      let locals = this.members[i].localsInner(node);
      if (!locals.length)
        continue;
      if (!result) {
        result = locals;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (let j = 0; j < locals.length; j++)
          result.push(locals[j]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(members) {
    switch (members.length) {
      case 0:
        return empty;
      case 1:
        return members[0];
      default:
        return new DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r2, m) => r2.concat(m instanceof DecorationSet ? m : m.members), []));
    }
  }
  forEachSet(f) {
    for (let i = 0; i < this.members.length; i++)
      this.members[i].forEachSet(f);
  }
}
function mapChildren(oldChildren, newLocal, mapping, node, offset3, oldOffset, options) {
  let children = oldChildren.slice();
  for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
    let moved = 0;
    mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i2 = 0; i2 < children.length; i2 += 3) {
        let end2 = children[i2 + 1];
        if (end2 < 0 || oldStart > end2 + baseOffset - moved)
          continue;
        let start2 = children[i2] + baseOffset - moved;
        if (oldEnd >= start2) {
          children[i2 + 1] = oldStart <= start2 ? -2 : -1;
        } else if (oldStart >= baseOffset && dSize) {
          children[i2] += dSize;
          children[i2 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] < 0) {
      if (children[i + 1] == -2) {
        mustRebuild = true;
        children[i + 1] = -1;
        continue;
      }
      let from2 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from2 - offset3;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset3;
      let { index: index2, offset: childOffset } = node.content.findIndex(fromLocal);
      let childNode = node.maybeChild(index2);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i] + oldOffset + 1, options);
        if (mapped != empty) {
          children[i] = fromLocal;
          children[i + 1] = toLocal;
          children[i + 2] = mapped;
        } else {
          children[i + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset3, oldOffset, options);
    let built = buildTree(decorations, node, 0, options);
    newLocal = built.local;
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] < 0) {
        children.splice(i, 3);
        i -= 3;
      }
    for (let i = 0, j = 0; i < built.children.length; i += 3) {
      let from2 = built.children[i];
      while (j < children.length && children[j] < from2)
        j += 3;
      children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset3) {
  if (!offset3 || !spans.length)
    return spans;
  let result = [];
  for (let i = 0; i < spans.length; i++) {
    let span = spans[i];
    result.push(new Decoration(span.from + offset3, span.to + offset3, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset3, oldOffset, options) {
  function gather(set2, oldOffset2) {
    for (let i = 0; i < set2.local.length; i++) {
      let mapped = set2.local[i].map(mapping, offset3, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options.onRemove)
        options.onRemove(set2.local[i].spec);
    }
    for (let i = 0; i < set2.children.length; i += 3)
      gather(set2.children[i + 2], set2.children[i] + oldOffset2 + 1);
  }
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] == -1)
      gather(children[i + 2], oldChildren[i] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset3) {
  if (node.isLeaf)
    return null;
  let end2 = offset3 + node.nodeSize, found2 = null;
  for (let i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset3 && span.to < end2) {
      (found2 || (found2 = [])).push(span);
      spans[i] = null;
    }
  }
  return found2;
}
function withoutNulls(array2) {
  let result = [];
  for (let i = 0; i < array2.length; i++)
    if (array2[i] != null)
      result.push(array2[i]);
  return result;
}
function buildTree(spans, node, offset3, options) {
  let children = [], hasNulls = false;
  node.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset3);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset3 + localStart + 1, options);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset3).sort(byPos);
  for (let i = 0; i < locals.length; i++)
    if (!locals[i].type.valid(node, locals[i])) {
      if (options.onRemove)
        options.onRemove(locals[i].spec);
      locals.splice(i--, 1);
    }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
function byPos(a2, b) {
  return a2.from - b.from || a2.to - b.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i = 0; i < working.length - 1; i++) {
    let span = working[i];
    if (span.from != span.to)
      for (let j = i + 1; j < working.length; j++) {
        let next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array2, i, deco) {
  while (i < array2.length && byPos(deco, array2[i]) > 0)
    i++;
  array2.splice(i, 0, deco);
}
function viewDecorations(view) {
  let found2 = [];
  view.someProp("decorations", (f) => {
    let result = f(view.state);
    if (result && result != empty)
      found2.push(result);
  });
  if (view.cursorWrapper)
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found2);
}
const observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
const useCharData = ie$1 && ie_version <= 11;
class SelectionState {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
}
class DOMObserver {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.lastChangedTextNode = null;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
      for (let i = 0; i < mutations.length; i++)
        this.queue.push(mutations[i]);
      if (ie$1 && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData) {
      this.onCharData = (e2) => {
        this.queue.push({ target: e2.target, type: "characterData", oldValue: e2.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i = 0; i < take.length; i++)
          this.queue.push(take[i]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie$1 && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelectionRange();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(sel) {
    if (!sel.focusNode)
      return true;
    let ancestors = /* @__PURE__ */ new Set(), container;
    for (let scan = sel.focusNode; scan; scan = parentNode(scan))
      ancestors.add(scan);
    for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
      if (ancestors.has(scan)) {
        container = scan;
        break;
      }
    let desc = container && this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  pendingRecords() {
    if (this.observer)
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
    return this.queue;
  }
  flush() {
    let { view } = this;
    if (!view.docView || this.flushingSoon > -1)
      return;
    let mutations = this.pendingRecords();
    if (mutations.length)
      this.queue = [];
    let sel = view.domSelectionRange();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
    let from2 = -1, to = -1, typeOver = false, added = [];
    if (view.editable) {
      for (let i = 0; i < mutations.length; i++) {
        let result = this.registerMutation(mutations[i], added);
        if (result) {
          from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko && added.length) {
      let brs = added.filter((n2) => n2.nodeName == "BR");
      if (brs.length == 2) {
        let [a2, b] = brs;
        if (a2.parentNode && a2.parentNode.parentNode == b.parentNode)
          b.remove();
        else
          a2.remove();
      } else {
        let { focusNode } = this.currentSelection;
        for (let br of brs) {
          let parent = br.parentNode;
          if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent))
            br.remove();
        }
      }
    }
    let readSel = null;
    if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
      view.input.lastFocus = 0;
      selectionToDOM(view);
      this.currentSelection.set(sel);
      view.scrollToSelection();
    } else if (from2 > -1 || newSel) {
      if (from2 > -1) {
        view.docView.markDirty(from2, to);
        checkCSS(view);
      }
      this.handleDOMChange(from2, to, typeOver, added);
      if (view.docView && view.docView.dirty)
        view.updateState(view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(view);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i = 0; i < mut.addedNodes.length; i++) {
        let node = mut.addedNodes[i];
        added.push(node);
        if (node.nodeType == 3)
          this.lastChangedTextNode = node;
      }
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let prev = mut.previousSibling, next = mut.nextSibling;
      if (ie$1 && ie_version <= 11 && mut.addedNodes.length) {
        for (let i = 0; i < mut.addedNodes.length; i++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next = nextSibling;
        }
      }
      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: from2, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      this.lastChangedTextNode = mut.target;
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
}
let cssChecked = /* @__PURE__ */ new WeakMap();
let cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function rangeToSelectionRange(view, range) {
  let anchorNode = range.startContainer, anchorOffset = range.startOffset;
  let focusNode = range.endContainer, focusOffset = range.endOffset;
  let currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariShadowSelectionRange(view, selection) {
  if (selection.getComposedRanges) {
    let range = selection.getComposedRanges(view.root)[0];
    if (range)
      return rangeToSelectionRange(view, range);
  }
  let found2;
  function read2(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found2 = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read2, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read2, true);
  return found2 ? rangeToSelectionRange(view, found2) : null;
}
function blockParent(view, node) {
  for (let p2 = node.parentNode; p2 && p2 != view.dom; p2 = p2.parentNode) {
    let desc = view.docView.nearestDesc(p2, true);
    if (desc && desc.node.isBlock)
      return p2;
  }
  return null;
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from: from2, to } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelectionRange();
  let find2;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find2 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome && view.input.lastKeyCode === 8) {
    for (let off = toOffset; off > fromOffset; off--) {
      let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser = view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from2);
  let sel = null, doc2 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find2,
    ruleFromNode,
    context: $from
  });
  if (find2 && find2[0].pos != null) {
    let anchor2 = find2[0].pos, head = find2[1] && find2[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from2, head: head + from2 };
  }
  return { doc: doc2, sel, from: from2, to };
}
function ruleFromNode(dom) {
  let desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
const isInline$1 = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(view, from2, to, typeOver, addedNodes) {
  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from2 < 0) {
    let origin2 = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin2);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
        return;
      let tr3 = view.state.tr.setSelection(newSel);
      if (origin2 == "pointer")
        tr3.setMeta("pointer", true);
      else if (origin2 == "key")
        tr3.scrollIntoView();
      if (compositionID)
        tr3.setMeta("composition", compositionID);
      view.dispatch(tr3);
    }
    return;
  }
  let $before = view.state.doc.resolve(from2);
  let shared = $before.sharedDepth(to);
  from2 = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  let sel = view.state.selection;
  let parse3 = parseBetween(view, from2, to);
  let doc2 = view.state.doc, compare = doc2.slice(parse3.from, parse3.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse3.doc.content, parse3.from, preferredPos, preferredSide);
  if (change)
    view.input.domChangeCount++;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n2) => n2.nodeType == 1 && !isInline$1.test(n2.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse3.sel && parse3.sel.anchor != parse3.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse3.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse3.sel);
        if (sel2 && !sel2.eq(view.state.selection)) {
          let tr3 = view.state.tr.setSelection(sel2);
          if (compositionID)
            tr3.setMeta("composition", compositionID);
          view.dispatch(tr3);
        }
      }
      return;
    }
  }
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse3.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse3.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie$1 && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse3.from && parse3.doc.textBetween(change.start - parse3.from - 1, change.start - parse3.from + 1) == " ") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse3.doc.resolveNoCache(change.start - parse3.from);
  let $to = parse3.doc.resolveNoCache(change.endB - parse3.from);
  let $fromA = doc2.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  let nextSel;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n2) => n2.nodeName == "DIV" || n2.nodeName == "P")) || !inlineChange && $from.pos < parse3.doc.content.size && !$from.sameParent($to) && (nextSel = Selection.findFrom(parse3.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeBackspace(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
    if (android && chrome)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome && change.endB == change.start)
    view.input.lastChromeDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse3.sel && parse3.sel.anchor == parse3.sel.head && parse3.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse3.doc.resolveNoCache(change.endB - parse3.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let tr2, storedMarks, markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie$1 && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      tr2 = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
    } else if (
      // Adding or removing a mark
      change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
    ) {
      tr2 = view.state.tr;
      if (markChange.type == "add")
        tr2.addMark(chFrom, chTo, markChange.mark);
      else
        tr2.removeMark(chFrom, chTo, markChange.mark);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text)))
        return;
      tr2 = view.state.tr.insertText(text, chFrom, chTo);
    }
  }
  if (!tr2)
    tr2 = view.state.tr.replace(chFrom, chTo, parse3.doc.slice(change.start - parse3.from, change.endB - parse3.from));
  if (parse3.sel) {
    let sel2 = resolveSelection(view, tr2.doc, parse3.sel);
    if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr2.mapping.map(chTo) - 1) || ie$1 && sel2.empty && sel2.head == chFrom))
      tr2.setSelection(sel2);
  }
  if (storedMarks)
    tr2.ensureMarks(storedMarks);
  if (compositionID)
    tr2.setMeta("composition", compositionID);
  view.dispatch(tr2.scrollIntoView());
}
function resolveSelection(view, doc2, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size)
    return null;
  return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update2;
  for (let i = 0; i < prevMarks.length; i++)
    added = prevMarks[i].removeFromSet(added);
  for (let i = 0; i < curMarks.length; i++)
    removed = curMarks[i].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update2 = (node) => node.mark(mark.addToSet(node.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update2 = (node) => node.mark(mark.removeFromSet(node.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i = 0; i < prev.childCount; i++)
    updated.push(update2(prev.child(i)));
  if (Fragment.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeBackspace(old, start2, end2, $newStart, $newEnd) {
  if (
    // The content must have shrunk
    end2 - start2 <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
    skipClosingAndOpening($newStart, true, false) < $newEnd.pos
  )
    return false;
  let $start = old.resolve(start2);
  if (!$newStart.parent.isTextblock) {
    let after = $start.nodeAfter;
    return after != null && end2 == start2 + after.nodeSize;
  }
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end2 || skipClosingAndOpening($next, true, false) < end2)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end2 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end2++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end2++;
    }
  }
  return end2;
}
function findDiff(a2, b, pos, preferredPos, preferredSide) {
  let start2 = a2.findDiffStart(b, pos);
  if (start2 == null)
    return null;
  let { a: endA, b: endB } = a2.findDiffEnd(b, pos + a2.size, pos + b.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start2 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start2;
  }
  if (endA < start2 && a2.size < b.size) {
    let move2 = preferredPos <= start2 && preferredPos >= endA ? start2 - preferredPos : 0;
    start2 -= move2;
    if (start2 && start2 < b.size && isSurrogatePair(b.textBetween(start2 - 1, start2 + 1)))
      start2 += move2 ? 1 : -1;
    endB = start2 + (endB - endA);
    endA = start2;
  } else if (endB < start2) {
    let move2 = preferredPos <= start2 && preferredPos >= endB ? start2 - preferredPos : 0;
    start2 -= move2;
    if (start2 && start2 < a2.size && isSurrogatePair(a2.textBetween(start2 - 1, start2 + 1)))
      start2 += move2 ? 1 : -1;
    endA = start2 + (endA - endB);
    endB = start2;
  }
  return { start: start2, endA, endB };
}
function isSurrogatePair(str) {
  if (str.length != 2)
    return false;
  let a2 = str.charCodeAt(0), b = str.charCodeAt(1);
  return a2 >= 56320 && a2 <= 57343 && b >= 55296 && b <= 56319;
}
const __serializeForClipboard = serializeForClipboard;
class EditorView {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(place, props) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, (from2, to, typeOver, added) => readDOMChange(this, from2, to, typeOver, added));
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let prev = this._props;
      this._props = {};
      for (let name in prev)
        this._props[name] = prev[name];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    let prevProps = this._props;
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, prevProps);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(props) {
    let updated = {};
    for (let name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props)
      updated[name] = props[name];
    this.update(updated);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(state) {
    this.updateStateInner(state, this._props);
  }
  updateStateInner(state, prevProps) {
    var _a;
    let prev = this.state, redraw = false, updateSel = false;
    if (state.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state;
    let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    let scroll2 = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    if (updateDoc || !state.selection.eq(prev.selection))
      updateSel = true;
    let oldScrollPos = scroll2 == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie$1 || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
      if (updateDoc) {
        let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
        if (this.composing)
          this.input.compositionNode = findCompositionNode(this);
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco(outerDeco);
          this.docView.destroy();
          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites)
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc))
      this.updateDraggedNode(this.dragging, prev);
    if (scroll2 == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll2 == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }
  /**
  @internal
  */
  scrollToSelection() {
    let startDOM = this.domSelectionRange().focusNode;
    if (this.someProp("handleScrollToSelection", (f) => f(this))) ;
    else if (this.state.selection instanceof NodeSelection) {
      let target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  }
  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i = 0; i < this.directPlugins.length; i++) {
        let plugin = this.directPlugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
      for (let i = 0; i < this.state.plugins.length; i++) {
        let plugin = this.state.plugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
    } else {
      for (let i = 0; i < this.pluginViews.length; i++) {
        let pluginView = this.pluginViews[i];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  updateDraggedNode(dragging, prev) {
    let sel = dragging.node, found2 = -1;
    if (this.state.doc.nodeAt(sel.from) == sel.node) {
      found2 = sel.from;
    } else {
      let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
      let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
      if (moved == sel.node)
        found2 = movedPos;
    }
    this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
  }
  someProp(propName, f) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f ? f(prop) : prop))
      return value;
    for (let i = 0; i < this.directPlugins.length; i++) {
      let prop2 = this.directPlugins[i].props[propName];
      if (prop2 != null && (value = f ? f(prop2) : prop2))
        return value;
    }
    let plugins = this.state.plugins;
    if (plugins)
      for (let i = 0; i < plugins.length; i++) {
        let prop2 = plugins[i].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (ie$1) {
      let node = this.root.activeElement;
      if (node == this.dom)
        return true;
      if (!node || !this.dom.contains(node))
        return false;
      while (node && this.dom != node && this.dom.contains(node)) {
        if (node.contentEditable == "false")
          return false;
        node = node.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search = this.dom.parentNode; search; search = search.parentNode) {
        if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
          if (!search.getSelection)
            Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
          return this._root = search;
        }
      }
    return cached || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(coords) {
    return posAtCoords(this, coords);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(pos, side = 1) {
    return coordsAtPos(this, pos, side);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimesfor example when interpreting an event
  targetyou don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(node, offset3, bias = -1) {
    let pos = this.docView.posFromDOM(node, offset3, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(dir, state) {
    return endOfTextblock(this, state || this.state, dir);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(html, event) {
    return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(text, event) {
    return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
    clearReusedRange();
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(event) {
    return dispatchEvent(this, event);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(tr2) {
    let dispatchTransaction = this._props.dispatchTransaction;
    if (dispatchTransaction)
      dispatchTransaction.call(this, tr2);
    else
      this.updateState(this.state.apply(tr2));
  }
  /**
  @internal
  */
  domSelectionRange() {
    let sel = this.domSelection();
    if (!sel)
      return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
function computeDocDeco(view) {
  let attrs2 = /* @__PURE__ */ Object.create(null);
  attrs2.class = "ProseMirror";
  attrs2.contenteditable = String(view.editable);
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr in value) {
        if (attr == "class")
          attrs2.class += " " + value[attr];
        else if (attr == "style")
          attrs2.style = (attrs2.style ? attrs2.style + ";" : "") + value[attr];
        else if (!attrs2[attr] && attr != "contenteditable" && attr != "nodeName")
          attrs2[attr] = String(value[attr]);
      }
  });
  if (!attrs2.translate)
    attrs2.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs2)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result = /* @__PURE__ */ Object.create(null);
  function add2(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result, prop))
        result[prop] = obj[prop];
  }
  view.someProp("nodeViews", add2);
  view.someProp("markViews", add2);
  return result;
}
function changedNodeViews(a2, b) {
  let nA = 0, nB = 0;
  for (let prop in a2) {
    if (a2[prop] != b[prop])
      return true;
    nA++;
  }
  for (let _ in b)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac$1 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
for (var code$1 in base) if (!shift.hasOwnProperty(code$1)) shift[code$1] = base[code$1];
function keyName(event) {
  var ignoreKey = mac$1 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name;
}
const mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
function normalizeKeyName$2(name) {
  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift3, meta;
  for (let i = 0; i < parts.length - 1; i++) {
    let mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift3 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift3)
    result = "Shift-" + result;
  return result;
}
function normalize(map3) {
  let copy2 = /* @__PURE__ */ Object.create(null);
  for (let prop in map3)
    copy2[normalizeKeyName$2(prop)] = map3[prop];
  return copy2;
}
function modifiers(name, event, shift3 = true) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift3 && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map3 = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), baseName, direct = map3[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        let noShift = map3[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {
        let fromCode = map3[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}
const deleteSelection$2 = (state, dispatch) => {
  if (state.selection.empty)
    return false;
  if (dispatch)
    dispatch(state.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
const joinBackward$2 = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  if (!$cut) {
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  let before = $cut.nodeBefore;
  if (deleteBarrier(state, $cut, dispatch, -1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
    for (let depth = $cursor.depth; ; depth--) {
      let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch) {
          let tr2 = state.tr.step(delStep);
          tr2.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr2.doc, $cut.pos - before.nodeSize));
          dispatch(tr2.scrollIntoView());
        }
        return true;
      }
      if (depth == 1 || $cursor.node(depth - 1).childCount > 1)
        break;
    }
  }
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
const joinTextblockBackward$2 = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};
const joinTextblockForward$2 = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};
function joinTextblocksAround(state, $cut, dispatch) {
  let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;
  for (; !beforeText.isTextblock; beforePos--) {
    if (beforeText.type.spec.isolating)
      return false;
    let child = beforeText.lastChild;
    if (!child)
      return false;
    beforeText = child;
  }
  let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;
  for (; !afterText.isTextblock; afterPos++) {
    if (afterText.type.spec.isolating)
      return false;
    let child = afterText.firstChild;
    if (!child)
      return false;
    afterText = child;
  }
  let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
  if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)
    return false;
  if (dispatch) {
    let tr2 = state.tr.step(step);
    tr2.setSelection(TextSelection.create(tr2.doc, beforePos));
    dispatch(tr2.scrollIntoView());
  }
  return true;
}
function textblockAt(node, side, only = false) {
  for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
const selectNodeBackward$2 = (state, dispatch, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  let node = $cut && $cut.nodeBefore;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      if ($pos.index(i) > 0)
        return $pos.doc.resolve($pos.before(i + 1));
      if ($pos.node(i).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
const joinForward$2 = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  let after = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch, 1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr2 = state.tr.step(delStep);
        tr2.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos)), 1) : NodeSelection.create(tr2.doc, tr2.mapping.map($cut.pos)));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
  }
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
const selectNodeForward$2 = (state, dispatch, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  let node = $cut && $cut.nodeAfter;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      let parent = $pos.node(i);
      if ($pos.index(i) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
const joinUp$2 = (state, dispatch) => {
  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
      return false;
    point = sel.from;
  } else {
    point = joinPoint(state.doc, sel.from, -1);
    if (point == null)
      return false;
  }
  if (dispatch) {
    let tr2 = state.tr.join(point);
    if (nodeSel)
      tr2.setSelection(NodeSelection.create(tr2.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch(tr2.scrollIntoView());
  }
  return true;
};
const joinDown$2 = (state, dispatch) => {
  let sel = state.selection, point;
  if (sel instanceof NodeSelection) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
      return false;
    point = sel.to;
  } else {
    point = joinPoint(state.doc, sel.to, 1);
    if (point == null)
      return false;
  }
  if (dispatch)
    dispatch(state.tr.join(point).scrollIntoView());
  return true;
};
const lift$2 = (state, dispatch) => {
  let { $from, $to } = state.selection;
  let range = $from.blockRange($to), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
const newlineInCode$2 = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch)
    dispatch(state.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt$2(match2) {
  for (let i = 0; i < match2.edgeCount; i++) {
    let { type } = match2.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
const exitCode$2 = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt$2(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type))
    return false;
  if (dispatch) {
    let pos = $head.after(), tr2 = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr2.setSelection(Selection.near(tr2.doc.resolve(pos), 1));
    dispatch(tr2.scrollIntoView());
  }
  return true;
};
const createParagraphNear$2 = (state, dispatch) => {
  let sel = state.selection, { $from, $to } = sel;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  let type = defaultBlockAt$2($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock)
    return false;
  if (dispatch) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr2 = state.tr.insert(side, type.createAndFill());
    tr2.setSelection(TextSelection.create(tr2.doc, side + 1));
    dispatch(tr2.scrollIntoView());
  }
  return true;
};
const liftEmptyBlock$2 = (state, dispatch) => {
  let { $cursor } = state.selection;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    let before = $cursor.before();
    if (canSplit(state.doc, before)) {
      if (dispatch)
        dispatch(state.tr.split(before).scrollIntoView());
      return true;
    }
  }
  let range = $cursor.blockRange(), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
const selectParentNode$2 = (state, dispatch) => {
  let { $from, to } = state.selection, pos;
  let same = $from.sharedDepth(to);
  if (same == 0)
    return false;
  pos = $from.before(same);
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
  return true;
};
function joinMaybeClear(state, $pos, dispatch) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index2 = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index2 - 1, index2)) {
    if (dispatch)
      dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index2, index2 + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
    return false;
  if (dispatch)
    dispatch(state.tr.join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch, dir) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match2;
  let isolated = before.type.spec.isolating || after.type.spec.isolating;
  if (!isolated && joinMaybeClear(state, $cut, dispatch))
    return true;
  let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match2 = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match2.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      let end2 = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
      for (let i = conn.length - 1; i >= 0; i--)
        wrap2 = Fragment.from(conn[i].create(null, wrap2));
      wrap2 = Fragment.from(before.copy(wrap2));
      let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end2, $cut.pos, end2, new Slice(wrap2, 1, 0), conn.length, true));
      let $joinAt = tr2.doc.resolve(end2 + 2 * conn.length);
      if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr2.doc, $joinAt.pos))
        tr2.join($joinAt.pos);
      dispatch(tr2.scrollIntoView());
    }
    return true;
  }
  let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);
  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at = before, wrap2 = [];
    for (; ; ) {
      wrap2.push(at);
      if (at.isTextblock)
        break;
      at = at.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        let end2 = Fragment.empty;
        for (let i = wrap2.length - 1; i >= 0; i--)
          end2 = Fragment.from(wrap2[i].copy(end2));
        let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end2, wrap2.length, 0), 0, true));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch) {
    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
const selectTextblockStart$2 = selectTextblockSide(-1);
const selectTextblockEnd$2 = selectTextblockSide(1);
function wrapIn$2(nodeType, attrs2 = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs2);
    if (!wrapping)
      return false;
    if (dispatch)
      dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}
function setBlockType(nodeType, attrs2 = null) {
  return function(state, dispatch) {
    let applicable = false;
    for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {
      let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (applicable)
          return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs2))
          return;
        if (node.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state.doc.resolve(pos), index2 = $pos.index();
          applicable = $pos.parent.canReplaceWith(index2, index2 + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch) {
      let tr2 = state.tr;
      for (let i = 0; i < state.selection.ranges.length; i++) {
        let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
        tr2.setBlockType(from2, to, nodeType, attrs2);
      }
      dispatch(tr2.scrollIntoView());
    }
    return true;
  };
}
typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
function wrapInList$2(listType, attrs2 = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to);
    if (!range)
      return false;
    let tr2 = dispatch ? state.tr : null;
    if (!wrapRangeInList(tr2, range, listType, attrs2))
      return false;
    if (dispatch)
      dispatch(tr2.scrollIntoView());
    return true;
  };
}
function wrapRangeInList(tr2, range, listType, attrs2 = null) {
  let doJoin = false, outerRange = range, doc2 = range.$from.doc;
  if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
    if (range.$from.index(range.depth - 1) == 0)
      return false;
    let $insert = doc2.resolve(range.start - 2);
    outerRange = new NodeRange($insert, $insert, range.depth);
    if (range.endIndex < range.parent.childCount)
      range = new NodeRange(range.$from, doc2.resolve(range.$to.end(range.depth)), range.depth);
    doJoin = true;
  }
  let wrap2 = findWrapping(outerRange, listType, attrs2, range);
  if (!wrap2)
    return false;
  if (tr2)
    doWrapInList(tr2, range, wrap2, doJoin, listType);
  return true;
}
function doWrapInList(tr2, range, wrappers, joinBefore, listType) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--)
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  tr2.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
  let found2 = 0;
  for (let i = 0; i < wrappers.length; i++)
    if (wrappers[i].type == listType)
      found2 = i + 1;
  let splitDepth = wrappers.length - found2;
  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (let i = range.startIndex, e2 = range.endIndex, first2 = true; i < e2; i++, first2 = false) {
    if (!first2 && canSplit(tr2.doc, splitPos, splitDepth)) {
      tr2.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i).nodeSize;
  }
  return tr2;
}
function liftListItem$2(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    if (!dispatch)
      return true;
    if ($from.node(range.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch, itemType, range);
    else
      return liftOutOfList(state, dispatch, range);
  };
}
function liftToOuterList(state, dispatch, itemType, range) {
  let tr2 = state.tr, end2 = range.end, endOfList = range.$to.end(range.depth);
  if (end2 < endOfList) {
    tr2.step(new ReplaceAroundStep(end2 - 1, endOfList, end2, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr2.doc.resolve(range.$from.pos), tr2.doc.resolve(endOfList), range.depth);
  }
  const target = liftTarget(range);
  if (target == null)
    return false;
  tr2.lift(range, target);
  let after = tr2.mapping.map(end2, -1) - 1;
  if (canJoin(tr2.doc, after))
    tr2.join(after);
  dispatch(tr2.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch, range) {
  let tr2 = state.tr, list = range.parent;
  for (let pos = range.end, i = range.endIndex - 1, e2 = range.startIndex; i > e2; i--) {
    pos -= list.child(i).nodeSize;
    tr2.delete(pos - 1, pos + 1);
  }
  let $start = tr2.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr2.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
    return false;
  let start2 = $start.pos, end2 = start2 + item.nodeSize;
  tr2.step(new ReplaceAroundStep(start2 - (atStart ? 1 : 0), end2 + (atEnd ? 1 : 0), start2 + 1, end2 - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr2.scrollIntoView());
  return true;
}
function sinkListItem$2(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    let startIndex = range.startIndex;
    if (startIndex == 0)
      return false;
    let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment.from(nestedBefore ? itemType.create() : null);
      let slice2 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before = range.start, after = range.end;
      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
    }
    return true;
  };
}
function createChainableState$1(config) {
  const { state, transaction } = config;
  let { selection } = transaction;
  let { doc: doc2 } = transaction;
  let { storedMarks } = transaction;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc2;
    },
    get tr() {
      selection = transaction.selection;
      doc2 = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  };
}
let CommandManager$1 = class CommandManager {
  constructor(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr: tr2 } = state;
    const props = this.buildProps(tr2);
    return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      const method = (...args) => {
        const callback = command2(...args)(props);
        if (!tr2.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr2);
        }
        return callback;
      };
      return [name, method];
    }));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr2 = startTr || state.tr;
    const run2 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr2.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr2);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain = {
      ...Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        const chainedCommand = (...args) => {
          const props = this.buildProps(tr2, shouldDispatch);
          const callback = command2(...args)(props);
          callbacks.push(callback);
          return chain;
        };
        return [name, chainedCommand];
      })),
      run: run2
    };
    return chain;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch = false;
    const tr2 = startTr || state.tr;
    const props = this.buildProps(tr2, dispatch);
    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
    }));
    return {
      ...formattedCommands,
      chain: () => this.createChain(tr2, dispatch)
    };
  }
  buildProps(tr2, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const props = {
      tr: tr2,
      editor,
      view,
      state: createChainableState$1({
        state,
        transaction: tr2
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr2, shouldDispatch),
      can: () => this.createCan(tr2),
      get commands() {
        return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          return [name, (...args) => command2(...args)(props)];
        }));
      }
    };
    return props;
  }
};
class EventEmitter {
  constructor() {
    this.callbacks = {};
  }
  on(event, fn2) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn2);
    return this;
  }
  emit(event, ...args) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback.apply(this, args));
    }
    return this;
  }
  off(event, fn2) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn2) {
        this.callbacks[event] = callbacks.filter((callback) => callback !== fn2);
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  }
  once(event, fn2) {
    const onceFn = (...args) => {
      this.off(event, onceFn);
      fn2.apply(this, args);
    };
    return this.on(event, onceFn);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
function getExtensionField$1(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField$1(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({
      ...context,
      parent: extension.parent ? getExtensionField$1(extension.parent, field, context) : null
    });
    return value;
  }
  return extension.config[field];
}
function splitExtensions$1(extensions) {
  const baseExtensions = extensions.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions.filter((extension) => extension.type === "node");
  const markExtensions = extensions.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getAttributesFromExtensions(extensions) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions$1(extensions);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  extensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      extensions: nodeAndMarkExtensions
    };
    const addGlobalAttributes = getExtensionField$1(extension, "addGlobalAttributes", context);
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionField$1(extension, "addAttributes", context);
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute]) => {
      const mergedAttr = {
        ...defaultAttribute,
        ...attribute
      };
      if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === "function") {
        mergedAttr.default = mergedAttr.default();
      }
      if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === void 0) {
        delete mergedAttr.default;
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: mergedAttr
      });
    });
  });
  return extensionAttributes;
}
function getNodeType$1(nameOrType, schema2) {
  if (typeof nameOrType === "string") {
    if (!schema2.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema2.nodes[nameOrType];
  }
  return nameOrType;
}
function mergeAttributes$1(...objects) {
  return objects.filter((item) => !!item).reduce((items2, item) => {
    const mergedAttributes = { ...items2 };
    Object.entries(item).forEach(([key, value]) => {
      const exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        const valueClasses = value ? value.split(" ") : [];
        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
      } else if (key === "style") {
        const newStyles = value ? value.split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const styleMap = /* @__PURE__ */ new Map();
        existingStyles.forEach((style2) => {
          const [property2, val] = style2.split(":").map((part) => part.trim());
          styleMap.set(property2, val);
        });
        newStyles.forEach((style2) => {
          const [property2, val] = style2.split(":").map((part) => part.trim());
          styleMap.set(property2, val);
        });
        mergedAttributes[key] = Array.from(styleMap.entries()).map(([property2, val]) => `${property2}: ${val}`).join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {
    if (!item.attribute.renderHTML) {
      return {
        [item.name]: nodeOrMark.attrs[item.name]
      };
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute) => mergeAttributes$1(attributes, attribute), {});
}
function isFunction$1(value) {
  return typeof value === "function";
}
function callOrReturn$1(value, context = void 0, ...props) {
  if (isFunction$1(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function isEmptyObject$1(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function fromString(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
  if ("style" in parseRule) {
    return parseRule;
  }
  return {
    ...parseRule,
    getAttrs: (node) => {
      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items2, item) => {
        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
        if (value === null || value === void 0) {
          return items2;
        }
        return {
          ...items2,
          [item.name]: value
        };
      }, {});
      return { ...oldAttributes, ...newAttributes };
    }
  };
}
function cleanUpSchemaItem(data) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(data).filter(([key, value]) => {
      if (key === "attrs" && isEmptyObject$1(value)) {
        return false;
      }
      return value !== null && value !== void 0;
    })
  );
}
function getSchemaByResolvedExtensions(extensions, editor) {
  var _a;
  const allAttributes = getAttributesFromExtensions(extensions);
  const { nodeExtensions, markExtensions } = splitExtensions$1(extensions);
  const topNode = (_a = nodeExtensions.find((extension) => getExtensionField$1(extension, "topNode"))) === null || _a === void 0 ? void 0 : _a.name;
  const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const extraNodeFields = extensions.reduce((fields, e2) => {
      const extendNodeSchema = getExtensionField$1(e2, "extendNodeSchema", context);
      return {
        ...fields,
        ...extendNodeSchema ? extendNodeSchema(extension) : {}
      };
    }, {});
    const schema2 = cleanUpSchemaItem({
      ...extraNodeFields,
      content: callOrReturn$1(getExtensionField$1(extension, "content", context)),
      marks: callOrReturn$1(getExtensionField$1(extension, "marks", context)),
      group: callOrReturn$1(getExtensionField$1(extension, "group", context)),
      inline: callOrReturn$1(getExtensionField$1(extension, "inline", context)),
      atom: callOrReturn$1(getExtensionField$1(extension, "atom", context)),
      selectable: callOrReturn$1(getExtensionField$1(extension, "selectable", context)),
      draggable: callOrReturn$1(getExtensionField$1(extension, "draggable", context)),
      code: callOrReturn$1(getExtensionField$1(extension, "code", context)),
      whitespace: callOrReturn$1(getExtensionField$1(extension, "whitespace", context)),
      linebreakReplacement: callOrReturn$1(getExtensionField$1(extension, "linebreakReplacement", context)),
      defining: callOrReturn$1(getExtensionField$1(extension, "defining", context)),
      isolating: callOrReturn$1(getExtensionField$1(extension, "isolating", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a2;
        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
      }))
    });
    const parseHTML = callOrReturn$1(getExtensionField$1(extension, "parseHTML", context));
    if (parseHTML) {
      schema2.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField$1(extension, "renderHTML", context);
    if (renderHTML) {
      schema2.toDOM = (node) => renderHTML({
        node,
        HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
      });
    }
    const renderText = getExtensionField$1(extension, "renderText", context);
    if (renderText) {
      schema2.toText = renderText;
    }
    return [extension.name, schema2];
  }));
  const marks = Object.fromEntries(markExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const extraMarkFields = extensions.reduce((fields, e2) => {
      const extendMarkSchema = getExtensionField$1(e2, "extendMarkSchema", context);
      return {
        ...fields,
        ...extendMarkSchema ? extendMarkSchema(extension) : {}
      };
    }, {});
    const schema2 = cleanUpSchemaItem({
      ...extraMarkFields,
      inclusive: callOrReturn$1(getExtensionField$1(extension, "inclusive", context)),
      excludes: callOrReturn$1(getExtensionField$1(extension, "excludes", context)),
      group: callOrReturn$1(getExtensionField$1(extension, "group", context)),
      spanning: callOrReturn$1(getExtensionField$1(extension, "spanning", context)),
      code: callOrReturn$1(getExtensionField$1(extension, "code", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a2;
        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
      }))
    });
    const parseHTML = callOrReturn$1(getExtensionField$1(extension, "parseHTML", context));
    if (parseHTML) {
      schema2.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField$1(extension, "renderHTML", context);
    if (renderHTML) {
      schema2.toDOM = (mark) => renderHTML({
        mark,
        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
      });
    }
    return [extension.name, schema2];
  }));
  return new Schema({
    topNode,
    nodes,
    marks
  });
}
function getSchemaTypeByName(name, schema2) {
  return schema2.nodes[name] || schema2.marks[name] || null;
}
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
function getHTMLFromFragment(fragment, schema2) {
  const documentFragment = DOMSerializer.fromSchema(schema2).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
const getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = "";
  const sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index2) => {
    var _a, _b;
    const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {
      node,
      pos,
      parent,
      index: index2
    })) || node.textContent || "%leaf%";
    textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
function isRegExp$1(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
let InputRule$1 = class InputRule {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
const inputRuleMatcherHandler = (text, find2) => {
  if (isRegExp$1(find2)) {
    return find2.exec(text);
  }
  const inputRuleMatch = find2(text);
  if (!inputRuleMatch) {
    return null;
  }
  const result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
function run$1$1(config) {
  var _a;
  const { editor, from: from2, to, text, rules, plugin } = config;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from2);
  if (
    // check for code node
    $from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find((mark) => mark.type.spec.code))
  ) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match2 = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match2) {
      return;
    }
    const tr2 = view.state.tr;
    const state = createChainableState$1({
      state: view.state,
      transaction: tr2
    });
    const range = {
      from: from2 - (match2[0].length - text.length),
      to
    };
    const { commands: commands2, chain, can } = new CommandManager$1({
      editor,
      state
    });
    const handler = rule.handler({
      state,
      range,
      match: match2,
      commands: commands2,
      chain,
      can
    });
    if (handler === null || !tr2.steps.length) {
      return;
    }
    tr2.setMeta(plugin, {
      transform: tr2,
      from: from2,
      to,
      text
    });
    view.dispatch(tr2);
    matched = true;
  });
  return matched;
}
function inputRulesPlugin(props) {
  const { editor, rules } = props;
  const plugin = new Plugin({
    state: {
      init() {
        return null;
      },
      apply(tr2, prev, state) {
        const stored = tr2.getMeta(plugin);
        if (stored) {
          return stored;
        }
        const simulatedInputMeta = tr2.getMeta("applyInputRules");
        const isSimulatedInput = !!simulatedInputMeta;
        if (isSimulatedInput) {
          setTimeout(() => {
            let { text } = simulatedInputMeta;
            if (typeof text === "string") {
              text = text;
            } else {
              text = getHTMLFromFragment(Fragment.from(text), state.schema);
            }
            const { from: from2 } = simulatedInputMeta;
            const to = from2 + text.length;
            run$1$1({
              editor,
              from: from2,
              to,
              text,
              rules,
              plugin
            });
          });
        }
        return tr2.selectionSet || tr2.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from2, to, text) {
        return run$1$1({
          editor,
          from: from2,
          to,
          text,
          rules,
          plugin
        });
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            const { $cursor } = view.state.selection;
            if ($cursor) {
              run$1$1({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "",
                rules,
                plugin
              });
            }
          });
          return false;
        }
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run$1$1({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules,
            plugin
          });
        }
        return false;
      }
    },
    // @ts-ignore
    isInputRules: true
  });
  return plugin;
}
function getType$1(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject$1(value) {
  if (getType$1(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep$2(target, source) {
  const output = { ...target };
  if (isPlainObject$1(target) && isPlainObject$1(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject$1(source[key]) && isPlainObject$1(target[key])) {
        output[key] = mergeDeep$2(target[key], source[key]);
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
let Mark$1 = class Mark2 {
  constructor(config = {}) {
    this.type = "mark";
    this.name = "mark";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn$1(getExtensionField$1(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn$1(getExtensionField$1(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Mark2(config);
  }
  configure(options = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep$2(this.options, options);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Mark2(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn$1(getExtensionField$1(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn$1(getExtensionField$1(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  static handleExit({ editor, mark }) {
    const { tr: tr2 } = editor.state;
    const currentPos = editor.state.selection.$from;
    const isAtEnd = currentPos.pos === currentPos.end();
    if (isAtEnd) {
      const currentMarks = currentPos.marks();
      const isInMark = !!currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
      if (!isInMark) {
        return false;
      }
      const removeMark2 = currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
      if (removeMark2) {
        tr2.removeStoredMark(removeMark2);
      }
      tr2.insertText(" ", currentPos.pos);
      editor.view.dispatch(tr2);
      return true;
    }
    return false;
  }
};
function isNumber(value) {
  return typeof value === "number";
}
let PasteRule$1 = class PasteRule {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
const pasteRuleMatcherHandler = (text, find2, event) => {
  if (isRegExp$1(find2)) {
    return [...text.matchAll(find2)];
  }
  const matches2 = find2(text, event);
  if (!matches2) {
    return [];
  }
  return matches2.map((pasteRuleMatch) => {
    const result = [pasteRuleMatch.text];
    result.index = pasteRuleMatch.index;
    result.input = text;
    result.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result.push(pasteRuleMatch.replaceWith);
    }
    return result;
  });
};
function run$2(config) {
  const { editor, state, from: from2, to, rule, pasteEvent, dropEvent } = config;
  const { commands: commands2, chain, can } = new CommandManager$1({
    editor,
    state
  });
  const handlers2 = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isTextblock || node.type.spec.code) {
      return;
    }
    const resolvedFrom = Math.max(from2, pos);
    const resolvedTo = Math.min(to, pos + node.content.size);
    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "");
    const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
    matches2.forEach((match2) => {
      if (match2.index === void 0) {
        return;
      }
      const start2 = resolvedFrom + match2.index + 1;
      const end2 = start2 + match2[0].length;
      const range = {
        from: state.tr.mapping.map(start2),
        to: state.tr.mapping.map(end2)
      };
      const handler = rule.handler({
        state,
        range,
        match: match2,
        commands: commands2,
        chain,
        can,
        pasteEvent,
        dropEvent
      });
      handlers2.push(handler);
    });
  });
  const success = handlers2.every((handler) => handler !== null);
  return success;
}
const createClipboardPasteEvent = (text) => {
  var _a;
  const event = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.setData("text/html", text);
  return event;
};
function pasteRulesPlugin(props) {
  const { editor, rules } = props;
  let dragSourceElement = null;
  let isPastedFromProseMirror = false;
  let isDroppedFromProseMirror = false;
  let pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
  let dropEvent;
  try {
    dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
  } catch (e2) {
    dropEvent = null;
  }
  const processEvent = ({ state, from: from2, to, rule, pasteEvt }) => {
    const tr2 = state.tr;
    const chainableState = createChainableState$1({
      state,
      transaction: tr2
    });
    const handler = run$2({
      editor,
      state: chainableState,
      from: Math.max(from2 - 1, 0),
      to: to.b - 1,
      rule,
      pasteEvent: pasteEvt,
      dropEvent
    });
    if (!handler || !tr2.steps.length) {
      return;
    }
    try {
      dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
    } catch (e2) {
      dropEvent = null;
    }
    pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
    return tr2;
  };
  const plugins = rules.map((rule) => {
    return new Plugin({
      // we register a global drag handler to track the current drag source element
      view(view) {
        const handleDragstart = (event) => {
          var _a;
          dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;
        };
        window.addEventListener("dragstart", handleDragstart);
        return {
          destroy() {
            window.removeEventListener("dragstart", handleDragstart);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: (view, event) => {
            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
            dropEvent = event;
            return false;
          },
          paste: (_view, event) => {
            var _a;
            const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
            pasteEvent = event;
            isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes("data-pm-slice"));
            return false;
          }
        }
      },
      appendTransaction: (transactions, oldState, state) => {
        const transaction = transactions[0];
        const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
        const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
        const simulatedPasteMeta = transaction.getMeta("applyPasteRules");
        const isSimulatedPaste = !!simulatedPasteMeta;
        if (!isPaste && !isDrop && !isSimulatedPaste) {
          return;
        }
        if (isSimulatedPaste) {
          let { text } = simulatedPasteMeta;
          if (typeof text === "string") {
            text = text;
          } else {
            text = getHTMLFromFragment(Fragment.from(text), state.schema);
          }
          const { from: from3 } = simulatedPasteMeta;
          const to2 = from3 + text.length;
          const pasteEvt = createClipboardPasteEvent(text);
          return processEvent({
            rule,
            state,
            from: from3,
            to: { b: to2 },
            pasteEvt
          });
        }
        const from2 = oldState.doc.content.findDiffStart(state.doc.content);
        const to = oldState.doc.content.findDiffEnd(state.doc.content);
        if (!isNumber(from2) || !to || from2 === to.b) {
          return;
        }
        return processEvent({
          rule,
          state,
          from: from2,
          to,
          pasteEvt: pasteEvent
        });
      }
    });
  });
  return plugins;
}
function findDuplicates(items2) {
  const filtered = items2.filter((el2, index2) => items2.indexOf(el2) !== index2);
  return Array.from(new Set(filtered));
}
class ExtensionManager {
  constructor(extensions, editor) {
    this.splittableMarks = [];
    this.editor = editor;
    this.extensions = ExtensionManager.resolve(extensions);
    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
    this.setupExtensions();
  }
  /**
   * Returns a flattened and sorted extension list while
   * also checking for duplicated extensions and warns the user.
   * @param extensions An array of Tiptap extensions
   * @returns An flattened and sorted array of Tiptap extensions
   */
  static resolve(extensions) {
    const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));
    const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
    if (duplicatedNames.length) {
      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
    }
    return resolvedExtensions;
  }
  /**
   * Create a flattened array of extensions by traversing the `addExtensions` field.
   * @param extensions An array of Tiptap extensions
   * @returns A flattened array of Tiptap extensions
   */
  static flatten(extensions) {
    return extensions.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addExtensions = getExtensionField$1(extension, "addExtensions", context);
      if (addExtensions) {
        return [extension, ...this.flatten(addExtensions())];
      }
      return extension;
    }).flat(10);
  }
  /**
   * Sort extensions by priority.
   * @param extensions An array of Tiptap extensions
   * @returns A sorted array of Tiptap extensions by priority
   */
  static sort(extensions) {
    const defaultPriority = 100;
    return extensions.sort((a2, b) => {
      const priorityA = getExtensionField$1(a2, "priority") || defaultPriority;
      const priorityB = getExtensionField$1(b, "priority") || defaultPriority;
      if (priorityA > priorityB) {
        return -1;
      }
      if (priorityA < priorityB) {
        return 1;
      }
      return 0;
    });
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((commands2, extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionField$1(extension, "addCommands", context);
      if (!addCommands) {
        return commands2;
      }
      return {
        ...commands2,
        ...addCommands()
      };
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor } = this;
    const extensions = ExtensionManager.sort([...this.extensions].reverse());
    const inputRules = [];
    const pasteRules = [];
    const allPlugins = extensions.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins = [];
      const addKeyboardShortcuts = getExtensionField$1(extension, "addKeyboardShortcuts", context);
      let defaultBindings = {};
      if (extension.type === "mark" && getExtensionField$1(extension, "exitable", context)) {
        defaultBindings.ArrowRight = () => Mark$1.handleExit({ editor, mark: extension });
      }
      if (addKeyboardShortcuts) {
        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
          return [shortcut, () => method({ editor })];
        }));
        defaultBindings = { ...defaultBindings, ...bindings };
      }
      const keyMapPlugin = keymap(defaultBindings);
      plugins.push(keyMapPlugin);
      const addInputRules = getExtensionField$1(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        inputRules.push(...addInputRules());
      }
      const addPasteRules = getExtensionField$1(extension, "addPasteRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
        pasteRules.push(...addPasteRules());
      }
      const addProseMirrorPlugins = getExtensionField$1(extension, "addProseMirrorPlugins", context);
      if (addProseMirrorPlugins) {
        const proseMirrorPlugins = addProseMirrorPlugins();
        plugins.push(...proseMirrorPlugins);
      }
      return plugins;
    }).flat();
    return [
      inputRulesPlugin({
        editor,
        rules: inputRules
      }),
      ...pasteRulesPlugin({
        editor,
        rules: pasteRules
      }),
      ...allPlugins
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return getAttributesFromExtensions(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor } = this;
    const { nodeExtensions } = splitExtensions$1(this.extensions);
    return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField$1(extension, "addNodeView")).map((extension) => {
      const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getNodeType$1(extension.name, this.schema)
      };
      const addNodeView = getExtensionField$1(extension, "addNodeView", context);
      if (!addNodeView) {
        return [];
      }
      const nodeview = (node, view, getPos, decorations, innerDecorations) => {
        const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
        return addNodeView()({
          // pass-through
          node,
          view,
          getPos,
          decorations,
          innerDecorations,
          // tiptap-specific
          editor,
          extension,
          HTMLAttributes
        });
      };
      return [extension.name, nodeview];
    }));
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    this.extensions.forEach((extension) => {
      var _a;
      this.editor.extensionStorage[extension.name] = extension.storage;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      if (extension.type === "mark") {
        const keepOnSplit = (_a = callOrReturn$1(getExtensionField$1(extension, "keepOnSplit", context))) !== null && _a !== void 0 ? _a : true;
        if (keepOnSplit) {
          this.splittableMarks.push(extension.name);
        }
      }
      const onBeforeCreate = getExtensionField$1(extension, "onBeforeCreate", context);
      const onCreate2 = getExtensionField$1(extension, "onCreate", context);
      const onUpdate = getExtensionField$1(extension, "onUpdate", context);
      const onSelectionUpdate = getExtensionField$1(extension, "onSelectionUpdate", context);
      const onTransaction = getExtensionField$1(extension, "onTransaction", context);
      const onFocus = getExtensionField$1(extension, "onFocus", context);
      const onBlur = getExtensionField$1(extension, "onBlur", context);
      const onDestroy2 = getExtensionField$1(extension, "onDestroy", context);
      if (onBeforeCreate) {
        this.editor.on("beforeCreate", onBeforeCreate);
      }
      if (onCreate2) {
        this.editor.on("create", onCreate2);
      }
      if (onUpdate) {
        this.editor.on("update", onUpdate);
      }
      if (onSelectionUpdate) {
        this.editor.on("selectionUpdate", onSelectionUpdate);
      }
      if (onTransaction) {
        this.editor.on("transaction", onTransaction);
      }
      if (onFocus) {
        this.editor.on("focus", onFocus);
      }
      if (onBlur) {
        this.editor.on("blur", onBlur);
      }
      if (onDestroy2) {
        this.editor.on("destroy", onDestroy2);
      }
    });
  }
}
let Extension$1 = class Extension {
  constructor(config = {}) {
    this.type = "extension";
    this.name = "extension";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn$1(getExtensionField$1(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn$1(getExtensionField$1(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Extension(config);
  }
  configure(options = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep$2(this.options, options);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Extension({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn$1(getExtensionField$1(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn$1(getExtensionField$1(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
};
function getTextBetween$1(startNode, range, options) {
  const { from: from2, to } = range;
  const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
  let text = "";
  startNode.nodesBetween(from2, to, (node, pos, parent, index2) => {
    var _a;
    if (node.isBlock && pos > from2) {
      text += blockSeparator;
    }
    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
    if (textSerializer) {
      if (parent) {
        text += textSerializer({
          node,
          pos,
          parent,
          index: index2,
          range
        });
      }
      return false;
    }
    if (node.isText) {
      text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from2, pos) - pos, to - pos);
    }
  });
  return text;
}
function getTextSerializersFromSchema$1(schema2) {
  return Object.fromEntries(Object.entries(schema2.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));
}
const ClipboardTextSerializer = Extension$1.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema: schema2 } = editor;
            const { doc: doc2, selection } = state;
            const { ranges } = selection;
            const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
            const to = Math.max(...ranges.map((range2) => range2.$to.pos));
            const textSerializers = getTextSerializersFromSchema$1(schema2);
            const range = { from: from2, to };
            return getTextBetween$1(doc2, range, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers
            });
          }
        }
      })
    ];
  }
});
const blur$1 = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a;
    if (!editor.isDestroyed) {
      view.dom.blur();
      (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
    }
  });
  return true;
};
const clearContent$1 = (emitUpdate = false) => ({ commands: commands2 }) => {
  return commands2.setContent("", emitUpdate);
};
const clearNodes$1 = () => ({ state, tr: tr2, dispatch }) => {
  const { selection } = tr2;
  const { ranges } = selection;
  if (!dispatch) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.type.isText) {
        return;
      }
      const { doc: doc2, mapping } = tr2;
      const $mappedFrom = doc2.resolve(mapping.map(pos));
      const $mappedTo = doc2.resolve(mapping.map(pos + node.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr2.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr2.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
const command$1 = (fn2) => (props) => {
  return fn2(props);
};
const createParagraphNear$1 = () => ({ state, dispatch }) => {
  return createParagraphNear$2(state, dispatch);
};
const cut$1 = (originRange, targetPos) => ({ editor, tr: tr2 }) => {
  const { state } = editor;
  const contentSlice = state.doc.slice(originRange.from, originRange.to);
  tr2.deleteRange(originRange.from, originRange.to);
  const newPos = tr2.mapping.map(targetPos);
  tr2.insert(newPos, contentSlice.content);
  tr2.setSelection(new TextSelection(tr2.doc.resolve(newPos - 1)));
  return true;
};
const deleteCurrentNode$1 = () => ({ tr: tr2, dispatch }) => {
  const { selection } = tr2;
  const currentNode = selection.$anchor.node();
  if (currentNode.content.size > 0) {
    return false;
  }
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === currentNode.type) {
      if (dispatch) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
const deleteNode$1 = (typeOrName) => ({ tr: tr2, state, dispatch }) => {
  const type = getNodeType$1(typeOrName, state.schema);
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === type) {
      if (dispatch) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
const deleteRange$1 = (range) => ({ tr: tr2, dispatch }) => {
  const { from: from2, to } = range;
  if (dispatch) {
    tr2.delete(from2, to);
  }
  return true;
};
const deleteSelection$1 = () => ({ state, dispatch }) => {
  return deleteSelection$2(state, dispatch);
};
const enter$1 = () => ({ commands: commands2 }) => {
  return commands2.keyboardShortcut("Enter");
};
const exitCode$1 = () => ({ state, dispatch }) => {
  return exitCode$2(state, dispatch);
};
function objectIncludes$1(object1, object2, options = { strict: true }) {
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key) => {
    if (options.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp$1(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet$1(marks, type, attributes = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes$1(
      // Only check equality for the attributes that are provided
      Object.fromEntries(Object.keys(attributes).map((k) => [k, item.attrs[k]])),
      attributes
    );
  });
}
function isMarkInSet$1(marks, type, attributes = {}) {
  return !!findMarkInSet$1(marks, type, attributes);
}
function getMarkRange$1($pos, type, attributes) {
  var _a;
  if (!$pos || !type) {
    return;
  }
  let start2 = $pos.parent.childAfter($pos.parentOffset);
  if (!start2.node || !start2.node.marks.some((mark2) => mark2.type === type)) {
    start2 = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start2.node || !start2.node.marks.some((mark2) => mark2.type === type)) {
    return;
  }
  attributes = attributes || ((_a = start2.node.marks[0]) === null || _a === void 0 ? void 0 : _a.attrs);
  const mark = findMarkInSet$1([...start2.node.marks], type, attributes);
  if (!mark) {
    return;
  }
  let startIndex = start2.index;
  let startPos = $pos.start() + start2.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start2.node.nodeSize;
  while (startIndex > 0 && isMarkInSet$1([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet$1([...$pos.parent.child(endIndex).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getMarkType$1(nameOrType, schema2) {
  if (typeof nameOrType === "string") {
    if (!schema2.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema2.marks[nameOrType];
  }
  return nameOrType;
}
const extendMarkRange$1 = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
  const type = getMarkType$1(typeOrName, state.schema);
  const { doc: doc2, selection } = tr2;
  const { $from, from: from2, to } = selection;
  if (dispatch) {
    const range = getMarkRange$1($from, type, attributes);
    if (range && range.from <= from2 && range.to >= to) {
      const newSelection = TextSelection.create(doc2, range.from, range.to);
      tr2.setSelection(newSelection);
    }
  }
  return true;
};
const first$1 = (commands2) => (props) => {
  const items2 = typeof commands2 === "function" ? commands2(props) : commands2;
  for (let i = 0; i < items2.length; i += 1) {
    if (items2[i](props)) {
      return true;
    }
  }
  return false;
};
function isTextSelection$1(value) {
  return value instanceof TextSelection;
}
function minMax$1(value = 0, min2 = 0, max2 = 0) {
  return Math.min(Math.max(value, min2), max2);
}
function resolveFocusPosition$1(doc2, position2 = null) {
  if (!position2) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc2);
  const selectionAtEnd = Selection.atEnd(doc2);
  if (position2 === "start" || position2 === true) {
    return selectionAtStart;
  }
  if (position2 === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position2 === "all") {
    return TextSelection.create(doc2, minMax$1(0, minPos, maxPos), minMax$1(doc2.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc2, minMax$1(position2, minPos, maxPos), minMax$1(position2, minPos, maxPos));
}
function isiOS$1() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
const focus$1 = (position2 = null, options = {}) => ({ editor, view, tr: tr2, dispatch }) => {
  options = {
    scrollIntoView: true,
    ...options
  };
  const delayedFocus = () => {
    if (isiOS$1()) {
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  if (view.hasFocus() && position2 === null || position2 === false) {
    return true;
  }
  if (dispatch && position2 === null && !isTextSelection$1(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition$1(tr2.doc, position2) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch) {
    if (!isSameSelection) {
      tr2.setSelection(selection);
    }
    if (isSameSelection && tr2.storedMarks) {
      tr2.setStoredMarks(tr2.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
const forEach$1 = (items2, fn2) => (props) => {
  return items2.every((item, index2) => fn2(item, { ...props, index: index2 }));
};
const insertContent$1 = (value, options) => ({ tr: tr2, commands: commands2 }) => {
  return commands2.insertContentAt({ from: tr2.selection.from, to: tr2.selection.to }, value, options);
};
const removeWhitespaces$1 = (node) => {
  const children = node.childNodes;
  for (let i = children.length - 1; i >= 0; i -= 1) {
    const child = children[i];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces$1(child);
    }
  }
  return node;
};
function elementFromString$2(value) {
  const wrappedValue = `<body>${value}</body>`;
  const html = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  return removeWhitespaces$1(html);
}
function createNodeFromContent$1(content, schema2, options) {
  if (content instanceof Node$3 || content instanceof Fragment) {
    return content;
  }
  options = {
    slice: true,
    parseOptions: {},
    ...options
  };
  const isJSONContent = typeof content === "object" && content !== null;
  const isTextContent = typeof content === "string";
  if (isJSONContent) {
    try {
      const isArrayContent = Array.isArray(content) && content.length > 0;
      if (isArrayContent) {
        return Fragment.fromArray(content.map((item) => schema2.nodeFromJSON(item)));
      }
      const node = schema2.nodeFromJSON(content);
      if (options.errorOnInvalidContent) {
        node.check();
      }
      return node;
    } catch (error) {
      if (options.errorOnInvalidContent) {
        throw new Error("[tiptap error]: Invalid JSON content", { cause: error });
      }
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
      return createNodeFromContent$1("", schema2, options);
    }
  }
  if (isTextContent) {
    if (options.errorOnInvalidContent) {
      let hasInvalidContent = false;
      let invalidContent = "";
      const contentCheckSchema = new Schema({
        topNode: schema2.spec.topNode,
        marks: schema2.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: schema2.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (e2) => {
                  hasInvalidContent = true;
                  invalidContent = typeof e2 === "string" ? e2 : e2.outerHTML;
                  return null;
                }
              }
            ]
          }
        })
      });
      if (options.slice) {
        DOMParser.fromSchema(contentCheckSchema).parseSlice(elementFromString$2(content), options.parseOptions);
      } else {
        DOMParser.fromSchema(contentCheckSchema).parse(elementFromString$2(content), options.parseOptions);
      }
      if (options.errorOnInvalidContent && hasInvalidContent) {
        throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${invalidContent}`) });
      }
    }
    const parser = DOMParser.fromSchema(schema2);
    if (options.slice) {
      return parser.parseSlice(elementFromString$2(content), options.parseOptions).content;
    }
    return parser.parse(elementFromString$2(content), options.parseOptions);
  }
  return createNodeFromContent$1("", schema2, options);
}
function selectionToInsertionEnd$1(tr2, startLen, bias) {
  const last = tr2.steps.length - 1;
  if (last < startLen) {
    return;
  }
  const step = tr2.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map3 = tr2.mapping.maps[last];
  let end2 = 0;
  map3.forEach((_from, _to, _newFrom, newTo) => {
    if (end2 === 0) {
      end2 = newTo;
    }
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end2), bias));
}
const isFragment$1 = (nodeOrFragment) => {
  return !("type" in nodeOrFragment);
};
const insertContentAt$1 = (position2, value, options) => ({ tr: tr2, dispatch, editor }) => {
  var _a;
  if (dispatch) {
    options = {
      parseOptions: editor.options.parseOptions,
      updateSelection: true,
      applyInputRules: false,
      applyPasteRules: false,
      ...options
    };
    let content;
    try {
      content = createNodeFromContent$1(value, editor.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...options.parseOptions
        },
        errorOnInvalidContent: (_a = options.errorOnInvalidContent) !== null && _a !== void 0 ? _a : editor.options.enableContentCheck
      });
    } catch (e2) {
      editor.emit("contentError", {
        editor,
        error: e2,
        disableCollaboration: () => {
          if (editor.storage.collaboration) {
            editor.storage.collaboration.isDisabled = true;
          }
        }
      });
      return false;
    }
    let { from: from2, to } = typeof position2 === "number" ? { from: position2, to: position2 } : { from: position2.from, to: position2.to };
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment$1(content) ? content : [content];
    nodes.forEach((node) => {
      node.check();
      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
    });
    if (from2 === to && isOnlyBlockContent) {
      const { parent } = tr2.doc.resolve(from2);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from2 -= 1;
        to += 1;
      }
    }
    let newContent;
    if (isOnlyTextContent) {
      if (Array.isArray(value)) {
        newContent = value.map((v) => v.text || "").join("");
      } else if (value instanceof Fragment) {
        let text = "";
        value.forEach((node) => {
          if (node.text) {
            text += node.text;
          }
        });
        newContent = text;
      } else if (typeof value === "object" && !!value && !!value.text) {
        newContent = value.text;
      } else {
        newContent = value;
      }
      tr2.insertText(newContent, from2, to);
    } else {
      newContent = content;
      tr2.replaceWith(from2, to, newContent);
    }
    if (options.updateSelection) {
      selectionToInsertionEnd$1(tr2, tr2.steps.length - 1, -1);
    }
    if (options.applyInputRules) {
      tr2.setMeta("applyInputRules", { from: from2, text: newContent });
    }
    if (options.applyPasteRules) {
      tr2.setMeta("applyPasteRules", { from: from2, text: newContent });
    }
  }
  return true;
};
const joinUp$1 = () => ({ state, dispatch }) => {
  return joinUp$2(state, dispatch);
};
const joinDown$1 = () => ({ state, dispatch }) => {
  return joinDown$2(state, dispatch);
};
const joinBackward$1 = () => ({ state, dispatch }) => {
  return joinBackward$2(state, dispatch);
};
const joinForward$1 = () => ({ state, dispatch }) => {
  return joinForward$2(state, dispatch);
};
const joinItemBackward$1 = () => ({ state, dispatch, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, -1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch) {
      dispatch(tr2);
    }
    return true;
  } catch (e2) {
    return false;
  }
};
const joinItemForward$1 = () => ({ state, dispatch, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, 1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch) {
      dispatch(tr2);
    }
    return true;
  } catch (e2) {
    return false;
  }
};
const joinTextblockBackward$1 = () => ({ state, dispatch }) => {
  return joinTextblockBackward$2(state, dispatch);
};
const joinTextblockForward$1 = () => ({ state, dispatch }) => {
  return joinTextblockForward$2(state, dispatch);
};
function isMacOS$1() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName$1(name) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  let alt;
  let ctrl;
  let shift3;
  let meta;
  for (let i = 0; i < parts.length - 1; i += 1) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift3 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS$1() || isMacOS$1()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result = `Alt-${result}`;
  }
  if (ctrl) {
    result = `Ctrl-${result}`;
  }
  if (meta) {
    result = `Meta-${result}`;
  }
  if (shift3) {
    result = `Shift-${result}`;
  }
  return result;
}
const keyboardShortcut$1 = (name) => ({ editor, view, tr: tr2, dispatch }) => {
  const keys2 = normalizeKeyName$1(name).split(/-(?!$)/);
  const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key === "Space" ? " " : key,
    altKey: keys2.includes("Alt"),
    ctrlKey: keys2.includes("Ctrl"),
    metaKey: keys2.includes("Meta"),
    shiftKey: keys2.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f) => f(view, event));
  });
  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
    const newStep = step.map(tr2.mapping);
    if (newStep && dispatch) {
      tr2.maybeStep(newStep);
    }
  });
  return true;
};
function isNodeActive$1(state, typeOrName, attributes = {}) {
  const { from: from2, to, empty: empty2 } = state.selection;
  const type = typeOrName ? getNodeType$1(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isText) {
      return;
    }
    const relativeFrom = Math.max(from2, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from2;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes$1(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty2) {
    return !!matchedNodeRanges.length;
  }
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
const lift$1 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType$1(typeOrName, state.schema);
  const isActive2 = isNodeActive$1(state, type, attributes);
  if (!isActive2) {
    return false;
  }
  return lift$2(state, dispatch);
};
const liftEmptyBlock$1 = () => ({ state, dispatch }) => {
  return liftEmptyBlock$2(state, dispatch);
};
const liftListItem$1 = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType$1(typeOrName, state.schema);
  return liftListItem$2(type)(state, dispatch);
};
const newlineInCode$1 = () => ({ state, dispatch }) => {
  return newlineInCode$2(state, dispatch);
};
function getSchemaTypeNameByName$1(name, schema2) {
  if (schema2.nodes[name]) {
    return "node";
  }
  if (schema2.marks[name]) {
    return "mark";
  }
  return null;
}
function deleteProps$1(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
const resetAttributes$1 = (typeOrName, attributes) => ({ tr: tr2, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName$1(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType$1(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType$1(typeOrName, state.schema);
  }
  if (dispatch) {
    tr2.selection.ranges.forEach((range) => {
      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr2.setNodeMarkup(pos, void 0, deleteProps$1(node.attrs, attributes));
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr2.addMark(pos, pos + node.nodeSize, markType.create(deleteProps$1(mark.attrs, attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
const scrollIntoView$1 = () => ({ tr: tr2, dispatch }) => {
  if (dispatch) {
    tr2.scrollIntoView();
  }
  return true;
};
const selectAll$1 = () => ({ tr: tr2, commands: commands2 }) => {
  return commands2.setTextSelection({
    from: 0,
    to: tr2.doc.content.size
  });
};
const selectNodeBackward$1 = () => ({ state, dispatch }) => {
  return selectNodeBackward$2(state, dispatch);
};
const selectNodeForward$1 = () => ({ state, dispatch }) => {
  return selectNodeForward$2(state, dispatch);
};
const selectParentNode$1 = () => ({ state, dispatch }) => {
  return selectParentNode$2(state, dispatch);
};
const selectTextblockEnd$1 = () => ({ state, dispatch }) => {
  return selectTextblockEnd$2(state, dispatch);
};
const selectTextblockStart$1 = () => ({ state, dispatch }) => {
  return selectTextblockStart$2(state, dispatch);
};
function createDocument$1(content, schema2, parseOptions = {}, options = {}) {
  return createNodeFromContent$1(content, schema2, {
    slice: false,
    parseOptions,
    errorOnInvalidContent: options.errorOnInvalidContent
  });
}
const setContent$2 = (content, emitUpdate = false, parseOptions = {}, options = {}) => ({ editor, tr: tr2, dispatch, commands: commands2 }) => {
  var _a, _b;
  const { doc: doc2 } = tr2;
  if (parseOptions.preserveWhitespace !== "full") {
    const document2 = createDocument$1(content, editor.schema, parseOptions, {
      errorOnInvalidContent: (_a = options.errorOnInvalidContent) !== null && _a !== void 0 ? _a : editor.options.enableContentCheck
    });
    if (dispatch) {
      tr2.replaceWith(0, doc2.content.size, document2).setMeta("preventUpdate", !emitUpdate);
    }
    return true;
  }
  if (dispatch) {
    tr2.setMeta("preventUpdate", !emitUpdate);
  }
  return commands2.insertContentAt({ from: 0, to: doc2.content.size }, content, {
    parseOptions,
    errorOnInvalidContent: (_b = options.errorOnInvalidContent) !== null && _b !== void 0 ? _b : editor.options.enableContentCheck
  });
};
function getMarkAttributes$1(state, typeOrName) {
  const type = getMarkType$1(typeOrName, state.schema);
  const { from: from2, to, empty: empty2 } = state.selection;
  const marks = [];
  if (empty2) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from2, to, (node) => {
      marks.push(...node.marks);
    });
  }
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark) {
    return {};
  }
  return { ...mark.attrs };
}
function combineTransactionSteps(oldDoc, transactions) {
  const transform = new Transform(oldDoc);
  transactions.forEach((transaction) => {
    transaction.steps.forEach((step) => {
      transform.step(step);
    });
  });
  return transform;
}
function defaultBlockAt$1(match2) {
  for (let i = 0; i < match2.edgeCount; i += 1) {
    const { type } = match2.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findChildrenInRange(node, range, predicate) {
  const nodesWithPos = [];
  node.nodesBetween(range.from, range.to, (child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function findParentNodeClosestToPos$1($pos, predicate) {
  for (let i = $pos.depth; i > 0; i -= 1) {
    const node = $pos.node(i);
    if (predicate(node)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node
      };
    }
  }
}
function findParentNode$1(predicate) {
  return (selection) => findParentNodeClosestToPos$1(selection.$from, predicate);
}
function getText(node, options) {
  const range = {
    from: 0,
    to: node.content.size
  };
  return getTextBetween$1(node, range, options);
}
function getNodeAttributes(state, typeOrName) {
  const type = getNodeType$1(typeOrName, state.schema);
  const { from: from2, to } = state.selection;
  const nodes = [];
  state.doc.nodesBetween(from2, to, (node2) => {
    nodes.push(node2);
  });
  const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
  if (!node) {
    return {};
  }
  return { ...node.attrs };
}
function getAttributes(state, typeOrName) {
  const schemaType = getSchemaTypeNameByName$1(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (schemaType === "node") {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes$1(state, typeOrName);
  }
  return {};
}
function removeDuplicates$1(array2, by = JSON.stringify) {
  const seen = {};
  return array2.filter((item) => {
    const key = by(item);
    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
  });
}
function simplifyChangedRanges(changes) {
  const uniqueChanges = removeDuplicates$1(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index2) => {
    const rest = uniqueChanges.filter((_, i) => i !== index2);
    return !rest.some((otherChange) => {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
function getChangedRanges(transform) {
  const { mapping, steps } = transform;
  const changes = [];
  mapping.maps.forEach((stepMap, index2) => {
    const ranges = [];
    if (!stepMap.ranges.length) {
      const { from: from2, to } = steps[index2];
      if (from2 === void 0 || to === void 0) {
        return;
      }
      ranges.push({ from: from2, to });
    } else {
      stepMap.forEach((from2, to) => {
        ranges.push({ from: from2, to });
      });
    }
    ranges.forEach(({ from: from2, to }) => {
      const newStart = mapping.slice(index2).map(from2, -1);
      const newEnd = mapping.slice(index2).map(to);
      const oldStart = mapping.invert().map(newStart, -1);
      const oldEnd = mapping.invert().map(newEnd);
      changes.push({
        oldRange: {
          from: oldStart,
          to: oldEnd
        },
        newRange: {
          from: newStart,
          to: newEnd
        }
      });
    });
  });
  return simplifyChangedRanges(changes);
}
function getMarksBetween$1(from2, to, doc2) {
  const marks = [];
  if (from2 === to) {
    doc2.resolve(from2).marks().forEach((mark) => {
      const $pos = doc2.resolve(from2);
      const range = getMarkRange$1($pos, mark.type);
      if (!range) {
        return;
      }
      marks.push({
        mark,
        ...range
      });
    });
  } else {
    doc2.nodesBetween(from2, to, (node, pos) => {
      if (!node || (node === null || node === void 0 ? void 0 : node.nodeSize) === void 0) {
        return;
      }
      marks.push(...node.marks.map((mark) => ({
        from: pos,
        to: pos + node.nodeSize,
        mark
      })));
    });
  }
  return marks;
}
function getSplittedAttributes$1(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
    const extensionAttribute = extensionAttributes.find((item) => {
      return item.type === typeName && item.name === name;
    });
    if (!extensionAttribute) {
      return false;
    }
    return extensionAttribute.attribute.keepOnSplit;
  }));
}
function isMarkActive$1(state, typeOrName, attributes = {}) {
  const { empty: empty2, ranges } = state.selection;
  const type = typeOrName ? getMarkType$1(typeOrName, state.schema) : null;
  if (empty2) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find((mark) => objectIncludes$1(mark.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from2 = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from2, to, (node, pos) => {
      if (!node.isText && !node.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from2, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(...node.marks.map((mark) => ({
        mark,
        from: relativeFrom,
        to: relativeTo
      })));
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes$1(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function isActive(state, name, attributes = {}) {
  if (!name) {
    return isNodeActive$1(state, null, attributes) || isMarkActive$1(state, null, attributes);
  }
  const schemaType = getSchemaTypeNameByName$1(name, state.schema);
  if (schemaType === "node") {
    return isNodeActive$1(state, name, attributes);
  }
  if (schemaType === "mark") {
    return isMarkActive$1(state, name, attributes);
  }
  return false;
}
function isList$1(name, extensions) {
  const { nodeExtensions } = splitExtensions$1(extensions);
  const extension = nodeExtensions.find((item) => item.name === name);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrReturn$1(getExtensionField$1(extension, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
function isNodeEmpty$1(node, { checkChildren = true, ignoreWhitespace = false } = {}) {
  var _a;
  if (ignoreWhitespace) {
    if (node.type.name === "hardBreak") {
      return true;
    }
    if (node.isText) {
      return /^\s*$/m.test((_a = node.text) !== null && _a !== void 0 ? _a : "");
    }
  }
  if (node.isText) {
    return !node.text;
  }
  if (node.isAtom || node.isLeaf) {
    return false;
  }
  if (node.content.childCount === 0) {
    return true;
  }
  if (checkChildren) {
    let isContentEmpty = true;
    node.content.forEach((childNode) => {
      if (isContentEmpty === false) {
        return;
      }
      if (!isNodeEmpty$1(childNode, { ignoreWhitespace, checkChildren })) {
        isContentEmpty = false;
      }
    });
    return isContentEmpty;
  }
  return false;
}
function isNodeSelection$1(value) {
  return value instanceof NodeSelection;
}
function posToDOMRect(view, from2, to) {
  const minPos = 0;
  const maxPos = view.state.doc.content.size;
  const resolvedFrom = minMax$1(from2, minPos, maxPos);
  const resolvedEnd = minMax$1(to, minPos, maxPos);
  const start2 = view.coordsAtPos(resolvedFrom);
  const end2 = view.coordsAtPos(resolvedEnd, -1);
  const top2 = Math.min(start2.top, end2.top);
  const bottom2 = Math.max(start2.bottom, end2.bottom);
  const left2 = Math.min(start2.left, end2.left);
  const right2 = Math.max(start2.right, end2.right);
  const width = right2 - left2;
  const height = bottom2 - top2;
  const x = left2;
  const y = top2;
  const data = {
    top: top2,
    bottom: bottom2,
    left: left2,
    right: right2,
    width,
    height,
    x,
    y
  };
  return {
    ...data,
    toJSON: () => data
  };
}
function canSetMark$1(state, tr2, newMarkType) {
  var _a;
  const { selection } = tr2;
  let cursor = null;
  if (isTextSelection$1(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
  }
  const { ranges } = selection;
  return ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
const setMark$1 = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
  const { selection } = tr2;
  const { empty: empty2, ranges } = selection;
  const type = getMarkType$1(typeOrName, state.schema);
  if (dispatch) {
    if (empty2) {
      const oldAttributes = getMarkAttributes$1(state, type);
      tr2.addStoredMark(type.create({
        ...oldAttributes,
        ...attributes
      }));
    } else {
      ranges.forEach((range) => {
        const from2 = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from2, to, (node, pos) => {
          const trimmedFrom = Math.max(pos, from2);
          const trimmedTo = Math.min(pos + node.nodeSize, to);
          const someHasMark = node.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node.marks.forEach((mark) => {
              if (type === mark.type) {
                tr2.addMark(trimmedFrom, trimmedTo, type.create({
                  ...mark.attrs,
                  ...attributes
                }));
              }
            });
          } else {
            tr2.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark$1(state, tr2, type);
};
const setMeta$1 = (key, value) => ({ tr: tr2 }) => {
  tr2.setMeta(key, value);
  return true;
};
const setNode$1 = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {
  const type = getNodeType$1(typeOrName, state.schema);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain().command(({ commands: commands2 }) => {
    const canSetBlock = setBlockType(type, { ...attributesToCopy, ...attributes })(state);
    if (canSetBlock) {
      return true;
    }
    return commands2.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch);
  }).run();
};
const setNodeSelection$1 = (position2) => ({ tr: tr2, dispatch }) => {
  if (dispatch) {
    const { doc: doc2 } = tr2;
    const from2 = minMax$1(position2, 0, doc2.content.size);
    const selection = NodeSelection.create(doc2, from2);
    tr2.setSelection(selection);
  }
  return true;
};
const setTextSelection$1 = (position2) => ({ tr: tr2, dispatch }) => {
  if (dispatch) {
    const { doc: doc2 } = tr2;
    const { from: from2, to } = typeof position2 === "number" ? { from: position2, to: position2 } : position2;
    const minPos = TextSelection.atStart(doc2).from;
    const maxPos = TextSelection.atEnd(doc2).to;
    const resolvedFrom = minMax$1(from2, minPos, maxPos);
    const resolvedEnd = minMax$1(to, minPos, maxPos);
    const selection = TextSelection.create(doc2, resolvedFrom, resolvedEnd);
    tr2.setSelection(selection);
  }
  return true;
};
const sinkListItem$1 = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType$1(typeOrName, state.schema);
  return sinkListItem$2(type)(state, dispatch);
};
function ensureMarks$1(state, splittableMarks) {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
const splitBlock$1 = ({ keepMarks = true } = {}) => ({ tr: tr2, state, dispatch, editor }) => {
  const { selection, doc: doc2 } = tr2;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes$1(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc2, $from.pos)) {
      return false;
    }
    if (dispatch) {
      if (keepMarks) {
        ensureMarks$1(state, editor.extensionManager.splittableMarks);
      }
      tr2.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  const atEnd = $to.parentOffset === $to.parent.content.size;
  const deflt = $from.depth === 0 ? void 0 : defaultBlockAt$1($from.node(-1).contentMatchAt($from.indexAfter(-1)));
  let types = atEnd && deflt ? [
    {
      type: deflt,
      attrs: newAttributes
    }
  ] : void 0;
  let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types);
  if (!types && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
    can = true;
    types = deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : void 0;
  }
  if (dispatch) {
    if (can) {
      if (selection instanceof TextSelection) {
        tr2.deleteSelection();
      }
      tr2.split(tr2.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr2.mapping.map($from.before());
        const $first = tr2.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks$1(state, editor.extensionManager.splittableMarks);
    }
    tr2.scrollIntoView();
  }
  return can;
};
const splitListItem$1 = (typeOrName, overrideAttrs = {}) => ({ tr: tr2, state, dispatch, editor }) => {
  var _a;
  const type = getNodeType$1(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node = state.selection.node;
  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch) {
      let wrap2 = Fragment.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
        wrap2 = Fragment.from($from.node(d).copy(wrap2));
      }
      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
      const newNextTypeAttributes2 = {
        ...getSplittedAttributes$1(extensionAttributes, $from.node().type.name, $from.node().attrs),
        ...overrideAttrs
      };
      const nextType2 = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
      const start2 = $from.before($from.depth - (depthBefore - 1));
      tr2.replace(start2, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
      let sel = -1;
      tr2.doc.nodesBetween(start2, tr2.doc.content.size, (n2, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n2.isTextblock && n2.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr2.setSelection(TextSelection.near(tr2.doc.resolve(sel)));
      }
      tr2.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = {
    ...getSplittedAttributes$1(extensionAttributes, grandParent.type.name, grandParent.attrs),
    ...overrideAttrs
  };
  const newNextTypeAttributes = {
    ...getSplittedAttributes$1(extensionAttributes, $from.node().type.name, $from.node().attrs),
    ...overrideAttrs
  };
  tr2.delete($from.pos, $to.pos);
  const types = nextType ? [
    { type, attrs: newTypeAttributes },
    { type: nextType, attrs: newNextTypeAttributes }
  ] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr2.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch) {
    const { selection, storedMarks } = state;
    const { splittableMarks } = editor.extensionManager;
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    tr2.split($from.pos, 2, types).scrollIntoView();
    if (!marks || !dispatch) {
      return true;
    }
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
  }
  return true;
};
const joinListBackwards$1 = (tr2, listType) => {
  const list = findParentNode$1((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const before = tr2.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before === void 0) {
    return true;
  }
  const nodeBefore = tr2.doc.nodeAt(before);
  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr2.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr2.join(list.pos);
  return true;
};
const joinListForwards$1 = (tr2, listType) => {
  const list = findParentNode$1((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const after = tr2.doc.resolve(list.start).after(list.depth);
  if (after === void 0) {
    return true;
  }
  const nodeAfter = tr2.doc.nodeAt(after);
  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr2.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr2.join(after);
  return true;
};
const toggleList$1 = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr: tr2, state, dispatch, chain, commands: commands2, can }) => {
  const { extensions, splittableMarks } = editor.extensionManager;
  const listType = getNodeType$1(listTypeOrName, state.schema);
  const itemType = getNodeType$1(itemTypeOrName, state.schema);
  const { selection, storedMarks } = state;
  const { $from, $to } = selection;
  const range = $from.blockRange($to);
  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
  if (!range) {
    return false;
  }
  const parentList = findParentNode$1((node) => isList$1(node.type.name, extensions))(selection);
  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands2.liftListItem(itemType);
    }
    if (isList$1(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {
      return chain().command(() => {
        tr2.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards$1(tr2, listType)).command(() => joinListForwards$1(tr2, listType)).run();
    }
  }
  if (!keepMarks || !marks || !dispatch) {
    return chain().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      if (canWrapInList) {
        return true;
      }
      return commands2.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards$1(tr2, listType)).command(() => joinListForwards$1(tr2, listType)).run();
  }
  return chain().command(() => {
    const canWrapInList = can().wrapInList(listType, attributes);
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
    if (canWrapInList) {
      return true;
    }
    return commands2.clearNodes();
  }).wrapInList(listType, attributes).command(() => joinListBackwards$1(tr2, listType)).command(() => joinListForwards$1(tr2, listType)).run();
};
const toggleMark$1 = (typeOrName, attributes = {}, options = {}) => ({ state, commands: commands2 }) => {
  const { extendEmptyMarkRange = false } = options;
  const type = getMarkType$1(typeOrName, state.schema);
  const isActive2 = isMarkActive$1(state, type, attributes);
  if (isActive2) {
    return commands2.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands2.setMark(type, attributes);
};
const toggleNode$1 = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType$1(typeOrName, state.schema);
  const toggleType = getNodeType$1(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive$1(state, type, attributes);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (isActive2) {
    return commands2.setNode(toggleType, attributesToCopy);
  }
  return commands2.setNode(type, { ...attributesToCopy, ...attributes });
};
const toggleWrap$1 = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType$1(typeOrName, state.schema);
  const isActive2 = isNodeActive$1(state, type, attributes);
  if (isActive2) {
    return commands2.lift(type);
  }
  return commands2.wrapIn(type, attributes);
};
const undoInputRule$1 = () => ({ state, dispatch }) => {
  const plugins = state.plugins;
  for (let i = 0; i < plugins.length; i += 1) {
    const plugin = plugins[i];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch) {
        const tr2 = state.tr;
        const toUndo = undoable.transform;
        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
          tr2.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          const marks = tr2.doc.resolve(undoable.from).marks();
          tr2.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr2.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
const unsetAllMarks$1 = () => ({ tr: tr2, dispatch }) => {
  const { selection } = tr2;
  const { empty: empty2, ranges } = selection;
  if (empty2) {
    return true;
  }
  if (dispatch) {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos);
    });
  }
  return true;
};
const unsetMark$1 = (typeOrName, options = {}) => ({ tr: tr2, state, dispatch }) => {
  var _a;
  const { extendEmptyMarkRange = false } = options;
  const { selection } = tr2;
  const type = getMarkType$1(typeOrName, state.schema);
  const { $from, empty: empty2, ranges } = selection;
  if (!dispatch) {
    return true;
  }
  if (empty2 && extendEmptyMarkRange) {
    let { from: from2, to } = selection;
    const attrs2 = (_a = $from.marks().find((mark) => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;
    const range = getMarkRange$1($from, type, attrs2);
    if (range) {
      from2 = range.from;
      to = range.to;
    }
    tr2.removeMark(from2, to, type);
  } else {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos, type);
    });
  }
  tr2.removeStoredMark(type);
  return true;
};
const updateAttributes$1 = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName$1(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType$1(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType$1(typeOrName, state.schema);
  }
  if (dispatch) {
    tr2.selection.ranges.forEach((range) => {
      const from2 = range.$from.pos;
      const to = range.$to.pos;
      let lastPos;
      let lastNode;
      let trimmedFrom;
      let trimmedTo;
      if (tr2.selection.empty) {
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from2);
            trimmedTo = Math.min(pos + node.nodeSize, to);
            lastPos = pos;
            lastNode = node;
          }
        });
      } else {
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (pos < from2 && nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from2);
            trimmedTo = Math.min(pos + node.nodeSize, to);
            lastPos = pos;
            lastNode = node;
          }
          if (pos >= from2 && pos <= to) {
            if (nodeType && nodeType === node.type) {
              tr2.setNodeMarkup(pos, void 0, {
                ...node.attrs,
                ...attributes
              });
            }
            if (markType && node.marks.length) {
              node.marks.forEach((mark) => {
                if (markType === mark.type) {
                  const trimmedFrom2 = Math.max(pos, from2);
                  const trimmedTo2 = Math.min(pos + node.nodeSize, to);
                  tr2.addMark(trimmedFrom2, trimmedTo2, markType.create({
                    ...mark.attrs,
                    ...attributes
                  }));
                }
              });
            }
          }
        });
      }
      if (lastNode) {
        if (lastPos !== void 0) {
          tr2.setNodeMarkup(lastPos, void 0, {
            ...lastNode.attrs,
            ...attributes
          });
        }
        if (markType && lastNode.marks.length) {
          lastNode.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr2.addMark(trimmedFrom, trimmedTo, markType.create({
                ...mark.attrs,
                ...attributes
              }));
            }
          });
        }
      }
    });
  }
  return true;
};
const wrapIn$1 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType$1(typeOrName, state.schema);
  return wrapIn$2(type, attributes)(state, dispatch);
};
const wrapInList$1 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType$1(typeOrName, state.schema);
  return wrapInList$2(type, attributes)(state, dispatch);
};
var commands$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur: blur$1,
  clearContent: clearContent$1,
  clearNodes: clearNodes$1,
  command: command$1,
  createParagraphNear: createParagraphNear$1,
  cut: cut$1,
  deleteCurrentNode: deleteCurrentNode$1,
  deleteNode: deleteNode$1,
  deleteRange: deleteRange$1,
  deleteSelection: deleteSelection$1,
  enter: enter$1,
  exitCode: exitCode$1,
  extendMarkRange: extendMarkRange$1,
  first: first$1,
  focus: focus$1,
  forEach: forEach$1,
  insertContent: insertContent$1,
  insertContentAt: insertContentAt$1,
  joinBackward: joinBackward$1,
  joinDown: joinDown$1,
  joinForward: joinForward$1,
  joinItemBackward: joinItemBackward$1,
  joinItemForward: joinItemForward$1,
  joinTextblockBackward: joinTextblockBackward$1,
  joinTextblockForward: joinTextblockForward$1,
  joinUp: joinUp$1,
  keyboardShortcut: keyboardShortcut$1,
  lift: lift$1,
  liftEmptyBlock: liftEmptyBlock$1,
  liftListItem: liftListItem$1,
  newlineInCode: newlineInCode$1,
  resetAttributes: resetAttributes$1,
  scrollIntoView: scrollIntoView$1,
  selectAll: selectAll$1,
  selectNodeBackward: selectNodeBackward$1,
  selectNodeForward: selectNodeForward$1,
  selectParentNode: selectParentNode$1,
  selectTextblockEnd: selectTextblockEnd$1,
  selectTextblockStart: selectTextblockStart$1,
  setContent: setContent$2,
  setMark: setMark$1,
  setMeta: setMeta$1,
  setNode: setNode$1,
  setNodeSelection: setNodeSelection$1,
  setTextSelection: setTextSelection$1,
  sinkListItem: sinkListItem$1,
  splitBlock: splitBlock$1,
  splitListItem: splitListItem$1,
  toggleList: toggleList$1,
  toggleMark: toggleMark$1,
  toggleNode: toggleNode$1,
  toggleWrap: toggleWrap$1,
  undoInputRule: undoInputRule$1,
  unsetAllMarks: unsetAllMarks$1,
  unsetMark: unsetMark$1,
  updateAttributes: updateAttributes$1,
  wrapIn: wrapIn$1,
  wrapInList: wrapInList$1
});
const Commands = Extension$1.create({
  name: "commands",
  addCommands() {
    return {
      ...commands$1
    };
  }
});
const Drop = Extension$1.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapDrop"),
        props: {
          handleDrop: (_, e2, slice2, moved) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e2,
              slice: slice2,
              moved
            });
          }
        }
      })
    ];
  }
});
const Editable = Extension$1.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
const FocusEvents = Extension$1.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: new PluginKey("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            }
          }
        }
      })
    ];
  }
});
const Keymap = Extension$1.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.undoInputRule(),
      // maybe convert first text block node to default node
      () => commands2.command(({ tr: tr2 }) => {
        const { selection, doc: doc2 } = tr2;
        const { empty: empty2, $anchor } = selection;
        const { pos, parent } = $anchor;
        const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr2.doc.resolve(pos - 1) : $anchor;
        const parentIsIsolating = $parentPos.parent.type.spec.isolating;
        const parentPos = $anchor.pos - $anchor.parentOffset;
        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc2).from === pos;
        if (!empty2 || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
          return false;
        }
        return commands2.clearNodes();
      }),
      () => commands2.deleteSelection(),
      () => commands2.joinBackward(),
      () => commands2.selectNodeBackward()
    ]);
    const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.deleteSelection(),
      () => commands2.deleteCurrentNode(),
      () => commands2.joinForward(),
      () => commands2.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.newlineInCode(),
      () => commands2.createParagraphNear(),
      () => commands2.liftEmptyBlock(),
      () => commands2.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace,
      "Mod-Backspace": handleBackspace,
      "Shift-Backspace": handleBackspace,
      Delete: handleDelete,
      "Mod-Delete": handleDelete,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = {
      ...baseKeymap
    };
    const macKeymap = {
      ...baseKeymap,
      "Ctrl-h": handleBackspace,
      "Alt-Backspace": handleBackspace,
      "Ctrl-d": handleDelete,
      "Ctrl-Alt-Backspace": handleDelete,
      "Alt-Delete": handleDelete,
      "Alt-d": handleDelete,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    if (isiOS$1() || isMacOS$1()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
      // with many other commands.
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
          const ignoreTr = transactions.some((transaction) => transaction.getMeta("preventClearDocument"));
          if (!docChanges || ignoreTr) {
            return;
          }
          const { empty: empty2, from: from2, to } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from2 === allFrom && to === allEnd;
          if (empty2 || !allWasSelected) {
            return;
          }
          const isEmpty = isNodeEmpty$1(newState.doc);
          if (!isEmpty) {
            return;
          }
          const tr2 = newState.tr;
          const state = createChainableState$1({
            state: newState,
            transaction: tr2
          });
          const { commands: commands2 } = new CommandManager$1({
            editor: this.editor,
            state
          });
          commands2.clearNodes();
          if (!tr2.steps.length) {
            return;
          }
          return tr2;
        }
      })
    ];
  }
});
const Paste = Extension$1.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapPaste"),
        props: {
          handlePaste: (_view, e2, slice2) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e2,
              slice: slice2
            });
          }
        }
      })
    ];
  }
});
const Tabindex = Extension$1.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ClipboardTextSerializer,
  Commands,
  Drop,
  Editable,
  FocusEvents,
  Keymap,
  Paste,
  Tabindex
});
class NodePos {
  get name() {
    return this.node.type.name;
  }
  constructor(pos, editor, isBlock = false, node = null) {
    this.currentNode = null;
    this.actualDepth = null;
    this.isBlock = isBlock;
    this.resolvedPos = pos;
    this.editor = editor;
    this.currentNode = node;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var _a;
    return (_a = this.actualDepth) !== null && _a !== void 0 ? _a : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(content) {
    let from2 = this.from;
    let to = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      from2 = this.from + 1;
      to = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: from2, to }, content);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    if (this.isBlock) {
      return this.pos;
    }
    return this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    if (this.isBlock) {
      return this.pos + this.size;
    }
    return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0) {
      return null;
    }
    const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
    const $pos = this.resolvedPos.doc.resolve(parentPos);
    return new NodePos($pos, this.editor);
  }
  get before() {
    let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.from - 3);
    }
    return new NodePos($pos, this.editor);
  }
  get after() {
    let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.to + 3);
    }
    return new NodePos($pos, this.editor);
  }
  get children() {
    const children = [];
    this.node.content.forEach((node, offset3) => {
      const isBlock = node.isBlock && !node.isTextblock;
      const isNonTextAtom = node.isAtom && !node.isText;
      const targetPos = this.pos + offset3 + (isNonTextAtom ? 0 : 1);
      const $pos = this.resolvedPos.doc.resolve(targetPos);
      if (!isBlock && $pos.depth <= this.depth) {
        return;
      }
      const childNodePos = new NodePos($pos, this.editor, isBlock, isBlock ? node : null);
      if (isBlock) {
        childNodePos.actualDepth = this.depth + 1;
      }
      children.push(new NodePos($pos, this.editor, isBlock, isBlock ? node : null));
    });
    return children;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const children = this.children;
    return children[children.length - 1] || null;
  }
  closest(selector, attributes = {}) {
    let node = null;
    let currentNode = this.parent;
    while (currentNode && !node) {
      if (currentNode.node.type.name === selector) {
        if (Object.keys(attributes).length > 0) {
          const nodeAttributes = currentNode.node.attrs;
          const attrKeys = Object.keys(attributes);
          for (let index2 = 0; index2 < attrKeys.length; index2 += 1) {
            const key = attrKeys[index2];
            if (nodeAttributes[key] !== attributes[key]) {
              break;
            }
          }
        } else {
          node = currentNode;
        }
      }
      currentNode = currentNode.parent;
    }
    return node;
  }
  querySelector(selector, attributes = {}) {
    return this.querySelectorAll(selector, attributes, true)[0] || null;
  }
  querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
    let nodes = [];
    if (!this.children || this.children.length === 0) {
      return nodes;
    }
    const attrKeys = Object.keys(attributes);
    this.children.forEach((childPos) => {
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      if (childPos.node.type.name === selector) {
        const doesAllAttributesMatch = attrKeys.every((key) => attributes[key] === childPos.node.attrs[key]);
        if (doesAllAttributesMatch) {
          nodes.push(childPos);
        }
      }
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));
    });
    return nodes;
  }
  setAttribute(attributes) {
    const { tr: tr2 } = this.editor.state;
    tr2.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...attributes
    });
    this.editor.view.dispatch(tr2);
  }
}
const style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function createStyleTag(style2, nonce, suffix) {
  const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${""}]`);
  if (tiptapStyleTag !== null) {
    return tiptapStyleTag;
  }
  const styleNode = document.createElement("style");
  if (nonce) {
    styleNode.setAttribute("nonce", nonce);
  }
  styleNode.setAttribute(`data-tiptap-style${""}`, "");
  styleNode.innerHTML = style2;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
}
class Editor extends EventEmitter {
  constructor(options = {}) {
    super();
    this.isFocused = false;
    this.isInitialized = false;
    this.extensionStorage = {};
    this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: true,
      injectNonce: void 0,
      extensions: [],
      autofocus: false,
      editable: true,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      enableContentCheck: false,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error }) => {
        throw error;
      },
      onPaste: () => null,
      onDrop: () => null
    };
    this.isCapturingTransaction = false;
    this.capturedTransaction = null;
    this.setOptions(options);
    this.createExtensionManager();
    this.createCommandManager();
    this.createSchema();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.on("contentError", this.options.onContentError);
    this.createView();
    this.injectCSS();
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.options.onFocus);
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    this.on("drop", ({ event, slice: slice2, moved }) => this.options.onDrop(event, slice2, moved));
    this.on("paste", ({ event, slice: slice2 }) => this.options.onPaste(event, slice2));
    window.setTimeout(() => {
      if (this.isDestroyed) {
        return;
      }
      this.commands.focus(this.options.autofocus);
      this.emit("create", { editor: this });
      this.isInitialized = true;
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    if (this.options.injectCSS && document) {
      this.css = createStyleTag(style, this.options.injectNonce);
    }
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(options = {}) {
    this.options = {
      ...this.options,
      ...options
    };
    if (!this.view || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(editable, emitUpdate = true) {
    this.setOptions({ editable });
    if (emitUpdate) {
      this.emit("update", { editor: this, transaction: this.state.tr });
    }
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(plugin, handlePlugins) {
    const plugins = isFunction$1(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
    const state = this.state.reconfigure({ plugins });
    this.view.updateState(state);
    return state;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(nameOrPluginKeyToRemove) {
    if (this.isDestroyed) {
      return void 0;
    }
    const prevPlugins = this.state.plugins;
    let plugins = prevPlugins;
    [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey) => {
      const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
      plugins = prevPlugins.filter((plugin) => !plugin.key.startsWith(name));
    });
    if (prevPlugins.length === plugins.length) {
      return void 0;
    }
    const state = this.state.reconfigure({
      plugins
    });
    this.view.updateState(state);
    return state;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var _a, _b;
    const coreExtensions = this.options.enableCoreExtensions ? [
      Editable,
      ClipboardTextSerializer.configure({
        blockSeparator: (_b = (_a = this.options.coreExtensionOptions) === null || _a === void 0 ? void 0 : _a.clipboardTextSerializer) === null || _b === void 0 ? void 0 : _b.blockSeparator
      }),
      Commands,
      FocusEvents,
      Keymap,
      Tabindex,
      Drop,
      Paste
    ].filter((ext) => {
      if (typeof this.options.enableCoreExtensions === "object") {
        return this.options.enableCoreExtensions[ext.name] !== false;
      }
      return true;
    }) : [];
    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
      return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
    });
    this.extensionManager = new ExtensionManager(allExtensions, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new CommandManager$1({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    var _a;
    let doc2;
    try {
      doc2 = createDocument$1(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
    } catch (e2) {
      if (!(e2 instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e2.message)) {
        throw e2;
      }
      this.emit("contentError", {
        editor: this,
        error: e2,
        disableCollaboration: () => {
          if (this.storage.collaboration) {
            this.storage.collaboration.isDisabled = true;
          }
          this.options.extensions = this.options.extensions.filter((extension) => extension.name !== "collaboration");
          this.createExtensionManager();
        }
      });
      doc2 = createDocument$1(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: false });
    }
    const selection = resolveFocusPosition$1(doc2, this.options.autofocus);
    this.view = new EditorView(this.options.element, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(_a = this.options.editorProps) === null || _a === void 0 ? void 0 : _a.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: EditorState.create({
        doc: doc2,
        selection: selection || void 0
      })
    });
    const newState = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(newState);
    this.createNodeViews();
    this.prependClass();
    const dom = this.view.dom;
    dom.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    if (this.view.isDestroyed) {
      return;
    }
    this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(fn2) {
    this.isCapturingTransaction = true;
    fn2();
    this.isCapturingTransaction = false;
    const tr2 = this.capturedTransaction;
    this.capturedTransaction = null;
    return tr2;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(transaction) {
    if (this.view.isDestroyed) {
      return;
    }
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = transaction;
        return;
      }
      transaction.steps.forEach((step) => {
        var _a;
        return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);
      });
      return;
    }
    const state = this.state.apply(transaction);
    const selectionHasChanged = !this.state.selection.eq(state.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction,
      nextState: state
    });
    this.view.updateState(state);
    this.emit("transaction", {
      editor: this,
      transaction
    });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", {
        editor: this,
        transaction
      });
    }
    const focus2 = transaction.getMeta("focus");
    const blur2 = transaction.getMeta("blur");
    if (focus2) {
      this.emit("focus", {
        editor: this,
        event: focus2.event,
        transaction
      });
    }
    if (blur2) {
      this.emit("blur", {
        editor: this,
        event: blur2.event,
        transaction
      });
    }
    if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
      return;
    }
    this.emit("update", {
      editor: this,
      transaction
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(nameOrType) {
    return getAttributes(this.state, nameOrType);
  }
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return getHTMLFromFragment(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(options) {
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    return getText(this.state.doc, {
      blockSeparator,
      textSerializers: {
        ...getTextSerializersFromSchema$1(this.schema),
        ...textSerializers
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return isNodeEmpty$1(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
    return this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy");
    if (this.view) {
      const dom = this.view.dom;
      if (dom && dom.editor) {
        delete dom.editor;
      }
      this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var _a;
    return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);
  }
  $node(selector, attributes) {
    var _a;
    return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelector(selector, attributes)) || null;
  }
  $nodes(selector, attributes) {
    var _a;
    return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selector, attributes)) || null;
  }
  $pos(pos) {
    const $pos = this.state.doc.resolve(pos);
    return new NodePos($pos, this);
  }
  get $doc() {
    return this.$pos(0);
  }
}
function markInputRule$1(config) {
  return new InputRule$1({
    find: config.find,
    handler: ({ state, range, match: match2 }) => {
      const attributes = callOrReturn$1(config.getAttributes, void 0, match2);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match2[match2.length - 1];
      const fullMatch = match2[0];
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween$1(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        const markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    }
  });
}
function nodeInputRule$1(config) {
  return new InputRule$1({
    find: config.find,
    handler: ({ state, range, match: match2 }) => {
      const attributes = callOrReturn$1(config.getAttributes, void 0, match2) || {};
      const { tr: tr2 } = state;
      const start2 = range.from;
      let end2 = range.to;
      const newNode = config.type.create(attributes);
      if (match2[1]) {
        const offset3 = match2[0].lastIndexOf(match2[1]);
        let matchStart = start2 + offset3;
        if (matchStart > end2) {
          matchStart = end2;
        } else {
          end2 = matchStart + match2[1].length;
        }
        const lastChar = match2[0][match2[0].length - 1];
        tr2.insertText(lastChar, start2 + match2[0].length - 1);
        tr2.replaceWith(matchStart, end2, newNode);
      } else if (match2[0]) {
        const insertionStart = config.type.isInline ? start2 : start2 - 1;
        tr2.insert(insertionStart, config.type.create(attributes)).delete(tr2.mapping.map(start2), tr2.mapping.map(end2));
      }
      tr2.scrollIntoView();
    }
  });
}
function textblockTypeInputRule$1(config) {
  return new InputRule$1({
    find: config.find,
    handler: ({ state, range, match: match2 }) => {
      const $start = state.doc.resolve(range.from);
      const attributes = callOrReturn$1(config.getAttributes, void 0, match2) || {};
      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
        return null;
      }
      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
    }
  });
}
function wrappingInputRule$1(config) {
  return new InputRule$1({
    find: config.find,
    handler: ({ state, range, match: match2, chain }) => {
      const attributes = callOrReturn$1(config.getAttributes, void 0, match2) || {};
      const tr2 = state.tr.delete(range.from, range.to);
      const $start = tr2.doc.resolve(range.from);
      const blockRange = $start.blockRange();
      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
      if (!wrapping) {
        return null;
      }
      tr2.wrap(blockRange, wrapping);
      if (config.keepMarks && config.editor) {
        const { selection, storedMarks } = state;
        const { splittableMarks } = config.editor.extensionManager;
        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        if (marks) {
          const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
          tr2.ensureMarks(filteredMarks);
        }
      }
      if (config.keepAttributes) {
        const nodeType = config.type.name === "bulletList" || config.type.name === "orderedList" ? "listItem" : "taskList";
        chain().updateAttributes(nodeType, attributes).run();
      }
      const before = tr2.doc.resolve(range.from - 1).nodeBefore;
      if (before && before.type === config.type && canJoin(tr2.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match2, before))) {
        tr2.join(range.from - 1);
      }
    }
  });
}
let Node$2 = class Node3 {
  constructor(config = {}) {
    this.type = "node";
    this.name = "node";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn$1(getExtensionField$1(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn$1(getExtensionField$1(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Node3(config);
  }
  configure(options = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep$2(this.options, options);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Node3(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn$1(getExtensionField$1(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn$1(getExtensionField$1(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
};
function markPasteRule$1(config) {
  return new PasteRule$1({
    find: config.find,
    handler: ({ state, range, match: match2, pasteEvent }) => {
      const attributes = callOrReturn$1(config.getAttributes, void 0, match2, pasteEvent);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match2[match2.length - 1];
      const fullMatch = match2[0];
      let markEnd = range.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween$1(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    }
  });
}
function escapeForRegEx(string2) {
  return string2.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument2 = node.ownerDocument;
    return ownerDocument2 ? ownerDocument2.defaultView || window : window;
  }
  return node;
}
function isElement$1(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style2 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style3, property2) {
        style3[property2] = "";
        return style3;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement$1(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect2 = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect2.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect2.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement$1(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect2.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect2.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect2.width / scaleX;
  var height = clientRect2.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}
function getLayoutRect(element) {
  var clientRect2 = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect2.width - width) <= 1) {
    width = clientRect2.width;
  }
  if (Math.abs(clientRect2.height - height) <= 1) {
    height = clientRect2.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement$1(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$1(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow$1(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement$1(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset3 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset3, _state$modifiersData$.centerOffset = offset3 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
const arrow$2 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow$1,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position2 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position2
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement$1(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll2 = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll2) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll2) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement$1(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement$1(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset3 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset3[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement$1(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b) {
    return overflows[a2] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement$1(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement$1(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement$1(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement$1(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset3) {
  var basePlacement = getBasePlacement$1(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset3 === "function" ? offset3(Object.assign({}, rects, {
    placement
  })) : offset3, skidding = _ref[0], distance2 = _ref[1];
  skidding = skidding || 0;
  distance2 = (distance2 || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance2,
    y: skidding
  } : {
    x: skidding,
    y: distance2
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset3 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset3);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
const offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement$1(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset3 = popperOffsets2[mainAxis];
    var min$1 = offset3 + overflow[mainSide];
    var max$1 = offset3 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset3 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset3 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset3, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset3;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll2 = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll2.scrollLeft - offsets.x,
    y: rect.top + scroll2.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers2) {
  var map3 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers2.forEach(function(modifier) {
    map3.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map3.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers2.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers2) {
  var orderedModifiers = order(modifiers2);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce$2(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers2) {
  var merged = modifiers2.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options2);
        state.scrollParents = {
          reference: isElement$1(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce$2(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect3 = _ref.effect;
        if (typeof effect3 === "function") {
          var cleanupFn = effect3({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$2, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
  return document.body;
};
function getValueAtIndexOrReturn(value, index2, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index2];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index2] : defaultValue : v;
  }
  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === "function" ? value.apply(void 0, args) : value;
}
function debounce$1(fn5, ms2) {
  if (ms2 === 0) {
    return fn5;
  }
  var timeout2;
  return function(arg) {
    clearTimeout(timeout2);
    timeout2 = setTimeout(function() {
      fn5(arg);
    }, ms2);
  };
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function(item, index2) {
    return arr.indexOf(item) === index2;
  });
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function(acc, key) {
    if (obj[key] !== void 0) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}
function div() {
  return document.createElement("div");
}
function isElement(value) {
  return ["Element", "Fragment"].some(function(type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, "NodeList");
}
function isMouseEvent(value) {
  return isType(value, "MouseEvent");
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement(value)) {
    return [value];
  }
  if (isNodeList(value)) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function(el2) {
    if (el2) {
      el2.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function(el2) {
    if (el2) {
      el2.setAttribute("data-state", state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;
  var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
  return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX, clientY = event.clientY;
  return popperTreeData.every(function(_ref) {
    var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement(popperState.placement);
    var offsetData = popperState.modifiersData.offset;
    if (!offsetData) {
      return true;
    }
    var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
    var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
    box[method](event, listener);
  });
}
function actualContains(parent, child) {
  var target = child;
  while (target) {
    var _target$getRootNode;
    if (parent.contains(target)) {
      return true;
    }
    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
  }
  return false;
}
var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }
  currentInput.isTouch = true;
  if (window.performance) {
    document.addEventListener("mousemove", onDocumentMouseMove);
  }
}
function onDocumentMouseMove() {
  var now2 = performance.now();
  if (now2 - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener("mousemove", onDocumentMouseMove);
  }
  lastMouseMoveTime = now2;
}
function onWindowBlur() {
  var activeElement = document.activeElement;
  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;
    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener("blur", onWindowBlur);
}
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
var isIE11 = isBrowser ? (
  // @ts-ignore
  !!window.msCrypto
) : false;
var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: "fade",
  arrow: true,
  content: "",
  inertia: false,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: TIPPY_DEFAULT_APPEND_TO,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {
  },
  onBeforeUpdate: function onBeforeUpdate() {
  },
  onCreate: function onCreate() {
  },
  onDestroy: function onDestroy() {
  },
  onHidden: function onHidden() {
  },
  onHide: function onHide() {
  },
  onMount: function onMount() {
  },
  onShow: function onShow() {
  },
  onShown: function onShown() {
  },
  onTrigger: function onTrigger() {
  },
  onUntrigger: function onUntrigger() {
  },
  onClickOutside: function onClickOutside() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: "mouseenter focus",
  triggerTarget: null
}, pluginProps, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps2(partialProps) {
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps2 = plugins.reduce(function(acc, plugin) {
    var name = plugin.name, defaultValue = plugin.defaultValue;
    if (name) {
      var _name;
      acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
    }
    return acc;
  }, {});
  return Object.assign({}, passedProps, pluginProps2);
}
function getDataAttributeProps(reference2, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function(acc, key) {
    var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
    if (!valueAsString) {
      return acc;
    }
    if (key === "content") {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e2) {
        acc[key] = valueAsString;
      }
    }
    return acc;
  }, {});
  return props;
}
function evaluateProps(reference2, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference2])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, out.aria);
  out.aria = {
    expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
    content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
  };
  return out;
}
var innerHTML = function innerHTML2() {
  return "innerHTML";
};
function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}
function createArrowElement(value) {
  var arrow2 = div();
  if (value === true) {
    arrow2.className = ARROW_CLASS;
  } else {
    arrow2.className = SVG_ARROW_CLASS;
    if (isElement(value)) {
      arrow2.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow2, value);
    }
  }
  return arrow2;
}
function setContent$1(content, props) {
  if (isElement(props.content)) {
    dangerouslySetInnerHTML(content, "");
    content.appendChild(props.content);
  } else if (typeof props.content !== "function") {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content, props.content);
    } else {
      content.textContent = props.content;
    }
  }
}
function getChildren(popper2) {
  var box = popper2.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box,
    content: boxChildren.find(function(node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function(node) {
      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function(node) {
      return node.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render(instance) {
  var popper2 = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute("data-state", "hidden");
  box.setAttribute("tabindex", "-1");
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute("data-state", "hidden");
  setContent$1(content, instance.props);
  popper2.appendChild(box);
  box.appendChild(content);
  onUpdate(instance.props, instance.props);
  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper2), box2 = _getChildren.box, content2 = _getChildren.content, arrow2 = _getChildren.arrow;
    if (nextProps.theme) {
      box2.setAttribute("data-theme", nextProps.theme);
    } else {
      box2.removeAttribute("data-theme");
    }
    if (typeof nextProps.animation === "string") {
      box2.setAttribute("data-animation", nextProps.animation);
    } else {
      box2.removeAttribute("data-animation");
    }
    if (nextProps.inertia) {
      box2.setAttribute("data-inertia", "");
    } else {
      box2.removeAttribute("data-inertia");
    }
    box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
    if (nextProps.role) {
      box2.setAttribute("role", nextProps.role);
    } else {
      box2.removeAttribute("role");
    }
    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent$1(content2, instance.props);
    }
    if (nextProps.arrow) {
      if (!arrow2) {
        box2.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box2.removeChild(arrow2);
        box2.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow2) {
      box2.removeChild(arrow2);
    }
  }
  return {
    popper: popper2,
    onUpdate
  };
}
render.$$tippy = true;
var idCounter = 1;
var mouseMoveListeners = [];
var mountedInstances = [];
function createTippy(reference2, passedProps) {
  var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners2 = [];
  var debouncedOnMouseMove = debounce$1(onMouseMove, props.interactiveDebounce);
  var currentTarget;
  var id2 = idCounter++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance = {
    // properties
    id: id2,
    reference: reference2,
    popper: div(),
    popperInstance,
    props,
    state,
    plugins,
    // methods
    clearDelayTimeouts,
    setProps,
    setContent: setContent2,
    show,
    hide: hide2,
    hideWithInteractivity,
    enable,
    disable,
    unmount,
    destroy
  };
  if (!props.render) {
    return instance;
  }
  var _props$render = props.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
  popper2.setAttribute("data-tippy-root", "");
  popper2.id = "tippy-" + instance.id;
  instance.popper = popper2;
  reference2._tippy = instance;
  popper2._tippy = instance;
  var pluginsHooks = plugins.map(function(plugin) {
    return plugin.fn(instance);
  });
  var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook("onCreate", [instance]);
  if (props.showOnCreate) {
    scheduleShow();
  }
  popper2.addEventListener("mouseenter", function() {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper2.addEventListener("mouseleave", function() {
    if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    }
  });
  return instance;
  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }
  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === "hold";
  }
  function getIsDefaultRenderFn() {
    var _instance$props$rende;
    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
  }
  function getCurrentTarget() {
    return currentTarget || reference2;
  }
  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }
  function getDefaultTemplateChildren() {
    return getChildren(popper2);
  }
  function getDelay(isShow) {
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
      return 0;
    }
    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }
  function handleStyles(fromHide) {
    if (fromHide === void 0) {
      fromHide = false;
    }
    popper2.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
    popper2.style.zIndex = "" + instance.props.zIndex;
  }
  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }
    pluginsHooks.forEach(function(pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });
    if (shouldInvokePropsHook) {
      var _instance$props;
      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }
  function handleAriaContentAttribute() {
    var aria = instance.props.aria;
    if (!aria.content) {
      return;
    }
    var attr = "aria-" + aria.content;
    var id22 = popper2.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      var currentValue = node.getAttribute(attr);
      if (instance.state.isVisible) {
        node.setAttribute(attr, currentValue ? currentValue + " " + id22 : id22);
      } else {
        var nextValue = currentValue && currentValue.replace(id22, "").trim();
        if (nextValue) {
          node.setAttribute(attr, nextValue);
        } else {
          node.removeAttribute(attr);
        }
      }
    });
  }
  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      if (instance.props.interactive) {
        node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false");
      } else {
        node.removeAttribute("aria-expanded");
      }
    });
  }
  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  function onDocumentPress(event) {
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === "mousedown") {
        return;
      }
    }
    var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
    if (instance.props.interactive && actualContains(popper2, actualTarget)) {
      return;
    }
    if (normalizeToArray(instance.props.triggerTarget || reference2).some(function(el2) {
      return actualContains(el2, actualTarget);
    })) {
      if (currentInput.isTouch) {
        return;
      }
      if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
        return;
      }
    } else {
      invokeHook("onClickOutside", [instance, event]);
    }
    if (instance.props.hideOnClick === true) {
      instance.clearDelayTimeouts();
      instance.hide();
      didHideDueToDocumentMouseDown = true;
      setTimeout(function() {
        didHideDueToDocumentMouseDown = false;
      });
      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }
  function onTouchMove() {
    didTouchMove = true;
  }
  function onTouchStart() {
    didTouchMove = false;
  }
  function addDocumentPress() {
    var doc2 = getDocument();
    doc2.addEventListener("mousedown", onDocumentPress, true);
    doc2.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc2.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc2.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function removeDocumentPress() {
    var doc2 = getDocument();
    doc2.removeEventListener("mousedown", onDocumentPress, true);
    doc2.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc2.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc2.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function() {
      if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
        callback();
      }
    });
  }
  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;
    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, "remove", listener);
        callback();
      }
    }
    if (duration === 0) {
      return callback();
    }
    updateTransitionEndListener(box, "remove", currentTransitionEndListener);
    updateTransitionEndListener(box, "add", listener);
    currentTransitionEndListener = listener;
  }
  function on(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      node.addEventListener(eventType, handler, options);
      listeners2.push({
        node,
        eventType,
        handler,
        options
      });
    });
  }
  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on("touchstart", onTrigger2, {
        passive: true
      });
      on("touchend", onMouseLeave, {
        passive: true
      });
    }
    splitBySpaces(instance.props.trigger).forEach(function(eventType) {
      if (eventType === "manual") {
        return;
      }
      on(eventType, onTrigger2);
      switch (eventType) {
        case "mouseenter":
          on("mouseleave", onMouseLeave);
          break;
        case "focus":
          on(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
          break;
        case "focusin":
          on("focusout", onBlurOrFocusOut);
          break;
      }
    });
  }
  function removeListeners() {
    listeners2.forEach(function(_ref) {
      var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners2 = [];
  }
  function onTrigger2(event) {
    var _lastTriggerEvent;
    var shouldScheduleClickHide = false;
    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }
    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();
    if (!instance.state.isVisible && isMouseEvent(event)) {
      mouseMoveListeners.forEach(function(listener) {
        return listener(event);
      });
    }
    if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }
    if (event.type === "click") {
      isVisibleFromClick = !shouldScheduleClickHide;
    }
    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }
  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
    if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
      return;
    }
    var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper22) {
      var _instance$popperInsta;
      var instance2 = popper22._tippy;
      var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
      if (state2) {
        return {
          popperRect: popper22.getBoundingClientRect(),
          popperState: state2,
          props
        };
      }
      return null;
    }).filter(Boolean);
    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }
  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
    if (shouldBail) {
      return;
    }
    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }
    scheduleHide(event);
  }
  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
      return;
    }
    if (instance.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
      return;
    }
    scheduleHide(event);
  }
  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
  }
  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset3 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
    var arrow2 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference2;
    var tippyModifier = {
      name: "$$tippy",
      enabled: true,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function fn5(_ref2) {
        var state2 = _ref2.state;
        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
            if (attr === "placement") {
              box.setAttribute("data-placement", state2.placement);
            } else {
              if (state2.attributes.popper["data-popper-" + attr]) {
                box.setAttribute("data-" + attr, "");
              } else {
                box.removeAttribute("data-" + attr);
              }
            }
          });
          state2.attributes.popper = {};
        }
      }
    };
    var modifiers2 = [{
      name: "offset",
      options: {
        offset: offset3
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];
    if (getIsDefaultRenderFn() && arrow2) {
      modifiers2.push({
        name: "arrow",
        options: {
          element: arrow2,
          padding: 3
        }
      });
    }
    modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {
      placement,
      onFirstUpdate,
      modifiers: modifiers2
    }));
  }
  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }
  function mount() {
    var appendTo = instance.props.appendTo;
    var parentNode2;
    var node = getCurrentTarget();
    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
      parentNode2 = node.parentNode;
    } else {
      parentNode2 = invokeWithArgsOrReturn(appendTo, [node]);
    }
    if (!parentNode2.contains(popper2)) {
      parentNode2.appendChild(popper2);
    }
    instance.state.isMounted = true;
    createPopperInstance();
  }
  function getNestedPopperTree() {
    return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
  }
  function scheduleShow(event) {
    instance.clearDelayTimeouts();
    if (event) {
      invokeHook("onTrigger", [instance, event]);
    }
    addDocumentPress();
    var delay = getDelay(true);
    var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
    if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
      delay = touchDelay;
    }
    if (delay) {
      showTimeout = setTimeout(function() {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }
  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook("onUntrigger", [instance, event]);
    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    }
    if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }
    var delay = getDelay(false);
    if (delay) {
      hideTimeout = setTimeout(function() {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      scheduleHideAnimationFrame = requestAnimationFrame(function() {
        instance.hide();
      });
    }
  }
  function enable() {
    instance.state.isEnabled = true;
  }
  function disable() {
    instance.hide();
    instance.state.isEnabled = false;
  }
  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }
  function setProps(partialProps) {
    if (instance.state.isDestroyed) {
      return;
    }
    invokeHook("onBeforeUpdate", [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
      ignoreAttributes: true
    }));
    instance.props = nextProps;
    addListeners();
    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce$1(onMouseMove, nextProps.interactiveDebounce);
    }
    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
        node.removeAttribute("aria-expanded");
      });
    } else if (nextProps.triggerTarget) {
      reference2.removeAttribute("aria-expanded");
    }
    handleAriaExpandedAttribute();
    handleStyles();
    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }
    if (instance.popperInstance) {
      createPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }
    invokeHook("onAfterUpdate", [instance, partialProps]);
  }
  function setContent2(content) {
    instance.setProps({
      content
    });
  }
  function show() {
    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    }
    if (getCurrentTarget().hasAttribute("disabled")) {
      return;
    }
    invokeHook("onShow", [instance], false);
    if (instance.props.onShow(instance) === false) {
      return;
    }
    instance.state.isVisible = true;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "visible";
    }
    handleStyles();
    addDocumentPress();
    if (!instance.state.isMounted) {
      popper2.style.transition = "none";
    }
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
      setTransitionDuration([box, content], 0);
    }
    onFirstUpdate = function onFirstUpdate2() {
      var _instance$popperInsta2;
      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }
      ignoreOnFirstUpdate = true;
      void popper2.offsetHeight;
      popper2.style.transition = instance.props.moveTransition;
      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], "visible");
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance);
      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      invokeHook("onMount", [instance]);
      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function() {
          instance.state.isShown = true;
          invokeHook("onShown", [instance]);
        });
      }
    };
    mount();
  }
  function hide2() {
    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }
    invokeHook("onHide", [instance], false);
    if (instance.props.onHide(instance) === false) {
      return;
    }
    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "hidden";
    }
    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles(true);
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
      if (instance.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], "hidden");
      }
    }
    handleAriaContentAttribute();
    handleAriaExpandedAttribute();
    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }
  function hideWithInteractivity(event) {
    getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }
  function unmount() {
    if (instance.state.isVisible) {
      instance.hide();
    }
    if (!instance.state.isMounted) {
      return;
    }
    destroyPopperInstance();
    getNestedPopperTree().forEach(function(nestedPopper) {
      nestedPopper._tippy.unmount();
    });
    if (popper2.parentNode) {
      popper2.parentNode.removeChild(popper2);
    }
    mountedInstances = mountedInstances.filter(function(i) {
      return i !== instance;
    });
    instance.state.isMounted = false;
    invokeHook("onHidden", [instance]);
  }
  function destroy() {
    if (instance.state.isDestroyed) {
      return;
    }
    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference2._tippy;
    instance.state.isDestroyed = true;
    invokeHook("onDestroy", [instance]);
  }
}
function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins
  });
  var elements = getArrayOfElements(targets);
  var instances = elements.reduce(function(acc, reference2) {
    var instance = reference2 && createTippy(reference2, passedProps);
    if (instance) {
      acc.push(instance);
    }
    return acc;
  }, []);
  return isElement(targets) ? instances[0] : instances;
}
tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
Object.assign({}, applyStyles$1, {
  effect: function effect2(_ref) {
    var state = _ref.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
  }
});
tippy.setDefaultProps({
  render
});
class BubbleMenuView {
  constructor({ editor, element, view, tippyOptions = {}, updateDelay = 250, shouldShow }) {
    this.preventHide = false;
    this.shouldShow = ({ view: view2, state, from: from2, to }) => {
      const { doc: doc2, selection } = state;
      const { empty: empty2 } = selection;
      const isEmptyTextBlock = !doc2.textBetween(from2, to).length && isTextSelection$1(state.selection);
      const isChildOfMenu = this.element.contains(document.activeElement);
      const hasEditorFocus = view2.hasFocus() || isChildOfMenu;
      if (!hasEditorFocus || empty2 || isEmptyTextBlock || !this.editor.isEditable) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.dragstartHandler = () => {
      this.hide();
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) === this.editor.view.dom) {
        return;
      }
      this.hide();
    };
    this.tippyBlurHandler = (event) => {
      this.blurHandler({ event });
    };
    this.handleDebouncedUpdate = (view2, oldState) => {
      const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view2.state.selection));
      const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view2.state.doc));
      if (!selectionChanged && !docChanged) {
        return;
      }
      if (this.updateDebounceTimer) {
        clearTimeout(this.updateDebounceTimer);
      }
      this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(view2, selectionChanged, docChanged, oldState);
      }, this.updateDelay);
    };
    this.updateHandler = (view2, selectionChanged, docChanged, oldState) => {
      var _a, _b, _c;
      const { state, composing } = view2;
      const { selection } = state;
      const isSame = !selectionChanged && !docChanged;
      if (composing || isSame) {
        return;
      }
      this.createTooltip();
      const { ranges } = selection;
      const from2 = Math.min(...ranges.map((range) => range.$from.pos));
      const to = Math.max(...ranges.map((range) => range.$to.pos));
      const shouldShow2 = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {
        editor: this.editor,
        element: this.element,
        view: view2,
        state,
        oldState,
        from: from2,
        to
      });
      if (!shouldShow2) {
        this.hide();
        return;
      }
      (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
        getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => {
          if (isNodeSelection$1(state.selection)) {
            let node = view2.nodeDOM(from2);
            if (node) {
              const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector("[data-node-view-wrapper]");
              if (nodeViewWrapper) {
                node = nodeViewWrapper.firstChild;
              }
              if (node) {
                return node.getBoundingClientRect();
              }
            }
          }
          return posToDOMRect(view2, from2, to);
        })
      });
      this.show();
    };
    this.editor = editor;
    this.element = element;
    this.view = view;
    this.updateDelay = updateDelay;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.addEventListener("dragstart", this.dragstartHandler);
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: editorElement } = this.editor.options;
    const editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy(editorElement, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    });
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler);
    }
  }
  update(view, oldState) {
    const { state } = view;
    const hasValidSelection = state.selection.from !== state.selection.to;
    if (this.updateDelay > 0 && hasValidSelection) {
      this.handleDebouncedUpdate(view, oldState);
      return;
    }
    const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));
    const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));
    this.updateHandler(view, selectionChanged, docChanged, oldState);
  }
  show() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
  }
  hide() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
  }
  destroy() {
    var _a, _b;
    if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {
      this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler);
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  }
}
const BubbleMenuPlugin = (options) => {
  return new Plugin({
    key: typeof options.pluginKey === "string" ? new PluginKey(options.pluginKey) : options.pluginKey,
    view: (view) => new BubbleMenuView({ view, ...options })
  });
};
Extension$1.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      BubbleMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});
const React$2 = await importShared("react");
const { forwardRef: forwardRef$2, useState: useState$2, useDebugValue, useLayoutEffect: useLayoutEffect$1, useEffect: useEffect$2, useRef: useRef$2, createContext: createContext$1, useContext: useContext$1 } = React$2;
const ReactDOM = await importShared("react-dom");
const { flushSync } = ReactDOM;
function getDefaultExportFromCjs(x) {
  return x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var shim = { exports: {} };
var useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreShim_production_min;
function requireUseSyncExternalStoreShim_production_min() {
  if (hasRequiredUseSyncExternalStoreShim_production_min) return useSyncExternalStoreShim_production_min;
  hasRequiredUseSyncExternalStoreShim_production_min = 1;
  var e2 = React$2;
  function h(a2, b) {
    return a2 === b && (0 !== a2 || 1 / a2 === 1 / b) || a2 !== a2 && b !== b;
  }
  var k = "function" === typeof Object.is ? Object.is : h, l2 = e2.useState, m = e2.useEffect, n2 = e2.useLayoutEffect, p2 = e2.useDebugValue;
  function q(a2, b) {
    var d = b(), f = l2({ inst: { value: d, getSnapshot: b } }), c2 = f[0].inst, g = f[1];
    n2(function() {
      c2.value = d;
      c2.getSnapshot = b;
      r2(c2) && g({ inst: c2 });
    }, [a2, d, b]);
    m(function() {
      r2(c2) && g({ inst: c2 });
      return a2(function() {
        r2(c2) && g({ inst: c2 });
      });
    }, [a2]);
    p2(d);
    return d;
  }
  function r2(a2) {
    var b = a2.getSnapshot;
    a2 = a2.value;
    try {
      var d = b();
      return !k(a2, d);
    } catch (f) {
      return true;
    }
  }
  function t2(a2, b) {
    return b();
  }
  var u2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t2 : q;
  useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e2.useSyncExternalStore ? e2.useSyncExternalStore : u2;
  return useSyncExternalStoreShim_production_min;
}
{
  shim.exports = requireUseSyncExternalStoreShim_production_min();
}
var shimExports = shim.exports;
const mergeRefs = (...refs) => {
  return (node) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(node);
      } else if (ref) {
        ref.current = node;
      }
    });
  };
};
const Portals = ({ contentComponent }) => {
  const renderers = shimExports.useSyncExternalStore(contentComponent.subscribe, contentComponent.getSnapshot, contentComponent.getServerSnapshot);
  return React$2.createElement(React$2.Fragment, null, Object.values(renderers));
};
function getInstance() {
  const subscribers = /* @__PURE__ */ new Set();
  let renderers = {};
  return {
    /**
     * Subscribe to the editor instance's changes.
     */
    subscribe(callback) {
      subscribers.add(callback);
      return () => {
        subscribers.delete(callback);
      };
    },
    getSnapshot() {
      return renderers;
    },
    getServerSnapshot() {
      return renderers;
    },
    /**
     * Adds a new NodeView Renderer to the editor.
     */
    setRenderer(id2, renderer) {
      renderers = {
        ...renderers,
        [id2]: ReactDOM.createPortal(renderer.reactElement, renderer.element, id2)
      };
      subscribers.forEach((subscriber) => subscriber());
    },
    /**
     * Removes a NodeView Renderer from the editor.
     */
    removeRenderer(id2) {
      const nextRenderers = { ...renderers };
      delete nextRenderers[id2];
      renderers = nextRenderers;
      subscribers.forEach((subscriber) => subscriber());
    }
  };
}
class PureEditorContent extends React$2.Component {
  constructor(props) {
    var _a;
    super(props);
    this.editorContentRef = React$2.createRef();
    this.initialized = false;
    this.state = {
      hasContentComponentInitialized: Boolean((_a = props.editor) === null || _a === void 0 ? void 0 : _a.contentComponent)
    };
  }
  componentDidMount() {
    this.init();
  }
  componentDidUpdate() {
    this.init();
  }
  init() {
    const editor = this.props.editor;
    if (editor && !editor.isDestroyed && editor.options.element) {
      if (editor.contentComponent) {
        return;
      }
      const element = this.editorContentRef.current;
      element.append(...editor.options.element.childNodes);
      editor.setOptions({
        element
      });
      editor.contentComponent = getInstance();
      if (!this.state.hasContentComponentInitialized) {
        this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {
          this.setState((prevState) => {
            if (!prevState.hasContentComponentInitialized) {
              return {
                hasContentComponentInitialized: true
              };
            }
            return prevState;
          });
          if (this.unsubscribeToContentComponent) {
            this.unsubscribeToContentComponent();
          }
        });
      }
      editor.createNodeViews();
      this.initialized = true;
    }
  }
  componentWillUnmount() {
    const editor = this.props.editor;
    if (!editor) {
      return;
    }
    this.initialized = false;
    if (!editor.isDestroyed) {
      editor.view.setProps({
        nodeViews: {}
      });
    }
    if (this.unsubscribeToContentComponent) {
      this.unsubscribeToContentComponent();
    }
    editor.contentComponent = null;
    if (!editor.options.element.firstChild) {
      return;
    }
    const newElement = document.createElement("div");
    newElement.append(...editor.options.element.childNodes);
    editor.setOptions({
      element: newElement
    });
  }
  render() {
    const { editor, innerRef, ...rest } = this.props;
    return React$2.createElement(
      React$2.Fragment,
      null,
      React$2.createElement("div", { ref: mergeRefs(innerRef, this.editorContentRef), ...rest }),
      (editor === null || editor === void 0 ? void 0 : editor.contentComponent) && React$2.createElement(Portals, { contentComponent: editor.contentComponent })
    );
  }
}
const EditorContentWithKey = forwardRef$2((props, ref) => {
  const key = React$2.useMemo(() => {
    return Math.floor(Math.random() * 4294967295).toString();
  }, [props.editor]);
  return React$2.createElement(PureEditorContent, {
    key,
    innerRef: ref,
    ...props
  });
});
const EditorContent = React$2.memo(EditorContentWithKey);
var react = function equal2(a2, b) {
  if (a2 === b) return true;
  if (a2 && b && typeof a2 == "object" && typeof b == "object") {
    if (a2.constructor !== b.constructor) return false;
    var length, i, keys2;
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0; )
        if (!equal2(a2[i], b[i])) return false;
      return true;
    }
    if (a2 instanceof Map && b instanceof Map) {
      if (a2.size !== b.size) return false;
      for (i of a2.entries())
        if (!b.has(i[0])) return false;
      for (i of a2.entries())
        if (!equal2(i[1], b.get(i[0]))) return false;
      return true;
    }
    if (a2 instanceof Set && b instanceof Set) {
      if (a2.size !== b.size) return false;
      for (i of a2.entries())
        if (!b.has(i[0])) return false;
      return true;
    }
    if (ArrayBuffer.isView(a2) && ArrayBuffer.isView(b)) {
      length = a2.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0; )
        if (a2[i] !== b[i]) return false;
      return true;
    }
    if (a2.constructor === RegExp) return a2.source === b.source && a2.flags === b.flags;
    if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b.valueOf();
    if (a2.toString !== Object.prototype.toString) return a2.toString() === b.toString();
    keys2 = Object.keys(a2);
    length = keys2.length;
    if (length !== Object.keys(b).length) return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys2[i])) return false;
    for (i = length; i-- !== 0; ) {
      var key = keys2[i];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!equal2(a2[key], b[key])) return false;
    }
    return true;
  }
  return a2 !== a2 && b !== b;
};
var deepEqual = /* @__PURE__ */ getDefaultExportFromCjs(react);
var withSelector = { exports: {} };
var withSelector_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredWithSelector_production_min;
function requireWithSelector_production_min() {
  if (hasRequiredWithSelector_production_min) return withSelector_production_min;
  hasRequiredWithSelector_production_min = 1;
  var h = React$2, n2 = shimExports;
  function p2(a2, b) {
    return a2 === b && (0 !== a2 || 1 / a2 === 1 / b) || a2 !== a2 && b !== b;
  }
  var q = "function" === typeof Object.is ? Object.is : p2, r2 = n2.useSyncExternalStore, t2 = h.useRef, u2 = h.useEffect, v = h.useMemo, w = h.useDebugValue;
  withSelector_production_min.useSyncExternalStoreWithSelector = function(a2, b, e2, l2, g) {
    var c2 = t2(null);
    if (null === c2.current) {
      var f = { hasValue: false, value: null };
      c2.current = f;
    } else f = c2.current;
    c2 = v(function() {
      function a22(a3) {
        if (!c22) {
          c22 = true;
          d2 = a3;
          a3 = l2(a3);
          if (void 0 !== g && f.hasValue) {
            var b2 = f.value;
            if (g(b2, a3)) return k = b2;
          }
          return k = a3;
        }
        b2 = k;
        if (q(d2, a3)) return b2;
        var e22 = l2(a3);
        if (void 0 !== g && g(b2, e22)) return b2;
        d2 = a3;
        return k = e22;
      }
      var c22 = false, d2, k, m = void 0 === e2 ? null : e2;
      return [function() {
        return a22(b());
      }, null === m ? void 0 : function() {
        return a22(m());
      }];
    }, [b, e2, l2, g]);
    var d = r2(a2, c2[0], c2[1]);
    u2(function() {
      f.hasValue = true;
      f.value = d;
    }, [d]);
    w(d);
    return d;
  };
  return withSelector_production_min;
}
{
  withSelector.exports = requireWithSelector_production_min();
}
var withSelectorExports = withSelector.exports;
const useIsomorphicLayoutEffect = typeof window !== "undefined" ? useLayoutEffect$1 : useEffect$2;
class EditorStateManager {
  constructor(initialEditor) {
    this.transactionNumber = 0;
    this.lastTransactionNumber = 0;
    this.subscribers = /* @__PURE__ */ new Set();
    this.editor = initialEditor;
    this.lastSnapshot = { editor: initialEditor, transactionNumber: 0 };
    this.getSnapshot = this.getSnapshot.bind(this);
    this.getServerSnapshot = this.getServerSnapshot.bind(this);
    this.watch = this.watch.bind(this);
    this.subscribe = this.subscribe.bind(this);
  }
  /**
   * Get the current editor instance.
   */
  getSnapshot() {
    if (this.transactionNumber === this.lastTransactionNumber) {
      return this.lastSnapshot;
    }
    this.lastTransactionNumber = this.transactionNumber;
    this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber };
    return this.lastSnapshot;
  }
  /**
   * Always disable the editor on the server-side.
   */
  getServerSnapshot() {
    return { editor: null, transactionNumber: 0 };
  }
  /**
   * Subscribe to the editor instance's changes.
   */
  subscribe(callback) {
    this.subscribers.add(callback);
    return () => {
      this.subscribers.delete(callback);
    };
  }
  /**
   * Watch the editor instance for changes.
   */
  watch(nextEditor) {
    this.editor = nextEditor;
    if (this.editor) {
      const fn2 = () => {
        this.transactionNumber += 1;
        this.subscribers.forEach((callback) => callback());
      };
      const currentEditor = this.editor;
      currentEditor.on("transaction", fn2);
      return () => {
        currentEditor.off("transaction", fn2);
      };
    }
    return void 0;
  }
}
function useEditorState(options) {
  var _a;
  const [editorStateManager] = useState$2(() => new EditorStateManager(options.editor));
  const selectedState = withSelectorExports.useSyncExternalStoreWithSelector(editorStateManager.subscribe, editorStateManager.getSnapshot, editorStateManager.getServerSnapshot, options.selector, (_a = options.equalityFn) !== null && _a !== void 0 ? _a : deepEqual);
  useIsomorphicLayoutEffect(() => {
    return editorStateManager.watch(options.editor);
  }, [options.editor, editorStateManager]);
  useDebugValue(selectedState);
  return selectedState;
}
const isDev = false;
const isSSR = typeof window === "undefined";
const isNext = isSSR || Boolean(typeof window !== "undefined" && window.next);
class EditorInstanceManager {
  constructor(options) {
    this.editor = null;
    this.subscriptions = /* @__PURE__ */ new Set();
    this.isComponentMounted = false;
    this.previousDeps = null;
    this.instanceId = "";
    this.options = options;
    this.subscriptions = /* @__PURE__ */ new Set();
    this.setEditor(this.getInitialEditor());
    this.scheduleDestroy();
    this.getEditor = this.getEditor.bind(this);
    this.getServerSnapshot = this.getServerSnapshot.bind(this);
    this.subscribe = this.subscribe.bind(this);
    this.refreshEditorInstance = this.refreshEditorInstance.bind(this);
    this.scheduleDestroy = this.scheduleDestroy.bind(this);
    this.onRender = this.onRender.bind(this);
    this.createEditor = this.createEditor.bind(this);
  }
  setEditor(editor) {
    this.editor = editor;
    this.instanceId = Math.random().toString(36).slice(2, 9);
    this.subscriptions.forEach((cb) => cb());
  }
  getInitialEditor() {
    if (this.options.current.immediatelyRender === void 0) {
      if (isSSR || isNext) {
        return null;
      }
      return this.createEditor();
    }
    if (this.options.current.immediatelyRender && isSSR && isDev) ;
    if (this.options.current.immediatelyRender) {
      return this.createEditor();
    }
    return null;
  }
  /**
   * Create a new editor instance. And attach event listeners.
   */
  createEditor() {
    const optionsToApply = {
      ...this.options.current,
      // Always call the most recent version of the callback function by default
      onBeforeCreate: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onBeforeCreate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      },
      onBlur: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      },
      onCreate: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onCreate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      },
      onDestroy: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onDestroy) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      },
      onFocus: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      },
      onSelectionUpdate: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onSelectionUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      },
      onTransaction: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onTransaction) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      },
      onUpdate: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      },
      onContentError: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onContentError) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      },
      onDrop: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onDrop) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      },
      onPaste: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onPaste) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      }
    };
    const editor = new Editor(optionsToApply);
    return editor;
  }
  /**
   * Get the current editor instance.
   */
  getEditor() {
    return this.editor;
  }
  /**
   * Always disable the editor on the server-side.
   */
  getServerSnapshot() {
    return null;
  }
  /**
   * Subscribe to the editor instance's changes.
   */
  subscribe(onStoreChange) {
    this.subscriptions.add(onStoreChange);
    return () => {
      this.subscriptions.delete(onStoreChange);
    };
  }
  /**
   * On each render, we will create, update, or destroy the editor instance.
   * @param deps The dependencies to watch for changes
   * @returns A cleanup function
   */
  onRender(deps) {
    return () => {
      this.isComponentMounted = true;
      clearTimeout(this.scheduledDestructionTimeout);
      if (this.editor && !this.editor.isDestroyed && deps.length === 0) {
        this.editor.setOptions({
          ...this.options.current,
          editable: this.editor.isEditable
        });
      } else {
        this.refreshEditorInstance(deps);
      }
      return () => {
        this.isComponentMounted = false;
        this.scheduleDestroy();
      };
    };
  }
  /**
   * Recreate the editor instance if the dependencies have changed.
   */
  refreshEditorInstance(deps) {
    if (this.editor && !this.editor.isDestroyed) {
      if (this.previousDeps === null) {
        this.previousDeps = deps;
        return;
      }
      const depsAreEqual = this.previousDeps.length === deps.length && this.previousDeps.every((dep, index2) => dep === deps[index2]);
      if (depsAreEqual) {
        return;
      }
    }
    if (this.editor && !this.editor.isDestroyed) {
      this.editor.destroy();
    }
    this.setEditor(this.createEditor());
    this.previousDeps = deps;
  }
  /**
   * Schedule the destruction of the editor instance.
   * This will only destroy the editor if it was not mounted on the next tick.
   * This is to avoid destroying the editor instance when it's actually still mounted.
   */
  scheduleDestroy() {
    const currentInstanceId = this.instanceId;
    const currentEditor = this.editor;
    this.scheduledDestructionTimeout = setTimeout(() => {
      if (this.isComponentMounted && this.instanceId === currentInstanceId) {
        if (currentEditor) {
          currentEditor.setOptions(this.options.current);
        }
        return;
      }
      if (currentEditor && !currentEditor.isDestroyed) {
        currentEditor.destroy();
        if (this.instanceId === currentInstanceId) {
          this.setEditor(null);
        }
      }
    }, 1);
  }
}
function useEditor(options = {}, deps = []) {
  const mostRecentOptions = useRef$2(options);
  mostRecentOptions.current = options;
  const [instanceManager] = useState$2(() => new EditorInstanceManager(mostRecentOptions));
  const editor = shimExports.useSyncExternalStore(instanceManager.subscribe, instanceManager.getEditor, instanceManager.getServerSnapshot);
  useDebugValue(editor);
  useEffect$2(instanceManager.onRender(deps));
  useEditorState({
    editor,
    selector: ({ transactionNumber }) => {
      if (options.shouldRerenderOnTransaction === false) {
        return null;
      }
      if (options.immediatelyRender && transactionNumber === 0) {
        return 0;
      }
      return transactionNumber + 1;
    }
  });
  return editor;
}
const EditorContext = createContext$1({
  editor: null
});
const EditorConsumer = EditorContext.Consumer;
const useCurrentEditor = () => useContext$1(EditorContext);
function EditorProvider({ children, slotAfter, slotBefore, editorContainerProps = {}, ...editorOptions }) {
  const editor = useEditor(editorOptions);
  if (!editor) {
    return null;
  }
  return React$2.createElement(
    EditorContext.Provider,
    { value: { editor } },
    slotBefore,
    React$2.createElement(EditorConsumer, null, ({ editor: currentEditor }) => React$2.createElement(EditorContent, { editor: currentEditor, ...editorContainerProps })),
    children,
    slotAfter
  );
}
const BubbleMenu = (props) => {
  const [element, setElement] = useState$2(null);
  const { editor: currentEditor } = useCurrentEditor();
  useEffect$2(() => {
    var _a;
    if (!element) {
      return;
    }
    if (((_a = props.editor) === null || _a === void 0 ? void 0 : _a.isDestroyed) || (currentEditor === null || currentEditor === void 0 ? void 0 : currentEditor.isDestroyed)) {
      return;
    }
    const { pluginKey = "bubbleMenu", editor, tippyOptions = {}, updateDelay, shouldShow = null } = props;
    const menuEditor = editor || currentEditor;
    if (!menuEditor) {
      console.warn("BubbleMenu component is not rendered inside of an editor component or does not have editor prop.");
      return;
    }
    const plugin = BubbleMenuPlugin({
      updateDelay,
      editor: menuEditor,
      element,
      pluginKey,
      shouldShow,
      tippyOptions
    });
    menuEditor.registerPlugin(plugin);
    return () => {
      menuEditor.unregisterPlugin(pluginKey);
    };
  }, [props.editor, currentEditor, element]);
  return React$2.createElement("div", { ref: setElement, className: props.className, style: { visibility: "hidden" } }, props.children);
};
const ReactNodeViewContext = createContext$1({
  onDragStart: void 0
});
const useReactNodeView = () => useContext$1(ReactNodeViewContext);
React$2.forwardRef((props, ref) => {
  const { onDragStart: onDragStart2 } = useReactNodeView();
  const Tag = props.as || "div";
  return (
    // @ts-ignore
    React$2.createElement(Tag, { ...props, ref, "data-node-view-wrapper": "", onDragStart: onDragStart2, style: {
      whiteSpace: "normal",
      ...props.style
    } })
  );
});
function isClassComponent(Component2) {
  return !!(typeof Component2 === "function" && Component2.prototype && Component2.prototype.isReactComponent);
}
function isForwardRefComponent(Component2) {
  var _a;
  return !!(typeof Component2 === "object" && ((_a = Component2.$$typeof) === null || _a === void 0 ? void 0 : _a.toString()) === "Symbol(react.forward_ref)");
}
class ReactRenderer {
  /**
   * Immediately creates element and renders the provided React component.
   */
  constructor(component, { editor, props = {}, as = "div", className = "" }) {
    this.ref = null;
    this.id = Math.floor(Math.random() * 4294967295).toString();
    this.component = component;
    this.editor = editor;
    this.props = props;
    this.element = document.createElement(as);
    this.element.classList.add("react-renderer");
    if (className) {
      this.element.classList.add(...className.split(" "));
    }
    if (this.editor.isInitialized) {
      flushSync(() => {
        this.render();
      });
    } else {
      this.render();
    }
  }
  /**
   * Render the React component.
   */
  render() {
    var _a;
    const Component2 = this.component;
    const props = this.props;
    const editor = this.editor;
    if (isClassComponent(Component2) || isForwardRefComponent(Component2)) {
      props.ref = (ref) => {
        this.ref = ref;
      };
    }
    this.reactElement = React$2.createElement(Component2, { ...props });
    (_a = editor === null || editor === void 0 ? void 0 : editor.contentComponent) === null || _a === void 0 ? void 0 : _a.setRenderer(this.id, this);
  }
  /**
   * Re-renders the React component with new props.
   */
  updateProps(props = {}) {
    this.props = {
      ...this.props,
      ...props
    };
    this.render();
  }
  /**
   * Destroy the React component.
   */
  destroy() {
    var _a;
    const editor = this.editor;
    (_a = editor === null || editor === void 0 ? void 0 : editor.contentComponent) === null || _a === void 0 ? void 0 : _a.removeRenderer(this.id);
  }
  /**
   * Update the attributes of the element that holds the React component.
   */
  updateAttributes(attributes) {
    Object.keys(attributes).forEach((key) => {
      this.element.setAttribute(key, attributes[key]);
    });
  }
}
const Document$1 = Node$2.create({
  name: "doc",
  topNode: true,
  content: "block+"
});
const schema = new Schema({
  nodes: {
    doc: {
      content: "block+"
    },
    paragraph: {
      content: "inline*",
      group: "block",
      parseDOM: [{ tag: "p" }],
      toDOM() {
        return ["p", 0];
      }
    },
    blockquote: {
      content: "block+",
      group: "block",
      parseDOM: [{ tag: "blockquote" }],
      toDOM() {
        return ["blockquote", 0];
      }
    },
    horizontal_rule: {
      group: "block",
      parseDOM: [{ tag: "hr" }],
      toDOM() {
        return ["div", ["hr"]];
      }
    },
    heading: {
      attrs: { level: { default: 1 } },
      content: "(text | image)*",
      group: "block",
      defining: true,
      parseDOM: [
        { tag: "h1", attrs: { level: 1 } },
        { tag: "h2", attrs: { level: 2 } },
        { tag: "h3", attrs: { level: 3 } },
        { tag: "h4", attrs: { level: 4 } },
        { tag: "h5", attrs: { level: 5 } },
        { tag: "h6", attrs: { level: 6 } }
      ],
      toDOM(node) {
        return ["h" + node.attrs.level, 0];
      }
    },
    code_block: {
      content: "text*",
      group: "block",
      code: true,
      defining: true,
      marks: "",
      attrs: { params: { default: "" } },
      parseDOM: [{ tag: "pre", preserveWhitespace: "full", getAttrs: (node) => ({ params: node.getAttribute("data-params") || "" }) }],
      toDOM(node) {
        return ["pre", node.attrs.params ? { "data-params": node.attrs.params } : {}, ["code", 0]];
      }
    },
    ordered_list: {
      content: "list_item+",
      group: "block",
      attrs: { order: { default: 1 }, tight: { default: false } },
      parseDOM: [{ tag: "ol", getAttrs(dom) {
        return {
          order: dom.hasAttribute("start") ? +dom.getAttribute("start") : 1,
          tight: dom.hasAttribute("data-tight")
        };
      } }],
      toDOM(node) {
        return ["ol", {
          start: node.attrs.order == 1 ? null : node.attrs.order,
          "data-tight": node.attrs.tight ? "true" : null
        }, 0];
      }
    },
    bullet_list: {
      content: "list_item+",
      group: "block",
      attrs: { tight: { default: false } },
      parseDOM: [{ tag: "ul", getAttrs: (dom) => ({ tight: dom.hasAttribute("data-tight") }) }],
      toDOM(node) {
        return ["ul", { "data-tight": node.attrs.tight ? "true" : null }, 0];
      }
    },
    list_item: {
      content: "block+",
      defining: true,
      parseDOM: [{ tag: "li" }],
      toDOM() {
        return ["li", 0];
      }
    },
    text: {
      group: "inline"
    },
    image: {
      inline: true,
      attrs: {
        src: {},
        alt: { default: null },
        title: { default: null }
      },
      group: "inline",
      draggable: true,
      parseDOM: [{ tag: "img[src]", getAttrs(dom) {
        return {
          src: dom.getAttribute("src"),
          title: dom.getAttribute("title"),
          alt: dom.getAttribute("alt")
        };
      } }],
      toDOM(node) {
        return ["img", node.attrs];
      }
    },
    hard_break: {
      inline: true,
      group: "inline",
      selectable: false,
      parseDOM: [{ tag: "br" }],
      toDOM() {
        return ["br"];
      }
    }
  },
  marks: {
    em: {
      parseDOM: [
        { tag: "i" },
        { tag: "em" },
        { style: "font-style=italic" },
        { style: "font-style=normal", clearMark: (m) => m.type.name == "em" }
      ],
      toDOM() {
        return ["em"];
      }
    },
    strong: {
      parseDOM: [
        { tag: "strong" },
        { tag: "b", getAttrs: (node) => node.style.fontWeight != "normal" && null },
        { style: "font-weight=400", clearMark: (m) => m.type.name == "strong" },
        { style: "font-weight", getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null }
      ],
      toDOM() {
        return ["strong"];
      }
    },
    link: {
      attrs: {
        href: {},
        title: { default: null }
      },
      inclusive: false,
      parseDOM: [{ tag: "a[href]", getAttrs(dom) {
        return { href: dom.getAttribute("href"), title: dom.getAttribute("title") };
      } }],
      toDOM(node) {
        return ["a", node.attrs];
      }
    },
    code: {
      parseDOM: [{ tag: "code" }],
      toDOM() {
        return ["code"];
      }
    }
  }
});
function maybeMerge(a2, b) {
  if (a2.isText && b.isText && Mark$2.sameSet(a2.marks, b.marks))
    return a2.withText(a2.text + b.text);
}
class MarkdownParseState {
  constructor(schema2, tokenHandlers2) {
    this.schema = schema2;
    this.tokenHandlers = tokenHandlers2;
    this.stack = [{ type: schema2.topNodeType, attrs: null, content: [], marks: Mark$2.none }];
  }
  top() {
    return this.stack[this.stack.length - 1];
  }
  push(elt) {
    if (this.stack.length)
      this.top().content.push(elt);
  }
  // Adds the given text to the current position in the document,
  // using the current marks as styling.
  addText(text) {
    if (!text)
      return;
    let top2 = this.top(), nodes = top2.content, last = nodes[nodes.length - 1];
    let node = this.schema.text(text, top2.marks), merged;
    if (last && (merged = maybeMerge(last, node)))
      nodes[nodes.length - 1] = merged;
    else
      nodes.push(node);
  }
  // Adds the given mark to the set of active marks.
  openMark(mark) {
    let top2 = this.top();
    top2.marks = mark.addToSet(top2.marks);
  }
  // Removes the given mark from the set of active marks.
  closeMark(mark) {
    let top2 = this.top();
    top2.marks = mark.removeFromSet(top2.marks);
  }
  parseTokens(toks) {
    for (let i = 0; i < toks.length; i++) {
      let tok = toks[i];
      let handler = this.tokenHandlers[tok.type];
      if (!handler)
        throw new Error("Token type `" + tok.type + "` not supported by Markdown parser");
      handler(this, tok, toks, i);
    }
  }
  // Add a node at the current position.
  addNode(type, attrs2, content) {
    let top2 = this.top();
    let node = type.createAndFill(attrs2, content, top2 ? top2.marks : []);
    if (!node)
      return null;
    this.push(node);
    return node;
  }
  // Wrap subsequent content in a node of the given type.
  openNode(type, attrs2) {
    this.stack.push({ type, attrs: attrs2, content: [], marks: Mark$2.none });
  }
  // Close and return the node that is currently on top of the stack.
  closeNode() {
    let info = this.stack.pop();
    return this.addNode(info.type, info.attrs, info.content);
  }
}
function attrs(spec, token, tokens, i) {
  if (spec.getAttrs)
    return spec.getAttrs(token, tokens, i);
  else if (spec.attrs instanceof Function)
    return spec.attrs(token);
  else
    return spec.attrs;
}
function noCloseToken(spec, type) {
  return spec.noCloseToken || type == "code_inline" || type == "code_block" || type == "fence";
}
function withoutTrailingNewline(str) {
  return str[str.length - 1] == "\n" ? str.slice(0, str.length - 1) : str;
}
function noOp() {
}
function tokenHandlers(schema2, tokens) {
  let handlers2 = /* @__PURE__ */ Object.create(null);
  for (let type in tokens) {
    let spec = tokens[type];
    if (spec.block) {
      let nodeType = schema2.nodeType(spec.block);
      if (noCloseToken(spec, type)) {
        handlers2[type] = (state, tok, tokens2, i) => {
          state.openNode(nodeType, attrs(spec, tok, tokens2, i));
          state.addText(withoutTrailingNewline(tok.content));
          state.closeNode();
        };
      } else {
        handlers2[type + "_open"] = (state, tok, tokens2, i) => state.openNode(nodeType, attrs(spec, tok, tokens2, i));
        handlers2[type + "_close"] = (state) => state.closeNode();
      }
    } else if (spec.node) {
      let nodeType = schema2.nodeType(spec.node);
      handlers2[type] = (state, tok, tokens2, i) => state.addNode(nodeType, attrs(spec, tok, tokens2, i));
    } else if (spec.mark) {
      let markType = schema2.marks[spec.mark];
      if (noCloseToken(spec, type)) {
        handlers2[type] = (state, tok, tokens2, i) => {
          state.openMark(markType.create(attrs(spec, tok, tokens2, i)));
          state.addText(withoutTrailingNewline(tok.content));
          state.closeMark(markType);
        };
      } else {
        handlers2[type + "_open"] = (state, tok, tokens2, i) => state.openMark(markType.create(attrs(spec, tok, tokens2, i)));
        handlers2[type + "_close"] = (state) => state.closeMark(markType);
      }
    } else if (spec.ignore) {
      if (noCloseToken(spec, type)) {
        handlers2[type] = noOp;
      } else {
        handlers2[type + "_open"] = noOp;
        handlers2[type + "_close"] = noOp;
      }
    } else {
      throw new RangeError("Unrecognized parsing spec " + JSON.stringify(spec));
    }
  }
  handlers2.text = (state, tok) => state.addText(tok.content);
  handlers2.inline = (state, tok) => state.parseTokens(tok.children);
  handlers2.softbreak = handlers2.softbreak || ((state) => state.addText(" "));
  return handlers2;
}
let MarkdownParser$1 = class MarkdownParser {
  /**
  Create a parser with the given configuration. You can configure
  the markdown-it parser to parse the dialect you want, and provide
  a description of the ProseMirror entities those tokens map to in
  the `tokens` object, which maps token names to descriptions of
  what to do with them. Such a description is an object, and may
  have the following properties:
  */
  constructor(schema2, tokenizer, tokens) {
    this.schema = schema2;
    this.tokenizer = tokenizer;
    this.tokens = tokens;
    this.tokenHandlers = tokenHandlers(schema2, tokens);
  }
  /**
  Parse a string as [CommonMark](http://commonmark.org/) markup,
  and create a ProseMirror document as prescribed by this parser's
  rules.
  
  The second argument, when given, is passed through to the
  [Markdown
  parser](https://markdown-it.github.io/markdown-it/#MarkdownIt.parse).
  */
  parse(text, markdownEnv = {}) {
    let state = new MarkdownParseState(this.schema, this.tokenHandlers), doc2;
    state.parseTokens(this.tokenizer.parse(text, markdownEnv));
    do {
      doc2 = state.closeNode();
    } while (state.stack.length);
    return doc2 || this.schema.topNodeType.createAndFill();
  }
};
function listIsTight(tokens, i) {
  while (++i < tokens.length)
    if (tokens[i].type != "list_item_open")
      return tokens[i].hidden;
  return false;
}
new MarkdownParser$1(schema, MarkdownIt("commonmark", { html: false }), {
  blockquote: { block: "blockquote" },
  paragraph: { block: "paragraph" },
  list_item: { block: "list_item" },
  bullet_list: { block: "bullet_list", getAttrs: (_, tokens, i) => ({ tight: listIsTight(tokens, i) }) },
  ordered_list: { block: "ordered_list", getAttrs: (tok, tokens, i) => ({
    order: +tok.attrGet("start") || 1,
    tight: listIsTight(tokens, i)
  }) },
  heading: { block: "heading", getAttrs: (tok) => ({ level: +tok.tag.slice(1) }) },
  code_block: { block: "code_block", noCloseToken: true },
  fence: { block: "code_block", getAttrs: (tok) => ({ params: tok.info || "" }), noCloseToken: true },
  hr: { node: "horizontal_rule" },
  image: { node: "image", getAttrs: (tok) => ({
    src: tok.attrGet("src"),
    title: tok.attrGet("title") || null,
    alt: tok.children[0] && tok.children[0].content || null
  }) },
  hardbreak: { node: "hard_break" },
  em: { mark: "em" },
  strong: { mark: "strong" },
  link: { mark: "link", getAttrs: (tok) => ({
    href: tok.attrGet("href"),
    title: tok.attrGet("title") || null
  }) },
  code_inline: { mark: "code", noCloseToken: true }
});
const blankMark = { open: "", close: "", mixable: true };
let MarkdownSerializer$1 = class MarkdownSerializer {
  /**
  Construct a serializer with the given configuration. The `nodes`
  object should map node names in a given schema to function that
  take a serializer state and such a node, and serialize the node.
  */
  constructor(nodes, marks, options = {}) {
    this.nodes = nodes;
    this.marks = marks;
    this.options = options;
  }
  /**
  Serialize the content of the given node to
  [CommonMark](http://commonmark.org/).
  */
  serialize(content, options = {}) {
    options = Object.assign({}, this.options, options);
    let state = new MarkdownSerializerState$1(this.nodes, this.marks, options);
    state.renderContent(content);
    return state.out;
  }
};
const defaultMarkdownSerializer = new MarkdownSerializer$1({
  blockquote(state, node) {
    state.wrapBlock("> ", null, node, () => state.renderContent(node));
  },
  code_block(state, node) {
    const backticks = node.textContent.match(/`{3,}/gm);
    const fence = backticks ? backticks.sort().slice(-1)[0] + "`" : "```";
    state.write(fence + (node.attrs.params || "") + "\n");
    state.text(node.textContent, false);
    state.write("\n");
    state.write(fence);
    state.closeBlock(node);
  },
  heading(state, node) {
    state.write(state.repeat("#", node.attrs.level) + " ");
    state.renderInline(node, false);
    state.closeBlock(node);
  },
  horizontal_rule(state, node) {
    state.write(node.attrs.markup || "---");
    state.closeBlock(node);
  },
  bullet_list(state, node) {
    state.renderList(node, "  ", () => (node.attrs.bullet || "*") + " ");
  },
  ordered_list(state, node) {
    let start2 = node.attrs.order || 1;
    let maxW = String(start2 + node.childCount - 1).length;
    let space2 = state.repeat(" ", maxW + 2);
    state.renderList(node, space2, (i) => {
      let nStr = String(start2 + i);
      return state.repeat(" ", maxW - nStr.length) + nStr + ". ";
    });
  },
  list_item(state, node) {
    state.renderContent(node);
  },
  paragraph(state, node) {
    state.renderInline(node);
    state.closeBlock(node);
  },
  image(state, node) {
    state.write("![" + state.esc(node.attrs.alt || "") + "](" + node.attrs.src.replace(/[\(\)]/g, "\\$&") + (node.attrs.title ? ' "' + node.attrs.title.replace(/"/g, '\\"') + '"' : "") + ")");
  },
  hard_break(state, node, parent, index2) {
    for (let i = index2 + 1; i < parent.childCount; i++)
      if (parent.child(i).type != node.type) {
        state.write("\\\n");
        return;
      }
  },
  text(state, node) {
    state.text(node.text, !state.inAutolink);
  }
}, {
  em: { open: "*", close: "*", mixable: true, expelEnclosingWhitespace: true },
  strong: { open: "**", close: "**", mixable: true, expelEnclosingWhitespace: true },
  link: {
    open(state, mark, parent, index2) {
      state.inAutolink = isPlainURL(mark, parent, index2);
      return state.inAutolink ? "<" : "[";
    },
    close(state, mark, parent, index2) {
      let { inAutolink } = state;
      state.inAutolink = void 0;
      return inAutolink ? ">" : "](" + mark.attrs.href.replace(/[\(\)"]/g, "\\$&") + (mark.attrs.title ? ` "${mark.attrs.title.replace(/"/g, '\\"')}"` : "") + ")";
    },
    mixable: true
  },
  code: {
    open(_state, _mark, parent, index2) {
      return backticksFor(parent.child(index2), -1);
    },
    close(_state, _mark, parent, index2) {
      return backticksFor(parent.child(index2 - 1), 1);
    },
    escape: false
  }
});
function backticksFor(node, side) {
  let ticks = /`+/g, m, len = 0;
  if (node.isText)
    while (m = ticks.exec(node.text))
      len = Math.max(len, m[0].length);
  let result = len > 0 && side > 0 ? " `" : "`";
  for (let i = 0; i < len; i++)
    result += "`";
  if (len > 0 && side < 0)
    result += " ";
  return result;
}
function isPlainURL(link, parent, index2) {
  if (link.attrs.title || !/^\w+:/.test(link.attrs.href))
    return false;
  let content = parent.child(index2);
  if (!content.isText || content.text != link.attrs.href || content.marks[content.marks.length - 1] != link)
    return false;
  return index2 == parent.childCount - 1 || !link.isInSet(parent.child(index2 + 1).marks);
}
let MarkdownSerializerState$1 = class MarkdownSerializerState {
  /**
  @internal
  */
  constructor(nodes, marks, options) {
    this.nodes = nodes;
    this.marks = marks;
    this.options = options;
    this.delim = "";
    this.out = "";
    this.closed = null;
    this.inAutolink = void 0;
    this.atBlockStart = false;
    this.inTightList = false;
    if (typeof this.options.tightLists == "undefined")
      this.options.tightLists = false;
    if (typeof this.options.hardBreakNodeName == "undefined")
      this.options.hardBreakNodeName = "hard_break";
  }
  /**
  @internal
  */
  flushClose(size2 = 2) {
    if (this.closed) {
      if (!this.atBlank())
        this.out += "\n";
      if (size2 > 1) {
        let delimMin = this.delim;
        let trim2 = /\s+$/.exec(delimMin);
        if (trim2)
          delimMin = delimMin.slice(0, delimMin.length - trim2[0].length);
        for (let i = 1; i < size2; i++)
          this.out += delimMin + "\n";
      }
      this.closed = null;
    }
  }
  /**
  @internal
  */
  getMark(name) {
    let info = this.marks[name];
    if (!info) {
      if (this.options.strict !== false)
        throw new Error(`Mark type \`${name}\` not supported by Markdown renderer`);
      info = blankMark;
    }
    return info;
  }
  /**
  Render a block, prefixing each line with `delim`, and the first
  line in `firstDelim`. `node` should be the node that is closed at
  the end of the block, and `f` is a function that renders the
  content of the block.
  */
  wrapBlock(delim, firstDelim, node, f) {
    let old = this.delim;
    this.write(firstDelim != null ? firstDelim : delim);
    this.delim += delim;
    f();
    this.delim = old;
    this.closeBlock(node);
  }
  /**
  @internal
  */
  atBlank() {
    return /(^|\n)$/.test(this.out);
  }
  /**
  Ensure the current content ends with a newline.
  */
  ensureNewLine() {
    if (!this.atBlank())
      this.out += "\n";
  }
  /**
  Prepare the state for writing output (closing closed paragraphs,
  adding delimiters, and so on), and then optionally add content
  (unescaped) to the output.
  */
  write(content) {
    this.flushClose();
    if (this.delim && this.atBlank())
      this.out += this.delim;
    if (content)
      this.out += content;
  }
  /**
  Close the block for the given node.
  */
  closeBlock(node) {
    this.closed = node;
  }
  /**
  Add the given text to the document. When escape is not `false`,
  it will be escaped.
  */
  text(text, escape2 = true) {
    let lines = text.split("\n");
    for (let i = 0; i < lines.length; i++) {
      this.write();
      if (!escape2 && lines[i][0] == "[" && /(^|[^\\])\!$/.test(this.out))
        this.out = this.out.slice(0, this.out.length - 1) + "\\!";
      this.out += escape2 ? this.esc(lines[i], this.atBlockStart) : lines[i];
      if (i != lines.length - 1)
        this.out += "\n";
    }
  }
  /**
  Render the given node as a block.
  */
  render(node, parent, index2) {
    if (this.nodes[node.type.name]) {
      this.nodes[node.type.name](this, node, parent, index2);
    } else {
      if (this.options.strict !== false) {
        throw new Error("Token type `" + node.type.name + "` not supported by Markdown renderer");
      } else if (!node.type.isLeaf) {
        if (node.type.inlineContent)
          this.renderInline(node);
        else
          this.renderContent(node);
        if (node.isBlock)
          this.closeBlock(node);
      }
    }
  }
  /**
  Render the contents of `parent` as block nodes.
  */
  renderContent(parent) {
    parent.forEach((node, _, i) => this.render(node, parent, i));
  }
  /**
  Render the contents of `parent` as inline content.
  */
  renderInline(parent, fromBlockStart = true) {
    this.atBlockStart = fromBlockStart;
    let active = [], trailing = "";
    let progress = (node, offset3, index2) => {
      let marks = node ? node.marks : [];
      if (node && node.type.name === this.options.hardBreakNodeName)
        marks = marks.filter((m) => {
          if (index2 + 1 == parent.childCount)
            return false;
          let next = parent.child(index2 + 1);
          return m.isInSet(next.marks) && (!next.isText || /\S/.test(next.text));
        });
      let leading = trailing;
      trailing = "";
      if (node && node.isText && marks.some((mark) => {
        let info = this.getMark(mark.type.name);
        return info && info.expelEnclosingWhitespace && !mark.isInSet(active);
      })) {
        let [_, lead, rest] = /^(\s*)(.*)$/m.exec(node.text);
        if (lead) {
          leading += lead;
          node = rest ? node.withText(rest) : null;
          if (!node)
            marks = active;
        }
      }
      if (node && node.isText && marks.some((mark) => {
        let info = this.getMark(mark.type.name);
        return info && info.expelEnclosingWhitespace && (index2 == parent.childCount - 1 || !mark.isInSet(parent.child(index2 + 1).marks));
      })) {
        let [_, rest, trail] = /^(.*?)(\s*)$/m.exec(node.text);
        if (trail) {
          trailing = trail;
          node = rest ? node.withText(rest) : null;
          if (!node)
            marks = active;
        }
      }
      let inner = marks.length ? marks[marks.length - 1] : null;
      let noEsc = inner && this.getMark(inner.type.name).escape === false;
      let len = marks.length - (noEsc ? 1 : 0);
      outer: for (let i = 0; i < len; i++) {
        let mark = marks[i];
        if (!this.getMark(mark.type.name).mixable)
          break;
        for (let j = 0; j < active.length; j++) {
          let other = active[j];
          if (!this.getMark(other.type.name).mixable)
            break;
          if (mark.eq(other)) {
            if (i > j)
              marks = marks.slice(0, j).concat(mark).concat(marks.slice(j, i)).concat(marks.slice(i + 1, len));
            else if (j > i)
              marks = marks.slice(0, i).concat(marks.slice(i + 1, j)).concat(mark).concat(marks.slice(j, len));
            continue outer;
          }
        }
      }
      let keep = 0;
      while (keep < Math.min(active.length, len) && marks[keep].eq(active[keep]))
        ++keep;
      while (keep < active.length)
        this.text(this.markString(active.pop(), false, parent, index2), false);
      if (leading)
        this.text(leading);
      if (node) {
        while (active.length < len) {
          let add2 = marks[active.length];
          active.push(add2);
          this.text(this.markString(add2, true, parent, index2), false);
          this.atBlockStart = false;
        }
        if (noEsc && node.isText)
          this.text(this.markString(inner, true, parent, index2) + node.text + this.markString(inner, false, parent, index2 + 1), false);
        else
          this.render(node, parent, index2);
        this.atBlockStart = false;
      }
      if ((node === null || node === void 0 ? void 0 : node.isText) && node.nodeSize > 0) {
        this.atBlockStart = false;
      }
    };
    parent.forEach(progress);
    progress(null, 0, parent.childCount);
    this.atBlockStart = false;
  }
  /**
  Render a node's content as a list. `delim` should be the extra
  indentation added to all lines except the first in an item,
  `firstDelim` is a function going from an item index to a
  delimiter for the first line of the item.
  */
  renderList(node, delim, firstDelim) {
    if (this.closed && this.closed.type == node.type)
      this.flushClose(3);
    else if (this.inTightList)
      this.flushClose(1);
    let isTight = typeof node.attrs.tight != "undefined" ? node.attrs.tight : this.options.tightLists;
    let prevTight = this.inTightList;
    this.inTightList = isTight;
    node.forEach((child, _, i) => {
      if (i && isTight)
        this.flushClose(1);
      this.wrapBlock(delim, firstDelim(i), node, () => this.render(child, node, i));
    });
    this.inTightList = prevTight;
  }
  /**
  Escape the given string so that it can safely appear in Markdown
  content. If `startOfLine` is true, also escape characters that
  have special meaning only at the start of the line.
  */
  esc(str, startOfLine = false) {
    str = str.replace(/[`*\\~\[\]_]/g, (m, i) => m == "_" && i > 0 && i + 1 < str.length && str[i - 1].match(/\w/) && str[i + 1].match(/\w/) ? m : "\\" + m);
    if (startOfLine)
      str = str.replace(/^(\+[ ]|[\-*>])/, "\\$&").replace(/^(\s*)(#{1,6})(\s|$)/, "$1\\$2$3").replace(/^(\s*\d+)\.\s/, "$1\\. ");
    if (this.options.escapeExtraCharacters)
      str = str.replace(this.options.escapeExtraCharacters, "\\$&");
    return str;
  }
  /**
  @internal
  */
  quote(str) {
    let wrap2 = str.indexOf('"') == -1 ? '""' : str.indexOf("'") == -1 ? "''" : "()";
    return wrap2[0] + str + wrap2[1];
  }
  /**
  Repeat the given string `n` times.
  */
  repeat(str, n2) {
    let out = "";
    for (let i = 0; i < n2; i++)
      out += str;
    return out;
  }
  /**
  Get the markdown string for a given opening or closing mark.
  */
  markString(mark, open, parent, index2) {
    let info = this.getMark(mark.type.name);
    let value = open ? info.open : info.close;
    return typeof value == "string" ? value : value(this, mark, parent, index2);
  }
  /**
  Get leading and trailing whitespace from a string. Values of
  leading or trailing property of the return object will be undefined
  if there is no match.
  */
  getEnclosingWhitespace(text) {
    return {
      leading: (text.match(/^(\s+)/) || [void 0])[0],
      trailing: (text.match(/(\s+)$/) || [void 0])[0]
    };
  }
};
var disableCheckboxes = true;
var useLabelWrapper = false;
var useLabelAfter = false;
var markdownItTaskLists = function(md2, options) {
  if (options) {
    disableCheckboxes = !options.enabled;
    useLabelWrapper = !!options.label;
    useLabelAfter = !!options.labelAfter;
  }
  md2.core.ruler.after("inline", "github-task-lists", function(state) {
    var tokens = state.tokens;
    for (var i = 2; i < tokens.length; i++) {
      if (isTodoItem(tokens, i)) {
        todoify(tokens[i], state.Token);
        attrSet(tokens[i - 2], "class", "task-list-item" + (!disableCheckboxes ? " enabled" : ""));
        attrSet(tokens[parentToken(tokens, i - 2)], "class", "contains-task-list");
      }
    }
  });
};
function attrSet(token, name, value) {
  var index2 = token.attrIndex(name);
  var attr = [name, value];
  if (index2 < 0) {
    token.attrPush(attr);
  } else {
    token.attrs[index2] = attr;
  }
}
function parentToken(tokens, index2) {
  var targetLevel = tokens[index2].level - 1;
  for (var i = index2 - 1; i >= 0; i--) {
    if (tokens[i].level === targetLevel) {
      return i;
    }
  }
  return -1;
}
function isTodoItem(tokens, index2) {
  return isInline(tokens[index2]) && isParagraph(tokens[index2 - 1]) && isListItem(tokens[index2 - 2]) && startsWithTodoMarkdown(tokens[index2]);
}
function todoify(token, TokenConstructor) {
  token.children.unshift(makeCheckbox(token, TokenConstructor));
  token.children[1].content = token.children[1].content.slice(3);
  token.content = token.content.slice(3);
  if (useLabelWrapper) {
    if (useLabelAfter) {
      token.children.pop();
      var id2 = "task-item-" + Math.ceil(Math.random() * (1e4 * 1e3) - 1e3);
      token.children[0].content = token.children[0].content.slice(0, -1) + ' id="' + id2 + '">';
      token.children.push(afterLabel(token.content, id2, TokenConstructor));
    } else {
      token.children.unshift(beginLabel(TokenConstructor));
      token.children.push(endLabel(TokenConstructor));
    }
  }
}
function makeCheckbox(token, TokenConstructor) {
  var checkbox = new TokenConstructor("html_inline", "", 0);
  var disabledAttr = disableCheckboxes ? ' disabled="" ' : "";
  if (token.content.indexOf("[ ] ") === 0) {
    checkbox.content = '<input class="task-list-item-checkbox"' + disabledAttr + 'type="checkbox">';
  } else if (token.content.indexOf("[x] ") === 0 || token.content.indexOf("[X] ") === 0) {
    checkbox.content = '<input class="task-list-item-checkbox" checked=""' + disabledAttr + 'type="checkbox">';
  }
  return checkbox;
}
function beginLabel(TokenConstructor) {
  var token = new TokenConstructor("html_inline", "", 0);
  token.content = "<label>";
  return token;
}
function endLabel(TokenConstructor) {
  var token = new TokenConstructor("html_inline", "", 0);
  token.content = "</label>";
  return token;
}
function afterLabel(content, id2, TokenConstructor) {
  var token = new TokenConstructor("html_inline", "", 0);
  token.content = '<label class="task-list-item-label" for="' + id2 + '">' + content + "</label>";
  token.attrs = [{ for: id2 }];
  return token;
}
function isInline(token) {
  return token.type === "inline";
}
function isParagraph(token) {
  return token.type === "paragraph_open";
}
function isListItem(token) {
  return token.type === "list_item_open";
}
function startsWithTodoMarkdown(token) {
  return token.content.indexOf("[ ] ") === 0 || token.content.indexOf("[x] ") === 0 || token.content.indexOf("[X] ") === 0;
}
const taskListPlugin = /* @__PURE__ */ getDefaultExportFromCjs$1(markdownItTaskLists);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const MarkdownTightLists = Extension$1.create({
  name: "markdownTightLists",
  addOptions: () => ({
    tight: true,
    tightClass: "tight",
    listTypes: ["bulletList", "orderedList"]
  }),
  addGlobalAttributes() {
    return [{
      types: this.options.listTypes,
      attributes: {
        tight: {
          default: this.options.tight,
          parseHTML: (element) => element.getAttribute("data-tight") === "true" || !element.querySelector("p"),
          renderHTML: (attributes) => ({
            class: attributes.tight ? this.options.tightClass : null,
            "data-tight": attributes.tight ? "true" : null
          })
        }
      }
    }];
  },
  addCommands() {
    var _this = this;
    return {
      toggleTight: function() {
        let tight = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        return (_ref) => {
          let {
            editor,
            commands: commands2
          } = _ref;
          function toggleTight(name) {
            if (!editor.isActive(name)) {
              return false;
            }
            const attrs2 = editor.getAttributes(name);
            return commands2.updateAttributes(name, {
              tight: tight !== null && tight !== void 0 ? tight : !(attrs2 !== null && attrs2 !== void 0 && attrs2.tight)
            });
          }
          return _this.options.listTypes.some((name) => toggleTight(name));
        };
      }
    };
  }
});
const md = MarkdownIt();
function scanDelims(text, pos) {
  md.inline.State.prototype.scanDelims.call({
    src: text,
    posMax: text.length
  });
  const state = new md.inline.State(text, null, null, []);
  return state.scanDelims(pos, true);
}
function shiftDelim(text, delim, start2, offset3) {
  let res = text.substring(0, start2) + text.substring(start2 + delim.length);
  res = res.substring(0, start2 + offset3) + delim + res.substring(start2 + offset3);
  return res;
}
function trimStart(text, delim, from2, to) {
  let pos = from2, res = text;
  while (pos < to) {
    if (scanDelims(res, pos).can_open) {
      break;
    }
    res = shiftDelim(res, delim, pos, 1);
    pos++;
  }
  return {
    text: res,
    from: pos,
    to
  };
}
function trimEnd(text, delim, from2, to) {
  let pos = to, res = text;
  while (pos > from2) {
    if (scanDelims(res, pos).can_close) {
      break;
    }
    res = shiftDelim(res, delim, pos, -1);
    pos--;
  }
  return {
    text: res,
    from: from2,
    to: pos
  };
}
function trimInline(text, delim, from2, to) {
  let state = {
    text,
    from: from2,
    to
  };
  state = trimStart(state.text, delim, state.from, state.to);
  state = trimEnd(state.text, delim, state.from, state.to);
  if (state.to - state.from < delim.length + 1) {
    state.text = state.text.substring(0, state.from) + state.text.substring(state.to + delim.length);
  }
  return state.text;
}
class MarkdownSerializerState2 extends MarkdownSerializerState$1 {
  constructor(nodes, marks, options) {
    super(nodes, marks, options !== null && options !== void 0 ? options : {});
    __publicField(this, "inTable", false);
    this.inlines = [];
  }
  render(node, parent, index2) {
    super.render(node, parent, index2);
    const top2 = this.inlines[this.inlines.length - 1];
    if (top2 !== null && top2 !== void 0 && top2.start && top2 !== null && top2 !== void 0 && top2.end) {
      const {
        delimiter,
        start: start2,
        end: end2
      } = this.normalizeInline(top2);
      this.out = trimInline(this.out, delimiter, start2, end2);
      this.inlines.pop();
    }
  }
  markString(mark, open, parent, index2) {
    const info = this.marks[mark.type.name];
    if (info.expelEnclosingWhitespace) {
      if (open) {
        this.inlines.push({
          start: this.out.length,
          delimiter: info.open
        });
      } else {
        const top2 = this.inlines.pop();
        this.inlines.push({
          ...top2,
          end: this.out.length
        });
      }
    }
    return super.markString(mark, open, parent, index2);
  }
  normalizeInline(inline) {
    let {
      start: start2,
      end: end2
    } = inline;
    while (this.out.charAt(start2).match(/\s/)) {
      start2++;
    }
    return {
      ...inline,
      start: start2
    };
  }
}
const HTMLMark = Mark$1.create({
  name: "markdownHTMLMark",
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: {
          open(state, mark) {
            var _getMarkTags$, _getMarkTags;
            if (!this.editor.storage.markdown.options.html) {
              console.warn(`Tiptap Markdown: "${mark.type.name}" mark is only available in html mode`);
              return "";
            }
            return (_getMarkTags$ = (_getMarkTags = getMarkTags(mark)) === null || _getMarkTags === void 0 ? void 0 : _getMarkTags[0]) !== null && _getMarkTags$ !== void 0 ? _getMarkTags$ : "";
          },
          close(state, mark) {
            var _getMarkTags$2, _getMarkTags2;
            if (!this.editor.storage.markdown.options.html) {
              return "";
            }
            return (_getMarkTags$2 = (_getMarkTags2 = getMarkTags(mark)) === null || _getMarkTags2 === void 0 ? void 0 : _getMarkTags2[1]) !== null && _getMarkTags$2 !== void 0 ? _getMarkTags$2 : "";
          }
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
function getMarkTags(mark) {
  const schema2 = mark.type.schema;
  const node = schema2.text(" ", [mark]);
  const html = getHTMLFromFragment(Fragment.from(node), schema2);
  const match2 = html.match(/^(<.*?>) (<\/.*?>)$/);
  return match2 ? [match2[1], match2[2]] : null;
}
function elementFromString$1(value) {
  const wrappedValue = `<body>${value}</body>`;
  return new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
}
function escapeHTML(value) {
  return value === null || value === void 0 ? void 0 : value.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function extractElement(node) {
  const parent = node.parentElement;
  const prepend2 = parent.cloneNode();
  while (parent.firstChild && parent.firstChild !== node) {
    prepend2.appendChild(parent.firstChild);
  }
  if (prepend2.childNodes.length > 0) {
    parent.parentElement.insertBefore(prepend2, parent);
  }
  parent.parentElement.insertBefore(node, parent);
  if (parent.childNodes.length === 0) {
    parent.remove();
  }
}
function unwrapElement(node) {
  const parent = node.parentNode;
  while (node.firstChild)
    parent.insertBefore(node.firstChild, node);
  parent.removeChild(node);
}
const HTMLNode = Node$2.create({
  name: "markdownHTMLNode",
  addStorage() {
    return {
      markdown: {
        serialize(state, node, parent) {
          if (this.editor.storage.markdown.options.html) {
            state.write(serializeHTML(node, parent));
          } else {
            console.warn(`Tiptap Markdown: "${node.type.name}" node is only available in html mode`);
            state.write(`[${node.type.name}]`);
          }
          if (node.isBlock) {
            state.closeBlock(node);
          }
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
function serializeHTML(node, parent) {
  const schema2 = node.type.schema;
  const html = getHTMLFromFragment(Fragment.from(node), schema2);
  if (node.isBlock && (parent instanceof Fragment || parent.type.name === schema2.topNodeType.name)) {
    return formatBlock(html);
  }
  return html;
}
function formatBlock(html) {
  const dom = elementFromString$1(html);
  const element = dom.firstElementChild;
  element.innerHTML = element.innerHTML.trim() ? `
${element.innerHTML}
` : `
`;
  return element.outerHTML;
}
const Blockquote$2 = Node$2.create({
  name: "blockquote"
});
const Blockquote$1$1 = Blockquote$2.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: defaultMarkdownSerializer.nodes.blockquote,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
const BulletList$2 = Node$2.create({
  name: "bulletList"
});
const BulletList$1$1 = BulletList$2.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(state, node) {
          return state.renderList(node, "  ", () => (this.editor.storage.markdown.options.bulletListMarker || "-") + " ");
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
const CodeBlock$2 = Node$2.create({
  name: "codeBlock"
});
const CodeBlock$1$1 = CodeBlock$2.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(state, node) {
          state.write("```" + (node.attrs.language || "") + "\n");
          state.text(node.textContent, false);
          state.ensureNewLine();
          state.write("```");
          state.closeBlock(node);
        },
        parse: {
          setup(markdownit2) {
            var _this$options$languag;
            markdownit2.set({
              langPrefix: (_this$options$languag = this.options.languageClassPrefix) !== null && _this$options$languag !== void 0 ? _this$options$languag : "language-"
            });
          },
          updateDOM(element) {
            element.innerHTML = element.innerHTML.replace(/\n<\/code><\/pre>/g, "</code></pre>");
          }
        }
      }
    };
  }
});
const HardBreak$1 = Node$2.create({
  name: "hardBreak"
});
const HardBreak$1$1 = HardBreak$1.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(state, node, parent, index2) {
          for (let i = index2 + 1; i < parent.childCount; i++)
            if (parent.child(i).type != node.type) {
              state.write(state.inTable ? HTMLNode.storage.markdown.serialize.call(this, state, node, parent) : "\\\n");
              return;
            }
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
const Heading$2 = Node$2.create({
  name: "heading"
});
const Heading$1$1 = Heading$2.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: defaultMarkdownSerializer.nodes.heading,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
const HorizontalRule$2 = Node$2.create({
  name: "horizontalRule"
});
const HorizontalRule$1$1 = HorizontalRule$2.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: defaultMarkdownSerializer.nodes.horizontal_rule,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
const Image$2 = Node$2.create({
  name: "image"
});
const Image$1$1 = Image$2.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: defaultMarkdownSerializer.nodes.image,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
const ListItem$2 = Node$2.create({
  name: "listItem"
});
const ListItem$1$1 = ListItem$2.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: defaultMarkdownSerializer.nodes.list_item,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
const OrderedList$2 = Node$2.create({
  name: "orderedList"
});
function findIndexOfAdjacentNode(node, parent, index2) {
  let i = 0;
  for (; index2 - i > 0; i++) {
    if (parent.child(index2 - i - 1).type.name !== node.type.name) {
      break;
    }
  }
  return i;
}
const OrderedList$1$1 = OrderedList$2.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(state, node, parent, index2) {
          const start2 = node.attrs.start || 1;
          const maxW = String(start2 + node.childCount - 1).length;
          const space2 = state.repeat(" ", maxW + 2);
          const adjacentIndex = findIndexOfAdjacentNode(node, parent, index2);
          const separator = adjacentIndex % 2 ? ") " : ". ";
          state.renderList(node, space2, (i) => {
            const nStr = String(start2 + i);
            return state.repeat(" ", maxW - nStr.length) + nStr + separator;
          });
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
const Paragraph$1 = Node$2.create({
  name: "paragraph"
});
const Paragraph$1$1 = Paragraph$1.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: defaultMarkdownSerializer.nodes.paragraph,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
function childNodes(node) {
  var _node$content$content, _node$content;
  return (_node$content$content = node === null || node === void 0 || (_node$content = node.content) === null || _node$content === void 0 ? void 0 : _node$content.content) !== null && _node$content$content !== void 0 ? _node$content$content : [];
}
const Table = Node$2.create({
  name: "table"
});
const Table$1 = Table.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(state, node, parent) {
          if (!isMarkdownSerializable(node)) {
            HTMLNode.storage.markdown.serialize.call(this, state, node, parent);
            return;
          }
          state.inTable = true;
          node.forEach((row, p2, i) => {
            state.write("| ");
            row.forEach((col, p22, j) => {
              if (j) {
                state.write(" | ");
              }
              const cellContent = col.firstChild;
              if (cellContent.textContent.trim()) {
                state.renderInline(cellContent);
              }
            });
            state.write(" |");
            state.ensureNewLine();
            if (!i) {
              const delimiterRow = Array.from({
                length: row.childCount
              }).map(() => "---").join(" | ");
              state.write(`| ${delimiterRow} |`);
              state.ensureNewLine();
            }
          });
          state.closeBlock(node);
          state.inTable = false;
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
function hasSpan(node) {
  return node.attrs.colspan > 1 || node.attrs.rowspan > 1;
}
function isMarkdownSerializable(node) {
  const rows = childNodes(node);
  const firstRow = rows[0];
  const bodyRows = rows.slice(1);
  if (childNodes(firstRow).some((cell) => cell.type.name !== "tableHeader" || hasSpan(cell) || cell.childCount > 1)) {
    return false;
  }
  if (bodyRows.some((row) => childNodes(row).some((cell) => cell.type.name === "tableHeader" || hasSpan(cell) || cell.childCount > 1))) {
    return false;
  }
  return true;
}
const TaskItem$1 = Node$2.create({
  name: "taskItem"
});
const TaskItem$1$1 = TaskItem$1.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(state, node) {
          const check = node.attrs.checked ? "[x]" : "[ ]";
          state.write(`${check} `);
          state.renderContent(node);
        },
        parse: {
          updateDOM(element) {
            [...element.querySelectorAll(".task-list-item")].forEach((item) => {
              const input = item.querySelector("input");
              item.setAttribute("data-type", "taskItem");
              if (input) {
                item.setAttribute("data-checked", input.checked);
                input.remove();
              }
            });
          }
        }
      }
    };
  }
});
const TaskList$1 = Node$2.create({
  name: "taskList"
});
const TaskList$1$1 = TaskList$1.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: BulletList$1$1.storage.markdown.serialize,
        parse: {
          setup(markdownit2) {
            markdownit2.use(taskListPlugin);
          },
          updateDOM(element) {
            [...element.querySelectorAll(".contains-task-list")].forEach((list) => {
              list.setAttribute("data-type", "taskList");
            });
          }
        }
      }
    };
  }
});
const Text$2 = Node$2.create({
  name: "text"
});
const Text$1$1 = Text$2.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(state, node) {
          state.text(escapeHTML(node.text));
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
const Bold$2 = Mark$1.create({
  name: "bold"
});
const Bold$1$1 = Bold$2.extend({
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: defaultMarkdownSerializer.marks.strong,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
const Code$2 = Mark$1.create({
  name: "code"
});
const Code$1$1 = Code$2.extend({
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: defaultMarkdownSerializer.marks.code,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
const Italic$2 = Mark$1.create({
  name: "italic"
});
const Italic$1$1 = Italic$2.extend({
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: defaultMarkdownSerializer.marks.em,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
const Link$1 = Mark$1.create({
  name: "link"
});
const Link$1$1 = Link$1.extend({
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: defaultMarkdownSerializer.marks.link,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
const Strike$2 = Mark$1.create({
  name: "strike"
});
const Strike$1$1 = Strike$2.extend({
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: {
          open: "~~",
          close: "~~",
          expelEnclosingWhitespace: true
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
const markdownExtensions = [Blockquote$1$1, BulletList$1$1, CodeBlock$1$1, HardBreak$1$1, Heading$1$1, HorizontalRule$1$1, HTMLNode, Image$1$1, ListItem$1$1, OrderedList$1$1, Paragraph$1$1, Table$1, TaskItem$1$1, TaskList$1$1, Text$1$1, Bold$1$1, Code$1$1, HTMLMark, Italic$1$1, Link$1$1, Strike$1$1];
function getMarkdownSpec(extension) {
  var _extension$storage, _markdownExtensions$f;
  const markdownSpec = (_extension$storage = extension.storage) === null || _extension$storage === void 0 ? void 0 : _extension$storage.markdown;
  const defaultMarkdownSpec = (_markdownExtensions$f = markdownExtensions.find((e2) => e2.name === extension.name)) === null || _markdownExtensions$f === void 0 ? void 0 : _markdownExtensions$f.storage.markdown;
  if (markdownSpec || defaultMarkdownSpec) {
    return {
      ...defaultMarkdownSpec,
      ...markdownSpec
    };
  }
  return null;
}
class MarkdownSerializer2 {
  constructor(editor) {
    __publicField(this, "editor", null);
    this.editor = editor;
  }
  serialize(content) {
    const state = new MarkdownSerializerState2(this.nodes, this.marks, {
      hardBreakNodeName: HardBreak$1$1.name
    });
    state.renderContent(content);
    return state.out;
  }
  get nodes() {
    var _this$editor$extensio;
    return {
      ...Object.fromEntries(Object.keys(this.editor.schema.nodes).map((name) => [name, this.serializeNode(HTMLNode)])),
      ...Object.fromEntries((_this$editor$extensio = this.editor.extensionManager.extensions.filter((extension) => extension.type === "node" && this.serializeNode(extension)).map((extension) => [extension.name, this.serializeNode(extension)])) !== null && _this$editor$extensio !== void 0 ? _this$editor$extensio : [])
    };
  }
  get marks() {
    var _this$editor$extensio2;
    return {
      ...Object.fromEntries(Object.keys(this.editor.schema.marks).map((name) => [name, this.serializeMark(HTMLMark)])),
      ...Object.fromEntries((_this$editor$extensio2 = this.editor.extensionManager.extensions.filter((extension) => extension.type === "mark" && this.serializeMark(extension)).map((extension) => [extension.name, this.serializeMark(extension)])) !== null && _this$editor$extensio2 !== void 0 ? _this$editor$extensio2 : [])
    };
  }
  serializeNode(node) {
    var _getMarkdownSpec;
    return (_getMarkdownSpec = getMarkdownSpec(node)) === null || _getMarkdownSpec === void 0 || (_getMarkdownSpec = _getMarkdownSpec.serialize) === null || _getMarkdownSpec === void 0 ? void 0 : _getMarkdownSpec.bind({
      editor: this.editor,
      options: node.options
    });
  }
  serializeMark(mark) {
    var _getMarkdownSpec2;
    const serialize = (_getMarkdownSpec2 = getMarkdownSpec(mark)) === null || _getMarkdownSpec2 === void 0 ? void 0 : _getMarkdownSpec2.serialize;
    return serialize ? {
      ...serialize,
      open: typeof serialize.open === "function" ? serialize.open.bind({
        editor: this.editor,
        options: mark.options
      }) : serialize.open,
      close: typeof serialize.close === "function" ? serialize.close.bind({
        editor: this.editor,
        options: mark.options
      }) : serialize.close
    } : null;
  }
}
class MarkdownParser2 {
  constructor(editor, _ref) {
    __publicField(this, "editor", null);
    __publicField(this, "md", null);
    let {
      html,
      linkify,
      breaks
    } = _ref;
    this.editor = editor;
    this.md = this.withPatchedRenderer(MarkdownIt({
      html,
      linkify,
      breaks
    }));
  }
  parse(content) {
    let {
      inline
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (typeof content === "string") {
      this.editor.extensionManager.extensions.forEach((extension) => {
        var _getMarkdownSpec;
        return (_getMarkdownSpec = getMarkdownSpec(extension)) === null || _getMarkdownSpec === void 0 || (_getMarkdownSpec = _getMarkdownSpec.parse) === null || _getMarkdownSpec === void 0 || (_getMarkdownSpec = _getMarkdownSpec.setup) === null || _getMarkdownSpec === void 0 ? void 0 : _getMarkdownSpec.call({
          editor: this.editor,
          options: extension.options
        }, this.md);
      });
      const renderedHTML = this.md.render(content);
      const element = elementFromString$1(renderedHTML);
      this.editor.extensionManager.extensions.forEach((extension) => {
        var _getMarkdownSpec2;
        return (_getMarkdownSpec2 = getMarkdownSpec(extension)) === null || _getMarkdownSpec2 === void 0 || (_getMarkdownSpec2 = _getMarkdownSpec2.parse) === null || _getMarkdownSpec2 === void 0 || (_getMarkdownSpec2 = _getMarkdownSpec2.updateDOM) === null || _getMarkdownSpec2 === void 0 ? void 0 : _getMarkdownSpec2.call({
          editor: this.editor,
          options: extension.options
        }, element);
      });
      this.normalizeDOM(element, {
        inline,
        content
      });
      return element.innerHTML;
    }
    return content;
  }
  normalizeDOM(node, _ref2) {
    let {
      inline,
      content
    } = _ref2;
    this.normalizeBlocks(node);
    node.querySelectorAll("*").forEach((el2) => {
      var _el$nextSibling;
      if (((_el$nextSibling = el2.nextSibling) === null || _el$nextSibling === void 0 ? void 0 : _el$nextSibling.nodeType) === Node.TEXT_NODE && !el2.closest("pre")) {
        el2.nextSibling.textContent = el2.nextSibling.textContent.replace(/^\n/, "");
      }
    });
    if (inline) {
      this.normalizeInline(node, content);
    }
    return node;
  }
  normalizeBlocks(node) {
    const blocks = Object.values(this.editor.schema.nodes).filter((node2) => node2.isBlock);
    const selector = blocks.map((block) => {
      var _block$spec$parseDOM;
      return (_block$spec$parseDOM = block.spec.parseDOM) === null || _block$spec$parseDOM === void 0 ? void 0 : _block$spec$parseDOM.map((spec) => spec.tag);
    }).flat().filter(Boolean).join(",");
    if (!selector) {
      return;
    }
    [...node.querySelectorAll(selector)].forEach((el2) => {
      if (el2.parentElement.matches("p")) {
        extractElement(el2);
      }
    });
  }
  normalizeInline(node, content) {
    var _node$firstElementChi;
    if ((_node$firstElementChi = node.firstElementChild) !== null && _node$firstElementChi !== void 0 && _node$firstElementChi.matches("p")) {
      var _content$match$, _content$match, _content$match$2, _content$match2;
      const firstParagraph = node.firstElementChild;
      const {
        nextElementSibling
      } = firstParagraph;
      const startSpaces = (_content$match$ = (_content$match = content.match(/^\s+/)) === null || _content$match === void 0 ? void 0 : _content$match[0]) !== null && _content$match$ !== void 0 ? _content$match$ : "";
      const endSpaces = !nextElementSibling ? (_content$match$2 = (_content$match2 = content.match(/\s+$/)) === null || _content$match2 === void 0 ? void 0 : _content$match2[0]) !== null && _content$match$2 !== void 0 ? _content$match$2 : "" : "";
      if (content.match(/^\n\n/)) {
        firstParagraph.innerHTML = `${firstParagraph.innerHTML}${endSpaces}`;
        return;
      }
      unwrapElement(firstParagraph);
      node.innerHTML = `${startSpaces}${node.innerHTML}${endSpaces}`;
    }
  }
  /**
   * @param {markdownit} md
   */
  withPatchedRenderer(md2) {
    const withoutNewLine = (renderer) => function() {
      const rendered = renderer(...arguments);
      if (rendered === "\n") {
        return rendered;
      }
      if (rendered[rendered.length - 1] === "\n") {
        return rendered.slice(0, -1);
      }
      return rendered;
    };
    md2.renderer.rules.hardbreak = withoutNewLine(md2.renderer.rules.hardbreak);
    md2.renderer.rules.softbreak = withoutNewLine(md2.renderer.rules.softbreak);
    md2.renderer.rules.fence = withoutNewLine(md2.renderer.rules.fence);
    md2.renderer.rules.code_block = withoutNewLine(md2.renderer.rules.code_block);
    md2.renderer.renderToken = withoutNewLine(md2.renderer.renderToken.bind(md2.renderer));
    return md2;
  }
}
const MarkdownClipboard = Extension$1.create({
  name: "markdownClipboard",
  addOptions() {
    return {
      transformPastedText: false,
      transformCopiedText: false
    };
  },
  addProseMirrorPlugins() {
    return [new Plugin({
      key: new PluginKey("markdownClipboard"),
      props: {
        clipboardTextParser: (text, context, plainText) => {
          if (plainText || !this.options.transformPastedText) {
            return null;
          }
          const parsed = this.editor.storage.markdown.parser.parse(text, {
            inline: true
          });
          return DOMParser.fromSchema(this.editor.schema).parseSlice(elementFromString$1(parsed), {
            preserveWhitespace: true,
            context
          });
        },
        /**
         * @param {import('prosemirror-model').Slice} slice
         */
        clipboardTextSerializer: (slice2) => {
          if (!this.options.transformCopiedText) {
            return null;
          }
          return this.editor.storage.markdown.serializer.serialize(slice2.content);
        }
      }
    })];
  }
});
const Markdown$1 = Extension$1.create({
  name: "markdown",
  priority: 50,
  addOptions() {
    return {
      html: true,
      tightLists: true,
      tightListClass: "tight",
      bulletListMarker: "-",
      linkify: false,
      breaks: false,
      transformPastedText: false,
      transformCopiedText: false
    };
  },
  addCommands() {
    const commands2 = index.Commands.config.addCommands();
    return {
      setContent: (content, emitUpdate, parseOptions) => (props) => {
        return commands2.setContent(props.editor.storage.markdown.parser.parse(content), emitUpdate, parseOptions)(props);
      },
      insertContentAt: (range, content, options) => (props) => {
        return commands2.insertContentAt(range, props.editor.storage.markdown.parser.parse(content, {
          inline: true
        }), options)(props);
      }
    };
  },
  onBeforeCreate() {
    this.editor.storage.markdown = {
      options: {
        ...this.options
      },
      parser: new MarkdownParser2(this.editor, this.options),
      serializer: new MarkdownSerializer2(this.editor),
      getMarkdown: () => {
        return this.editor.storage.markdown.serializer.serialize(this.editor.state.doc);
      }
    };
    this.editor.options.initialContent = this.editor.options.content;
    this.editor.options.content = this.editor.storage.markdown.parser.parse(this.editor.options.content);
  },
  onCreate() {
    this.editor.options.content = this.editor.options.initialContent;
    delete this.editor.options.initialContent;
  },
  addStorage() {
    return {
      /// storage will be defined in onBeforeCreate() to prevent initial object overriding
    };
  },
  addExtensions() {
    return [MarkdownTightLists.configure({
      tight: this.options.tightLists,
      tightClass: this.options.tightListClass
    }), MarkdownClipboard.configure({
      transformPastedText: this.options.transformPastedText,
      transformCopiedText: this.options.transformCopiedText
    })];
  }
});
const Underline = Mark$1.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("underline") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["u", mergeAttributes$1(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleUnderline: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetUnderline: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});
const Heading$1 = Node$2.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: true,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: false
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((level) => ({
      tag: `h${level}`,
      attrs: { level }
    }));
  },
  renderHTML({ node, HTMLAttributes }) {
    const hasLevel = this.options.levels.includes(node.attrs.level);
    const level = hasLevel ? node.attrs.level : this.options.levels[0];
    return [`h${level}`, mergeAttributes$1(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.setNode(this.name, attributes);
      },
      toggleHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((items2, level) => ({
      ...items2,
      ...{
        [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
      }
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((level) => {
      return textblockTypeInputRule$1({
        find: new RegExp(`^(#{1,${level}})\\s$`),
        type: this.type,
        getAttributes: {
          level
        }
      });
    });
  }
});
const TextStyle = Mark$1.create({
  name: "textStyle",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (element) => {
          const hasStyles = element.hasAttribute("style");
          if (!hasStyles) {
            return false;
          }
          return {};
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["span", mergeAttributes$1(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state, commands: commands2 }) => {
        const attributes = getMarkAttributes$1(state, this.type);
        const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
        if (hasStyles) {
          return true;
        }
        return commands2.unsetMark(this.name);
      }
    };
  }
});
const Color = Extension$1.create({
  name: "color",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (element) => {
              var _a;
              return (_a = element.style.color) === null || _a === void 0 ? void 0 : _a.replace(/['"]+/g, "");
            },
            renderHTML: (attributes) => {
              if (!attributes.color) {
                return {};
              }
              return {
                style: `color: ${attributes.color}`
              };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setColor: (color) => ({ chain }) => {
        return chain().setMark("textStyle", { color }).run();
      },
      unsetColor: () => ({ chain }) => {
        return chain().setMark("textStyle", { color: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
const inputRegex$c = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/;
const pasteRegex$4 = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g;
const Highlight = Mark$1.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: false,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    if (!this.options.multicolor) {
      return {};
    }
    return {
      color: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-color") || element.style.backgroundColor,
        renderHTML: (attributes) => {
          if (!attributes.color) {
            return {};
          }
          return {
            "data-color": attributes.color,
            style: `background-color: ${attributes.color}; color: inherit`
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["mark", mergeAttributes$1(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHighlight: (attributes) => ({ commands: commands2 }) => {
        return commands2.setMark(this.name, attributes);
      },
      toggleHighlight: (attributes) => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name, attributes);
      },
      unsetHighlight: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      markInputRule$1({
        find: inputRegex$c,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule$1({
        find: pasteRegex$4,
        type: this.type
      })
    ];
  }
});
const starInputRegex$3 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/;
const starPasteRegex$3 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g;
const underscoreInputRegex$3 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/;
const underscorePasteRegex$3 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g;
const Bold$1 = Mark$1.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (node) => node.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (mark) => mark.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["strong", mergeAttributes$1(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleBold: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetBold: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      markInputRule$1({
        find: starInputRegex$3,
        type: this.type
      }),
      markInputRule$1({
        find: underscoreInputRegex$3,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule$1({
        find: starPasteRegex$3,
        type: this.type
      }),
      markPasteRule$1({
        find: underscorePasteRegex$3,
        type: this.type
      })
    ];
  }
});
const starInputRegex$2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/;
const starPasteRegex$2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g;
const underscoreInputRegex$2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/;
const underscorePasteRegex$2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g;
const Italic$1 = Mark$1.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (node) => node.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (mark) => mark.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["em", mergeAttributes$1(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleItalic: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetItalic: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      markInputRule$1({
        find: starInputRegex$2,
        type: this.type
      }),
      markInputRule$1({
        find: underscoreInputRegex$2,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule$1({
        find: starPasteRegex$2,
        type: this.type
      }),
      markPasteRule$1({
        find: underscorePasteRegex$2,
        type: this.type
      })
    ];
  }
});
const inputRegex$b = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/;
const pasteRegex$3 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g;
const Strike$1 = Mark$1.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("line-through") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["s", mergeAttributes$1(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleStrike: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetStrike: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      markInputRule$1({
        find: inputRegex$b,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule$1({
        find: pasteRegex$3,
        type: this.type
      })
    ];
  }
});
function createChainableState(config) {
  const { state, transaction } = config;
  let { selection } = transaction;
  let { doc: doc2 } = transaction;
  let { storedMarks } = transaction;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc2;
    },
    get tr() {
      selection = transaction.selection;
      doc2 = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  };
}
class CommandManager2 {
  constructor(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr: tr2 } = state;
    const props = this.buildProps(tr2);
    return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      const method = (...args) => {
        const callback = command2(...args)(props);
        if (!tr2.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr2);
        }
        return callback;
      };
      return [name, method];
    }));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr2 = startTr || state.tr;
    const run2 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr2.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr2);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain = {
      ...Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        const chainedCommand = (...args) => {
          const props = this.buildProps(tr2, shouldDispatch);
          const callback = command2(...args)(props);
          callbacks.push(callback);
          return chain;
        };
        return [name, chainedCommand];
      })),
      run: run2
    };
    return chain;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch = false;
    const tr2 = startTr || state.tr;
    const props = this.buildProps(tr2, dispatch);
    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
    }));
    return {
      ...formattedCommands,
      chain: () => this.createChain(tr2, dispatch)
    };
  }
  buildProps(tr2, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const props = {
      tr: tr2,
      editor,
      view,
      state: createChainableState({
        state,
        transaction: tr2
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr2, shouldDispatch),
      can: () => this.createCan(tr2),
      get commands() {
        return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          return [name, (...args) => command2(...args)(props)];
        }));
      }
    };
    return props;
  }
}
function getExtensionField(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({
      ...context,
      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
    });
    return value;
  }
  return extension.config[field];
}
function splitExtensions(extensions) {
  const baseExtensions = extensions.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions.filter((extension) => extension.type === "node");
  const markExtensions = extensions.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getNodeType(nameOrType, schema2) {
  if (typeof nameOrType === "string") {
    if (!schema2.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema2.nodes[nameOrType];
  }
  return nameOrType;
}
function mergeAttributes(...objects) {
  return objects.filter((item) => !!item).reduce((items2, item) => {
    const mergedAttributes = { ...items2 };
    Object.entries(item).forEach(([key, value]) => {
      const exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        const valueClasses = value ? value.split(" ") : [];
        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
      } else if (key === "style") {
        const newStyles = value ? value.split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const styleMap = /* @__PURE__ */ new Map();
        existingStyles.forEach((style2) => {
          const [property2, val] = style2.split(":").map((part) => part.trim());
          styleMap.set(property2, val);
        });
        newStyles.forEach((style2) => {
          const [property2, val] = style2.split(":").map((part) => part.trim());
          styleMap.set(property2, val);
        });
        mergedAttributes[key] = Array.from(styleMap.entries()).map(([property2, val]) => `${property2}: ${val}`).join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function isFunction(value) {
  return typeof value === "function";
}
function callOrReturn(value, context = void 0, ...props) {
  if (isFunction(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function isRegExp(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
class InputRule2 {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
}
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep$1(target, source) {
  const output = { ...target };
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject(source[key]) && isPlainObject(target[key])) {
        output[key] = mergeDeep$1(target[key], source[key]);
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
class Mark3 {
  constructor(config = {}) {
    this.type = "mark";
    this.name = "mark";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Mark3(config);
  }
  configure(options = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep$1(this.options, options);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Mark3(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  static handleExit({ editor, mark }) {
    const { tr: tr2 } = editor.state;
    const currentPos = editor.state.selection.$from;
    const isAtEnd = currentPos.pos === currentPos.end();
    if (isAtEnd) {
      const currentMarks = currentPos.marks();
      const isInMark = !!currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
      if (!isInMark) {
        return false;
      }
      const removeMark2 = currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
      if (removeMark2) {
        tr2.removeStoredMark(removeMark2);
      }
      tr2.insertText(" ", currentPos.pos);
      editor.view.dispatch(tr2);
      return true;
    }
    return false;
  }
}
class PasteRule2 {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
}
class Extension2 {
  constructor(config = {}) {
    this.type = "extension";
    this.name = "extension";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Extension2(config);
  }
  configure(options = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep$1(this.options, options);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Extension2({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
}
function getTextBetween(startNode, range, options) {
  const { from: from2, to } = range;
  const { blockSeparator = "\n\n", textSerializers = {} } = options;
  let text = "";
  startNode.nodesBetween(from2, to, (node, pos, parent, index2) => {
    var _a;
    if (node.isBlock && pos > from2) {
      text += blockSeparator;
    }
    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
    if (textSerializer) {
      if (parent) {
        text += textSerializer({
          node,
          pos,
          parent,
          index: index2,
          range
        });
      }
      return false;
    }
    if (node.isText) {
      text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from2, pos) - pos, to - pos);
    }
  });
  return text;
}
function getTextSerializersFromSchema(schema2) {
  return Object.fromEntries(Object.entries(schema2.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));
}
Extension2.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema: schema2 } = editor;
            const { doc: doc2, selection } = state;
            const { ranges } = selection;
            const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
            const to = Math.max(...ranges.map((range2) => range2.$to.pos));
            const textSerializers = getTextSerializersFromSchema(schema2);
            const range = { from: from2, to };
            return getTextBetween(doc2, range, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers
            });
          }
        }
      })
    ];
  }
});
const blur = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a;
    if (!editor.isDestroyed) {
      view.dom.blur();
      (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
    }
  });
  return true;
};
const clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {
  return commands2.setContent("", emitUpdate);
};
const clearNodes = () => ({ state, tr: tr2, dispatch }) => {
  const { selection } = tr2;
  const { ranges } = selection;
  if (!dispatch) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.type.isText) {
        return;
      }
      const { doc: doc2, mapping } = tr2;
      const $mappedFrom = doc2.resolve(mapping.map(pos));
      const $mappedTo = doc2.resolve(mapping.map(pos + node.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr2.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr2.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
const command = (fn2) => (props) => {
  return fn2(props);
};
const createParagraphNear = () => ({ state, dispatch }) => {
  return createParagraphNear$2(state, dispatch);
};
const cut = (originRange, targetPos) => ({ editor, tr: tr2 }) => {
  const { state } = editor;
  const contentSlice = state.doc.slice(originRange.from, originRange.to);
  tr2.deleteRange(originRange.from, originRange.to);
  const newPos = tr2.mapping.map(targetPos);
  tr2.insert(newPos, contentSlice.content);
  tr2.setSelection(new TextSelection(tr2.doc.resolve(newPos - 1)));
  return true;
};
const deleteCurrentNode = () => ({ tr: tr2, dispatch }) => {
  const { selection } = tr2;
  const currentNode = selection.$anchor.node();
  if (currentNode.content.size > 0) {
    return false;
  }
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === currentNode.type) {
      if (dispatch) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
const deleteNode = (typeOrName) => ({ tr: tr2, state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === type) {
      if (dispatch) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
const deleteRange = (range) => ({ tr: tr2, dispatch }) => {
  const { from: from2, to } = range;
  if (dispatch) {
    tr2.delete(from2, to);
  }
  return true;
};
const deleteSelection = () => ({ state, dispatch }) => {
  return deleteSelection$2(state, dispatch);
};
const enter = () => ({ commands: commands2 }) => {
  return commands2.keyboardShortcut("Enter");
};
const exitCode = () => ({ state, dispatch }) => {
  return exitCode$2(state, dispatch);
};
function objectIncludes(object1, object2, options = { strict: true }) {
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key) => {
    if (options.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet(marks, type, attributes = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes(
      // Only check equality for the attributes that are provided
      Object.fromEntries(Object.keys(attributes).map((k) => [k, item.attrs[k]])),
      attributes
    );
  });
}
function isMarkInSet(marks, type, attributes = {}) {
  return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange($pos, type, attributes) {
  var _a;
  if (!$pos || !type) {
    return;
  }
  let start2 = $pos.parent.childAfter($pos.parentOffset);
  if (!start2.node || !start2.node.marks.some((mark2) => mark2.type === type)) {
    start2 = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start2.node || !start2.node.marks.some((mark2) => mark2.type === type)) {
    return;
  }
  attributes = attributes || ((_a = start2.node.marks[0]) === null || _a === void 0 ? void 0 : _a.attrs);
  const mark = findMarkInSet([...start2.node.marks], type, attributes);
  if (!mark) {
    return;
  }
  let startIndex = start2.index;
  let startPos = $pos.start() + start2.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start2.node.nodeSize;
  while (startIndex > 0 && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getMarkType(nameOrType, schema2) {
  if (typeof nameOrType === "string") {
    if (!schema2.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema2.marks[nameOrType];
  }
  return nameOrType;
}
const extendMarkRange = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
  const type = getMarkType(typeOrName, state.schema);
  const { doc: doc2, selection } = tr2;
  const { $from, from: from2, to } = selection;
  if (dispatch) {
    const range = getMarkRange($from, type, attributes);
    if (range && range.from <= from2 && range.to >= to) {
      const newSelection = TextSelection.create(doc2, range.from, range.to);
      tr2.setSelection(newSelection);
    }
  }
  return true;
};
const first = (commands2) => (props) => {
  const items2 = typeof commands2 === "function" ? commands2(props) : commands2;
  for (let i = 0; i < items2.length; i += 1) {
    if (items2[i](props)) {
      return true;
    }
  }
  return false;
};
function isTextSelection(value) {
  return value instanceof TextSelection;
}
function minMax(value = 0, min2 = 0, max2 = 0) {
  return Math.min(Math.max(value, min2), max2);
}
function resolveFocusPosition(doc2, position2 = null) {
  if (!position2) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc2);
  const selectionAtEnd = Selection.atEnd(doc2);
  if (position2 === "start" || position2 === true) {
    return selectionAtStart;
  }
  if (position2 === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position2 === "all") {
    return TextSelection.create(doc2, minMax(0, minPos, maxPos), minMax(doc2.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc2, minMax(position2, minPos, maxPos), minMax(position2, minPos, maxPos));
}
function isiOS() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
const focus = (position2 = null, options = {}) => ({ editor, view, tr: tr2, dispatch }) => {
  options = {
    scrollIntoView: true,
    ...options
  };
  const delayedFocus = () => {
    if (isiOS()) {
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  if (view.hasFocus() && position2 === null || position2 === false) {
    return true;
  }
  if (dispatch && position2 === null && !isTextSelection(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition(tr2.doc, position2) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch) {
    if (!isSameSelection) {
      tr2.setSelection(selection);
    }
    if (isSameSelection && tr2.storedMarks) {
      tr2.setStoredMarks(tr2.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
const forEach = (items2, fn2) => (props) => {
  return items2.every((item, index2) => fn2(item, { ...props, index: index2 }));
};
const insertContent = (value, options) => ({ tr: tr2, commands: commands2 }) => {
  return commands2.insertContentAt({ from: tr2.selection.from, to: tr2.selection.to }, value, options);
};
const removeWhitespaces = (node) => {
  const children = node.childNodes;
  for (let i = children.length - 1; i >= 0; i -= 1) {
    const child = children[i];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node;
};
function elementFromString(value) {
  const wrappedValue = `<body>${value}</body>`;
  const html = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  return removeWhitespaces(html);
}
function createNodeFromContent(content, schema2, options) {
  if (content instanceof Node$3 || content instanceof Fragment) {
    return content;
  }
  options = {
    slice: true,
    parseOptions: {},
    ...options
  };
  const isJSONContent = typeof content === "object" && content !== null;
  const isTextContent = typeof content === "string";
  if (isJSONContent) {
    try {
      const isArrayContent = Array.isArray(content) && content.length > 0;
      if (isArrayContent) {
        return Fragment.fromArray(content.map((item) => schema2.nodeFromJSON(item)));
      }
      const node = schema2.nodeFromJSON(content);
      if (options.errorOnInvalidContent) {
        node.check();
      }
      return node;
    } catch (error) {
      if (options.errorOnInvalidContent) {
        throw new Error("[tiptap error]: Invalid JSON content", { cause: error });
      }
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
      return createNodeFromContent("", schema2, options);
    }
  }
  if (isTextContent) {
    if (options.errorOnInvalidContent) {
      let hasInvalidContent = false;
      let invalidContent = "";
      const contentCheckSchema = new Schema({
        topNode: schema2.spec.topNode,
        marks: schema2.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: schema2.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (e2) => {
                  hasInvalidContent = true;
                  invalidContent = typeof e2 === "string" ? e2 : e2.outerHTML;
                  return null;
                }
              }
            ]
          }
        })
      });
      if (options.slice) {
        DOMParser.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);
      } else {
        DOMParser.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);
      }
      if (options.errorOnInvalidContent && hasInvalidContent) {
        throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${invalidContent}`) });
      }
    }
    const parser = DOMParser.fromSchema(schema2);
    if (options.slice) {
      return parser.parseSlice(elementFromString(content), options.parseOptions).content;
    }
    return parser.parse(elementFromString(content), options.parseOptions);
  }
  return createNodeFromContent("", schema2, options);
}
function selectionToInsertionEnd(tr2, startLen, bias) {
  const last = tr2.steps.length - 1;
  if (last < startLen) {
    return;
  }
  const step = tr2.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map3 = tr2.mapping.maps[last];
  let end2 = 0;
  map3.forEach((_from, _to, _newFrom, newTo) => {
    if (end2 === 0) {
      end2 = newTo;
    }
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end2), bias));
}
const isFragment = (nodeOrFragment) => {
  return !("type" in nodeOrFragment);
};
const insertContentAt = (position2, value, options) => ({ tr: tr2, dispatch, editor }) => {
  var _a;
  if (dispatch) {
    options = {
      parseOptions: editor.options.parseOptions,
      updateSelection: true,
      applyInputRules: false,
      applyPasteRules: false,
      ...options
    };
    let content;
    try {
      content = createNodeFromContent(value, editor.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...options.parseOptions
        },
        errorOnInvalidContent: (_a = options.errorOnInvalidContent) !== null && _a !== void 0 ? _a : editor.options.enableContentCheck
      });
    } catch (e2) {
      editor.emit("contentError", {
        editor,
        error: e2,
        disableCollaboration: () => {
          if (editor.storage.collaboration) {
            editor.storage.collaboration.isDisabled = true;
          }
        }
      });
      return false;
    }
    let { from: from2, to } = typeof position2 === "number" ? { from: position2, to: position2 } : { from: position2.from, to: position2.to };
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content) ? content : [content];
    nodes.forEach((node) => {
      node.check();
      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
    });
    if (from2 === to && isOnlyBlockContent) {
      const { parent } = tr2.doc.resolve(from2);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from2 -= 1;
        to += 1;
      }
    }
    let newContent;
    if (isOnlyTextContent) {
      if (Array.isArray(value)) {
        newContent = value.map((v) => v.text || "").join("");
      } else if (value instanceof Fragment) {
        let text = "";
        value.forEach((node) => {
          if (node.text) {
            text += node.text;
          }
        });
        newContent = text;
      } else if (typeof value === "object" && !!value && !!value.text) {
        newContent = value.text;
      } else {
        newContent = value;
      }
      tr2.insertText(newContent, from2, to);
    } else {
      newContent = content;
      tr2.replaceWith(from2, to, newContent);
    }
    if (options.updateSelection) {
      selectionToInsertionEnd(tr2, tr2.steps.length - 1, -1);
    }
    if (options.applyInputRules) {
      tr2.setMeta("applyInputRules", { from: from2, text: newContent });
    }
    if (options.applyPasteRules) {
      tr2.setMeta("applyPasteRules", { from: from2, text: newContent });
    }
  }
  return true;
};
const joinUp = () => ({ state, dispatch }) => {
  return joinUp$2(state, dispatch);
};
const joinDown = () => ({ state, dispatch }) => {
  return joinDown$2(state, dispatch);
};
const joinBackward = () => ({ state, dispatch }) => {
  return joinBackward$2(state, dispatch);
};
const joinForward = () => ({ state, dispatch }) => {
  return joinForward$2(state, dispatch);
};
const joinItemBackward = () => ({ state, dispatch, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, -1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch) {
      dispatch(tr2);
    }
    return true;
  } catch (e2) {
    return false;
  }
};
const joinItemForward = () => ({ state, dispatch, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, 1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch) {
      dispatch(tr2);
    }
    return true;
  } catch (e2) {
    return false;
  }
};
const joinTextblockBackward = () => ({ state, dispatch }) => {
  return joinTextblockBackward$2(state, dispatch);
};
const joinTextblockForward = () => ({ state, dispatch }) => {
  return joinTextblockForward$2(state, dispatch);
};
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName(name) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  let alt;
  let ctrl;
  let shift3;
  let meta;
  for (let i = 0; i < parts.length - 1; i += 1) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift3 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result = `Alt-${result}`;
  }
  if (ctrl) {
    result = `Ctrl-${result}`;
  }
  if (meta) {
    result = `Meta-${result}`;
  }
  if (shift3) {
    result = `Shift-${result}`;
  }
  return result;
}
const keyboardShortcut = (name) => ({ editor, view, tr: tr2, dispatch }) => {
  const keys2 = normalizeKeyName(name).split(/-(?!$)/);
  const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key === "Space" ? " " : key,
    altKey: keys2.includes("Alt"),
    ctrlKey: keys2.includes("Ctrl"),
    metaKey: keys2.includes("Meta"),
    shiftKey: keys2.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f) => f(view, event));
  });
  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
    const newStep = step.map(tr2.mapping);
    if (newStep && dispatch) {
      tr2.maybeStep(newStep);
    }
  });
  return true;
};
function isNodeActive(state, typeOrName, attributes = {}) {
  const { from: from2, to, empty: empty2 } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isText) {
      return;
    }
    const relativeFrom = Math.max(from2, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from2;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty2) {
    return !!matchedNodeRanges.length;
  }
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
const lift = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (!isActive2) {
    return false;
  }
  return lift$2(state, dispatch);
};
const liftEmptyBlock = () => ({ state, dispatch }) => {
  return liftEmptyBlock$2(state, dispatch);
};
const liftListItem = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return liftListItem$2(type)(state, dispatch);
};
const newlineInCode = () => ({ state, dispatch }) => {
  return newlineInCode$2(state, dispatch);
};
function getSchemaTypeNameByName(name, schema2) {
  if (schema2.nodes[name]) {
    return "node";
  }
  if (schema2.marks[name]) {
    return "mark";
  }
  return null;
}
function deleteProps(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
const resetAttributes = (typeOrName, attributes) => ({ tr: tr2, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr2.selection.ranges.forEach((range) => {
      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr2.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr2.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
const scrollIntoView = () => ({ tr: tr2, dispatch }) => {
  if (dispatch) {
    tr2.scrollIntoView();
  }
  return true;
};
const selectAll = () => ({ tr: tr2, commands: commands2 }) => {
  return commands2.setTextSelection({
    from: 0,
    to: tr2.doc.content.size
  });
};
const selectNodeBackward = () => ({ state, dispatch }) => {
  return selectNodeBackward$2(state, dispatch);
};
const selectNodeForward = () => ({ state, dispatch }) => {
  return selectNodeForward$2(state, dispatch);
};
const selectParentNode = () => ({ state, dispatch }) => {
  return selectParentNode$2(state, dispatch);
};
const selectTextblockEnd = () => ({ state, dispatch }) => {
  return selectTextblockEnd$2(state, dispatch);
};
const selectTextblockStart = () => ({ state, dispatch }) => {
  return selectTextblockStart$2(state, dispatch);
};
function createDocument(content, schema2, parseOptions = {}, options = {}) {
  return createNodeFromContent(content, schema2, {
    slice: false,
    parseOptions,
    errorOnInvalidContent: options.errorOnInvalidContent
  });
}
const setContent = (content, emitUpdate = false, parseOptions = {}, options = {}) => ({ editor, tr: tr2, dispatch, commands: commands2 }) => {
  var _a, _b;
  const { doc: doc2 } = tr2;
  if (parseOptions.preserveWhitespace !== "full") {
    const document2 = createDocument(content, editor.schema, parseOptions, {
      errorOnInvalidContent: (_a = options.errorOnInvalidContent) !== null && _a !== void 0 ? _a : editor.options.enableContentCheck
    });
    if (dispatch) {
      tr2.replaceWith(0, doc2.content.size, document2).setMeta("preventUpdate", !emitUpdate);
    }
    return true;
  }
  if (dispatch) {
    tr2.setMeta("preventUpdate", !emitUpdate);
  }
  return commands2.insertContentAt({ from: 0, to: doc2.content.size }, content, {
    parseOptions,
    errorOnInvalidContent: (_b = options.errorOnInvalidContent) !== null && _b !== void 0 ? _b : editor.options.enableContentCheck
  });
};
function getMarkAttributes(state, typeOrName) {
  const type = getMarkType(typeOrName, state.schema);
  const { from: from2, to, empty: empty2 } = state.selection;
  const marks = [];
  if (empty2) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from2, to, (node) => {
      marks.push(...node.marks);
    });
  }
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark) {
    return {};
  }
  return { ...mark.attrs };
}
function defaultBlockAt(match2) {
  for (let i = 0; i < match2.edgeCount; i += 1) {
    const { type } = match2.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findParentNodeClosestToPos($pos, predicate) {
  for (let i = $pos.depth; i > 0; i -= 1) {
    const node = $pos.node(i);
    if (predicate(node)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node
      };
    }
  }
}
function findParentNode(predicate) {
  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}
function getMarksBetween(from2, to, doc2) {
  const marks = [];
  if (from2 === to) {
    doc2.resolve(from2).marks().forEach((mark) => {
      const $pos = doc2.resolve(from2);
      const range = getMarkRange($pos, mark.type);
      if (!range) {
        return;
      }
      marks.push({
        mark,
        ...range
      });
    });
  } else {
    doc2.nodesBetween(from2, to, (node, pos) => {
      if (!node || (node === null || node === void 0 ? void 0 : node.nodeSize) === void 0) {
        return;
      }
      marks.push(...node.marks.map((mark) => ({
        from: pos,
        to: pos + node.nodeSize,
        mark
      })));
    });
  }
  return marks;
}
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
    const extensionAttribute = extensionAttributes.find((item) => {
      return item.type === typeName && item.name === name;
    });
    if (!extensionAttribute) {
      return false;
    }
    return extensionAttribute.attribute.keepOnSplit;
  }));
}
function isMarkActive(state, typeOrName, attributes = {}) {
  const { empty: empty2, ranges } = state.selection;
  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty2) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from2 = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from2, to, (node, pos) => {
      if (!node.isText && !node.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from2, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(...node.marks.map((mark) => ({
        mark,
        from: relativeFrom,
        to: relativeTo
      })));
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function isList(name, extensions) {
  const { nodeExtensions } = splitExtensions(extensions);
  const extension = nodeExtensions.find((item) => item.name === name);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrReturn(getExtensionField(extension, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
function isNodeEmpty(node, { checkChildren = true, ignoreWhitespace = false } = {}) {
  var _a;
  if (ignoreWhitespace) {
    if (node.type.name === "hardBreak") {
      return true;
    }
    if (node.isText) {
      return /^\s*$/m.test((_a = node.text) !== null && _a !== void 0 ? _a : "");
    }
  }
  if (node.isText) {
    return !node.text;
  }
  if (node.isAtom || node.isLeaf) {
    return false;
  }
  if (node.content.childCount === 0) {
    return true;
  }
  if (checkChildren) {
    let isContentEmpty = true;
    node.content.forEach((childNode) => {
      if (isContentEmpty === false) {
        return;
      }
      if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {
        isContentEmpty = false;
      }
    });
    return isContentEmpty;
  }
  return false;
}
function isNodeSelection(value) {
  return value instanceof NodeSelection;
}
function canSetMark(state, tr2, newMarkType) {
  var _a;
  const { selection } = tr2;
  let cursor = null;
  if (isTextSelection(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
  }
  const { ranges } = selection;
  return ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
const setMark = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
  const { selection } = tr2;
  const { empty: empty2, ranges } = selection;
  const type = getMarkType(typeOrName, state.schema);
  if (dispatch) {
    if (empty2) {
      const oldAttributes = getMarkAttributes(state, type);
      tr2.addStoredMark(type.create({
        ...oldAttributes,
        ...attributes
      }));
    } else {
      ranges.forEach((range) => {
        const from2 = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from2, to, (node, pos) => {
          const trimmedFrom = Math.max(pos, from2);
          const trimmedTo = Math.min(pos + node.nodeSize, to);
          const someHasMark = node.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node.marks.forEach((mark) => {
              if (type === mark.type) {
                tr2.addMark(trimmedFrom, trimmedTo, type.create({
                  ...mark.attrs,
                  ...attributes
                }));
              }
            });
          } else {
            tr2.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark(state, tr2, type);
};
const setMeta = (key, value) => ({ tr: tr2 }) => {
  tr2.setMeta(key, value);
  return true;
};
const setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {
  const type = getNodeType(typeOrName, state.schema);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain().command(({ commands: commands2 }) => {
    const canSetBlock = setBlockType(type, { ...attributesToCopy, ...attributes })(state);
    if (canSetBlock) {
      return true;
    }
    return commands2.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch);
  }).run();
};
const setNodeSelection = (position2) => ({ tr: tr2, dispatch }) => {
  if (dispatch) {
    const { doc: doc2 } = tr2;
    const from2 = minMax(position2, 0, doc2.content.size);
    const selection = NodeSelection.create(doc2, from2);
    tr2.setSelection(selection);
  }
  return true;
};
const setTextSelection = (position2) => ({ tr: tr2, dispatch }) => {
  if (dispatch) {
    const { doc: doc2 } = tr2;
    const { from: from2, to } = typeof position2 === "number" ? { from: position2, to: position2 } : position2;
    const minPos = TextSelection.atStart(doc2).from;
    const maxPos = TextSelection.atEnd(doc2).to;
    const resolvedFrom = minMax(from2, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const selection = TextSelection.create(doc2, resolvedFrom, resolvedEnd);
    tr2.setSelection(selection);
  }
  return true;
};
const sinkListItem = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return sinkListItem$2(type)(state, dispatch);
};
function ensureMarks(state, splittableMarks) {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
const splitBlock = ({ keepMarks = true } = {}) => ({ tr: tr2, state, dispatch, editor }) => {
  const { selection, doc: doc2 } = tr2;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc2, $from.pos)) {
      return false;
    }
    if (dispatch) {
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr2.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  const atEnd = $to.parentOffset === $to.parent.content.size;
  const deflt = $from.depth === 0 ? void 0 : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
  let types = atEnd && deflt ? [
    {
      type: deflt,
      attrs: newAttributes
    }
  ] : void 0;
  let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types);
  if (!types && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
    can = true;
    types = deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : void 0;
  }
  if (dispatch) {
    if (can) {
      if (selection instanceof TextSelection) {
        tr2.deleteSelection();
      }
      tr2.split(tr2.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr2.mapping.map($from.before());
        const $first = tr2.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks(state, editor.extensionManager.splittableMarks);
    }
    tr2.scrollIntoView();
  }
  return can;
};
const splitListItem = (typeOrName, overrideAttrs = {}) => ({ tr: tr2, state, dispatch, editor }) => {
  var _a;
  const type = getNodeType(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node = state.selection.node;
  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch) {
      let wrap2 = Fragment.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
        wrap2 = Fragment.from($from.node(d).copy(wrap2));
      }
      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
      const newNextTypeAttributes2 = {
        ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
        ...overrideAttrs
      };
      const nextType2 = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
      const start2 = $from.before($from.depth - (depthBefore - 1));
      tr2.replace(start2, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
      let sel = -1;
      tr2.doc.nodesBetween(start2, tr2.doc.content.size, (n2, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n2.isTextblock && n2.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr2.setSelection(TextSelection.near(tr2.doc.resolve(sel)));
      }
      tr2.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),
    ...overrideAttrs
  };
  const newNextTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
    ...overrideAttrs
  };
  tr2.delete($from.pos, $to.pos);
  const types = nextType ? [
    { type, attrs: newTypeAttributes },
    { type: nextType, attrs: newNextTypeAttributes }
  ] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr2.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch) {
    const { selection, storedMarks } = state;
    const { splittableMarks } = editor.extensionManager;
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    tr2.split($from.pos, 2, types).scrollIntoView();
    if (!marks || !dispatch) {
      return true;
    }
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
  }
  return true;
};
const joinListBackwards = (tr2, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const before = tr2.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before === void 0) {
    return true;
  }
  const nodeBefore = tr2.doc.nodeAt(before);
  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr2.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr2.join(list.pos);
  return true;
};
const joinListForwards = (tr2, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const after = tr2.doc.resolve(list.start).after(list.depth);
  if (after === void 0) {
    return true;
  }
  const nodeAfter = tr2.doc.nodeAt(after);
  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr2.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr2.join(after);
  return true;
};
const toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr: tr2, state, dispatch, chain, commands: commands2, can }) => {
  const { extensions, splittableMarks } = editor.extensionManager;
  const listType = getNodeType(listTypeOrName, state.schema);
  const itemType = getNodeType(itemTypeOrName, state.schema);
  const { selection, storedMarks } = state;
  const { $from, $to } = selection;
  const range = $from.blockRange($to);
  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
  if (!range) {
    return false;
  }
  const parentList = findParentNode((node) => isList(node.type.name, extensions))(selection);
  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands2.liftListItem(itemType);
    }
    if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {
      return chain().command(() => {
        tr2.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
    }
  }
  if (!keepMarks || !marks || !dispatch) {
    return chain().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      if (canWrapInList) {
        return true;
      }
      return commands2.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
  }
  return chain().command(() => {
    const canWrapInList = can().wrapInList(listType, attributes);
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
    if (canWrapInList) {
      return true;
    }
    return commands2.clearNodes();
  }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
};
const toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands: commands2 }) => {
  const { extendEmptyMarkRange = false } = options;
  const type = getMarkType(typeOrName, state.schema);
  const isActive2 = isMarkActive(state, type, attributes);
  if (isActive2) {
    return commands2.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands2.setMark(type, attributes);
};
const toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const toggleType = getNodeType(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (isActive2) {
    return commands2.setNode(toggleType, attributesToCopy);
  }
  return commands2.setNode(type, { ...attributesToCopy, ...attributes });
};
const toggleWrap = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands2.lift(type);
  }
  return commands2.wrapIn(type, attributes);
};
const undoInputRule = () => ({ state, dispatch }) => {
  const plugins = state.plugins;
  for (let i = 0; i < plugins.length; i += 1) {
    const plugin = plugins[i];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch) {
        const tr2 = state.tr;
        const toUndo = undoable.transform;
        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
          tr2.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          const marks = tr2.doc.resolve(undoable.from).marks();
          tr2.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr2.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
const unsetAllMarks = () => ({ tr: tr2, dispatch }) => {
  const { selection } = tr2;
  const { empty: empty2, ranges } = selection;
  if (empty2) {
    return true;
  }
  if (dispatch) {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos);
    });
  }
  return true;
};
const unsetMark = (typeOrName, options = {}) => ({ tr: tr2, state, dispatch }) => {
  var _a;
  const { extendEmptyMarkRange = false } = options;
  const { selection } = tr2;
  const type = getMarkType(typeOrName, state.schema);
  const { $from, empty: empty2, ranges } = selection;
  if (!dispatch) {
    return true;
  }
  if (empty2 && extendEmptyMarkRange) {
    let { from: from2, to } = selection;
    const attrs2 = (_a = $from.marks().find((mark) => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;
    const range = getMarkRange($from, type, attrs2);
    if (range) {
      from2 = range.from;
      to = range.to;
    }
    tr2.removeMark(from2, to, type);
  } else {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos, type);
    });
  }
  tr2.removeStoredMark(type);
  return true;
};
const updateAttributes = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr2.selection.ranges.forEach((range) => {
      const from2 = range.$from.pos;
      const to = range.$to.pos;
      let lastPos;
      let lastNode;
      let trimmedFrom;
      let trimmedTo;
      if (tr2.selection.empty) {
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from2);
            trimmedTo = Math.min(pos + node.nodeSize, to);
            lastPos = pos;
            lastNode = node;
          }
        });
      } else {
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (pos < from2 && nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from2);
            trimmedTo = Math.min(pos + node.nodeSize, to);
            lastPos = pos;
            lastNode = node;
          }
          if (pos >= from2 && pos <= to) {
            if (nodeType && nodeType === node.type) {
              tr2.setNodeMarkup(pos, void 0, {
                ...node.attrs,
                ...attributes
              });
            }
            if (markType && node.marks.length) {
              node.marks.forEach((mark) => {
                if (markType === mark.type) {
                  const trimmedFrom2 = Math.max(pos, from2);
                  const trimmedTo2 = Math.min(pos + node.nodeSize, to);
                  tr2.addMark(trimmedFrom2, trimmedTo2, markType.create({
                    ...mark.attrs,
                    ...attributes
                  }));
                }
              });
            }
          }
        });
      }
      if (lastNode) {
        if (lastPos !== void 0) {
          tr2.setNodeMarkup(lastPos, void 0, {
            ...lastNode.attrs,
            ...attributes
          });
        }
        if (markType && lastNode.marks.length) {
          lastNode.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr2.addMark(trimmedFrom, trimmedTo, markType.create({
                ...mark.attrs,
                ...attributes
              }));
            }
          });
        }
      }
    });
  }
  return true;
};
const wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapIn$2(type, attributes)(state, dispatch);
};
const wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapInList$2(type, attributes)(state, dispatch);
};
var commands = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur,
  clearContent,
  clearNodes,
  command,
  createParagraphNear,
  cut,
  deleteCurrentNode,
  deleteNode,
  deleteRange,
  deleteSelection,
  enter,
  exitCode,
  extendMarkRange,
  first,
  focus,
  forEach,
  insertContent,
  insertContentAt,
  joinBackward,
  joinDown,
  joinForward,
  joinItemBackward,
  joinItemForward,
  joinTextblockBackward,
  joinTextblockForward,
  joinUp,
  keyboardShortcut,
  lift,
  liftEmptyBlock,
  liftListItem,
  newlineInCode,
  resetAttributes,
  scrollIntoView,
  selectAll,
  selectNodeBackward,
  selectNodeForward,
  selectParentNode,
  selectTextblockEnd,
  selectTextblockStart,
  setContent,
  setMark,
  setMeta,
  setNode,
  setNodeSelection,
  setTextSelection,
  sinkListItem,
  splitBlock,
  splitListItem,
  toggleList,
  toggleMark,
  toggleNode,
  toggleWrap,
  undoInputRule,
  unsetAllMarks,
  unsetMark,
  updateAttributes,
  wrapIn,
  wrapInList
});
Extension2.create({
  name: "commands",
  addCommands() {
    return {
      ...commands
    };
  }
});
Extension2.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapDrop"),
        props: {
          handleDrop: (_, e2, slice2, moved) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e2,
              slice: slice2,
              moved
            });
          }
        }
      })
    ];
  }
});
Extension2.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
Extension2.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: new PluginKey("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            }
          }
        }
      })
    ];
  }
});
Extension2.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.undoInputRule(),
      // maybe convert first text block node to default node
      () => commands2.command(({ tr: tr2 }) => {
        const { selection, doc: doc2 } = tr2;
        const { empty: empty2, $anchor } = selection;
        const { pos, parent } = $anchor;
        const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr2.doc.resolve(pos - 1) : $anchor;
        const parentIsIsolating = $parentPos.parent.type.spec.isolating;
        const parentPos = $anchor.pos - $anchor.parentOffset;
        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc2).from === pos;
        if (!empty2 || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
          return false;
        }
        return commands2.clearNodes();
      }),
      () => commands2.deleteSelection(),
      () => commands2.joinBackward(),
      () => commands2.selectNodeBackward()
    ]);
    const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.deleteSelection(),
      () => commands2.deleteCurrentNode(),
      () => commands2.joinForward(),
      () => commands2.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.newlineInCode(),
      () => commands2.createParagraphNear(),
      () => commands2.liftEmptyBlock(),
      () => commands2.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace,
      "Mod-Backspace": handleBackspace,
      "Shift-Backspace": handleBackspace,
      Delete: handleDelete,
      "Mod-Delete": handleDelete,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = {
      ...baseKeymap
    };
    const macKeymap = {
      ...baseKeymap,
      "Ctrl-h": handleBackspace,
      "Alt-Backspace": handleBackspace,
      "Ctrl-d": handleDelete,
      "Ctrl-Alt-Backspace": handleDelete,
      "Alt-Delete": handleDelete,
      "Alt-d": handleDelete,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    if (isiOS() || isMacOS()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
      // with many other commands.
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
          const ignoreTr = transactions.some((transaction) => transaction.getMeta("preventClearDocument"));
          if (!docChanges || ignoreTr) {
            return;
          }
          const { empty: empty2, from: from2, to } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from2 === allFrom && to === allEnd;
          if (empty2 || !allWasSelected) {
            return;
          }
          const isEmpty = isNodeEmpty(newState.doc);
          if (!isEmpty) {
            return;
          }
          const tr2 = newState.tr;
          const state = createChainableState({
            state: newState,
            transaction: tr2
          });
          const { commands: commands2 } = new CommandManager2({
            editor: this.editor,
            state
          });
          commands2.clearNodes();
          if (!tr2.steps.length) {
            return;
          }
          return tr2;
        }
      })
    ];
  }
});
Extension2.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapPaste"),
        props: {
          handlePaste: (_view, e2, slice2) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e2,
              slice: slice2
            });
          }
        }
      })
    ];
  }
});
Extension2.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
function markInputRule(config) {
  return new InputRule2({
    find: config.find,
    handler: ({ state, range, match: match2 }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match2);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match2[match2.length - 1];
      const fullMatch = match2[0];
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        const markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    }
  });
}
function nodeInputRule(config) {
  return new InputRule2({
    find: config.find,
    handler: ({ state, range, match: match2 }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match2) || {};
      const { tr: tr2 } = state;
      const start2 = range.from;
      let end2 = range.to;
      const newNode = config.type.create(attributes);
      if (match2[1]) {
        const offset3 = match2[0].lastIndexOf(match2[1]);
        let matchStart = start2 + offset3;
        if (matchStart > end2) {
          matchStart = end2;
        } else {
          end2 = matchStart + match2[1].length;
        }
        const lastChar = match2[0][match2[0].length - 1];
        tr2.insertText(lastChar, start2 + match2[0].length - 1);
        tr2.replaceWith(matchStart, end2, newNode);
      } else if (match2[0]) {
        const insertionStart = config.type.isInline ? start2 : start2 - 1;
        tr2.insert(insertionStart, config.type.create(attributes)).delete(tr2.mapping.map(start2), tr2.mapping.map(end2));
      }
      tr2.scrollIntoView();
    }
  });
}
function textblockTypeInputRule(config) {
  return new InputRule2({
    find: config.find,
    handler: ({ state, range, match: match2 }) => {
      const $start = state.doc.resolve(range.from);
      const attributes = callOrReturn(config.getAttributes, void 0, match2) || {};
      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
        return null;
      }
      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
    }
  });
}
function wrappingInputRule(config) {
  return new InputRule2({
    find: config.find,
    handler: ({ state, range, match: match2, chain }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match2) || {};
      const tr2 = state.tr.delete(range.from, range.to);
      const $start = tr2.doc.resolve(range.from);
      const blockRange = $start.blockRange();
      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
      if (!wrapping) {
        return null;
      }
      tr2.wrap(blockRange, wrapping);
      if (config.keepMarks && config.editor) {
        const { selection, storedMarks } = state;
        const { splittableMarks } = config.editor.extensionManager;
        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        if (marks) {
          const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
          tr2.ensureMarks(filteredMarks);
        }
      }
      if (config.keepAttributes) {
        const nodeType = config.type.name === "bulletList" || config.type.name === "orderedList" ? "listItem" : "taskList";
        chain().updateAttributes(nodeType, attributes).run();
      }
      const before = tr2.doc.resolve(range.from - 1).nodeBefore;
      if (before && before.type === config.type && canJoin(tr2.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match2, before))) {
        tr2.join(range.from - 1);
      }
    }
  });
}
let Node$1 = class Node4 {
  constructor(config = {}) {
    this.type = "node";
    this.name = "node";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Node4(config);
  }
  configure(options = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep$1(this.options, options);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Node4(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
};
function markPasteRule(config) {
  return new PasteRule2({
    find: config.find,
    handler: ({ state, range, match: match2, pasteEvent }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match2, pasteEvent);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match2[match2.length - 1];
      const fullMatch = match2[0];
      let markEnd = range.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    }
  });
}
const inputRegex$a = /^\s*>\s$/;
const Blockquote$1 = Node$1.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: true,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["blockquote", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: commands2 }) => {
        return commands2.wrapIn(this.name);
      },
      toggleBlockquote: () => ({ commands: commands2 }) => {
        return commands2.toggleWrap(this.name);
      },
      unsetBlockquote: () => ({ commands: commands2 }) => {
        return commands2.lift(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex$a,
        type: this.type
      })
    ];
  }
});
const starInputRegex$1 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/;
const starPasteRegex$1 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g;
const underscoreInputRegex$1 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/;
const underscorePasteRegex$1 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g;
const Bold = Mark3.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (node) => node.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (mark) => mark.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleBold: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetBold: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex$1,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex$1,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex$1,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex$1,
        type: this.type
      })
    ];
  }
});
const ListItemName$3 = "listItem";
const TextStyleName$3 = "textStyle";
const inputRegex$9 = /^\s*([-+*])\s$/;
const BulletList$1 = Node$1.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: commands2, chain }) => {
        if (this.options.keepAttributes) {
          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName$3, this.editor.getAttributes(TextStyleName$3)).run();
        }
        return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: inputRegex$9,
      type: this.type
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: inputRegex$9,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: () => {
          return this.editor.getAttributes(TextStyleName$3);
        },
        editor: this.editor
      });
    }
    return [
      inputRule
    ];
  }
});
const inputRegex$8 = /(?<!`)`([^`]+)`(?!`)/;
const pasteRegex$2 = /(?<!`)`([^`]+)`(?!`)/g;
const Code$1 = Mark3.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: true,
  exitable: true,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleCode: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetCode: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex$8,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex$2,
        type: this.type
      })
    ];
  }
});
const backtickInputRegex$1 = /^```([a-z]+)?[\s\n]$/;
const tildeInputRegex$1 = /^~~~([a-z]+)?[\s\n]$/;
const CodeBlock$1 = Node$1.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: true,
      exitOnArrowDown: true,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: true,
  defining: true,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (element) => {
          var _a;
          const { languageClassPrefix } = this.options;
          const classNames = [...((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || []];
          const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
          const language = languages[0];
          if (!language) {
            return null;
          }
          return language;
        },
        rendered: false
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "pre",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
      [
        "code",
        {
          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (attributes) => ({ commands: commands2 }) => {
        return commands2.setNode(this.name, attributes);
      },
      toggleCodeBlock: (attributes) => ({ commands: commands2 }) => {
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: empty2, $anchor } = this.editor.state.selection;
        const isAtStart = $anchor.pos === 1;
        if (!empty2 || $anchor.parent.type.name !== this.name) {
          return false;
        }
        if (isAtStart || !$anchor.parent.textContent.length) {
          return this.editor.commands.clearNodes();
        }
        return false;
      },
      // exit node on triple enter
      Enter: ({ editor }) => {
        if (!this.options.exitOnTripleEnter) {
          return false;
        }
        const { state } = editor;
        const { selection } = state;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
        if (!isAtEnd || !endsWithDoubleNewline) {
          return false;
        }
        return editor.chain().command(({ tr: tr2 }) => {
          tr2.delete($from.pos - 2, $from.pos);
          return true;
        }).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor }) => {
        if (!this.options.exitOnArrowDown) {
          return false;
        }
        const { state } = editor;
        const { selection, doc: doc2 } = state;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        if (!isAtEnd) {
          return false;
        }
        const after = $from.after();
        if (after === void 0) {
          return false;
        }
        const nodeAfter = doc2.nodeAt(after);
        if (nodeAfter) {
          return editor.commands.command(({ tr: tr2 }) => {
            tr2.setSelection(Selection.near(doc2.resolve(after)));
            return true;
          });
        }
        return editor.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      textblockTypeInputRule({
        find: backtickInputRegex$1,
        type: this.type,
        getAttributes: (match2) => ({
          language: match2[1]
        })
      }),
      textblockTypeInputRule({
        find: tildeInputRegex$1,
        type: this.type,
        getAttributes: (match2) => ({
          language: match2[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Plugin({
        key: new PluginKey("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (view, event) => {
            if (!event.clipboardData) {
              return false;
            }
            if (this.editor.isActive(this.type.name)) {
              return false;
            }
            const text = event.clipboardData.getData("text/plain");
            const vscode = event.clipboardData.getData("vscode-editor-data");
            const vscodeData = vscode ? JSON.parse(vscode) : void 0;
            const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;
            if (!text || !language) {
              return false;
            }
            const { tr: tr2, schema: schema2 } = view.state;
            const textNode = schema2.text(text.replace(/\r\n?/g, "\n"));
            tr2.replaceSelectionWith(this.type.create({ language }, textNode));
            if (tr2.selection.$from.parent.type !== this.type) {
              tr2.setSelection(TextSelection.near(tr2.doc.resolve(Math.max(0, tr2.selection.from - 2))));
            }
            tr2.setMeta("paste", true);
            view.dispatch(tr2);
            return true;
          }
        }
      })
    ];
  }
});
const Document = Node$1.create({
  name: "doc",
  topNode: true,
  content: "block+"
});
function dropCursor(options = {}) {
  return new Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options);
    }
  });
}
class DropCursorView {
  constructor(editorView, options) {
    var _a;
    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;
    this.color = options.color === false ? void 0 : options.color || "black";
    this.class = options.class;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
      let handler = (e2) => {
        this[name](e2);
      };
      editorView.dom.addEventListener(name, handler);
      return { name, handler };
    });
  }
  destroy() {
    this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
  }
  update(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size)
        this.setCursor(null);
      else
        this.updateOverlay();
    }
  }
  setCursor(pos) {
    if (pos == this.cursorPos)
      return;
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  }
  updateOverlay() {
    let $pos = this.editorView.state.doc.resolve(this.cursorPos);
    let isBlock = !$pos.parent.inlineContent, rect;
    if (isBlock) {
      let before = $pos.nodeBefore, after = $pos.nodeAfter;
      if (before || after) {
        let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
        if (node) {
          let nodeRect = node.getBoundingClientRect();
          let top2 = before ? nodeRect.bottom : nodeRect.top;
          if (before && after)
            top2 = (top2 + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          rect = { left: nodeRect.left, right: nodeRect.right, top: top2 - this.width / 2, bottom: top2 + this.width / 2 };
        }
      }
    }
    if (!rect) {
      let coords = this.editorView.coordsAtPos(this.cursorPos);
      rect = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };
    }
    let parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class)
        this.element.className = this.class;
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
      if (this.color) {
        this.element.style.backgroundColor = this.color;
      }
    }
    this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
    this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
    let parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      let rect2 = parent.getBoundingClientRect();
      parentLeft = rect2.left - parent.scrollLeft;
      parentTop = rect2.top - parent.scrollTop;
    }
    this.element.style.left = rect.left - parentLeft + "px";
    this.element.style.top = rect.top - parentTop + "px";
    this.element.style.width = rect.right - rect.left + "px";
    this.element.style.height = rect.bottom - rect.top + "px";
  }
  scheduleRemoval(timeout2) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.setCursor(null), timeout2);
  }
  dragover(event) {
    if (!this.editorView.editable)
      return;
    let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
    let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    let disableDropCursor = node && node.type.spec.disableDropCursor;
    let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
    if (pos && !disabled) {
      let target = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
        if (point != null)
          target = point;
      }
      this.setCursor(target);
      this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(event) {
    if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))
      this.setCursor(null);
  }
}
const Dropcursor = Extension2.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      dropCursor(this.options)
    ];
  }
});
class GapCursor extends Selection {
  /**
  Create a gap cursor.
  */
  constructor($pos) {
    super($pos, $pos);
  }
  map(doc2, mapping) {
    let $pos = doc2.resolve(mapping.map(this.head));
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
  content() {
    return Slice.empty;
  }
  eq(other) {
    return other instanceof GapCursor && other.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new GapCursor(doc2.resolve(json.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new GapBookmark(this.anchor);
  }
  /**
  @internal
  */
  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
      return false;
    let override = parent.type.spec.allowGapCursor;
    if (override != null)
      return override;
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom($pos, dir, mustMove = false) {
    search: for (; ; ) {
      if (!mustMove && GapCursor.valid($pos))
        return $pos;
      let pos = $pos.pos, next = null;
      for (let d = $pos.depth; ; d--) {
        let parent = $pos.node(d);
        if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
          next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
          break;
        } else if (d == 0) {
          return null;
        }
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (GapCursor.valid($cur))
          return $cur;
      }
      for (; ; ) {
        let inside = dir > 0 ? next.firstChild : next.lastChild;
        if (!inside) {
          if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
            $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
            mustMove = false;
            continue search;
          }
          break;
        }
        next = inside;
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (GapCursor.valid($cur))
          return $cur;
      }
      return null;
    }
  }
}
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
Selection.jsonID("gapcursor", GapCursor);
class GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new GapBookmark(mapping.map(this.pos));
  }
  resolve(doc2) {
    let $pos = doc2.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
}
function closedBefore($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index2 = $pos.index(d), parent = $pos.node(d);
    if (index2 == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let before = parent.child(index2 - 1); ; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
        return true;
      if (before.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index2 = $pos.indexAfter(d), parent = $pos.node(d);
    if (index2 == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let after = parent.child(index2); ; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
        return true;
      if (after.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown,
      handleDOMEvents: { beforeinput }
    }
  });
}
const handleKeyDown = keydownHandler({
  "ArrowLeft": arrow("horiz", -1),
  "ArrowRight": arrow("horiz", 1),
  "ArrowUp": arrow("vert", -1),
  "ArrowDown": arrow("vert", 1)
});
function arrow(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch, view) {
    let sel = state.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  let { $from } = view.state.selection;
  let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert)
    return false;
  let frag = Fragment.empty;
  for (let i = insert.length - 1; i >= 0; i--)
    frag = Fragment.from(insert[i].createAndFill(null, frag));
  let tr2 = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr2.setSelection(TextSelection.near(tr2.doc.resolve($from.pos + 1)));
  view.dispatch(tr2);
  return false;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor))
    return null;
  let node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
}
const Gapcursor = Extension2.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      gapCursor()
    ];
  },
  extendNodeSchema(extension) {
    var _a;
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      allowGapCursor: (_a = callOrReturn(getExtensionField(extension, "allowGapCursor", context))) !== null && _a !== void 0 ? _a : null
    };
  }
});
const HardBreak = Node$1.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: true,
      HTMLAttributes: {}
    };
  },
  inline: true,
  group: "inline",
  selectable: false,
  linebreakReplacement: true,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  renderText() {
    return "\n";
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: commands2, chain, state, editor }) => {
        return commands2.first([
          () => commands2.exitCode(),
          () => commands2.command(() => {
            const { selection, storedMarks } = state;
            if (selection.$from.parent.type.spec.isolating) {
              return false;
            }
            const { keepMarks } = this.options;
            const { splittableMarks } = editor.extensionManager;
            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
            return chain().insertContent({ type: this.name }).command(({ tr: tr2, dispatch }) => {
              if (dispatch && marks && keepMarks) {
                const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
                tr2.ensureMarks(filteredMarks);
              }
              return true;
            }).run();
          })
        ]);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
});
const Heading = Node$1.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: true,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: false
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((level) => ({
      tag: `h${level}`,
      attrs: { level }
    }));
  },
  renderHTML({ node, HTMLAttributes }) {
    const hasLevel = this.options.levels.includes(node.attrs.level);
    const level = hasLevel ? node.attrs.level : this.options.levels[0];
    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.setNode(this.name, attributes);
      },
      toggleHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((items2, level) => ({
      ...items2,
      ...{
        [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
      }
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((level) => {
      return textblockTypeInputRule({
        find: new RegExp(`^(#{1,${level}})\\s$`),
        type: this.type,
        getAttributes: {
          level
        }
      });
    });
  }
});
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice(from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  if (from2 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get2(i) {
  if (i < 0 || i >= this.length) {
    return void 0;
  }
  return this.getInner(i);
};
RopeSequence.prototype.forEach = function forEach2(f, from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  if (from2 <= to) {
    this.forEachInner(f, from2, to, 0);
  } else {
    this.forEachInvertedInner(f, from2, to, 0);
  }
};
RopeSequence.prototype.map = function map(f, from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  var result = [];
  this.forEach(function(elt, i) {
    return result.push(f(elt, i));
  }, from2, to);
  return result;
};
RopeSequence.from = function from(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from2, to));
  };
  Leaf2.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
    for (var i = from2; i < to; i++) {
      if (f(this.values[i], start2 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
    for (var i = from2 - 1; i >= to; i--) {
      if (f(this.values[i], start2 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors);
  return Leaf2;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ function(RopeSequence3) {
  function Append2(left2, right2) {
    RopeSequence3.call(this);
    this.left = left2;
    this.right = right2;
    this.length = left2.length + right2.length;
    this.depth = Math.max(left2.depth, right2.depth) + 1;
  }
  Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
    var leftLen = this.left.length;
    if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start2) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start2 + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
    var leftLen = this.left.length;
    if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start2 + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start2) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from2, to);
    }
    if (from2 >= leftLen) {
      return this.right.slice(from2 - leftLen, to - leftLen);
    }
    return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
}(RopeSequence);
const max_empty_items = 500;
class Branch {
  constructor(items2, eventCount) {
    this.items = items2;
    this.eventCount = eventCount;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(state, preserveItems) {
    if (this.eventCount == 0)
      return null;
    let end2 = this.items.length;
    for (; ; end2--) {
      let next = this.items.get(end2 - 1);
      if (next.selection) {
        --end2;
        break;
      }
    }
    let remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end2, this.items.length);
      mapFrom = remap.maps.length;
    }
    let transform = state.tr;
    let selection, remaining;
    let addAfter = [], addBefore = [];
    this.items.forEach((item, i) => {
      if (!item.step) {
        if (!remap) {
          remap = this.remapping(end2, i + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item);
        return;
      }
      if (remap) {
        addBefore.push(new Item(item.map));
        let step = item.step.map(remap.slice(mapFrom)), map3;
        if (step && transform.maybeStep(step).doc) {
          map3 = transform.mapping.maps[transform.mapping.maps.length - 1];
          addAfter.push(new Item(map3, void 0, void 0, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map3)
          remap.appendMap(map3, mapFrom);
      } else {
        transform.maybeStep(item.step);
      }
      if (item.selection) {
        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
        remaining = new Branch(this.items.slice(0, end2).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform, selection };
  }
  // Create a new branch with the given transform added.
  addTransform(transform, selection, histOptions, preserveItems) {
    let newItems = [], eventCount = this.eventCount;
    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (let i = 0; i < transform.steps.length; i++) {
      let step = transform.steps[i].invert(transform.docs[i]);
      let item = new Item(transform.mapping.maps[i], step, selection), merged;
      if (merged = lastItem && lastItem.merge(item)) {
        item = merged;
        if (i)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item);
      if (selection) {
        eventCount++;
        selection = void 0;
      }
      if (!preserveItems)
        lastItem = item;
    }
    let overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new Branch(oldItems.append(newItems), eventCount);
  }
  remapping(from2, to) {
    let maps = new Mapping();
    this.items.forEach((item, i) => {
      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
      maps.appendMap(item.map, mirrorPos);
    }, from2, to);
    return maps;
  }
  addMaps(array2) {
    if (this.eventCount == 0)
      return this;
    return new Branch(this.items.append(array2.map((map3) => new Item(map3))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    let rebasedItems = [], start2 = Math.max(0, this.items.length - rebasedCount);
    let mapping = rebasedTransform.mapping;
    let newUntil = rebasedTransform.steps.length;
    let eventCount = this.eventCount;
    this.items.forEach((item) => {
      if (item.selection)
        eventCount--;
    }, start2);
    let iRebased = rebasedCount;
    this.items.forEach((item) => {
      let pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      let map3 = mapping.maps[pos];
      if (item.step) {
        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item(map3, step, selection));
      } else {
        rebasedItems.push(new Item(map3));
      }
    }, start2);
    let newMaps = [];
    for (let i = rebasedCount; i < newUntil; i++)
      newMaps.push(new Item(mapping.maps[i]));
    let items2 = this.items.slice(0, start2).append(newMaps).append(rebasedItems);
    let branch = new Branch(items2, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  }
  emptyItemCount() {
    let count = 0;
    this.items.forEach((item) => {
      if (!item.step)
        count++;
    });
    return count;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(upto = this.items.length) {
    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    let items2 = [], events = 0;
    this.items.forEach((item, i) => {
      if (i >= upto) {
        items2.push(item);
        if (item.selection)
          events++;
      } else if (item.step) {
        let step = item.step.map(remap.slice(mapFrom)), map3 = step && step.getMap();
        mapFrom--;
        if (map3)
          remap.appendMap(map3, mapFrom);
        if (step) {
          let selection = item.selection && item.selection.map(remap.slice(mapFrom));
          if (selection)
            events++;
          let newItem = new Item(map3.invert(), step, selection), merged, last = items2.length - 1;
          if (merged = items2.length && items2[last].merge(newItem))
            items2[last] = merged;
          else
            items2.push(newItem);
        }
      } else if (item.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new Branch(RopeSequence.from(items2.reverse()), events);
  }
}
Branch.empty = new Branch(RopeSequence.empty, 0);
function cutOffEvents(items2, n2) {
  let cutPoint;
  items2.forEach((item, i) => {
    if (item.selection && n2-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items2.slice(cutPoint);
}
class Item {
  constructor(map3, step, selection, mirrorOffset) {
    this.map = map3;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  merge(other) {
    if (this.step && other.step && !other.selection) {
      let step = other.step.merge(this.step);
      if (step)
        return new Item(step.getMap().invert(), step, this.selection);
    }
  }
}
class HistoryState {
  constructor(done, undone, prevRanges, prevTime, prevComposition) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
    this.prevComposition = prevComposition;
  }
}
const DEPTH_OVERFLOW = 20;
function applyTransaction(history2, state, tr2, options) {
  let historyTr = tr2.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr2.getMeta(closeHistoryKey))
    history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
  let appended = tr2.getMeta("appendedTransaction");
  if (tr2.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history2.done.addTransform(tr2, void 0, options, mustPreserveItems(state)), history2.undone, rangesFor(tr2.mapping.maps), history2.prevTime, history2.prevComposition);
    else
      return new HistoryState(history2.done, history2.undone.addTransform(tr2, void 0, options, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
  } else if (tr2.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let composition = tr2.getMeta("composition");
    let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr2.time || 0) - options.newGroupDelay || !isAdjacentTo(tr2, history2.prevRanges));
    let prevRanges = appended ? mapRanges(history2.prevRanges, tr2.mapping) : rangesFor(tr2.mapping.maps);
    return new HistoryState(history2.done.addTransform(tr2, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr2.time, composition == null ? history2.prevComposition : composition);
  } else if (rebased = tr2.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr2, rebased), history2.undone.rebased(tr2, rebased), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  } else {
    return new HistoryState(history2.done.addMaps(tr2.mapping.maps), history2.undone.addMaps(tr2.mapping.maps), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform.docChanged)
    return true;
  let adjacent = false;
  transform.mapping.maps[0].forEach((start2, end2) => {
    for (let i = 0; i < prevRanges.length; i += 2)
      if (start2 <= prevRanges[i + 1] && end2 >= prevRanges[i])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(maps) {
  let result = [];
  for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)
    maps[i].forEach((_from, _to, from2, to) => result.push(from2, to));
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result = [];
  for (let i = 0; i < ranges.length; i += 2) {
    let from2 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
    if (from2 <= to)
      result.push(from2, to);
  }
  return result;
}
function histTransaction(history2, state, redo2) {
  let preserveItems = mustPreserveItems(state);
  let histOptions = historyKey.get(state).spec.config;
  let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop)
    return null;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
  return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist });
}
let cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  let plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (let i = 0; i < plugins.length; i++)
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
const historyKey = new PluginKey("history");
const closeHistoryKey = new PluginKey("closeHistory");
function history(config = {}) {
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply(tr2, hist, state) {
        return applyTransaction(hist, state, tr2, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput(view, e2) {
          let inputType = e2.inputType;
          let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command2)
            return false;
          e2.preventDefault();
          return command2(view.state, view.dispatch);
        }
      }
    }
  });
}
function buildCommand(redo2, scroll2) {
  return (state, dispatch) => {
    let hist = historyKey.getState(state);
    if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0)
      return false;
    if (dispatch) {
      let tr2 = histTransaction(hist, state, redo2);
      if (tr2)
        dispatch(scroll2 ? tr2.scrollIntoView() : tr2);
    }
    return true;
  };
}
const undo = buildCommand(false, true);
const redo = buildCommand(true, true);
const History = Extension2.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state, dispatch }) => {
        return undo(state, dispatch);
      },
      redo: () => ({ state, dispatch }) => {
        return redo(state, dispatch);
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      history(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-": () => this.editor.commands.undo(),
      "Shift-Mod-": () => this.editor.commands.redo()
    };
  }
});
const HorizontalRule$1 = Node$1.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain, state }) => {
        const { selection } = state;
        const { $from: $originFrom, $to: $originTo } = selection;
        const currentChain = chain();
        if ($originFrom.parentOffset === 0) {
          currentChain.insertContentAt({
            from: Math.max($originFrom.pos - 1, 0),
            to: $originTo.pos
          }, {
            type: this.name
          });
        } else if (isNodeSelection(selection)) {
          currentChain.insertContentAt($originTo.pos, {
            type: this.name
          });
        } else {
          currentChain.insertContent({ type: this.name });
        }
        return currentChain.command(({ tr: tr2, dispatch }) => {
          var _a;
          if (dispatch) {
            const { $to } = tr2.selection;
            const posAfter = $to.end();
            if ($to.nodeAfter) {
              if ($to.nodeAfter.isTextblock) {
                tr2.setSelection(TextSelection.create(tr2.doc, $to.pos + 1));
              } else if ($to.nodeAfter.isBlock) {
                tr2.setSelection(NodeSelection.create(tr2.doc, $to.pos));
              } else {
                tr2.setSelection(TextSelection.create(tr2.doc, $to.pos));
              }
            } else {
              const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();
              if (node) {
                tr2.insert(posAfter, node);
                tr2.setSelection(TextSelection.create(tr2.doc, posAfter + 1));
              }
            }
            tr2.scrollIntoView();
          }
          return true;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: /^(?:---|-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
});
const starInputRegex = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/;
const starPasteRegex = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g;
const underscoreInputRegex = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/;
const underscorePasteRegex = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g;
const Italic = Mark3.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (node) => node.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (mark) => mark.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleItalic: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetItalic: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex,
        type: this.type
      })
    ];
  }
});
const ListItem$1 = Node$1.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});
const ListItemName$2 = "listItem";
const TextStyleName$2 = "textStyle";
const inputRegex$7 = /^(\d+)\.\s$/;
const OrderedList$1 = Node$1.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (element) => {
          return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
        }
      },
      type: {
        default: void 0,
        parseHTML: (element) => element.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    const { start: start2, ...attributesWithoutStart } = HTMLAttributes;
    return start2 === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: commands2, chain }) => {
        if (this.options.keepAttributes) {
          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName$2, this.editor.getAttributes(TextStyleName$2)).run();
        }
        return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: inputRegex$7,
      type: this.type,
      getAttributes: (match2) => ({ start: +match2[1] }),
      joinPredicate: (match2, node) => node.childCount + node.attrs.start === +match2[1]
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: inputRegex$7,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: (match2) => ({ start: +match2[1], ...this.editor.getAttributes(TextStyleName$2) }),
        joinPredicate: (match2, node) => node.childCount + node.attrs.start === +match2[1],
        editor: this.editor
      });
    }
    return [
      inputRule
    ];
  }
});
const Paragraph = Node$1.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: commands2 }) => {
        return commands2.setNode(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
});
const inputRegex$6 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/;
const pasteRegex$1 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g;
const Strike = Mark3.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("line-through") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleStrike: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetStrike: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex$6,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex$1,
        type: this.type
      })
    ];
  }
});
const Text$1 = Node$1.create({
  name: "text",
  group: "inline"
});
const StarterKit = Extension2.create({
  name: "starterKit",
  addExtensions() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    const extensions = [];
    if (this.options.bold !== false) {
      extensions.push(Bold.configure((_a = this.options) === null || _a === void 0 ? void 0 : _a.bold));
    }
    if (this.options.blockquote !== false) {
      extensions.push(Blockquote$1.configure((_b = this.options) === null || _b === void 0 ? void 0 : _b.blockquote));
    }
    if (this.options.bulletList !== false) {
      extensions.push(BulletList$1.configure((_c = this.options) === null || _c === void 0 ? void 0 : _c.bulletList));
    }
    if (this.options.code !== false) {
      extensions.push(Code$1.configure((_d = this.options) === null || _d === void 0 ? void 0 : _d.code));
    }
    if (this.options.codeBlock !== false) {
      extensions.push(CodeBlock$1.configure((_e = this.options) === null || _e === void 0 ? void 0 : _e.codeBlock));
    }
    if (this.options.document !== false) {
      extensions.push(Document.configure((_f = this.options) === null || _f === void 0 ? void 0 : _f.document));
    }
    if (this.options.dropcursor !== false) {
      extensions.push(Dropcursor.configure((_g = this.options) === null || _g === void 0 ? void 0 : _g.dropcursor));
    }
    if (this.options.gapcursor !== false) {
      extensions.push(Gapcursor.configure((_h = this.options) === null || _h === void 0 ? void 0 : _h.gapcursor));
    }
    if (this.options.hardBreak !== false) {
      extensions.push(HardBreak.configure((_j = this.options) === null || _j === void 0 ? void 0 : _j.hardBreak));
    }
    if (this.options.heading !== false) {
      extensions.push(Heading.configure((_k = this.options) === null || _k === void 0 ? void 0 : _k.heading));
    }
    if (this.options.history !== false) {
      extensions.push(History.configure((_l = this.options) === null || _l === void 0 ? void 0 : _l.history));
    }
    if (this.options.horizontalRule !== false) {
      extensions.push(HorizontalRule$1.configure((_m = this.options) === null || _m === void 0 ? void 0 : _m.horizontalRule));
    }
    if (this.options.italic !== false) {
      extensions.push(Italic.configure((_o = this.options) === null || _o === void 0 ? void 0 : _o.italic));
    }
    if (this.options.listItem !== false) {
      extensions.push(ListItem$1.configure((_p = this.options) === null || _p === void 0 ? void 0 : _p.listItem));
    }
    if (this.options.orderedList !== false) {
      extensions.push(OrderedList$1.configure((_q = this.options) === null || _q === void 0 ? void 0 : _q.orderedList));
    }
    if (this.options.paragraph !== false) {
      extensions.push(Paragraph.configure((_r = this.options) === null || _r === void 0 ? void 0 : _r.paragraph));
    }
    if (this.options.strike !== false) {
      extensions.push(Strike.configure((_s = this.options) === null || _s === void 0 ? void 0 : _s.strike));
    }
    if (this.options.text !== false) {
      extensions.push(Text$1.configure((_t = this.options) === null || _t === void 0 ? void 0 : _t.text));
    }
    return extensions;
  }
});
const HorizontalRule = Node$2.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["hr", mergeAttributes$1(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain, state }) => {
        const { selection } = state;
        const { $from: $originFrom, $to: $originTo } = selection;
        const currentChain = chain();
        if ($originFrom.parentOffset === 0) {
          currentChain.insertContentAt({
            from: Math.max($originFrom.pos - 1, 0),
            to: $originTo.pos
          }, {
            type: this.name
          });
        } else if (isNodeSelection$1(selection)) {
          currentChain.insertContentAt($originTo.pos, {
            type: this.name
          });
        } else {
          currentChain.insertContent({ type: this.name });
        }
        return currentChain.command(({ tr: tr2, dispatch }) => {
          var _a;
          if (dispatch) {
            const { $to } = tr2.selection;
            const posAfter = $to.end();
            if ($to.nodeAfter) {
              if ($to.nodeAfter.isTextblock) {
                tr2.setSelection(TextSelection.create(tr2.doc, $to.pos + 1));
              } else if ($to.nodeAfter.isBlock) {
                tr2.setSelection(NodeSelection.create(tr2.doc, $to.pos));
              } else {
                tr2.setSelection(TextSelection.create(tr2.doc, $to.pos));
              }
            } else {
              const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();
              if (node) {
                tr2.insert(posAfter, node);
                tr2.setSelection(TextSelection.create(tr2.doc, posAfter + 1));
              }
            }
            tr2.scrollIntoView();
          }
          return true;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule$1({
        find: /^(?:---|-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
});
const encodedTlds = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
const encodedUtlds = "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222";
const assign = (target, properties) => {
  for (const key in properties) {
    target[key] = properties[key];
  }
  return target;
};
const numeric = "numeric";
const ascii = "ascii";
const alpha = "alpha";
const asciinumeric = "asciinumeric";
const alphanumeric = "alphanumeric";
const domain = "domain";
const emoji = "emoji";
const scheme = "scheme";
const slashscheme = "slashscheme";
const whitespace = "whitespace";
function registerGroup(name, groups) {
  if (!(name in groups)) {
    groups[name] = [];
  }
  return groups[name];
}
function addToGroups(t2, flags, groups) {
  if (flags[numeric]) {
    flags[asciinumeric] = true;
    flags[alphanumeric] = true;
  }
  if (flags[ascii]) {
    flags[asciinumeric] = true;
    flags[alpha] = true;
  }
  if (flags[asciinumeric]) {
    flags[alphanumeric] = true;
  }
  if (flags[alpha]) {
    flags[alphanumeric] = true;
  }
  if (flags[alphanumeric]) {
    flags[domain] = true;
  }
  if (flags[emoji]) {
    flags[domain] = true;
  }
  for (const k in flags) {
    const group = registerGroup(k, groups);
    if (group.indexOf(t2) < 0) {
      group.push(t2);
    }
  }
}
function flagsForToken(t2, groups) {
  const result = {};
  for (const c2 in groups) {
    if (groups[c2].indexOf(t2) >= 0) {
      result[c2] = true;
    }
  }
  return result;
}
function State(token = null) {
  this.j = {};
  this.jr = [];
  this.jd = null;
  this.t = token;
}
State.groups = {};
State.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(input) {
    const state = this;
    const nextState = state.j[input];
    if (nextState) {
      return nextState;
    }
    for (let i = 0; i < state.jr.length; i++) {
      const regex = state.jr[i][0];
      const nextState2 = state.jr[i][1];
      if (nextState2 && regex.test(input)) {
        return nextState2;
      }
    }
    return state.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(input, exactOnly = false) {
    return exactOnly ? input in this.j : !!this.go(input);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(inputs, next, flags, groups) {
    for (let i = 0; i < inputs.length; i++) {
      this.tt(inputs[i], next, flags, groups);
    }
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(regexp, next, flags, groups) {
    groups = groups || State.groups;
    let nextState;
    if (next && next.j) {
      nextState = next;
    } else {
      nextState = new State(next);
      if (flags && groups) {
        addToGroups(next, flags, groups);
      }
    }
    this.jr.push([regexp, nextState]);
    return nextState;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(input, next, flags, groups) {
    let state = this;
    const len = input.length;
    if (!len) {
      return state;
    }
    for (let i = 0; i < len - 1; i++) {
      state = state.tt(input[i]);
    }
    return state.tt(input[len - 1], next, flags, groups);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(input, next, flags, groups) {
    groups = groups || State.groups;
    const state = this;
    if (next && next.j) {
      state.j[input] = next;
      return next;
    }
    const t2 = next;
    let nextState, templateState = state.go(input);
    if (templateState) {
      nextState = new State();
      assign(nextState.j, templateState.j);
      nextState.jr.push.apply(nextState.jr, templateState.jr);
      nextState.jd = templateState.jd;
      nextState.t = templateState.t;
    } else {
      nextState = new State();
    }
    if (t2) {
      if (groups) {
        if (nextState.t && typeof nextState.t === "string") {
          const allFlags = assign(flagsForToken(nextState.t, groups), flags);
          addToGroups(t2, allFlags, groups);
        } else if (flags) {
          addToGroups(t2, flags, groups);
        }
      }
      nextState.t = t2;
    }
    state.j[input] = nextState;
    return nextState;
  }
};
const ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);
const tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);
const ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);
const tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);
const WORD = "WORD";
const UWORD = "UWORD";
const ASCIINUMERICAL = "ASCIINUMERICAL";
const ALPHANUMERICAL = "ALPHANUMERICAL";
const LOCALHOST = "LOCALHOST";
const TLD = "TLD";
const UTLD = "UTLD";
const SCHEME = "SCHEME";
const SLASH_SCHEME = "SLASH_SCHEME";
const NUM = "NUM";
const WS = "WS";
const NL = "NL";
const OPENBRACE = "OPENBRACE";
const CLOSEBRACE = "CLOSEBRACE";
const OPENBRACKET = "OPENBRACKET";
const CLOSEBRACKET = "CLOSEBRACKET";
const OPENPAREN = "OPENPAREN";
const CLOSEPAREN = "CLOSEPAREN";
const OPENANGLEBRACKET = "OPENANGLEBRACKET";
const CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
const FULLWIDTHLEFTPAREN = "FULLWIDTHLEFTPAREN";
const FULLWIDTHRIGHTPAREN = "FULLWIDTHRIGHTPAREN";
const LEFTCORNERBRACKET = "LEFTCORNERBRACKET";
const RIGHTCORNERBRACKET = "RIGHTCORNERBRACKET";
const LEFTWHITECORNERBRACKET = "LEFTWHITECORNERBRACKET";
const RIGHTWHITECORNERBRACKET = "RIGHTWHITECORNERBRACKET";
const FULLWIDTHLESSTHAN = "FULLWIDTHLESSTHAN";
const FULLWIDTHGREATERTHAN = "FULLWIDTHGREATERTHAN";
const AMPERSAND = "AMPERSAND";
const APOSTROPHE = "APOSTROPHE";
const ASTERISK = "ASTERISK";
const AT = "AT";
const BACKSLASH = "BACKSLASH";
const BACKTICK = "BACKTICK";
const CARET = "CARET";
const COLON = "COLON";
const COMMA = "COMMA";
const DOLLAR = "DOLLAR";
const DOT = "DOT";
const EQUALS = "EQUALS";
const EXCLAMATION = "EXCLAMATION";
const HYPHEN = "HYPHEN";
const PERCENT = "PERCENT";
const PIPE = "PIPE";
const PLUS = "PLUS";
const POUND = "POUND";
const QUERY = "QUERY";
const QUOTE = "QUOTE";
const FULLWIDTHMIDDLEDOT = "FULLWIDTHMIDDLEDOT";
const SEMI = "SEMI";
const SLASH = "SLASH";
const TILDE = "TILDE";
const UNDERSCORE = "UNDERSCORE";
const EMOJI$1 = "EMOJI";
const SYM = "SYM";
var tk = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WORD,
  UWORD,
  ASCIINUMERICAL,
  ALPHANUMERICAL,
  LOCALHOST,
  TLD,
  UTLD,
  SCHEME,
  SLASH_SCHEME,
  NUM,
  WS,
  NL,
  OPENBRACE,
  CLOSEBRACE,
  OPENBRACKET,
  CLOSEBRACKET,
  OPENPAREN,
  CLOSEPAREN,
  OPENANGLEBRACKET,
  CLOSEANGLEBRACKET,
  FULLWIDTHLEFTPAREN,
  FULLWIDTHRIGHTPAREN,
  LEFTCORNERBRACKET,
  RIGHTCORNERBRACKET,
  LEFTWHITECORNERBRACKET,
  RIGHTWHITECORNERBRACKET,
  FULLWIDTHLESSTHAN,
  FULLWIDTHGREATERTHAN,
  AMPERSAND,
  APOSTROPHE,
  ASTERISK,
  AT,
  BACKSLASH,
  BACKTICK,
  CARET,
  COLON,
  COMMA,
  DOLLAR,
  DOT,
  EQUALS,
  EXCLAMATION,
  HYPHEN,
  PERCENT,
  PIPE,
  PLUS,
  POUND,
  QUERY,
  QUOTE,
  FULLWIDTHMIDDLEDOT,
  SEMI,
  SLASH,
  TILDE,
  UNDERSCORE,
  EMOJI: EMOJI$1,
  SYM
});
const ASCII_LETTER = /[a-z]/;
const LETTER = /\p{L}/u;
const EMOJI = /\p{Emoji}/u;
const DIGIT = /\d/;
const SPACE = /\s/;
const CR = "\r";
const LF = "\n";
const EMOJI_VARIATION = "";
const EMOJI_JOINER = "";
const OBJECT_REPLACEMENT = "";
let tlds = null, utlds = null;
function init$2(customSchemes = []) {
  const groups = {};
  State.groups = groups;
  const Start = new State();
  if (tlds == null) {
    tlds = decodeTlds(encodedTlds);
  }
  if (utlds == null) {
    utlds = decodeTlds(encodedUtlds);
  }
  tt(Start, "'", APOSTROPHE);
  tt(Start, "{", OPENBRACE);
  tt(Start, "}", CLOSEBRACE);
  tt(Start, "[", OPENBRACKET);
  tt(Start, "]", CLOSEBRACKET);
  tt(Start, "(", OPENPAREN);
  tt(Start, ")", CLOSEPAREN);
  tt(Start, "<", OPENANGLEBRACKET);
  tt(Start, ">", CLOSEANGLEBRACKET);
  tt(Start, "", FULLWIDTHLEFTPAREN);
  tt(Start, "", FULLWIDTHRIGHTPAREN);
  tt(Start, "", LEFTCORNERBRACKET);
  tt(Start, "", RIGHTCORNERBRACKET);
  tt(Start, "", LEFTWHITECORNERBRACKET);
  tt(Start, "", RIGHTWHITECORNERBRACKET);
  tt(Start, "", FULLWIDTHLESSTHAN);
  tt(Start, "", FULLWIDTHGREATERTHAN);
  tt(Start, "&", AMPERSAND);
  tt(Start, "*", ASTERISK);
  tt(Start, "@", AT);
  tt(Start, "`", BACKTICK);
  tt(Start, "^", CARET);
  tt(Start, ":", COLON);
  tt(Start, ",", COMMA);
  tt(Start, "$", DOLLAR);
  tt(Start, ".", DOT);
  tt(Start, "=", EQUALS);
  tt(Start, "!", EXCLAMATION);
  tt(Start, "-", HYPHEN);
  tt(Start, "%", PERCENT);
  tt(Start, "|", PIPE);
  tt(Start, "+", PLUS);
  tt(Start, "#", POUND);
  tt(Start, "?", QUERY);
  tt(Start, '"', QUOTE);
  tt(Start, "/", SLASH);
  tt(Start, ";", SEMI);
  tt(Start, "~", TILDE);
  tt(Start, "_", UNDERSCORE);
  tt(Start, "\\", BACKSLASH);
  tt(Start, "", FULLWIDTHMIDDLEDOT);
  const Num = tr(Start, DIGIT, NUM, {
    [numeric]: true
  });
  tr(Num, DIGIT, Num);
  const Asciinumeric = tr(Num, ASCII_LETTER, ASCIINUMERICAL, {
    [asciinumeric]: true
  });
  const Alphanumeric = tr(Num, LETTER, ALPHANUMERICAL, {
    [alphanumeric]: true
  });
  const Word = tr(Start, ASCII_LETTER, WORD, {
    [ascii]: true
  });
  tr(Word, DIGIT, Asciinumeric);
  tr(Word, ASCII_LETTER, Word);
  tr(Asciinumeric, DIGIT, Asciinumeric);
  tr(Asciinumeric, ASCII_LETTER, Asciinumeric);
  const UWord = tr(Start, LETTER, UWORD, {
    [alpha]: true
  });
  tr(UWord, ASCII_LETTER);
  tr(UWord, DIGIT, Alphanumeric);
  tr(UWord, LETTER, UWord);
  tr(Alphanumeric, DIGIT, Alphanumeric);
  tr(Alphanumeric, ASCII_LETTER);
  tr(Alphanumeric, LETTER, Alphanumeric);
  const Nl2 = tt(Start, LF, NL, {
    [whitespace]: true
  });
  const Cr = tt(Start, CR, WS, {
    [whitespace]: true
  });
  const Ws = tr(Start, SPACE, WS, {
    [whitespace]: true
  });
  tt(Start, OBJECT_REPLACEMENT, Ws);
  tt(Cr, LF, Nl2);
  tt(Cr, OBJECT_REPLACEMENT, Ws);
  tr(Cr, SPACE, Ws);
  tt(Ws, CR);
  tt(Ws, LF);
  tr(Ws, SPACE, Ws);
  tt(Ws, OBJECT_REPLACEMENT, Ws);
  const Emoji = tr(Start, EMOJI, EMOJI$1, {
    [emoji]: true
  });
  tt(Emoji, "#");
  tr(Emoji, EMOJI, Emoji);
  tt(Emoji, EMOJI_VARIATION, Emoji);
  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);
  tt(EmojiJoiner, "#");
  tr(EmojiJoiner, EMOJI, Emoji);
  const wordjr = [[ASCII_LETTER, Word], [DIGIT, Asciinumeric]];
  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord], [DIGIT, Alphanumeric]];
  for (let i = 0; i < tlds.length; i++) {
    fastts(Start, tlds[i], TLD, WORD, wordjr);
  }
  for (let i = 0; i < utlds.length; i++) {
    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);
  }
  addToGroups(TLD, {
    tld: true,
    ascii: true
  }, groups);
  addToGroups(UTLD, {
    utld: true,
    alpha: true
  }, groups);
  fastts(Start, "file", SCHEME, WORD, wordjr);
  fastts(Start, "mailto", SCHEME, WORD, wordjr);
  fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
  addToGroups(SCHEME, {
    scheme: true,
    ascii: true
  }, groups);
  addToGroups(SLASH_SCHEME, {
    slashscheme: true,
    ascii: true
  }, groups);
  customSchemes = customSchemes.sort((a2, b) => a2[0] > b[0] ? 1 : -1);
  for (let i = 0; i < customSchemes.length; i++) {
    const sch = customSchemes[i][0];
    const optionalSlashSlash = customSchemes[i][1];
    const flags = optionalSlashSlash ? {
      [scheme]: true
    } : {
      [slashscheme]: true
    };
    if (sch.indexOf("-") >= 0) {
      flags[domain] = true;
    } else if (!ASCII_LETTER.test(sch)) {
      flags[numeric] = true;
    } else if (DIGIT.test(sch)) {
      flags[asciinumeric] = true;
    } else {
      flags[ascii] = true;
    }
    ts(Start, sch, sch, flags);
  }
  ts(Start, "localhost", LOCALHOST, {
    ascii: true
  });
  Start.jd = new State(SYM);
  return {
    start: Start,
    tokens: assign({
      groups
    }, tk)
  };
}
function run$1(start2, str) {
  const iterable = stringToArray(str.replace(/[A-Z]/g, (c2) => c2.toLowerCase()));
  const charCount = iterable.length;
  const tokens = [];
  let cursor = 0;
  let charCursor = 0;
  while (charCursor < charCount) {
    let state = start2;
    let nextState = null;
    let tokenLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    let charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor += iterable[charCursor].length;
      charCursor++;
    }
    cursor -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;
    tokens.push({
      t: latestAccepting.t,
      // token type/name
      v: str.slice(cursor - tokenLength, cursor),
      // string value
      s: cursor - tokenLength,
      // start index
      e: cursor
      // end index (excluding)
    });
  }
  return tokens;
}
function stringToArray(str) {
  const result = [];
  const len = str.length;
  let index2 = 0;
  while (index2 < len) {
    let first2 = str.charCodeAt(index2);
    let second;
    let char = first2 < 55296 || first2 > 56319 || index2 + 1 === len || (second = str.charCodeAt(index2 + 1)) < 56320 || second > 57343 ? str[index2] : str.slice(index2, index2 + 2);
    result.push(char);
    index2 += char.length;
  }
  return result;
}
function fastts(state, input, t2, defaultt, jr) {
  let next;
  const len = input.length;
  for (let i = 0; i < len - 1; i++) {
    const char = input[i];
    if (state.j[char]) {
      next = state.j[char];
    } else {
      next = new State(defaultt);
      next.jr = jr.slice();
      state.j[char] = next;
    }
    state = next;
  }
  next = new State(t2);
  next.jr = jr.slice();
  state.j[input[len - 1]] = next;
  return next;
}
function decodeTlds(encoded) {
  const words2 = [];
  const stack = [];
  let i = 0;
  let digits = "0123456789";
  while (i < encoded.length) {
    let popDigitCount = 0;
    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {
      popDigitCount++;
    }
    if (popDigitCount > 0) {
      words2.push(stack.join(""));
      for (let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {
        stack.pop();
      }
      i += popDigitCount;
    } else {
      stack.push(encoded[i]);
      i++;
    }
  }
  return words2;
}
const defaults = {
  defaultProtocol: "http",
  events: null,
  format: noop,
  formatHref: noop,
  nl2br: false,
  tagName: "a",
  target: null,
  rel: null,
  validate: true,
  truncate: Infinity,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Options(opts, defaultRender = null) {
  let o2 = assign({}, defaults);
  if (opts) {
    o2 = assign(o2, opts instanceof Options ? opts.o : opts);
  }
  const ignoredTags = o2.ignoreTags;
  const uppercaseIgnoredTags = [];
  for (let i = 0; i < ignoredTags.length; i++) {
    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());
  }
  this.o = o2;
  if (defaultRender) {
    this.defaultRender = defaultRender;
  }
  this.ignoreTags = uppercaseIgnoredTags;
}
Options.prototype = {
  o: defaults,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(ir) {
    return ir;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(token) {
    return this.get("validate", token.toString(), token);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(key, operator, token) {
    const isCallable = operator != null;
    let option = this.o[key];
    if (!option) {
      return option;
    }
    if (typeof option === "object") {
      option = token.t in option ? option[token.t] : defaults[key];
      if (typeof option === "function" && isCallable) {
        option = option(operator, token);
      }
    } else if (typeof option === "function" && isCallable) {
      option = option(operator, token.t, token);
    }
    return option;
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(key, operator, token) {
    let obj = this.o[key];
    if (typeof obj === "function" && operator != null) {
      obj = obj(operator, token.t, token);
    }
    return obj;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(token) {
    const ir = token.render(this);
    const renderFn = this.get("render", null, token) || this.defaultRender;
    return renderFn(ir, token.t, token);
  }
};
function noop(val) {
  return val;
}
function MultiToken(value, tokens) {
  this.t = "token";
  this.v = value;
  this.tk = tokens;
}
MultiToken.prototype = {
  isLink: false,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(scheme2) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(options) {
    const val = this.toString();
    const truncate = options.get("truncate", val, this);
    const formatted = options.get("format", val, this);
    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "" : formatted;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(options) {
    return options.get("formatHref", this.toHref(options.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(protocol = defaults.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(protocol),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(options) {
    return {
      type: this.t,
      value: this.toFormattedString(options),
      isLink: this.isLink,
      href: this.toFormattedHref(options),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(options) {
    return options.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(options) {
    const token = this;
    const href = this.toHref(options.get("defaultProtocol"));
    const formattedHref = options.get("formatHref", href, this);
    const tagName = options.get("tagName", href, token);
    const content = this.toFormattedString(options);
    const attributes = {};
    const className = options.get("className", href, token);
    const target = options.get("target", href, token);
    const rel = options.get("rel", href, token);
    const attrs2 = options.getObj("attributes", href, token);
    const eventListeners2 = options.getObj("events", href, token);
    attributes.href = formattedHref;
    if (className) {
      attributes.class = className;
    }
    if (target) {
      attributes.target = target;
    }
    if (rel) {
      attributes.rel = rel;
    }
    if (attrs2) {
      assign(attributes, attrs2);
    }
    return {
      tagName,
      attributes,
      content,
      eventListeners: eventListeners2
    };
  }
};
function createTokenClass(type, props) {
  class Token extends MultiToken {
    constructor(value, tokens) {
      super(value, tokens);
      this.t = type;
    }
  }
  for (const p2 in props) {
    Token.prototype[p2] = props[p2];
  }
  Token.t = type;
  return Token;
}
const Email = createTokenClass("email", {
  isLink: true,
  toHref() {
    return "mailto:" + this.toString();
  }
});
const Text = createTokenClass("text");
const Nl = createTokenClass("nl");
const Url = createTokenClass("url", {
  isLink: true,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(scheme2 = defaults.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${scheme2}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const tokens = this.tk;
    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
  }
});
const makeState = (arg) => new State(arg);
function init$1({
  groups
}) {
  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);
  const qsNonAccepting = [COLON, COMMA, DOT, EXCLAMATION, PERCENT, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];
  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];
  const Start = makeState();
  const Localpart = tt(Start, TILDE);
  ta(Localpart, localpartAccepting, Localpart);
  ta(Localpart, groups.domain, Localpart);
  const Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
  ta(Start, groups.domain, Domain);
  ta(Start, groups.scheme, Scheme);
  ta(Start, groups.slashscheme, SlashScheme);
  ta(Domain, localpartAccepting, Localpart);
  ta(Domain, groups.domain, Domain);
  const LocalpartAt = tt(Domain, AT);
  tt(Localpart, AT, LocalpartAt);
  tt(Scheme, AT, LocalpartAt);
  tt(SlashScheme, AT, LocalpartAt);
  const LocalpartDot = tt(Localpart, DOT);
  ta(LocalpartDot, localpartAccepting, Localpart);
  ta(LocalpartDot, groups.domain, Localpart);
  const EmailDomain = makeState();
  ta(LocalpartAt, groups.domain, EmailDomain);
  ta(EmailDomain, groups.domain, EmailDomain);
  const EmailDomainDot = tt(EmailDomain, DOT);
  ta(EmailDomainDot, groups.domain, EmailDomain);
  const Email$1 = makeState(Email);
  ta(EmailDomainDot, groups.tld, Email$1);
  ta(EmailDomainDot, groups.utld, Email$1);
  tt(LocalpartAt, LOCALHOST, Email$1);
  const EmailDomainHyphen = tt(EmailDomain, HYPHEN);
  tt(EmailDomainHyphen, HYPHEN, EmailDomainHyphen);
  ta(EmailDomainHyphen, groups.domain, EmailDomain);
  ta(Email$1, groups.domain, EmailDomain);
  tt(Email$1, DOT, EmailDomainDot);
  tt(Email$1, HYPHEN, EmailDomainHyphen);
  const EmailColon = tt(Email$1, COLON);
  ta(EmailColon, groups.numeric, Email);
  const DomainHyphen = tt(Domain, HYPHEN);
  const DomainDot = tt(Domain, DOT);
  tt(DomainHyphen, HYPHEN, DomainHyphen);
  ta(DomainHyphen, groups.domain, Domain);
  ta(DomainDot, localpartAccepting, Localpart);
  ta(DomainDot, groups.domain, Domain);
  const DomainDotTld = makeState(Url);
  ta(DomainDot, groups.tld, DomainDotTld);
  ta(DomainDot, groups.utld, DomainDotTld);
  ta(DomainDotTld, groups.domain, Domain);
  ta(DomainDotTld, localpartAccepting, Localpart);
  tt(DomainDotTld, DOT, DomainDot);
  tt(DomainDotTld, HYPHEN, DomainHyphen);
  tt(DomainDotTld, AT, LocalpartAt);
  const DomainDotTldColon = tt(DomainDotTld, COLON);
  const DomainDotTldColonPort = makeState(Url);
  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
  const Url$1 = makeState(Url);
  const UrlNonaccept = makeState();
  ta(Url$1, qsAccepting, Url$1);
  ta(Url$1, qsNonAccepting, UrlNonaccept);
  ta(UrlNonaccept, qsAccepting, Url$1);
  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);
  tt(DomainDotTld, SLASH, Url$1);
  tt(DomainDotTldColonPort, SLASH, Url$1);
  const SchemeColon = tt(Scheme, COLON);
  const SlashSchemeColon = tt(SlashScheme, COLON);
  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH);
  const UriPrefix = tt(SlashSchemeColonSlash, SLASH);
  ta(Scheme, groups.domain, Domain);
  tt(Scheme, DOT, DomainDot);
  tt(Scheme, HYPHEN, DomainHyphen);
  ta(SlashScheme, groups.domain, Domain);
  tt(SlashScheme, DOT, DomainDot);
  tt(SlashScheme, HYPHEN, DomainHyphen);
  ta(SchemeColon, groups.domain, Url$1);
  tt(SchemeColon, SLASH, Url$1);
  tt(SchemeColon, QUERY, Url$1);
  ta(UriPrefix, groups.domain, Url$1);
  ta(UriPrefix, qsAccepting, Url$1);
  tt(UriPrefix, SLASH, Url$1);
  const bracketPairs = [
    [OPENBRACE, CLOSEBRACE],
    // {}
    [OPENBRACKET, CLOSEBRACKET],
    // []
    [OPENPAREN, CLOSEPAREN],
    // ()
    [OPENANGLEBRACKET, CLOSEANGLEBRACKET],
    // <>
    [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],
    // 
    [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],
    // 
    [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],
    // 
    [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN]
    // 
  ];
  for (let i = 0; i < bracketPairs.length; i++) {
    const [OPEN, CLOSE] = bracketPairs[i];
    const UrlOpen = tt(Url$1, OPEN);
    tt(UrlNonaccept, OPEN, UrlOpen);
    tt(UrlOpen, CLOSE, Url$1);
    const UrlOpenQ = makeState(Url);
    ta(UrlOpen, qsAccepting, UrlOpenQ);
    const UrlOpenSyms = makeState();
    ta(UrlOpen, qsNonAccepting);
    ta(UrlOpenQ, qsAccepting, UrlOpenQ);
    ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);
    ta(UrlOpenSyms, qsAccepting, UrlOpenQ);
    ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);
    tt(UrlOpenQ, CLOSE, Url$1);
    tt(UrlOpenSyms, CLOSE, Url$1);
  }
  tt(Start, LOCALHOST, DomainDotTld);
  tt(Start, NL, Nl);
  return {
    start: Start,
    tokens: tk
  };
}
function run(start2, input, tokens) {
  let len = tokens.length;
  let cursor = 0;
  let multis = [];
  let textTokens = [];
  while (cursor < len) {
    let state = start2;
    let secondState = null;
    let nextState = null;
    let multiLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
      textTokens.push(tokens[cursor++]);
    }
    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
      secondState = null;
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      cursor -= multiLength;
      if (cursor < len) {
        textTokens.push(tokens[cursor]);
        cursor++;
      }
    } else {
      if (textTokens.length > 0) {
        multis.push(initMultiToken(Text, input, textTokens));
        textTokens = [];
      }
      cursor -= sinceAccepts;
      multiLength -= sinceAccepts;
      const Multi = latestAccepting.t;
      const subtokens = tokens.slice(cursor - multiLength, cursor);
      multis.push(initMultiToken(Multi, input, subtokens));
    }
  }
  if (textTokens.length > 0) {
    multis.push(initMultiToken(Text, input, textTokens));
  }
  return multis;
}
function initMultiToken(Multi, input, tokens) {
  const startIdx = tokens[0].s;
  const endIdx = tokens[tokens.length - 1].e;
  const value = input.slice(startIdx, endIdx);
  return new Multi(value, tokens);
}
const warn = typeof console !== "undefined" && console && console.warn || (() => {
});
const warnAdvice = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.";
const INIT = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: false
};
function reset() {
  State.groups = {};
  INIT.scanner = null;
  INIT.parser = null;
  INIT.tokenQueue = [];
  INIT.pluginQueue = [];
  INIT.customSchemes = [];
  INIT.initialized = false;
  return INIT;
}
function registerCustomProtocol(scheme2, optionalSlashSlash = false) {
  if (INIT.initialized) {
    warn(`linkifyjs: already initialized - will not register custom scheme "${scheme2}" ${warnAdvice}`);
  }
  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme2)) {
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  }
  INIT.customSchemes.push([scheme2, optionalSlashSlash]);
}
function init() {
  INIT.scanner = init$2(INIT.customSchemes);
  for (let i = 0; i < INIT.tokenQueue.length; i++) {
    INIT.tokenQueue[i][1]({
      scanner: INIT.scanner
    });
  }
  INIT.parser = init$1(INIT.scanner.tokens);
  for (let i = 0; i < INIT.pluginQueue.length; i++) {
    INIT.pluginQueue[i][1]({
      scanner: INIT.scanner,
      parser: INIT.parser
    });
  }
  INIT.initialized = true;
  return INIT;
}
function tokenize(str) {
  if (!INIT.initialized) {
    init();
  }
  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));
}
tokenize.scan = run$1;
function find(str, type = null, opts = null) {
  if (type && typeof type === "object") {
    if (opts) {
      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);
    }
    opts = type;
    type = null;
  }
  const options = new Options(opts);
  const tokens = tokenize(str);
  const filtered = [];
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (token.isLink && (!type || token.t === type) && options.check(token)) {
      filtered.push(token.toFormattedObject(options));
    }
  }
  return filtered;
}
function isValidLinkStructure(tokens) {
  if (tokens.length === 1) {
    return tokens[0].isLink;
  }
  if (tokens.length === 3 && tokens[1].isLink) {
    return ["()", "[]"].includes(tokens[0].value + tokens[2].value);
  }
  return false;
}
function autolink(options) {
  return new Plugin({
    key: new PluginKey("autolink"),
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
      const preventAutolink = transactions.some((transaction) => transaction.getMeta("preventAutolink"));
      if (!docChanges || preventAutolink) {
        return;
      }
      const { tr: tr2 } = newState;
      const transform = combineTransactionSteps(oldState.doc, [...transactions]);
      const changes = getChangedRanges(transform);
      changes.forEach(({ newRange }) => {
        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, (node) => node.isTextblock);
        let textBlock;
        let textBeforeWhitespace;
        if (nodesInChangedRanges.length > 1) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, void 0, " ");
        } else if (nodesInChangedRanges.length && newState.doc.textBetween(newRange.from, newRange.to, " ", " ").endsWith(" ")) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, " ");
        }
        if (textBlock && textBeforeWhitespace) {
          const wordsBeforeWhitespace = textBeforeWhitespace.split(" ").filter((s2) => s2 !== "");
          if (wordsBeforeWhitespace.length <= 0) {
            return false;
          }
          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];
          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);
          if (!lastWordBeforeSpace) {
            return false;
          }
          const linksBeforeSpace = tokenize(lastWordBeforeSpace).map((t2) => t2.toObject(options.defaultProtocol));
          if (!isValidLinkStructure(linksBeforeSpace)) {
            return false;
          }
          linksBeforeSpace.filter((link) => link.isLink).map((link) => ({
            ...link,
            from: lastWordAndBlockOffset + link.start + 1,
            to: lastWordAndBlockOffset + link.end + 1
          })).filter((link) => {
            if (!newState.schema.marks.code) {
              return true;
            }
            return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);
          }).filter((link) => options.validate(link.value)).filter((link) => options.shouldAutoLink(link.value)).forEach((link) => {
            if (getMarksBetween$1(link.from, link.to, newState.doc).some((item) => item.mark.type === options.type)) {
              return;
            }
            tr2.addMark(link.from, link.to, options.type.create({
              href: link.href
            }));
          });
        }
      });
      if (!tr2.steps.length) {
        return;
      }
      return tr2;
    }
  });
}
function clickHandler(options) {
  return new Plugin({
    key: new PluginKey("handleClickLink"),
    props: {
      handleClick: (view, pos, event) => {
        var _a, _b;
        if (event.button !== 0) {
          return false;
        }
        if (!view.editable) {
          return false;
        }
        let a2 = event.target;
        const els = [];
        while (a2.nodeName !== "DIV") {
          els.push(a2);
          a2 = a2.parentNode;
        }
        if (!els.find((value) => value.nodeName === "A")) {
          return false;
        }
        const attrs2 = getAttributes(view.state, options.type.name);
        const link = event.target;
        const href = (_a = link === null || link === void 0 ? void 0 : link.href) !== null && _a !== void 0 ? _a : attrs2.href;
        const target = (_b = link === null || link === void 0 ? void 0 : link.target) !== null && _b !== void 0 ? _b : attrs2.target;
        if (link && href) {
          window.open(href, target);
          return true;
        }
        return false;
      }
    }
  });
}
function pasteHandler(options) {
  return new Plugin({
    key: new PluginKey("handlePasteLink"),
    props: {
      handlePaste: (view, event, slice2) => {
        const { state } = view;
        const { selection } = state;
        const { empty: empty2 } = selection;
        if (empty2) {
          return false;
        }
        let textContent = "";
        slice2.content.forEach((node) => {
          textContent += node.textContent;
        });
        const link = find(textContent, { defaultProtocol: options.defaultProtocol }).find((item) => item.isLink && item.value === textContent);
        if (!textContent || !link) {
          return false;
        }
        options.editor.commands.setMark(options.type, {
          href: link.href
        });
        return true;
      }
    }
  });
}
const ATTR_WHITESPACE = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function isAllowedUri(uri, protocols) {
  const allowedProtocols = [
    "http",
    "https",
    "ftp",
    "ftps",
    "mailto",
    "tel",
    "callto",
    "sms",
    "cid",
    "xmpp"
  ];
  if (protocols) {
    protocols.forEach((protocol) => {
      const nextProtocol = typeof protocol === "string" ? protocol : protocol.scheme;
      if (nextProtocol) {
        allowedProtocols.push(nextProtocol);
      }
    });
  }
  return !uri || uri.replace(ATTR_WHITESPACE, "").match(new RegExp(
    // eslint-disable-next-line no-useless-escape
    `^(?:(?:${allowedProtocols.join("|")}):|[^a-z]|[a-z+.-]+(?:[^a-z+.-:]|$))`,
    "i"
  ));
}
const Link = Mark$1.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: false,
  exitable: true,
  onCreate() {
    if (this.options.validate && !this.options.shouldAutoLink) {
      this.options.shouldAutoLink = this.options.validate;
      console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.");
    }
    this.options.protocols.forEach((protocol) => {
      if (typeof protocol === "string") {
        registerCustomProtocol(protocol);
        return;
      }
      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);
    });
  },
  onDestroy() {
    reset();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: true,
      linkOnPaste: true,
      autolink: true,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),
      validate: (url) => !!url,
      shouldAutoLink: (url) => !!url
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(element) {
          return element.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (dom) => {
          const href = dom.getAttribute("href");
          if (!href || !this.options.isAllowedUri(href, {
            defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          })) {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    if (!this.options.isAllowedUri(HTMLAttributes.href, {
      defaultValidate: (href) => !!isAllowedUri(href, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    })) {
      return [
        "a",
        mergeAttributes$1(this.options.HTMLAttributes, { ...HTMLAttributes, href: "" }),
        0
      ];
    }
    return ["a", mergeAttributes$1(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setLink: (attributes) => ({ chain }) => {
        return chain().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
      },
      toggleLink: (attributes) => ({ chain }) => {
        return chain().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      },
      unsetLink: () => ({ chain }) => {
        return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      }
    };
  },
  addPasteRules() {
    return [
      markPasteRule$1({
        find: (text) => {
          const foundLinks = [];
          if (text) {
            const { protocols, defaultProtocol } = this.options;
            const links = find(text).filter((item) => item.isLink && this.options.isAllowedUri(item.value, {
              defaultValidate: (href) => !!isAllowedUri(href, protocols),
              protocols,
              defaultProtocol
            }));
            if (links.length) {
              links.forEach((link) => foundLinks.push({
                text: link.value,
                data: {
                  href: link.href
                },
                index: link.start
              }));
            }
          }
          return foundLinks;
        },
        type: this.type,
        getAttributes: (match2) => {
          var _a;
          return {
            href: (_a = match2.data) === null || _a === void 0 ? void 0 : _a.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const plugins = [];
    const { protocols, defaultProtocol } = this.options;
    if (this.options.autolink) {
      plugins.push(autolink({
        type: this.type,
        defaultProtocol: this.options.defaultProtocol,
        validate: (url) => this.options.isAllowedUri(url, {
          defaultValidate: (href) => !!isAllowedUri(href, protocols),
          protocols,
          defaultProtocol
        }),
        shouldAutoLink: this.options.shouldAutoLink
      }));
    }
    if (this.options.openOnClick === true) {
      plugins.push(clickHandler({
        type: this.type
      }));
    }
    if (this.options.linkOnPaste) {
      plugins.push(pasteHandler({
        editor: this.editor,
        defaultProtocol: this.options.defaultProtocol,
        type: this.type
      }));
    }
    return plugins;
  }
});
const inputRegex$5 = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/;
const Image$1 = Node$2.create({
  name: "image",
  addOptions() {
    return {
      inline: false,
      allowBase64: false,
      HTMLAttributes: {}
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: true,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["img", mergeAttributes$1(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setImage: (options) => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: options
        });
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule$1({
        find: inputRegex$5,
        type: this.type,
        getAttributes: (match2) => {
          const [, , alt, src, title] = match2;
          return { src, alt, title };
        }
      })
    ];
  }
});
const Placeholder = Extension$1.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something ",
      showOnlyWhenEditable: true,
      showOnlyCurrent: true,
      includeChildren: false
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("placeholder"),
        props: {
          decorations: ({ doc: doc2, selection }) => {
            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;
            const { anchor } = selection;
            const decorations = [];
            if (!active) {
              return null;
            }
            const isEmptyDoc = this.editor.isEmpty;
            doc2.descendants((node, pos) => {
              const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;
              const isEmpty = !node.isLeaf && isNodeEmpty$1(node);
              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {
                const classes2 = [this.options.emptyNodeClass];
                if (isEmptyDoc) {
                  classes2.push(this.options.emptyEditorClass);
                }
                const decoration = Decoration.node(pos, pos + node.nodeSize, {
                  class: classes2.join(" "),
                  "data-placeholder": typeof this.options.placeholder === "function" ? this.options.placeholder({
                    editor: this.editor,
                    node,
                    pos,
                    hasAnchor
                  }) : this.options.placeholder
                });
                decorations.push(decoration);
              }
              return this.options.includeChildren;
            });
            return DecorationSet.create(doc2, decorations);
          }
        }
      })
    ];
  }
});
const inputRegex$4 = /^\s*(\[([( |x])?\])\s$/;
const TaskItem = Node$2.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: false,
      HTMLAttributes: {},
      taskListTypeName: "taskList"
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: true,
  addAttributes() {
    return {
      checked: {
        default: false,
        keepOnSplit: false,
        parseHTML: (element) => {
          const dataChecked = element.getAttribute("data-checked");
          return dataChecked === "" || dataChecked === "true";
        },
        renderHTML: (attributes) => ({
          "data-checked": attributes.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "li",
      mergeAttributes$1(this.options.HTMLAttributes, HTMLAttributes, {
        "data-type": this.name
      }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: node.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      ["div", 0]
    ];
  },
  addKeyboardShortcuts() {
    const shortcuts = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    if (!this.options.nested) {
      return shortcuts;
    }
    return {
      ...shortcuts,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    };
  },
  addNodeView() {
    return ({ node, HTMLAttributes, getPos, editor }) => {
      const listItem2 = document.createElement("li");
      const checkboxWrapper = document.createElement("label");
      const checkboxStyler = document.createElement("span");
      const checkbox = document.createElement("input");
      const content = document.createElement("div");
      checkboxWrapper.contentEditable = "false";
      checkbox.type = "checkbox";
      checkbox.addEventListener("mousedown", (event) => event.preventDefault());
      checkbox.addEventListener("change", (event) => {
        if (!editor.isEditable && !this.options.onReadOnlyChecked) {
          checkbox.checked = !checkbox.checked;
          return;
        }
        const { checked } = event.target;
        if (editor.isEditable && typeof getPos === "function") {
          editor.chain().focus(void 0, { scrollIntoView: false }).command(({ tr: tr2 }) => {
            const position2 = getPos();
            if (typeof position2 !== "number") {
              return false;
            }
            const currentNode = tr2.doc.nodeAt(position2);
            tr2.setNodeMarkup(position2, void 0, {
              ...currentNode === null || currentNode === void 0 ? void 0 : currentNode.attrs,
              checked
            });
            return true;
          }).run();
        }
        if (!editor.isEditable && this.options.onReadOnlyChecked) {
          if (!this.options.onReadOnlyChecked(node, checked)) {
            checkbox.checked = !checkbox.checked;
          }
        }
      });
      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {
        listItem2.setAttribute(key, value);
      });
      listItem2.dataset.checked = node.attrs.checked;
      if (node.attrs.checked) {
        checkbox.setAttribute("checked", "checked");
      }
      checkboxWrapper.append(checkbox, checkboxStyler);
      listItem2.append(checkboxWrapper, content);
      Object.entries(HTMLAttributes).forEach(([key, value]) => {
        listItem2.setAttribute(key, value);
      });
      return {
        dom: listItem2,
        contentDOM: content,
        update: (updatedNode) => {
          if (updatedNode.type !== this.type) {
            return false;
          }
          listItem2.dataset.checked = updatedNode.attrs.checked;
          if (updatedNode.attrs.checked) {
            checkbox.setAttribute("checked", "checked");
          } else {
            checkbox.removeAttribute("checked");
          }
          return true;
        }
      };
    };
  },
  addInputRules() {
    return [
      wrappingInputRule$1({
        find: inputRegex$4,
        type: this.type,
        getAttributes: (match2) => ({
          checked: match2[match2.length - 1] === "x"
        })
      })
    ];
  }
});
const TaskList = Node$2.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes$1(this.options.HTMLAttributes, HTMLAttributes, { "data-type": this.name }), 0];
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands: commands2 }) => {
        return commands2.toggleList(this.name, this.options.itemTypeName);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
});
const ListItemName$1 = "listItem";
const TextStyleName$1 = "textStyle";
const inputRegex$3 = /^(\d+)\.\s$/;
const OrderedList = Node$2.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (element) => {
          return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
        }
      },
      type: {
        default: void 0,
        parseHTML: (element) => element.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    const { start: start2, ...attributesWithoutStart } = HTMLAttributes;
    return start2 === 1 ? ["ol", mergeAttributes$1(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes$1(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: commands2, chain }) => {
        if (this.options.keepAttributes) {
          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName$1, this.editor.getAttributes(TextStyleName$1)).run();
        }
        return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule$1({
      find: inputRegex$3,
      type: this.type,
      getAttributes: (match2) => ({ start: +match2[1] }),
      joinPredicate: (match2, node) => node.childCount + node.attrs.start === +match2[1]
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule$1({
        find: inputRegex$3,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: (match2) => ({ start: +match2[1], ...this.editor.getAttributes(TextStyleName$1) }),
        joinPredicate: (match2, node) => node.childCount + node.attrs.start === +match2[1],
        editor: this.editor
      });
    }
    return [
      inputRule
    ];
  }
});
const ListItemName = "listItem";
const TextStyleName = "textStyle";
const inputRegex$2 = /^\s*([-+*])\s$/;
const BulletList = Node$2.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes$1(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: commands2, chain }) => {
        if (this.options.keepAttributes) {
          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();
        }
        return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule$1({
      find: inputRegex$2,
      type: this.type
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule$1({
        find: inputRegex$2,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: () => {
          return this.editor.getAttributes(TextStyleName);
        },
        editor: this.editor
      });
    }
    return [
      inputRule
    ];
  }
});
const ListItem = Node$2.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes$1(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});
const backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
const tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
const CodeBlock = Node$2.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: true,
      exitOnArrowDown: true,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: true,
  defining: true,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (element) => {
          var _a;
          const { languageClassPrefix } = this.options;
          const classNames = [...((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || []];
          const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
          const language = languages[0];
          if (!language) {
            return null;
          }
          return language;
        },
        rendered: false
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "pre",
      mergeAttributes$1(this.options.HTMLAttributes, HTMLAttributes),
      [
        "code",
        {
          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (attributes) => ({ commands: commands2 }) => {
        return commands2.setNode(this.name, attributes);
      },
      toggleCodeBlock: (attributes) => ({ commands: commands2 }) => {
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: empty2, $anchor } = this.editor.state.selection;
        const isAtStart = $anchor.pos === 1;
        if (!empty2 || $anchor.parent.type.name !== this.name) {
          return false;
        }
        if (isAtStart || !$anchor.parent.textContent.length) {
          return this.editor.commands.clearNodes();
        }
        return false;
      },
      // exit node on triple enter
      Enter: ({ editor }) => {
        if (!this.options.exitOnTripleEnter) {
          return false;
        }
        const { state } = editor;
        const { selection } = state;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
        if (!isAtEnd || !endsWithDoubleNewline) {
          return false;
        }
        return editor.chain().command(({ tr: tr2 }) => {
          tr2.delete($from.pos - 2, $from.pos);
          return true;
        }).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor }) => {
        if (!this.options.exitOnArrowDown) {
          return false;
        }
        const { state } = editor;
        const { selection, doc: doc2 } = state;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        if (!isAtEnd) {
          return false;
        }
        const after = $from.after();
        if (after === void 0) {
          return false;
        }
        const nodeAfter = doc2.nodeAt(after);
        if (nodeAfter) {
          return editor.commands.command(({ tr: tr2 }) => {
            tr2.setSelection(Selection.near(doc2.resolve(after)));
            return true;
          });
        }
        return editor.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      textblockTypeInputRule$1({
        find: backtickInputRegex,
        type: this.type,
        getAttributes: (match2) => ({
          language: match2[1]
        })
      }),
      textblockTypeInputRule$1({
        find: tildeInputRegex,
        type: this.type,
        getAttributes: (match2) => ({
          language: match2[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Plugin({
        key: new PluginKey("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (view, event) => {
            if (!event.clipboardData) {
              return false;
            }
            if (this.editor.isActive(this.type.name)) {
              return false;
            }
            const text = event.clipboardData.getData("text/plain");
            const vscode = event.clipboardData.getData("vscode-editor-data");
            const vscodeData = vscode ? JSON.parse(vscode) : void 0;
            const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;
            if (!text || !language) {
              return false;
            }
            const { tr: tr2, schema: schema2 } = view.state;
            const textNode = schema2.text(text.replace(/\r\n?/g, "\n"));
            tr2.replaceSelectionWith(this.type.create({ language }, textNode));
            if (tr2.selection.$from.parent.type !== this.type) {
              tr2.setSelection(TextSelection.near(tr2.doc.resolve(Math.max(0, tr2.selection.from - 2))));
            }
            tr2.setMeta("paste", true);
            view.dispatch(tr2);
            return true;
          }
        }
      })
    ];
  }
});
const inputRegex$1 = /^\s*>\s$/;
const Blockquote = Node$2.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: true,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["blockquote", mergeAttributes$1(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: commands2 }) => {
        return commands2.wrapIn(this.name);
      },
      toggleBlockquote: () => ({ commands: commands2 }) => {
        return commands2.toggleWrap(this.name);
      },
      unsetBlockquote: () => ({ commands: commands2 }) => {
        return commands2.lift(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule$1({
        find: inputRegex$1,
        type: this.type
      })
    ];
  }
});
const inputRegex = /(?<!`)`([^`]+)`(?!`)/;
const pasteRegex = /(?<!`)`([^`]+)`(?!`)/g;
const Code = Mark$1.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: true,
  exitable: true,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["code", mergeAttributes$1(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleCode: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetCode: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      markInputRule$1({
        find: inputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule$1({
        find: pasteRegex,
        type: this.type
      })
    ];
  }
});
function findSuggestionMatch(config) {
  var _a;
  const { char, allowSpaces, allowedPrefixes, startOfLine, $position } = config;
  const escapedChar = escapeForRegEx(char);
  const suffix = new RegExp(`\\s${escapedChar}$`);
  const prefix2 = startOfLine ? "^" : "";
  const regexp = allowSpaces ? new RegExp(`${prefix2}${escapedChar}.*?(?=\\s${escapedChar}|$)`, "gm") : new RegExp(`${prefix2}(?:^)?${escapedChar}[^\\s${escapedChar}]*`, "gm");
  const text = ((_a = $position.nodeBefore) === null || _a === void 0 ? void 0 : _a.isText) && $position.nodeBefore.text;
  if (!text) {
    return null;
  }
  const textFrom = $position.pos - text.length;
  const match2 = Array.from(text.matchAll(regexp)).pop();
  if (!match2 || match2.input === void 0 || match2.index === void 0) {
    return null;
  }
  const matchPrefix = match2.input.slice(Math.max(0, match2.index - 1), match2.index);
  const matchPrefixIsAllowed = new RegExp(`^[${allowedPrefixes === null || allowedPrefixes === void 0 ? void 0 : allowedPrefixes.join("")}\0]?$`).test(matchPrefix);
  if (allowedPrefixes !== null && !matchPrefixIsAllowed) {
    return null;
  }
  const from2 = textFrom + match2.index;
  let to = from2 + match2[0].length;
  if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {
    match2[0] += " ";
    to += 1;
  }
  if (from2 < $position.pos && to >= $position.pos) {
    return {
      range: {
        from: from2,
        to
      },
      query: match2[0].slice(char.length),
      text: match2[0]
    };
  }
  return null;
}
const SuggestionPluginKey = new PluginKey("suggestion");
function Suggestion({ pluginKey = SuggestionPluginKey, editor, char = "@", allowSpaces = false, allowedPrefixes = [" "], startOfLine = false, decorationTag = "span", decorationClass = "suggestion", command: command2 = () => null, items: items2 = () => [], render: render2 = () => ({}), allow = () => true, findSuggestionMatch: findSuggestionMatch$1 = findSuggestionMatch }) {
  let props;
  const renderer = render2 === null || render2 === void 0 ? void 0 : render2();
  const plugin = new Plugin({
    key: pluginKey,
    view() {
      return {
        update: async (view, prevState) => {
          var _a, _b, _c, _d, _e, _f, _g;
          const prev = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(prevState);
          const next = (_b = this.key) === null || _b === void 0 ? void 0 : _b.getState(view.state);
          const moved = prev.active && next.active && prev.range.from !== next.range.from;
          const started = !prev.active && next.active;
          const stopped = prev.active && !next.active;
          const changed = !started && !stopped && prev.query !== next.query;
          const handleStart = started || moved && changed;
          const handleChange = changed || moved;
          const handleExit = stopped || moved && changed;
          if (!handleStart && !handleChange && !handleExit) {
            return;
          }
          const state = handleExit && !handleStart ? prev : next;
          const decorationNode = view.dom.querySelector(`[data-decoration-id="${state.decorationId}"]`);
          props = {
            editor,
            range: state.range,
            query: state.query,
            text: state.text,
            items: [],
            command: (commandProps) => {
              return command2({
                editor,
                range: state.range,
                props: commandProps
              });
            },
            decorationNode,
            // virtual node for popper.js or tippy.js
            // this can be used for building popups without a DOM node
            clientRect: decorationNode ? () => {
              var _a2;
              const { decorationId } = (_a2 = this.key) === null || _a2 === void 0 ? void 0 : _a2.getState(editor.state);
              const currentDecorationNode = view.dom.querySelector(`[data-decoration-id="${decorationId}"]`);
              return (currentDecorationNode === null || currentDecorationNode === void 0 ? void 0 : currentDecorationNode.getBoundingClientRect()) || null;
            } : null
          };
          if (handleStart) {
            (_c = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeStart) === null || _c === void 0 ? void 0 : _c.call(renderer, props);
          }
          if (handleChange) {
            (_d = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeUpdate) === null || _d === void 0 ? void 0 : _d.call(renderer, props);
          }
          if (handleChange || handleStart) {
            props.items = await items2({
              editor,
              query: state.query
            });
          }
          if (handleExit) {
            (_e = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _e === void 0 ? void 0 : _e.call(renderer, props);
          }
          if (handleChange) {
            (_f = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _f === void 0 ? void 0 : _f.call(renderer, props);
          }
          if (handleStart) {
            (_g = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _g === void 0 ? void 0 : _g.call(renderer, props);
          }
        },
        destroy: () => {
          var _a;
          if (!props) {
            return;
          }
          (_a = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _a === void 0 ? void 0 : _a.call(renderer, props);
        }
      };
    },
    state: {
      // Initialize the plugin's internal state.
      init() {
        const state = {
          active: false,
          range: {
            from: 0,
            to: 0
          },
          query: null,
          text: null,
          composing: false
        };
        return state;
      },
      // Apply changes to the plugin state from a view transaction.
      apply(transaction, prev, _oldState, state) {
        const { isEditable } = editor;
        const { composing } = editor.view;
        const { selection } = transaction;
        const { empty: empty2, from: from2 } = selection;
        const next = { ...prev };
        next.composing = composing;
        if (isEditable && (empty2 || editor.view.composing)) {
          if ((from2 < prev.range.from || from2 > prev.range.to) && !composing && !prev.composing) {
            next.active = false;
          }
          const match2 = findSuggestionMatch$1({
            char,
            allowSpaces,
            allowedPrefixes,
            startOfLine,
            $position: selection.$from
          });
          const decorationId = `id_${Math.floor(Math.random() * 4294967295)}`;
          if (match2 && allow({
            editor,
            state,
            range: match2.range,
            isActive: prev.active
          })) {
            next.active = true;
            next.decorationId = prev.decorationId ? prev.decorationId : decorationId;
            next.range = match2.range;
            next.query = match2.query;
            next.text = match2.text;
          } else {
            next.active = false;
          }
        } else {
          next.active = false;
        }
        if (!next.active) {
          next.decorationId = null;
          next.range = { from: 0, to: 0 };
          next.query = null;
          next.text = null;
        }
        return next;
      }
    },
    props: {
      // Call the keydown hook if suggestion is active.
      handleKeyDown(view, event) {
        var _a;
        const { active, range } = plugin.getState(view.state);
        if (!active) {
          return false;
        }
        return ((_a = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(renderer, { view, event, range })) || false;
      },
      // Setup decorator on the currently active suggestion.
      decorations(state) {
        const { active, range, decorationId } = plugin.getState(state);
        if (!active) {
          return null;
        }
        return DecorationSet.create(state.doc, [
          Decoration.inline(range.from, range.to, {
            nodeName: decorationTag,
            class: decorationClass,
            "data-decoration-id": decorationId
          })
        ]);
      }
    }
  });
  return plugin;
}
const React$1 = await importShared("react");
const { forwardRef: forwardRef$1, useRef: useRef$1, useEffect: useEffect$1, useState: useState$1, useImperativeHandle, useMemo: useMemo$1, useDeferredValue } = React$1;
const { CheckIcon, TextFieldsIcon, LooksOneIcon, LooksTwoIcon, Looks3Icon, CheckBoxIcon, FormatListBulletedIcon, FormatListNumberedIcon: FormatListNumberedIcon$1, FormatQuoteIcon: FormatQuoteIcon$1, CodeIcon, KeyboardArrowDownIcon: KeyboardArrowDownIcon$1, Button: Button$1, Popover: Popover$1, cls: cls$1, focusedDisabled: focusedDisabled$1, DeleteIcon: DeleteIcon$1, FormatBoldIcon, FormatItalicIcon, FormatUnderlinedIcon, FormatStrikethroughIcon, defaultBorderMixin: defaultBorderMixin$1, AutoFixHighIcon, ImageIcon, useInjectStyles, Separator } = await importShared("@firecms/ui");
const EditorBubble = forwardRef$1((t0, ref) => {
  const $ = c_1(21);
  let children;
  let rest;
  let tippyOptions;
  if ($[0] !== t0) {
    ({
      children,
      tippyOptions,
      ...rest
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = rest;
    $[3] = tippyOptions;
  } else {
    children = $[1];
    rest = $[2];
    tippyOptions = $[3];
  }
  const {
    editor
  } = useCurrentEditor();
  const instanceRef = useRef$1(null);
  let t1;
  if ($[4] !== tippyOptions) {
    t1 = () => {
      if (!instanceRef.current || !tippyOptions?.placement) {
        return;
      }
      instanceRef.current.setProps({
        placement: tippyOptions.placement
      });
      instanceRef.current.popperInstance?.update();
    };
    $[4] = tippyOptions;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  const t2 = tippyOptions?.placement;
  let t3;
  if ($[6] !== t2) {
    t3 = [t2];
    $[6] = t2;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  useEffect$1(t1, t3);
  let t4;
  const shouldShow = _temp$1$1;
  let t5;
  if ($[8] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = (val) => {
      instanceRef.current = val;
    };
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  let t6;
  if ($[9] !== tippyOptions) {
    t6 = {
      onCreate: t5,
      moveTransition: "transform 0.15s ease-out",
      ...tippyOptions
    };
    $[9] = tippyOptions;
    $[10] = t6;
  } else {
    t6 = $[10];
  }
  let t7;
  if ($[11] !== rest || $[12] !== t6) {
    t7 = {
      shouldShow,
      tippyOptions: t6,
      ...rest
    };
    $[11] = rest;
    $[12] = t6;
    $[13] = t7;
  } else {
    t7 = $[13];
  }
  t4 = t7;
  const bubbleMenuProps = t4;
  if (!editor) {
    return null;
  }
  let t8;
  if ($[14] !== bubbleMenuProps || $[15] !== children || $[16] !== editor) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(BubbleMenu, { editor, ...bubbleMenuProps, children });
    $[14] = bubbleMenuProps;
    $[15] = children;
    $[16] = editor;
    $[17] = t8;
  } else {
    t8 = $[17];
  }
  let t9;
  if ($[18] !== ref || $[19] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, children: t8 });
    $[18] = ref;
    $[19] = t8;
    $[20] = t9;
  } else {
    t9 = $[20];
  }
  return t9;
});
function _temp$1$1(t0) {
  const {
    editor: editor_0,
    state
  } = t0;
  const {
    selection
  } = state;
  const {
    empty: empty2
  } = selection;
  if (editor_0.isActive("image") || empty2 || isNodeSelection$1(selection)) {
    return false;
  }
  return true;
}
const EditorBubbleItem = forwardRef$1((t0, ref) => {
  const $ = c_1(14);
  let asChild;
  let children;
  let onSelect;
  let rest;
  if ($[0] !== t0) {
    ({
      children,
      asChild,
      onSelect,
      ...rest
    } = t0);
    $[0] = t0;
    $[1] = asChild;
    $[2] = children;
    $[3] = onSelect;
    $[4] = rest;
  } else {
    asChild = $[1];
    children = $[2];
    onSelect = $[3];
    rest = $[4];
  }
  const {
    editor
  } = useCurrentEditor();
  const Comp = asChild ? Slot : "div";
  if (!editor) {
    return null;
  }
  let t1;
  if ($[5] !== editor || $[6] !== onSelect) {
    t1 = () => onSelect?.(editor);
    $[5] = editor;
    $[6] = onSelect;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  let t2;
  if ($[8] !== Comp || $[9] !== children || $[10] !== ref || $[11] !== rest || $[12] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ref, ...rest, onClick: t1, children });
    $[8] = Comp;
    $[9] = children;
    $[10] = ref;
    $[11] = rest;
    $[12] = t1;
    $[13] = t2;
  } else {
    t2 = $[13];
  }
  return t2;
});
EditorBubbleItem.displayName = "EditorBubbleItem";
const items = [{
  name: "Text",
  icon: TextFieldsIcon,
  command: (editor) => editor?.chain().focus().toggleNode("paragraph", "paragraph").run(),
  // I feel like there has to be a more efficient way to do this  feel free to PR if you know how!
  isActive: (editor) => (editor?.isActive("paragraph") && !editor?.isActive("bulletList") && !editor?.isActive("orderedList")) ?? false
}, {
  name: "Heading 1",
  icon: LooksOneIcon,
  command: (editor) => editor?.chain().focus().toggleHeading({
    level: 1
  }).run(),
  isActive: (editor) => editor?.isActive("heading", {
    level: 1
  }) ?? false
}, {
  name: "Heading 2",
  icon: LooksTwoIcon,
  command: (editor) => editor?.chain().focus().toggleHeading({
    level: 2
  }).run(),
  isActive: (editor) => editor?.isActive("heading", {
    level: 2
  }) ?? false
}, {
  name: "Heading 3",
  icon: Looks3Icon,
  command: (editor) => editor?.chain().focus().toggleHeading({
    level: 3
  }).run(),
  isActive: (editor) => editor?.isActive("heading", {
    level: 3
  }) ?? false
}, {
  name: "To-do List",
  icon: CheckBoxIcon,
  command: (editor) => editor?.chain().focus().toggleTaskList().run(),
  isActive: (editor) => editor?.isActive("taskItem") ?? false
}, {
  name: "Bullet List",
  icon: FormatListBulletedIcon,
  command: (editor) => editor?.chain().focus().toggleBulletList().run(),
  isActive: (editor) => editor?.isActive("bulletList") ?? false
}, {
  name: "Numbered List",
  icon: FormatListNumberedIcon$1,
  command: (editor) => editor?.chain().focus().toggleOrderedList().run(),
  isActive: (editor) => editor?.isActive("orderedList") ?? false
}, {
  name: "Quote",
  icon: FormatQuoteIcon$1,
  command: (editor) => editor?.chain().focus().toggleNode("paragraph", "paragraph").toggleBlockquote().run(),
  isActive: (editor) => editor?.isActive("blockquote") ?? false
}, {
  name: "Code",
  icon: CodeIcon,
  command: (editor) => editor?.chain().focus().toggleCodeBlock().run(),
  isActive: (editor) => editor?.isActive("codeBlock") ?? false
}];
const NodeSelector = (t0) => {
  const $ = c_1(16);
  const {
    open,
    onOpenChange,
    portalContainer
  } = t0;
  const {
    editor
  } = useCurrentEditor();
  if (!editor) {
    return null;
  }
  let t1;
  if ($[0] !== editor) {
    t1 = items.filter((item) => item.isActive(editor)).pop() ?? {
      name: "Multiple"
    };
    $[0] = editor;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const activeItem = t1;
  let t2;
  if ($[2] !== activeItem.name) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "whitespace-nowrap text-sm", children: activeItem.name });
    $[2] = activeItem.name;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardArrowDownIcon$1, { size: "small" });
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== t2) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Button$1, { variant: "text", className: "gap-2 rounded-none", color: "text", children: [
      t2,
      t3
    ] });
    $[5] = t2;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  let t5;
  if ($[7] !== activeItem.name || $[8] !== onOpenChange) {
    t5 = items.map((item_0, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(EditorBubbleItem, { onSelect: (editor_0) => {
      item_0.command(editor_0);
      onOpenChange(false);
    }, className: "flex cursor-pointer items-center justify-between rounded px-2 py-1 text-sm hover:bg-blue-50 hover:dark:bg-surface-700 text-surface-900 dark:text-white", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(item_0.icon, { size: "smallest" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: item_0.name })
      ] }),
      activeItem.name === item_0.name && /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon, { size: "smallest" })
    ] }, index2));
    $[7] = activeItem.name;
    $[8] = onOpenChange;
    $[9] = t5;
  } else {
    t5 = $[9];
  }
  let t6;
  if ($[10] !== onOpenChange || $[11] !== open || $[12] !== portalContainer || $[13] !== t4 || $[14] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(Popover$1, { sideOffset: 5, align: "start", portalContainer, className: "w-48 p-1", trigger: t4, modal: true, open, onOpenChange, children: t5 });
    $[10] = onOpenChange;
    $[11] = open;
    $[12] = portalContainer;
    $[13] = t4;
    $[14] = t5;
    $[15] = t6;
  } else {
    t6 = $[15];
  }
  return t6;
};
function isValidUrl(url) {
  try {
    new URL(url);
    return true;
  } catch (e2) {
    return false;
  }
}
function getUrlFromString(str) {
  if (isValidUrl(str)) return str;
  try {
    if (str.includes(".") && !str.includes(" ")) {
      return new URL(`https://${str}`).toString();
    }
    return null;
  } catch (e2) {
    return null;
  }
}
const LinkSelector = (t0) => {
  const $ = c_1(24);
  const {
    open,
    onOpenChange
  } = t0;
  const inputRef = useRef$1(null);
  const {
    editor
  } = useCurrentEditor();
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => {
      inputRef.current && inputRef.current?.focus();
    };
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  useEffect$1(t1);
  if (!editor) {
    return null;
  }
  let t2;
  if ($[1] !== editor) {
    t2 = cls$1("underline decoration-stone-400 underline-offset-4", {
      "text-blue-500": editor.isActive("link")
    });
    $[1] = editor;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  let t3;
  if ($[3] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { variant: "text", className: "gap-2 rounded-none", color: "text", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: t2, children: "Link" }) });
    $[3] = t2;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== editor) {
    t4 = (e2) => {
      const target = e2.currentTarget;
      e2.preventDefault();
      const input = target[0];
      const url = getUrlFromString(input.value);
      url && editor.chain().focus().setLink({
        href: url
      }).run();
    };
    $[5] = editor;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  let t5;
  if ($[7] !== editor) {
    t5 = editor.getAttributes("link").href || "";
    $[7] = editor;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  let t6;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = cls$1("text-surface-900 dark:text-white flex-grow bg-transparent p-1 text-sm outline-none", focusedDisabled$1);
    $[9] = t6;
  } else {
    t6 = $[9];
  }
  let t7;
  if ($[10] !== open || $[11] !== t5) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx("input", { ref: inputRef, autoFocus: open, placeholder: "Paste a link", defaultValue: t5, className: t6 });
    $[10] = open;
    $[11] = t5;
    $[12] = t7;
  } else {
    t7 = $[12];
  }
  let t8;
  if ($[13] !== editor) {
    t8 = editor.getAttributes("link").href ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { size: "small", variant: "text", type: "button", color: "text", className: "flex items-center", onClick: () => {
      editor.chain().focus().unsetLink().run();
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteIcon$1, { size: "small" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { size: "small", variant: "text", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon, { size: "small" }) });
    $[13] = editor;
    $[14] = t8;
  } else {
    t8 = $[14];
  }
  let t9;
  if ($[15] !== t4 || $[16] !== t7 || $[17] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: t4, className: "flex p-1", children: [
      t7,
      t8
    ] });
    $[15] = t4;
    $[16] = t7;
    $[17] = t8;
    $[18] = t9;
  } else {
    t9 = $[18];
  }
  let t10;
  if ($[19] !== onOpenChange || $[20] !== open || $[21] !== t3 || $[22] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(Popover$1, { modal: true, open, onOpenChange, trigger: t3, children: t9 });
    $[19] = onOpenChange;
    $[20] = open;
    $[21] = t3;
    $[22] = t9;
    $[23] = t10;
  } else {
    t10 = $[23];
  }
  return t10;
};
const TextButtons = () => {
  const $ = c_1(2);
  const {
    editor
  } = useCurrentEditor();
  if (!editor) {
    return null;
  }
  let t0;
  if ($[0] !== editor) {
    const items2 = [{
      name: "bold",
      isActive: _temp$r,
      command: _temp2$e,
      icon: FormatBoldIcon
    }, {
      name: "italic",
      isActive: _temp3$5,
      command: _temp4$3,
      icon: FormatItalicIcon
    }, {
      name: "underline",
      isActive: _temp5$2,
      command: _temp6$2,
      icon: FormatUnderlinedIcon
    }, {
      name: "strike",
      isActive: _temp7$1,
      command: _temp8$1,
      icon: FormatStrikethroughIcon
    }, {
      name: "code",
      isActive: _temp9,
      command: _temp10,
      icon: CodeIcon
    }];
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex", children: items2.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(EditorBubbleItem, { onSelect: (editor_10) => {
      item.command(editor_10);
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { size: "small", color: "text", className: "gap-2 rounded-none h-full", variant: "text", children: /* @__PURE__ */ jsxRuntimeExports.jsx(item.icon, { className: cls$1({
      "text-inherit": !item.isActive(editor),
      "text-blue-500": item.isActive(editor)
    }) }) }) }, index2)) });
    $[0] = editor;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
};
function _temp$r(editor_0) {
  return editor_0?.isActive("bold") ?? false;
}
function _temp2$e(editor_1) {
  return editor_1?.chain().focus().toggleBold().run();
}
function _temp3$5(editor_2) {
  return editor_2?.isActive("italic") ?? false;
}
function _temp4$3(editor_3) {
  return editor_3?.chain().focus().toggleItalic().run();
}
function _temp5$2(editor_4) {
  return editor_4?.isActive("underline") ?? false;
}
function _temp6$2(editor_5) {
  return editor_5?.chain().focus().toggleUnderline().run();
}
function _temp7$1(editor_6) {
  return editor_6?.isActive("strike") ?? false;
}
function _temp8$1(editor_7) {
  return editor_7?.chain().focus().toggleStrike().run();
}
function _temp9(editor_8) {
  return editor_8?.isActive("code") ?? false;
}
function _temp10(editor_9) {
  return editor_9?.chain().focus().toggleCode().run();
}
function removeClassesFromJson(jsonObj) {
  if (Array.isArray(jsonObj)) {
    return jsonObj.map((item) => removeClassesFromJson(item));
  } else if (typeof jsonObj === "object" && jsonObj !== null) {
    if (jsonObj.attrs && typeof jsonObj.attrs === "object" && "class" in jsonObj.attrs) {
      delete jsonObj.attrs.class;
    }
    Object.keys(jsonObj).forEach((key) => {
      jsonObj[key] = removeClassesFromJson(jsonObj[key]);
    });
  }
  return jsonObj;
}
const loadingDecorationKey = new PluginKey("loadingDecoration");
const TextLoadingDecorationExtension = Extension$1.create({
  name: "loadingDecoration",
  addOptions() {
    return {
      pluginKey: loadingDecorationKey
    };
  },
  addProseMirrorPlugins() {
    const pluginKey = this.options.pluginKey;
    return [new Plugin({
      key: pluginKey,
      state: {
        init() {
          return {
            decorationSet: DecorationSet.empty,
            hasDecoration: false
          };
        },
        apply(tr2, oldState) {
          const action = tr2.getMeta(pluginKey);
          if (action?.type === "loadingDecoration") {
            const {
              pos,
              remove,
              loadingHtml
            } = action;
            if (remove) {
              return {
                decorationSet: DecorationSet.empty,
                hasDecoration: false
              };
            }
            const decoration = Decoration.widget(pos, () => {
              const container = document.createElement("span");
              container.className = "loading-decoration";
              if (loadingHtml) {
                container.innerHTML = loadingHtml;
              } else {
                const span = document.createElement("span");
                span.innerText = "loading...";
                container.appendChild(span);
              }
              return container;
            });
            return {
              decorationSet: DecorationSet.empty.add(tr2.doc, [decoration]),
              hasDecoration: true
            };
          }
          return {
            decorationSet: oldState.decorationSet.map(tr2.mapping, tr2.doc),
            hasDecoration: oldState.hasDecoration
          };
        }
      },
      props: {
        decorations(state) {
          return this.getState(state)?.decorationSet || DecorationSet.empty;
        }
      }
    })];
  },
  addCommands() {
    return {
      toggleLoadingDecoration: (loadingHtml) => ({
        state,
        dispatch
      }) => {
        const {
          selection
        } = state;
        const pos = selection.from;
        if (!dispatch) return false;
        const pluginKey = this.options.pluginKey;
        const tr2 = state.tr.setMeta(pluginKey, {
          pos,
          type: "loadingDecoration",
          remove: false,
          loadingHtml
        });
        dispatch(tr2);
        return true;
      },
      removeLoadingDecoration: () => ({
        state,
        dispatch
      }) => {
        if (!dispatch) return false;
        const pluginKey = this.options.pluginKey;
        const tr2 = state.tr.setMeta(pluginKey, {
          pos: 0,
          // We can pass any position as it will remove the entire decoration set
          type: "loadingDecoration",
          remove: true
        });
        dispatch(tr2);
        return true;
      }
    };
  }
});
const PlaceholderExtension = Placeholder.configure({
  placeholder: ({
    node,
    editor
  }) => {
    editor.state.selection;
    function hasLoadingDecoration(editor2) {
      const pluginState = loadingDecorationKey.get(editor2.state);
      return pluginState?.getState(editor2.state)?.hasDecoration ?? false;
    }
    const hasDecoration = hasLoadingDecoration(editor);
    if (hasDecoration) {
      return "";
    }
    if (node.type.name === "heading") {
      return `Heading ${node.attrs.level}`;
    }
    if (node.type.name === "paragraph") {
      return "Press '/' for commands";
    }
    return "";
  },
  includeChildren: true
});
const Horizontal = HorizontalRule.extend({
  addInputRules() {
    return [new InputRule$1({
      find: /^(?:---|-|___\s|\*\*\*\s)$/,
      handler: ({
        state,
        range
      }) => {
        const attributes = {};
        const {
          tr: tr2
        } = state;
        const start2 = range.from;
        const end2 = range.to;
        tr2.insert(start2 - 1, this.type.create(attributes)).delete(tr2.mapping.map(start2), tr2.mapping.map(end2));
      }
    })];
  }
});
const placeholder = PlaceholderExtension;
const tiptapLink = Link.configure({
  HTMLAttributes: {
    class: cls$1("text-surface-700 dark:text-surface-accent-200 underline underline-offset-[3px] hover:text-primary transition-colors cursor-pointer")
  }
});
const taskList = TaskList.configure({
  HTMLAttributes: {
    class: cls$1("not-prose")
  }
});
const taskItem = TaskItem.configure({
  HTMLAttributes: {
    class: cls$1("flex items-start my-4")
  },
  nested: true
});
const horizontalRule = Horizontal.configure({
  HTMLAttributes: {
    class: cls$1("mt-4 mb-6 border-t", defaultBorderMixin$1)
  }
});
const bulletList = BulletList.configure({
  HTMLAttributes: {
    class: cls$1("list-disc list-outside leading-3 -mt-2")
  }
});
const orderedList = OrderedList.configure({
  HTMLAttributes: {
    class: cls$1("list-decimal list-outside leading-3 -mt-2")
  }
});
const listItem = ListItem.configure({
  HTMLAttributes: {
    class: cls$1("leading-normal -mb-2")
  }
});
const blockquote = Blockquote.configure({
  HTMLAttributes: {
    class: cls$1("border-l-4 border-primary")
  }
});
const codeBlock = CodeBlock.configure({
  HTMLAttributes: {
    class: cls$1("rounded bg-blue-50 dark:bg-surface-700 border p-5 font-mono font-medium", defaultBorderMixin$1)
  }
});
const code = Code.configure({
  HTMLAttributes: {
    class: cls$1("rounded-md bg-surface-accent-50 dark:bg-surface-700 px-1.5 py-1 font-mono font-medium"),
    spellcheck: "false"
  }
});
const starterKit = StarterKit.configure({
  document: false,
  horizontalRule: false,
  dropcursor: {
    color: "#DBEAFE",
    width: 4
  },
  gapcursor: false
});
async function onFileRead(view, readerEvent, pos, upload, image) {
  const {
    schema: schema2
  } = view.state;
  const plugin = view.state.plugins.find((p2) => p2.key === ImagePluginKey.key);
  if (!plugin) {
    console.error("Image plugin not found");
    return;
  }
  let decorationSet = plugin.getState(view.state);
  const placeholder2 = document.createElement("div");
  const imageElement = document.createElement("img");
  imageElement.setAttribute("class", "opacity-40 rounded-lg border " + defaultBorderMixin$1);
  imageElement.src = readerEvent.target?.result;
  placeholder2.appendChild(imageElement);
  const deco = Decoration.widget(pos, placeholder2);
  decorationSet = decorationSet?.add(view.state.doc, [deco]);
  view.dispatch(view.state.tr.setMeta(plugin, {
    decorationSet
  }));
  const src = await upload(image);
  console.debug("Uploaded image", src);
  const imageNode = schema2.nodes.image.create({
    src
  });
  const tr2 = view.state.tr.replaceWith(pos, pos, imageNode);
  decorationSet = decorationSet?.remove([deco]);
  tr2.setMeta(plugin, {
    decorationSet
  });
  view.dispatch(tr2);
}
const ImagePluginKey = new PluginKey("imagePlugin");
const createDropImagePlugin = (upload) => {
  const plugin = new Plugin({
    key: ImagePluginKey,
    state: {
      // Initialize the plugin state with an empty DecorationSet
      init: () => DecorationSet.empty,
      // Apply transactions to update the state
      apply: (tr2, old) => {
        const meta = tr2.getMeta(plugin);
        if (meta && meta.decorationSet) {
          return meta.decorationSet;
        }
        return old.map(tr2.mapping, tr2.doc);
      }
    },
    props: {
      handleDOMEvents: {
        drop: (view, event) => {
          if (!event.dataTransfer?.files || event.dataTransfer?.files.length === 0) {
            return false;
          }
          event.preventDefault();
          const files = Array.from(event.dataTransfer.files);
          const images = files.filter((file) => /image/i.test(file.type));
          if (images.length === 0) {
            console.log("No images found in dropped files");
            return false;
          }
          images.forEach((image) => {
            const position2 = view.posAtCoords({
              left: event.clientX,
              top: event.clientY
            });
            if (!position2) return;
            const reader = new FileReader();
            reader.onload = async (readerEvent) => {
              await onFileRead(view, readerEvent, position2.pos, upload, image);
            };
            reader.readAsDataURL(image);
          });
          return true;
        }
      },
      handlePaste(view, event, slice2) {
        const items2 = Array.from(event.clipboardData?.items || []);
        const pos = view.state.selection.from;
        let anyImageFound = false;
        items2.forEach((item) => {
          const image = item.getAsFile();
          if (image) {
            anyImageFound = true;
            const reader = new FileReader();
            reader.onload = async (readerEvent) => {
              await onFileRead(view, readerEvent, pos, upload, image);
            };
            reader.readAsDataURL(image);
          }
        });
        return anyImageFound;
      },
      decorations(state) {
        return plugin.getState(state);
      }
    },
    view(editorView) {
      return {
        update(view, prevState) {
          const prevDecos = plugin.getState(prevState);
          const newDecos = plugin.getState(view.state);
          if (prevDecos !== newDecos) {
            view.updateState(view.state);
          }
        }
      };
    }
  });
  return plugin;
};
const createImageExtension = (dropImagePlugin) => {
  return Image$1.extend({
    addProseMirrorPlugins() {
      return [dropImagePlugin];
    }
  }).configure({
    allowBase64: true,
    HTMLAttributes: {
      class: cls$1("rounded-lg border", defaultBorderMixin$1)
    }
  });
};
const CustomKeymap = Extension$1.create({
  name: "CustomKeymap",
  addCommands() {
    return {
      selectTextWithinNodeBoundaries: () => ({
        editor,
        commands: commands2
      }) => {
        const {
          state
        } = editor;
        const {
          tr: tr2
        } = state;
        const startNodePos = tr2.selection.$from.start();
        const endNodePos = tr2.selection.$to.end();
        return commands2.setTextSelection({
          from: startNodePos,
          to: endNodePos
        });
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-a": ({
        editor
      }) => {
        const {
          state
        } = editor;
        const {
          tr: tr2
        } = state;
        const startSelectionPos = tr2.selection.from;
        const endSelectionPos = tr2.selection.to;
        const startNodePos = tr2.selection.$from.start();
        const endNodePos = tr2.selection.$to.end();
        const isCurrentTextSelectionNotExtendedToNodeBoundaries = startSelectionPos > startNodePos || endSelectionPos < endNodePos;
        if (isCurrentTextSelectionNotExtendedToNodeBoundaries) {
          editor.chain().selectTextWithinNodeBoundaries().run();
          return true;
        }
        return false;
      }
    };
  }
});
function absoluteRect(element) {
  const data = element.getBoundingClientRect();
  let ancestor = element.parentElement;
  while (ancestor && window.getComputedStyle(ancestor).position === "static") {
    ancestor = ancestor.parentElement;
  }
  const ancestorRect = ancestor?.getBoundingClientRect();
  return {
    top: data.top - (ancestorRect?.top ?? 0),
    left: data.left - (ancestorRect?.left ?? 0),
    width: data.width
  };
}
function nodeDOMAtCoords(coords) {
  return document.elementsFromPoint(coords.x, coords.y).find((elem) => elem.parentElement?.matches?.(".ProseMirror") || elem.matches(["li", "p:not(:first-child)", "pre", "blockquote", "h1, h2, h3, h4, h5, h6"].join(", ")));
}
function nodePosAtDOM(node, view, options) {
  const boundingRect = node.getBoundingClientRect();
  return view.posAtCoords({
    left: boundingRect.left + 50 + options.dragHandleWidth,
    top: boundingRect.top + 1
  })?.inside;
}
function DragHandle(options) {
  function handleDragStart(event, view) {
    view.focus();
    if (!event.dataTransfer) return;
    const node = nodeDOMAtCoords({
      x: event.clientX + 50 + options.dragHandleWidth,
      y: event.clientY
    });
    if (!(node instanceof Element)) return;
    const nodePos = nodePosAtDOM(node, view, options);
    if (nodePos == null || nodePos < 0) return;
    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, nodePos)));
    const slice2 = view.state.selection.content();
    const {
      dom,
      text
    } = __serializeForClipboard(view, slice2);
    event.dataTransfer.clearData();
    event.dataTransfer.setData("text/html", dom.innerHTML);
    event.dataTransfer.setData("text/plain", text);
    event.dataTransfer.effectAllowed = "copyMove";
    event.dataTransfer.setDragImage(node, 0, 0);
    view.dragging = {
      slice: slice2,
      move: event.ctrlKey
    };
  }
  function handleClick2(event, view) {
    view.focus();
    view.dom.classList.remove("dragging");
    const node = nodeDOMAtCoords({
      x: event.clientX + 50 + options.dragHandleWidth,
      y: event.clientY
    });
    if (!(node instanceof Element)) return;
    const nodePos = nodePosAtDOM(node, view, options);
    if (!nodePos) return;
    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, nodePos)));
  }
  let dragHandleElement = null;
  function hideDragHandle() {
    if (dragHandleElement) {
      dragHandleElement.classList.add("hide");
    }
  }
  function showDragHandle() {
    if (dragHandleElement) {
      dragHandleElement.classList.remove("hide");
    }
  }
  return new Plugin({
    view: (view) => {
      dragHandleElement = document.createElement("div");
      dragHandleElement.draggable = true;
      dragHandleElement.dataset.dragHandle = "";
      dragHandleElement.classList.add("drag-handle");
      dragHandleElement.addEventListener("dragstart", (e2) => {
        handleDragStart(e2, view);
      });
      dragHandleElement.addEventListener("click", (e2) => {
        handleClick2(e2, view);
      });
      hideDragHandle();
      view?.dom?.parentElement?.appendChild(dragHandleElement);
      return {
        destroy: () => {
        }
      };
    },
    props: {
      handleDOMEvents: {
        mousemove: (view, event) => {
          if (!view.editable) {
            return;
          }
          const node = nodeDOMAtCoords({
            x: event.clientX + 50 + options.dragHandleWidth,
            y: event.clientY
          });
          if (!(node instanceof Element)) {
            hideDragHandle();
            return;
          }
          const compStyle = window.getComputedStyle(node);
          const lineHeight = parseInt(compStyle.lineHeight, 10);
          const paddingTop = parseInt(compStyle.paddingTop, 10);
          const rect = absoluteRect(node);
          rect.top += (lineHeight - 24) / 2;
          rect.top += paddingTop;
          if (node.matches("ul:not([data-type=taskList]) li, ol li")) {
            rect.left -= options.dragHandleWidth;
          }
          rect.width = options.dragHandleWidth;
          if (!dragHandleElement) return;
          dragHandleElement.style.left = `${rect.left - rect.width}px`;
          dragHandleElement.style.top = `${rect.top}px`;
          showDragHandle();
        },
        keydown: () => {
          hideDragHandle();
        },
        mousewheel: () => {
          hideDragHandle();
        },
        // dragging class is used for CSS
        dragstart: (view) => {
          view.dom.classList.add("dragging");
        },
        drop: (view) => {
          view.dom.classList.remove("dragging");
        },
        dragend: (view) => {
          view.dom.classList.remove("dragging");
        }
      }
    }
  });
}
const DragAndDrop = Extension$1.create({
  name: "dragAndDrop",
  addProseMirrorPlugins() {
    return [DragHandle({
      dragHandleWidth: 24
    })];
  }
});
function buildDecorationSet(highlight, doc2) {
  const decorations = [];
  if (highlight) {
    decorations.push(Decoration.inline(highlight.from, highlight.to, {
      class: "dark:bg-surface-accent-700 bg-surface-accent-300"
    }));
  }
  const decorationSet = DecorationSet.create(doc2, decorations);
  return decorationSet;
}
const HighlightDecorationExtension = (initialHighlight) => Extension$1.create({
  name: "highlightDecoration",
  addOptions() {
    return {
      pluginKey: new PluginKey("highlightDecoration"),
      highlight: initialHighlight
    };
  },
  addProseMirrorPlugins() {
    const pluginKey = this.options.pluginKey;
    return [new Plugin({
      key: pluginKey,
      state: {
        init: (_, {
          doc: doc2
        }) => {
          const highlight = this.options.highlight;
          const decorationSet = highlight && doc2 ? buildDecorationSet(highlight, doc2) : DecorationSet.empty;
          return {
            decorationSet,
            highlight
          };
        },
        apply(transaction, oldState) {
          const action = transaction.getMeta(pluginKey);
          const highlight = action?.range;
          if (action?.type === "highlightDecoration") {
            const doc2 = transaction.doc;
            const {
              remove
            } = action;
            if (remove) {
              return {
                decorationSet: DecorationSet.empty
              };
            }
            const decorationSet = buildDecorationSet(highlight, doc2);
            return {
              decorationSet,
              highlight
            };
          } else {
            return oldState;
          }
        }
      },
      props: {
        decorations(state) {
          const autocompleteState = this.getState(state);
          if (autocompleteState?.decorationSet) {
            return autocompleteState.decorationSet;
          } else {
            return DecorationSet.empty;
          }
        }
      }
    })];
  },
  addCommands() {
    return {
      toggleAutocompleteHighlight: (range) => ({
        state,
        dispatch
      }) => {
        const {
          selection
        } = state;
        const pos = selection.from;
        if (!dispatch) return false;
        const pluginKey = this.options.pluginKey;
        const tr2 = state.tr.setMeta(pluginKey, {
          pos,
          type: "highlightDecoration",
          remove: false,
          range
        });
        dispatch(tr2);
        return true;
      },
      removeAutocompleteHighlight: () => ({
        state,
        dispatch
      }) => {
        if (!dispatch) return false;
        const pluginKey = this.options.pluginKey;
        const tr2 = state.tr.setMeta(pluginKey, {
          pos: 0,
          // We can pass any position as it will remove the entire decoration set
          type: "highlightDecoration",
          remove: true
        });
        dispatch(tr2);
        return true;
      }
    };
  }
});
const CommandPluginKey = new PluginKey("slash-command");
const SlashCommand = Node$2.create({
  name: "command",
  addOptions() {
    return {
      HTMLAttributes: {},
      renderText({
        options,
        node
      }) {
        return `${options.suggestion.char}${node.attrs.label ?? node.attrs.id}`;
      },
      deleteTriggerWithBackspace: false,
      renderHTML({
        options,
        node
      }) {
        return ["span", mergeAttributes$1(this.HTMLAttributes, options.HTMLAttributes), `${options.suggestion.char}${node.attrs.label ?? node.attrs.id}`];
      },
      suggestion: {
        char: "/",
        pluginKey: CommandPluginKey,
        command: ({
          editor,
          range,
          props
        }) => {
          const nodeAfter = editor.view.state.selection.$to.nodeAfter;
          const overrideSpace = nodeAfter?.text?.startsWith(" ");
          if (overrideSpace) {
            range.to += 1;
          }
          editor.chain().focus().insertContentAt(range, [{
            type: this.name,
            attrs: props
          }, {
            type: "text",
            text: " "
          }]).run();
          window.getSelection()?.collapseToEnd();
        },
        allow: ({
          state,
          range
        }) => {
          const $from = state.doc.resolve(range.from);
          const type = state.schema.nodes[this.name];
          const allow = !!$from.parent.type.contentMatch.matchType(type);
          return allow;
        }
      }
    };
  },
  group: "inline",
  inline: true,
  selectable: false,
  atom: true,
  addAttributes() {
    return {
      id: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-id"),
        renderHTML: (attributes) => {
          if (!attributes.id) {
            return {};
          }
          return {
            "data-id": attributes.id
          };
        }
      },
      label: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-label"),
        renderHTML: (attributes) => {
          if (!attributes.label) {
            return {};
          }
          return {
            "data-label": attributes.label
          };
        }
      }
    };
  },
  parseHTML() {
    return [{
      tag: `span[data-type="${this.name}"]`
    }];
  },
  renderHTML({
    node,
    HTMLAttributes
  }) {
    if (this.options.renderLabel !== void 0) {
      console.warn("renderLabel is deprecated use renderText and renderHTML instead");
      return ["span", mergeAttributes$1({
        "data-type": this.name
      }, this.options.HTMLAttributes, HTMLAttributes), this.options.renderLabel({
        options: this.options,
        node
      })];
    }
    const mergedOptions = {
      ...this.options
    };
    mergedOptions.HTMLAttributes = mergeAttributes$1({
      "data-type": this.name
    }, this.options.HTMLAttributes, HTMLAttributes);
    const html = this.options.renderHTML({
      options: mergedOptions,
      node
    });
    if (typeof html === "string") {
      return ["span", mergeAttributes$1({
        "data-type": this.name
      }, this.options.HTMLAttributes, HTMLAttributes), html];
    }
    return html;
  },
  renderText({
    node
  }) {
    return this.options.renderText({
      options: this.options,
      node
    });
  },
  addKeyboardShortcuts() {
    return {
      Backspace: () => this.editor.commands.command(({
        tr: tr2,
        state
      }) => {
        let isCommand = false;
        const {
          selection
        } = state;
        const {
          empty: empty2,
          anchor
        } = selection;
        if (!empty2) {
          return false;
        }
        state.doc.nodesBetween(anchor - 1, anchor, (node, pos) => {
          if (node.type.name === this.name) {
            isCommand = true;
            tr2.insertText(this.options.deleteTriggerWithBackspace ? "" : this.options.suggestion.char || "", pos, pos + node.nodeSize);
            return false;
          }
          return true;
        });
        return isCommand;
      })
    };
  },
  addProseMirrorPlugins() {
    return [Suggestion({
      editor: this.editor,
      ...this.options.suggestion
    })];
  }
});
const suggestion = (ref, {
  upload,
  onDisabledAutocompleteClick,
  aiController
}) => ({
  items: ({
    query
  }) => {
    const availableSuggestionItems = [...suggestionItems];
    if (!onDisabledAutocompleteClick && aiController) {
      availableSuggestionItems.push(autocompleteSuggestionItem);
    }
    if (onDisabledAutocompleteClick) {
      availableSuggestionItems.push({
        title: "Autocomplete",
        description: "Add text based on the context.",
        searchTerms: ["ai"],
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(AutoFixHighIcon, { size: 18 }),
        command: onDisabledAutocompleteClick
      });
    }
    return availableSuggestionItems.filter((item) => {
      const inTitle = item.title.toLowerCase().startsWith(query.toLowerCase());
      if (inTitle) return inTitle;
      const inSearchTerms = item.searchTerms?.some((term) => term.toLowerCase().startsWith(query.toLowerCase()));
      return inSearchTerms;
    });
  },
  render: () => {
    let component;
    let popup;
    return {
      onStart: (props) => {
        component = new ReactRenderer(CommandList, {
          props: {
            ...props,
            upload,
            aiController
          },
          editor: props.editor
        });
        if (!props.clientRect) {
          return;
        }
        popup = tippy("body", {
          getReferenceClientRect: props.clientRect,
          appendTo: ref?.current,
          content: component.element,
          showOnCreate: true,
          interactive: true,
          trigger: "manual",
          placement: "bottom-start"
        });
      },
      onUpdate(props) {
        component.updateProps(props);
        if (!props.clientRect) {
          return;
        }
        popup[0].setProps({
          getReferenceClientRect: props.clientRect
        });
      },
      onKeyDown(props) {
        if (props.event.key === "Escape") {
          popup[0].hide();
          props.event.preventDefault();
          return true;
        }
        return component.ref?.onKeyDown(props);
      },
      onExit() {
        if (popup && popup[0]) popup[0].destroy();
        component?.destroy();
      }
    };
  }
});
const CommandList = forwardRef$1((props, ref) => {
  const $ = c_1(33);
  const [selectedIndex, setSelectedIndex] = useState$1(0);
  const {
    editor
  } = useCurrentEditor();
  let t0;
  if ($[0] !== editor || $[1] !== props.aiController || $[2] !== props.range || $[3] !== props.upload) {
    t0 = (item) => {
      if (!editor) {
        return;
      }
      item?.command?.({
        editor,
        range: props.range,
        upload: props.upload,
        aiController: props.aiController
      });
    };
    $[0] = editor;
    $[1] = props.aiController;
    $[2] = props.range;
    $[3] = props.upload;
    $[4] = t0;
  } else {
    t0 = $[4];
  }
  const selectItem = t0;
  let t1;
  if ($[5] !== props.items.length || $[6] !== selectedIndex) {
    t1 = () => {
      setSelectedIndex((selectedIndex + props.items.length - 1) % props.items.length);
    };
    $[5] = props.items.length;
    $[6] = selectedIndex;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  const upHandler = t1;
  let t2;
  if ($[8] !== props.items.length || $[9] !== selectedIndex) {
    t2 = () => {
      setSelectedIndex((selectedIndex + 1) % props.items.length);
    };
    $[8] = props.items.length;
    $[9] = selectedIndex;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  const downHandler = t2;
  let t3;
  if ($[11] !== props.items || $[12] !== selectItem || $[13] !== selectedIndex) {
    t3 = () => {
      const item_0 = props.items[selectedIndex];
      selectItem(item_0);
    };
    $[11] = props.items;
    $[12] = selectItem;
    $[13] = selectedIndex;
    $[14] = t3;
  } else {
    t3 = $[14];
  }
  const enterHandler = t3;
  let t4;
  if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = () => setSelectedIndex(0);
    $[15] = t4;
  } else {
    t4 = $[15];
  }
  let t5;
  if ($[16] !== props.items) {
    t5 = [props.items];
    $[16] = props.items;
    $[17] = t5;
  } else {
    t5 = $[17];
  }
  useEffect$1(t4, t5);
  let t6;
  if ($[18] !== downHandler || $[19] !== enterHandler || $[20] !== upHandler) {
    t6 = () => ({
      onKeyDown: (t72) => {
        const {
          event
        } = t72;
        if (event.key === "ArrowUp") {
          upHandler();
          return true;
        }
        if (event.key === "ArrowDown") {
          downHandler();
          return true;
        }
        if (event.key === "Enter") {
          enterHandler();
          return true;
        }
        return false;
      }
    });
    $[18] = downHandler;
    $[19] = enterHandler;
    $[20] = upHandler;
    $[21] = t6;
  } else {
    t6 = $[21];
  }
  useImperativeHandle(ref, t6);
  let t7;
  if ($[22] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = [];
    $[22] = t7;
  } else {
    t7 = $[22];
  }
  const itemRefs = useRef$1(t7);
  let t8;
  let t9;
  if ($[23] !== selectedIndex) {
    t8 = () => {
      if (itemRefs.current[selectedIndex]) {
        itemRefs.current[selectedIndex].scrollIntoView({
          block: "nearest"
        });
      }
    };
    t9 = [selectedIndex];
    $[23] = selectedIndex;
    $[24] = t8;
    $[25] = t9;
  } else {
    t8 = $[24];
    t9 = $[25];
  }
  useEffect$1(t8, t9);
  let t10;
  if ($[26] === Symbol.for("react.memo_cache_sentinel")) {
    t10 = cls$1("text-surface-900 dark:text-white z-50 max-h-[280px] h-auto w-72 overflow-y-auto rounded-md border bg-white dark:bg-surface-900 px-1 py-2 shadow transition-all", defaultBorderMixin$1);
    $[26] = t10;
  } else {
    t10 = $[26];
  }
  let t11;
  if ($[27] !== props.items || $[28] !== selectItem || $[29] !== selectedIndex) {
    t11 = props.items.length ? props.items.map((item_1, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { value: item_1.title, ref: (el2) => {
      if (!el2) {
        return;
      }
      itemRefs.current[index2] = el2;
    }, onClick: () => selectItem(item_1), tabIndex: index2 === selectedIndex ? 0 : -1, "aria-selected": index2 === selectedIndex, className: cls$1("flex w-full items-center space-x-2 rounded-md px-2 py-1 text-left text-sm hover:bg-blue-50 hover:dark:bg-surface-700 aria-selected:bg-blue-50 aria-selected:dark:bg-surface-700", index2 === selectedIndex ? "bg-blue-100 dark:bg-surface-accent-950" : ""), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls$1("flex h-10 w-10 items-center justify-center rounded-md border bg-white dark:bg-surface-900", defaultBorderMixin$1), children: item_1.icon }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-medium", children: item_1.title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-surface-700 dark:text-surface-accent-300", children: item_1.description })
      ] })
    ] }, item_1.title)) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "item", children: "No result" });
    $[27] = props.items;
    $[28] = selectItem;
    $[29] = selectedIndex;
    $[30] = t11;
  } else {
    t11 = $[30];
  }
  let t12;
  if ($[31] !== t11) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t10, children: t11 });
    $[31] = t11;
    $[32] = t12;
  } else {
    t12 = $[32];
  }
  return t12;
});
const autocompleteSuggestionItem = {
  title: "Autocomplete",
  description: "Add text based on the context.",
  searchTerms: ["ai"],
  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(AutoFixHighIcon, { size: 18 }),
  command: async ({
    editor,
    range,
    aiController
  }) => {
    if (!aiController) throw Error("No AiController");
    editor.chain().focus().deleteRange(range).toggleNode("paragraph", "paragraph").run();
    const {
      state
    } = editor;
    const {
      from: from2,
      to
    } = state.selection;
    const textBeforeCursor = state.doc.textBetween(0, from2, "\n");
    const textAfterCursor = state.doc.textBetween(to, state.doc.content.size, "\n");
    let buffer = "";
    const result = await aiController.autocomplete(textBeforeCursor, textAfterCursor, (delta) => {
      buffer += delta;
      if (delta.length !== 0) {
        editor.chain().focus().toggleLoadingDecoration(buffer).run();
      }
    });
    editor.chain().focus().insertContent(result, {
      applyInputRules: false,
      applyPasteRules: false,
      parseOptions: {
        preserveWhitespace: false
      }
    }).run();
  }
};
const suggestionItems = [{
  title: "Text",
  description: "Just start typing with plain text.",
  searchTerms: ["p", "paragraph"],
  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(TextFieldsIcon, { size: 18 }),
  command: ({
    editor,
    range
  }) => {
    editor.chain().focus().deleteRange(range).toggleNode("paragraph", "paragraph").run();
  }
}, {
  title: "To-do List",
  description: "Track tasks with a to-do list.",
  searchTerms: ["todo", "task", "list", "check", "checkbox"],
  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxIcon, { size: 18 }),
  command: ({
    editor,
    range
  }) => {
    editor.chain().focus().deleteRange(range).toggleTaskList().run();
  }
}, {
  title: "Heading 1",
  description: "Big section heading.",
  searchTerms: ["title", "big", "large"],
  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(LooksOneIcon, { size: 18 }),
  command: ({
    editor,
    range
  }) => {
    editor.chain().focus().deleteRange(range).setNode("heading", {
      level: 1
    }).run();
  }
}, {
  title: "Heading 2",
  description: "Medium section heading.",
  searchTerms: ["subtitle", "medium"],
  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(LooksTwoIcon, { size: 18 }),
  command: ({
    editor,
    range
  }) => {
    editor.chain().focus().deleteRange(range).setNode("heading", {
      level: 2
    }).run();
  }
}, {
  title: "Heading 3",
  description: "Small section heading.",
  searchTerms: ["subtitle", "small"],
  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Looks3Icon, { size: 18 }),
  command: ({
    editor,
    range
  }) => {
    editor.chain().focus().deleteRange(range).setNode("heading", {
      level: 3
    }).run();
  }
}, {
  title: "Bullet List",
  description: "Create a simple bullet list.",
  searchTerms: ["unordered", "point"],
  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FormatListBulletedIcon, { size: 18 }),
  command: ({
    editor,
    range
  }) => {
    editor.chain().focus().deleteRange(range).toggleBulletList().run();
  }
}, {
  title: "Numbered List",
  description: "Create a list with numbering.",
  searchTerms: ["ordered"],
  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FormatListNumberedIcon$1, { size: 18 }),
  command: ({
    editor,
    range
  }) => {
    editor.chain().focus().deleteRange(range).toggleOrderedList().run();
  }
}, {
  title: "Quote",
  description: "Capture a quote.",
  searchTerms: ["blockquote"],
  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FormatQuoteIcon$1, { size: 18 }),
  command: ({
    editor,
    range
  }) => editor.chain().focus().deleteRange(range).toggleNode("paragraph", "paragraph").toggleBlockquote().run()
}, {
  title: "Code",
  description: "Capture a code snippet.",
  searchTerms: ["codeblock"],
  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CodeIcon, { size: 18 }),
  command: ({
    editor,
    range
  }) => editor.chain().focus().deleteRange(range).toggleCodeBlock().run()
}, {
  title: "Image",
  description: "Upload an image from your computer.",
  searchTerms: ["photo", "picture", "media", "upload", "file"],
  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(ImageIcon, { size: 18 }),
  command: ({
    editor,
    range,
    upload
  }) => {
    editor.chain().focus().deleteRange(range).run();
    const input = document.createElement("input");
    input.type = "file";
    input.accept = "image/*";
    input.onchange = async () => {
      if (input.files?.length) {
        const file = input.files[0];
        if (!file) return;
        const pos = editor.view.state.selection.from;
        const fileList = input.files;
        const files = Array.from(fileList);
        const images = files.filter((file2) => /image/i.test(file2.type));
        if (images.length === 0) {
          console.log("No images found in uploaded files");
          return false;
        }
        const view = editor.view;
        images.forEach((image) => {
          const reader = new FileReader();
          reader.onload = async (readerEvent) => {
            await onFileRead(view, readerEvent, pos, upload, image);
          };
          reader.readAsDataURL(image);
        });
      }
      return true;
    };
    input.click();
  }
}];
const CustomDocument = Document$1.extend({
  // content: 'heading block*',
});
const proseClasses = {
  "sm": "prose-sm",
  "base": "prose-base",
  "lg": "prose-lg"
};
const FireCMSEditor = ({
  content,
  onJsonContentChange,
  onHtmlContentChange,
  onMarkdownContentChange,
  version,
  textSize = "base",
  highlight,
  handleImageUpload,
  aiController,
  onDisabledAutocompleteClick
}) => {
  const ref = React$1.useRef(null);
  const editorRef = React$1.useRef(null);
  const imagePlugin = createDropImagePlugin(handleImageUpload);
  const imageExtension = useMemo$1(() => createImageExtension(imagePlugin), []);
  const [openNode, setOpenNode] = useState$1(false);
  const [openLink, setOpenLink] = useState$1(false);
  useInjectStyles("Editor", cssStyles);
  const deferredHighlight = useDeferredValue(highlight);
  useEffect$1(() => {
    if (version === void 0) return;
    if (version > -1 && editorRef.current) {
      editorRef.current?.commands.setContent(content ?? "");
    }
  }, [version]);
  useEffect$1(() => {
    if (version === void 0) return;
    if (editorRef.current && version > 0) {
      const chain = editorRef.current.chain();
      if (deferredHighlight) {
        chain.focus().toggleAutocompleteHighlight(deferredHighlight).run();
      } else {
        chain.focus().removeAutocompleteHighlight().run();
      }
    }
  }, [deferredHighlight?.from, deferredHighlight?.to]);
  const onEditorUpdate = (editor) => {
    editorRef.current = editor;
    if (onMarkdownContentChange) {
      const markdown = editorRef.current.storage.markdown.getMarkdown();
      onMarkdownContentChange?.(addLineBreakAfterImages(markdown));
    }
    if (onJsonContentChange) {
      const jsonContent = removeClassesFromJson(editor.getJSON());
      onJsonContentChange(jsonContent);
    }
    if (onHtmlContentChange) {
      onHtmlContentChange?.(editor.getHTML());
    }
  };
  const proseClass = proseClasses[textSize];
  const extensions = useMemo$1(() => [
    starterKit,
    CustomDocument,
    HighlightDecorationExtension(highlight),
    TextLoadingDecorationExtension,
    Underline,
    Bold$1,
    TextStyle,
    Italic$1,
    Strike$1,
    Color,
    Highlight.configure({
      multicolor: true
    }),
    // CustomBlock.configure({
    //     component: CustomComponent,
    //     delimiter: "```custom"
    // }),
    Heading$1,
    CustomKeymap,
    DragAndDrop,
    placeholder,
    tiptapLink,
    imageExtension,
    taskList,
    taskItem,
    Markdown$1.configure({
      html: true
    }),
    horizontalRule,
    bulletList,
    orderedList,
    listItem,
    blockquote,
    codeBlock,
    code,
    SlashCommand.configure({
      HTMLAttributes: {
        class: "mention"
      },
      suggestion: suggestion(ref, {
        upload: handleImageUpload,
        aiController,
        onDisabledAutocompleteClick
      })
    })
  ], []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: "relative min-h-[300px] w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(EditorProvider, { content: content ?? "", extensions, editorProps: {
    attributes: {
      class: cls$1(proseClass, "prose-headings:font-title font-default focus:outline-none max-w-full p-12")
    }
  }, onCreate: ({
    editor: editor_0
  }) => {
    editorRef.current = editor_0;
  }, onUpdate: ({
    editor: editor_1
  }) => {
    onEditorUpdate(editor_1);
  }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(EditorBubble, { tippyOptions: {
    placement: "top"
  }, className: cls$1("flex w-fit max-w-[90vw] h-10 overflow-hidden rounded border bg-white dark:bg-surface-900 shadow", defaultBorderMixin$1), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(NodeSelector, { portalContainer: ref.current, open: openNode, onOpenChange: setOpenNode }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Separator, { orientation: "vertical" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LinkSelector, { open: openLink, onOpenChange: setOpenLink }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Separator, { orientation: "vertical" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TextButtons, {})
  ] }) }) });
};
function addLineBreakAfterImages(markdown) {
  const imageRegex = /!\[.*?\]\(.*?\)/g;
  return markdown.replace(imageRegex, (match2) => `${match2}
`);
}
const cssStyles = `
.ProseMirror {
    box-shadow: none !important;
}
.ProseMirror .is-editor-empty:first-child::before {
  content: attr(data-placeholder);
  float: left;
  color:  rgb(100 116 139); //500
  pointer-events: none;
  height: 0;
}
.ProseMirror .is-empty::before {
  content: attr(data-placeholder);
  float: left;
  color:  rgb(100 116 139); //500
  pointer-events: none;
  height: 0;
}

[data-theme="dark"] {
  .ProseMirror .is-empty::before {
    color: rgb(100 116 139); //500
  }
}

.is-empty {
  cursor: text;
  color: rgb(100 116 139); //500
}


/* Custom image styles */

.ProseMirror img {
  transition: filter 0.1s ease-in-out;

  &:hover {
    cursor: pointer;
    filter: brightness(90%);
  }

  &.ProseMirror-selectednode {
    outline: 3px solid #5abbf7;
    filter: brightness(90%);
    box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000) !important;
  }
}

/* Custom TODO list checkboxes  shoutout to this awesome tutorial: https://moderncss.dev/pure-css-custom-checkbox-style/ */

ul[data-type="taskList"] li > label {
  margin-right: 0.2rem;
  user-select: none;
}

@media screen and (max-width: 768px) {
  ul[data-type="taskList"] li > label {
    margin-right: 0.5rem;
  }
}


[data-theme="dark"] {
  ul[data-type="taskList"] li > label input[type="checkbox"] {
    background-color: rgb(30 41 59); // 800
    border: 2px solid #666;
  
    &:hover {
      background-color: rgb(51 65 85); // 700
    }
  
    &:active {
      background-color: rgb(71 85 105);
    }
  }
}
  

ul[data-type="taskList"] li > label input[type="checkbox"] {
  -webkit-appearance: none;
  appearance: none;
  background-color: white;
  margin: 0;
  cursor: pointer;
  width: 1.2em;
  height: 1.2em;
  position: relative;
  top: 5px;
  border: 2px solid #777;
  border-radius: 0.25em;
  margin-right: 0.3rem;
  display: grid;
  place-content: center;

  &:hover {
    background-color: rgb(241 245 249); //100
  }

  &:active {
    background-color: rgb(226 232 240); //200
  }

  &::before {
    content: "";
    width: 0.65em;
    height: 0.65em;
    transform: scale(0);
    transition: 120ms transform ease-in-out;
    box-shadow: inset 1em 1em;
    transform-origin: center;
    clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
  }

  &:checked::before {
    transform: scale(1);
  }
}

[data-theme="dark"] {
  ul[data-type="taskList"] li[data-checked="true"] > div > p {
    color: rgb(226 232 240);
    text-decoration: line-through;
    text-decoration-thickness: 2px;
  }
}

ul[data-type="taskList"] li[data-checked="true"] > div > p {
  color: rgb(51 65 85); // 700
  text-decoration: line-through;
  text-decoration-thickness: 2px;
}

/* Overwrite tippy-box original max-width */

.tippy-box {
  max-width: 400px !important;
}

.ProseMirror:not(.dragging) .ProseMirror-selectednode {
  // outline: none !important;
  background-color: rgb(219 234 254); // blue 100
  transition: background-color 0.2s;
  box-shadow: none;
}

[data-theme="dark"] .ProseMirror:not(.dragging) .ProseMirror-selectednode {
  background-color:  rgb(51 65 85); // 700
}

.prose-base table p {
    margin: 0;
}

.drag-handle {
  position: absolute;
  opacity: 1;
  transition: opacity ease-in 0.2s;
  border-radius: 0.25rem;

  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 10 10' style='fill: rgba(128, 128, 128, 0.9)'%3E%3Cpath d='M3,2 C2.44771525,2 2,1.55228475 2,1 C2,0.44771525 2.44771525,0 3,0 C3.55228475,0 4,0.44771525 4,1 C4,1.55228475 3.55228475,2 3,2 Z M3,6 C2.44771525,6 2,5.55228475 2,5 C2,4.44771525 2.44771525,4 3,4 C3.55228475,4 4,4.44771525 4,5 C4,5.55228475 3.55228475,6 3,6 Z M3,10 C2.44771525,10 2,9.55228475 2,9 C2,8.44771525 2.44771525,8 3,8 C3.55228475,8 4,8.44771525 4,9 C4,9.55228475 3.55228475,10 3,10 Z M7,2 C6.44771525,2 6,1.55228475 6,1 C6,0.44771525 6.44771525,0 7,0 C7.55228475,0 8,0.44771525 8,1 C8,1.55228475 7.55228475,2 7,2 Z M7,6 C6.44771525,6 6,5.55228475 6,5 C6,4.44771525 6.44771525,4 7,4 C7.55228475,4 8,4.44771525 8,5 C8,5.55228475 7.55228475,6 7,6 Z M7,10 C6.44771525,10 6,9.55228475 6,9 C6,8.44771525 6.44771525,8 7,8 C7.55228475,8 8,8.44771525 8,9 C8,9.55228475 7.55228475,10 7,10 Z'%3E%3C/path%3E%3C/svg%3E");
  background-size: calc(0.5em + 0.375rem) calc(0.5em + 0.375rem);
  background-repeat: no-repeat;
  background-position: center;
  width: 1.2rem;
  height: 1.5rem;
  z-index: 100;
  cursor: grab;

  &:hover {
    background-color: rgb(241 245 249); //100
    transition: background-color 0.2s;
  }

  &:active {
    background-color: rgb(226 232 240); //200
    transition: background-color 0.2s;
  }

  &.hide {
    opacity: 0;
    pointer-events: none;
  }

  @media screen and (max-width: 600px) {
    display: none;
    pointer-events: none;
  }
}

[data-theme="dark"] .drag-handle {
  &:hover {
    background-color: rgb(51 65 85); // 700
  }

  &:active {
    background-color: rgb(51 65 85); // 700
  }
}
`;
const React = await importShared("react");
const React__default = await importShared("react");
const { forwardRef, useState, useRef, useEffect, useContext, useCallback, useMemo, createRef, createContext, useLayoutEffect, createElement } = React__default;
const { getColorSchemeForSeed, CHIP_COLORS, Tooltip, IconButton, InfoIcon, Typography, ContentCopyIcon, CircleIcon, FunctionsIcon, iconKeys, coolIconKeys, Icon, ErrorIcon, cls, defaultBorderMixin, OpenInNewIcon, TextareaAutosize, focusedDisabled, MultiSelect, MultiSelectItem, Select, SelectItem, BooleanSwitch, DateTimeField, Skeleton, paperMixin, EditIcon, KeyboardTabIcon, DoNotDisturbOnIcon, Menu, MoreVertIcon, MenuItem, Checkbox, CircularProgress, SearchBar, Badge, ArrowUpwardIcon, Popover, FilterListIcon, Button, CenteredView, AssignmentIcon, Label, CloseIcon, TextField, BooleanSwitchWithLabel, useOutsideAlerter, Dialog, DialogTitle, DialogContent, DialogActions, FileCopyIcon, ArchiveIcon, DeleteIcon, AddIcon, ExpandablePanel, Markdown, ArrowForwardIcon, Card, cardMixin, cardClickableMixin, StarIcon, Chip, Collapse, Container, NotesIcon, Tab, Tabs, Alert, FilterListOffIcon, SearchIcon, LoadingButton, Avatar, DarkModeIcon, LightModeIcon, LogoutIcon, HandleIcon, RemoveIcon, KeyboardArrowUpIcon, KeyboardArrowDownIcon, debounce, DescriptionIcon, fieldBackgroundMixin, fieldBackgroundHoverMixin, fieldBackgroundDisabledMixin, ArrowDropDownIcon, ShortTextIcon, SubjectIcon, FormatQuoteIcon, HttpIcon, MailIcon, FlagIcon, ListIcon, ListAltIcon, NumbersIcon, FormatListNumberedIcon, UploadFileIcon, DriveFolderUploadIcon, LinkIcon, AddLinkIcon, ScheduleIcon, BallotIcon, RepeatIcon, ViewStreamIcon, Sheet, MenuIcon, ChevronLeftIcon } = await importShared("@firecms/ui");
const SnackbarProvider = (t0) => {
  const $ = c_1(2);
  const {
    children
  } = t0;
  let t1;
  if ($[0] !== children) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarProvider$1, { maxSnack: 3, autoHideDuration: 3500, children });
    $[0] = children;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
};
const DEFAULT_MODE_STATE = {
  mode: "light",
  setMode: (mode) => {
  },
  toggleMode: () => {
  }
};
const ModeControllerContext = React__default.createContext(DEFAULT_MODE_STATE);
const ModeControllerProvider = ModeControllerContext.Provider;
const AuthControllerContext = React__default.createContext({});
function removeInitialAndTrailingSlashes(s2) {
  return removeInitialSlash(removeTrailingSlash(s2));
}
function removeInitialSlash(s2) {
  if (s2.startsWith("/")) return s2.slice(1);
  else return s2;
}
function removeTrailingSlash(s2) {
  if (s2.endsWith("/")) return s2.slice(0, -1);
  else return s2;
}
function addInitialSlash(s2) {
  if (s2.startsWith("/")) return s2;
  else return `/${s2}`;
}
function getLastSegment(path) {
  const cleanPath = removeInitialAndTrailingSlashes(path);
  if (cleanPath.includes("/")) {
    const segments = cleanPath.split("/");
    return segments[segments.length - 1];
  }
  return cleanPath;
}
function resolveCollectionPathIds(path, allCollections) {
  const cleanPath = removeInitialAndTrailingSlashes(path);
  const subpaths = cleanPath.split("/");
  if (subpaths.length % 2 === 0) {
    throw Error(`resolveCollectionPathAliases: Collection paths must have an odd number of segments: ${path}`);
  }
  const aliasedCollection = allCollections.find((col) => col.id === subpaths[0]);
  let resolvedAliased;
  if (aliasedCollection) {
    resolvedAliased = aliasedCollection.path;
  }
  if (subpaths.length > 1) {
    const segmentCollection = getCollectionByPathOrId(resolvedAliased ?? subpaths[0], allCollections);
    if (!segmentCollection?.subcollections) {
      return cleanPath;
    }
    const restOfThePath = cleanPath.split("/").slice(2).join("/");
    return (resolvedAliased ?? subpaths[0]) + "/" + subpaths[1] + "/" + resolveCollectionPathIds(restOfThePath, segmentCollection.subcollections);
  } else {
    return resolvedAliased ?? cleanPath;
  }
}
function getCollectionByPathOrId(pathOrId, collections) {
  const subpaths = removeInitialAndTrailingSlashes(pathOrId).split("/");
  if (subpaths.length % 2 === 0) {
    throw Error(`getCollectionByPathOrId: Collection paths must have an odd number of segments: ${pathOrId}`);
  }
  const subpathCombinations = getCollectionPathsCombinations(subpaths);
  let result;
  for (let i = 0; i < subpathCombinations.length; i++) {
    const subpathCombination = subpathCombinations[i];
    const navigationEntry = collections && collections.sort((a2, b) => (a2.id ?? "").localeCompare(b.id ?? "")).find((entry) => entry.id === subpathCombination || entry.path === subpathCombination);
    if (navigationEntry) {
      if (subpathCombination === pathOrId) {
        result = navigationEntry;
      } else if (navigationEntry.subcollections) {
        const newPath = pathOrId.replace(subpathCombination, "").split("/").slice(2).join("/");
        if (newPath.length > 0) result = getCollectionByPathOrId(newPath, navigationEntry.subcollections);
      }
    }
    if (result) break;
  }
  return result;
}
function getCollectionPathsCombinations(subpaths) {
  const entries = subpaths.length > 0 && subpaths.length % 2 === 0 ? subpaths.splice(0, subpaths.length - 1) : subpaths;
  const length = entries.length;
  const result = [];
  for (let i = length; i > 0; i = i - 2) {
    result.push(entries.slice(0, i).join("/"));
  }
  return result;
}
class EntityReference {
  /**
   * ID of the entity
   */
  id;
  /**
   * A string representing the path of the referenced document (relative
   * to the root of the database).
   */
  path;
  constructor(id2, path) {
    this.id = id2;
    this.path = path;
  }
  get pathWithId() {
    return `${this.path}/${this.id}`;
  }
  isEntityReference() {
    return true;
  }
}
class GeoPoint {
  /**
   * The latitude of this GeoPoint instance.
   */
  latitude;
  /**
   * The longitude of this GeoPoint instance.
   */
  longitude;
  constructor(latitude, longitude) {
    this.latitude = latitude;
    this.longitude = longitude;
  }
}
class Vector {
  value;
  constructor(value) {
    this.value = value;
  }
}
const pick = (obj, ...args) => ({
  ...args.reduce((res, key) => ({
    ...res,
    [key]: obj[key]
  }), {})
});
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
function mergeDeep(target, source) {
  const targetIsObject = isObject(target);
  const output = targetIsObject ? {
    ...target
  } : target;
  if (targetIsObject && isObject(source)) {
    Object.keys(source).forEach((key) => {
      const sourceElement = source[key];
      if (isObject(sourceElement)) {
        if (!(key in target)) Object.assign(output, {
          [key]: sourceElement
        });
        else output[key] = mergeDeep(target[key], sourceElement);
      } else {
        Object.assign(output, {
          [key]: sourceElement
        });
      }
    });
  }
  return output;
}
function getValueInPath(o2, path) {
  if (!o2) return void 0;
  if (typeof o2 === "object") {
    if (path in o2) {
      return o2[path];
    }
    if (path.includes(".") || path.includes("[")) {
      let pathSegments = path.split(/[.[]/);
      if (path.includes("[")) {
        pathSegments = pathSegments.map((segment) => segment.replace("]", ""));
      }
      const firstSegment = pathSegments[0];
      const isArrayAndIndexExists = Array.isArray(o2[firstSegment]) && !isNaN(parseInt(pathSegments[1]));
      const nextObject = isArrayAndIndexExists ? o2[firstSegment][parseInt(pathSegments[1])] : o2[firstSegment];
      const nextPath = pathSegments.slice(isArrayAndIndexExists ? 2 : 1).join(".");
      if (nextPath === "") return nextObject;
      return getValueInPath(nextObject, nextPath);
    }
  }
  return void 0;
}
function removeInPath(o2, path) {
  let currentObject = {
    ...o2
  };
  const parts = path.split(".");
  const last = parts.pop();
  for (const part of parts) {
    currentObject = currentObject[part];
  }
  if (last) delete currentObject[last];
  return currentObject;
}
function removeFunctions(o2) {
  if (o2 === void 0) return void 0;
  if (o2 === null) return null;
  if (typeof o2 === "object") {
    return Object.entries(o2).filter(([_, value]) => typeof value !== "function").map(([key, value]) => {
      if (Array.isArray(value)) {
        return {
          [key]: value.map((v) => removeFunctions(v))
        };
      } else if (typeof value === "object") {
        return {
          [key]: removeFunctions(value)
        };
      } else return {
        [key]: value
      };
    }).reduce((a2, b) => ({
      ...a2,
      ...b
    }), {});
  }
  return o2;
}
function getHashValue(v) {
  if (!v) return null;
  if (typeof v === "object") {
    if ("id" in v) return v.id;
    else if (v instanceof Date) return v.toLocaleString();
    else if (v instanceof GeoPoint) return hash$2(v);
  }
  return hash$2(v, {
    ignoreUnknown: true
  });
}
function removeUndefined(value, removeEmptyStrings) {
  if (typeof value === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map((v) => removeUndefined(v, removeEmptyStrings));
  }
  if (typeof value === "object") {
    const res = {};
    if (value === null) return value;
    Object.keys(value).forEach((key) => {
      if (!isEmptyObject(value)) {
        const childRes = removeUndefined(value[key], removeEmptyStrings);
        const isString = typeof childRes === "string";
        const shouldKeepIfString = !removeEmptyStrings || removeEmptyStrings && !isString || removeEmptyStrings && isString && childRes !== "";
        if (childRes !== void 0 && !isEmptyObject(childRes) && shouldKeepIfString) res[key] = childRes;
      }
    });
    return res;
  }
  return value;
}
function removeNulls(value) {
  if (typeof value === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map((v) => removeNulls(v));
  }
  if (typeof value === "object") {
    const res = {};
    if (value === null) return value;
    Object.keys(value).forEach((key) => {
      if (value[key] !== null) res[key] = removeNulls(value[key]);
    });
    return res;
  }
  return value;
}
function isEmptyObject(obj) {
  return obj && Object.getPrototypeOf(obj) === Object.prototype && Object.keys(obj).length === 0;
}
function removePropsIfExisting(source, comparison) {
  const isObject2 = (val) => typeof val === "object" && val !== null;
  const isArray2 = (val) => Array.isArray(val);
  if (!isObject2(source) || !isObject2(comparison)) {
    return source;
  }
  const res = isArray2(source) ? [...source] : {
    ...source
  };
  if (isArray2(res)) {
    for (let i = res.length - 1; i >= 0; i--) {
      if (res[i] === comparison[i]) {
        res.splice(i, 1);
      } else if (isObject2(res[i]) && isObject2(comparison[i])) {
        res[i] = removePropsIfExisting(res[i], comparison[i]);
      }
    }
  } else {
    Object.keys(comparison).forEach((key) => {
      if (key in res) {
        if (isObject2(res[key]) && isObject2(comparison[key])) {
          res[key] = removePropsIfExisting(res[key], comparison[key]);
        } else if (res[key] === comparison[key]) {
          delete res[key];
        }
      }
    });
  }
  return res;
}
const DEFAULT_ONE_OF_TYPE = "type";
const DEFAULT_ONE_OF_VALUE = "value";
function isReadOnly(property2) {
  if (property2.readOnly) return true;
  if (property2.dataType === "date") {
    if (property2.autoValue) return true;
  }
  if (property2.dataType === "reference") {
    return !property2.path;
  }
  return false;
}
function isHidden(property2) {
  return typeof property2.disabled === "object" && Boolean(property2.disabled.hidden);
}
function isPropertyBuilder(propertyOrBuilder) {
  return typeof propertyOrBuilder === "function";
}
function getDefaultValuesFor(properties) {
  if (!properties) return {};
  return Object.entries(properties).map(([key, property2]) => {
    if (!property2) return {};
    const value = getDefaultValueFor(property2);
    return value === void 0 ? {} : {
      [key]: value
    };
  }).reduce((a2, b) => ({
    ...a2,
    ...b
  }), {});
}
function getDefaultValueFor(property2) {
  if (!property2) return void 0;
  if (isPropertyBuilder(property2)) return void 0;
  if (property2.defaultValue || property2.defaultValue === null) {
    return property2.defaultValue;
  } else if (property2.dataType === "map" && property2.properties) {
    const defaultValuesFor = getDefaultValuesFor(property2.properties);
    if (Object.keys(defaultValuesFor).length === 0) return void 0;
    return defaultValuesFor;
  } else {
    return getDefaultValueForDataType(property2.dataType);
  }
}
function getDefaultValueForDataType(dataType) {
  if (dataType === "string") {
    return null;
  } else if (dataType === "number") {
    return null;
  } else if (dataType === "boolean") {
    return false;
  } else if (dataType === "date") {
    return null;
  } else if (dataType === "array") {
    return [];
  } else if (dataType === "map") {
    return {};
  } else {
    return null;
  }
}
function updateDateAutoValues({
  inputValues,
  properties,
  status,
  timestampNowValue,
  setDateToMidnight
}) {
  return traverseValuesProperties(inputValues, properties, (inputValue, property2) => {
    if (property2.dataType === "date") {
      let resultDate;
      if (status === "existing" && property2.autoValue === "on_update") {
        resultDate = timestampNowValue;
      } else if ((status === "new" || status === "copy") && (property2.autoValue === "on_update" || property2.autoValue === "on_create")) {
        resultDate = timestampNowValue;
      } else {
        resultDate = inputValue;
      }
      if (property2.mode === "date") resultDate = setDateToMidnight(resultDate);
      return resultDate;
    } else {
      return inputValue;
    }
  }) ?? {};
}
function sanitizeData(values, properties) {
  const result = values;
  Object.entries(properties).forEach(([key, property2]) => {
    if (values && values[key] !== void 0) result[key] = values[key];
    else if (property2.validation?.required) result[key] = null;
  });
  return result;
}
function getReferenceFrom(entity) {
  return new EntityReference(entity.id, entity.path);
}
function traverseValuesProperties(inputValues, properties, operation) {
  const updatedValues = Object.entries(properties).map(([key, property2]) => {
    const inputValue = inputValues && inputValues[key];
    const updatedValue = traverseValueProperty(inputValue, property2, operation);
    if (updatedValue === null) return null;
    if (updatedValue === void 0) return void 0;
    return {
      [key]: updatedValue
    };
  }).reduce((a2, b) => ({
    ...a2,
    ...b
  }), {});
  const result = {
    ...inputValues,
    ...updatedValues
  };
  if (Object.keys(result).length === 0) return void 0;
  return result;
}
function traverseValueProperty(inputValue, property2, operation) {
  let value;
  if (property2.dataType === "map" && property2.properties) {
    value = traverseValuesProperties(inputValue, property2.properties, operation);
  } else if (property2.dataType === "array") {
    if (property2.of && Array.isArray(inputValue)) {
      value = inputValue.map((e2) => traverseValueProperty(e2, property2.of, operation));
    } else if (property2.oneOf && Array.isArray(inputValue)) {
      const typeField = property2.oneOf?.typeField ?? DEFAULT_ONE_OF_TYPE;
      const valueField = property2.oneOf?.valueField ?? DEFAULT_ONE_OF_VALUE;
      value = inputValue.map((e2) => {
        if (e2 === null) return null;
        if (typeof e2 !== "object") return e2;
        const type = e2[typeField];
        const childProperty = property2.oneOf?.properties[type];
        if (!type || !childProperty) return e2;
        return {
          [typeField]: type,
          [valueField]: traverseValueProperty(e2[valueField], childProperty, operation)
        };
      });
    } else {
      value = inputValue;
    }
  } else {
    value = operation(inputValue, property2);
  }
  return value;
}
function enumToObjectEntries(enumValues) {
  if (Array.isArray(enumValues)) {
    return enumValues;
  } else {
    return Object.entries(enumValues).map(([id2, value]) => {
      if (typeof value === "string") {
        return {
          id: id2,
          label: value
        };
      } else {
        return {
          ...value,
          id: id2
        };
      }
    });
  }
}
function getLabelOrConfigFrom(enumValues, key) {
  if (key === null || key === void 0) return void 0;
  return enumValues.find((entry) => String(entry.id) === String(key));
}
function getColorScheme(enumValues, key) {
  const labelOrConfig = getLabelOrConfigFrom(enumValues, key);
  if (!labelOrConfig?.color) return getColorSchemeForSeed(key.toString());
  if (typeof labelOrConfig === "object" && "color" in labelOrConfig) {
    if (typeof labelOrConfig.color === "string") return CHIP_COLORS[labelOrConfig.color];
    if (typeof labelOrConfig.color === "object") return labelOrConfig.color;
  }
  return void 0;
}
function isEnumValueDisabled(labelOrConfig) {
  return typeof labelOrConfig === "object" && labelOrConfig.disabled;
}
function buildEnumLabel(labelOrConfig) {
  if (labelOrConfig === void 0) return void 0;
  if (typeof labelOrConfig === "object") {
    return labelOrConfig.label;
  } else {
    return labelOrConfig;
  }
}
function FieldHelperText(t0) {
  const $ = c_1(10);
  const {
    error,
    showError,
    property: property2,
    includeDescription: t1,
    disabled
  } = t0;
  const includeDescription = t1 === void 0 ? true : t1;
  const hasDescription = property2.description || property2.longDescription;
  if (!(showError && error) && (!includeDescription || !hasDescription)) {
    return null;
  }
  if (showError && error) {
    let t22;
    if ($[0] !== error) {
      t22 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", className: "ml-3.5 text-red-500 dark:text-red-500", children: error });
      $[0] = error;
      $[1] = t22;
    } else {
      t22 = $[1];
    }
    return t22;
  }
  const disabledTooltip = typeof property2.disabled === "object" ? property2.disabled.disabledMessage : void 0;
  const t2 = disabled ? "disabled" : "secondary";
  const t3 = disabledTooltip || property2.description;
  let t4;
  if ($[2] !== t2 || $[3] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: t2, className: "flex-grow", children: t3 });
    $[2] = t2;
    $[3] = t3;
    $[4] = t4;
  } else {
    t4 = $[4];
  }
  let t5;
  if ($[5] !== property2.longDescription) {
    t5 = property2.longDescription && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: property2.longDescription, side: "bottom", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { size: "small", className: "self-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoIcon, { color: "disabled", size: "small" }) }) });
    $[5] = property2.longDescription;
    $[6] = t5;
  } else {
    t5 = $[6];
  }
  let t6;
  if ($[7] !== t4 || $[8] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex ml-3.5 mt-1", children: [
      t4,
      t5
    ] });
    $[7] = t4;
    $[8] = t5;
    $[9] = t6;
  } else {
    t6 = $[9];
  }
  return t6;
}
const LabelWithIcon = forwardRef((t0, ref) => {
  const $ = c_1(8);
  const {
    icon,
    title,
    small,
    className,
    required
  } = t0;
  const t1 = `inline-flex items-center my-0.5 ${small ? "gap-1" : "gap-2"} ${className ?? ""}`;
  const t2 = `text-start font-medium text-${small ? "base" : "sm"} origin-top-left transform ${small ? "translate-x-2 scale-75" : ""}`;
  const t3 = (title ?? "") + (required ? " *" : "");
  let t4;
  if ($[0] !== t2 || $[1] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: t2, children: t3 });
    $[0] = t2;
    $[1] = t3;
    $[2] = t4;
  } else {
    t4 = $[2];
  }
  let t5;
  if ($[3] !== icon || $[4] !== ref || $[5] !== t1 || $[6] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref, className: t1, children: [
      icon,
      t4
    ] });
    $[3] = icon;
    $[4] = ref;
    $[5] = t1;
    $[6] = t4;
    $[7] = t5;
  } else {
    t5 = $[7];
  }
  return t5;
});
LabelWithIcon.displayName = "LabelWithIcon";
function PropertyIdCopyTooltip(t0) {
  const $ = c_1(6);
  const {
    propertyKey,
    className,
    children
  } = t0;
  let t1;
  if ($[0] !== propertyKey) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyIdCopyTooltipContent, { propertyKey });
    $[0] = propertyKey;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== children || $[3] !== className || $[4] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: t1, delayDuration: 800, side: "top", asChild: false, align: "start", sideOffset: 8, className, children });
    $[2] = children;
    $[3] = className;
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}
function PropertyIdCopyTooltipContent(t0) {
  const $ = c_1(14);
  const {
    propertyKey
  } = t0;
  const [copied, setCopied] = useState(false);
  const t1 = copied ? "Copied" : "Property ID";
  let t2;
  if ($[0] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", className: "min-w-20 text-surface-accent-400", color: "disabled", children: t1 });
    $[0] = t1;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  let t3;
  if ($[2] !== propertyKey) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", className: "text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: propertyKey }) });
    $[2] = propertyKey;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  let t4;
  if ($[4] !== t2 || $[5] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      t2,
      t3
    ] });
    $[4] = t2;
    $[5] = t3;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  let t5;
  if ($[7] !== propertyKey) {
    t5 = () => {
      navigator.clipboard.writeText(propertyKey);
      setCopied(true);
      setTimeout(() => setCopied(false), 2e3);
    };
    $[7] = propertyKey;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  const t6 = t5;
  let t7;
  if ($[9] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { size: "small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ContentCopyIcon, { size: "smallest", className: "text-white", onClick: t6 }) });
    $[9] = t6;
    $[10] = t7;
  } else {
    t7 = $[10];
  }
  let t8;
  if ($[11] !== t4 || $[12] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row gap-2 items-center justify-center text-white", children: [
      t4,
      t7
    ] });
    $[11] = t4;
    $[12] = t7;
    $[13] = t8;
  } else {
    t8 = $[13];
  }
  return t8;
}
function LabelWithIconAndTooltip(t0) {
  const $ = c_1(10);
  let className;
  let propertyKey;
  let props;
  if ($[0] !== t0) {
    ({
      propertyKey,
      className,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = className;
    $[2] = propertyKey;
    $[3] = props;
  } else {
    className = $[1];
    propertyKey = $[2];
    props = $[3];
  }
  let t1;
  if ($[4] !== props) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(LabelWithIcon, { ...props });
    $[4] = props;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  let t2;
  if ($[6] !== className || $[7] !== propertyKey || $[8] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyIdCopyTooltip, { propertyKey, className, children: t1 });
    $[6] = className;
    $[7] = propertyKey;
    $[8] = t1;
    $[9] = t2;
  } else {
    t2 = $[9];
  }
  return t2;
}
function sortProperties(properties, propertiesOrder) {
  try {
    const propertiesKeys = Object.keys(properties);
    const allPropertiesOrder = propertiesOrder ?? propertiesKeys;
    return allPropertiesOrder.map((key) => {
      if (properties[key]) {
        const property2 = properties[key];
        if (!isPropertyBuilder(property2) && property2?.dataType === "map" && property2.properties) {
          return {
            [key]: {
              ...property2,
              properties: sortProperties(property2.properties, property2.propertiesOrder)
            }
          };
        } else {
          return {
            [key]: property2
          };
        }
      } else {
        return void 0;
      }
    }).filter((a2) => a2 !== void 0).reduce((a2, b) => ({
      ...a2,
      ...b
    }), {});
  } catch (e2) {
    console.error("Error sorting properties", e2);
    return properties;
  }
}
function resolveDefaultSelectedView(defaultSelectedView, params) {
  if (!defaultSelectedView) {
    return void 0;
  } else if (typeof defaultSelectedView === "string") {
    return defaultSelectedView;
  } else {
    return defaultSelectedView(params);
  }
}
const applyPermissionsFunctionIfEmpty = (collections, permissionsBuilder) => {
  return collections.map((collection) => {
    if (collection.permissions) {
      return collection;
    }
    return {
      ...collection,
      permissions: permissionsBuilder
    };
  });
};
const kebabCaseRegex = /[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g;
const toKebabCase = (str) => {
  const regExpMatchArray = str.match(kebabCaseRegex);
  if (!regExpMatchArray) return "";
  return regExpMatchArray.map((x) => x.toLowerCase()).join("-");
};
const snakeCaseRegex = /[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g;
const toSnakeCase = (str) => {
  const regExpMatchArray = str.match(snakeCaseRegex);
  if (!regExpMatchArray) return "";
  return regExpMatchArray.map((x) => x.toLowerCase()).join("_");
};
function randomString(strLength = 5) {
  return Math.random().toString(36).slice(2, 2 + strLength);
}
function randomColor() {
  return Math.floor(Math.random() * 16777215).toString(16);
}
function slugify(text, separator = "_", lowercase = true) {
  if (!text) return "";
  const from2 = "/_,:;-";
  const to = `aaaaaeeeeeiiiiooooouuuunc${separator}${separator}${separator}${separator}${separator}${separator}${separator}`;
  for (let i = 0, l2 = from2.length; i < l2; i++) {
    text = text.replace(new RegExp(from2.charAt(i), "g"), to.charAt(i));
  }
  text = text.toString().replace(/\s+/g, separator).replace(/&/g, separator).replace(/[^\w\\-]+/g, "").replace(new RegExp("\\" + separator + "\\" + separator + "+", "g"), separator).trim().replace(/^\s+|\s+$/g, "");
  return lowercase ? text.toLowerCase() : text;
}
function unslugify(slug) {
  if (!slug) return "";
  if (slug.includes("-") || slug.includes("_") || !slug.includes(" ")) {
    const result = slug.replace(/[-_]/g, " ");
    return result.replace(/\w\S*/g, function(txt) {
      return txt.charAt(0).toUpperCase() + txt.substr(1);
    }).trim();
  } else {
    return slug.trim();
  }
}
const defaultDateFormat = "MMMM dd, yyyy, HH:mm:ss";
const COLLECTION_PATH_SEPARATOR = "::";
function stripCollectionPath(path) {
  return segmentsToStrippedPath(fullPathToCollectionSegments(path));
}
function segmentsToStrippedPath(paths) {
  if (paths.length === 1) return paths[0];
  return paths.reduce((a2, b) => `${a2}${COLLECTION_PATH_SEPARATOR}${b}`);
}
function fullPathToCollectionSegments(path) {
  return path.split("/").filter((e2, i) => i % 2 === 0);
}
function serializeRegExp(input) {
  if (!input) return "";
  return input.toString();
}
function hydrateRegExp(input) {
  if (!input) return void 0;
  const fragments = input.match(/\/(.*?)\/([a-z]*)?$/i);
  if (fragments) {
    return new RegExp(fragments[1], fragments[2] || "");
  } else {
    return new RegExp(input, "");
  }
}
function isValidRegExp(input) {
  const fullRegexp = input.match(/\/((?![*+?])(?:[^\r\n[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*])+)\/((?:g(?:im?|mi?)?|i(?:gm?|mg?)?|m(?:gi?|ig?)?)?)/);
  if (fullRegexp) return true;
  const simpleRegexp = input.match(/((?![*+?])(?:[^\r\n[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*])+)/);
  return !!simpleRegexp;
}
function useDebouncedCallback(value, callback, immediate2, t0) {
  const $ = c_1(9);
  const timeoutMs = t0 === void 0 ? 300 : t0;
  const pendingUpdate = React__default.useRef(false);
  let t1;
  if ($[0] !== callback) {
    t1 = () => {
      callback();
      pendingUpdate.current = false;
    };
    $[0] = callback;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const performUpdate = t1;
  const handlerRef = React__default.useRef(void 0);
  let t2;
  if ($[2] !== immediate2 || $[3] !== performUpdate || $[4] !== timeoutMs) {
    t2 = () => {
      pendingUpdate.current = true;
      clearTimeout(handlerRef.current);
      handlerRef.current = setTimeout(performUpdate, timeoutMs);
      return () => {
        if (immediate2) {
          performUpdate();
        }
      };
    };
    $[2] = immediate2;
    $[3] = performUpdate;
    $[4] = timeoutMs;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  let t3;
  if ($[6] !== immediate2 || $[7] !== value) {
    t3 = [immediate2, value];
    $[6] = immediate2;
    $[7] = value;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  React__default.useEffect(t2, t3);
}
function isReferenceProperty(propertyOrBuilder, fields) {
  const resolvedProperty = resolveProperty({
    propertyKey: "ignore",
    // TODO
    propertyOrBuilder,
    propertyConfigs: fields
  });
  if (!resolvedProperty) return null;
  if (resolvedProperty.dataType === "reference") {
    return true;
  }
  if (resolvedProperty.dataType === "array") {
    if (Array.isArray(resolvedProperty.of)) return false;
    else return resolvedProperty.of?.dataType === "reference";
  }
  return false;
}
function getIdIcon(size2) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CircleIcon, { size: size2 });
}
function getIconForWidget(widget, size2) {
  const Icon2 = widget?.Icon ?? CircleIcon;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { size: size2 });
}
function getIconForProperty(property2, size2 = "small", fields = {}) {
  if (isPropertyBuilder(property2)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FunctionsIcon, { size: size2 });
  } else {
    const widget = getFieldConfig(property2, fields);
    return getIconForWidget(widget, size2);
  }
}
function getColorForProperty(property2, fields) {
  if (isPropertyBuilder(property2)) {
    return "#888";
  } else {
    const widget = getFieldConfig(property2, fields);
    return widget?.color ?? "#666";
  }
}
function getPropertyInPath(properties, path) {
  if (typeof properties === "object") {
    if (path in properties) {
      return properties[path];
    }
    if (path.includes(".")) {
      const pathSegments = path.split(".");
      const childProperty = properties[pathSegments[0]];
      if (typeof childProperty === "object" && childProperty.dataType === "map" && childProperty.properties) {
        return getPropertyInPath(childProperty.properties, pathSegments.slice(1).join("."));
      }
    }
  }
  return void 0;
}
function getResolvedPropertyInPath(properties, path) {
  if (typeof properties === "object") {
    if (path in properties) {
      return properties[path];
    }
    if (path.includes(".")) {
      const pathSegments = path.split(".");
      const childProperty = properties[pathSegments[0]];
      if (childProperty.dataType === "map" && childProperty.properties) {
        return getResolvedPropertyInPath(childProperty.properties, pathSegments.slice(1).join("."));
      }
    }
  }
  return void 0;
}
function getBracketNotation(path) {
  return path.replace(/\.([^.]*)/g, "[$1]");
}
function getPropertiesWithPropertiesOrder(properties, propertiesOrder) {
  if (!propertiesOrder) return properties;
  const result = {};
  propertiesOrder.filter(Boolean).forEach((path) => {
    const property2 = getPropertyInPath(properties, path);
    if (typeof property2 === "object" && property2.dataType === "map" && property2.properties) {
      result[path] = {
        ...property2,
        properties: getPropertiesWithPropertiesOrder(property2.properties, property2.propertiesOrder ?? [])
      };
    }
    if (property2) {
      result[path] = property2;
    }
  });
  return result;
}
function getDefaultPropertiesOrder(collection) {
  if (collection.propertiesOrder) return collection.propertiesOrder;
  return [...Object.keys(collection.properties), ...(collection.additionalFields ?? []).map((field) => field.key)];
}
const DEFAULT_PERMISSIONS = {
  read: true,
  edit: true,
  create: true,
  delete: true
};
function resolvePermissions(collection, authController, path, entity) {
  const permission = collection.permissions;
  if (permission === void 0) {
    return DEFAULT_PERMISSIONS;
  } else if (typeof permission === "object") {
    return permission;
  } else if (typeof permission === "function") {
    const pathSegments = fullPathToCollectionSegments(path);
    return permission({
      entity,
      path,
      user: authController.user,
      authController,
      collection,
      pathSegments
    });
  }
  console.error("Permissions:", permission);
  throw Error("New type of permission added and not mapped");
}
function canEditEntity(collection, authController, path, entity) {
  return resolvePermissions(collection, authController, path, entity)?.edit ?? DEFAULT_PERMISSIONS.edit;
}
function canCreateEntity(collection, authController, path, entity) {
  if (collection.collectionGroup) return false;
  return resolvePermissions(collection, authController, path, entity)?.create ?? DEFAULT_PERMISSIONS.create;
}
function canDeleteEntity(collection, authController, path, entity) {
  return resolvePermissions(collection, authController, path, entity)?.delete ?? DEFAULT_PERMISSIONS.delete;
}
const iconSynonyms = {
  abc: "alphabet character font letter symbol text type",
  access_alarm: "clock time",
  access_alarms: "clock time",
  accessibility: "accessible body handicap help human people person user",
  accessibility_new: "accessible arms body handicap help human people person user",
  accessible: "accessibility body handicap help human people person user wheelchair",
  accessible_forward: "accessibility body handicap help human people person wheelchair",
  access_time: "clock time",
  account_balance: "bank bill building card cash coin commerce court credit currency dollars finance money online payment structure temple transaction",
  account_balance_wallet: "bank bill card cash coin commerce credit currency dollars finance money online payment transaction",
  account_box: "avatar face human people person profile square thumbnail user",
  account_circle: "avatar face human people person profile thumbnail user",
  account_tree: "analytics chart connect data diagram flow infographic measure metrics process project sitemap square statistics structure tracking",
  ac_unit: "air cold conditioner freeze snowflake temperature weather winter",
  adb: "android bridge debug",
  add: "+ create item new plus symbol",
  add_alarm: "clock plus time",
  add_alert: "+ active alarm announcement bell callout chime information new notifications notify plus reminder ring sound symbol",
  add_a_photo: "+ camera lens new photography picture plus symbol",
  add_box: "create new plus square symbol",
  add_business: "+ bill building card cash coin commerce company credit currency dollars market money new online payment plus retail shopping storefront symbol",
  add_card: "+ bill cash coin commerce cost credit currency dollars finance money new online payment plus price shopping symbol",
  add_chart: "+ analytics bars data diagram infographic measure metrics new plus statistics symbol tracking",
  add_circle: "+ create new plus",
  add_circle_outline: "+ create new plus",
  add_comment: "+ bubble chat communicate feedback message new plus speech symbol",
  add_ic_call: "+ cell contact device hardware mobile new plus symbol telephone",
  add_link: "attach clip new plus symbol",
  add_location: "+ destination direction gps maps new pin place plus stop symbol",
  add_location_alt: "+ destination direction maps new pin place plus stop symbol",
  add_moderator: "+ certified new plus privacy private protection security shield symbol verified",
  add_photo_alternate: "+ image landscape mountains new photography picture plus symbol",
  add_road: "+ destination direction highway maps new plus stop street symbol traffic",
  add_shopping_cart: "card cash checkout coin commerce credit currency dollars money online payment plus",
  add_task: "+ approve check circle completed increase mark ok plus select tick yes",
  add_to_drive: "+ app backup cloud data files folders gdrive google plus recovery storage",
  add_to_home_screen: "Android add arrow cell device hardware iOS mobile phone tablet to up",
  add_to_photos: "collection image landscape mountains photography picture plus",
  add_to_queue: "+ Android backlog chrome desktop device display hardware iOS lineup mac monitor new plus screen symbol television watch web window",
  adf_scanner: "document feeder machine office",
  adjust: "alter center circles control dot edit filter fix image mix move setting slider sort switch target tune",
  admin_panel_settings: "account avatar certified face human people person privacy private profile protection security shield user verified",
  ad_units: "Android banner cell device hardware iOS mobile notifications phone tablet top",
  agriculture: "automobile cars cultivation farm harvest maps tractor transport travel truck vehicle",
  air: "blowing breeze flow wave weather wind",
  airlines: "airplane airport flight transportation travel trip",
  airline_seat_flat: "bed body business class first human people person rest sleep travel",
  airline_seat_flat_angled: "bed body business class first human people person rest sleep travel",
  airline_seat_individual_suite: "bed body business class first human people person rest sleep travel",
  airline_seat_legroom_extra: "body feet human people person sitting space travel",
  airline_seat_legroom_normal: "body feet human people person sitting space travel",
  airline_seat_legroom_reduced: "body feet human people person sitting space travel",
  airline_seat_recline_extra: "body feet human legroom people person sitting space travel",
  airline_seat_recline_normal: "body extra feet human legroom people person sitting space travel",
  airline_stops: "arrow destination direction layover location maps place transportation travel trip",
  airplanemode_active: "flight flying on signal",
  airplanemode_inactive: "airport disabled enabled flight flying maps offline slash transportation travel",
  airplane_ticket: "airport boarding flight fly maps pass transportation travel",
  airplay: "apple arrow cast connect control desktop device display monitor screen signal television tv",
  airport_shuttle: "automobile bus cars commercial delivery direction maps mini public transportation travel truck van vehicle",
  alarm: "alart bell clock countdown date notification schedule time",
  alarm_add: "+ alart bell clock countdown date new notification plus schedule symbol time",
  alarm_off: "alart bell clock disabled duration enabled notification slash stop timer watch",
  alarm_on: "alart bell checkmark clock disabled duration enabled notification off ready slash start timer watch",
  album: "artist audio bvb cd computer data disk file music play record sound storage track vinyl",
  align_horizontal_center: "alignment format layout lines paragraph rules style text",
  align_horizontal_left: "alignment format layout lines paragraph rules style text",
  align_horizontal_right: "alignment format layout lines paragraph rules style text",
  align_vertical_bottom: "alignment format layout lines paragraph rules style text",
  align_vertical_center: "alignment format layout lines paragraph rules style text",
  align_vertical_top: "alignment format layout lines paragraph rules style text",
  all_inbox: "Inbox delivered delivery email letter message post send",
  all_inclusive: "endless forever infinite infinity loop mobius neverending strip sustainability sustainable",
  all_out: "arrows circle directional expand shape",
  alternate_email: "@ address contact tag",
  alt_route: "alternate alternative arrows direction maps navigation options other routes split symbol",
  analytics: "assessment bar chart data diagram infographic measure metrics statistics tracking",
  anchor: "google logo",
  android: "brand character logo mascot operating system toy",
  animation: "circles film motion movement movie moving sequence video",
  announcement: "! alert attention balloon bubble caution chat comment communicate danger error exclamation feedback important mark message news notification speech symbol warning",
  aod: "Android always device display hardware homescreen iOS mobile phone tablet",
  apartment: "accommodation architecture building city company estate flat home house office places real residence residential shelter units workplace",
  api: "developer development enterprise software",
  app_blocking: "Android applications cancel cell device hardware iOS mobile phone stopped tablet",
  app_registration: "apps edit pencil register",
  approval: "apply approvals approve certificate certification disapproval drive file impression ink mark postage stamp",
  apps: "all applications circles collection components dots grid homescreen icons interface squares ui ux",
  app_settings_alt: "Android applications cell device gear hardware iOS mobile phone tablet",
  app_shortcut: "bookmarked favorite highlight important mobile saved software special star",
  apps_outage: "all applications circles collection components dots grid interface squares ui ux",
  architecture: "art compass design drawing engineering geometric tool",
  archive: "inbox mail store",
  arrow_back: "application components direction interface left navigation previous screen ui ux website",
  arrow_back_ios: "application chevron components direction interface left navigation previous screen ui ux website",
  arrow_back_ios_new: "application chevron components direction interface left navigation previous screen ui ux website",
  arrow_circle_down: "direction navigation",
  arrow_circle_up: "direction navigation",
  arrow_downward: "application components direction interface navigation screen ui ux website",
  arrow_drop_down: "application components direction interface navigation screen ui ux website",
  arrow_drop_down_circle: "application components direction interface navigation screen ui ux website",
  arrow_drop_up: "application components direction interface navigation screen ui ux website",
  arrow_forward: "application arrows components direction interface navigation right screen ui ux website",
  arrow_forward_ios: "application chevron components direction interface navigation next right screen ui ux website",
  arrow_left: "application backstack backward components direction interface navigation previous screen ui ux website",
  arrow_right: "application components continue direction forward interface navigation screen ui ux website",
  arrow_right_alt: "arrows direction east navigation pointing shape",
  arrow_upward: "application components direction interface navigation screen submit ui ux website",
  article: "clarify document file news page paper text writing",
  art_track: "album artist audio display format image insert music photography picture sound tracks",
  aspect_ratio: "expand image monitor resize resolution scale screen square",
  assessment: "analytics bars chart data diagram infographic measure metrics report statistics tracking",
  assignment: "article clipboard document task text writing",
  assignment_ind: "account clipboard document face people person profile task user",
  assignment_late: "! alert announcement attention caution clipboard danger document error exclamation important mark notification symbol task warning",
  assignment_return: "arrow back clipboard document left point retun task",
  assignment_returned: "arrow clipboard document down point task",
  assignment_turned_in: "approve checkmark clipboard complete document done finished ok select task tick validate verified yes",
  assistant: "bubble chat comment communicate feedback message recommendation speech star suggestion twinkle",
  assistant_direction: "destination location maps navigate navigation pin place right stop",
  assistant_photo: "flag recommendation smart star suggestion",
  assured_workload: "compliance confidential federal government regulatory secure sensitive",
  atm: "alphabet automated bill card cart cash character coin commerce credit currency dollars font letter machine money online payment shopping symbol teller text type",
  attach_email: "attachment clip compose envelop letter link message send",
  attach_file: "add item link mail media paperclip",
  attachment: "compose file image item link paperclip",
  attach_money: "bill card cash coin commerce cost credit currency dollars finance online payment price profit sale symbol",
  attractions: "amusement entertainment ferris fun maps park places wheel",
  attribution: "attribute body copyright copywriter human people person",
  audio_file: "document key music note sound track",
  audiotrack: "key music note sound",
  auto_awesome: "adjust editing enhance filter image photography photos setting stars",
  auto_awesome_mosaic: "adjust collage editing enhance filter grid image layout photographs photography photos pictures setting",
  auto_awesome_motion: "adjust animation collage editing enhance filter image live photographs photography photos pictures setting video",
  auto_delete: "bin can clock date garbage remove schedule time trash",
  auto_fix_high: "adjust editing enhance erase magic modify pen stars tool wand",
  auto_fix_normal: "edit erase magic modify stars wand",
  auto_fix_off: "disabled edit enabled erase magic modify on slash stars wand",
  autofps_select: "A alphabet character font frame frequency letter per rate seconds symbol text type",
  auto_graph: "analytics chart data diagram infographic line measure metrics stars statistics tracking",
  auto_mode: "around arrows direction inprogress loading navigation nest refresh renew rotate turn",
  autorenew: "around arrows cached direction inprogress loader loading navigation pending refresh rotate status turn",
  auto_stories: "audiobook flipping pages reading story",
  av_timer: "clock countdown duration minutes seconds stopwatch",
  baby_changing_station: "babies bathroom body children father human infant kids mother newborn people person toddler wc young",
  backpack: "bookbag knapsack storage travel",
  backspace: "arrow cancel clear correct delete erase remove",
  backup: "arrow cloud data drive files folders point storage submit upload",
  backup_table: "drive files folders format layout stack storage",
  badge: "account avatar card certified employee face human identification name people person profile security user work",
  bakery_dining: "bread breakfast brunch croissant food",
  balance: "equal equilibrium equity impartiality justice parity stability. steadiness symmetry",
  balcony: "architecture doors estate home house maps outside place real residence residential stay terrace window",
  ballot: "bullet bulllet election list point poll vote",
  bar_chart: "analytics anlytics data diagram infographic measure metrics statistics tracking",
  batch_prediction: "bulb idea light",
  bathroom: "closet home house place plumbing shower sprinkler wash water wc",
  bathtub: "bathing bathroom clean home hotel human person shower travel",
  battery_alert: "! attention caution cell charge danger error exclamation important mark mobile notification power symbol warning",
  battery_charging_full: "cell charge lightening lightning mobile power thunderbolt",
  battery_full: "cell charge mobile power",
  battery_saver: "+ add charge charging new plus power symbol",
  battery_std: "cell charge mobile plus power standard",
  battery_unknown: "? assistance cell charge help information mark mobile power punctuation question support symbol",
  beach_access: "parasol places summer sunny umbrella",
  bed: "bedroom double full furniture home hotel house king night pillows queen rest size sleep",
  bedroom_baby: "babies children home horse house infant kid newborn rocking toddler young",
  bedroom_child: "children furniture home hotel house kid night pillows rest size sleep twin young",
  bedroom_parent: "double full furniture home hotel house king master night pillows queen rest sizem sleep",
  bedtime: "nightime sleep",
  bedtime_off: "nightime sleep",
  beenhere: "approve archive bookmark checkmark complete done favorite label library reading remember ribbon save select tag tick validate verified yes",
  bento: "box dinner food lunch meal restaurant takeout",
  bike_scooter: "automobile cars maps transportation vehicle vespa",
  biotech: "chemistry laboratory microscope research science technology test",
  blender: "appliance cooking electric juicer kitchen machine vitamix",
  blinds_closed: "cover curtains nest shutter sunshade",
  block: "allowed avoid banned cancel close disable entry exit not prohibited quit remove stop",
  bloodtype: "donate droplet emergency hospital medicine negative positive water",
  bluetooth: "cast connection device network paring streaming symbol wireless",
  bluetooth_audio: "connection device music signal sound symbol",
  bluetooth_connected: "cast connection device network paring streaming symbol wireless",
  bluetooth_disabled: "cast connection device enabled network offline paring slash streaming symbol wireless",
  bluetooth_drive: "automobile cars cast connection device maps paring streaming symbol transportation travel vehicle wireless",
  bluetooth_searching: "connection device network paring symbol wireless",
  blur_circular: "circle dots editing effect enhance filter",
  blur_linear: "dots editing effect enhance filter",
  blur_off: "disabled dots editing effect enabled enhance on slash",
  blur_on: "disabled dots editing effect enabled enhance filter off slash",
  bolt: "electric energy fast flash lightning power thunderbolt",
  book: "blog bookmark favorite label library reading remember ribbon save tag",
  bookmark: "archive favorite follow label library reading remember ribbon save tag",
  bookmark_add: "+ favorite plus remember ribbon save symbol",
  bookmark_added: "approve check complete done favorite remember save select tick validate verified yes",
  bookmark_border: "archive favorite label library outline reading remember ribbon save tag",
  bookmark_remove: "delete favorite minus remember ribbon save subtract",
  bookmarks: "favorite label layers library multiple reading remember ribbon save stack tag",
  book_online: "Android admission appointment cell device event hardware iOS mobile pass phone reservation tablet ticket",
  border_all: "doc editing editor spreadsheet stroke text type writing",
  border_bottom: "doc editing editor spreadsheet stroke text type writing",
  border_clear: "doc editing editor spreadsheet stroke text type writing",
  border_color: "all create doc editing editor marker pencil spreadsheet stroke text type writing",
  border_horizontal: "doc editing editor spreadsheet stroke text type writing",
  border_inner: "doc editing editor spreadsheet stroke text type writing",
  border_left: "doc editing editor spreadsheet stroke text type writing",
  border_outer: "doc editing editor spreadsheet stroke text type writing",
  border_right: "doc editing editor spreadsheet stroke text type writing",
  border_style: "color doc editing editor spreadsheet stroke text type writing",
  border_top: "doc editing editor spreadsheet stroke text type writing",
  border_vertical: "doc editing editor spreadsheet stroke text type writing",
  boy: "body gender human male people person social symbol",
  branding_watermark: "components copyright design emblem format identity interface layout logo screen stamp ui ux website window",
  breakfast_dining: "bakery bread butter food toast",
  brightness_1: "circle control crescent cresent level moon screen",
  brightness_2: "circle control crescent cresent level moon night screen",
  brightness_3: "circle control crescent cresent level moon night screen",
  brightness_4: "circle control crescent cresent dark level moon night screen sun",
  brightness_5: "circle control crescent cresent level moon screen sun",
  brightness_6: "circle control crescent cresent level moon screen sun",
  brightness_7: "circle control crescent cresent level light moon screen sun",
  brightness_auto: "A control display level mobile monitor phone screen",
  brightness_high: "auto control mobile monitor phone",
  brightness_low: "auto control mobile monitor phone",
  brightness_medium: "auto control mobile monitor phone",
  broken_image: "corrupt error landscape mountains photography picture torn",
  browser_not_supported: "disabled enabled internet off on page screen slash website www",
  browser_updated: "Android arrow chrome desktop device display download hardware iOS mac monitor screen web window",
  brunch_dining: "breakfast champagne champaign drink food lunch meal",
  brush: "art design draw editing painting tool",
  bubble_chart: "analytics bars data diagram infographic measure metrics statistics tracking",
  bug_report: "animal file fix insect issue problem testing ticket virus warning",
  build: "adjust fix repair spanner tool wrench",
  build_circle: "adjust fix repair tool wrench",
  bungalow: "architecture cottage estate home house maps place real residence residential stay traveling",
  burst_mode: "image landscape mountains multiple photography picture",
  bus_alert: "! attention automobile cars caution danger error exclamation important maps mark notification symbol transportation vehicle warning",
  business: "address apartment architecture building company estate flat home office place real residence residential shelter structure",
  business_center: "baggage briefcase places purse suitcase work",
  cabin: "architecture camping cottage estate home house log maps place real residence residential stay traveling wood",
  cable: "connection device electronics usb wire",
  cached: "around arrows inprogress loader loading refresh reload renew rotate",
  cake: "baked birthday candles celebration dessert food frosting party pastries pastry pie social sweet",
  calculate: "+ - = calculator count finance math",
  calendar_today: "date event month remember reminder schedule week",
  calendar_view_day: "date event format grid layout month remember reminder schedule today week",
  calendar_view_month: "date event format grid layout schedule today",
  calendar_view_week: "date event format grid layout month schedule today",
  call: "cell contact device hardware mobile talk telephone",
  call_end: "cell contact device hardware mobile talk telephone",
  call_made: "arrow device mobile",
  call_merge: "arrow device mobile",
  call_missed: "arrow device mobile",
  call_missed_outgoing: "arrow device mobile",
  call_received: "arrow device mobile",
  call_split: "arrow device mobile",
  call_to_action: "alert bar components cta design information interface layout message notification screen ui ux website window",
  camera: "album aperture lens photography picture record screenshot shutter",
  camera_alt: "image photography picture",
  camera_enhance: "important lens photography picture quality special star",
  camera_front: "body human lens mobile person phone photography portrait selfie",
  camera_indoor: "architecture building estate filming home house image inside motion nest picture place real residence residential shelter videography",
  camera_outdoor: "architecture building estate filming home house image motion nest outside picture place real residence residential shelter videography",
  camera_rear: "front lens mobile phone photography picture portrait selfie",
  camera_roll: "film image library photography",
  cameraswitch: "arrows flip rotate swap view",
  campaign: "alert announcement loud megaphone microphone notification speaker",
  cancel: "circle close cross disable exit status stop",
  cancel_presentation: "close device exit no quit remove screen share slide stop website window",
  cancel_schedule_send: "email no quit remove share stop x",
  candlestick_chart: "analytics data diagram finance infographic measure metrics statistics tracking",
  card_giftcard: "account balance bill cart cash certificate coin commerce creditcard currency dollars money online payment present shopping",
  card_membership: "bill bookmark cash certificate coin commerce cost creditcard currency dollars finance loyalty money online payment shopping subscription",
  card_travel: "bill cash coin commerce cost creditcard currency dollars finance membership miles money online payment trip",
  carpenter: "building construction cutting handyman repair saw tool",
  car_rental: "automobile cars key maps transportation vehicle",
  car_repair: "automobile cars maps transportation vehicle",
  cases: "baggage briefcase business purse suitcase",
  casino: "dice dots entertainment gamble gambling games luck places",
  cast: "Android airplay chromecast connect desktop device display hardware iOS mac monitor screencast streaming television tv web window wireless",
  cast_connected: "Android airplay chromecast desktop device display hardware iOS mac monitor screencast streaming television tv web window wireless",
  cast_for_education: "Android airplay chrome connect desktop device display hardware iOS learning lessons mac monitor screencast streaming teaching television tv web window wireless",
  category: "categories circle collection items product sort square triangle",
  celebration: "activity birthday event fun party",
  cell_tower: "broadcast casting network signal transmitting wireless",
  cell_wifi: "connection data internet mobile network phone service signal wireless",
  center_focus_strong: "camera image lens photography zoom",
  center_focus_weak: "camera image lens photography zoom",
  chair: "comfort couch decoration furniture home house living lounging loveseat room seating sofa",
  chair_alt: "cahir furniture home house kitchen lounging seating table",
  chalet: "architecture cottage estate home house maps place real residence residential stay traveling",
  change_circle: "around arrows direction navigation rotate",
  change_history: "shape triangle",
  charging_station: "Android battery cell device electric hardware iOS lightning mobile phone tablet thunderbolt",
  chat: "bubble comment communicate feedback message speech talk text",
  chat_bubble: "comment communicate feedback message speech talk text",
  chat_bubble_outline: "comment communicate feedback message speech talk text",
  check: "checkmark complete confirm correct done enter okay purchased select success tick yes",
  check_box: "approved button checkmark component control form ok selected selection square success tick toggle ui yes",
  check_box_outline_blank: "button checkmark component control deselected empty form selection square tick toggle ui",
  check_circle: "approve checkmark complete done download finished ok select success tick upload validate verified yes",
  check_circle_outline: "approve checkmark complete done finished ok select success tick validate verified yes",
  checkroom: "check closet clothes coat hanger",
  chevron_left: "arrows back direction triangle",
  chevron_right: "arrows direction forward triangle",
  child_care: "babies baby children face infant kids newborn toddler young",
  child_friendly: "baby care carriage children infant kid newborn stroller toddler young",
  chrome_reader_mode: "text",
  circle: "bullet button dot full geometry moon period radio",
  circle_notifications: "active alarm alert bell chime notify reminder ring sound",
  class: "archive bookmark category favorite item label library reading remember ribbon save tag",
  clean_hands: "bacteria disinfect germs gesture sanitizer",
  cleaning_services: "dust sweep",
  clear: "allowed back cancel correct cross delete disable erase exit not times",
  clear_all: "delete document erase format lines list notifications wipe",
  close: "allowed cancel cross disable exit not status stop times",
  closed_caption: "accessible alphabet character decoder font language letter media movies subtitles symbol text tv type",
  closed_caption_disabled: "accessible alphabet character decoder enabled font language letter media movies off slash subtitles symbol text tv type",
  closed_caption_off: "accessible alphabet character decoder font language letter media movies outline subtitles symbol text tv type",
  close_fullscreen: "action arrows collapse direction minimize",
  cloud: "connection internet network sky upload weather",
  cloud_circle: "application backup connection drive files folders internet network sky storage upload",
  cloud_done: "application approve backup checkmark complete connection drive files folders internet network ok select sky storage tick upload validate verified yes",
  cloud_download: "application arrow backup connection drive files folders internet network sky storage upload",
  cloud_off: "application backup connection disabled drive enabled files folders internet network offline sky slash storage upload",
  cloud_queue: "connection internet network sky upload",
  cloud_sync: "application around backup connection drive files folders inprogress internet loading network refresh renew rotate sky storage turn upload",
  cloud_upload: "application arrow backup connection download drive files folders internet network sky storage",
  co2: "carbon dioxide gas",
  code: "brackets css developer engineering html parenthesis platform",
  code_off: "brackets css developer disabled enabled engineering html on platform slash",
  coffee: "beverage cup drink mug plate set tea",
  coffee_maker: "appliances beverage cup drink machine mug",
  collections: "album gallery image landscape library mountains photography picture stack",
  collections_bookmark: "album archive favorite gallery label library reading remember ribbon save stack tag",
  colorize: "color dropper extract eye picker pipette tool",
  color_lens: "art paint pallet",
  comment: "bubble chat communicate document feedback message note outline speech",
  comment_bank: "archive bookmark bubble cchat communicate favorite label library message remember ribbon save speech tag",
  comments_disabled: "bubble chat communicate enabled feedback message offline on slash speech",
  commit: "accomplish bind circle dedicate execute line perform pledge",
  commute: "automobile car direction maps public train transportation trip vehicle",
  compare: "adjustment editing edits enhance fix images photography photos scan settings",
  compare_arrows: "collide directional facing left pointing pressure push right together",
  compass_calibration: "connection internet location maps network refresh service signal wifi wireless",
  compress: "arrows collide pressure push together",
  computer: "Android chrome desktop device hardware iOS laptop mac monitor pc web window",
  confirmation_number: "admission entertainment event ticket",
  connected_tv: "Android airplay chrome desktop device display hardware iOS mac monitor screencast streaming television web window wireless",
  connecting_airports: "airplanes flight transportation travel trip",
  connect_without_contact: "communicating distance people signal socialize",
  construction: "build carpenter equipment fix hammer improvement industrial industry repair tools wrench",
  contactless: "applepay bluetooth cash connection connectivity credit device finance payment signal tap transaction wifi wireless",
  contact_mail: "account address avatar communicate email face human information message people person profile user",
  contact_page: "account avatar data document drive face folders human people person profile sheet slide storage user writing",
  contact_phone: "account avatar call communicate face human information message mobile number people person profile user",
  contacts: "account address avatar call cell face human information mobile number people person phone profile user",
  contact_support: "? alert announcement bubble chat comment communicate help information mark message punctuation speech symbol vquestion",
  content_copy: "copy document duplicate file multiple past",
  content_cut: "cut document file past scissors trim",
  content_paste: "clipboard copy cut document file multiple",
  content_paste_go: "clipboard disabled document enabled file slash",
  content_paste_off: "clipboard disabled document enabled file slash",
  content_paste_search: "clipboard document file find trace track",
  contrast: "black editing effect filter grayscale images photography pictures settings white",
  control_camera: "adjust arrows center direction left move right",
  control_point: "+ add circle plus",
  control_point_duplicate: "+ add circle multiple new plus symbol",
  co_present: "arrow co-present presentation screen share slides togather website",
  copy_all: "content cut document file multiple page paper past",
  copyright: "alphabet character circle emblem font legal letter owner symbol text",
  coronavirus: "19 bacteria covid disease germs illness sick social",
  corporate_fare: "architecture building business estate organization place real residence residential shelter",
  cottage: "architecture beach estate home house lake lodge maps place real residence residential stay traveling",
  countertops: "home house kitchen sink table",
  create: "compose editing input item new pencil write writing",
  create_new_folder: "+ add data directory document drive file plus sheet slide storage symbol",
  credit_card: "bill cash charge coin commerce cost creditcard currency dollars finance information money online payment price shopping symbol",
  credit_card_off: "charge commerce cost disabled enabled finance money online payment slash",
  credit_score: "approve bill card cash check coin commerce complete cost currency dollars done finance loan mark money ok online payment select symbol tick validate verified yes",
  crib: "babies baby bassinet bed children cradle infant kid newborn sleeping toddler",
  crop: "adjustments area editing frame images photos rectangle settings size square",
  crop_din: "adjustments area editing frame images photos picture rectangle settings size square",
  crop_free: "adjustments barcode editing focus frame image photos qrcode settings size square zoom",
  crop_landscape: "adjustments area editing frame images photos picture settings size square",
  crop_original: "adjustments area editing frame images photos picture settings size square",
  crop_portrait: "adjustments area editing frame images photos picture rectangle settings size square",
  crop_rotate: "adjustments area arrows editing frame images photos settings size turn",
  crop_square: "adjustments area editing frame images photos rectangle settings size",
  css: "alphabet brackets character code developer engineering font html letter platform symbol text type",
  currency_exchange: "360 around arrows cash coin commerce direction dollars inprogress money pay renew rotate sync turn universal",
  currency_franc: "bill card cash coin commerce cost credit dollars finance money online payment price shopping symbol",
  currency_lira: "bill card cash coin commerce cost credit dollars finance money online payment price shopping symbol",
  currency_pound: "bill card cash coin commerce cost credit dollars finance money online payment price shopping symbol",
  currency_ruble: "bill card cash coin commerce cost credit dollars finance money online payment price shopping symbol",
  currency_rupee: "bill card cash coin commerce cost credit dollars finance money online payment price shopping symbol",
  currency_yen: "bill card cash coin commerce cost credit dollars finance money online payment price shopping symbol",
  currency_yuan: "bill card cash coin commerce cost credit dollars finance money online payment price shopping symbol",
  curtains: "blinds cover nest open shutter sunshade",
  curtains_closed: "blinds cover nest shutter sunshade",
  dangerous: "broken fix no sign stop update warning wrong",
  dark_mode: "application device interface moon night silent theme ui ux website",
  dashboard: "cards format layout rectangle shapes square website",
  dashboard_customize: "cards format layout rectangle shapes square website",
  data_saver_off: "analytics bars chart diagram donut infographic measure metrics ring statistics tracking",
  data_saver_on: "+ add analytics chart diagram infographic measure metrics new plus ring statistics symbol tracking",
  data_thresholding: "hidden privacy thresold",
  data_usage: "analytics chart circle diagram infographic measure metrics statistics tracking",
  date_range: "agenda calendar event month remember reminder schedule time today week",
  deblur: "adjust editing enhance face image lines photography sharpen",
  deck: "chairs furniture garden home house outdoors outside patio social terrace umbrella yard",
  dehaze: "adjust editing enhance image lines photography remove",
  delete: "bin garbage junk recycle remove trashcan",
  delete_forever: "bin cancel exit garbage junk recycle remove trashcan",
  delete_outline: "bin can garbage remove trash",
  delete_sweep: "bin garbage junk recycle remove trashcan",
  density_large: "horizontal lines rules",
  density_medium: "horizontal lines rules",
  density_small: "horizontal lines rules",
  departure_board: "automobile bus cars clock maps public schedule time transportation travel vehicle",
  description: "article bill data document drive file folders invoice item notes page paper sheet slide text writing",
  desktop_access_disabled: "Android apple chrome device display enabled hardware iOS mac monitor offline pc screen slash web window",
  desktop_mac: "Android apple chrome device display hardware iOS monitor pc screen web window",
  desktop_windows: "Android chrome device display hardware iOS mac monitor pc screen television tv web",
  details: "editing enhance image photography sharpen triangle",
  developer_board: "computer development devkit hardware microchip processor",
  developer_board_off: "computer development disabled enabled hardware microchip on processor slash",
  developer_mode: "Android bracket cell code development device engineer hardware iOS mobile phone tablet",
  device_hub: "Android circle computer desktop hardware iOS laptop mobile monitor phone square tablet triangle watch wearable web",
  devices: "Android computer desktop hardware iOS laptop mobile monitor phone tablet watch wearable web",
  devices_other: "Android cell chrome desktop gadget hardware iOS ipad mac mobile monitor phone smartwatch tablet vr wearables window",
  device_thermostat: "celsius fahrenheit temperature thermometer",
  device_unknown: "? Android assistance cell hardware help iOS information mark mobile phone punctuation question support symbol tablet",
  dialer_sip: "alphabet call cell character contact device font hardware initiation internet letter mobile over protocol routing session symbol telephone text type voice",
  dialpad: "buttons call contact device dots mobile numbers phone",
  diamond: "fashion gems jewelry logo retail valuables",
  difference: "compare content copy cut document duplicate file multiple past",
  dining: "cafeteria cutlery diner eating fork room spoon",
  dinner_dining: "breakfast food fork lunch meal restaurant spaghetti utensils",
  directions: "arrow maps naviate right route sign traffic",
  directions_bike: "bicycle human maps person public route transportation",
  directions_boat: "automobile cars ferry maps public transportation vehicle",
  directions_boat_filled: "automobile cars ferry maps public transportation vehicle",
  directions_bus: "automobile cars maps public transportation vehicle",
  directions_bus_filled: "automobile cars maps public transportation vehicle",
  directions_car: "automobile cars maps public transportation vehicle",
  directions_car_filled: "automobile cars maps public transportation vehicle",
  directions_off: "arrow disabled enabled maps right route sign slash traffic",
  directions_railway: "automobile cars maps public train transportation vehicle",
  directions_railway_filled: "automobile cars maps public train transportation vehicle",
  directions_run: "body health human jogging maps people person route running walk",
  directions_subway: "automobile cars maps public rail train transportation vehicle",
  directions_subway_filled: "automobile cars maps public rail train transportation vehicle",
  directions_transit: "automobile cars maps metro public rail subway train transportation vehicle",
  directions_transit_filled: "automobile cars maps public rail subway train transportation vehicle",
  directions_walk: "body human jogging maps people person route run",
  dirty_lens: "camera photography picture splat",
  disabled_by_default: "box cancel close exit no quit remove square stop",
  disc_full: "! alert attention caution cd danger error exclamation important mark music notification storage symbol vinyl warning",
  display_settings: "Android application change chrome desktop details device gear hardware iOS information mac monitor options personal screen service web window",
  dns: "address bars domain information ip list lookup name network server system",
  dock: "Android cell charger charging connector device hardware iOS mobile phone power station tablet",
  document_scanner: "article data drive file folders notes page paper sheet slide text writing",
  do_disturb: "cancel close denied deny remove silence stop",
  do_disturb_alt: "cancel close denied deny remove silence stop",
  do_disturb_off: "cancel close denied deny disabled enabled on remove silence slash stop",
  do_disturb_on: "cancel close denied deny disabled enabled off remove silence slash stop",
  domain: "apartment architecture building business estate home place real residence residential shelter web www",
  domain_add: "+ apartment architecture building business estate home new place plus real residence residential shelter symbol web www",
  domain_disabled: "apartment architecture building business company enabled estate home internet maps office offline on place real residence residential slash website",
  domain_verification: "application approve check complete design desktop done interface internet layout mark ok screen select tick ui ux validate verified website window www yes",
  done: "approve checkmark complete finished ok select success tick validate verified yes",
  done_all: "approve checkmark complete finished layers multiple ok select stack success tick validate verified yes",
  done_outline: "all approve checkmark complete finished ok select success tick validate verified yes",
  do_not_disturb: "cancel close denied deny remove silence stop",
  do_not_disturb_alt: "cancel close denied deny remove silence stop",
  do_not_disturb_off: "cancel close denied deny disabled enabled on remove silence slash stop",
  do_not_disturb_on: "cancel close denied deny disabled enabled off remove silence slash stop",
  do_not_disturb_on_total_silence: "busy mute on quiet total",
  do_not_step: "boot disabled enabled feet foot off on shoe slash sneaker",
  do_not_touch: "disabled enabled fingers gesture hand off on slash",
  donut_large: "analytics chart circle complete data diagram infographic inprogress, measure metrics pie statistics tracking",
  donut_small: "analytics chart circle data diagram infographic inprogress measure metrics pie statistics tracking",
  door_back: "closed doorway entrance exit home house",
  doorbell: "alarm home house ringing",
  door_front: "closed doorway entrance exit home house",
  door_sliding: "automatic doorway double entrance exit glass home house two",
  double_arrow: "arrows chevron direction multiple navigation right",
  downhill_skiing: "athlete athletic body entertainment exercise hobby human people person ski snow social sports travel winter",
  download: "arrow downloads drive install upload",
  download_done: "arrows check downloads drive installed ok tick upload",
  download_for_offline: "arrow circle for install offline upload",
  downloading: "arrow circle downloads install pending progress upload",
  drafts: "document email envelope file letter message read",
  drag_handle: "application components design interface layout lines menu move screen ui ux website window",
  drag_indicator: "application circles components design dots drop interface layout mobile monitor move phone screen shape shift tablet ui ux website window",
  drive_eta: "automobile cars destination direction estimate maps public transportation travel trip vehicle",
  drive_file_move: "arrows data direction document folders right sheet side slide storage",
  drive_file_rename_outline: "compose create draft editing input pencil write writing",
  drive_folder_upload: "arrow data document file sheet slide storage",
  dry: "air bathroom dryer fingers gesture hand wc",
  dry_cleaning: "hanger hotel laundry places service towel",
  duo: "call chat conference device video",
  dvr: "Android audio chrome computer desktop device display electronic hardware iOS laptop list mac monitor recorder screen tv video web window",
  dynamic_feed: "layer live multiple post refresh update",
  dynamic_form: "code electric fast lightning lists questionnaire thunderbolt",
  earbuds: "accessory audio earphone headphone listen music sound",
  earbuds_battery: "accessory audio charging earphone headphone listen music sound",
  east: "arrow directional maps navigation right",
  edgesensor_high: "Android cell device hardware iOS mobile move phone sensitivity tablet vibrate",
  edgesensor_low: "Android cell device hardware iOS mobile move phone sensitivity tablet vibrate",
  edit: "compose create editing input new pencil write writing",
  edit_attributes: "approve attribution check complete done mark ok select tick validate verified yes",
  edit_location: "destination direction gps maps pencil pin place stop write",
  edit_location_alt: "pencil pin",
  edit_notifications: "active alarm alert bell chime compose create draft editing input new notify pencil reminder ring sound write writing",
  edit_off: "compose create disabled draft editing enabled input new offline on pencil slash write writing",
  edit_road: "destination direction highway maps pencil street traffic",
  egg: "breakfast brunch food",
  egg_alt: "breakfast brunch food",
  eject: "arrow disc drive dvd player remove triangle up usb",
  elderly: "body cane human old people person senior",
  elderly_woman: "body cane female gender girl human lady old people person senior social symbol women",
  electrical_services: "charge cord plug power wire",
  electric_bike: "automobile cars electricity maps scooter transportation travel vehicle vespa",
  electric_bolt: "energy fast lightning nest thunderbolt",
  electric_car: "automobile cars electricity maps transportation travel vehicle",
  electric_meter: "energy fast lightning measure nest thunderbolt usage voltage volts",
  electric_moped: "automobile bike cars maps scooter transportation travel vehicle vespa",
  electric_rickshaw: "automobile cars india maps transportation truck vehicle",
  electric_scooter: "automobile bike cars maps transportation vehicle vespa",
  elevator: "body down human people person up",
  email: "envelope letter message note post receive send write",
  e_mobiledata: "alphabet font letter text type",
  emoji_emotions: "emoticon expressions face feelings glad happiness happy like mood person pleased smiley smiling social survey",
  emoji_events: "achievement award chalice champion cup first prize reward sport trophy winner",
  emoji_food_beverage: "coffee cup dring drink mug plate set tea",
  emoji_nature: "animal bee daisy flower honey insect ladybug petals spring summer",
  emoji_objects: "creative idea lamp lightbulb solution thinking",
  emoji_people: "arm body greeting human person social wave waving",
  emoji_symbols: "ampersand character hieroglyph music note percent sign",
  emoji_transportation: "architecture automobile building cars commute company direction estate maps office place public real residence residential shelter travel vehicle",
  energy_savings_leaf: "eco leaves nest usage",
  engineering: "body cogs cogwheel construction fixing gears hat helmet human maintenance people person setting worker",
  enhanced_encryption: "+ add locked new password plus privacy private protection safety secure security symbol",
  equalizer: "adjustment analytics chart data graph measure metrics music noise sound static statistics tracking volume",
  error: "! alert announcement attention caution circle danger exclamation feedback important mark notification problem symbol warning",
  error_outline: "! alert announcement attention caution circle danger exclamation feedback important mark notification problem symbol warning",
  escalator: "down staircase up",
  escalator_warning: "body child human kid parent people person",
  euro: "bill card cash coin commerce cost credit currency dollars euros finance money online payment price profit shopping symbol",
  euro_symbol: "bill card cash coin commerce cost credit currency dollars finance money online payment price profit",
  event: "agenda calendar date item mark month range remember reminder today week",
  event_available: "agenda approve calendar check complete done item mark ok schedule select tick time validate verified yes",
  event_busy: "agenda calendar cancel close date exit item no remove schedule stop time unavailable",
  event_note: "agenda calendar date item schedule text time writing",
  event_repeat: "around calendar date day inprogress loading month refresh renew rotate schedule turn",
  event_seat: "assigned bench chair furniture reservation row section sit",
  ev_station: "automobile cars charge charging electricity filling fuel gasoline maps places power station transportation vehicle",
  exit_to_app: "application arrow back components design export interface layout leave login logout mobile monitor move output phone pointing quit register right screen signin signout signup tablet ux website window",
  expand: "arrows compress enlarge grow move push together",
  expand_circle_down: "arrows chevron collapse direction expandable list more",
  expand_less: "arrows chevron collapse direction expandable list up",
  expand_more: "arrows chevron collapse direction down expandable list",
  explicit: "adult alphabet character content font language letter media movies music parent rating supervision symbol text type",
  explore: "compass destination direction east location maps needle north south travel west",
  explore_off: "compass destination direction disabled east enabled location maps needle north slash south travel west",
  exposure: "add brightness contrast editing effect image minus photography picture plus settings subtract",
  extension: "add-ons app extended game item jigsaw piece plugin puzzle shape",
  extension_off: "disabled enabled extended jigsaw piece puzzle shape slash",
  face: "account avatar emoji eyes human login logout people person profile recognition security social thumbnail unlock user",
  face_retouching_natural: "editing effect emoji emotion faces image photography settings star tag",
  face_retouching_off: "disabled editing effect emoji emotion enabled faces image natural photography settings slash tag",
  fact_check: "approve complete done list mark ok select tick validate verified yes",
  factory: "industry manufacturing warehouse",
  family_restroom: "bathroom children father kids mother parents wc",
  fastfood: "drink hamburger maps meal places",
  fast_forward: "control ff media music play speed time tv video",
  fast_rewind: "back control media music play speed time tv video",
  favorite: "appreciate health heart like love remember save shape success",
  favorite_border: "health heart like love outline remember save shape success",
  fax: "machine office phone send",
  featured_play_list: "audio collection highlighted item music playlist recommended",
  featured_video: "advertisement advertisment highlighted item play recommended watch,advertised",
  feed: "article headline information newspaper public social timeline",
  feedback: "! alert announcement attention bubble caution chat comment communicate danger error exclamation important mark message notification speech symbol warning",
  female: "gender girl lady social symbol woman women",
  fence: "backyard barrier boundaries boundary home house protection",
  festival: "circus event local maps places tent tour travel",
  fiber_dvr: "alphabet character digital electronics font letter network recorder symbol text tv type video",
  fiber_manual_record: "circle dot play watch",
  fiber_new: "alphabet character font letter network symbol text type",
  fiber_pin: "alphabet character font letter network symbol text type",
  fiber_smart_record: "circle dot play watch",
  file_copy: "bill clone content cut document duplicate invoice item multiple page past",
  file_download: "arrows downloads drive export install upload",
  file_download_done: "arrows check downloads drive installed tick upload",
  file_download_off: "arrow disabled drive enabled export install on save slash upload",
  file_open: "arrow document drive left page paper",
  file_present: "clip data document drive folders note paper reminder sheet slide storage writing",
  file_upload: "arrows download drive export",
  filter: "editing effect image landscape mountains photography picture settings",
  filter_1: "digit editing effect images multiple number photography pictures settings stack symbol",
  filter_2: "digit editing effect images multiple number photography pictures settings stack symbol",
  filter_3: "digit editing effect images multiple number photography pictures settings stack symbol",
  filter_4: "digit editing effect images multiple number photography pictures settings stack symbol",
  filter_5: "digit editing effect images multiple number photography pictures settings stack symbol",
  filter_6: "digit editing effect images multiple number photography pictures settings stack symbol",
  filter_7: "digit editing effect images multiple number photography pictures settings stack symbol",
  filter_8: "digit editing effect images multiple number photography pictures settings stack symbol",
  filter_9: "digit editing effect images multiple number photography pictures settings stack symbol",
  filter_9_plus: "+ digit editing effect images multiple number photography pictures settings stack symbol",
  filter_alt: "edit funnel options refine sift",
  filter_alt_off: "[offline] disabled edit funnel options refine sift slash",
  filter_b_and_w: "black contrast editing effect grayscale images photography pictures settings white",
  filter_center_focus: "camera dot edit image photography picture",
  filter_drama: "camera cloud editing effect image photography picture sky",
  filter_frames: "boarders border camera center editing effect filters focus image options photography picture",
  filter_hdr: "camera editing effect image mountains photography picture",
  filter_list: "lines organize sort",
  filter_list_off: "[offline] alt disabled edit options refine sift slash",
  filter_none: "multiple stack",
  filter_tilt_shift: "blur center editing effect focus images photography pictures",
  filter_vintage: "editing effect flower images photography pictures",
  find_in_page: "data document drive file folders glass look magnifying paper search see sheet slide writing",
  find_replace: "around arrows glass inprogress loading look magnifying refresh renew rotate search see",
  fingerprint: "biometrics identification identity reader thumbprint touchid verification",
  fire_extinguisher: "emergency water",
  fireplace: "chimney flame home house living pit room warm winter",
  first_page: "arrow back chevron left rewind",
  fitness_center: "athlete dumbbell exercise gym health hobby places sport weights workout",
  fit_screen: "enlarge format layout reduce scale size",
  flag: "country goal mark nation report start",
  flag_circle: "country goal mark nation report round start",
  flaky: "approve check close complete contrast done exit mark no ok options select stop tick verified yes",
  flare: "bright editing effect images lensflare light photography pictures shine sparkle star sun",
  flash_auto: "camera electric fast lightning thunderbolt",
  flashlight_off: "disabled enabled on slash",
  flashlight_on: "disabled enabled off slash",
  flash_off: "camera disabled electric enabled fast lightning on slash thunderbolt",
  flash_on: "camera disabled electric enabled fast lightning off slash thunderbolt",
  flatware: "cafeteria cutlery diner dining eating fork room spoon",
  flight: "airplane airport flying transportation travel trip",
  flight_class: "airplane business first seat transportation travel trip window",
  flight_land: "airplane airport arrival arriving flying landing transportation travel",
  flight_takeoff: "airplane airport departed departing flying landing transportation travel",
  flip: "editing image orientation scanning",
  flip_camera_android: "center editing front image mobile orientation rear reverse rotate turn",
  flip_camera_ios: "android editing front image mobile orientation rear reverse rotate turn",
  flip_to_back: "arrangement format front layout move order sort",
  flip_to_front: "arrangement back format layout move order sort",
  flutter_dash: "bird mascot",
  fmd_bad: "! alert attention caution danger destination direction error exclamation important location maps mark notification pin place symbol warning",
  fmd_good: "destination direction location maps pin place stop",
  folder: "data directory document drive file folders sheet slide storage",
  folder_delete: "bin can data document drive file folders garbage remove sheet slide storage trash",
  folder_off: "[online] data disabled document drive enabled file folders sheet slash slide storage",
  folder_open: "data directory document drive file folders sheet slide storage",
  folder_shared: "account collaboration data directory document drive face human people person profile sheet slide storage team user",
  folder_special: "bookmark data directory document drive favorite file highlight important marked saved shape sheet slide star storage",
  folder_zip: "compress data document drive file folders open sheet slide storage",
  follow_the_signs: "arrow body directional human people person right social",
  font_download: "A alphabet character letter square symbol text type",
  font_download_off: "alphabet character disabled enabled letter slash square symbol text type",
  food_bank: "architecture building charity eat estate fork house knife meal place real residence residential shelter utensils",
  forest: "jungle nature plantation plants trees woodland",
  fork_left: "arrows directions maps navigation path route sign traffic",
  fork_right: "arrows directions maps navigation path route sign traffic",
  format_align_center: "alignment doc editing editor lines spreadsheet text type writing",
  format_align_justify: "alignment density doc editing editor extra lines small spreadsheet text type writing",
  format_align_left: "alignment doc editing editor lines spreadsheet text type writing",
  format_align_right: "alignment doc editing editor lines spreadsheet text type writing",
  format_bold: "B alphabet character doc editing editor font letter spreadsheet styles symbol text type writing",
  format_clear: "T alphabet character disabled doc editing editor enabled font letter off slash spreadsheet style symbol text type writing",
  format_color_fill: "bucket doc editing editor paint spreadsheet style text type writing",
  format_color_reset: "clear disabled doc droplet editing editor enabled fill liquid off on paint slash spreadsheet style text type water writing",
  format_color_text: "doc editing editor fill paint spreadsheet style type writing",
  format_indent_decrease: "alignment doc editing editor indentation paragraph spreadsheet text type writing",
  format_indent_increase: "alignment doc editing editor indentation paragraph spreadsheet text type writing",
  format_italic: "alphabet character doc editing editor font letter spreadsheet style symbol text type writing",
  format_line_spacing: "alignment doc editing editor spreadsheet text type writing",
  format_list_bulleted: "alignment doc editing editor notes spreadsheet task text todo type writing",
  format_list_numbered: "alignment digit doc editing editor notes spreadsheet symbol task text todo type writing",
  format_list_numbered_rtl: "alignment digit doc editing editor notes spreadsheet symbol task text todo type writing",
  format_overline: "alphabet character doc editing editor font letter spreadsheet style symbol text type under writing",
  format_paint: "brush color doc editing editor fill paintroller spreadsheet style text type writing",
  format_quote: "doc editing editor quotation spreadsheet text type writing",
  format_shapes: "alphabet character color doc editing editor fill font letter paint spreadsheet style symbol text type writing",
  format_size: "alphabet character color doc editing editor fill font letter paint spreadsheet style symbol text type writing",
  format_strikethrough: "alphabet character doc editing editor font letter spreadsheet style symbol text type writing",
  format_textdirection_l_to_r: "alignment doc editing editor ltr paragraph spreadsheet type writing",
  format_textdirection_r_to_l: "alignment doc editing editor paragraph rtl spreadsheet type writing",
  format_underlined: "alphabet character doc editing editor font letter spreadsheet style symbol text type writing",
  forum: "bubble chat comment communicate community conversation feedback hub messages speech talk",
  forward: "arrow mail message playback right sent",
  forward_10: "arrow circle controls digit fast music number play rotate seconds speed symbol time video",
  forward_30: "arrow circle controls digit fast music number rotate seconds speed symbol time video",
  forward_5: "10 arrow circle controls digit fast music number rotate seconds speed symbol time video",
  forward_to_inbox: "arrow email envelop letter message send",
  foundation: "architecture base basis building construction estate home house real residential",
  free_breakfast: "beverage cafe coffee cup drink mug tea",
  fullscreen: "adjust application components interface size ui ux view website",
  fullscreen_exit: "adjust application components interface size ui ux view website",
  functions: "average calculate count doc editing editor math sigma spreadsheet style sum text type writing",
  gamepad: "buttons console controller device gaming playstation video",
  games: "adjust arrows controller direction dpad gaming left move nintendo playstation right xbox",
  garage: "automobile automotive cars direction maps transportation travel vehicle",
  gas_meter: "droplet energy measure nest usage water",
  gavel: "agreement contract court document government hammer judge law mallet official police rules terms",
  gesture: "drawing finger gestures hand line motion",
  get_app: "arrows downloads export install play pointing retrieve upload",
  gif: "alphabet animated animation bitmap character font format graphics interchange letter symbol text type",
  gif_box: "alphabet animated animation bitmap character font format graphics interchange letter symbol text type",
  girl: "body female gender human lady people person social symbol woman women",
  gite: "architecture estate home hostel house maps place real residence residential stay traveling",
  g_mobiledata: "alphabet character font letter network service symbol text type",
  golf_course: "athlete athletic ball club entertainment flag golfer golfing hobby hole places putt sports",
  gpp_bad: "cancel certified close error exit no privacy private protection remove security shield sim stop verified",
  gpp_good: "certified check ok pass security shield sim tick",
  gpp_maybe: "! alert attention caution certified danger error exclamation important mark notification privacy private protection security shield sim symbol verified warning",
  gps_fixed: "destination direction location maps pin place pointer stop tracking",
  gps_not_fixed: "destination direction disabled enabled fixed location maps not off online place pointer slash tracking",
  gps_off: "destination direction disabled enabled fixed location maps not offline place pointer slash tracking",
  grade: "achievement important likes marked rated rating reward saved shape special star",
  gradient: "color editing effect filter images photography pictures",
  grading: "approve check complete document done feedback grade mark ok reviewed select tick validate verified writing yes",
  grain: "dots editing effect filter images photography pictures",
  graphic_eq: "audio equalizer music recording sound voice",
  grass: "backyard fodder ground home lawn plant turf",
  grid_goldenratio: "layout lines space",
  grid_off: "collage disabled enabled image layout on slash view",
  grid_on: "collage disabled enabled image layout off sheet slash view",
  grid_view: "application blocks components dashboard design interface layout screen square tiles ui ux website window",
  group: "accounts committee face family friends humans network people persons profiles social team users",
  group_add: "accounts committee face family friends humans increase more network people persons plus profiles social team users",
  group_remove: "accounts committee face family friends humans network people persons profiles social team users",
  groups: "body club collaboration crowd gathering human meeting people person social teams",
  group_work: "alliance circle collaboration film partnership reel teamwork together",
  g_translate: "emblem google language logo mark speaking speech translator words",
  hail: "body human people person pick public stop taxi transportation",
  handyman: "build construction fix hammer repair screwdriver tools",
  hardware: "break construction hammer nail repair tool",
  hd: "alphabet character definition display font high letter movies quality resolution screen symbol text tv type video",
  hdr_auto: "A alphabet camera character circle dynamic font high letter photo range symbol text type",
  hdr_auto_select: "+ A alphabet camera character circle dynamic font high letter photo range symbol text type",
  hdr_enhanced_select: "add alphabet character dynamic font high letter plus range symbol text type",
  hdr_off: "alphabet character disabled dynamic enabled enhance font high letter range select slash symbol text type",
  hdr_off_select: "alphabet camera character circle disabled dynamic enabled font high letter photo range slash symbol text type",
  hdr_on: "add alphabet character dynamic enhance font high letter plus range select symbol text type",
  hdr_on_select: "+ alphabet camera character circle dynamic font high letter photo range symbol text type",
  hdr_plus: "+ add alphabet character circle dynamic enhance font high letter range select symbol text type",
  hdr_strong: "circles dots dynamic enhance high range",
  hdr_weak: "circles dots dynamic enhance high range",
  headphones: "accessory audio device earphone headset listen music sound",
  headphones_battery: "accessory audio charging device earphone headset listen music sound",
  headset: "accessory audio device earbuds earmuffs earphone headphones listen music sound",
  headset_mic: "accessory audio chat device earphone headphones listen music sound talk",
  headset_off: "accessory audio chat device disabled earphone enabled headphones listen mic music slash sound talk",
  healing: "bandage bandaid editing emergency fix health hospital image medicine",
  health_and_safety: "+ add certified plus privacy private protection security shield symbol verified",
  hearing: "accessibility accessible aid handicap help impaired listen sound volume",
  hearing_disabled: "accessibility accessible aid enabled handicap help impaired listen off on slash sound volume",
  heart_broken: "break core crush health nucleus split",
  heat_pump: "air conditioner cool energy furnance nest usage",
  height: "arrows color doc down editing editor fill format paint resize spreadsheet stretch style text type up writing",
  help: "? alert announcement assistance circle information mark punctuation question shape support symbol",
  help_center: "? assistance information mark punctuation question support symbol",
  help_outline: "? alert announcement assistance circle information mark punctuation question shape support symbol",
  hevc: "alphabet character coding efficiency font high letter symbol text type video",
  hexagon: "shape sides six",
  hide_image: "disabled enabled landscape mountains off on photography picture slash",
  hide_source: "circle disabled enabled offline on shape slash",
  highlight: "color doc editing editor emphasize fill flashlight format marker paint spreadsheet style text type writing",
  highlight_off: "cancel circle clear click close delete disable exit focus no quit remove stop target times",
  high_quality: "alphabet character definition display font hq letter movies resolution screen symbol text tv type",
  hiking: "backpacking bag climbing duffle mountain social sports stick trail travel walking",
  history: "arrow backwards clock date refresh renew reverse revert rotate schedule time turn undo",
  history_edu: "document education feather letter paper pen quill school tools write writing",
  history_toggle_off: "clock date schedule time",
  hls: "alphabet character developer engineering font letter platform symbol text type",
  hls_off: "[offline] alphabet character developer disabled enabled engineering font letter platform slash symbol text type",
  h_mobiledata: "alphabet character font letter network service symbol text type",
  holiday_village: "architecture beach camping cottage estate home house lake lodge maps place real residence residential stay traveling vacation",
  home: "address application--house architecture building components design estate homepage interface layout place real residence residential screen shelter structure unit ux website window",
  home_max: "device gadget hardware internet iot nest smart things",
  home_mini: "Internet device gadget hardware iot nest smart things",
  home_repair_service: "equipment fix kit mechanic repairing toolbox tools workshop",
  home_work: "architecture building estate house office place real residence residential shelter",
  horizontal_rule: "gmail line novitas",
  horizontal_split: "bars format layout lines stacked",
  hotel: "bed body human people person sleep stay travel trip",
  hot_tub: "bathing bathroom bathtub hotel human jacuzzi person shower spa steam travel water",
  hourglass_bottom: "countdown half loading minutes time waiting",
  hourglass_disabled: "clock countdown empty enabled loading minutes off on slash time waiting",
  hourglass_empty: "countdown loading minutes start time waiting",
  hourglass_full: "countdown loading minutes time waiting",
  hourglass_top: "countdown half loading minutes time waiting",
  house: "architecture building estate family homepage places real residence residential shelter",
  houseboat: "architecture beach estate floating home maps place real residence residential sea stay traveling vacation",
  house_siding: "architecture building construction estate exterior facade home real residential",
  how_to_reg: "approve ballot check complete done election mark ok poll register registration select tick to validate verified vote yes",
  how_to_vote: "ballot election poll",
  h_plus_mobiledata: "+ alphabet character font letter network service symbol text type",
  html: "alphabet brackets character code css developer engineering font letter platform symbol text type",
  http: "alphabet character font internet letter network symbol text transfer type url website",
  https: "connection encrypt internet key locked network password privacy private protection safety secure security ssl web",
  hub: "center connection core focal network nucleus point topology",
  hvac: "air conditioning heating ventilation",
  icecream: "dessert food snack",
  ice_skating: "athlete athletic entertainment exercise hobby shoe skates social sports travel",
  image: "disabled enabled frame hide landscape mountains off on photography picture slash",
  image_aspect_ratio: "photography picture rectangle square",
  image_not_supported: "disabled enabled landscape mountains off on photography picture slash",
  image_search: "find glass landscape look magnifying mountains photography picture see",
  imagesearch_roller: "art paint",
  important_devices: "Android cell computer desktop hardware iOS mobile monitor phone star tablet web",
  import_contacts: "address book friends information magazine open",
  import_export: "arrows direction down explort up",
  inbox: "archive email incoming message",
  indeterminate_check_box: "application button components control design form interface minus screen selected selection square toggle ui undetermined ux website",
  info: "about alert announcement announcment assistance bubble circle details help information service support",
  input: "arrow box download login move right",
  insert_chart: "analytics barchart bars data diagram infographic measure metrics statistics tracking",
  insert_chart_outlined: "analytics bars data diagram infographic measure metrics statistics tracking",
  insert_comment: "add bubble chat feedback message",
  insert_drive_file: "bill document format invoice item sheet slide",
  insert_emoticon: "account emoji face happy human like people person profile sentiment smiley user",
  insert_invitation: "agenda calendar date event mark month range remember reminder today week",
  insert_link: "add anchor attach clip file mail media",
  insert_page_break: "document file paper",
  insert_photo: "image landscape mountains photography picture wallpaper",
  insights: "analytics bars chart data diagram infographic measure metrics stars statistics tracking",
  install_desktop: "Android chrome device display fix hardware iOS mac monitor place pwa screen web window",
  install_mobile: "Android cell device hardware iOS phone pwa tablet",
  integration_instructions: "brackets clipboard code css developer document engineering html platform",
  interests: "circle heart shapes social square triangle",
  interpreter_mode: "language microphone person speaking symbol",
  inventory: "archive box buy check clipboard document e-commerce file list organize packages product purchase shop stock store supply",
  invert_colors: "droplet editing hue inverted liquid palette tone water",
  invert_colors_off: "disabled droplet enabled hue inverted liquid offline opacity palette slash tone water",
  ios_share: "arrows button direction export internet link send sharing social up website",
  iron: "appliance clothes electric ironing machine object",
  iso: "add editing effect image minus photography picture plus sensor shutter speed subtract",
  javascript: "alphabet brackets character code css developer engineering font html letter platform symbol text type",
  join_full: "circle combine command left outter right sql",
  join_inner: "circle command matching sql values",
  join_left: "circle command matching sql values",
  join_right: "circle command matching sql values",
  kayaking: "athlete athletic body canoe entertainment exercise hobby human lake paddle paddling people person rafting river row social sports summer travel water",
  key: "blackout password restricted secret unlock",
  keyboard: "computer device hardware input keypad letter office text type",
  keyboard_alt: "computer device hardware input keypad letter office text type",
  keyboard_arrow_down: "arrows chevron open",
  keyboard_arrow_left: "arrows chevron",
  keyboard_arrow_right: "arrows chevron open start",
  keyboard_arrow_up: "arrows chevron submit",
  keyboard_backspace: "arrow left",
  keyboard_capslock: "arrow up",
  keyboard_command_key: "button command control key",
  keyboard_control_key: "control key",
  keyboard_double_arrow_down: "arrows direction multiple navigation",
  keyboard_double_arrow_left: "arrows direction multiple navigation",
  keyboard_double_arrow_right: "arrows direction multiple navigation",
  keyboard_double_arrow_up: "arrows direction multiple navigation",
  keyboard_hide: "arrow computer device down hardware input keypad text",
  keyboard_option_key: "alt key modifier",
  keyboard_return: "arrow back left",
  keyboard_tab: "arrow next right",
  keyboard_voice: "microphone noise recorder speaker",
  key_off: "[offline] disabled enabled on password slash unlock",
  king_bed: "bedroom double furniture home hotel house night pillows queen rest sleep",
  kitchen: "appliance cabinet cold food freezer fridge home house ice places refrigerator storage",
  kitesurfing: "athlete athletic beach body entertainment exercise hobby human people person social sports travel water",
  label: "badge favorite indent item library mail remember save stamp sticker tag",
  label_important: "badge favorite important. indent item library mail remember save stamp sticker tag wing",
  label_off: "disabled enabled favorite indent library mail on remember save slash stamp sticker tag wing",
  lan: "computer connection data internet network service",
  landscape: "image mountains nature photography picture",
  language: "country earth globe i18n internet l10n planet website world www",
  laptop: "Android chrome computer connect desktop device display hardware iOS link mac monitor smart tv web windows",
  laptop_chromebook: "Android chromebook device display hardware iOS mac monitor screen web window",
  laptop_mac: "Android apple chrome device display hardware iOS monitor screen web window",
  laptop_windows: "Android chrome device display hardware iOS mac monitor screen web",
  last_page: "application arrow chevron components end forward interface right screen ui ux website",
  launch: "application arrow box components core interface internal new open screen ui ux website window",
  layers: "arrange disabled enabled interaction maps off overlay pages slash stack",
  layers_clear: "arrange delete disabled enabled interaction maps off overlay pages slash",
  leaderboard: "analytics bars chart data diagram infographic measure metrics statistics tracking",
  leak_add: "connection data link network service signals synce wireless",
  leak_remove: "connection data disabled enabled link network offline service signals slash synce wireless",
  legend_toggle: "analytics chart data diagram infographic measure metrics monitoring stackdriver statistics tracking",
  lens: "circle full geometry moon",
  lens_blur: "camera dim dot effect foggy fuzzy image photo soften",
  library_add: "+ collection layers multiple music new plus save stacked symbol video",
  library_add_check: "approve collection complete done layers mark multiple music ok select stacked tick validate verified video yes",
  library_books: "add album audio collection reading",
  library_music: "add album audio collection song sounds",
  light: "bulb ceiling hanging inside interior lamp lighting pendent room",
  lightbulb: "alert announcement idea information learning mode",
  lightbulb_circle: "alert announcement idea information",
  light_mode: "brightness day device lighting morning mornng sky sunny",
  linear_scale: "application components design interface layout measure menu screen slider ui ux website window",
  line_axis: "dash horizontal stroke vertical",
  line_style: "dash dotted editor rule spacing",
  line_weight: "editor height size spacing style thickness",
  link: "anchor chain clip connection external hyperlink linked links multimedia unlisted url",
  linked_camera: "connection lens network photography picture signals sync wireless",
  link_off: "anchor attached chain clip connection disabled enabled linked links multimedia slash unlink url",
  liquor: "alcohol bar bottle club cocktail drink food party store wine",
  list: "editor file format index menu options playlist task todo",
  list_alt: "box contained editor format lines reorder sheet stacked task title todo",
  live_help: "? alert announcement assistance bubble chat comment communicate faq information mark message punctuation question speech support symbol",
  live_tv: "Android antennas chrome desktop device hardware iOS mac monitor movie play stream television web window",
  living: "chair comfort couch decoration furniture home house lounging loveseat room seating sofa",
  local_activity: "event star things ticket",
  local_airport: "airplane flight flying transportation travel trip",
  local_atm: "bill card cart cash coin commerce credit currency dollars financial money online payment price profit shopping symbol",
  local_bar: "alcohol bottle club cocktail drink food liquor martini wine",
  local_cafe: "bottle coffee cup drink food mug restaurant tea",
  local_car_wash: "automobile cars maps transportation travel vehicle",
  local_convenience_store: "-- 24 bill building business card cash coin commerce company credit currency dollars maps market money new online payment plus shopping storefront symbol",
  local_dining: "cutlery eat food fork knife meal restaurant spoon",
  local_drink: "cup droplet glass liquid park water",
  local_fire_department: "911 firefighter flame hot",
  local_florist: "flower shop",
  local_gas_station: "auto car filling fuel gasoline oil station vehicle",
  local_grocery_store: "market shop",
  local_hospital: "911 aid cross doctor emergency first health medical medicine plus",
  local_hotel: "bed body human people person sleep stay travel trip",
  local_laundry_service: "cleaning clothing dryer hotel washer",
  local_library: "book community learning person read",
  local_mall: "bill building business buy card cart cash coin commerce credit currency dollars handbag money online payment shopping storefront",
  local_offer: "deal discount price shopping store tag",
  local_parking: "alphabet auto car character font garage letter symbol text type vehicle",
  local_pharmacy: "911 aid cross emergency first food hospital medicine places",
  local_phone: "booth call telecommunication",
  local_pizza: "drink fastfood meal",
  local_police: "911 badge law officer protection security shield",
  local_post_office: "delivery email envelop letter message package parcel postal send stamp",
  local_printshop: "draft fax ink machine office paper printer send",
  local_see: "camera lens photography picture",
  local_shipping: "automobile cars delivery letter mail maps office package parcel postal semi send shopping stamp transportation truck vehicle",
  local_taxi: "automobile cab call cars direction lyft maps public transportation uber vehicle yellow",
  location_city: "apartments architecture buildings business company estate home landscape place real residence residential shelter town urban",
  location_disabled: "destination direction enabled maps off pin place pointer slash stop tracking",
  location_off: "destination direction disabled enabled gps maps pin place room slash stop",
  location_on: "destination direction disabled enabled gps maps off pin place room slash stop",
  location_searching: "destination direction maps pin place pointer stop tracking",
  lock: "connection key locked logout padlock password privacy private protection safety secure security signout",
  lock_clock: "date locked password privacy private protection safety schedule secure security time",
  lock_open: "connection key login padlock password privacy private protection register safety secure security signin signup unlocked",
  lock_reset: "around inprogress loading locked password privacy private protection refresh renew rotate safety secure security turn",
  login: "access application arrow components design enter interface left screen ui ux website",
  logo_dev: "dev.to",
  logout: "application arrow components design exit interface leave login right screen ui ux website",
  looks: "circle half rainbow",
  looks_3: "digit numbers square symbol",
  looks_4: "digit numbers square symbol",
  looks_5: "digit numbers square symbol",
  looks_6: "digit numbers square symbol",
  looks_one: "1 digit numbers square symbol",
  looks_two: "2 digit numbers square symbol",
  loop: "around arrows direction inprogress loader loading music navigation refresh renew repeat rotate turn",
  loupe: "+ add details focus glass magnifying new plus symbol",
  low_priority: "arrange arrow backward bottom list move order task todo",
  loyalty: "badge card credit heart love membership miles points program sale subscription tag travel trip",
  lte_mobiledata: "alphabet character font internet letter network speed symbol text type wifi wireless",
  lte_plus_mobiledata: "+ alphabet character font internet letter network speed symbol text type wifi wireless",
  luggage: "airport baggage carry flight hotel on suitcase travel trip",
  lunch_dining: "breakfast dinner drink fastfood hamburger meal",
  lyrics: "audio bubble chat comment communicate feedback key message music note song sound speech track",
  mail: "email envelope inbox letter message send",
  mail_lock: "email envelop letter locked message password privacy private protection safety secure security send",
  mail_outline: "email envelope letter message note post receive send write",
  male: "boy gender man social symbol",
  man: "boy gender male social symbol",
  manage_accounts: "change details face gear options people person profile service-human settings user",
  manage_search: "glass history magnifying text",
  map: "destination direction location maps pin place route stop travel",
  maps_home_work: "building house office",
  maps_ugc: "+ add bubble comment communicate feedback message new plus speech symbol",
  margin: "design layout padding size square",
  mark_as_unread: "envelop letter mail postal receive send",
  mark_chat_read: "approve bubble check comment communicate complete done message ok select sent speech tick verified yes",
  mark_chat_unread: "bubble circle comment communicate message notification speech",
  mark_email_read: "approve check complete done envelop letter message note ok select send sent tick yes",
  mark_email_unread: "check circle envelop letter message note notification send",
  markunread: "email envelope letter message send",
  markunread_mailbox: "deliver envelop letter postal postbox receive send",
  masks: "air cover covid face hospital medical pollution protection respirator sick social",
  maximize: "application components design interface line screen shape ui ux website",
  media_bluetooth_off: "connection connectivity device disabled enabled music note offline paring signal slash symbol wireless",
  media_bluetooth_on: "connection connectivity device disabled enabled music note off online paring signal slash symbol wireless",
  mediation: "alternative arrows compromise direction dots negotiation party right structure",
  medical_services: "aid bag briefcase emergency first kit medicine",
  medication: "doctor drug emergency hospital medicine pharmacy pills prescription",
  meeting_room: "building doorway entrance home house interior logout office open places signout",
  memory: "card chip digital micro processor sd storage",
  menu: "application components hamburger interface lines playlist screen ui ux website",
  menu_book: "dining food meal page restaurant",
  menu_open: "application arrow chevron components hamburger interface left lines screen ui ux website",
  merge: "arrows directions maps navigation path route sign traffic",
  merge_type: "arrow combine direction format text",
  message: "bubble chat comment communicate feedback speech talk text",
  mic: "hearing microphone noise record search sound speech voice",
  mic_external_off: "audio disabled enabled microphone slash sound voice",
  mic_external_on: "audio disabled enabled microphone off slash sound voice",
  mic_none: "hearing microphone noise record sound voice",
  mic_off: "audio disabled enabled hearing microphone noise recording slash sound voice",
  microwave: "appliance cooking electric heat home house kitchen machine",
  military_tech: "army award badge honor medal merit order privilege prize rank reward ribbon soldier star status trophy winner",
  minimize: "application components design interface line screen shape ui ux website",
  missed_video_call: "arrow camera filming hardware image motion picture record videography",
  mms: "bubble chat comment communicate feedback image landscape message mountains multimedia photography picture speech",
  mobiledata_off: "arrow disabled down enabled internet network on slash speed up wifi wireless",
  mobile_friendly: "Android approve cell check complete device done hardware iOS mark ok phone select tablet tick validate verified yes",
  mobile_off: "Android cell device disabled enabled hardware iOS phone silence slash tablet",
  mobile_screen_share: "Android arrow cell device hardware iOS mirror monitor phone screencast streaming tablet tv wireless",
  mode: "compose create draft draw edit pencil write",
  mode_comment: "bubble chat comment communicate feedback message mode speech",
  mode_edit: "compose create draft draw pencil write",
  mode_edit_outline: "compose create draft draw pencil write",
  model_training: "arrow bulb idea inprogress light loading refresh renew restore reverse rotate",
  mode_night: "dark disturb moon sleep weather",
  mode_of_travel: "arrow destination direction location maps pin place stop transportation trip",
  mode_standby: "disturb power sleep target",
  monetization_on: "bill card cash circle coin commerce cost credit currency dollars finance money online payment price profit sale shopping symbol",
  money: "100 bill card cash coin commerce cost credit currency digit dollars finance number online payment price profit shopping symbol",
  money_off: "bill card cart cash coin commerce credit currency disabled dollars enabled finance money online payment price profit shopping slash symbol",
  money_off_csred: "bill card cart cash coin commerce credit currency disabled dollars enabled online payment shopping slash symbol",
  monitor: "Android chrome device display hardware iOS mac screen web window",
  monitor_weight: "body device diet health scale smart",
  monochrome_photos: "black camera image photography picture white",
  mood: "emoji emoticon emotions expressions face feelings glad happiness happy like person pleased smiley smiling social survey",
  mood_bad: "disappointment dislike emoji emoticon emotions expressions face feelings person rating smiley social survey unhappiness unhappy unpleased unsmile unsmiling",
  more: "3 archive badge bookmark dots etc favorite indent label remember save stamp sticker tab tag three",
  more_horiz: "3 application components dots etc horizontal interface ios pending screen status three ui ux website",
  more_time: "+ add clock date new plus schedule symbol",
  more_vert: "3 android application components dots etc interface screen three ui ux vertical website",
  motion_photos_auto: "A alphabet animation automatic character circle font gif letter live symbol text type video",
  motion_photos_off: "animation circle disabled enabled slash video",
  mouse: "click computer cursor device hardware wireless",
  move_down: "arrow direction jump navigation transfer",
  move_to_inbox: "archive arrow down email envelop incoming letter message move send to",
  move_up: "arrow direction jump navigation transfer",
  movie: "cinema film media screen show slate tv video watch",
  movie_creation: "clapperboard film movies slate video",
  movie_filter: "clapperboard creation film movies slate stars video",
  moving: "arrow direction navigation travel up",
  mp: "alphabet character font image letter megapixel photography pixels quality resolution symbol text type",
  multiline_chart: "analytics bars data diagram infographic line measure metrics multiple statistics tracking",
  multiple_stop: "arrows directions dots left maps navigation right",
  museum: "architecture attraction building estate event exhibition explore local palces places real see shop store tour",
  music_note: "audiotrack key sound",
  music_off: "audiotrack disabled enabled key note on slash sound",
  music_video: "band mv recording screen tv watch",
  my_location: "destination direction maps navigation pin place point stop",
  nat: "communication",
  nature: "forest outdoor outside park tree wilderness",
  nature_people: "activity body forest human outdoor outside park person tree wilderness",
  navigate_before: "arrows direction left",
  navigate_next: "arrows direction right",
  navigation: "arrow destination direction location maps pin place point stop",
  nearby_error: "! alert attention caution danger exclamation important mark notification symbol warning",
  nearby_off: "disabled enabled on slash",
  near_me: "arrow destination direction location maps navigation pin place point stop",
  near_me_disabled: "destination direction enabled location maps navigation off pin place point slash",
  nest_cam_wired_stand: "camera filming hardware image motion picture videography",
  network_cell: "cellular data internet mobile phone speed wifi wireless",
  network_check: "connection internet meter signal speed tick wifi wireless",
  network_locked: "alert available cellular connection data error internet mobile not privacy private protection restricted safety secure security service signal warning wifi wireless",
  network_wifi: "cellular data internet mobile phone speed wireless",
  new_releases: "! alert announcement attention burst caution danger error exclamation important mark notification star symbol warning",
  newspaper: "article data document drive file folders magazine media notes page sheet slide text writing",
  next_plan: "arrow circle right",
  next_week: "arrow baggage briefcase business suitcase",
  nfc: "communication data field mobile near wireless",
  nightlife: "alcohol bar bottle club cocktail dance drink food glass liquor music note wine",
  nightlight: "dark disturb mode moon sleep weather",
  nightlight_round: "dark half mode moon",
  night_shelter: "architecture bed building estate homeless house place real sleep",
  nights_stay: "cloud crescent dark mode moon phases silence silent sky time weather",
  no_accounts: "avatar disabled enabled face human offline people person profile slash thumbnail unavailable unidentifiable unknown user",
  no_backpack: "accessory bookbag knapsack travel",
  no_drinks: "alcohol beverage bottle cocktail food liquor wine",
  no_encryption: "disabled enabled lock off password safety security slash",
  no_encryption_gmailerrorred: "disabled enabled locked off slash",
  no_flash: "camera disabled enabled image lightning off on photography picture slash thunderbolt",
  no_food: "disabled drink enabled fastfood hamburger meal off on slash",
  no_luggage: "baggage carry disabled enabled off on slash suitcase travel",
  no_meals: "dining disabled eat enabled food fork knife off restaurant slash spoon utensils",
  no_meeting_room: "building disabled doorway enabled entrance home house interior office on open places slash",
  no_photography: "camera disabled enabled image off on picture slash",
  nordic_walking: "athlete athletic body entertainment exercise hiking hobby human people person social sports travel walker",
  north: "arrow directional maps navigation up",
  north_east: "arrow maps navigation noth right up",
  north_west: "arrow directional left maps navigation up",
  no_sim: "camera card device eject insert memory phone storage",
  no_stroller: "baby care carriage children disabled enabled infant kid newborn off on parents slash toddler young",
  not_accessible: "accessibility body handicap help human person wheelchair",
  note: "bookmark message paper",
  note_add: "+ -doc create data document drive file folders new page paper plus sheet slide symbol writing",
  note_alt: "clipboard document file memo page paper writing",
  notes: "comment document text write writing",
  notification_add: "+ active alarm alert bell chime notifications notify plus reminder ring sound symbol",
  notification_important: "! active alarm alert announcement attention bell caution chime danger error exclamation feedback mark notifications notify problem reminder ring sound symbol warning",
  notifications: "active alarm alert bell chime notify reminder ring sound",
  notifications_active: "alarm alert bell chime notify reminder ringing sound",
  notifications_none: "alarm alert bell notify reminder ring sound",
  notifications_off: "active alarm alert bell chime disabled enabled notify offline reminder ring slash sound",
  notifications_paused: "--- active alarm aleet alert bell chime ignore notify pause quiet reminder ring sleep snooze sound zzz",
  not_interested: "allowed banned cancel circle close disabled dislike exit interested not off prohibited quit remove stop",
  not_listed_location: "? assistance destination direction help information maps pin place punctuation questionmark stop support symbol",
  no_transfer: "automobile bus cars direction disabled enabled maps off public slash transportation vehicle",
  not_started: "circle media pause play video",
  offline_bolt: "circle electric fast flash lightning spark thunderbolt",
  offline_pin: "approve checkmark circle complete done ok select tick validate verified yes",
  offline_share: "Android arrow cell connect device direction hardware iOS link mobile multiple phone right tablet",
  oil_barrel: "droplet gasoline nest water",
  ondemand_video: "Android chrome desktop device hardware iOS mac monitor play television tv web window",
  on_device_training: "arrow bulb call cell contact hardware idea inprogress light loading mobile model refresh renew restore reverse rotate telephone",
  online_prediction: "bulb connection idea light network signal wireless",
  opacity: "color droplet hue inverted liquid palette tone water",
  open_in_browser: "arrow box new up website window",
  open_in_full: "action arrows expand grow move",
  open_in_new: "application arrow box components interface screen ui ux website window",
  open_in_new_off: "arrow box disabled enabled export on slash window",
  open_with: "arrows directional expand move",
  other_houses: "architecture cottage estate home maps place real residence residential stay traveling",
  outbound: "arrow circle directional right up",
  outbox: "mail send sent",
  outdoor_grill: "barbecue barbeque bbq charcoal cooking home house outside",
  outlet: "connecter electricity plug power",
  outlined_flag: "country goal mark nation report start",
  padding: "design layout margin size square",
  pages: "article gplus paper post star",
  pageview: "document find glass magnifying paper search",
  paid: "circle currency money payment transaction",
  palette: "art colors filters paint",
  panorama: "angle image mountains photography picture view wide",
  panorama_fish_eye: "angle circle image photography picture wide",
  panorama_horizontal: "angle image photography picture wide",
  panorama_photosphere: "angle horizontal image photography picture wide",
  panorama_vertical: "angle image photography picture wide",
  panorama_wide_angle: "image photography picture",
  pan_tool: "drag fingers gesture hands human move scan stop touch wait",
  paragliding: "athlete athletic body entertainment exercise fly hobby human parachute people person skydiving social sports travel",
  park: "attraction fresh local nature outside plant tree",
  party_mode: "camera lens photography picture",
  password: "key login pin security star unlock",
  pattern: "key login password pin security star unlock",
  pause: "controls media music pending player status video wait",
  pause_circle: "controls media music video",
  pause_circle_filled: "controls media music pending status video wait",
  pause_circle_outline: "controls media music pending status video wait",
  pause_presentation: "application desktop device pending screen share slides status wait website window www",
  payment: "bill cash charge coin commerce cost creditcard currency dollars finance financial information money online price shopping symbol",
  payments: "bill card cash coin commerce cost credit currency dollars finance layer money multiple online price shopping symbol",
  pedal_bike: "automobile bicycle cars direction human maps public route scooter transportation vehicle vespa",
  pending: "circle dots loading progress waiting",
  pending_actions: "clipboard clock date document remember schedule time",
  pentagon: "five shape sides",
  people: "accounts committee community face family friends group humans network persons profiles social team users",
  people_alt: "accounts committee face family friends group humans network persons profiles social team users",
  people_outline: "accounts committee face family friends group humans network persons profiles social team users",
  percent: "math number symbol",
  perm_camera_mic: "image microphone min photography picture speaker",
  perm_contact_calendar: "account agenda date face human information people person profile schedule time user",
  perm_data_setting: "cellular configure gear information network settings wifi wireless",
  perm_device_information: "Android alert announcement cell hardware iOS important mobile phone tablet",
  perm_identity: "account avatar face human information people person profile save, thumbnail user",
  perm_media: "collection data directories document file folders images landscape mountains photography picture save storage",
  perm_phone_msg: "bubble call cell chat comment communicate contact device message mobile recording save speech telephone voice",
  perm_scan_wifi: "alert announcement connection information internet network service signal wireless",
  person: "account avatar face human people profile user",
  person_add: "+ account avatar face friend human new people plus profile symbol user",
  person_add_alt: "+ account face human people plus profile user",
  person_add_disabled: "+ account enabled face human new offline people plus profile slash symbol user",
  personal_video: "Android cam chrome desktop device hardware iOS mac monitor television tv web window",
  person_off: "account avatar disabled enabled face human people profile slash user",
  person_outline: "account avatar face human people profile user",
  person_pin: "account avatar destination direction face gps human location maps people place profile stop user",
  person_pin_circle: "account destination direction face gps human location maps people place profile stop user",
  person_remove: "account avatar delete face human minus people profile unfriend user",
  person_search: "account avatar face find glass human look magnifying people profile user",
  pest_control: "bug exterminator insects",
  pest_control_rodent: "exterminator mice",
  pets: "animal cat claw dog hand paw",
  phishing: "fishing fraud hook scam",
  phone: "call cell chat contact device hardware mobile telephone text",
  phone_android: "cell device hardware iOS mobile tablet",
  phone_bluetooth_speaker: "call cell connection connectivity contact device hardware mobile signal symbol telephone wireless",
  phone_callback: "arrow cell contact device down hardware mobile telephone",
  phone_disabled: "call cell contact device enabled hardware mobile offline slash telephone",
  phone_enabled: "call cell contact device hardware mobile telephone",
  phone_forwarded: "arrow call cell contact device direction hardware mobile right telephone",
  phone_iphone: "Android apple cell device hardware iOS mobile tablet",
  phonelink: "Android chrome computer connect desktop device hardware iOS mac mobile sync tablet web windows",
  phonelink_erase: "Android cancel cell close connection device exit hardware iOS mobile no remove stop tablet",
  phonelink_lock: "Android cell connection device erase hardware iOS locked mobile password privacy private protection safety secure security tablet",
  phonelink_off: "Android chrome computer connect desktop device disabled enabled hardware iOS mac mobile slash sync tablet web windows",
  phonelink_ring: "Android cell connection data device hardware iOS mobile network service signal tablet wireless",
  phonelink_setup: "Android call chat device hardware iOS information mobile settings tablet text",
  phone_locked: "call cell contact device hardware mobile password privacy private protection safety secure security telephone",
  phone_missed: "arrow call cell contact device hardware mobile telephone",
  phone_paused: "call cell contact device hardware mobile telephone wait",
  photo: "image mountains photography picture",
  photo_album: "archive bookmark image label library mountains photography picture ribbon save tag",
  photo_camera: "image photography picture",
  photo_camera_back: "image landscape mountains photography picture rear",
  photo_camera_front: "account face human image people person photography picture portrait profile user",
  photo_filter: "filters image photography picture stars",
  photo_library: "album image mountains photography picture",
  photo_size_select_actual: "image mountains photography picture",
  photo_size_select_large: "adjust album editing image library mountains photography picture",
  photo_size_select_small: "adjust album editing image large library mountains photography picture",
  php: "alphabet brackets character code css developer engineering font html letter platform symbol text type",
  piano: "instrument keyboard keys musical social",
  piano_off: "disabled enabled instrument keyboard keys musical on slash social",
  picture_as_pdf: "alphabet character document file font image letter multiple photography symbol text type",
  picture_in_picture: "cropped overlap photo position shape",
  picture_in_picture_alt: "cropped overlap photo position shape",
  pie_chart: "analytics bars data diagram infographic measure metrics statistics tracking",
  pie_chart_outline: "analytics bars data diagram infographic measure metrics statistics tracking",
  pin: "1 2 3 digit key login logout number password pattern security star symbol unlock",
  pinch: "arrows compress direction finger grasp hand navigation nip squeeze tweak",
  pin_drop: "destination direction gps location maps navigation place stop",
  pivot_table_chart: "analytics arrows bars data diagram direction drive editing grid infographic measure metrics rotate sheet statistics tracking",
  place: "destination direction location maps navigation pin point stop",
  plagiarism: "document find glass look magnifying page paper search see",
  play_arrow: "controls media music player start video",
  play_circle: "arrow controls media music video",
  play_disabled: "controls enabled media music off slash video",
  play_for_work: "arrow circle down google half",
  play_lesson: "audio bookmark digital ebook lesson multimedia play reading ribbon",
  playlist_add: "+ collection music new plus symbol task todo",
  playlist_add_check: "approve checkmark collection complete done music ok select task tick todo validate verified yes",
  playlist_add_check_circle: "album artist audio cd collection mark music record sound track",
  playlist_add_circle: "album artist audio cd check collection mark music record sound track",
  playlist_play: "arow arrow collection music",
  playlist_remove: "- collection minus music",
  plumbing: "build construction fix handyman repair tools wrench",
  plus_one: "1 add digit increase number symbol",
  podcasts: "broadcast casting network signal transmitting wireless",
  point_of_sale: "checkout cost machine merchant money payment pos retail system transaction",
  policy: "certified find glass legal look magnifying privacy private protection search security see shield verified",
  poll: "analytics barchart bars data diagram infographic measure metrics statistics survey tracking vote",
  pool: "athlete athletic beach body entertainment exercise hobby human ocean people person places sea sports swimming water",
  portable_wifi_off: "connected connection data device disabled enabled internet network offline service signal slash usage wireless",
  portrait: "account face human people person photo picture profile user",
  post_add: "+ data document drive file folders item page paper plus sheet slide text writing",
  power: "charge cord electrical online outlet plug socket",
  power_input: "dc lines supply",
  power_off: "charge cord disabled electrical enabled on outlet plug slash",
  power_settings_new: "information off save shutdown",
  precision_manufacturing: "arm automatic chain conveyor crane factory industry machinery mechanical production repairing robot supply warehouse",
  pregnant_woman: "baby birth body female human lady maternity mom mother people person user women",
  present_to_all: "arrow presentation screen share slides website",
  preview: "design eye layout reveal screen see show website window www",
  price_change: "arrows bill card cash coin commerce cost credit currency dollars down finance money online payment shopping symbol up",
  price_check: "approve bill card cash coin commerce complete cost credit currency dollars done finance mark money ok online payment select shopping symbol tick validate verified yes",
  print: "draft fax ink machine office paper printer send",
  print_disabled: "enabled off on paper printer slash",
  priority_high: "! alert attention caution danger error exclamation important mark notification symbol warning",
  privacy_tip: "alert announcement announcment assistance certified details help information private protection security service shield support verified",
  production_quantity_limits: "! alert attention bill card cart cash caution coin commerce credit currency danger dollars error exclamation important mark money notification online payment shopping symbol warning",
  propane: "gas nest",
  propane_tank: "bbq gas grill nest",
  psychology: "behavior body brain cognitive function gear head human intellectual mental mind people person preferences psychiatric science settings social therapy thinking thoughts",
  public: "country earth global globe language map network planet social space web world",
  public_off: "disabled earth enabled global globe map network on planet slash social space web world",
  publish: "arrow cloud file import submit upload",
  published_with_changes: "approve arrows check complete done inprogress loading mark ok refresh renew replace rotate select tick validate verified yes",
  push_pin: "location marker place remember save",
  qr_code: "barcode camera media product quick response smartphone urls",
  qr_code_2: "barcode camera media product quick response smartphone urls",
  qr_code_scanner: "barcode camera media product quick response smartphone urls",
  query_builder: "clock date hour minute save schedule time",
  query_stats: "analytics chart data diagram find glass infographic line look magnifying measure metrics search see statistics tracking",
  question_answer: "bubble chat comment communicate conversation converse feedback message speech talk",
  question_mark: "? assistance help information mark punctuation question support symbol",
  queue: "add collection layers multiple music playlist stack stream video",
  queue_music: "add collection playlist stream",
  queue_play_next: "+ add arrow collection desktop device display hardware monitor music new playlist plus screen steam symbol tv video",
  quickreply: "bubble chat comment communicate fast lightning message speech thunderbolt",
  quiz: "? assistance faq help information mark punctuation question support symbol test",
  radar: "detect military near network position scan",
  radio: "antenna audio device frequency hardware listen media music player signal tune",
  radio_button_checked: "application bullet circle components design form interface off point record screen selected toggle ui ux website",
  radio_button_unchecked: "bullet circle deselected form off point record toggle",
  railway_alert: "! attention automobile bike cars caution danger direction error exclamation important maps mark notification public scooter subway symbol train transportation vehicle vespa warning",
  ramen_dining: "breakfast dinner drink fastfood lunch meal noodles restaurant",
  ramp_left: "arrows directions maps navigation path route sign traffic",
  ramp_right: "arrows directions maps navigation path route sign traffic",
  rate_review: "chat comment feedback message pencil stars write",
  raw_off: "alphabet character disabled enabled font image letter original photography slash symbol text type",
  raw_on: "alphabet character disabled enabled font image letter off original photography slash symbol text type",
  read_more: "arrow text",
  receipt: "bill credit invoice paper payment sale transaction",
  receipt_long: "bill check document list paperwork record store transaction",
  recent_actors: "account avatar cards carousel contacts face human layers list people person profile thumbnail user",
  recommend: "approved circle confirm favorite gesture hand like reaction social support thumbs well",
  record_voice_over: "account face human people person profile recording sound speaking speech transcript user",
  rectangle: "four parallelograms polygons quadrilaterals recangle shape sides",
  redeem: "bill cart cash certificate coin commerce credit currency dollars giftcard money online payment present shopping",
  redo: "arrow backward forward next repeat rotate undo",
  reduce_capacity: "arrow body covid decrease down human people person social",
  refresh: "around arrows direction inprogress loading navigation refresh renew right rotate turn",
  remember_me: "Android avatar device hardware human iOS identity mobile people person phone profile tablet user",
  remove: "can delete line minus negative substract subtract trash",
  remove_circle: "allowed banned block can delete disable minus negative not substract trash",
  remove_circle_outline: "allowed banned block can delete disable minus negative not substract trash",
  remove_done: "approve check complete disabled enabled finished mark multiple off ok select slash tick yes",
  remove_from_queue: "collection desktop device display hardware list monitor screen steam television",
  remove_moderator: "certified disabled enabled off privacy private protection security shield slash verified",
  remove_red_eye: "iris looking preview see sight vision",
  remove_road: "- cancel close destination direction exit highway maps minus new no stop street symbol traffic",
  remove_shopping_cart: "card cash checkout coin commerce credit currency disabled dollars enabled off online payment slash tick",
  reorder: "format lines list stacked",
  repeat: "arrows controls media music video",
  repeat_on: "arrows controls media music video",
  repeat_one: "1 arrows controls digit media music number symbol video",
  repeat_one_on: "arrows controls digit media music number symbol video",
  replay: "arrows controls music refresh reload renew repeat retry rewind undo video",
  replay_10: "arrows controls digit music number refresh renew repeat rewind symbol ten video",
  replay_30: "arrows controls digit music number refresh renew repeat rewind symbol thirty video",
  replay_5: "arrows controls digit five music number refresh renew repeat rewind symbol video",
  replay_circle_filled: "arrows controls music refresh renew repeat video",
  reply: "arrow backward left mail message send share",
  reply_all: "arrows backward group left mail message multiple send share",
  report: "! alert attention caution danger error exclamation important mark notification octagon symbol warning",
  report_gmailerrorred: "! alert attention caution danger exclamation important mark notification octagon symbol warning",
  report_off: "! alert attention caution danger disabled enabled error exclamation important mark notification octagon offline slash symbol warning",
  report_problem: "! alert announcement attention caution danger error exclamation feedback important mark notification symbol triangle warning",
  request_quote: "bill card cash coin commerce cost credit currency dollars finance money online payment price shopping symbol",
  reset_tv: "arrow device hardware monitor television",
  restart_alt: "around arrow inprogress loading reboot refresh renew repeat reset",
  restaurant: "breakfast cutlery dining dinner eat food fork knife local lunch meal places spoon utensils",
  restaurant_menu: "book dining eat food fork knife local meal spoon",
  restore: "arrow backwards clock date history refresh renew reverse rotate schedule time turn undo",
  restore_from_trash: "arrow backwards can clock date delete garbage history refresh remove renew reverse rotate schedule time turn up",
  restore_page: "arrow data doc file history paper refresh rotate sheet storage undo web",
  reviews: "bubble chat comment communicate feedback message rate rating recommendation speech",
  rice_bowl: "dinner food lunch meal restaurant",
  ring_volume: "calling cell contact device hardware incoming mobile ringer sound telephone",
  r_mobiledata: "alphabet character font letter symbol text type",
  rocket: "spaceship",
  rocket_launch: "spaceship takeoff",
  roller_shades: "blinds cover curtains nest open shutter sunshade",
  roller_shades_closed: "blinds cover curtains nest shutter sunshade",
  roofing: "architecture building chimney construction estate home house real residence residential service shelter",
  room: "destination direction gps location maps marker pin place spot stop",
  room_preferences: "building doorway entrance gear home house interior office open settings",
  room_service: "alert bell concierge delivery hotel notify",
  rotate_90_degrees_ccw: "arrows direction editing image photo turn",
  rotate_90_degrees_cw: "arrows ccw direction editing image photo turn",
  rotate_left: "around arrow circle direction inprogress loading refresh reload renew reset turn",
  rotate_right: "around arrow circle direction inprogress loading refresh renew turn",
  roundabout_left: "arrows directions maps navigation path route sign traffic",
  roundabout_right: "arrows directions maps navigation path route sign traffic",
  rounded_corner: "adjust edit shape square transform",
  route: "directions maps path sign traffic",
  router: "box cable connection device hardware internet network signal wifi",
  rowing: "activity boat body canoe human people person sports water",
  rss_feed: "application blog connection data internet network service signal website wifi wireless",
  rsvp: "alphabet character font invitation invite letter plat respond rpondez sil symbol text type vous",
  rtt: "call real rrt text time",
  rule: "approve check done incomplete line mark missing no ok select tick validate verified wrong x yes",
  rule_folder: "approve cancel check close complete data document done drive exit file mark no ok remove select sheet slide storage tick validate verified yes",
  run_circle: "body exercise human people person running",
  running_with_errors: "! alert attention caution danger duration exclamation important mark notification processing symbol time warning",
  rv_hookup: "arrow attach automobile automotive back cars connect direction left maps public right trailer transportation travel truck van vehicle",
  safety_divider: "apart distance separate social space",
  sailing: "entertainment fishing hobby ocean sailboat sea social sports travel water",
  sanitizer: "bacteria bottle clean covid disinfect germs pump",
  satellite: "bluetooth connection connectivity data device image internet landscape location maps mountains network photography picture scan service signal symbol wifi wireless--",
  satellite_alt: "alternative artificial communication space station television",
  save: "data diskette document drive file floppy multimedia storage write",
  save_alt: "arrow diskette document down file floppy multimedia write",
  save_as: "compose create data disk document draft drive editing file floppy input multimedia pencil storage write writing",
  saved_search: "find glass important look magnifying marked see star",
  savings: "bank bill card cash coin commerce cost credit currency dollars finance money online payment piggy symbol",
  scale: "measure monitor weight",
  scanner: "copy device hardware machine",
  scatter_plot: "analytics bars chart circles data diagram dot infographic measure metrics statistics tracking",
  schedule: "calendar clock date mark save time",
  schedule_send: "calendar clock date email letter remember share time",
  schema: "analytics chart data diagram flow infographic measure metrics statistics tracking",
  school: "academy achievement cap class college education graduation hat knowledge learning university",
  science: "beaker chemical chemistry experiment flask glass laboratory research tube",
  score: "2k alphabet analytics bars character chart data diagram digit font infographic letter measure metrics number statistics symbol text tracking type",
  screen_lock_landscape: "Android device hardware iOS mobile phone rotate security tablet",
  screen_lock_portrait: "Android device hardware iOS mobile phone rotate security tablet",
  screen_lock_rotation: "Android arrow device hardware iOS mobile phone rotate tablet turn",
  screen_rotation: "Android arrow device hardware iOS mobile phone rotate tablet turn",
  screen_search_desktop: "Android arrow device hardware iOS lock monitor rotate web",
  screen_share: "Android arrow cast chrome device display hardware iOS laptop mac mirror monitor steam streaming web window",
  screenshot: "Android cell crop device hardware iOS mobile phone tablet",
  screenshot_monitor: "Android chrome desktop device display hardware iOS mac screengrab web window",
  sd: "alphabet camera card character data device digital drive flash font image letter memory photo secure symbol text type",
  sd_card: "camera digital memory photos secure storage",
  sd_card_alert: "! attention camera caution danger digital error exclamation important mark memory notification photos secure storage symbol warning",
  sd_storage: "camera card data digital memory microsd secure",
  search: "filter find glass look magnifying see up",
  search_off: "cancel close disabled enabled find glass look magnifying on see slash stop x",
  security: "certified privacy private protection shield verified",
  security_update: "Android arrow device download hardware iOS mobile phone tablet",
  security_update_good: "Android checkmark device hardware iOS mobile ok phone tablet tick",
  security_update_warning: "! Android alert attention caution danger device download error exclamation hardware iOS important mark mobile notification phone symbol tablet",
  segment: "alignment fonts format lines list paragraph part piece rules style text",
  select_all: "selection square tool",
  self_improvement: "body calm care chi human meditate meditation people person relax sitting wellbeing yoga zen",
  sell: "bill card cart cash coin commerce credit currency dollars money online payment price shopping tag",
  send: "chat email message paper plane reply right share telegram",
  send_and_archive: "arrow download email letter save share",
  send_time_extension: "deliver dispatch envelop mail message schedule",
  send_to_mobile: "Android arrow device export forward hardware iOS phone right share tablet",
  sensors: "connection network scan signal wireless",
  sensors_off: "connection disabled enabled network scan signal slash wireless",
  sentiment_dissatisfied: "angry disappointed dislike emoji emoticon emotions expressions face feelings frown mood person sad smiley survey unhappy unsatisfied upset",
  sentiment_neutral: "emotionless emotions expressions face feelings indifference mood okay person survey",
  sentiment_satisfied: "emoji emoticon emotions expressions face feelings glad happiness happy like mood person pleased smiley smiling survey",
  sentiment_satisfied_alt: "account emoji face happy human people person profile smile user",
  sentiment_very_dissatisfied: "angry disappointed dislike emoji emoticon emotions expressions face feelings mood person sad smiley sorrow survey unhappy unsatisfied upset",
  sentiment_very_satisfied: "emoji emoticon emotions expressions face feelings glad happiness happy like mood person pleased smiley smiling survey",
  set_meal: "chopsticks dinner fish food lunch restaurant teishoku",
  settings: "application change details gear information options personal service",
  settings_accessibility: "body details human information people personal preferences profile user",
  settings_applications: "change details gear information options personal save service",
  settings_backup_restore: "arrow backwards history refresh reverse rotate time undo",
  settings_bluetooth: "connection connectivity device network signal symbol wifi",
  settings_brightness: "dark filter light mode sun",
  settings_cell: "Android cellphone device hardware iOS mobile tablet",
  settings_ethernet: "arrows brackets computer connection connectivity dots internet network parenthesis wifi",
  settings_input_antenna: "airplay arrows computer connection connectivity dots internet network screencast stream wifi wireless",
  settings_input_component: "audio av cables connection connectivity internet plugs points video wifi",
  settings_input_composite: "cable component connection connectivity plugs points",
  settings_input_hdmi: "cable connection connectivity definition high plugin points video wire",
  settings_input_svideo: "cable connection connectivity definition plugin plugs points standard svideo,",
  settings_overscan: "arrows expand image photo picture",
  settings_phone: "call cell contact device hardware mobile telephone",
  settings_power: "information off save shutdown",
  settings_remote: "bluetooth connection connectivity control device signal wifi wireless",
  settings_suggest: "change details gear options recommendation service suggestion system",
  settings_system_daydream: "backup cloud drive storage",
  settings_voice: "microphone recorder speaker",
  share: "android connect contect link multimedia multiple network options send shared sharing social",
  share_location: "destination direction gps maps pin place stop tracking",
  shield: "certified privacy private protection secure security verified",
  shop: "arrow bag bill briefcase buy card cart cash coin commerce credit currency dollars google money online payment play purchase shopping store",
  shop_2: "add arrow buy cart google play purchase shopping",
  shopping_bag: "bill business buy card cart cash coin commerce credit currency dollars money online payment storefront",
  shopping_basket: "add bill buy card cart cash checkout coin commerce credit currency dollars money online payment purchase",
  shopping_cart: "add bill buy card cash checkout coin commerce credit currency dollars money online payment purchase",
  shopping_cart_checkout: "arrow cash coin commerce currency dollars money online payment right",
  shop_two: "add arrow briefcase buy cart google play purchase shopping",
  shortcut: "arrow direction forward right",
  short_text: "brief comment document lines note write writing",
  show_chart: "analytics bars chart data diagram infographic line measure metrics presentation show statistics stock tracking",
  shower: "bathroom closet home house place plumbing sprinkler wash water wc",
  shuffle: "arrows controls music random video",
  shuffle_on: "arrows controls music random video",
  shutter_speed: "aperture camera duration image lens photography photos picture setting stop timer watch",
  sick: "covid discomfort emotions expressions face feelings fever flu ill mood pain person survey upset",
  signal_cellular_0_bar: "data internet mobile network phone speed wifi wireless",
  signal_cellular_4_bar: "data internet mobile network phone speed wifi wireless",
  signal_cellular_alt: "analytics bar chart data diagram infographic internet measure metrics mobile network phone statistics tracking wifi wireless",
  signal_cellular_connected_no_internet_0_bar: "! alert attention caution danger data error exclamation important mark mobile network notification phone symbol warning wifi wireless",
  signal_cellular_connected_no_internet_4_bar: "! alert attention caution danger data error exclamation important mark mobile network notification phone symbol warning wifi wireless",
  signal_cellular_nodata: "internet mobile network offline phone quit wifi wireless x",
  signal_cellular_no_sim: "camera card chip device disabled enabled memory network offline phone slash storage",
  signal_cellular_null: "data internet mobile network phone wifi wireless",
  signal_cellular_off: "data disabled enabled internet mobile network offline phone slash wifi wireless",
  signal_wifi_bad: "bar cancel cellular close data exit internet mobile network no phone quit remove stop wireless",
  signal_wifi_off: "cellular data disabled enabled internet mobile network phone slash speed wireless",
  signal_wifi_statusbar_null: "cellular data internet mobile network phone speed wireless",
  signpost: "arrow direction left maps right signal signs street traffic",
  sim_card: "camera chip device memory network phone storage",
  sim_card_alert: "! attention camera caution danger digital error exclamation important mark memory notification photos sd secure storage symbol warning",
  sim_card_download: "arrow camera chip device memory phone storage",
  single_bed: "bedroom double furniture home hotel house king night pillows queen rest sleep twin",
  sip: "alphabet call character dialer font initiation internet letter over phone protocol routing session symbol text type voice",
  skateboarding: "athlete athletic body entertainment exercise hobby human people person skateboarder social sports",
  skip_next: "arrow back controls forward music play previous transport video",
  skip_previous: "arrow backward controls forward music next play transport video",
  sledding: "athlete athletic body entertainment exercise hobby human people person sledge snow social sports travel winter",
  slideshow: "movie photos play presentation square video view",
  slow_motion_video: "arrow circle controls music play speed time",
  smart_button: "action auto components composer function interface special stars ui ux website",
  smart_display: "airplay chrome connect device screencast stream television tv video wireless",
  smartphone: "Android call cell chat device hardware iOS mobile tablet text",
  smart_screen: "Android airplay cell connect device hardware iOS mobile phone screencast stream tablet video",
  smart_toy: "games robot",
  smoke_free: "cigarette disabled enabled never no off places prohibited slash smoking tobacco warning zone",
  smoking_rooms: "allowed cigarette places smoke tobacco zone",
  sms: "3 bubble chat comment communication conversation dots message more service speech three",
  sms_failed: "! alert attention bubbles caution chat comment communication conversation danger error exclamation important mark message notification service speech symbol warning",
  snippet_folder: "data document drive file sheet slide storage",
  snooze: "alarm bell clock duration notification set timer watch",
  snowboarding: "athlete athletic body entertainment exercise hobby human people person social sports travel winter",
  snowmobile: "automobile car direction skimobile social sports transportation travel vehicle winter",
  snowshoeing: "body human people person sports travel walking winter",
  soap: "bathroom clean fingers gesture hand wash wc",
  social_distance: "6 apart body ft human people person space",
  solar_power: "eco energy heat nest sunny",
  sort: "filter find lines list organize",
  sort_by_alpha: "alphabetize az by character font letters list order organize symbol text type",
  soup_kitchen: "breakfast brunch dining food lunch meal",
  source: "code composer content creation data document file folder mode storage view",
  south: "arrow directional down maps navigation",
  south_america: "america continent landscape place region south",
  south_east: "arrow directional down maps navigation right",
  south_west: "arrow directional down left maps navigation",
  spa: "aromatherapy flower healthcare leaf massage meditation nature petals places relax wellbeing wellness",
  space_bar: "keyboard line",
  speaker: "audio box electronic loud music sound stereo system video",
  speaker_group: "audio box electronic loud multiple music sound stereo system video",
  speaker_notes: "bubble cards chat comment communicate format list message speech text",
  speaker_notes_off: "bubble cards chat comment communicate disabled enabled format list message on slash speech text",
  speaker_phone: "Android cell device hardware iOS mobile sound tablet volume",
  speed: "arrow clock controls dial fast gauge measure motion music slow speedometer test velocity video",
  spellcheck: "alphabet approve character checkmark edit font letter ok processor select symbol text tick type word write yes",
  splitscreen: "grid layout multitasking two",
  spoke: "connection network radius",
  sports: "athlete athletic basketball blowing coach entertainment exercise game hobby instrument live referee soccer social sound trophy warning whistle",
  sports_bar: "alcohol beer drink liquor pint places pub",
  sports_baseball: "athlete athletic entertainment exercise game hobby social",
  sports_basketball: "athlete athletic entertainment exercise game hobby social",
  sports_cricket: "athlete athletic ball bat entertainment exercise game hobby social",
  sports_esports: "controller entertainment gamepad gaming hobby online playstation social video xbox",
  sports_football: "american athlete athletic entertainment exercise game hobby social",
  sports_golf: "athlete athletic ball club entertainment exercise game golfer golfing hobby social",
  sports_handball: "athlete athletic body entertainment exercise game hobby human people person social",
  sports_hockey: "athlete athletic entertainment exercise game hobby ice social sticks",
  sports_kabaddi: "athlete athletic body combat entertainment exercise fighting game hobby human judo martial people person social wrestle wrestling",
  sports_martial_arts: "athlete athletic entertainment exercise hobby human karate people person social",
  sports_mma: "arts athlete athletic boxing combat entertainment exercise fighting game glove hobby martial mixed social",
  sports_motorsports: "athlete athletic automobile bike drive driving entertainment helmet hobby motorcycle protect social vehicle",
  sports_rugby: "athlete athletic ball entertainment exercise game hobby social",
  sports_score: "destination flag goal",
  sports_soccer: "athlete athletic entertainment exercise football game hobby social",
  sports_tennis: "athlete athletic ball bat entertainment exercise game hobby racket social",
  sports_volleyball: "athlete athletic entertainment exercise game hobby social",
  square: "draw four quadrangle shape sides",
  square_foot: "construction feet inches length measurement ruler school set tools",
  ssid_chart: "graph lines network wifi",
  stacked_bar_chart: "analytics chart-chart data diagram infographic measure metrics statistics tracking",
  stacked_line_chart: "analytics data diagram infographic measure metrics statistics tracking",
  stadium: "activity amphitheater arena coliseum event local star things ticket",
  stairs: "down staircase up",
  star: "best bookmark favorite highlight ranking rate rating save toggle",
  star_border: "best bookmark favorite highlight outline ranking rate rating save toggle",
  star_half: "0.5 1/2 achievement bookmark favorite highlight important marked ranking rate rating reward saved shape special toggle",
  star_outline: "bookmark favorite half highlight ranking rate rating save toggle",
  star_rate: "achievement bookmark favorite highlight important marked ranking rating reward saved shape special",
  stars: "achievement bookmark circle favorite highlight important like love marked ranking rate rating reward saved shape special",
  start: "arrow keyboard next right",
  stay_current_landscape: "Android device hardware iOS mobile phone tablet",
  stay_current_portrait: "Android device hardware iOS mobile phone tablet",
  stay_primary_landscape: "Android current device hardware iOS mobile phone tablet",
  stay_primary_portrait: "Android current device hardware iOS mobile phone tablet",
  sticky_note_2: "bookmark message paper text writing",
  stop: "arrow controls music pause player square video",
  stop_circle: "controls music pause play square video",
  stop_screen_share: "Android arrow cast chrome device disabled display enabled hardware iOS laptop mac mirror monitor offline slash steam streaming web window",
  storage: "computer database drive memory network server",
  store: "bill building business buy card cash coin company credit currency dollars e-commerce market money online payment purchase shopping storefront",
  storefront: "business buy cafe commerce market merchant places restaurant retail sell shopping stall",
  store_mall_directory: "building",
  storm: "forecast hurricane temperature twister weather wind",
  straight: "arrows directions maps navigation path route sign traffic up",
  straighten: "length measurement piano ruler size",
  stream: "cast connected feed live network signal wireless",
  streetview: "gps location maps",
  strikethrough_s: "alphabet character cross doc editing editor font letter out spreadsheet styles symbol text type writing",
  stroller: "baby care carriage children infant kid newborn toddler young",
  style: "booklet cards filters options tags",
  subdirectory_arrow_left: "arrow down navigation",
  subdirectory_arrow_right: "arrow down navigation",
  subject: "alignment document email full justify lines list note text writing",
  subscript: "2 doc editing editor gmail novitas spreadsheet style symbol text writing",
  subscriptions: "enroll media order playlist queue signup subscribe youtube",
  subtitles: "accessibility accessible captions character closed decoder language media movies translate tv",
  subtitles_off: "accessibility accessible caption closed disabled enabled language slash translate video",
  subway: "automobile bike cars maps metro rail scooter train transportation travel tunnel underground vehicle vespa",
  summarize: "document list menu note report summary",
  superscript: "2 doc editing editor gmail novitas spreadsheet style symbol text writing",
  supervised_user_circle: "account avatar control face human parental parents people person profile supervisor",
  supervisor_account: "administrator avatar control face human parental parents people person profile supervised user",
  support: "assist help lifebuoy rescue safety",
  support_agent: "care customer face headphone person representative service",
  surfing: "athlete athletic beach body entertainment exercise hobby human people person sea social sports summer water",
  surround_sound: "audio circle signal speaker system volume volumn wireless",
  swap_calls: "arrows device direction mobile share",
  swap_horiz: "arrows back direction forward horizontal",
  swap_horizontal_circle: "arrows back direction forward",
  swap_vert: "arrows back direction down navigation up vertical",
  swap_vertical_circle: "arrows back direction down horizontal up",
  swipe: "arrows fingers gesture hands touch",
  swipe_down: "arrows direction disable enable finger hands hit navigation strike swing swpie take",
  swipe_down_alt: "arrows direction disable enable finger hands hit navigation strike swing swpie take",
  swipe_left: "arrows finger hand hit navigation reject strike swing take",
  swipe_left_alt: "arrows finger hand hit navigation reject strike swing take",
  swipe_right: "accept arrows direction finger hands hit navigation strike swing swpie take",
  swipe_right_alt: "accept arrows direction finger hands hit navigation strike swing swpie take",
  swipe_up: "arrows direction disable enable finger hands hit navigation strike swing swpie take",
  swipe_up_alt: "arrows direction disable enable finger hands hit navigation strike swing swpie take",
  swipe_vertical: "arrows direction finger hands hit navigation strike swing swpie take verticle",
  switch_access_shortcut: "arrows direction navigation new north star symbol up",
  switch_access_shortcut_add: "+ arrows direction navigation new north plus star symbol up",
  switch_account: "choices face human multiple options people person profile social user",
  switch_camera: "arrows photography picture",
  switch_left: "arrows directional navigation toggle",
  switch_right: "arrows directional navigation toggle",
  switch_video: "arrows camera photography videos",
  sync: "360 around arrows direction inprogress loading refresh renew rotate turn",
  sync_alt: "arrows horizontal internet technology update wifi",
  sync_disabled: "360 around arrows direction enabled inprogress loading off refresh renew rotate slash turn",
  sync_lock: "around arrows locked password privacy private protection renew rotate safety secure security turn",
  sync_problem: "! 360 alert around arrows attention caution danger direction error exclamation important inprogress loading mark notification refresh renew rotate symbol turn warning",
  system_security_update: "Android arrow cell device down hardware iOS mobile phone tablet",
  system_security_update_good: "Android approve cell check complete device done hardware iOS mark mobile ok phone select tablet tick validate verified yes",
  system_security_update_warning: "! Android alert attention caution cell danger device error exclamation hardware iOS important mark mobile notification phone symbol tablet",
  system_update: "Android arrows cell device direction download hardware iOS install mobile phone tablet",
  system_update_alt: "arrow download export",
  tab: "browser computer documents folder internet tabs website windows",
  table_chart: "analytics bars data diagram grid infographic measure metrics statistics tracking",
  table_rows: "grid layout lines stacked",
  tablet: "Android device hardware iOS ipad mobile web",
  tablet_android: "device hardware iOS ipad mobile web",
  tablet_mac: "Android apple device hardware iOS ipad mac mobile tablet web",
  table_view: "format grid group layout multiple",
  tab_unselected: "browser computer documents folder internet tabs website windows",
  tag: "hashtag key media number pound social trend",
  tag_faces: "emoji emotion happy satisfied smile",
  takeout_dining: "box container delivery food meal restaurant",
  tap_and_play: "Android cell connection device hardware iOS internet mobile network nfc phone signal tablet to wifi wireless",
  tapas: "appetizer brunch dinner food lunch restaurant snack",
  task: "approve check complete data document done drive file folders mark ok page paper select sheet slide tick validate verified writing yes",
  task_alt: "approve check circle complete done mark ok select tick validate verified yes",
  taxi_alert: "! attention automobile cab cars caution danger direction error exclamation important lyft maps mark notification public symbol transportation uber vehicle warning yellow",
  terminal: "application code emulator program software",
  terrain: "geography landscape mountain",
  text_decrease: "- alphabet character font letter minus remove resize subtract symbol type",
  text_fields: "T add alphabet character font input letter symbol type",
  text_format: "A alphabet character font letter square style symbol type",
  text_increase: "+ add alphabet character font letter new plus resize symbol type",
  text_rotate_up: "A alphabet arrow character field font letter move symbol type",
  text_rotate_vertical: "A alphabet arrow character down field font letter move symbol type verticle",
  text_rotation_angledown: "A alphabet arrow character field font letter move rotate symbol type",
  text_rotation_angleup: "A alphabet arrow character field font letter move rotate symbol type",
  text_rotation_down: "A alphabet arrow character field font letter move rotate symbol type",
  text_rotation_none: "A alphabet arrow character field font letter move rotate symbol type",
  textsms: "bubble chat comment communicate dots feedback message speech",
  text_snippet: "data document file notes storage writing",
  texture: "diagonal lines pattern stripes",
  theater_comedy: "broadway event movie musical places show standup tour watch",
  theaters: "film media movies photography showtimes video watch",
  thermostat: "forecast temperature weather",
  thermostat_auto: "A celsius fahrenheit temperature thermometer",
  thumb_down: "dislike downvote favorite fingers gesture hands ranking rate rating reject up",
  thumb_down_alt: "bad decline disapprove dislike feedback hand hate negative no reject social veto vote",
  thumb_down_off_alt: "bad decline disapprove dislike favorite feedback filled fingers gesture hands hate negative no ranking rate rating reject sad social veto vote",
  thumbs_up_down: "dislike favorite fingers gesture hands rate rating vote",
  thumb_up: "approve dislike down favorite fingers gesture hands ranking rate rating success upvote",
  thumb_up_alt: "agreed approved confirm correct favorite feedback good hand happy like okay positive satisfaction social success vote yes",
  thumb_up_off_alt: "agreed approved confirm correct favorite feedback fingers gesture good hands happy like okay positive ranking rate rating satisfaction social vote yes",
  timelapse: "duration motion photo timer video",
  timeline: "analytics chart data graph history line movement points tracking trending zigzag zigzap",
  timer: "alarm alart bell clock disabled duration enabled notification off slash stopwatch wait",
  timer_10: "digits duration numbers seconds",
  timer_10_select: "alphabet camera character digit font letter number seconds symbol text type",
  timer_3: "digits duration numbers seconds",
  timer_3_select: "alphabet camera character digit font letter number seconds symbol text type",
  timer_off: "alarm alart bell clock disabled duration enabled notification slash stopwatch",
  time_to_leave: "automobile cars destination direction drive estimate eta maps public transportation travel trip vehicle",
  tips_and_updates: "alert announcement electricity idea information lamp lightbulb stars",
  title: "T alphabet character font header letter subject symbol text type",
  toc: "content format lines list reorder stacked table text titles",
  today: "agenda calendar date event mark month range remember reminder schedule time week",
  toggle_off: "application components configuration control design disable inable inactive interface selection settings slider switch ui ux website",
  toggle_on: "application components configuration control design disable inable inactive interface off selection settings slider switch ui ux website",
  token: "badge hexagon mark shield sign symbol",
  toll: "bill booth card cash circles coin commerce credit currency dollars highway money online payment ticket",
  tonality: "circle editing filter image photography picture",
  topic: "data document drive file folder sheet slide storage",
  tornado: "crisis disaster natural rain storm weather wind",
  touch_app: "arrow command fingers gesture hand press swipe tap",
  tour: "destination flag places travel visit",
  toys: "car fan games kids windmill",
  track_changes: "bullseye circle evolve lines movement radar rotate shift target",
  traffic: "direction light maps signal street",
  train: "automobile cars direction maps public rail subway transportation vehicle",
  tram: "automobile cars direction maps public rail subway train transportation vehicle",
  transfer_within_a_station: "arrows body direction human left maps people person public right route stop transit transportation vehicle walk",
  transform: "adjust crop editing image photo picture",
  transgender: "female lgbt neutral neutrual social symbol",
  transit_enterexit: "arrow direction maps navigation route transportation",
  translate: "alphabet language letter speaking speech text translator words",
  travel_explore: "earth find glass global globe look magnifying map network planet search see social space web world",
  trending_down: "analytics arrow change chart data diagram infographic measure metrics movement rate rating sale statistics tracking",
  trending_flat: "arrow change chart data graph metric movement rate right tracking",
  trending_up: "analytics arrow change chart data diagram infographic measure metrics movement rate rating statistics tracking",
  trip_origin: "circle departure",
  try: "bookmark bubble chat comment communicate favorite feedback highlight important marked message saved shape special speech star",
  tty: "call cell contact deaf device hardware impaired mobile speech talk telephone text",
  tune: "adjust editing options settings sliders",
  tungsten: "electricity indoor lamp lightbulb setting",
  turned_in: "archive bookmark favorite item label library reading remember ribbon save submit tag",
  turned_in_not: "archive bookmark favorite item label library outline reading remember ribbon save submit tag",
  turn_left: "arrows directions maps navigation path route sign traffic",
  turn_right: "arrows directions maps navigation path route sign traffic",
  turn_sharp_left: "arrows directions maps navigation path route sign traffic",
  turn_sharp_right: "arrows directions maps navigation path route sign traffic",
  turn_slight_left: "arrows directions maps navigation path right route sign traffic",
  turn_slight_right: "arrows directions maps navigation path route sharp sign traffic",
  tv: "device display linear living monitor room screencast stream television video wireless",
  tv_off: "Android chrome desktop device disabled enabled hardware iOS mac monitor slash television web window",
  two_wheeler: "automobile bicycle cars direction maps moped motorbike motorcycle public ride riding scooter transportation travel twom vehicle wheeler wheels",
  umbrella: "beach protection rain sunny",
  unarchive: "arrow inbox mail store undo up",
  undo: "arrow backward mail previous redo repeat rotate",
  unfold_less: "arrows chevron collapse direction expandable inward list navigation up",
  unfold_more: "arrows chevron collapse direction down expandable list navigation",
  unpublished: "approve check circle complete disabled done enabled mark off ok select slash tick validate verified yes",
  unsubscribe: "cancel close email envelop esubscribe message newsletter off remove send",
  upcoming: "alarm calendar mail message notification",
  update: "arrow backwards clock forward future history load refresh reverse rotate schedule time",
  update_disabled: "arrow backwards clock enabled forward history load off on refresh reverse rotate schedule slash time",
  upgrade: "arrow export instal line replace update",
  upload: "arrows download drive",
  upload_file: "arrow data document download drive folders page paper sheet slide writing",
  usb: "cable connection device wire",
  usb_off: "cable connection device wire",
  u_turn_left: "arrows directions maps navigation path route sign traffic u-turn",
  u_turn_right: "arrows directions maps navigation path route sign traffic u-turn",
  vaccines: "aid covid doctor drug emergency hospital immunity injection medical medication medicine needle pharmacy sick syringe vaccination vial",
  verified: "approve badge burst check complete done mark ok select star tick validate yes",
  verified_user: "approve audit certified checkmark complete done ok privacy private protection security select shield tick validate yes",
  vertical_align_bottom: "alignment arrow doc down editing editor spreadsheet text type writing",
  vertical_align_center: "alignment arrow doc down editing editor spreadsheet text type up writing",
  vertical_align_top: "alignment arrow doc editing editor spreadsheet text type up writing",
  vertical_shades: "blinds cover curtains nest open shutter sunshade",
  vertical_shades_closed: "blinds cover curtains nest roller shutter sunshade",
  vertical_split: "design format grid layout paragraph text website writing",
  vibration: "Android alert cell device hardware iOS mobile mode motion notification phone silence silent tablet vibrate",
  video_call: "+ add camera chat conference filming hardware image motion new picture plus screen symbol videography",
  videocam: "camera chat conference filming hardware image motion picture screen videography",
  video_camera_back: "image landscape mountains photography picture rear",
  video_camera_front: "account face human image people person photography picture profile user",
  videocam_off: "camera chat conference disabled enabled filming hardware image motion offline picture screen slash videography",
  video_file: "camera document filming hardware image motion picture videography",
  videogame_asset: "console controller device gamepad gaming nintendo playstation xbox",
  videogame_asset_off: "console controller device disabled enabled gamepad gaming playstation slash",
  video_label: "device item screen window",
  video_library: "arrow collection play",
  video_settings: "change details gear information options play screen service window",
  video_stable: "filming recording setting stability taping",
  view_agenda: "blocks cards design format grid layout website,stacked",
  view_array: "blocks design format grid layout website",
  view_carousel: "banner blocks cards design format grid images layout website",
  view_column: "blocks design format grid layout vertical website",
  view_comfy: "grid layout pattern squares",
  view_comfy_alt: "cozy design format layout web",
  view_compact: "grid layout pattern squares",
  view_compact_alt: "dense design format layout web",
  view_cozy: "comfy design format layout web",
  view_day: "blocks calendar cards carousel design format grid layout website week",
  view_headline: "blocks design format grid layout paragraph text website",
  view_in_ar: "3d augmented cube daydream headset reality square vr",
  view_kanban: "grid layout pattern squares",
  view_list: "blocks design format grid layout lines reorder stacked title website",
  view_module: "blocks design format grid layout reorder squares stacked title website",
  view_quilt: "blocks design format grid layout reorder squares stacked title website",
  view_sidebar: "design format grid layout web",
  view_stream: "blocks design format grid layout lines list reorder stacked title website",
  view_timeline: "grid layout pattern squares",
  view_week: "bars blocks columns day design format grid layout website",
  vignette: "border editing effect filter gradient image photography setting",
  villa: "architecture beach estate home house maps place real residence residential stay traveling vacation",
  visibility: "eye on password preview reveal see shown visability",
  visibility_off: "disabled enabled eye hidden invisible on password reveal see show slash view visability",
  voice_chat: "bubble camera comment communicate facetime feedback message speech video",
  voicemail: "call device message missed mobile phone recording",
  voice_over_off: "account disabled enabled face human people person profile recording slash speaking speech transcript user",
  volume_down: "audio av control music quieter shh soft sound speaker tv",
  volume_mute: "audio control music sound speaker tv",
  volume_off: "audio av control disabled enabled low music mute slash sound speaker tv",
  volume_up: "audio control music sound speaker tv",
  volunteer_activism: "donation fingers gesture giving hands heart love sharing",
  vpn_key: "login network passcode password register security signin signup unlock",
  vpn_key_off: "[offline] disabled enabled network on passcode password slash unlock",
  vpn_lock: "earth globe locked network password privacy private protection safety secure security virtual world",
  vrpano: "angle image landscape mountains panorama photography picture view wide",
  wallpaper: "background image landscape photography picture",
  warehouse: "garage industry manufacturing storage",
  warning: "! alert announcement attention caution danger error exclamation feedback important mark notification problem symbol triangle",
  warning_amber: "! alert attention caution danger error exclamation important mark notification symbol triangle",
  wash: "bathroom clean fingers gesture hand wc",
  watch: "Android clock gadget iOS smartwatch time vr wearables web wristwatch",
  watch_later: "clock date hour minute schedule time",
  watch_off: "Android clock close gadget iOS shut time vr wearables web wristwatch",
  water: "aqua beach lake ocean river waves weather",
  water_damage: "architecture building droplet estate house leak plumbing real residence residential shelter",
  waterfall_chart: "analytics bar data diagram infographic measure metrics statistics tracking",
  waves: "beach lake ocean pool river sea swim water",
  wb_auto: "A W alphabet automatic balance character editing font image letter photography symbol text type white wp",
  wb_cloudy: "balance editing white wp",
  wb_incandescent: "balance bright editing lamp lightbulb lighting settings white wp",
  wb_iridescent: "balance bright editing lighting settings white wp",
  wb_shade: "balance house lighting white",
  wb_sunny: "balance bright lighting weather white",
  wc: "bathroom closet female gender man person restroom toilet unisex wash water women",
  web: "blocks browser internet page screen website www",
  web_asset: "-website application browser design desktop download image interface internet layout screen ui ux video window www",
  web_asset_off: "browser disabled enabled internet on screen slash webpage website windows www",
  webhook: "api developer development enterprise software",
  weekend: "chair couch furniture home living lounge relax room seat",
  west: "arrow directional left maps navigation",
  whatshot: "arrow circle direction fire frames round trending",
  wheelchair_pickup: "accessibility accessible body handicap help human person",
  where_to_vote: "approve ballot check complete destination direction done election location maps mark ok pin place poll select stop tick validate verified yes",
  widgets: "app blocks box menu setting squares ui",
  wifi: "connection data internet network scan service signal wireless",
  wifi_calling: "cell connection connectivity contact device hardware mobile signal telephone wireless",
  wifi_calling_3: "cellular data internet mobile network phone speed wireless",
  wifi_channel: "(scan) [cellular connection data internet mobile] network service signal wireless",
  wifi_find: "(scan) [cellular connection data detect discover glass internet look magnifying mobile] network notice search service signal wireless",
  wifi_lock: "cellular connection data internet locked mobile network password privacy private protection safety secure security service signal wireless",
  wifi_off: "connection data disabled enabled internet network offline scan service signal slash wireless",
  wifi_password: "(scan) [cellular connection data internet lock mobile] network secure service signal wireless",
  wifi_protected_setup: "around arrows rotate",
  wifi_tethering: "cellular connection data internet mobile network phone scan service signal speed wireless",
  wifi_tethering_off: "cellular connection data disabled enabled internet mobile network offline phone scan service signal slash speed wireless",
  window: "close glass grid home house interior layout outside",
  wind_power: "eco energy nest windy",
  wine_bar: "alcohol cocktail cup drink glass liquor",
  work: "-briefcase baggage business job suitcase",
  work_history: "arrow backwards baggage briefcase business clock date job refresh renew reverse rotate schedule suitcase time turn",
  work_off: "baggage briefcase business disabled enabled job on slash suitcase",
  work_outline: "baggage briefcase business job suitcase",
  workspace_premium: "certification degree ecommerce guarantee medal permit ribbon verification",
  workspaces: "circles collaboration dot filled group team",
  wrap_text: "arrow doc editing editor spreadsheet type write writing",
  wrong_location: "cancel close destination direction exit maps no pin place quit remove stop",
  wysiwyg: "composer mode screen software system text view visibility website window",
  yard: "backyard flower garden home house nature pettle plants",
  youtube_searched_for: "arrow backwards find glass history inprogress loading look magnifying refresh renew restore reverse rotate see yt",
  zoom_in: "bigger find glass grow look magnifier magnifying plus scale search see size",
  zoom_in_map: "arrows destination location maps move place stop",
  zoom_out: "find glass look magnifier magnifying minus negative scale search see size smaller",
  zoom_out_map: "arrows destination location maps move place stop"
};
const map2 = iconKeys.map((importName) => {
  const iconSynonym = importName in iconSynonyms ? iconSynonyms[importName] : "";
  return {
    key: importName,
    synonyms: iconSynonym
  };
});
const iconsSearch = new Fuse(map2, {
  isCaseSensitive: false,
  shouldSort: true,
  ignoreLocation: true,
  distance: 0,
  keys: ["key", "synonyms"]
});
function hashString(str) {
  let hash2 = 0;
  let i;
  let chr;
  for (i = 0; i < str.length; i++) {
    chr = str.charCodeAt(i);
    hash2 = (hash2 << 5) - hash2 + chr;
    hash2 |= 0;
  }
  return Math.abs(hash2);
}
function getIcon(iconKey, className, color) {
  if (!iconKey) return void 0;
  iconKey = slugify(iconKey);
  if (!(iconKey in iconKeysMap)) {
    return void 0;
  }
  return iconKey in iconKeysMap ? /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { iconKey, size: "medium", className, color }) : void 0;
}
const IconForView = React__default.memo(function IconForView2(t0) {
  const $ = c_1(14);
  const {
    collectionOrView,
    className,
    color,
    size: t1
  } = t0;
  const size2 = t1 === void 0 ? "medium" : t1;
  if (!collectionOrView) {
    let t22;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
      t22 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
      $[0] = t22;
    } else {
      t22 = $[0];
    }
    return t22;
  }
  let t2;
  if ($[1] !== className || $[2] !== collectionOrView.icon || $[3] !== color) {
    t2 = getIcon(collectionOrView.icon, className, color);
    $[1] = className;
    $[2] = collectionOrView.icon;
    $[3] = color;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  const icon = t2;
  if (collectionOrView?.icon && icon) {
    return icon;
  }
  const t3 = ("singularName" in collectionOrView ? collectionOrView.singularName : void 0) ?? collectionOrView.name;
  let t4;
  if ($[5] !== t3) {
    t4 = slugify(t3);
    $[5] = t3;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  let slugName = t4;
  let key;
  if (slugName in iconKeysMap) {
    key = slugName;
  }
  if (!key) {
    let t52;
    if ($[7] !== collectionOrView.path) {
      t52 = slugify(collectionOrView.path);
      $[7] = collectionOrView.path;
      $[8] = t52;
    } else {
      t52 = $[8];
    }
    slugName = t52;
    if (slugName in iconKeysMap) {
      key = slugName;
    }
  }
  const iconsCount = coolIconKeys.length;
  if (!key) {
    key = coolIconKeys[hashString(collectionOrView.path) % iconsCount];
  }
  let t5;
  if ($[9] !== className || $[10] !== color || $[11] !== key || $[12] !== size2) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { iconKey: key, size: size2, className, color });
    $[9] = className;
    $[10] = color;
    $[11] = key;
    $[12] = size2;
    $[13] = t5;
  } else {
    t5 = $[13];
  }
  return t5;
}, (prevProps, nextProps) => {
  return equal(prevProps.collectionOrView?.icon, nextProps.collectionOrView?.icon) && equal(prevProps.color, nextProps.color);
});
const iconKeysMap = iconKeys.reduce((acc, key) => {
  acc[key] = key;
  return acc;
}, {});
function plural(word, amount) {
  if (amount !== void 0 && amount === 1) {
    return word;
  }
  const plurals = {
    "(quiz)$": "$1zes",
    "^(ox)$": "$1en",
    "([m|l])ouse$": "$1ice",
    "(matr|vert|ind)ix|ex$": "$1ices",
    "(x|ch|ss|sh)$": "$1es",
    "([^aeiouy]|qu)y$": "$1ies",
    "(hive)$": "$1s",
    "(?:([^f])fe|([lr])f)$": "$1$2ves",
    "(shea|lea|loa|thie)f$": "$1ves",
    sis$: "ses",
    "([ti])um$": "$1a",
    "(tomat|potat|ech|her|vet)o$": "$1oes",
    "(bu)s$": "$1ses",
    "(alias)$": "$1es",
    "(octop)us$": "$1i",
    "(ax|test)is$": "$1es",
    "(us)$": "$1es",
    "([^s]+)$": "$1s"
  };
  const irregular = {
    move: "moves",
    foot: "feet",
    goose: "geese",
    sex: "sexes",
    child: "children",
    man: "men",
    tooth: "teeth",
    person: "people"
  };
  const uncountable = ["sheep", "fish", "deer", "moose", "series", "species", "money", "rice", "information", "equipment", "bison", "cod", "offspring", "pike", "salmon", "shrimp", "swine", "trout", "aircraft", "hovercraft", "spacecraft", "sugar", "tuna", "you", "wood"];
  if (uncountable.indexOf(word.toLowerCase()) >= 0) {
    return word;
  }
  for (const w in irregular) {
    const pattern = new RegExp(`${w}$`, "i");
    const replace2 = irregular[w];
    if (pattern.test(word)) {
      return word.replace(pattern, replace2);
    }
  }
  for (const reg in plurals) {
    const pattern = new RegExp(reg, "i");
    if (pattern.test(word)) {
      return word.replace(pattern, plurals[reg]);
    }
  }
  return word;
}
function singular(word, amount) {
  if (amount !== void 0 && amount !== 1) {
    return word;
  }
  const singulars = {
    "(quiz)zes$": "$1",
    "(matr)ices$": "$1ix",
    "(vert|ind)ices$": "$1ex",
    "^(ox)en$": "$1",
    "(alias)es$": "$1",
    "(octop|vir)i$": "$1us",
    "(cris|ax|test)es$": "$1is",
    "(shoe)s$": "$1",
    "(o)es$": "$1",
    "(bus)es$": "$1",
    "([m|l])ice$": "$1ouse",
    "(x|ch|ss|sh)es$": "$1",
    "(m)ovies$": "$1ovie",
    "(s)eries$": "$1eries",
    "([^aeiouy]|qu)ies$": "$1y",
    "([lr])ves$": "$1f",
    "(tive)s$": "$1",
    "(hive)s$": "$1",
    "(li|wi|kni)ves$": "$1fe",
    "(shea|loa|lea|thie)ves$": "$1f",
    "(^analy)ses$": "$1sis",
    "((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$": "$1$2sis",
    "([ti])a$": "$1um",
    "(n)ews$": "$1ews",
    "(h|bl)ouses$": "$1ouse",
    "(corpse)s$": "$1",
    "(us)es$": "$1",
    s$: ""
  };
  const irregular = {
    move: "moves",
    foot: "feet",
    goose: "geese",
    sex: "sexes",
    child: "children",
    man: "men",
    tooth: "teeth",
    person: "people"
  };
  const uncountable = ["sheep", "fish", "deer", "moose", "series", "species", "money", "rice", "information", "equipment", "bison", "cod", "offspring", "pike", "salmon", "shrimp", "swine", "trout", "aircraft", "hovercraft", "spacecraft", "sugar", "tuna", "you", "wood"];
  if (uncountable.indexOf(word.toLowerCase()) >= 0) {
    return word;
  }
  for (const w in irregular) {
    const pattern = new RegExp(`${irregular[w]}$`, "i");
    if (pattern.test(word)) {
      return word.replace(pattern, w);
    }
  }
  for (const reg in singulars) {
    const pattern = new RegExp(reg, "i");
    if (pattern.test(word)) {
      return word.replace(pattern, singulars[reg]);
    }
  }
  return word;
}
function getEntityPreviewKeys(targetCollection, fields, previewProperties, limit = 3) {
  const allProperties = Object.keys(targetCollection.properties);
  let listProperties = previewProperties?.filter((p2) => allProperties.includes(p2));
  if (!listProperties && targetCollection.previewProperties) {
    listProperties = targetCollection.previewProperties?.filter((p2) => allProperties.includes(p2));
  }
  if (listProperties && listProperties.length > 0) {
    return listProperties;
  } else {
    listProperties = allProperties;
    return listProperties.filter((key) => {
      const propertyOrBuilder = targetCollection.properties[key];
      return propertyOrBuilder && !isPropertyBuilder(propertyOrBuilder) && !isReferenceProperty(propertyOrBuilder, fields);
    }).slice(0, limit);
  }
}
function getEntityTitlePropertyKey(collection, propertyConfigs) {
  if (collection.titleProperty) {
    return collection.titleProperty;
  }
  for (const key in collection.properties) {
    const property2 = collection.properties[key];
    if (!isPropertyBuilder(property2)) {
      const field = getFieldConfig(property2, propertyConfigs);
      if (field?.key === "text_field") {
        return key;
      }
    }
  }
  return void 0;
}
function getEntityImagePreviewPropertyKey(collection) {
  for (const key in collection.properties) {
    const property2 = collection.properties[key];
    if (property2.dataType === "string" && property2.storage?.acceptedFiles?.includes("image/*")) {
      return key;
    }
  }
  for (const key in collection.properties) {
    const property2 = collection.properties[key];
    if (property2.dataType === "array" && property2.of?.dataType === "string" && property2.of.storage?.acceptedFiles?.includes("image/*")) {
      return key;
    }
  }
  return void 0;
}
function flattenObject(obj, parentKey = "") {
  if (!obj) return obj;
  return Object.keys(obj).reduce((flatObj, key) => {
    const newKey = parentKey ? `${parentKey}.${key}` : key;
    if (typeof obj[key] === "object" && obj[key] !== null) {
      if (Array.isArray(obj[key])) {
        obj[key].forEach((item, index2) => {
          Object.assign(flatObj, flattenObject(item, `${newKey}[${index2}]`));
        });
      } else {
        Object.assign(flatObj, flattenObject(obj[key], newKey));
      }
    } else {
      flatObj[newKey] = obj[key];
    }
    return flatObj;
  }, {});
}
function getArrayValuesCount(array2) {
  return array2.reduce((acc, obj) => {
    Object.entries(obj).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        acc[key] = Math.max(acc[key] || 0, value.length);
      }
      if (typeof value === "object" && value !== null) {
        const nested = getArrayValuesCount([value]);
        Object.entries(nested).forEach(([nestedKey, nestedCount]) => {
          const compoundKey = `${key}.${nestedKey}`;
          acc[compoundKey] = Math.max(acc[compoundKey] || 0, nestedCount);
        });
      }
    });
    return acc;
  }, {});
}
function makePropertiesEditable(properties) {
  Object.keys(properties).forEach((key) => {
    const property2 = properties[key];
    if (property2) {
      property2.editable = true;
      if (property2.dataType === "map" && property2.properties) {
        makePropertiesEditable(property2.properties);
      }
    }
  });
  return properties;
}
function makePropertiesNonEditable(properties) {
  return Object.entries(properties).reduce((acc, [key, property2]) => {
    if (!isPropertyBuilder(property2) && property2.dataType === "map" && property2.properties) {
      const updated = {
        ...property2,
        properties: makePropertiesNonEditable(property2.properties)
      };
      acc[key] = updated;
    }
    if (isPropertyBuilder(property2)) {
      acc[key] = property2;
    } else {
      acc[key] = {
        ...property2,
        editable: false
      };
    }
    return acc;
  }, {});
}
function applyModifyFunction(modifyCollection, collection, parentPaths) {
  if (modifyCollection) {
    const modified = modifyCollection({
      collection,
      parentPaths
    });
    const resCollection = modified ?? collection;
    if (resCollection.subcollections) {
      resCollection.subcollections = resCollection.subcollections.map((subcollection) => {
        return applyModifyFunction(modifyCollection, subcollection, [...parentPaths, collection.path]);
      });
    }
    return resCollection;
  } else {
    return collection;
  }
}
function joinCollectionLists(targetCollections, sourceCollections, parentPaths = [], modifyCollection) {
  const updatedCollections = (sourceCollections ?? []).map((sourceCol) => {
    const targetCol = targetCollections?.find((collection) => {
      return collection.id === sourceCol.id;
    });
    if (!targetCol) {
      return applyModifyFunction(modifyCollection, sourceCol, parentPaths);
    } else {
      return mergeCollection(targetCol, sourceCol, parentPaths, modifyCollection);
    }
  });
  const sourceCollectionIds = updatedCollections.map((c2) => c2.id);
  const resultStoredCollections = targetCollections.filter((col) => {
    return !sourceCollectionIds.includes(col.id);
  }).map((col) => {
    if (modifyCollection) {
      return applyModifyFunction(modifyCollection, col, parentPaths);
    } else {
      return col;
    }
  });
  return [...updatedCollections, ...resultStoredCollections];
}
function mergeCollection(target, source, parentPaths = [], modifyCollection) {
  const subcollectionsMerged = joinCollectionLists(target?.subcollections ?? [], source?.subcollections ?? [], [...parentPaths, target.path], modifyCollection);
  const propertiesMerged = {
    ...target.properties
  };
  Object.keys(source.properties).forEach((key) => {
    const property2 = target.properties[key];
    if (property2) propertiesMerged[key] = mergePropertyOrBuilder(property2, source.properties[key]);
    else propertiesMerged[key] = source.properties[key];
  });
  const mergedCollection = mergeDeep(target, source);
  const targetPropertiesOrder = getCollectionKeys(target);
  const sourcePropertiesOrder = getCollectionKeys(source);
  const mergedPropertiesOrder = [.../* @__PURE__ */ new Set([...sourcePropertiesOrder, ...targetPropertiesOrder])];
  const mergedEntityViews = [.../* @__PURE__ */ new Set([...target.entityViews ?? [], ...source.entityViews ?? []])];
  let resultCollection = {
    ...mergedCollection,
    subcollections: subcollectionsMerged,
    properties: sortProperties(propertiesMerged, mergedPropertiesOrder),
    propertiesOrder: mergedPropertiesOrder,
    entityViews: mergedEntityViews
  };
  if (modifyCollection) {
    const modifiedCollection = modifyCollection({
      collection: resultCollection,
      parentPaths
    });
    if (modifiedCollection) resultCollection = modifiedCollection;
  }
  return resultCollection;
}
function mergePropertyOrBuilder(target, source) {
  if (isPropertyBuilder(source)) {
    return source;
  } else if (isPropertyBuilder(target)) {
    return target;
  } else {
    const mergedProperty = mergeDeep(target, source);
    const targetEditable = Boolean(target.editable);
    const sourceEditable = Boolean(source.editable);
    if (source.dataType === "map" && source.properties) {
      const targetProperties = "properties" in target ? target.properties : {};
      const sourceProperties = "properties" in source ? source.properties : {};
      const targetPropertiesOrder = "propertiesOrder" in target && target.propertiesOrder ? target.propertiesOrder : Object.keys(targetProperties);
      const sourcePropertiesOrder = "propertiesOrder" in source && source.propertiesOrder ? source.propertiesOrder : "properties" in source ? Object.keys(source.properties) : [];
      const mergedPropertiesOrder = [.../* @__PURE__ */ new Set([...targetPropertiesOrder, ...sourcePropertiesOrder])];
      const mergedProperties = {
        ...targetProperties
      };
      Object.keys(source.properties).forEach((key) => {
        const property2 = targetProperties[key];
        if (property2) mergedProperties[key] = mergePropertyOrBuilder(property2, sourceProperties[key]);
      });
      return {
        ...mergedProperty,
        editable: targetEditable && sourceEditable,
        properties: mergedProperties,
        propertiesOrder: mergedPropertiesOrder
      };
    }
    return {
      ...mergedProperty,
      editable: targetEditable && sourceEditable
    };
  }
}
function getCollectionKeys(collection) {
  if (collection.propertiesOrder && collection.propertiesOrder.length > 0) {
    const propertiesOrder = collection.propertiesOrder;
    if (collection.additionalFields) {
      collection.additionalFields.forEach((field) => {
        if (!propertiesOrder.includes(field.key)) {
          propertiesOrder.push(field.key);
        }
      });
    }
    return propertiesOrder;
  }
  return [...Object.keys(collection.properties), ...(collection.additionalFields ?? [])?.map((f) => f.key)];
}
function buildCollection(collection) {
  return collection;
}
function buildProperty(property2) {
  return property2;
}
function buildProperties(properties) {
  return properties;
}
function buildPropertiesOrBuilder(propertiesOrBuilder) {
  return propertiesOrBuilder;
}
function buildEnumValues(enumValues) {
  return enumValues;
}
function buildEnumValueConfig(enumValueConfig) {
  return enumValueConfig;
}
function buildEntityCallbacks(callbacks) {
  return callbacks;
}
function buildAdditionalFieldDelegate(additionalFieldDelegate) {
  return additionalFieldDelegate;
}
function buildFieldConfig(propertyConfig) {
  return propertyConfig;
}
function printChanged(props, prev, path = "", depth = 0, maxDepth = 10) {
  if (depth > maxDepth) {
    return;
  }
  if (props && prev && typeof props === "object" && typeof prev === "object") {
    Object.keys(props).forEach((key) => {
      printChanged(props[key], prev[key], path + "." + key, depth + 1, maxDepth);
    });
  } else if (props !== prev) {
    console.log("Changed props:", path);
  }
}
function useTraceUpdate(props, t0) {
  const $ = c_1(3);
  const maxDepth = t0 === void 0 ? 3 : t0;
  const prev = useRef(props);
  let t1;
  if ($[0] !== maxDepth || $[1] !== props) {
    t1 = () => {
      console.log("Changed props:");
      printChanged(props, prev.current, "", 0, maxDepth);
      prev.current = props;
    };
    $[0] = maxDepth;
    $[1] = props;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  useEffect(t1);
}
async function resolveStorageFilenameString({
  input,
  storage,
  values,
  entityId,
  path,
  property: property2,
  file,
  propertyKey
}) {
  let result;
  if (typeof input === "function") {
    result = await input({
      path,
      entityId,
      values,
      property: property2,
      file,
      storage,
      propertyKey
    });
    if (!result) console.warn("Storage callback returned empty result. Using default name value");
  } else {
    result = replacePlaceholders({
      file,
      input,
      entityId,
      propertyKey,
      path
    });
  }
  if (!result) result = randomString() + "_" + file.name;
  return result;
}
function resolveStoragePathString({
  input,
  storage,
  values,
  entityId,
  path,
  property: property2,
  file,
  propertyKey
}) {
  let result;
  if (typeof input === "function") {
    result = input({
      path,
      entityId,
      values,
      property: property2,
      file,
      storage,
      propertyKey
    });
    if (!result) console.warn("Storage callback returned empty result. Using default name value");
  } else {
    result = replacePlaceholders({
      file,
      input,
      entityId,
      propertyKey,
      path
    });
  }
  if (!result) result = randomString() + "_" + file.name;
  return result;
}
function replacePlaceholders({
  file,
  input,
  entityId,
  propertyKey,
  path
}) {
  const ext = file.name.split(".").pop();
  let result = input.replace("{entityId}", entityId).replace("{propertyKey}", propertyKey).replace("{rand}", randomString()).replace("{file}", file.name).replace("{file.type}", file.type);
  if (path) {
    result = result.replace("{path}", path);
  }
  if (ext) {
    result = result.replace("{file.ext}", ext);
    const name = file.name.replace(`.${ext}`, "");
    result = result.replace("{file.name}", name);
  }
  if (!result) result = randomString() + "_" + file.name;
  return result;
}
const DataSourceContext = React__default.createContext({});
const useDataSource = (collection) => {
  const defaultDataSource = useContext(DataSourceContext);
  return defaultDataSource;
};
const NavigationContext = React__default.createContext({});
const useNavigationController = () => {
  return useContext(NavigationContext);
};
const useAuthController = () => {
  return useContext(AuthControllerContext);
};
const SideDialogsControllerContext = React__default.createContext({});
const useSideDialogsController = () => {
  return useContext(SideDialogsControllerContext);
};
const SideEntityControllerContext = React__default.createContext({});
const useSideEntityController = () => {
  return useContext(SideEntityControllerContext);
};
const StorageSourceContext = React__default.createContext({});
const useStorageSource = (collection) => {
  const defaultStorageSource = useContext(StorageSourceContext);
  if (collection?.overrides?.storageSource) {
    return collection.overrides.storageSource;
  }
  return defaultStorageSource;
};
const useSnackbarController = () => {
  const {
    enqueueSnackbar,
    closeSnackbar
  } = useSnackbar();
  const open = useCallback((props) => {
    const {
      type,
      message: message2,
      autoHideDuration
    } = props;
    enqueueSnackbar({
      message: message2,
      variant: type,
      autoHideDuration
    });
  }, []);
  const close2 = useCallback(() => {
    closeSnackbar();
  }, []);
  return useMemo(() => ({
    open,
    close: close2
  }), [open, close2]);
};
const UserConfigurationPersistenceContext = React__default.createContext(void 0);
const useUserConfigurationPersistence = () => {
  return useContext(UserConfigurationPersistenceContext);
};
const DialogsControllerContext = React__default.createContext({});
const DialogsProvider = (t0) => {
  const $ = c_1(16);
  const {
    children
  } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [];
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  const [dialogEntries, setDialogEntries] = useState(t1);
  const dialogEntriesRef = useRef(dialogEntries);
  let t2;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = (newPanels) => {
      dialogEntriesRef.current = newPanels;
      setDialogEntries(newPanels);
    };
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  const updateDialogEntries = t2;
  let t3;
  if ($[2] !== dialogEntries.length) {
    t3 = () => {
      if (dialogEntries.length === 0) {
        return;
      }
      const updatedPanels = [...dialogEntriesRef.current.slice(0, -1)];
      updateDialogEntries(updatedPanels);
    };
    $[2] = dialogEntries.length;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  const close2 = t3;
  let t4;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = (dialogEntry) => {
      const updatedPanels_0 = [...dialogEntriesRef.current, dialogEntry];
      updateDialogEntries(updatedPanels_0);
      return {
        closeDialog: () => {
          const updatedPanels_1 = dialogEntriesRef.current.filter((e2) => e2.key !== dialogEntry.key);
          updateDialogEntries(updatedPanels_1);
        }
      };
    };
    $[4] = t4;
  } else {
    t4 = $[4];
  }
  const open = t4;
  let t5;
  if ($[5] !== close2) {
    t5 = {
      open,
      close: close2
    };
    $[5] = close2;
    $[6] = t5;
  } else {
    t5 = $[6];
  }
  let t6;
  if ($[7] !== close2 || $[8] !== dialogEntries) {
    let t72;
    if ($[10] !== close2) {
      t72 = (entry, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(entry.Component, { open: true, closeDialog: close2 }, `dialog_${i}`);
      $[10] = close2;
      $[11] = t72;
    } else {
      t72 = $[11];
    }
    t6 = dialogEntries.map(t72);
    $[7] = close2;
    $[8] = dialogEntries;
    $[9] = t6;
  } else {
    t6 = $[9];
  }
  let t7;
  if ($[12] !== children || $[13] !== t5 || $[14] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogsControllerContext.Provider, { value: t5, children: [
      children,
      t6
    ] });
    $[12] = children;
    $[13] = t5;
    $[14] = t6;
    $[15] = t7;
  } else {
    t7 = $[15];
  }
  return t7;
};
const useDialogsController = () => {
  return useContext(DialogsControllerContext);
};
const CustomizationControllerContext = React__default.createContext({});
const useCustomizationController = () => {
  return useContext(CustomizationControllerContext);
};
const AnalyticsContext = React__default.createContext({});
const useAnalyticsController = () => {
  return useContext(AnalyticsContext);
};
const useFireCMSContext = () => {
  const authController = useAuthController();
  const sideDialogsController = useSideDialogsController();
  const sideEntityController = useSideEntityController();
  const navigation = useNavigationController();
  const dataSource = useDataSource();
  const storageSource = useStorageSource();
  const snackbarController = useSnackbarController();
  const userConfigPersistence = useUserConfigurationPersistence();
  const dialogsController = useDialogsController();
  const customizationController = useCustomizationController();
  const analyticsController = useAnalyticsController();
  const fireCMSContextRef = React__default.useRef({
    authController,
    sideDialogsController,
    sideEntityController,
    navigation,
    dataSource,
    storageSource,
    snackbarController,
    userConfigPersistence,
    dialogsController,
    customizationController,
    analyticsController
  });
  useEffect(() => {
    fireCMSContextRef.current = {
      authController,
      sideDialogsController,
      sideEntityController,
      navigation,
      dataSource,
      storageSource,
      snackbarController,
      userConfigPersistence,
      dialogsController,
      customizationController,
      analyticsController
    };
  }, [authController, dialogsController, navigation, sideDialogsController]);
  return fireCMSContextRef.current;
};
function useCollectionFetch(t0) {
  const $ = c_1(26);
  const {
    path: inputPath,
    collection,
    filterValues,
    sortBy,
    itemCount,
    searchString
  } = t0;
  const dataSource = useDataSource();
  const navigationController = useNavigationController();
  let t1;
  if ($[0] !== inputPath || $[1] !== navigationController) {
    t1 = navigationController.resolveAliasesFrom(inputPath);
    $[0] = inputPath;
    $[1] = navigationController;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const path = t1;
  const sortByProperty = sortBy ? sortBy[0] : void 0;
  const currentSort = sortBy ? sortBy[1] : void 0;
  const context = useFireCMSContext();
  let t2;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = [];
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const [data, setData] = useState(t2);
  const [dataLoading, setDataLoading] = useState(false);
  const [dataLoadingError, setDataLoadingError] = useState();
  const [noMoreToLoad, setNoMoreToLoad] = useState(false);
  let t3;
  if ($[4] !== collection || $[5] !== context || $[6] !== currentSort || $[7] !== dataSource || $[8] !== filterValues || $[9] !== itemCount || $[10] !== path || $[11] !== searchString || $[12] !== sortByProperty) {
    t3 = () => {
      setDataLoading(true);
      const onEntitiesUpdate = async (entities) => {
        if (collection.callbacks?.onFetch) {
          try {
            entities = await Promise.all(entities.map((entity) => collection.callbacks.onFetch({
              collection,
              path,
              entity,
              context
            })));
          } catch (t42) {
            const e2 = t42;
            console.error(e2);
          }
        }
        setDataLoading(false);
        setDataLoadingError(void 0);
        setData(entities.map(_temp$q));
        setNoMoreToLoad(!itemCount || entities.length < itemCount);
      };
      const onError = (error) => {
        console.error("ERROR", error);
        setDataLoading(false);
        setData([]);
        setDataLoadingError(error);
      };
      if (dataSource.listenCollection) {
        return dataSource.listenCollection({
          path,
          collection,
          onUpdate: onEntitiesUpdate,
          onError,
          searchString,
          filter: filterValues,
          limit: itemCount,
          startAfter: void 0,
          orderBy: sortByProperty,
          order: currentSort
        });
      } else {
        dataSource.fetchCollection({
          path,
          collection,
          searchString,
          filter: filterValues,
          limit: itemCount,
          startAfter: void 0,
          orderBy: sortByProperty,
          order: currentSort
        }).then(onEntitiesUpdate).catch(onError);
        return _temp2$d;
      }
    };
    $[4] = collection;
    $[5] = context;
    $[6] = currentSort;
    $[7] = dataSource;
    $[8] = filterValues;
    $[9] = itemCount;
    $[10] = path;
    $[11] = searchString;
    $[12] = sortByProperty;
    $[13] = t3;
  } else {
    t3 = $[13];
  }
  let t4;
  if ($[14] !== currentSort || $[15] !== filterValues || $[16] !== itemCount || $[17] !== path || $[18] !== searchString || $[19] !== sortByProperty) {
    t4 = [path, itemCount, currentSort, sortByProperty, filterValues, searchString];
    $[14] = currentSort;
    $[15] = filterValues;
    $[16] = itemCount;
    $[17] = path;
    $[18] = searchString;
    $[19] = sortByProperty;
    $[20] = t4;
  } else {
    t4 = $[20];
  }
  useEffect(t3, t4);
  let t5;
  if ($[21] !== data || $[22] !== dataLoading || $[23] !== dataLoadingError || $[24] !== noMoreToLoad) {
    t5 = {
      data,
      dataLoading,
      dataLoadingError,
      noMoreToLoad
    };
    $[21] = data;
    $[22] = dataLoading;
    $[23] = dataLoadingError;
    $[24] = noMoreToLoad;
    $[25] = t5;
  } else {
    t5 = $[25];
  }
  return t5;
}
function _temp2$d() {
}
function _temp$q(e_0) {
  return {
    ...e_0
  };
}
const CACHE = {};
function useEntityFetch(t0) {
  const $ = c_1(17);
  const {
    path: inputPath,
    entityId,
    collection,
    useCache: t1
  } = t0;
  const useCache = t1 === void 0 ? false : t1;
  const dataSource = useDataSource();
  const navigationController = useNavigationController();
  let t2;
  if ($[0] !== inputPath || $[1] !== navigationController) {
    t2 = navigationController.resolveAliasesFrom(inputPath);
    $[0] = inputPath;
    $[1] = navigationController;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  const path = t2;
  const context = useFireCMSContext();
  const [entity, setEntity] = useState();
  const [dataLoading, setDataLoading] = useState(true);
  const [dataLoadingError, setDataLoadingError] = useState();
  let t3;
  if ($[3] !== collection || $[4] !== context || $[5] !== dataSource || $[6] !== entityId || $[7] !== path || $[8] !== useCache) {
    t3 = () => {
      setDataLoading(true);
      const onEntityUpdate = async (updatedEntity) => {
        if (collection.callbacks?.onFetch && updatedEntity) {
          try {
            updatedEntity = await collection.callbacks.onFetch({
              collection,
              path,
              entity: updatedEntity,
              context
            });
          } catch (t42) {
            const e2 = t42;
            console.error(e2);
          }
        }
        CACHE[`${path}/${entityId}`] = updatedEntity;
        setEntity(updatedEntity);
        setDataLoading(false);
        setDataLoadingError(void 0);
      };
      const onError = (error) => {
        console.error("ERROR fetching entity", error);
        setDataLoading(false);
        setEntity(void 0);
        setDataLoadingError(error);
      };
      if (entityId && useCache && CACHE[`${path}/${entityId}`]) {
        setEntity(CACHE[`${path}/${entityId}`]);
        setDataLoading(false);
        setDataLoadingError(void 0);
        return _temp$p;
      } else {
        if (entityId && path && collection) {
          if (dataSource.listenEntity) {
            return dataSource.listenEntity({
              path,
              entityId,
              collection,
              onUpdate: onEntityUpdate,
              onError
            });
          } else {
            dataSource.fetchEntity({
              path,
              entityId,
              collection
            }).then(onEntityUpdate).catch(onError);
            return _temp2$c;
          }
        } else {
          onEntityUpdate(void 0);
          return _temp3$4;
        }
      }
    };
    $[3] = collection;
    $[4] = context;
    $[5] = dataSource;
    $[6] = entityId;
    $[7] = path;
    $[8] = useCache;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  let t4;
  if ($[10] !== entityId || $[11] !== path) {
    t4 = [entityId, path];
    $[10] = entityId;
    $[11] = path;
    $[12] = t4;
  } else {
    t4 = $[12];
  }
  useEffect(t3, t4);
  let t5;
  if ($[13] !== dataLoading || $[14] !== dataLoadingError || $[15] !== entity) {
    t5 = {
      entity,
      dataLoading,
      dataLoadingError
    };
    $[13] = dataLoading;
    $[14] = dataLoadingError;
    $[15] = entity;
    $[16] = t5;
  } else {
    t5 = $[16];
  }
  return t5;
}
function _temp3$4() {
}
function _temp2$c() {
}
function _temp$p() {
}
async function saveEntityWithCallbacks({
  collection,
  path,
  entityId,
  values,
  previousValues,
  status,
  dataSource,
  context,
  onSaveSuccess,
  onSaveFailure,
  onPreSaveHookError,
  onSaveSuccessHookError
}) {
  if (status !== "new" && !entityId) {
    throw new Error("Entity id must be specified when updating an existing entity");
  }
  let updatedValues;
  const customizationController = context.customizationController;
  const resolvedPath = context.navigation.resolveAliasesFrom(path);
  const callbacks = collection.callbacks;
  if (callbacks?.onPreSave) {
    try {
      const resolvedCollection = resolveCollection({
        collection,
        path,
        values: previousValues,
        entityId,
        propertyConfigs: customizationController.propertyConfigs
      });
      updatedValues = await callbacks.onPreSave({
        collection: resolvedCollection,
        path,
        resolvedPath,
        entityId,
        values,
        previousValues,
        status,
        context
      });
    } catch (e2) {
      console.error(e2);
      if (onPreSaveHookError) onPreSaveHookError(e2);
      return;
    }
  } else {
    updatedValues = values;
  }
  console.debug("Saving entity", {
    entityId,
    updatedValues,
    collection
  });
  return dataSource.saveEntity({
    collection,
    path: resolvedPath,
    entityId,
    values: updatedValues,
    previousValues,
    status
  }).then((entity) => {
    try {
      if (callbacks?.onSaveSuccess) {
        const resolvedCollection = resolveCollection({
          collection,
          path,
          values: updatedValues,
          entityId,
          propertyConfigs: customizationController.propertyConfigs
        });
        callbacks.onSaveSuccess({
          collection: resolvedCollection,
          path,
          resolvedPath,
          entityId: entity.id,
          values: updatedValues,
          previousValues,
          status,
          context
        });
      }
    } catch (e2) {
      if (onSaveSuccessHookError) onSaveSuccessHookError(e2);
    }
    if (onSaveSuccess) onSaveSuccess(entity);
  }).catch((e2) => {
    console.error("!!!", e2);
    if (callbacks?.onSaveFailure) {
      const resolvedCollection = resolveCollection({
        collection,
        path,
        values: updatedValues,
        entityId,
        propertyConfigs: customizationController.propertyConfigs
      });
      callbacks.onSaveFailure({
        collection: resolvedCollection,
        path,
        resolvedPath,
        entityId,
        values: updatedValues,
        previousValues,
        status,
        context
      });
    }
    if (onSaveFailure) onSaveFailure(e2);
  });
}
async function deleteEntityWithCallbacks({
  dataSource,
  entity,
  collection,
  callbacks,
  onDeleteSuccess,
  onDeleteFailure,
  onPreDeleteHookError,
  onDeleteSuccessHookError,
  context
}) {
  console.debug("Deleting entity", entity.path, entity.id);
  const entityDeleteProps = {
    entity,
    collection,
    entityId: entity.id,
    path: entity.path,
    context
  };
  if (callbacks?.onPreDelete) {
    try {
      await callbacks.onPreDelete(entityDeleteProps);
    } catch (e2) {
      console.error(e2);
      if (onPreDeleteHookError) onPreDeleteHookError(entity, e2);
      return false;
    }
  }
  return dataSource.deleteEntity({
    entity,
    collection
  }).then(() => {
    onDeleteSuccess && onDeleteSuccess(entity);
    try {
      if (callbacks?.onDelete) {
        callbacks.onDelete(entityDeleteProps);
      }
      return true;
    } catch (e2) {
      if (onDeleteSuccessHookError) onDeleteSuccessHookError(entity, e2);
      return false;
    }
  }).catch((e2) => {
    if (onDeleteFailure) onDeleteFailure(entity, e2);
    return false;
  });
}
function resolveNavigationFrom({
  path,
  context
}) {
  const dataSource = context.dataSource;
  const navigation = context.navigation;
  if (!navigation) {
    throw Error("Calling getNavigationFrom, but main navigation has not yet been initialised");
  }
  const navigationEntries = getNavigationEntriesFromPathInternal({
    path,
    collections: navigation.collections ?? []
  });
  const resultPromises = navigationEntries.map((entry) => {
    if (entry.type === "collection") {
      return Promise.resolve(entry);
    } else if (entry.type === "entity") {
      const collection = navigation.getCollection(entry.path);
      if (!collection) {
        throw Error(`No collection defined in the navigation for the entity with path ${entry.path}`);
      }
      return dataSource.fetchEntity({
        path: entry.path,
        entityId: entry.entityId,
        collection
      }).then((entity) => {
        if (!entity) return void 0;
        return {
          ...entry,
          entity
        };
      });
    } else if (entry.type === "custom_view") {
      return Promise.resolve(entry);
    } else {
      throw Error("Unmapped element in useEntitiesFromPath");
    }
  }).filter((v) => Boolean(v));
  return Promise.all(resultPromises);
}
function useResolvedNavigationFrom(t0) {
  const $ = c_1(9);
  const {
    path
  } = t0;
  const context = useFireCMSContext();
  const [data, setData] = useState();
  const [dataLoading, setDataLoading] = useState(false);
  const [dataLoadingError, setDataLoadingError] = useState();
  let t1;
  let t2;
  if ($[0] !== context || $[1] !== path) {
    t1 = () => {
      const navigation = context.navigation;
      if (navigation) {
        setDataLoading(true);
        setDataLoadingError(void 0);
        resolveNavigationFrom({
          path,
          context
        }).then((res) => {
          setData(res);
        }).catch((e2) => setDataLoadingError(e2)).finally(() => setDataLoading(false));
      }
    };
    t2 = [path, context];
    $[0] = context;
    $[1] = path;
    $[2] = t1;
    $[3] = t2;
  } else {
    t1 = $[2];
    t2 = $[3];
  }
  useEffect(t1, t2);
  if (!context.navigation) {
    let t32;
    if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
      t32 = {
        dataLoading: true
      };
      $[4] = t32;
    } else {
      t32 = $[4];
    }
    return t32;
  }
  let t3;
  if ($[5] !== data || $[6] !== dataLoading || $[7] !== dataLoadingError) {
    t3 = {
      data,
      dataLoading,
      dataLoadingError
    };
    $[5] = data;
    $[6] = dataLoading;
    $[7] = dataLoadingError;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  return t3;
}
const useModeController = () => {
  return useContext(ModeControllerContext);
};
const useClipboard = (options) => {
  const {
    onSuccess,
    onError,
    disableClipboardAPI = false,
    copiedDuration
  } = options || {};
  const ref = useRef(null);
  const [isCoppied, setIsCoppied] = useState(false);
  const [clipboard, setClipbaord] = useState("");
  useEffect(() => {
    if (copiedDuration) setTimeout(() => setIsCoppied(false), copiedDuration);
  }, [isCoppied]);
  const isSupported = () => navigator.clipboard !== void 0;
  const handleError = useCallback((error) => {
    if (onError) onError(error);
    else throw new Error(error);
  }, [onError]);
  const handleSuccess = useCallback((text) => {
    if (onSuccess) onSuccess(text);
    setIsCoppied(true);
    setClipbaord(text);
  }, [onSuccess]);
  const copyToClipboard = useCallback((text_0) => {
    navigator.clipboard.writeText(text_0).then(() => handleSuccess(text_0)).catch((err) => {
      handleError(err);
      setIsCoppied(false);
    });
  }, [handleError, handleSuccess]);
  const clearClipboard = () => {
    if (isSupported()) {
      navigator.clipboard.writeText("");
    }
  };
  const copy2 = (text_1) => action("copy", typeof text_1 === "object" ? void 0 : text_1);
  const cut2 = () => action("cut");
  const action = useCallback((operation = "copy", text_2) => {
    const element = ref.current;
    const isInput = element && (element.tagName === "INPUT" || element.tagName === "TEXTAREA");
    const input = ref.current;
    if (isSupported() && !disableClipboardAPI) {
      if (text_2) {
        copyToClipboard(text_2);
      } else if (element) {
        if (isInput) {
          copyToClipboard(input.value);
          if (operation === "cut") {
            input.value = "";
          }
        } else {
          copyToClipboard(element.innerText);
        }
      } else {
        handleError("Both the ref & text were undefined");
      }
    }
  }, [disableClipboardAPI, copyToClipboard, handleError]);
  return {
    ref,
    isCoppied,
    clipboard,
    clearClipboard,
    isSupported,
    copy: copy2,
    cut: cut2
  };
};
const breakpoints = {
  xs: 0,
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  "2xl": 1536,
  "3xl": 1920
};
let isLargeLayoutGlobal = checkLargeLayout("lg");
const listeners = [];
const notifyListeners = () => {
  listeners.forEach((listener) => listener(isLargeLayoutGlobal));
};
if (typeof window !== "undefined") window.addEventListener("resize", () => {
  const newIsLargeLayout = checkLargeLayout("lg");
  if (newIsLargeLayout !== isLargeLayoutGlobal) {
    isLargeLayoutGlobal = newIsLargeLayout;
    notifyListeners();
  }
});
const useLargeLayout = () => {
  const $ = c_1(2);
  const [isLargeLayout, setIsLargeLayout] = useState(isLargeLayoutGlobal);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      const listener = (newIsLargeLayout) => {
        setIsLargeLayout(newIsLargeLayout);
      };
      listeners.push(listener);
      setIsLargeLayout(isLargeLayoutGlobal);
      return () => {
        const index2 = listeners.indexOf(listener);
        if (index2 > -1) {
          listeners.splice(index2, 1);
        }
      };
    };
    t1 = [];
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  useEffect(t0, t1);
  return isLargeLayout;
};
function checkLargeLayout(breakpoint = "lg") {
  if (typeof window === "undefined") return false;
  return window.matchMedia(`(min-width: ${breakpoints[breakpoint] + 1}px)`).matches;
}
function ErrorTooltip(props) {
  const $ = c_1(2);
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { ...props, tooltipClassName: "!text-red-500 bg-red-50", children: props.children });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ErrorView(t0) {
  const $ = c_1(11);
  const {
    title,
    error,
    tooltip
  } = t0;
  const component = error instanceof Error ? error.message : error;
  console.warn("ErrorView", error);
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorIcon, { className: "mx-2", size: "small", color: "error" });
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let t2;
  if ($[1] !== title) {
    t2 = title && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", className: "font-medium", children: title });
    $[1] = title;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  let t3;
  if ($[3] !== component) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: component });
    $[3] = component;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== t2 || $[6] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center m-2", children: [
      t1,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pl-4", children: [
        t2,
        t3
      ] })
    ] });
    $[5] = t2;
    $[6] = t3;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  const body = t4;
  if (tooltip) {
    let t5;
    if ($[8] !== body || $[9] !== tooltip) {
      t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorTooltip, { title: tooltip, children: body });
      $[8] = body;
      $[9] = tooltip;
      $[10] = t5;
    } else {
      t5 = $[10];
    }
    return t5;
  }
  return body;
}
function EntityView({
  entity,
  collection,
  path,
  className
}) {
  const customizationController = useCustomizationController();
  const resolvedCollection = useMemo(() => resolveCollection({
    collection,
    path,
    entityId: entity.id,
    values: entity.values,
    propertyConfigs: customizationController.propertyConfigs
  }), [collection, path, entity, customizationController.propertyConfigs]);
  const properties = resolvedCollection.properties;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full " + className, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full mb-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cls(defaultBorderMixin, "flex justify-between py-2 border-b last:border-b-0"), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center w-1/4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "pl-2 text-sm text-surface-600", children: "Id" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-grow p-2 ml-2 w-3/4 text-surface-900 dark:text-white min-h-[56px] flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "flex-grow mr-2", children: entity.id }),
        customizationController?.entityLinkBuilder && /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: customizationController.entityLinkBuilder({
          entity
        }), rel: "noopener noreferrer", target: "_blank", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(OpenInNewIcon, { size: "small" }) }) })
      ] })
    ] }),
    Object.entries(properties).map(([key, property2]) => {
      const value = entity.values?.[key];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cls(defaultBorderMixin, "flex justify-between py-2 border-b last:border-b-0"), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center w-1/4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "pl-2 text-sm text-surface-600", children: property2.name }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow p-2 ml-2 w-3/4 text-surface-900 dark:text-white min-h-[56px] flex items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PropertyPreview,
          {
            propertyKey: key,
            value,
            property: property2,
            size: "medium"
          }
        ) })
      ] }, `reference_previews_${key}`);
    })
  ] }) });
}
function VirtualTableInput(props) {
  const $ = c_1(22);
  const ref = React__default.useRef(null);
  const {
    value,
    multiline,
    updateValue,
    focused
  } = props;
  const prevValue = useRef(value);
  const [internalValue, setInternalValue] = useState(value);
  const focusedState = useRef(false);
  let t0;
  if ($[0] !== internalValue || $[1] !== value) {
    t0 = () => {
      if (prevValue.current !== value && value !== internalValue) {
        setInternalValue(value);
      }
      prevValue.current = value;
    };
    $[0] = internalValue;
    $[1] = value;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  let t1;
  if ($[3] !== value) {
    t1 = [value];
    $[3] = value;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  useEffect(t0, t1);
  let t2;
  if ($[5] !== internalValue || $[6] !== updateValue || $[7] !== value) {
    t2 = () => {
      const emptyInitialValue = !value;
      if (emptyInitialValue && !internalValue) {
        return;
      }
      if (internalValue !== value) {
        prevValue.current = internalValue;
        updateValue(internalValue);
      }
    };
    $[5] = internalValue;
    $[6] = updateValue;
    $[7] = value;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  const doUpdate = t2;
  useDebouncedCallback(internalValue, doUpdate, !focused, 2e3);
  let t3;
  let t4;
  if ($[9] !== focused) {
    t3 = () => {
      if (ref.current && focused && !focusedState.current) {
        focusedState.current = true;
        ref.current.focus({
          preventScroll: true
        });
        ref.current.selectionStart = ref.current.value.length;
        ref.current.selectionEnd = ref.current.value.length;
      } else {
        focusedState.current = focused;
      }
    };
    t4 = [focused, ref];
    $[9] = focused;
    $[10] = t3;
    $[11] = t4;
  } else {
    t3 = $[10];
    t4 = $[11];
  }
  useEffect(t3, t4);
  let t5;
  if ($[12] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = {
      padding: 0,
      margin: 0,
      width: "100%",
      color: "unset",
      fontWeight: "unset",
      lineHeight: "unset",
      fontSize: "unset",
      fontFamily: "unset",
      background: "unset",
      border: "unset",
      resize: "none",
      outline: "none"
    };
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  const t6 = internalValue ?? "";
  let t7;
  if ($[13] !== multiline) {
    t7 = (evt) => {
      const newValue = evt.target.value;
      if (multiline || !newValue.endsWith("\n")) {
        setInternalValue(newValue);
      }
    };
    $[13] = multiline;
    $[14] = t7;
  } else {
    t7 = $[14];
  }
  let t8;
  if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = () => {
      focusedState.current = true;
    };
    $[15] = t8;
  } else {
    t8 = $[15];
  }
  let t9;
  if ($[16] !== doUpdate) {
    t9 = () => {
      focusedState.current = false;
      doUpdate();
    };
    $[16] = doUpdate;
    $[17] = t9;
  } else {
    t9 = $[17];
  }
  let t10;
  if ($[18] !== t6 || $[19] !== t7 || $[20] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(TextareaAutosize, { className: focusedDisabled, ref, style: t5, value: t6, onChange: t7, onFocus: t8, onBlur: t9 });
    $[18] = t6;
    $[19] = t7;
    $[20] = t9;
    $[21] = t10;
  } else {
    t10 = $[21];
  }
  return t10;
}
function VirtualTableSelect(props) {
  const $ = c_1(19);
  const {
    enumValues,
    internalValue,
    disabled,
    small,
    focused,
    updateValue,
    multiple,
    valueType
  } = props;
  const validValue = Array.isArray(internalValue) && multiple || !Array.isArray(internalValue) && !multiple;
  const ref = React__default.useRef(null);
  let t0;
  let t1;
  if ($[0] !== focused) {
    t0 = () => {
      if (ref.current && focused) {
        ref.current?.focus({
          preventScroll: true
        });
      }
    };
    t1 = [focused, ref];
    $[0] = focused;
    $[1] = t0;
    $[2] = t1;
  } else {
    t0 = $[1];
    t1 = $[2];
  }
  useEffect(t0, t1);
  let t2;
  if ($[3] !== multiple || $[4] !== updateValue || $[5] !== valueType) {
    t2 = (updatedValue) => {
      console.trace("onChange");
      if (valueType === "number") {
        if (multiple) {
          const newValue = updatedValue.map(_temp$o);
          updateValue(newValue);
        } else {
          updateValue(parseFloat(updatedValue));
        }
      } else {
        if (valueType === "string") {
          if (!updatedValue) {
            updateValue(null);
          } else {
            updateValue(updatedValue);
          }
        } else {
          throw Error("Missing mapping in TableSelect");
        }
      }
    };
    $[3] = multiple;
    $[4] = updateValue;
    $[5] = valueType;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  const onChange = t2;
  let t3;
  if ($[7] !== enumValues || $[8] !== small) {
    t3 = (enumKey) => /* @__PURE__ */ jsxRuntimeExports.jsx(EnumValuesChip, { enumKey: String(enumKey), enumValues, size: small ? "small" : "medium" }, `${enumKey}`);
    $[7] = enumValues;
    $[8] = small;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  const renderValue = t3;
  let t4;
  if ($[10] !== disabled || $[11] !== enumValues || $[12] !== internalValue || $[13] !== multiple || $[14] !== onChange || $[15] !== renderValue || $[16] !== small || $[17] !== validValue) {
    t4 = multiple ? /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSelect, { inputRef: ref, className: "w-full h-full p-0 bg-transparent", position: "item-aligned", disabled, includeClear: false, useChips: false, value: validValue ? internalValue.map(_temp2$b) : [], onValueChange: onChange, children: enumValues?.map((enumConfig) => /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSelectItem, { value: String(enumConfig.id), children: /* @__PURE__ */ jsxRuntimeExports.jsx(EnumValuesChip, { enumKey: enumConfig.id, enumValues, size: small ? "small" : "medium" }) }, enumConfig.id)) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Select, { inputRef: ref, size: "large", fullWidth: true, className: "w-full h-full p-0 bg-transparent", position: "item-aligned", disabled, padding: false, value: validValue ? internalValue?.toString() : "", onValueChange: onChange, renderValue, children: enumValues?.map((enumConfig_0) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: String(enumConfig_0.id), children: /* @__PURE__ */ jsxRuntimeExports.jsx(EnumValuesChip, { enumKey: enumConfig_0.id, enumValues, size: small ? "small" : "medium" }) }, enumConfig_0.id)) });
    $[10] = disabled;
    $[11] = enumValues;
    $[12] = internalValue;
    $[13] = multiple;
    $[14] = onChange;
    $[15] = renderValue;
    $[16] = small;
    $[17] = validValue;
    $[18] = t4;
  } else {
    t4 = $[18];
  }
  return t4;
}
function _temp2$b(v_0) {
  return v_0.toString();
}
function _temp$o(v) {
  return parseFloat(v);
}
function VirtualTableNumberInput(props) {
  const {
    align,
    value,
    updateValue,
    focused
  } = props;
  const propStringValue = value && typeof value === "number" ? value.toString() : "";
  const [internalValue, setInternalValue] = useState(propStringValue);
  const prevValue = useRef(value);
  useEffect(() => {
    if (prevValue.current !== value && String(value) !== internalValue) setInternalValue(value ? value.toString() : null);
    prevValue.current = value;
  }, [value]);
  const doUpdate = React__default.useCallback(() => {
    if (internalValue !== propStringValue) {
      if (internalValue !== void 0 && internalValue !== null) {
        const numberValue = parseFloat(internalValue);
        if (isNaN(numberValue)) return;
        if (numberValue !== void 0 && numberValue !== null) updateValue(numberValue);
      } else {
        updateValue(null);
      }
    }
  }, [internalValue, value]);
  useDebouncedCallback(internalValue, doUpdate, !focused, 2e3);
  useEffect(() => {
    if (!focused && propStringValue !== internalValue) setInternalValue(value !== void 0 && value !== null ? value.toString() : null);
  }, [value, focused]);
  const ref = React__default.useRef(null);
  useEffect(() => {
    if (ref.current && focused) {
      ref.current.focus({
        preventScroll: true
      });
    }
  }, [focused, ref]);
  const regexp = /^-?[0-9]+[,.]?[0-9]*$/;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("input", { ref, className: cls("w-full text-right p-0 m-0 bg-transparent border-none resize-none outline-none font-normal leading-normal text-unset", focusedDisabled), style: {
    textAlign: align
  }, value: internalValue ?? "", onChange: (evt) => {
    const newValue = evt.target.value.replace(",", ".");
    if (newValue.length === 0) setInternalValue(null);
    if (regexp.test(newValue) || newValue.startsWith("-")) setInternalValue(newValue);
  } });
}
function VirtualTableSwitch(props) {
  const $ = c_1(6);
  const {
    internalValue,
    updateValue,
    focused
  } = props;
  const ref = React__default.useRef(null);
  let t0;
  let t1;
  if ($[0] !== focused) {
    t0 = () => {
      if (ref.current && focused) {
        ref.current.focus({
          preventScroll: true
        });
      }
    };
    t1 = [focused, ref];
    $[0] = focused;
    $[1] = t0;
    $[2] = t1;
  } else {
    t0 = $[1];
    t1 = $[2];
  }
  useEffect(t0, t1);
  const t2 = Boolean(internalValue);
  let t3;
  if ($[3] !== t2 || $[4] !== updateValue) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanSwitch, { ref, size: "small", value: t2, onValueChange: updateValue });
    $[3] = t2;
    $[4] = updateValue;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  return t3;
}
function VirtualTableDateField(props) {
  const $ = c_1(9);
  const {
    locale
  } = useCustomizationController();
  const {
    mode,
    internalValue,
    updateValue
  } = props;
  const t0 = internalValue ?? void 0;
  let t1;
  if ($[0] !== updateValue) {
    t1 = (dateValue) => updateValue(dateValue ?? null);
    $[0] = updateValue;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  let t3;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = cls("w-full h-full", focusedDisabled);
    t3 = cls("w-full h-full", focusedDisabled);
    $[2] = t2;
    $[3] = t3;
  } else {
    t2 = $[2];
    t3 = $[3];
  }
  let t4;
  if ($[4] !== locale || $[5] !== mode || $[6] !== t0 || $[7] !== t1) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(DateTimeField, { value: t0, onChange: t1, size: "large", invisible: true, inputClassName: t2, className: t3, mode, locale });
    $[4] = locale;
    $[5] = mode;
    $[6] = t0;
    $[7] = t1;
    $[8] = t4;
  } else {
    t4 = $[8];
  }
  return t4;
}
class ErrorBoundary2 extends React__default.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: null
    };
  }
  // eslint-disable-next-line n/handle-callback-err
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error(error);
  }
  render() {
    if (this.state.error) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col m-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center m-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorIcon, { color: "error", size: "small" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-4", children: "Error" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", children: this.state.error?.message ?? "See the error in the console" })
      ] });
    }
    return this.props.children;
  }
}
const SMALL_THUMBNAIL = 40;
const MEDIUM_THUMBNAIL = 100;
const LARGE_THUMBNAIL = 200;
function getThumbnailMeasure(size2) {
  if (size2 === "small") return SMALL_THUMBNAIL;
  else if (size2 === "medium") return MEDIUM_THUMBNAIL;
  else if (size2 === "large") return LARGE_THUMBNAIL;
  else throw Error("Thumbnail size not mapped");
}
function getPreviewSizeFrom(size2) {
  switch (size2) {
    case "xs":
    case "s":
      return "small";
    case "m":
      return "medium";
    case "l":
    case "xl":
      return "large";
    default:
      throw Error("Missing mapping value in getPreviewSizeFrom: " + size2);
  }
}
function useStorageUploadController({
  entityId,
  entityValues,
  path,
  value,
  property: property2,
  propertyKey,
  storageSource,
  disabled,
  onChange
}) {
  const storage = property2.dataType === "string" ? property2.storage : property2.dataType === "array" && property2.of.dataType === "string" ? property2.of.storage : void 0;
  const multipleFilesSupported = property2.dataType === "array";
  if (!storage) throw Error("Storage meta must be specified");
  const metadata = storage?.metadata;
  const size2 = multipleFilesSupported ? "medium" : "large";
  const compression = storage?.imageCompression;
  const internalInitialValue = (multipleFilesSupported ? value ?? [] : value ? [value] : []).map((entry) => ({
    id: getRandomId$2(),
    storagePathOrDownloadUrl: entry,
    metadata,
    size: size2
  }));
  const [initialValue, setInitialValue] = useState(value);
  const [internalValue, setInternalValue] = useState(internalInitialValue);
  useEffect(() => {
    if (!equal(initialValue, value)) {
      setInitialValue(value);
      setInternalValue(internalInitialValue);
    }
  }, [internalInitialValue, value, initialValue]);
  const resolvedProperty = resolveProperty({
    propertyOrBuilder: property2,
    values: entityValues
  });
  const fileNameBuilder = useCallback(async (file) => {
    if (storage.fileName) {
      const fileName = await resolveStorageFilenameString({
        input: storage.fileName,
        storage,
        values: entityValues,
        entityId,
        path,
        property: resolvedProperty,
        file,
        propertyKey
      });
      if (!fileName || fileName.length === 0) {
        throw Error("You need to return a valid filename");
      }
      return fileName;
    }
    return randomString() + "_" + file.name;
  }, [entityId, entityValues, path, resolvedProperty, propertyKey, storage]);
  const storagePathBuilder = useCallback((file_0) => {
    return resolveStoragePathString({
      input: storage.storagePath,
      storage,
      values: entityValues,
      entityId,
      path,
      property: resolvedProperty,
      file: file_0,
      propertyKey
    }) ?? "/";
  }, [entityId, entityValues, path, resolvedProperty, propertyKey, storage]);
  const onFileUploadComplete = useCallback(async (uploadedPath, entry_0, metadata_0) => {
    console.debug("onFileUploadComplete", uploadedPath, entry_0);
    let uploadPathOrDownloadUrl = uploadedPath;
    if (storage.storeUrl) {
      uploadPathOrDownloadUrl = (await storageSource.getDownloadURL(uploadedPath)).url;
    }
    if (storage.postProcess && uploadPathOrDownloadUrl) {
      uploadPathOrDownloadUrl = await storage.postProcess(uploadPathOrDownloadUrl);
    }
    if (!uploadPathOrDownloadUrl) {
      console.warn("uploadPathOrDownloadUrl is null");
      return;
    }
    let newValue;
    entry_0.storagePathOrDownloadUrl = uploadPathOrDownloadUrl;
    entry_0.metadata = metadata_0;
    newValue = [...internalValue];
    newValue = removeDuplicates(newValue);
    setInternalValue(newValue);
    const fieldValue = newValue.filter((e2) => !!e2.storagePathOrDownloadUrl).map((e_0) => e_0.storagePathOrDownloadUrl);
    if (multipleFilesSupported) {
      onChange(fieldValue);
    } else {
      onChange(fieldValue ? fieldValue[0] : null);
    }
  }, [internalValue, multipleFilesSupported, onChange, storage, storageSource]);
  const onFilesAdded = useCallback(async (acceptedFiles) => {
    if (!acceptedFiles.length || disabled) return;
    let newInternalValue;
    if (multipleFilesSupported) {
      newInternalValue = [...internalValue, ...await Promise.all(acceptedFiles.map(async (file_1) => {
        if (compression && compressionFormat(file_1)) {
          file_1 = await resizeAndCompressImage(file_1, compression);
        }
        return {
          id: getRandomId$2(),
          file: file_1,
          fileName: await fileNameBuilder(file_1),
          metadata,
          size: size2
        };
      }))];
    } else {
      let file_2 = acceptedFiles[0];
      if (compression && compressionFormat(file_2)) {
        file_2 = await resizeAndCompressImage(file_2, compression);
      }
      newInternalValue = [{
        id: getRandomId$2(),
        file: file_2,
        fileName: await fileNameBuilder(file_2),
        metadata,
        size: size2
      }];
    }
    newInternalValue = removeDuplicates(newInternalValue);
    setInternalValue(newInternalValue);
  }, [disabled, fileNameBuilder, internalValue, metadata, multipleFilesSupported, size2]);
  return {
    internalValue,
    setInternalValue,
    storage,
    fileNameBuilder,
    storagePathBuilder,
    onFileUploadComplete,
    onFilesAdded,
    multipleFilesSupported
  };
}
function removeDuplicates(items2) {
  return items2.filter((item, i) => {
    return (items2.map((v) => v.storagePathOrDownloadUrl).indexOf(item.storagePathOrDownloadUrl) === i || !item.storagePathOrDownloadUrl) && (items2.map((v) => v.file).indexOf(item.file) === i || !item.file);
  });
}
function getRandomId$2() {
  return Math.floor(Math.random() * Math.floor(Number.MAX_SAFE_INTEGER));
}
const supportedTypes = {
  "image/jpeg": "JPEG",
  "image/png": "PNG",
  "image/webp": "WEBP"
};
const compressionFormat = (file) => supportedTypes[file.type] ? supportedTypes[file.type] : null;
const defaultQuality = 100;
const resizeAndCompressImage = (file, compression) => new Promise((resolve) => {
  const inputQuality = compression.quality === void 0 ? defaultQuality : compression.quality;
  const quality = inputQuality >= 0 ? inputQuality <= 100 ? inputQuality : 100 : 100;
  const format2 = compressionFormat(file);
  if (!format2) {
    throw Error("resizeAndCompressImage: Unsupported image format");
  }
  Resizer.imageFileResizer(file, compression.maxWidth || Number.MAX_VALUE, compression.maxHeight || Number.MAX_VALUE, format2, quality, 0, (file2) => resolve(file2), "file");
});
function StorageUploadProgress({
  storagePath,
  entry,
  metadata,
  onFileUploadComplete,
  imageSize,
  simple
}) {
  const storageSource = useStorageSource();
  const snackbarController = useSnackbarController();
  const [error, setError] = React__default.useState();
  const [loading, setLoading] = React__default.useState(false);
  const mounted = React__default.useRef(false);
  const uploading = React__default.useRef(false);
  const upload = useCallback((file, fileName) => {
    if (uploading.current) return;
    uploading.current = true;
    setError(void 0);
    setLoading(true);
    storageSource.uploadFile({
      file,
      fileName,
      path: storagePath,
      metadata
    }).then(async ({
      path
    }) => {
      console.debug("Upload successful", path);
      await onFileUploadComplete(path, entry, metadata);
      if (mounted.current) setLoading(false);
    }).catch((e2) => {
      console.warn("Upload error", e2);
      if (mounted.current) {
        setError(e2);
        setLoading(false);
        snackbarController.open({
          type: "error",
          message: "Error uploading file: " + e2.message
        });
      }
    }).finally(() => {
      uploading.current = false;
    });
  }, [entry, metadata, onFileUploadComplete, storageSource, storagePath]);
  React__default.useEffect(() => {
    mounted.current = true;
    if (entry.file) upload(entry.file, entry.fileName);
    return () => {
      mounted.current = false;
    };
  }, [entry.file, entry.fileName, upload]);
  if (simple) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `m-4 w-${imageSize} h-${imageSize}`, children: loading && /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { className: `w-${imageSize} h-${imageSize}` }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cls(paperMixin, "relative m-4 border-box flex items-center justify-center", `min-w-[${imageSize}px] min-h-[${imageSize}px]`), children: [
    loading && /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { className: "w-full h-full" }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView, { title: "Error uploading file", error })
  ] });
}
function EntityTableCellActions({
  showError,
  disabled,
  showExpandIcon,
  selected,
  openPopup,
  children
}) {
  const ref = useRef(null);
  const doOpenPopup = useCallback(() => {
    if (openPopup) {
      const cellRect = ref && ref?.current?.getBoundingClientRect();
      openPopup(cellRect);
    }
  }, []);
  const iconRef = useRef();
  useEffect(() => {
    if (iconRef.current && selected) {
      iconRef.current.focus({
        preventScroll: true
      });
    }
  }, [selected]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: (showError || !disabled && showExpandIcon) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref, className: "absolute top-0.5 right-0.5 flex items-center", children: [
    selected && children,
    selected && !disabled && showExpandIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { ref: iconRef, color: "inherit", size: "small", onClick: doOpenPopup, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { fill: "#888", width: "20", height: "20", viewBox: "0 0 24 24", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { className: "cls-2", d: "M20,5a1,1,0,0,0-1-1L14,4h0a1,1,0,0,0,0,2h2.57L13.29,9.29a1,1,0,0,0,0,1.42,1,1,0,0,0,1.42,0L18,7.42V10a1,1,0,0,0,1,1h0a1,1,0,0,0,1-1Z" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { className: "cls-2", d: "M10.71,13.29a1,1,0,0,0-1.42,0L6,16.57V14a1,1,0,0,0-1-1H5a1,1,0,0,0-1,1l0,5a1,1,0,0,0,1,1h5a1,1,0,0,0,0-2H7.42l3.29-3.29A1,1,0,0,0,10.71,13.29Z" })
    ] }) }),
    showError && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorTooltip, { side: "left", title: showError.message, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center", style: {
      width: 32,
      height: 32
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorIcon, { size: "small", color: "error" }) }) })
  ] }) });
}
const dropZoneClasses$1 = "max-w-full box-border relative pt-[2px] items-center border border-transparent outline-none rounded-md duration-200 ease-[cubic-bezier(0.4,0,0.2,1)] focus:border-primary-solid";
const activeDropClasses$1 = "pt-0 border-2 border-solid";
const acceptDropClasses$1 = "transition-colors duration-200 ease-[cubic-bezier(0,0,0.2,1)] border-2 border-solid border-green-500 bg-green-50 dark:bg-green-900";
const rejectDropClasses$1 = "transition-colors duration-200 ease-[cubic-bezier(0,0,0.2,1)] border-2 border-solid border-red-500 bg-red-50 dark:bg-red-900";
function TableStorageUpload(props) {
  const $ = c_1(27);
  const {
    propertyKey,
    error,
    selected,
    openPopup,
    value,
    disabled,
    property: property2,
    entity,
    path,
    previewSize,
    updateValue
  } = props;
  const storageSource = useStorageSource();
  let t0;
  if ($[0] !== disabled || $[1] !== entity.id || $[2] !== entity.values || $[3] !== path || $[4] !== property2 || $[5] !== propertyKey || $[6] !== storageSource || $[7] !== updateValue || $[8] !== value) {
    t0 = {
      entityValues: entity.values,
      entityId: entity.id,
      path,
      property: property2,
      propertyKey,
      storageSource,
      onChange: updateValue,
      value,
      disabled
    };
    $[0] = disabled;
    $[1] = entity.id;
    $[2] = entity.values;
    $[3] = path;
    $[4] = property2;
    $[5] = propertyKey;
    $[6] = storageSource;
    $[7] = updateValue;
    $[8] = value;
    $[9] = t0;
  } else {
    t0 = $[9];
  }
  const {
    internalValue,
    setInternalValue,
    onFilesAdded,
    storage,
    onFileUploadComplete,
    storagePathBuilder,
    multipleFilesSupported
  } = useStorageUploadController(t0);
  let t1;
  if ($[10] !== disabled || $[11] !== entity || $[12] !== error || $[13] !== internalValue || $[14] !== multipleFilesSupported || $[15] !== onFileUploadComplete || $[16] !== onFilesAdded || $[17] !== openPopup || $[18] !== previewSize || $[19] !== property2 || $[20] !== propertyKey || $[21] !== selected || $[22] !== setInternalValue || $[23] !== storage || $[24] !== storagePathBuilder || $[25] !== updateValue) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(StorageUpload$1, { internalValue, setInternalValue, name: propertyKey, disabled, autoFocus: false, openPopup, error, selected, property: property2, onChange: updateValue, entity, storagePathBuilder, storage, multipleFilesSupported, onFilesAdded, onFileUploadComplete, previewSize });
    $[10] = disabled;
    $[11] = entity;
    $[12] = error;
    $[13] = internalValue;
    $[14] = multipleFilesSupported;
    $[15] = onFileUploadComplete;
    $[16] = onFilesAdded;
    $[17] = openPopup;
    $[18] = previewSize;
    $[19] = property2;
    $[20] = propertyKey;
    $[21] = selected;
    $[22] = setInternalValue;
    $[23] = storage;
    $[24] = storagePathBuilder;
    $[25] = updateValue;
    $[26] = t1;
  } else {
    t1 = $[26];
  }
  return t1;
}
function StorageUpload$1(t0) {
  const $ = c_1(64);
  const {
    property: property2,
    internalValue,
    openPopup,
    entity,
    selected,
    error,
    multipleFilesSupported,
    previewSize: previewSizeInput,
    disabled,
    autoFocus,
    storage,
    onFilesAdded,
    onFileUploadComplete,
    storagePathBuilder
  } = t0;
  const previewSize = previewSizeInput;
  if (multipleFilesSupported) {
    const arrayProperty = property2;
    if (Array.isArray(arrayProperty.of)) {
      throw Error("Using array properties instead of single one in `of` in ArrayProperty");
    }
    if (arrayProperty.of) {
      if (arrayProperty.of.dataType !== "string") {
        throw Error("Storage field using array must be of data type string");
      }
    } else {
      throw Error("Storage field using array must be of data type string");
    }
  }
  const metadata = storage?.metadata;
  const hasValue = Boolean(internalValue);
  const snackbarContext = useSnackbarController();
  let t1;
  if ($[0] !== storage.acceptedFiles) {
    t1 = storage.acceptedFiles ? storage.acceptedFiles.map(_temp$n).reduce(_temp2$a, {}) : void 0;
    $[0] = storage.acceptedFiles;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== snackbarContext || $[3] !== storage.maxSize) {
    t2 = (fileRejections, event) => {
      for (const fileRejection of fileRejections) {
        for (const error_0 of fileRejection.errors) {
          console.error("Error uploading file: ", error_0);
          if (error_0.code === "file-too-large") {
            snackbarContext.open({
              type: "error",
              message: `Error uploading file: File is larger than ${storage.maxSize} bytes`
            });
          } else {
            if (error_0.code === "file-invalid-type") {
              snackbarContext.open({
                type: "error",
                message: "Error uploading file: File type is not supported"
              });
            }
          }
        }
      }
    };
    $[2] = snackbarContext;
    $[3] = storage.maxSize;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  let t3;
  if ($[5] !== disabled || $[6] !== onFilesAdded || $[7] !== storage.maxSize || $[8] !== t1 || $[9] !== t2) {
    t3 = {
      accept: t1,
      disabled,
      maxSize: storage.maxSize,
      noClick: true,
      noKeyboard: true,
      onDrop: onFilesAdded,
      onDropRejected: t2
    };
    $[5] = disabled;
    $[6] = onFilesAdded;
    $[7] = storage.maxSize;
    $[8] = t1;
    $[9] = t2;
    $[10] = t3;
  } else {
    t3 = $[10];
  }
  const {
    open,
    getRootProps,
    getInputProps,
    isDragActive,
    isDragAccept,
    isDragReject
  } = useDropzone(t3);
  let t4;
  if ($[11] !== getRootProps) {
    t4 = getRootProps();
    $[11] = getRootProps;
    $[12] = t4;
  } else {
    t4 = $[12];
  }
  let rootProps;
  if ($[13] !== t4) {
    ({
      ...rootProps
    } = t4);
    $[13] = t4;
    $[14] = rootProps;
  } else {
    rootProps = $[14];
  }
  const helpText = multipleFilesSupported ? "Drag 'n' drop some files here, or click here to edit" : "Drag 'n' drop a file here, or click here edit";
  const renderProperty = multipleFilesSupported ? property2.of : property2;
  let t5;
  let t6;
  if ($[15] !== previewSize) {
    t6 = getThumbnailMeasure(previewSize);
    $[15] = previewSize;
    $[16] = t6;
  } else {
    t6 = $[16];
  }
  t5 = t6;
  const imageSize = t5;
  const showError = !disabled && error;
  const t7 = `justify-${hasValue ? "start" : "center"}`;
  const t8 = isDragActive ? activeDropClasses$1 : "";
  const t9 = isDragAccept ? acceptDropClasses$1 : "";
  const t10 = isDragReject ? rejectDropClasses$1 : "";
  let t11;
  if ($[17] !== t10 || $[18] !== t7 || $[19] !== t8 || $[20] !== t9) {
    t11 = cls(dropZoneClasses$1, "relative w-full h-full flex", t7, t8, t9, t10);
    $[17] = t10;
    $[18] = t7;
    $[19] = t8;
    $[20] = t9;
    $[21] = t11;
  } else {
    t11 = $[21];
  }
  let t12;
  if ($[22] !== getInputProps) {
    t12 = getInputProps();
    $[22] = getInputProps;
    $[23] = t12;
  } else {
    t12 = $[23];
  }
  let t13;
  if ($[24] !== autoFocus || $[25] !== t12) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsx("input", { autoFocus, ...t12 });
    $[24] = autoFocus;
    $[25] = t12;
    $[26] = t13;
  } else {
    t13 = $[26];
  }
  let t14;
  if ($[27] !== entity || $[28] !== imageSize || $[29] !== internalValue || $[30] !== metadata || $[31] !== onFileUploadComplete || $[32] !== previewSize || $[33] !== renderProperty || $[34] !== storagePathBuilder) {
    let t152;
    if ($[36] !== entity || $[37] !== imageSize || $[38] !== metadata || $[39] !== onFileUploadComplete || $[40] !== previewSize || $[41] !== renderProperty || $[42] !== storagePathBuilder) {
      t152 = (entry, index2) => {
        let child;
        if (entry.storagePathOrDownloadUrl) {
          child = /* @__PURE__ */ jsxRuntimeExports.jsx(TableStorageItemPreview, { property: renderProperty, value: entry.storagePathOrDownloadUrl, entity, size: previewSize }, `storage_preview_${index2}`);
        } else {
          if (entry.file) {
            child = /* @__PURE__ */ jsxRuntimeExports.jsx(StorageUploadProgress, { entry, metadata, storagePath: storagePathBuilder(entry.file), onFileUploadComplete, imageSize, simple: true }, `storage_progress_${index2}`);
          }
        }
        return child;
      };
      $[36] = entity;
      $[37] = imageSize;
      $[38] = metadata;
      $[39] = onFileUploadComplete;
      $[40] = previewSize;
      $[41] = renderProperty;
      $[42] = storagePathBuilder;
      $[43] = t152;
    } else {
      t152 = $[43];
    }
    t14 = internalValue.map(t152);
    $[27] = entity;
    $[28] = imageSize;
    $[29] = internalValue;
    $[30] = metadata;
    $[31] = onFileUploadComplete;
    $[32] = previewSize;
    $[33] = renderProperty;
    $[34] = storagePathBuilder;
    $[35] = t14;
  } else {
    t14 = $[35];
  }
  let t15;
  if ($[44] !== helpText || $[45] !== internalValue || $[46] !== open) {
    t15 = !internalValue && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow m-2 max-w-[200px]", onClick: open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { className: "text-surface-400 dark:text-surface-600", variant: "body2", align: "center", children: helpText }) });
    $[44] = helpText;
    $[45] = internalValue;
    $[46] = open;
    $[47] = t15;
  } else {
    t15 = $[47];
  }
  const t16 = !disabled ? openPopup : void 0;
  let t17;
  if ($[48] === Symbol.for("react.memo_cache_sentinel")) {
    t17 = /* @__PURE__ */ jsxRuntimeExports.jsx(EditIcon, { size: "small", className: "text-surface-500" });
    $[48] = t17;
  } else {
    t17 = $[48];
  }
  let t18;
  if ($[49] !== open) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { color: "inherit", size: "small", onClick: open, children: t17 });
    $[49] = open;
    $[50] = t18;
  } else {
    t18 = $[50];
  }
  let t19;
  if ($[51] !== disabled || $[52] !== selected || $[53] !== showError || $[54] !== t16 || $[55] !== t18) {
    t19 = /* @__PURE__ */ jsxRuntimeExports.jsx(EntityTableCellActions, { showError, disabled, showExpandIcon: true, selected, openPopup: t16, children: t18 });
    $[51] = disabled;
    $[52] = selected;
    $[53] = showError;
    $[54] = t16;
    $[55] = t18;
    $[56] = t19;
  } else {
    t19 = $[56];
  }
  let t20;
  if ($[57] !== rootProps || $[58] !== t11 || $[59] !== t13 || $[60] !== t14 || $[61] !== t15 || $[62] !== t19) {
    t20 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ...rootProps, className: t11, children: [
      t13,
      t14,
      t15,
      t19
    ] });
    $[57] = rootProps;
    $[58] = t11;
    $[59] = t13;
    $[60] = t14;
    $[61] = t15;
    $[62] = t19;
    $[63] = t20;
  } else {
    t20 = $[63];
  }
  return t20;
}
function _temp2$a(a2, b) {
  return {
    ...a2,
    ...b
  };
}
function _temp$n(e2) {
  return {
    [e2]: []
  };
}
function TableStorageItemPreview(t0) {
  const $ = c_1(6);
  const {
    property: property2,
    value,
    size: size2
  } = t0;
  let t1;
  if ($[0] !== property2 || $[1] !== size2 || $[2] !== value) {
    t1 = value && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyPreview, { propertyKey: "ignore", value, property: property2, size: size2 }) });
    $[0] = property2;
    $[1] = size2;
    $[2] = value;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative p-2 max-w-full", children: t1 });
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}
function EntityPreview({
  actions,
  disabled,
  hover,
  collection: collectionProp,
  previewProperties,
  onClick,
  size: size2,
  includeId = true,
  includeEntityLink = true,
  entity
}) {
  const analyticsController = useAnalyticsController();
  const sideEntityController = useSideEntityController();
  const customizationController = useCustomizationController();
  const navigationController = useNavigationController();
  const collection = collectionProp ?? navigationController.getCollection(entity.path);
  if (!collection) {
    throw Error(`Couldn't find the corresponding collection view for the path: ${entity.path}`);
  }
  const resolvedCollection = React.useMemo(() => resolveCollection({
    collection,
    path: entity.path,
    values: entity.values,
    propertyConfigs: customizationController.propertyConfigs
  }), [collection]);
  const listProperties = useMemo(() => getEntityPreviewKeys(resolvedCollection, customizationController.propertyConfigs, previewProperties, size2 === "medium" || size2 === "large" ? 3 : 1), [previewProperties, resolvedCollection, size2]);
  const titleProperty = getEntityTitlePropertyKey(resolvedCollection, customizationController.propertyConfigs);
  const imagePropertyKey = getEntityImagePreviewPropertyKey(resolvedCollection);
  const imageProperty = imagePropertyKey ? resolvedCollection.properties[imagePropertyKey] : void 0;
  const usedImageProperty = imageProperty && "of" in imageProperty ? imageProperty.of : imageProperty;
  const restProperties = listProperties.filter((p2) => p2 !== titleProperty && p2 !== imagePropertyKey);
  const imageValue = imagePropertyKey ? getValueInPath(entity.values, imagePropertyKey) : void 0;
  const usedImageValue = imageProperty !== void 0 ? "of" in imageProperty ? (imageValue ?? []).length > 0 ? imageValue[0] : void 0 : imageValue : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(EntityPreviewContainer, { onClick: disabled ? void 0 : onClick, hover: disabled ? void 0 : hover, size: size2, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cls("flex w-10 h-10 ml-1 mr-2 shrink-0", size2 === "small" ? "my-0.5" : "m-2 self-start"), children: [
      usedImageProperty && usedImageValue && /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyPreview, { property: usedImageProperty, propertyKey: imagePropertyKey, size: "small", value: usedImageValue }),
      (!usedImageProperty || !usedImageValue) && /* @__PURE__ */ jsxRuntimeExports.jsx(IconForView, { collectionOrView: collection, color: "primary", size: size2, className: "m-auto p-1" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col grow-1 w-full m-1 shrink-1", style: {
      "maxWidth": "calc(100% - 96px)"
    }, children: [
      size2 !== "small" && includeId && (entity ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "block whitespace-nowrap overflow-hidden truncate", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "disabled", className: "font-mono", children: entity.id }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, {})),
      titleProperty && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "truncate my-0.5 text-sm font-medium", children: entity ? /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyPreview, { propertyKey: titleProperty, value: getValueInPath(entity.values, titleProperty), property: resolvedCollection.properties[titleProperty], size: "large" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonPropertyComponent, { property: resolvedCollection.properties[titleProperty], size: "large" }) }),
      restProperties && restProperties.map((key) => {
        const childProperty = resolvedCollection.properties[key];
        if (!childProperty) return null;
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls("truncate", restProperties.length > 1 ? "my-0.5" : "my-0"), children: entity ? /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyPreview, { propertyKey: key, value: getValueInPath(entity.values, key), property: childProperty, size: "small" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonPropertyComponent, { property: childProperty, size: "small" }) }, "ref_prev_" + key);
      })
    ] }),
    entity && includeEntityLink && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: `See details for ${entity.id}`, className: "shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { color: "inherit", size: "medium", className: size2 !== "small" ? "self-start" : "", onClick: (e2) => {
      e2.stopPropagation();
      analyticsController.onAnalyticsEvent?.("entity_click_from_reference", {
        path: entity.path,
        entityId: entity.id
      });
      sideEntityController.open({
        entityId: entity.id,
        path: entity.path,
        collection,
        updateUrl: true
      });
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardTabIcon, { size: "medium" }) }) }),
    actions
  ] });
}
const EntityPreviewContainer = React.forwardRef((t0, ref) => {
  const $ = c_1(26);
  let children;
  let className;
  let hover;
  let onClick;
  let props;
  let size2;
  let style2;
  let t1;
  if ($[0] !== t0) {
    ({
      children,
      hover,
      onClick,
      size: size2,
      style: style2,
      className,
      fullwidth: t1,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = className;
    $[3] = hover;
    $[4] = onClick;
    $[5] = props;
    $[6] = size2;
    $[7] = style2;
    $[8] = t1;
  } else {
    children = $[1];
    className = $[2];
    hover = $[3];
    onClick = $[4];
    props = $[5];
    size2 = $[6];
    style2 = $[7];
    t1 = $[8];
  }
  const fullwidth = t1 === void 0 ? true : t1;
  let t2;
  if ($[9] !== style2) {
    t2 = {
      ...style2,
      tabindex: 0
    };
    $[9] = style2;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  const t3 = fullwidth ? "w-full" : "";
  const t4 = hover ? "hover:bg-surface-accent-50 dark:hover:bg-surface-800 group-hover:bg-surface-accent-50 dark:group-hover:bg-surface-800" : "";
  const t5 = size2 === "small" ? "p-1" : "px-2 py-1";
  const t6 = onClick ? "cursor-pointer" : "";
  let t7;
  if ($[11] !== className || $[12] !== t3 || $[13] !== t4 || $[14] !== t5 || $[15] !== t6) {
    t7 = cls("bg-white dark:bg-surface-900", "min-h-[42px]", t3, "items-center", t4, t5, "flex border rounded-lg", t6, defaultBorderMixin, className);
    $[11] = className;
    $[12] = t3;
    $[13] = t4;
    $[14] = t5;
    $[15] = t6;
    $[16] = t7;
  } else {
    t7 = $[16];
  }
  let t8;
  if ($[17] !== onClick) {
    t8 = (event) => {
      if (onClick) {
        event.preventDefault();
        onClick(event);
      }
    };
    $[17] = onClick;
    $[18] = t8;
  } else {
    t8 = $[18];
  }
  let t9;
  if ($[19] !== children || $[20] !== props || $[21] !== ref || $[22] !== t2 || $[23] !== t7 || $[24] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, style: t2, className: t7, onClick: t8, ...props, children });
    $[19] = children;
    $[20] = props;
    $[21] = ref;
    $[22] = t2;
    $[23] = t7;
    $[24] = t8;
    $[25] = t9;
  } else {
    t9 = $[25];
  }
  return t9;
});
EntityPreviewContainer.displayName = "EntityPreviewContainer";
function TableReferenceField(props) {
  const $ = c_1(9);
  const customizationController = useCustomizationController();
  const navigationController = useNavigationController();
  const {
    path
  } = props;
  let t0;
  if ($[0] !== navigationController || $[1] !== path) {
    t0 = navigationController.getCollection(path);
    $[0] = navigationController;
    $[1] = path;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const collection = t0;
  if (!collection) {
    if (customizationController.components?.missingReference) {
      let t12;
      if ($[3] !== customizationController.components.missingReference || $[4] !== path) {
        t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(customizationController.components.missingReference, { path });
        $[3] = customizationController.components.missingReference;
        $[4] = path;
        $[5] = t12;
      } else {
        t12 = $[5];
      }
      return t12;
    } else {
      throw Error(`Couldn't find the corresponding collection view for the path: ${path}`);
    }
  }
  let t1;
  if ($[6] !== collection || $[7] !== props) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(TableReferenceFieldInternal, { ...props, collection });
    $[6] = collection;
    $[7] = props;
    $[8] = t1;
  } else {
    t1 = $[8];
  }
  return t1;
}
const TableReferenceFieldInternal = React__default.memo(function TableReferenceFieldInternal2(props) {
  const $ = c_1(54);
  const {
    name,
    internalValue,
    updateValue,
    multiselect,
    path,
    size: size2,
    previewProperties,
    title,
    disabled,
    forceFilter,
    collection,
    includeId,
    includeEntityLink
  } = props;
  let t0;
  if ($[0] !== updateValue) {
    t0 = (entity) => {
      updateValue(entity ? getReferenceFrom(entity) : null);
    };
    $[0] = updateValue;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const onSingleEntitySelected = t0;
  let t1;
  if ($[2] !== updateValue) {
    t1 = (entities) => {
      updateValue(entities.map(_temp$m));
    };
    $[2] = updateValue;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const onMultipleEntitiesSelected = t1;
  let t2;
  if ($[4] !== internalValue) {
    t2 = internalValue ? Array.isArray(internalValue) ? internalValue.map(_temp2$9) : internalValue.id ? [internalValue.id] : [] : [];
    $[4] = internalValue;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const selectedEntityIds = t2;
  let t3;
  if ($[6] !== collection || $[7] !== forceFilter || $[8] !== multiselect || $[9] !== onMultipleEntitiesSelected || $[10] !== onSingleEntitySelected || $[11] !== path || $[12] !== selectedEntityIds) {
    t3 = {
      multiselect,
      path,
      collection,
      onMultipleEntitiesSelected,
      onSingleEntitySelected,
      selectedEntityIds,
      forceFilter
    };
    $[6] = collection;
    $[7] = forceFilter;
    $[8] = multiselect;
    $[9] = onMultipleEntitiesSelected;
    $[10] = onSingleEntitySelected;
    $[11] = path;
    $[12] = selectedEntityIds;
    $[13] = t3;
  } else {
    t3 = $[13];
  }
  const referenceDialogController = useReferenceDialog(t3);
  let t4;
  if ($[14] !== disabled || $[15] !== referenceDialogController) {
    t4 = () => {
      if (disabled) {
        return;
      }
      referenceDialogController.open();
    };
    $[14] = disabled;
    $[15] = referenceDialogController;
    $[16] = t4;
  } else {
    t4 = $[16];
  }
  const handleOpen = t4;
  const valueNotSet = !internalValue || Array.isArray(internalValue) && internalValue.length === 0;
  let t5;
  if ($[17] !== disabled || $[18] !== handleOpen || $[19] !== includeEntityLink || $[20] !== includeId || $[21] !== internalValue || $[22] !== path || $[23] !== previewProperties || $[24] !== size2) {
    t5 = () => {
      if (internalValue && !Array.isArray(internalValue) && internalValue.isEntityReference && internalValue.isEntityReference()) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ReferencePreview, { onClick: disabled ? void 0 : handleOpen, size: getPreviewSizeFrom(size2), reference: internalValue, hover: !disabled, disabled: !path, previewProperties, includeId, includeEntityLink });
      } else {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(EntityPreviewContainer, { onClick: disabled ? void 0 : handleOpen, size: getPreviewSizeFrom(size2), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView, { title: "Value is not a reference.", error: "Click to edit" }) });
      }
    };
    $[17] = disabled;
    $[18] = handleOpen;
    $[19] = includeEntityLink;
    $[20] = includeId;
    $[21] = internalValue;
    $[22] = path;
    $[23] = previewProperties;
    $[24] = size2;
    $[25] = t5;
  } else {
    t5 = $[25];
  }
  const buildSingleReferenceField = t5;
  let t6;
  if ($[26] !== disabled || $[27] !== handleOpen || $[28] !== includeEntityLink || $[29] !== includeId || $[30] !== internalValue || $[31] !== name || $[32] !== path || $[33] !== previewProperties) {
    t6 = () => {
      if (Array.isArray(internalValue)) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: internalValue.map((reference2, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full my-0.5", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReferencePreview, { onClick: disabled ? void 0 : handleOpen, size: "small", reference: reference2, hover: !disabled, disabled: !path, previewProperties, includeId, includeEntityLink }) }, `preview_array_ref_${name}_${index2}`)) });
      } else {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView, { error: "Data is not an array of references" });
      }
    };
    $[26] = disabled;
    $[27] = handleOpen;
    $[28] = includeEntityLink;
    $[29] = includeId;
    $[30] = internalValue;
    $[31] = name;
    $[32] = path;
    $[33] = previewProperties;
    $[34] = t6;
  } else {
    t6 = $[34];
  }
  const buildMultipleReferenceField = t6;
  if (!collection) {
    let t72;
    if ($[35] === Symbol.for("react.memo_cache_sentinel")) {
      t72 = /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView, { error: "The specified collection does not exist" });
      $[35] = t72;
    } else {
      t72 = $[35];
    }
    return t72;
  }
  let t7;
  if ($[36] !== buildSingleReferenceField || $[37] !== internalValue || $[38] !== multiselect) {
    t7 = internalValue && !multiselect && buildSingleReferenceField();
    $[36] = buildSingleReferenceField;
    $[37] = internalValue;
    $[38] = multiselect;
    $[39] = t7;
  } else {
    t7 = $[39];
  }
  let t8;
  if ($[40] !== buildMultipleReferenceField || $[41] !== internalValue || $[42] !== multiselect) {
    t8 = internalValue && multiselect && buildMultipleReferenceField();
    $[40] = buildMultipleReferenceField;
    $[41] = internalValue;
    $[42] = multiselect;
    $[43] = t8;
  } else {
    t8 = $[43];
  }
  let t9;
  if ($[44] !== disabled || $[45] !== handleOpen || $[46] !== multiselect || $[47] !== title || $[48] !== valueNotSet) {
    t9 = valueNotSet && /* @__PURE__ */ jsxRuntimeExports.jsxs(EntityPreviewContainer, { className: cls("px-3 py-2 text-sm font-medium flex items-center", multiselect ? "gap-4" : "gap-6", disabled ? "text-surface-accent-500" : "cursor-pointer text-text-secondary dark:text-text-secondary-dark hover:bg-surface-accent-50 dark:hover:bg-surface-800 group-hover:bg-surface-accent-50 dark:group-hover:bg-surface-800"), onClick: handleOpen, size: "medium", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(EditIcon, { size: "small", className: "ml-2 mr-1 text-surface-300 dark:text-surface-600" }),
      title
    ] });
    $[44] = disabled;
    $[45] = handleOpen;
    $[46] = multiselect;
    $[47] = title;
    $[48] = valueNotSet;
    $[49] = t9;
  } else {
    t9 = $[49];
  }
  let t10;
  if ($[50] !== t7 || $[51] !== t8 || $[52] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full group", children: [
      t7,
      t8,
      t9
    ] });
    $[50] = t7;
    $[51] = t8;
    $[52] = t9;
    $[53] = t10;
  } else {
    t10 = $[53];
  }
  return t10;
}, equal);
function _temp$m(e2) {
  return getReferenceFrom(e2);
}
function _temp2$9(ref) {
  return ref.id;
}
addMethod(create$1, "uniqueInArray", function(mapper = (a2) => a2, message2) {
  return this.test("uniqueInArray", message2, (values) => {
    return !values || values.length === new Set(values.map(mapper)).size;
  });
});
function getYupEntitySchema(entityId, properties, customFieldValidator) {
  const objectSchema = {};
  Object.entries(properties).forEach(([name, property2]) => {
    objectSchema[name] = mapPropertyToYup({
      property: property2,
      customFieldValidator,
      name,
      entityId
    });
  });
  return create$2().shape(objectSchema);
}
function mapPropertyToYup(propertyContext) {
  const property2 = propertyContext.property;
  if (isPropertyBuilder(property2)) {
    console.error("Error in property", propertyContext);
    throw Error("Trying to create a yup mapping from a property builder. Please use resolved properties only");
  }
  if (property2.dataType === "string") {
    return getYupStringSchema(propertyContext);
  } else if (property2.dataType === "number") {
    return getYupNumberSchema(propertyContext);
  } else if (property2.dataType === "boolean") {
    return getYupBooleanSchema(propertyContext);
  } else if (property2.dataType === "map") {
    return getYupMapObjectSchema(propertyContext);
  } else if (property2.dataType === "array") {
    return getYupArraySchema(propertyContext);
  } else if (property2.dataType === "date") {
    return getYupDateSchema(propertyContext);
  } else if (property2.dataType === "geopoint") {
    return getYupGeoPointSchema(propertyContext);
  } else if (property2.dataType === "reference") {
    return getYupReferenceSchema(propertyContext);
  }
  console.error("Unsupported data type in yup mapping", property2);
  throw Error("Unsupported data type in yup mapping");
}
function getYupMapObjectSchema({
  property: property2,
  entityId,
  customFieldValidator,
  name
}) {
  const objectSchema = {};
  const validation = property2.validation;
  if (property2.properties) Object.entries(property2.properties).forEach(([childName, childProperty]) => {
    objectSchema[childName] = mapPropertyToYup({
      property: childProperty,
      parentProperty: property2,
      customFieldValidator,
      name: `${name}[${childName}]`,
      entityId
    });
  });
  const shape = create$2().shape(objectSchema);
  if (validation?.required) {
    return shape.required(validation?.requiredMessage ? validation.requiredMessage : "Required").nullable(true);
  }
  return create$2().shape(shape.fields).default(void 0).notRequired().nullable(true);
}
function getYupStringSchema({
  property: property2,
  parentProperty,
  customFieldValidator,
  name,
  entityId
}) {
  let collection = create$5();
  const validation = property2.validation;
  if (property2.enumValues) {
    if (validation?.required) collection = collection.required(validation?.requiredMessage ? validation.requiredMessage : "Required");
    const entries = enumToObjectEntries(property2.enumValues);
    collection = collection.oneOf((validation?.required ? entries : [...entries, null]).map((enumValueConfig) => enumValueConfig?.id ?? null)).nullable(true);
  }
  if (validation) {
    collection = validation.required ? collection.required(validation?.requiredMessage ? validation.requiredMessage : "Required").nullable(true) : collection.notRequired().nullable(true);
    if (validation.unique && customFieldValidator && name) collection = collection.test("unique", "This value already exists and should be unique", (value, context) => customFieldValidator({
      name,
      property: property2,
      parentProperty,
      value,
      entityId
    }));
    if (validation.min || validation.min === 0) collection = collection.min(validation.min, `${property2.name} must be min ${validation.min} characters long`);
    if (validation.max || validation.max === 0) collection = collection.max(validation.max, `${property2.name} must be max ${validation.max} characters long`);
    if (validation.matches) {
      const regExp = typeof validation.matches === "string" ? hydrateRegExp(validation.matches) : validation.matches;
      if (regExp) {
        collection = collection.matches(regExp, validation.matchesMessage ? {
          message: validation.matchesMessage
        } : void 0);
      }
    }
    if (validation.trim) collection = collection.trim();
    if (validation.lowercase) collection = collection.lowercase();
    if (validation.uppercase) collection = collection.uppercase();
    if (property2.email) collection = collection.email(`${property2.name} must be an email`);
    if (property2.url) collection = collection.url(`${property2.name} must be a url`);
  } else {
    collection = collection.notRequired().nullable(true);
  }
  return collection;
}
function getYupNumberSchema({
  property: property2,
  parentProperty,
  customFieldValidator,
  name,
  entityId
}) {
  const validation = property2.validation;
  let collection = create$4().typeError("Must be a number");
  if (validation) {
    collection = validation.required ? collection.required(validation.requiredMessage ? validation.requiredMessage : "Required").nullable(true) : collection.notRequired().nullable(true);
    if (validation.unique && customFieldValidator && name) collection = collection.test("unique", "This value already exists and should be unique", (value) => customFieldValidator({
      name,
      property: property2,
      parentProperty,
      value,
      entityId
    }));
    if (validation.min || validation.min === 0) collection = collection.min(validation.min, `${property2.name} must be higher or equal to ${validation.min}`);
    if (validation.max || validation.max === 0) collection = collection.max(validation.max, `${property2.name} must be lower or equal to ${validation.max}`);
    if (validation.lessThan || validation.lessThan === 0) collection = collection.lessThan(validation.lessThan, `${property2.name} must be higher than ${validation.lessThan}`);
    if (validation.moreThan || validation.moreThan === 0) collection = collection.moreThan(validation.moreThan, `${property2.name} must be lower than ${validation.moreThan}`);
    if (validation.positive) collection = collection.positive(`${property2.name} must be positive`);
    if (validation.negative) collection = collection.negative(`${property2.name} must be negative`);
    if (validation.integer) collection = collection.integer(`${property2.name} must be an integer`);
  } else {
    collection = collection.notRequired().nullable(true);
  }
  return collection;
}
function getYupGeoPointSchema({
  property: property2,
  parentProperty,
  customFieldValidator,
  name,
  entityId
}) {
  let collection = create$2();
  const validation = property2.validation;
  if (validation?.unique && customFieldValidator && name) collection = collection.test("unique", "This value already exists and should be unique", (value) => customFieldValidator({
    name,
    property: property2,
    parentProperty,
    value,
    entityId
  }));
  if (validation?.required) {
    collection = collection.required(validation.requiredMessage).nullable(true);
  } else {
    collection = collection.notRequired().nullable(true);
  }
  return collection;
}
function getYupDateSchema({
  property: property2,
  parentProperty,
  customFieldValidator,
  name,
  entityId
}) {
  if (property2.autoValue) {
    return create$2().nullable();
  }
  let collection = create$3();
  const validation = property2.validation;
  if (validation) {
    collection = validation.required ? collection.required(validation?.requiredMessage ? validation.requiredMessage : "Required") : collection.notRequired();
    if (validation.unique && customFieldValidator && name) collection = collection.test("unique", "This value already exists and should be unique", (value) => customFieldValidator({
      name,
      property: property2,
      parentProperty,
      value,
      entityId
    }));
    if (validation.min) collection = collection.min(validation.min, `${property2.name} must be after ${validation.min}`);
    if (validation.max) collection = collection.max(validation.max, `${property2.name} must be before ${validation.min}`);
  } else {
    collection = collection.notRequired();
  }
  return collection.transform((v) => v instanceof Date ? v : null).nullable();
}
function getYupReferenceSchema({
  property: property2,
  parentProperty,
  customFieldValidator,
  name,
  entityId
}) {
  let collection = create$2();
  const validation = property2.validation;
  if (validation) {
    collection = validation.required ? collection.required(validation?.requiredMessage ? validation.requiredMessage : "Required").nullable(true) : collection.notRequired().nullable(true);
    if (validation.unique && customFieldValidator && name) collection = collection.test("unique", "This value already exists and should be unique", (value) => customFieldValidator({
      name,
      property: property2,
      parentProperty,
      value,
      entityId
    }));
  } else {
    collection = collection.notRequired().nullable(true);
  }
  return collection;
}
function getYupBooleanSchema({
  property: property2,
  parentProperty,
  customFieldValidator,
  name,
  entityId
}) {
  let collection = create$6();
  const validation = property2.validation;
  if (validation) {
    collection = validation.required ? collection.required(validation?.requiredMessage ? validation.requiredMessage : "Required").nullable(true) : collection.notRequired().nullable(true);
    if (validation.unique && customFieldValidator && name) collection = collection.test("unique", "This value already exists and should be unique", (value) => customFieldValidator({
      name,
      property: property2,
      parentProperty,
      value,
      entityId
    }));
  } else {
    collection = collection.notRequired().nullable(true);
  }
  return collection;
}
function hasUniqueInArrayModifier(property2) {
  if (property2.validation?.uniqueInArray) {
    return true;
  } else if (property2.dataType === "map" && property2.properties) {
    return Object.entries(property2.properties).filter(([key, childProperty]) => childProperty.validation?.uniqueInArray);
  }
  return false;
}
function getYupArraySchema({
  property: property2,
  parentProperty,
  customFieldValidator,
  name,
  entityId
}) {
  let arraySchema = create$1();
  if (property2.of) {
    if (Array.isArray(property2.of)) {
      const yupProperties = property2.of.map((p2, index2) => ({
        [`${name}[${index2}]`]: mapPropertyToYup({
          property: p2,
          parentProperty: property2,
          entityId
        })
      })).reduce((a2, b) => ({
        ...a2,
        ...b
      }), {});
      return create$1().of(create$7().test("Dynamic object validation", "Dynamic object validation error", (object2, context) => {
        const yupProperty = getValueInPath(yupProperties, context.path);
        return yupProperty.validate(object2);
      }));
    } else {
      arraySchema = arraySchema.of(mapPropertyToYup({
        property: property2.of,
        parentProperty: property2,
        entityId
      }));
      const arrayUniqueFields = hasUniqueInArrayModifier(property2.of);
      if (arrayUniqueFields) {
        if (typeof arrayUniqueFields === "boolean") {
          arraySchema = arraySchema.uniqueInArray((v) => v, `${property2.name} should have unique values within the array`);
        } else if (Array.isArray(arrayUniqueFields)) {
          arrayUniqueFields.forEach(([name2, childProperty]) => {
            arraySchema = arraySchema.uniqueInArray((v) => v && v[name2], `${property2.name}  ${childProperty.name ?? name2}: should have unique values within the array`);
          });
        }
      }
    }
  }
  const validation = property2.validation;
  if (validation) {
    arraySchema = validation.required ? arraySchema.required(validation?.requiredMessage ? validation.requiredMessage : "Required").nullable(true) : arraySchema.notRequired().nullable(true);
    if (validation.min || validation.min === 0) arraySchema = arraySchema.min(validation.min, `${property2.name} should be min ${validation.min} entries long`);
    if (validation.max) arraySchema = arraySchema.max(validation.max, `${property2.name} should be max ${validation.max} entries long`);
  } else {
    arraySchema = arraySchema.notRequired().nullable(true);
  }
  return arraySchema;
}
function getRowHeight(size2) {
  switch (size2) {
    case "xl":
      return 400;
    case "l":
      return 280;
    case "m":
      return 140;
    case "s":
      return 80;
    case "xs":
      return 54;
    default:
      throw Error("Missing mapping for collection size -> height");
  }
}
const TableCellInner = (t0) => {
  const $ = c_1(12);
  const {
    justifyContent,
    scrollable,
    faded,
    fullHeight,
    children
  } = t0;
  const t1 = faded || scrollable;
  let t2;
  if ($[0] !== t1) {
    t2 = cls("flex flex-col max-h-full w-full", {
      "items-start": t1
    });
    $[0] = t1;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  const t3 = fullHeight ? "100%" : void 0;
  const t4 = scrollable ? "auto" : void 0;
  const t5 = faded ? "linear-gradient(to bottom, black 60%, transparent 100%)" : void 0;
  const t6 = faded ? "linear-gradient(to bottom, black 60%, transparent 100%)" : void 0;
  let t7;
  if ($[2] !== justifyContent || $[3] !== t3 || $[4] !== t4 || $[5] !== t5 || $[6] !== t6) {
    t7 = {
      justifyContent,
      height: t3,
      overflow: t4,
      WebkitMaskImage: t5,
      maskImage: t6
    };
    $[2] = justifyContent;
    $[3] = t3;
    $[4] = t4;
    $[5] = t5;
    $[6] = t6;
    $[7] = t7;
  } else {
    t7 = $[7];
  }
  let t8;
  if ($[8] !== children || $[9] !== t2 || $[10] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t2, style: t7, children });
    $[8] = children;
    $[9] = t2;
    $[10] = t7;
    $[11] = t8;
  } else {
    t8 = $[11];
  }
  return t8;
};
const EntityTableCell = React__default.memo(function EntityTableCell2(t0) {
  const $ = c_1(45);
  const {
    children,
    actions,
    size: size2,
    selected,
    disabled,
    disabledTooltip,
    saved,
    error,
    align,
    allowScroll,
    removePadding,
    fullHeight,
    onSelect,
    width,
    hideOverflow: t1,
    showExpandIcon: t2
  } = t0;
  const hideOverflow = t1 === void 0 ? true : t1;
  const [measureRef, bounds] = useMeasure();
  const ref = useRef(null);
  let t3;
  t3 = getRowHeight(size2);
  const maxHeight = t3;
  const [onHover, setOnHover] = useState(false);
  const [internalSaved, setInternalSaved] = useState(saved);
  const showError = !disabled && Boolean(error);
  let t4;
  let t5;
  if ($[0] !== saved) {
    t4 = () => {
      if (saved) {
        setInternalSaved(true);
      }
      const handler = setTimeout(() => {
        setInternalSaved(false);
      }, 800);
      return () => {
        clearTimeout(handler);
      };
    };
    t5 = [saved];
    $[0] = saved;
    $[1] = t4;
    $[2] = t5;
  } else {
    t4 = $[1];
    t5 = $[2];
  }
  useEffect(t4, t5);
  let p2 = 0;
  if (!removePadding) {
    bb0: switch (size2) {
      case "l":
      case "xl": {
        p2 = 4;
        break bb0;
      }
      case "m": {
        p2 = 2;
        break bb0;
      }
      case "s":
      default: {
        p2 = 1;
      }
    }
  }
  let justifyContent;
  bb1: switch (align) {
    case "right": {
      justifyContent = "flex-end";
      break bb1;
    }
    case "center": {
      justifyContent = "center";
      break bb1;
    }
    case "left":
    default: {
      justifyContent = "flex-start";
    }
  }
  let t6;
  if ($[3] !== disabled || $[4] !== onSelect || $[5] !== selected) {
    t6 = () => {
      if (!onSelect) {
        return;
      }
      const cellRect = ref && ref?.current?.getBoundingClientRect();
      if (disabled) {
        onSelect(void 0);
      } else {
        if (!selected && cellRect) {
          onSelect(cellRect);
        }
      }
    };
    $[3] = disabled;
    $[4] = onSelect;
    $[5] = selected;
    $[6] = t6;
  } else {
    t6 = $[6];
  }
  const onSelectCallback = t6;
  let t7;
  if ($[7] !== onSelectCallback) {
    t7 = (event) => {
      event.stopPropagation();
      event.preventDefault();
      onSelectCallback();
    };
    $[7] = onSelectCallback;
    $[8] = t7;
  } else {
    t7 = $[8];
  }
  const onFocus = t7;
  let t8;
  bb2: {
    if (bounds) {
      t8 = bounds.height > maxHeight;
      break bb2;
    }
    t8 = false;
  }
  const isOverflowing = t8;
  const isSelected = !showError && selected;
  const scrollable = !disabled && allowScroll && isOverflowing;
  const faded = !disabled && !allowScroll && isOverflowing;
  let t9;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = () => setOnHover(true);
    $[9] = t9;
  } else {
    t9 = $[9];
  }
  const setOnHoverTrue = t9;
  let t10;
  if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
    t10 = () => setOnHover(false);
    $[10] = t10;
  } else {
    t10 = $[10];
  }
  const setOnHoverFalse = t10;
  const borderClass = showError ? "border-red-500" : internalSaved ? "border-green-500" : isSelected ? "border-primary" : "border-transparent";
  const t11 = `flex relative h-full rounded-md p-${p2} border border-4  border-opacity-75`;
  const t12 = onHover && !disabled ? "bg-surface-50 dark:bg-surface-900" : "";
  const t13 = saved ? "bg-surface-100 bg-opacity-75 dark:bg-surface-800 dark:bg-opacity-75" : "";
  const t14 = hideOverflow ? "overflow-hidden" : "";
  const t15 = isSelected ? "bg-surface-50 dark:bg-surface-900" : "";
  let t16;
  if ($[11] !== borderClass || $[12] !== t11 || $[13] !== t12 || $[14] !== t13 || $[15] !== t14 || $[16] !== t15) {
    t16 = cls("transition-colors duration-100 ease-in-out", t11, t12, t13, t14, t15, borderClass);
    $[11] = borderClass;
    $[12] = t11;
    $[13] = t12;
    $[14] = t13;
    $[15] = t14;
    $[16] = t15;
    $[17] = t16;
  } else {
    t16 = $[17];
  }
  const t17 = disabled || !isOverflowing ? "center" : void 0;
  const t18 = width ?? "100%";
  let t19;
  if ($[18] !== align || $[19] !== justifyContent || $[20] !== t17 || $[21] !== t18) {
    t19 = {
      justifyContent,
      alignItems: t17,
      width: t18,
      textAlign: align
    };
    $[18] = align;
    $[19] = justifyContent;
    $[20] = t17;
    $[21] = t18;
    $[22] = t19;
  } else {
    t19 = $[22];
  }
  const t20 = selected || disabled ? void 0 : 0;
  const t21 = fullHeight && !faded && children;
  let t22;
  if ($[23] !== children || $[24] !== faded || $[25] !== fullHeight || $[26] !== justifyContent || $[27] !== measureRef || $[28] !== scrollable) {
    t22 = (!fullHeight || faded) && /* @__PURE__ */ jsxRuntimeExports.jsx(TableCellInner, { fullHeight: fullHeight ?? false, justifyContent, scrollable: scrollable ?? false, faded, children: !fullHeight && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: measureRef, style: {
      display: "flex",
      width: "100%",
      justifyContent,
      height: fullHeight ? "100%" : void 0
    }, children }) });
    $[23] = children;
    $[24] = faded;
    $[25] = fullHeight;
    $[26] = justifyContent;
    $[27] = measureRef;
    $[28] = scrollable;
    $[29] = t22;
  } else {
    t22 = $[29];
  }
  let t23;
  if ($[30] !== t21 || $[31] !== t22) {
    t23 = /* @__PURE__ */ jsxRuntimeExports.jsxs(ErrorBoundary2, { children: [
      t21,
      t22
    ] });
    $[30] = t21;
    $[31] = t22;
    $[32] = t23;
  } else {
    t23 = $[32];
  }
  let t24;
  if ($[33] !== disabled || $[34] !== disabledTooltip || $[35] !== onHover) {
    t24 = disabled && onHover && disabledTooltip && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-1 right-1 text-xs", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: disabledTooltip, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DoNotDisturbOnIcon, { size: "smallest", color: "disabled", className: "text-surface-500" }) }) });
    $[33] = disabled;
    $[34] = disabledTooltip;
    $[35] = onHover;
    $[36] = t24;
  } else {
    t24 = $[36];
  }
  let t25;
  if ($[37] !== actions || $[38] !== onFocus || $[39] !== t16 || $[40] !== t19 || $[41] !== t20 || $[42] !== t23 || $[43] !== t24) {
    t25 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t16, ref, style: t19, tabIndex: t20, onFocus, onMouseEnter: setOnHoverTrue, onMouseMove: setOnHoverTrue, onMouseLeave: setOnHoverFalse, children: [
      t23,
      actions,
      t24
    ] });
    $[37] = actions;
    $[38] = onFocus;
    $[39] = t16;
    $[40] = t19;
    $[41] = t20;
    $[42] = t23;
    $[43] = t24;
    $[44] = t25;
  } else {
    t25 = $[44];
  }
  return t25;
}, (a2, b) => {
  return a2.error === b.error && a2.value === b.value && a2.disabled === b.disabled && a2.saved === b.saved && a2.allowScroll === b.allowScroll && a2.align === b.align && a2.size === b.size && a2.disabledTooltip === b.disabledTooltip && a2.width === b.width && a2.showExpandIcon === b.showExpandIcon && a2.removePadding === b.removePadding && a2.fullHeight === b.fullHeight && a2.selected === b.selected;
});
const SelectableTableContext = React__default.createContext({});
const useSelectableTableController = () => {
  return useContext(SelectableTableContext);
};
function useClearRestoreValue(t0) {
  const $ = c_1(6);
  const {
    property: property2,
    value,
    setValue
  } = t0;
  const clearedValueRef = useRef(null);
  let t1;
  if ($[0] !== property2.disabled || $[1] !== setValue || $[2] !== value) {
    t1 = () => {
      const shouldClearValueIfDisabled = typeof property2.disabled === "object" && Boolean(property2.disabled.clearOnDisabled);
      if (shouldClearValueIfDisabled) {
        if (value != null) {
          clearedValueRef.current = value;
          setValue(null);
        }
      } else {
        if (clearedValueRef.current) {
          setValue(clearedValueRef.current);
          clearedValueRef.current = null;
        }
      }
    };
    $[0] = property2.disabled;
    $[1] = setValue;
    $[2] = value;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] !== property2) {
    t2 = [property2];
    $[4] = property2;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  useEffect(t1, t2);
}
function isStorageProperty(property2) {
  if (property2.dataType === "string" && property2.markdown) return false;
  if (property2.dataType === "string" && property2.storage) return true;
  if (property2.dataType === "array") {
    if (Array.isArray(property2.of)) {
      return false;
    } else {
      return property2.of?.dataType === "string" && property2.of?.storage;
    }
  }
  return false;
}
const PropertyTableCell = React__default.memo(function PropertyTableCell2({
  propertyKey,
  customFieldValidator,
  value,
  property: property2,
  align,
  width,
  height,
  path,
  entity,
  readonly,
  disabled: disabledProp,
  enablePopupIcon = true
}) {
  const {
    onValueChange,
    size: size2,
    selectedCell,
    select,
    setPopupCell
  } = useSelectableTableController();
  const selected = selectedCell?.propertyKey === propertyKey && selectedCell?.entityPath === entity.path && selectedCell?.entityId === entity.id;
  const [internalValue, setInternalValue] = useState(value);
  const internalValueRef = useRef(value);
  const [error, setError] = useState();
  const [validationError, setValidationError] = useState();
  const [saved, setSaved] = useState(false);
  const onValueUpdated = useCallback(() => {
    setSaved(true);
    setTimeout(() => {
      setSaved(false);
    }, 100);
  }, []);
  const customField = Boolean(property2.Field);
  const customPreview = Boolean(property2.Preview);
  const readOnlyProperty = isReadOnly(property2);
  const disabledTooltip = typeof property2.disabled === "object" ? property2.disabled.disabledMessage : void 0;
  const disabled = readonly || disabledProp || Boolean(property2.disabled);
  const validation = useMemo(() => mapPropertyToYup({
    property: property2,
    entityId: entity.id,
    customFieldValidator,
    name: propertyKey
  }), [entity.id, property2, propertyKey]);
  useEffect(() => {
    if (!equal(value, internalValueRef.current)) {
      setValidationError(void 0);
      setInternalValue(value);
      internalValueRef.current = value;
      onValueUpdated();
    }
  }, [onValueUpdated, value]);
  const saveValues = (value_0) => {
    if (equal(value_0, internalValueRef.current)) return;
    setSaved(false);
    validation.validate(value_0).then(() => {
      setValidationError(void 0);
      internalValueRef.current = value_0;
      if (onValueChange) {
        try {
          onValueChange({
            value: value_0,
            propertyKey,
            setError,
            onValueUpdated,
            data: entity
          });
        } catch (e2) {
          console.error("onValueChange error", e2);
          setError(e2);
        }
      }
    }).catch((e_0) => {
      setValidationError(e_0);
    });
  };
  useEffect(() => {
    validation.validate(internalValue).then(() => setValidationError(void 0)).catch(setValidationError);
  }, [internalValue, validation, propertyKey, property2, entity]);
  const updateValue = (newValue) => {
    let updatedValue;
    if (newValue === void 0) {
      updatedValue = null;
    } else {
      updatedValue = newValue;
    }
    setInternalValue(updatedValue);
    saveValues(updatedValue);
  };
  useClearRestoreValue({
    property: property2,
    value: internalValue,
    setValue: updateValue
  });
  const onSelect = useCallback((cellRect) => {
    if (!cellRect) {
      select(void 0);
    } else {
      select({
        width,
        height,
        entityPath: entity.path,
        entityId: entity.id,
        cellRect,
        propertyKey
      });
    }
  }, [entity, height, propertyKey, select, width]);
  const openPopup = (cellRect_0) => {
    if (!setPopupCell) return;
    if (!cellRect_0) {
      setPopupCell(void 0);
    } else {
      setPopupCell({
        width,
        height,
        entityPath: entity.path,
        entityId: entity.id,
        cellRect: cellRect_0,
        propertyKey
      });
    }
  };
  let innerComponent;
  let allowScroll = false;
  let showExpandIcon = false;
  let hideOverflow = true;
  let removePadding = false;
  let fullHeight = false;
  let includeActions = true;
  const showError = !disabled && error;
  if (readonly || readOnlyProperty) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(EntityTableCell, { size: size2, width, saved, value: internalValue, align: align ?? "left", fullHeight: false, disabledTooltip: disabledTooltip ?? (readOnlyProperty ? "Read only" : void 0), disabled: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyPreview, { width, height: getRowHeight(size2), propertyKey, property: property2, value: internalValue, size: getPreviewSizeFrom(size2) }) }, `${propertyKey}_${entity.path}_${entity.id}`);
  }
  if (!customField && (!customPreview || selected)) {
    const isAStorageProperty = isStorageProperty(property2);
    if (isAStorageProperty) {
      innerComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(TableStorageUpload, { error: validationError ?? error, disabled, focused: selected, selected, openPopup: setPopupCell ? openPopup : void 0, property: property2, entity, path, value: internalValue, previewSize: getPreviewSizeFrom(size2), updateValue, propertyKey });
      includeActions = false;
      showExpandIcon = true;
      fullHeight = true;
      removePadding = true;
    } else if (selected && property2.dataType === "number") {
      const numberProperty = property2;
      if (numberProperty.enumValues) {
        innerComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualTableSelect, { name: propertyKey, multiple: false, disabled, focused: selected, valueType: "number", small: getPreviewSizeFrom(size2) !== "medium", enumValues: numberProperty.enumValues, error: validationError ?? error, internalValue, updateValue });
        fullHeight = true;
      } else {
        innerComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualTableNumberInput, { align, error: validationError ?? error, focused: selected, disabled, value: internalValue, updateValue });
        allowScroll = true;
      }
    } else if (selected && property2.dataType === "string") {
      const stringProperty = property2;
      if (stringProperty.enumValues) {
        innerComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualTableSelect, { name: propertyKey, multiple: false, focused: selected, disabled, valueType: "string", small: getPreviewSizeFrom(size2) !== "medium", enumValues: stringProperty.enumValues, error: validationError ?? error, internalValue, updateValue });
        fullHeight = true;
      } else if (stringProperty.markdown || !stringProperty.storage) {
        const multiline = Boolean(stringProperty.multiline) || Boolean(stringProperty.markdown);
        innerComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualTableInput, { error: validationError ?? error, disabled, multiline, focused: selected, value: internalValue, updateValue });
        allowScroll = true;
      }
    } else if (property2.dataType === "boolean") {
      innerComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualTableSwitch, { error: validationError ?? error, disabled, focused: selected, internalValue, updateValue });
    } else if (property2.dataType === "date") {
      innerComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualTableDateField, { name: propertyKey, error: validationError ?? error, disabled, mode: property2.mode, focused: selected, internalValue, updateValue });
      fullHeight = true;
      hideOverflow = false;
      allowScroll = false;
    } else if (property2.dataType === "reference") {
      if (typeof property2.path === "string") {
        innerComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(TableReferenceField, { name: propertyKey, internalValue, updateValue, disabled, size: size2, path: property2.path, multiselect: false, previewProperties: property2.previewProperties, includeId: property2.includeId, includeEntityLink: property2.includeEntityLink, title: property2.name, forceFilter: property2.forceFilter });
      }
      allowScroll = false;
    } else if (property2.dataType === "array") {
      const arrayProperty = property2;
      if (!arrayProperty.of && !arrayProperty.oneOf) {
        throw Error(`You need to specify an 'of' or 'oneOf' prop (or specify a custom field) in your array property ${propertyKey}`);
      }
      if (arrayProperty.of && !Array.isArray(arrayProperty.of)) {
        if (arrayProperty.of.dataType === "string" || arrayProperty.of.dataType === "number") {
          if (selected && arrayProperty.of.enumValues) {
            innerComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualTableSelect, { name: propertyKey, multiple: true, disabled, focused: selected, small: getPreviewSizeFrom(size2) !== "medium", valueType: arrayProperty.of.dataType, enumValues: arrayProperty.of.enumValues, error: validationError ?? error, internalValue, updateValue });
            allowScroll = true;
            fullHeight = true;
            hideOverflow = false;
          }
        } else if (arrayProperty.of.dataType === "reference") {
          if (typeof arrayProperty.of.path === "string") {
            innerComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(TableReferenceField, { name: propertyKey, disabled, internalValue, updateValue, size: size2, multiselect: true, path: arrayProperty.of.path, previewProperties: arrayProperty.of.previewProperties, title: arrayProperty.name, forceFilter: arrayProperty.of.forceFilter, includeId: arrayProperty.of.includeId, includeEntityLink: arrayProperty.of.includeEntityLink });
          }
          allowScroll = false;
        }
      }
    }
  }
  if (!innerComponent) {
    allowScroll = false;
    showExpandIcon = enablePopupIcon && selected && !innerComponent && !disabled && !readOnlyProperty;
    innerComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyPreview, { width, height, propertyKey, value: internalValue, property: property2, size: getPreviewSizeFrom(size2) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(EntityTableCell, { size: size2, width, onSelect, selected, disabled: disabled || readOnlyProperty, disabledTooltip: disabledTooltip ?? "Disabled", removePadding, fullHeight, saved, error: validationError ?? error, align, allowScroll, showExpandIcon, value: internalValue, hideOverflow, actions: includeActions && /* @__PURE__ */ jsxRuntimeExports.jsx(EntityTableCellActions, { showError, disabled, showExpandIcon, selected, openPopup: !disabled ? openPopup : void 0 }), children: innerComponent }, `cell_${propertyKey}_${entity.path}_${entity.id}`);
}, areEqual$1);
function areEqual$1(prevProps, nextProps) {
  return prevProps.height === nextProps.height && prevProps.propertyKey === nextProps.propertyKey && prevProps.align === nextProps.align && prevProps.width === nextProps.width && equal(prevProps.property, nextProps.property) && equal(prevProps.value, nextProps.value) && equal(prevProps.entity.id, nextProps.entity.id) && equal(prevProps.entity.values, nextProps.entity.values);
}
const EntityCollectionRowActions = function EntityCollectionRowActions2({
  entity,
  collection,
  fullPath,
  width,
  frozen,
  isSelected,
  selectionEnabled,
  size: size2,
  highlightEntity,
  onCollectionChange,
  unhighlightEntity,
  actions = [],
  hideId,
  selectionController
}) {
  const largeLayout = useLargeLayout();
  const context = useFireCMSContext();
  const onCheckedChange = useCallback((checked) => {
    selectionController?.toggleEntitySelection(entity, checked);
  }, [entity, selectionController?.toggleEntitySelection]);
  const hasActions = actions.length > 0;
  const hasCollapsedActions = actions.some((a2) => a2.collapsed || a2.collapsed === void 0);
  const collapsedActions = actions.filter((a_0) => a_0.collapsed || a_0.collapsed === void 0);
  const uncollapsedActions = actions.filter((a_1) => a_1.collapsed === false);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cls("h-full flex items-center justify-center flex-col bg-surface-50 dark:bg-surface-900 bg-opacity-90 dark:bg-opacity-90 z-10", frozen ? "sticky left-0" : ""), onClick: useCallback((event) => {
    event.stopPropagation();
  }, []), style: {
    width,
    position: frozen ? "sticky" : "initial",
    left: frozen ? 0 : "initial",
    contain: "strict"
  }, children: [
    (hasActions || selectionEnabled) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-34 flex justify-center", children: [
      uncollapsedActions.map((action, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: action.name, asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: (event_0) => {
        event_0.stopPropagation();
        action.onClick({
          entity,
          fullPath,
          collection,
          context,
          selectionController,
          highlightEntity,
          unhighlightEntity,
          onCollectionChange
        });
      }, size: largeLayout ? "medium" : "small", children: action.icon }) }, index2)),
      hasCollapsedActions && /* @__PURE__ */ jsxRuntimeExports.jsx(Menu, { trigger: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { size: largeLayout ? "medium" : "small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MoreVertIcon, {}) }), children: collapsedActions.map((action_0, index_0) => /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem, { onClick: (e2) => {
        e2.stopPropagation();
        action_0.onClick({
          entity,
          fullPath,
          collection,
          context,
          selectionController,
          highlightEntity,
          unhighlightEntity,
          onCollectionChange
        });
      }, children: [
        action_0.icon,
        action_0.name
      ] }, index_0)) }),
      selectionEnabled && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: `Select ${entity.id}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { size: largeLayout ? "medium" : "small", checked: Boolean(isSelected), onCheckedChange }) })
    ] }),
    !hideId && size2 !== "xs" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[138px] text-center overflow-hidden truncate font-mono text-xs text-text-secondary dark:text-text-secondary-dark max-w-full text-ellipsis px-2", onClick: (event_1) => {
      event_1.stopPropagation();
    }, children: entity ? entity.id : /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, {}) })
  ] });
};
function CollectionTableToolbar(t0) {
  const $ = c_1(30);
  const {
    actions,
    actionsStart,
    loading,
    onSizeChanged,
    onTextSearch,
    onTextSearchClick,
    size: size2,
    textSearchLoading,
    title
  } = t0;
  const searchInputRef = React__default.useRef(null);
  const largeLayout = useLargeLayout();
  const searchLoading = React__default.useRef(false);
  let t1;
  let t2;
  if ($[0] !== textSearchLoading) {
    t1 = () => {
      if (searchInputRef.current && searchLoading.current && !textSearchLoading) {
        searchInputRef.current.focus();
      }
      searchLoading.current = textSearchLoading ?? false;
    };
    t2 = [textSearchLoading];
    $[0] = textSearchLoading;
    $[1] = t1;
    $[2] = t2;
  } else {
    t1 = $[1];
    t2 = $[2];
  }
  useEffect(t1, t2);
  const t3 = size2;
  let t4;
  if ($[3] !== onSizeChanged) {
    t4 = (v) => onSizeChanged(v);
    $[3] = onSizeChanged;
    $[4] = t4;
  } else {
    t4 = $[4];
  }
  let t5;
  if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = ["xs", "s", "m", "l", "xl"].map(_temp2$8);
    $[5] = t5;
  } else {
    t5 = $[5];
  }
  let t6;
  if ($[6] !== t3 || $[7] !== t4) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Table row size", side: "right", sideOffset: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Select, { value: t3, className: "w-16 h-10", size: "medium", onValueChange: t4, renderValue: _temp$l, children: t5 }) });
    $[6] = t3;
    $[7] = t4;
    $[8] = t6;
  } else {
    t6 = $[8];
  }
  const sizeSelect = t6;
  let t7;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = cls(defaultBorderMixin, "no-scrollbar min-h-[56px] overflow-x-auto px-2 md:px-4 bg-surface-50 dark:bg-surface-900 border-b flex flex-row justify-between items-center w-full");
    $[9] = t7;
  } else {
    t7 = $[9];
  }
  let t8;
  if ($[10] !== title) {
    t8 = title && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hidden lg:block", children: title });
    $[10] = title;
    $[11] = t8;
  } else {
    t8 = $[11];
  }
  let t9;
  if ($[12] !== actionsStart || $[13] !== sizeSelect || $[14] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 md:mr-4 mr-2", children: [
      t8,
      sizeSelect,
      actionsStart
    ] });
    $[12] = actionsStart;
    $[13] = sizeSelect;
    $[14] = t8;
    $[15] = t9;
  } else {
    t9 = $[15];
  }
  let t10;
  if ($[16] !== largeLayout || $[17] !== loading) {
    t10 = largeLayout && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[22px]", children: loading && /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: "small" }) });
    $[16] = largeLayout;
    $[17] = loading;
    $[18] = t10;
  } else {
    t10 = $[18];
  }
  let t11;
  if ($[19] !== onTextSearch || $[20] !== onTextSearchClick || $[21] !== textSearchLoading) {
    t11 = (onTextSearch || onTextSearchClick) && /* @__PURE__ */ jsxRuntimeExports.jsx(SearchBar, { inputRef: searchInputRef, loading: textSearchLoading, disabled: Boolean(onTextSearchClick), onClick: onTextSearchClick, onTextSearch: onTextSearchClick ? void 0 : onTextSearch, expandable: true }, "search-bar");
    $[19] = onTextSearch;
    $[20] = onTextSearchClick;
    $[21] = textSearchLoading;
    $[22] = t11;
  } else {
    t11 = $[22];
  }
  let t12;
  if ($[23] !== actions || $[24] !== t10 || $[25] !== t11) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
      t10,
      t11,
      actions
    ] });
    $[23] = actions;
    $[24] = t10;
    $[25] = t11;
    $[26] = t12;
  } else {
    t12 = $[26];
  }
  let t13;
  if ($[27] !== t12 || $[28] !== t9) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t7, children: [
      t9,
      t12
    ] });
    $[27] = t12;
    $[28] = t9;
    $[29] = t13;
  } else {
    t13 = $[29];
  }
  return t13;
}
function _temp2$8(size_0) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: size_0, className: "w-12 font-medium text-center", children: size_0.toUpperCase() }, size_0);
}
function _temp$l(v_0) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-medium", children: v_0.toUpperCase() });
}
function getTableCellAlignment(property2) {
  if (property2.dataType === "boolean") {
    return "center";
  } else if (property2.dataType === "number") {
    if (property2.enumValues) return "left";
    return "right";
  } else if (property2.dataType === "date") {
    return "right";
  } else {
    return "left";
  }
}
function getTablePropertyColumnWidth(property2) {
  if (property2.columnWidth) {
    return property2.columnWidth;
  }
  if (property2.dataType === "string") {
    if (property2.url) {
      return 280;
    } else if (property2.storage) {
      return 160;
    } else if (property2.enumValues) {
      return 200;
    } else if (property2.multiline) {
      return 300;
    } else if (property2.markdown) {
      return 300;
    } else if (property2.email) {
      return 200;
    } else {
      return 200;
    }
  } else if (property2.dataType === "array") {
    const arrayProperty = property2;
    if (arrayProperty.of) {
      if (Array.isArray(property2.of)) {
        return 300;
      } else {
        return getTablePropertyColumnWidth(arrayProperty.of);
      }
    } else {
      return 300;
    }
  } else if (property2.dataType === "number") {
    if (property2.enumValues) {
      return 200;
    }
    return 140;
  } else if (property2.dataType === "map") {
    return 360;
  } else if (property2.dataType === "date") {
    return 200;
  } else if (property2.dataType === "reference") {
    return 220;
  } else if (property2.dataType === "boolean") {
    return 140;
  } else {
    return 200;
  }
}
function getSubcollectionColumnId(collection) {
  return `subcollection:${collection.id ?? collection.path}`;
}
const COLLECTION_GROUP_PARENT_ID$1 = "collectionGroupParent";
function useColumnIds(collection, includeSubcollections) {
  const $ = c_1(5);
  let t0;
  bb0: {
    if (collection.propertiesOrder) {
      let propertyColumnConfigs;
      if ($[0] !== collection) {
        propertyColumnConfigs = hideAndExpandKeys(collection, collection.propertiesOrder);
        if (collection.collectionGroup) {
          propertyColumnConfigs.push({
            key: COLLECTION_GROUP_PARENT_ID$1,
            disabled: true
          });
        }
        $[0] = collection;
        $[1] = propertyColumnConfigs;
      } else {
        propertyColumnConfigs = $[1];
      }
      t0 = propertyColumnConfigs;
      break bb0;
    }
    let t1;
    if ($[2] !== collection || $[3] !== includeSubcollections) {
      t1 = getDefaultColumnKeys(collection, includeSubcollections);
      $[2] = collection;
      $[3] = includeSubcollections;
      $[4] = t1;
    } else {
      t1 = $[4];
    }
    t0 = t1;
  }
  return t0;
}
function hideAndExpandKeys(collection, keys2) {
  return keys2.flatMap((key) => {
    const property2 = collection.properties[key];
    if (property2) {
      if (property2.hideFromCollection) return [null];
      if (property2.disabled && typeof property2.disabled === "object" && property2.disabled.hidden) return [null];
      if (property2.dataType === "map" && property2.spreadChildren && property2.properties) {
        return getColumnKeysForProperty(property2, key);
      }
      return [{
        key,
        disabled: Boolean(property2.disabled) || Boolean(property2.readOnly)
      }];
    }
    const additionalField = collection.additionalFields?.find((field) => field.key === key);
    if (additionalField) {
      return [{
        key,
        disabled: true
      }];
    }
    if (collection.subcollections) {
      const subCollection = collection.subcollections.find((subCol) => getSubcollectionColumnId(subCol) === key);
      if (subCollection) {
        return [{
          key,
          disabled: true
        }];
      }
    }
    if (collection.collectionGroup && key === COLLECTION_GROUP_PARENT_ID$1) {
      return [{
        key,
        disabled: true
      }];
    }
    return [null];
  }).filter(Boolean);
}
function getDefaultColumnKeys(collection, includeSubCollections) {
  const propertyKeys = Object.keys(collection.properties);
  const additionalFields = collection.additionalFields ?? [];
  const subCollections = collection.subcollections ?? [];
  const columnIds = [...propertyKeys, ...additionalFields.map((field) => field.key)];
  if (includeSubCollections) {
    const subCollectionIds = subCollections.map((collection2) => getSubcollectionColumnId(collection2));
    columnIds.push(...subCollectionIds.filter((subColId) => !columnIds.includes(subColId)));
  }
  if (collection.collectionGroup) {
    columnIds.push(COLLECTION_GROUP_PARENT_ID$1);
  }
  return hideAndExpandKeys(collection, columnIds);
}
function getColumnKeysForProperty(property2, key, disabled) {
  if (property2.dataType === "map" && property2.spreadChildren && property2.properties) {
    return Object.entries(property2.properties).flatMap(([childKey, childProperty]) => getColumnKeysForProperty(childProperty, `${key}.${childKey}`, disabled || Boolean(property2.disabled) || Boolean(property2.readOnly)));
  }
  return [{
    key,
    disabled: disabled || Boolean(property2.disabled) || Boolean(property2.readOnly)
  }];
}
function getFormFieldKeys(collection) {
  const propertyKeys = Object.keys(collection.properties);
  const additionalFields = collection.additionalFields ?? [];
  const allKeys = [...propertyKeys, ...additionalFields.map((field) => field.key)];
  if (collection.propertiesOrder) {
    return collection.propertiesOrder.filter((key) => allKeys.includes(key));
  }
  return allKeys;
}
function buildIdColumn(largeLayout) {
  return {
    key: "id_ewcfedcswdf3",
    width: largeLayout ? 160 : 130,
    title: "ID",
    resizable: false,
    frozen: largeLayout ?? false,
    headerAlign: "center",
    align: "center"
  };
}
function propertiesToColumns({
  properties,
  sortable,
  forceFilter,
  AdditionalHeaderWidget
}) {
  const disabledFilter = Boolean(forceFilter);
  return Object.entries(properties).flatMap(([key, property2]) => getColumnKeysForProperty(property2, key)).map(({
    key,
    disabled
  }) => {
    const property2 = getResolvedPropertyInPath(properties, key);
    if (!property2) throw Error("Internal error: no property found in path " + key);
    const filterable = filterableProperty(property2);
    return {
      key,
      align: getTableCellAlignment(property2),
      icon: getIconForProperty(property2, "small"),
      title: property2.name ?? key,
      sortable,
      filter: !disabledFilter && filterable,
      width: getTablePropertyColumnWidth(property2),
      resizable: true,
      custom: {
        resolvedProperty: property2,
        disabled
      },
      AdditionalHeaderWidget: AdditionalHeaderWidget ? ({
        onHover
      }) => /* @__PURE__ */ jsxRuntimeExports.jsx(AdditionalHeaderWidget, { property: property2, propertyKey: key, onHover }) : void 0
    };
  });
}
function filterableProperty(property2, partOfArray = false) {
  if (partOfArray) {
    return ["string", "number", "date", "reference"].includes(property2.dataType);
  }
  if (property2.dataType === "array") {
    if (property2.of) return filterableProperty(property2.of, true);
    else return false;
  }
  return ["string", "number", "boolean", "date", "reference", "array"].includes(property2.dataType);
}
function CircularProgressCenter(t0) {
  const $ = c_1(10);
  let props;
  let text;
  if ($[0] !== t0) {
    ({
      text,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = props;
    $[2] = text;
  } else {
    props = $[1];
    text = $[2];
  }
  let t1;
  if ($[3] !== props) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { ...props });
    $[3] = props;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  let t2;
  if ($[5] !== text) {
    t2 = text && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { color: "secondary", variant: "caption", className: "text-center", children: text });
    $[5] = text;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  let t3;
  if ($[7] !== t1 || $[8] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-full h-screen max-h-full max-w-full bg-surface-50 dark:bg-surface-900 gap-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "m-auto flex flex-col gap-2 items-center", children: [
      t1,
      t2
    ] }) });
    $[7] = t1;
    $[8] = t2;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  return t3;
}
const VirtualTableHeader = React__default.memo(function VirtualTableHeader2(t0) {
  const $ = c_1(57);
  const {
    resizeHandleRef,
    columnIndex,
    isResizingIndex,
    sort,
    onColumnSort,
    onFilterUpdate,
    filter,
    column,
    onClickResizeColumn,
    createFilterField: createFilterField2,
    AdditionalHeaderWidget
  } = t0;
  const [onHover, setOnHover] = useState(false);
  const [openFilter, setOpenFilter] = React__default.useState(false);
  const [hidden, setHidden] = React__default.useState(false);
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (event) => {
      setOpenFilter(true);
    };
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  const handleSettingsClick = t1;
  let t2;
  if ($[1] !== column || $[2] !== onFilterUpdate) {
    t2 = (filterForProperty, newOpenFilterState) => {
      onFilterUpdate(column, filterForProperty);
      if (newOpenFilterState !== void 0) {
        setOpenFilter(newOpenFilterState);
      }
    };
    $[1] = column;
    $[2] = onFilterUpdate;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const update2 = t2;
  const thisColumnIsResizing = isResizingIndex === columnIndex;
  const anotherColumnIsResizing = isResizingIndex !== columnIndex && isResizingIndex > 0;
  const hovered = !anotherColumnIsResizing && (onHover || thisColumnIsResizing);
  const t3 = column.frozen ? "sticky left-0 z-10" : "relative z-0";
  let t4;
  if ($[4] !== t3) {
    t4 = cls("flex py-0 px-3 h-full text-xs uppercase font-semibold relative select-none items-center bg-surface-50 dark:bg-surface-900", "text-text-secondary hover:text-text-primary dark:text-text-secondary-dark dark:hover:text-text-primary-dark", "hover:bg-surface-100 dark:hover:bg-surface-800 hover:bg-opacity-50 dark:hover:bg-opacity-50", t3);
    $[4] = t3;
    $[5] = t4;
  } else {
    t4 = $[5];
  }
  const t5 = column.frozen ? 0 : void 0;
  let t6;
  if ($[6] !== column.width || $[7] !== t5) {
    t6 = {
      left: t5,
      minWidth: column.width,
      maxWidth: column.width
    };
    $[6] = column.width;
    $[7] = t5;
    $[8] = t6;
  } else {
    t6 = $[8];
  }
  let t7;
  let t8;
  let t9;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = () => setOnHover(true);
    t8 = () => setOnHover(true);
    t9 = () => setOnHover(false);
    $[9] = t7;
    $[10] = t8;
    $[11] = t9;
  } else {
    t7 = $[9];
    t8 = $[10];
    t9 = $[11];
  }
  const t10 = `flex items-center justify-${column.headerAlign} flex-row`;
  let t11;
  if ($[12] !== column.align) {
    t11 = {
      WebkitBoxOrient: "vertical",
      WebkitLineClamp: 2,
      justifyContent: column.align
    };
    $[12] = column.align;
    $[13] = t11;
  } else {
    t11 = $[13];
  }
  let t12;
  if ($[14] !== column.title || $[15] !== t11) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "truncate -webkit-box w-full mx-1 overflow-hidden", style: t11, children: column.title });
    $[14] = column.title;
    $[15] = t11;
    $[16] = t12;
  } else {
    t12 = $[16];
  }
  let t13;
  if ($[17] !== column.icon || $[18] !== t10 || $[19] !== t12) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-hidden flex-grow", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t10, children: [
      column.icon,
      t12
    ] }) });
    $[17] = column.icon;
    $[18] = t10;
    $[19] = t12;
    $[20] = t13;
  } else {
    t13 = $[20];
  }
  let t14;
  if ($[21] !== AdditionalHeaderWidget || $[22] !== onHover || $[23] !== openFilter) {
    t14 = AdditionalHeaderWidget && /* @__PURE__ */ jsxRuntimeExports.jsx(AdditionalHeaderWidget, { onHover: onHover || openFilter });
    $[21] = AdditionalHeaderWidget;
    $[22] = onHover;
    $[23] = openFilter;
    $[24] = t14;
  } else {
    t14 = $[24];
  }
  let t15;
  if ($[25] !== column.key || $[26] !== column.sortable || $[27] !== hovered || $[28] !== onColumnSort || $[29] !== onHover || $[30] !== openFilter || $[31] !== sort) {
    t15 = column.sortable && (sort || hovered || openFilter) && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { color: "secondary", invisible: !sort, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IconButton, { size: "small", className: onHover || openFilter ? "bg-white dark:bg-surface-950" : void 0, onClick: () => {
      onColumnSort(column.key);
    }, children: [
      !sort && /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowUpwardIcon, {}),
      sort === "asc" && /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowUpwardIcon, {}),
      sort === "desc" && /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowUpwardIcon, { className: "rotate-180" })
    ] }) });
    $[25] = column.key;
    $[26] = column.sortable;
    $[27] = hovered;
    $[28] = onColumnSort;
    $[29] = onHover;
    $[30] = openFilter;
    $[31] = sort;
    $[32] = t15;
  } else {
    t15 = $[32];
  }
  let t16;
  if ($[33] !== t14 || $[34] !== t15) {
    t16 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t14,
      t15
    ] });
    $[33] = t14;
    $[34] = t15;
    $[35] = t16;
  } else {
    t16 = $[35];
  }
  let t17;
  if ($[36] !== column || $[37] !== createFilterField2 || $[38] !== filter || $[39] !== hidden || $[40] !== onHover || $[41] !== openFilter || $[42] !== update2) {
    t17 = column.filter && createFilterField2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { color: "secondary", invisible: !filter, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Popover, { open: openFilter, onOpenChange: setOpenFilter, className: hidden ? "hidden" : void 0, modal: true, trigger: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { className: onHover || openFilter ? "bg-white dark:bg-surface-950" : void 0, size: "small", onClick: handleSettingsClick, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FilterListIcon, { size: "small" }) }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(FilterForm, { column, filter, onHover, onFilterUpdate: update2, createFilterField: createFilterField2, hidden, setHidden }) }) }) });
    $[36] = column;
    $[37] = createFilterField2;
    $[38] = filter;
    $[39] = hidden;
    $[40] = onHover;
    $[41] = openFilter;
    $[42] = update2;
    $[43] = t17;
  } else {
    t17 = $[43];
  }
  let t18;
  if ($[44] !== column || $[45] !== columnIndex || $[46] !== hovered || $[47] !== onClickResizeColumn || $[48] !== resizeHandleRef) {
    t18 = column.resizable && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: resizeHandleRef, className: cls("absolute h-full w-[6px] top-0 right-0 cursor-col-resize", hovered && "bg-surface-300 dark:bg-surface-700"), onMouseDown: onClickResizeColumn ? () => onClickResizeColumn(columnIndex, column) : void 0 });
    $[44] = column;
    $[45] = columnIndex;
    $[46] = hovered;
    $[47] = onClickResizeColumn;
    $[48] = resizeHandleRef;
    $[49] = t18;
  } else {
    t18 = $[49];
  }
  let t19;
  if ($[50] !== t13 || $[51] !== t16 || $[52] !== t17 || $[53] !== t18 || $[54] !== t4 || $[55] !== t6) {
    t19 = /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t4, style: t6, onMouseEnter: t7, onMouseMove: t8, onMouseLeave: t9, children: [
      t13,
      t16,
      t17,
      t18
    ] }) });
    $[50] = t13;
    $[51] = t16;
    $[52] = t17;
    $[53] = t18;
    $[54] = t4;
    $[55] = t6;
    $[56] = t19;
  } else {
    t19 = $[56];
  }
  return t19;
}, equal);
function FilterForm(t0) {
  const $ = c_1(33);
  const {
    column,
    onFilterUpdate,
    filter,
    createFilterField: createFilterField2,
    hidden,
    setHidden
  } = t0;
  const id2 = column.key;
  const [filterInternal, setFilterInternal] = useState(filter);
  let t1;
  let t2;
  if ($[0] !== filter) {
    t1 = () => {
      setFilterInternal(filter);
    };
    t2 = [filter];
    $[0] = filter;
    $[1] = t1;
    $[2] = t2;
  } else {
    t1 = $[1];
    t2 = $[2];
  }
  useEffect(t1, t2);
  if (!column.filter) {
    return null;
  }
  let t3;
  if ($[3] !== filterInternal || $[4] !== onFilterUpdate) {
    t3 = () => {
      onFilterUpdate(filterInternal, false);
    };
    $[3] = filterInternal;
    $[4] = onFilterUpdate;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  const submit = t3;
  let t4;
  if ($[6] !== onFilterUpdate) {
    t4 = (e2) => {
      onFilterUpdate(void 0, false);
    };
    $[6] = onFilterUpdate;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  const reset2 = t4;
  const filterIsSet = !!filter;
  let t5;
  if ($[8] !== column || $[9] !== createFilterField2 || $[10] !== filterInternal || $[11] !== hidden || $[12] !== id2 || $[13] !== setHidden) {
    t5 = createFilterField2({
      id: id2,
      filterValue: filterInternal,
      setFilterValue: setFilterInternal,
      column,
      hidden,
      setHidden
    });
    $[8] = column;
    $[9] = createFilterField2;
    $[10] = filterInternal;
    $[11] = hidden;
    $[12] = id2;
    $[13] = setHidden;
    $[14] = t5;
  } else {
    t5 = $[14];
  }
  const filterField = t5;
  if (!filterField) {
    return null;
  }
  let t6;
  if ($[15] !== submit) {
    t6 = (e_0) => {
      e_0.stopPropagation();
      e_0.preventDefault();
      submit();
    };
    $[15] = submit;
    $[16] = t6;
  } else {
    t6 = $[16];
  }
  let t7;
  if ($[17] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = cls(defaultBorderMixin, "py-4 px-6 typography-label border-b");
    $[17] = t7;
  } else {
    t7 = $[17];
  }
  const t8 = column.title ?? id2;
  let t9;
  if ($[18] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t7, children: t8 });
    $[18] = t8;
    $[19] = t9;
  } else {
    t9 = $[19];
  }
  let t10;
  if ($[20] !== filterField) {
    t10 = filterField && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-4", children: filterField });
    $[20] = filterField;
    $[21] = t10;
  } else {
    t10 = $[21];
  }
  const t11 = !filterIsSet;
  let t12;
  if ($[22] !== reset2 || $[23] !== t11) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: "mr-4", disabled: t11, variant: "text", color: "primary", type: "reset", "aria-label": "filter clear", onClick: reset2, children: "Clear" });
    $[22] = reset2;
    $[23] = t11;
    $[24] = t12;
  } else {
    t12 = $[24];
  }
  let t13;
  if ($[25] === Symbol.for("react.memo_cache_sentinel")) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outlined", color: "primary", type: "submit", children: "Filter" });
    $[25] = t13;
  } else {
    t13 = $[25];
  }
  let t14;
  if ($[26] !== t12) {
    t14 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end m-4", children: [
      t12,
      t13
    ] });
    $[26] = t12;
    $[27] = t14;
  } else {
    t14 = $[27];
  }
  let t15;
  if ($[28] !== t10 || $[29] !== t14 || $[30] !== t6 || $[31] !== t9) {
    t15 = /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { noValidate: true, onSubmit: t6, className: "text-surface-900 dark:text-white", children: [
      t9,
      t10,
      t14
    ] });
    $[28] = t10;
    $[29] = t14;
    $[30] = t6;
    $[31] = t9;
    $[32] = t15;
  } else {
    t15 = $[32];
  }
  return t15;
}
const VirtualTableHeaderRow = ({
  columns,
  currentSort,
  onColumnSort,
  onFilterUpdate,
  sortByProperty,
  filter,
  onColumnResize,
  onColumnResizeEnd,
  createFilterField: createFilterField2,
  AddColumnComponent
}) => {
  const columnRefs = columns.map(() => createRef());
  const [isResizing, setIsResizing] = useState(-1);
  const adjustWidthColumn = useCallback((index2, width, end2) => {
    const column = columns[index2];
    const minWidth = 100;
    const maxWidth = 800;
    const newWidth = width > maxWidth ? maxWidth : width < minWidth ? minWidth : width;
    const params = {
      width: newWidth,
      key: column.key,
      column: {
        ...column,
        width: newWidth
      }
    };
    if (!end2) onColumnResize(params);
    else onColumnResizeEnd(params);
  }, [columns, onColumnResize, onColumnResizeEnd]);
  const getEventNewWidth = useCallback((e2) => {
    if (isResizing >= 0) {
      const left2 = columnRefs[isResizing].current?.parentElement?.getBoundingClientRect().left;
      if (!left2) return;
      return e2.clientX - left2;
    }
    return void 0;
  }, [columnRefs, isResizing]);
  const setCursorDocument = useCallback((isResizing_0) => {
    document.body.style.cursor = isResizing_0 ? "col-resize" : "auto";
  }, []);
  const handleOnMouseMove = useCallback((e_0) => {
    e_0.stopPropagation();
    e_0.preventDefault();
    const newWidth_0 = getEventNewWidth(e_0);
    if (newWidth_0) adjustWidthColumn(isResizing, newWidth_0, false);
  }, [adjustWidthColumn, getEventNewWidth, isResizing]);
  const handleOnMouseUp = useCallback((e_1) => {
    e_1.stopPropagation();
    e_1.preventDefault();
    const newWidth_1 = getEventNewWidth(e_1);
    if (newWidth_1) adjustWidthColumn(isResizing, newWidth_1, true);
    setIsResizing(-1);
    setCursorDocument(false);
  }, [adjustWidthColumn, getEventNewWidth, isResizing, setCursorDocument]);
  const removeResizingListeners = useCallback(() => {
    document.removeEventListener("mousemove", handleOnMouseMove);
    document.removeEventListener("mouseup", handleOnMouseUp);
  }, [handleOnMouseMove, handleOnMouseUp]);
  const attachResizeListeners = useCallback(() => {
    document.addEventListener("mousemove", handleOnMouseMove);
    document.addEventListener("mouseup", handleOnMouseUp);
  }, [handleOnMouseMove, handleOnMouseUp]);
  useEffect(() => {
    if (isResizing >= 0) {
      attachResizeListeners();
    } else {
      removeResizingListeners();
    }
    return () => {
      removeResizingListeners();
    };
  }, [attachResizeListeners, isResizing, removeResizingListeners]);
  const onClickResizeColumn = useCallback((index_0) => {
    setIsResizing(index_0);
    setCursorDocument(true);
  }, [setCursorDocument]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cls(defaultBorderMixin, "z-20 sticky min-w-full flex w-fit flex-row top-0 left-0 h-12 border-b bg-surface-50 dark:bg-surface-900"), children: [
    columns.map((c2, columnIndex) => {
      const column_0 = columns[columnIndex];
      const filterForThisProperty = column_0 && filter && filter[column_0.key] ? filter[column_0.key] : void 0;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualTableHeader, { resizeHandleRef: columnRefs[columnIndex], columnIndex, isResizingIndex: isResizing, onFilterUpdate, filter: filterForThisProperty, sort: sortByProperty === column_0.key ? currentSort : void 0, onColumnSort, onClickResizeColumn, column: column_0, createFilterField: createFilterField2, AdditionalHeaderWidget: column_0.AdditionalHeaderWidget }) }, "header_" + column_0.key);
    }),
    AddColumnComponent && /* @__PURE__ */ jsxRuntimeExports.jsx(AddColumnComponent, {})
  ] });
};
const VirtualTableRow = React__default.memo(function VirtualTableRow2(t0) {
  const $ = c_1(17);
  const {
    rowData,
    rowIndex,
    children,
    onRowClick,
    rowHeight,
    style: style2,
    hoverRow,
    rowClassName
  } = t0;
  let t1;
  if ($[0] !== onRowClick || $[1] !== rowData || $[2] !== rowIndex) {
    t1 = (event) => {
      if (onRowClick) {
        onRowClick({
          rowData,
          rowIndex,
          event
        });
      }
    };
    $[0] = onRowClick;
    $[1] = rowData;
    $[2] = rowIndex;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const onClick = t1;
  let t2;
  if ($[4] !== hoverRow || $[5] !== onRowClick || $[6] !== rowClassName || $[7] !== rowData) {
    t2 = cls("flex min-w-full text-sm border-b border-surface-200 dark:border-surface-800 border-opacity-40 dark:border-opacity-40", rowClassName ? rowClassName(rowData) : "", {
      "hover:bg-opacity-95": hoverRow,
      "cursor-pointer": onRowClick
    });
    $[4] = hoverRow;
    $[5] = onRowClick;
    $[6] = rowClassName;
    $[7] = rowData;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  let t3;
  if ($[9] !== rowHeight || $[10] !== style2) {
    t3 = {
      ...style2,
      height: rowHeight,
      width: "fit-content"
    };
    $[9] = rowHeight;
    $[10] = style2;
    $[11] = t3;
  } else {
    t3 = $[11];
  }
  let t4;
  if ($[12] !== children || $[13] !== onClick || $[14] !== t2 || $[15] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t2, onClick, style: t3, children });
    $[12] = children;
    $[13] = onClick;
    $[14] = t2;
    $[15] = t3;
    $[16] = t4;
  } else {
    t4 = $[16];
  }
  return t4;
}, equal);
const VirtualTableCell = React__default.memo(function VirtualTableCell2(props) {
  return props.rowData && props.cellRenderer({
    cellData: props.cellData,
    rowData: props.rowData,
    rowIndex: props.rowIndex,
    isScrolling: false,
    column: props.column,
    columns: props.columns,
    columnIndex: props.columnIndex,
    width: props.column.width
  });
}, (a2, b) => {
  return equal(a2.rowData, b.rowData) && equal(a2.column, b.column) && equal(a2.cellData, b.cellData) && equal(a2.rowIndex, b.rowIndex) && equal(a2.cellRenderer, b.cellRenderer) && equal(a2.columnIndex, b.columnIndex);
});
const VirtualListContext = createContext({});
VirtualListContext.displayName = "VirtualListContext";
const innerElementType = forwardRef((t0, ref) => {
  const $ = c_1(7);
  let children;
  let rest;
  if ($[0] !== t0) {
    ({
      children,
      ...rest
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = rest;
  } else {
    children = $[1];
    rest = $[2];
  }
  let t1;
  if ($[3] !== children || $[4] !== ref || $[5] !== rest) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualListContext.Consumer, { children: (virtualTableProps) => {
      const customView = virtualTableProps.customView;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "virtual-table", style: {
          position: "relative",
          height: "100%"
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref, ...rest, style: {
          ...rest?.style,
          minHeight: "100%",
          position: "relative"
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualTableHeaderRow, { ...virtualTableProps }),
          !customView && children
        ] }) }),
        customView && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
          position: "sticky",
          top: "48px",
          flexGrow: 1,
          height: "calc(100% - 48px)",
          marginTop: "calc(48px - 100vh)",
          left: 0
        }, children: customView })
      ] });
    } });
    $[3] = children;
    $[4] = ref;
    $[5] = rest;
    $[6] = t1;
  } else {
    t1 = $[6];
  }
  return t1;
});
const VirtualTable = React__default.memo(function VirtualTable2({
  data,
  onResetPagination,
  onEndReached,
  endOffset = 600,
  rowHeight = 54,
  columns: columnsProp,
  onRowClick,
  onColumnResize,
  filter: filterInput,
  checkFilterCombination,
  onFilterUpdate,
  sortBy,
  error,
  emptyComponent,
  onSortByUpdate,
  loading,
  cellRenderer,
  hoverRow,
  createFilterField: createFilterField2,
  rowClassName,
  style: style2,
  className,
  endAdornment,
  AddColumnComponent,
  debug
}) {
  const sortByProperty = sortBy ? sortBy[0] : void 0;
  const currentSort = sortBy ? sortBy[1] : void 0;
  const [columns, setColumns] = useState(columnsProp);
  const tableRef = useRef(null);
  const endReachCallbackThreshold = useRef(0);
  useEffect(() => {
    setColumns(columnsProp);
  }, [columnsProp]);
  const [measureRef, bounds] = useMeasure();
  const onColumnResizeInternal = useCallback((params) => {
    if (debug) console.log("onColumnResizeInternal", params);
    setColumns(columns.map((column) => column.key === params.column.key ? params.column : column));
  }, [columns]);
  const onColumnResizeEndInternal = useCallback((params_0) => {
    if (debug) console.log("onColumnResizeEndInternal", params_0);
    setColumns(columns.map((column_0) => column_0.key === params_0.column.key ? params_0.column : column_0));
    if (onColumnResize) {
      onColumnResize(params_0);
    }
  }, [columns, onColumnResize]);
  const filterRef = useRef();
  useEffect(() => {
    if (debug) console.log("Filter updated", filterInput);
    filterRef.current = filterInput;
  }, [filterInput]);
  const scrollToTop = useCallback(() => {
    if (debug) console.log("scrollToTop");
    endReachCallbackThreshold.current = 0;
    if (tableRef.current) {
      tableRef.current.scrollTo(tableRef.current?.scrollLeft, 0);
    }
  }, []);
  const onColumnSort = useCallback((key) => {
    if (debug) console.log("onColumnSort", key);
    const isDesc = sortByProperty === key && currentSort === "desc";
    const isAsc = sortByProperty === key && currentSort === "asc";
    const newSort = isAsc ? "desc" : isDesc ? void 0 : "asc";
    const newSortProperty = isDesc ? void 0 : key;
    const filter = filterRef.current;
    const newSortBy = newSort && newSortProperty ? [newSortProperty, newSort] : void 0;
    if (filter) {
      if (checkFilterCombination && !checkFilterCombination(filter, newSortBy)) {
        if (onFilterUpdate) onFilterUpdate(void 0);
      }
    }
    if (onResetPagination) {
      onResetPagination();
    }
    if (onSortByUpdate) {
      onSortByUpdate(newSortBy);
    }
    scrollToTop();
  }, [checkFilterCombination, currentSort, onFilterUpdate, onResetPagination, onSortByUpdate, scrollToTop, sortByProperty]);
  const maxScroll = Math.max((data?.length ?? 0) * rowHeight - bounds.height, 0);
  if (debug) console.log("maxScroll", maxScroll);
  const onEndReachedInternal = useCallback((scrollOffset) => {
    if (debug) console.log("onEndReachedInternal", scrollOffset, endReachCallbackThreshold.current + endOffset);
    if (onEndReached && (data?.length ?? 0) > 0 && scrollOffset > endReachCallbackThreshold.current + endOffset) {
      endReachCallbackThreshold.current = scrollOffset;
      onEndReached();
    }
  }, [data?.length, onEndReached]);
  const onScroll = useCallback(({
    scrollDirection,
    scrollOffset: scrollOffset_0,
    scrollUpdateWasRequested
  }) => {
    if (debug) console.log("onScroll", {
      scrollDirection,
      scrollOffset: scrollOffset_0,
      scrollUpdateWasRequested
    });
    if (!scrollUpdateWasRequested && scrollOffset_0 >= maxScroll - endOffset) onEndReachedInternal(scrollOffset_0);
  }, [maxScroll, onEndReachedInternal]);
  const onFilterUpdateInternal = useCallback((column_1, filterForProperty) => {
    if (debug) console.log("onFilterUpdateInternal", column_1, filterForProperty);
    endReachCallbackThreshold.current = 0;
    const filter_0 = filterRef.current;
    let newFilterValue = filter_0 ? {
      ...filter_0
    } : {};
    if (!filterForProperty) {
      delete newFilterValue[column_1.key];
    } else {
      newFilterValue[column_1.key] = filterForProperty;
    }
    const newSortBy_0 = sortByProperty && currentSort ? [sortByProperty, currentSort] : void 0;
    const isNewFilterCombinationValid = !checkFilterCombination || checkFilterCombination(newFilterValue, newSortBy_0);
    if (!isNewFilterCombinationValid) {
      newFilterValue = filterForProperty ? {
        [column_1.key]: filterForProperty
      } : {};
    }
    if (onFilterUpdate) onFilterUpdate(newFilterValue);
  }, [checkFilterCombination, currentSort, onFilterUpdate, sortByProperty]);
  const empty2 = !loading && (data?.length ?? 0) === 0;
  const customView = error ? /* @__PURE__ */ jsxRuntimeExports.jsxs(CenteredView, { maxWidth: "2xl", className: "flex flex-col gap-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", children: "Error" }),
    error?.message && /* @__PURE__ */ jsxRuntimeExports.jsx(SafeLinkRenderer, { text: error.message })
  ] }) : empty2 ? loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCenter, {}) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col overflow-auto items-center justify-center p-2 gap-2 h-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AssignmentIcon, {}),
    emptyComponent
  ] }) : void 0;
  const virtualListController = {
    data,
    rowHeight,
    cellRenderer,
    columns,
    currentSort,
    onRowClick,
    customView,
    onColumnResize: onColumnResizeInternal,
    onColumnResizeEnd: onColumnResizeEndInternal,
    filter: filterRef.current,
    onColumnSort,
    onFilterUpdate: onFilterUpdateInternal,
    sortByProperty,
    hoverRow: hoverRow ?? false,
    createFilterField: createFilterField2,
    rowClassName,
    endAdornment,
    AddColumnComponent
  };
  if (debug) console.log("VirtualTable render", virtualListController);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: measureRef, style: style2, className: cls("h-full w-full", className), children: /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualListContext.Provider, { value: virtualListController, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MemoizedList, { outerRef: tableRef, width: bounds.width, height: bounds.height, itemCount: (data?.length ?? 0) + (endAdornment ? 1 : 0), onScroll, includeAddColumn: Boolean(AddColumnComponent), itemSize: rowHeight }, rowHeight) }) });
}, equal);
function MemoizedList({
  outerRef,
  width,
  height,
  itemCount,
  onScroll,
  itemSize,
  includeAddColumn
}) {
  const Row = useCallback(({
    index: index2,
    style: style2
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualListContext.Consumer, { children: ({
      onRowClick,
      data,
      columns,
      rowHeight = 54,
      cellRenderer,
      hoverRow,
      rowClassName,
      endAdornment
    }) => {
      if (endAdornment && index2 === (data ?? []).length) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
          ...style2,
          height: "auto",
          position: "sticky",
          bottom: 0,
          zIndex: 1
        }, children: endAdornment });
      }
      const rowData = data && data[index2];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(VirtualTableRow, { rowData, rowIndex: index2, onRowClick, columns, hoverRow, rowClassName, style: {
        ...style2,
        top: `calc(${style2.top}px + 48px)`
      }, rowHeight, children: [
        columns.map((column, columnIndex) => {
          const cellData = rowData && rowData[column.key];
          return /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualTableCell, { dataKey: column.key, cellRenderer, column, columns, rowData, cellData, rowIndex: index2, columnIndex }, `cell_${column.key}`);
        }),
        includeAddColumn && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-20" })
      ] }, `row_${index2}`);
    } });
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FixedSizeList, { outerRef, innerElementType, width, height, overscanCount: 4, itemCount, onScroll, itemSize, children: Row });
}
const SafeLinkRenderer = (t0) => {
  const $ = c_1(4);
  const {
    text
  } = t0;
  let t1;
  if ($[0] !== text) {
    const urlRegex = /https?:\/\/[^\s]+/g;
    t1 = text.replace(urlRegex, _temp$k);
    $[0] = text;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const htmlContent = t1;
  let t2;
  if ($[2] !== htmlContent) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "break-all", dangerouslySetInnerHTML: {
      __html: htmlContent
    } });
    $[2] = htmlContent;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
};
function _temp$k(url) {
  return `<a href="${url}" class="underline" target="_blank">Link</a><br/>`;
}
const operationLabels$2 = {
  "==": "==",
  "!=": "!=",
  ">": ">",
  "<": "<",
  ">=": ">=",
  "<=": "<=",
  in: "In",
  "not-in": "Not in",
  "array-contains": "Contains",
  "array-contains-any": "Contains Any"
};
const multipleSelectOperations$2 = ["array-contains-any", "in", "not-in"];
function ReferenceFilterField({
  name,
  value,
  setValue,
  isArray: isArray2,
  path,
  title,
  includeId = true,
  previewProperties,
  setHidden
}) {
  const possibleOperations = isArray2 ? ["array-contains"] : ["==", "!=", ">", "<", ">=", "<="];
  isArray2 ? possibleOperations.push("array-contains-any") : possibleOperations.push("in", "not-in");
  const [fieldOperation, fieldValue] = value || [possibleOperations[0], void 0];
  const [operation, setOperation] = useState(fieldOperation);
  const [internalValue, setInternalValue] = useState(fieldValue);
  const selectedEntityIds = internalValue ? Array.isArray(internalValue) ? internalValue.map((ref) => {
    if (!(ref?.isEntityReference && ref?.isEntityReference())) {
      return null;
    }
    return ref.id;
  }).filter(Boolean) : [internalValue.id] : [];
  function updateFilter(op, val) {
    const prevOpIsArray = multipleSelectOperations$2.includes(operation);
    const newOpIsArray = multipleSelectOperations$2.includes(op);
    let newValue = val;
    if (prevOpIsArray !== newOpIsArray) {
      newValue = newOpIsArray ? newValue?.isEntityReference && newValue?.isEntityReference() ? [newValue] : [] : void 0;
    }
    setOperation(op);
    setInternalValue(newValue);
    const hasNewValue = newValue !== null && Array.isArray(newValue) ? newValue.length > 0 : newValue !== void 0;
    if (op && hasNewValue) {
      setValue([op, newValue]);
    } else {
      setValue(void 0);
    }
  }
  const navigationController = useNavigationController();
  const collection = useMemo(() => {
    return path ? navigationController.getCollection(path) : void 0;
  }, [path]);
  const onSingleEntitySelected = (entity) => {
    updateFilter(operation, getReferenceFrom(entity));
  };
  const onMultipleEntitiesSelected = (entities) => {
    updateFilter(operation, entities.map((e2) => getReferenceFrom(e2)));
  };
  const multiple = multipleSelectOperations$2.includes(operation);
  const referenceDialogController = useReferenceDialog({
    multiselect: multiple,
    path,
    collection,
    onSingleEntitySelected,
    onMultipleEntitiesSelected,
    selectedEntityIds,
    onClose: () => {
      setHidden(false);
    }
  });
  const doOpenDialog = () => {
    setHidden(true);
    referenceDialogController.open();
  };
  const buildEntry = (reference2) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ReferencePreview, { disabled: !path, previewProperties, size: "medium", onClick: doOpenDialog, reference: reference2, hover: true, includeId, includeEntityLink: false });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-[440px] flex-row", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[140px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Select, { value: operation, size: "large", fullWidth: true, onValueChange: (value_0) => {
      updateFilter(value_0, internalValue);
    }, renderValue: (op_0) => operationLabels$2[op_0], children: possibleOperations.map((op_1) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: op_1, children: operationLabels$2[op_1] }, op_1)) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-grow ml-2 h-full gap-2 flex flex-col", children: [
      internalValue && Array.isArray(internalValue) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: internalValue.map((ref_0, index2) => buildEntry(ref_0)) }),
      internalValue && !Array.isArray(internalValue) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: buildEntry(internalValue) }),
      (!internalValue || Array.isArray(internalValue) && internalValue.length === 0) && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: doOpenDialog, variant: "outlined", size: "large", className: "h-full w-full", children: multiple ? "Select references" : "Select reference" }),
      !isArray2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Label, { className: "border cursor-pointer rounded-md p-2 flex items-center gap-2 [&:has(:checked)]:bg-surface-100 dark:[&:has(:checked)]:bg-surface-800", htmlFor: "null-filter", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { id: "null-filter", checked: internalValue === null, size: "small", onCheckedChange: (checked) => {
          if (internalValue !== null) updateFilter(operation, null);
          else updateFilter(operation, void 0);
        } }),
        "Filter for null values"
      ] })
    ] })
  ] });
}
const operationLabels$1 = {
  "==": "==",
  "!=": "!=",
  ">": ">",
  "<": "<",
  ">=": ">=",
  "<=": "<=",
  in: "In",
  "not-in": "Not in",
  "array-contains": "Contains",
  "array-contains-any": "Any"
};
const multipleSelectOperations$1 = ["array-contains-any", "in", "not-in"];
function StringNumberFilterField(t0) {
  const $ = c_1(55);
  const {
    name,
    value,
    setValue,
    dataType,
    isArray: isArray2,
    enumValues
  } = t0;
  let possibleOperations;
  if ($[0] !== enumValues || $[1] !== isArray2) {
    possibleOperations = isArray2 ? ["array-contains"] : ["==", "!=", ">", "<", ">=", "<="];
    if (enumValues) {
      isArray2 ? possibleOperations.push("array-contains-any") : possibleOperations.push("in", "not-in");
    }
    $[0] = enumValues;
    $[1] = isArray2;
    $[2] = possibleOperations;
  } else {
    possibleOperations = $[2];
  }
  let t1;
  if ($[3] !== possibleOperations || $[4] !== value) {
    t1 = value || [possibleOperations[0], void 0];
    $[3] = possibleOperations;
    $[4] = value;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  const [fieldOperation, fieldValue] = t1;
  const [operation, setOperation] = useState(fieldOperation);
  const [internalValue, setInternalValue] = useState(fieldValue);
  let t2;
  if ($[6] !== operation || $[7] !== setValue) {
    t2 = function updateFilter2(op, val) {
      let newValue = val;
      const prevOpIsArray = multipleSelectOperations$1.includes(operation);
      const newOpIsArray = multipleSelectOperations$1.includes(op);
      if (prevOpIsArray !== newOpIsArray) {
        newValue = newOpIsArray ? typeof val === "string" || typeof val === "number" ? [val] : [] : void 0;
      }
      if (typeof newValue === "number" && isNaN(newValue)) {
        newValue = void 0;
      }
      setOperation(op);
      setInternalValue(newValue);
      const hasNewValue = newValue !== null && Array.isArray(newValue) ? newValue.length > 0 : newValue !== void 0;
      if (op && hasNewValue) {
        setValue([op, newValue]);
      } else {
        setValue(void 0);
      }
    };
    $[6] = operation;
    $[7] = setValue;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  const updateFilter = t2;
  let t3;
  if ($[9] !== operation) {
    t3 = multipleSelectOperations$1.includes(operation);
    $[9] = operation;
    $[10] = t3;
  } else {
    t3 = $[10];
  }
  const multiple = t3;
  let t4;
  if ($[11] !== internalValue || $[12] !== updateFilter) {
    t4 = (value_0) => {
      updateFilter(value_0, internalValue);
    };
    $[11] = internalValue;
    $[12] = updateFilter;
    $[13] = t4;
  } else {
    t4 = $[13];
  }
  let t5;
  if ($[14] !== possibleOperations) {
    t5 = possibleOperations.map(_temp2$7);
    $[14] = possibleOperations;
    $[15] = t5;
  } else {
    t5 = $[15];
  }
  let t6;
  if ($[16] !== operation || $[17] !== t4 || $[18] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[80px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Select, { value: operation, fullWidth: true, position: "item-aligned", onValueChange: t4, renderValue: _temp$j, children: t5 }) });
    $[16] = operation;
    $[17] = t4;
    $[18] = t5;
    $[19] = t6;
  } else {
    t6 = $[19];
  }
  let t7;
  if ($[20] !== dataType || $[21] !== enumValues || $[22] !== internalValue || $[23] !== operation || $[24] !== updateFilter) {
    t7 = !enumValues && /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { type: dataType === "number" ? "number" : void 0, value: internalValue !== void 0 && internalValue != null ? String(internalValue) : "", onChange: (evt) => {
      const val_0 = dataType === "number" ? parseFloat(evt.target.value) : evt.target.value;
      updateFilter(operation, val_0);
    }, endAdornment: internalValue && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: (e2) => updateFilter(operation, void 0), children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {}) }) });
    $[20] = dataType;
    $[21] = enumValues;
    $[22] = internalValue;
    $[23] = operation;
    $[24] = updateFilter;
    $[25] = t7;
  } else {
    t7 = $[25];
  }
  let t8;
  if ($[26] !== dataType || $[27] !== enumValues || $[28] !== internalValue || $[29] !== multiple || $[30] !== name || $[31] !== operation || $[32] !== updateFilter) {
    t8 = enumValues && !multiple && /* @__PURE__ */ jsxRuntimeExports.jsx(Select, { position: "item-aligned", fullWidth: true, value: typeof internalValue === "string" ? internalValue : "", onValueChange: (value_1) => {
      if (value_1 !== "") {
        updateFilter(operation, dataType === "number" ? parseInt(value_1) : value_1);
      }
    }, endAdornment: internalValue && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { className: "absolute right-2 top-3", onClick: (e_0) => updateFilter(operation, void 0), children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {}) }), renderValue: (enumKey) => {
      if (enumKey === null) {
        return "Filter for null values";
      }
      if (enumKey === void 0) {
        return null;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(EnumValuesChip, { enumKey, enumValues, size: "small" }, `select_value_${name}_${enumKey}`);
    }, children: enumValues.map((enumConfig) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: String(enumConfig.id), children: /* @__PURE__ */ jsxRuntimeExports.jsx(EnumValuesChip, { enumKey: String(enumConfig.id), enumValues, size: "small" }) }, `select_item_${name}_${enumConfig.id}`)) });
    $[26] = dataType;
    $[27] = enumValues;
    $[28] = internalValue;
    $[29] = multiple;
    $[30] = name;
    $[31] = operation;
    $[32] = updateFilter;
    $[33] = t8;
  } else {
    t8 = $[33];
  }
  let t9;
  if ($[34] !== dataType || $[35] !== enumValues || $[36] !== internalValue || $[37] !== multiple || $[38] !== name || $[39] !== operation || $[40] !== updateFilter) {
    t9 = enumValues && multiple && /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSelect, { position: "item-aligned", value: Array.isArray(internalValue) ? internalValue.map(_temp3$3) : [], onValueChange: (value_2) => {
      updateFilter(operation, dataType === "number" ? value_2.map(_temp4$2) : value_2);
    }, multiple, endAdornment: internalValue && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { className: "absolute right-2 top-3", onClick: (e_2) => updateFilter(operation, void 0), children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {}) }), children: enumValues.map((enumConfig_0) => /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSelectItem, { value: String(enumConfig_0.id), children: /* @__PURE__ */ jsxRuntimeExports.jsx(EnumValuesChip, { enumKey: String(enumConfig_0.id), enumValues, size: "small" }) }, `select_value_${name}_${enumConfig_0.id}`)) });
    $[34] = dataType;
    $[35] = enumValues;
    $[36] = internalValue;
    $[37] = multiple;
    $[38] = name;
    $[39] = operation;
    $[40] = updateFilter;
    $[41] = t9;
  } else {
    t9 = $[41];
  }
  let t10;
  if ($[42] !== internalValue || $[43] !== isArray2 || $[44] !== operation || $[45] !== updateFilter) {
    t10 = !isArray2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Label, { className: "border cursor-pointer rounded-md p-2 flex items-center gap-2 [&:has(:checked)]:bg-surface-100 dark:[&:has(:checked)]:bg-surface-800", htmlFor: "null-filter", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { id: "null-filter", checked: internalValue === null, size: "small", onCheckedChange: (checked) => {
        if (internalValue !== null) {
          updateFilter(operation, null);
        } else {
          updateFilter(operation, void 0);
        }
      } }),
      "Filter for null values"
    ] });
    $[42] = internalValue;
    $[43] = isArray2;
    $[44] = operation;
    $[45] = updateFilter;
    $[46] = t10;
  } else {
    t10 = $[46];
  }
  let t11;
  if ($[47] !== t10 || $[48] !== t7 || $[49] !== t8 || $[50] !== t9) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-grow ml-2 flex flex-col gap-2", children: [
      t7,
      t8,
      t9,
      t10
    ] });
    $[47] = t10;
    $[48] = t7;
    $[49] = t8;
    $[50] = t9;
    $[51] = t11;
  } else {
    t11 = $[51];
  }
  let t12;
  if ($[52] !== t11 || $[53] !== t6) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-[440px]", children: [
      t6,
      t11
    ] });
    $[52] = t11;
    $[53] = t6;
    $[54] = t12;
  } else {
    t12 = $[54];
  }
  return t12;
}
function _temp4$2(v) {
  return parseInt(v);
}
function _temp3$3(e_1) {
  return String(e_1);
}
function _temp2$7(op_1) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: op_1, children: operationLabels$1[op_1] }, op_1);
}
function _temp$j(op_0) {
  return operationLabels$1[op_0];
}
function BooleanFilterField(t0) {
  const $ = c_1(8);
  const {
    title,
    value,
    setValue
  } = t0;
  let t1;
  if ($[0] !== setValue) {
    t1 = function updateFilter2(val) {
      if (val !== void 0) {
        setValue(["==", val]);
      } else {
        setValue(void 0);
      }
    };
    $[0] = setValue;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const updateFilter = t1;
  const valueSetToTrue = value && value[1];
  const valueSet = !!value;
  let t2;
  if ($[2] !== updateFilter) {
    t2 = (v) => updateFilter(v === null ? void 0 : v);
    $[2] = updateFilter;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const t3 = !valueSet ? "No filter" : valueSetToTrue ? `${title} is true` : `${title} is false`;
  let t4;
  if ($[4] !== t2 || $[5] !== t3 || $[6] !== valueSetToTrue) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[300px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanSwitchWithLabel, { value: valueSetToTrue, allowIndeterminate: true, onValueChange: t2, label: t3 }) });
    $[4] = t2;
    $[5] = t3;
    $[6] = valueSetToTrue;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  return t4;
}
const operationLabels = {
  "==": "==",
  "!=": "!=",
  ">": ">",
  "<": "<",
  ">=": ">=",
  "<=": "<=",
  "not-in": "not in",
  in: "in",
  "array-contains": "Contains",
  "array-contains-any": "Any"
};
const multipleSelectOperations = ["array-contains-any", "in"];
function DateTimeFilterField(t0) {
  const $ = c_1(38);
  const {
    isArray: isArray2,
    mode,
    value,
    setValue
  } = t0;
  const {
    locale
  } = useCustomizationController();
  let t1;
  if ($[0] !== isArray2) {
    t1 = isArray2 ? ["array-contains"] : ["==", "!=", ">", "<", ">=", "<="];
    $[0] = isArray2;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const possibleOperations = t1;
  let t2;
  if ($[2] !== possibleOperations || $[3] !== value) {
    t2 = value || [possibleOperations[0], void 0];
    $[2] = possibleOperations;
    $[3] = value;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  const [fieldOperation, fieldValue] = t2;
  const [operation, setOperation] = useState(fieldOperation);
  const [internalValue, setInternalValue] = useState(fieldValue);
  let t3;
  if ($[5] !== operation || $[6] !== setValue) {
    t3 = function updateFilter2(op, val) {
      let newValue = val;
      const prevOpIsArray = multipleSelectOperations.includes(operation);
      const newOpIsArray = multipleSelectOperations.includes(op);
      if (prevOpIsArray !== newOpIsArray) {
        newValue = newOpIsArray ? val ? [val] : [] : "";
      }
      setOperation(op);
      setInternalValue(newValue === null ? void 0 : newValue);
      const hasNewValue = newValue !== null && Array.isArray(newValue) ? newValue.length > 0 : newValue !== void 0;
      if (op && hasNewValue) {
        setValue([op, newValue]);
      } else {
        setValue(void 0);
      }
    };
    $[5] = operation;
    $[6] = setValue;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  const updateFilter = t3;
  let t4;
  if ($[8] !== internalValue || $[9] !== updateFilter) {
    t4 = (value_0) => {
      updateFilter(value_0, internalValue);
    };
    $[8] = internalValue;
    $[9] = updateFilter;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  let t5;
  if ($[11] !== possibleOperations) {
    t5 = possibleOperations.map(_temp2$6);
    $[11] = possibleOperations;
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  let t6;
  if ($[13] !== operation || $[14] !== t4 || $[15] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[80px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Select, { value: operation, size: "large", fullWidth: true, onValueChange: t4, renderValue: _temp$i, children: t5 }) });
    $[13] = operation;
    $[14] = t4;
    $[15] = t5;
    $[16] = t6;
  } else {
    t6 = $[16];
  }
  const t7 = internalValue ?? void 0;
  let t8;
  if ($[17] !== operation || $[18] !== updateFilter) {
    t8 = (dateValue) => {
      updateFilter(operation, dateValue === null ? void 0 : dateValue);
    };
    $[17] = operation;
    $[18] = updateFilter;
    $[19] = t8;
  } else {
    t8 = $[19];
  }
  let t9;
  if ($[20] !== locale || $[21] !== mode || $[22] !== t7 || $[23] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(DateTimeField, { mode, size: "large", locale, value: t7, onChange: t8, clearable: true });
    $[20] = locale;
    $[21] = mode;
    $[22] = t7;
    $[23] = t8;
    $[24] = t9;
  } else {
    t9 = $[24];
  }
  const t10 = internalValue === null;
  let t11;
  if ($[25] !== internalValue || $[26] !== operation || $[27] !== updateFilter) {
    t11 = (checked) => {
      if (internalValue !== null) {
        updateFilter(operation, null);
      } else {
        updateFilter(operation, void 0);
      }
    };
    $[25] = internalValue;
    $[26] = operation;
    $[27] = updateFilter;
    $[28] = t11;
  } else {
    t11 = $[28];
  }
  let t12;
  if ($[29] !== t10 || $[30] !== t11) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Label, { className: "border cursor-pointer rounded-md p-2 flex items-center gap-2 [&:has(:checked)]:bg-surface-100 dark:[&:has(:checked)]:bg-surface-800", htmlFor: "null-filter", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { id: "null-filter", checked: t10, size: "small", onCheckedChange: t11 }),
      "Filter for null values"
    ] });
    $[29] = t10;
    $[30] = t11;
    $[31] = t12;
  } else {
    t12 = $[31];
  }
  let t13;
  if ($[32] !== t12 || $[33] !== t9) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-grow ml-2 flex flex-col gap-2", children: [
      t9,
      t12
    ] });
    $[32] = t12;
    $[33] = t9;
    $[34] = t13;
  } else {
    t13 = $[34];
  }
  let t14;
  if ($[35] !== t13 || $[36] !== t6) {
    t14 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-[440px]", children: [
      t6,
      t13
    ] });
    $[35] = t13;
    $[36] = t6;
    $[37] = t14;
  } else {
    t14 = $[37];
  }
  return t14;
}
function _temp2$6(op_1) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: op_1, children: operationLabels[op_1] }, op_1);
}
function _temp$i(op_0) {
  return operationLabels[op_0];
}
const SelectableTable = React__default.memo(
  function SelectableTable2({
    onValueChange,
    cellRenderer,
    onEntityClick,
    onColumnResize,
    hoverRow = true,
    size: size2 = "m",
    inlineEditing = false,
    tableController: {
      data,
      dataLoading,
      noMoreToLoad,
      dataLoadingError,
      filterValues,
      setFilterValues,
      sortBy,
      setSortBy,
      itemCount,
      setItemCount,
      pageSize = 50,
      paginationEnabled,
      checkFilterCombination,
      setPopupCell
    },
    filterable = true,
    emptyComponent,
    columns,
    forceFilter,
    highlightedRow,
    endAdornment,
    AddColumnComponent
  }) {
    const ref = useRef(null);
    const [selectedCell, setSelectedCell] = React__default.useState(void 0);
    const loadNextPage = () => {
      if (!paginationEnabled || dataLoading || noMoreToLoad) return;
      if (itemCount !== void 0) setItemCount?.(itemCount + pageSize);
    };
    const resetPagination = useCallback(() => {
      setItemCount?.(pageSize);
    }, [pageSize]);
    const onRowClick = useCallback(({
      rowData
    }) => {
      if (inlineEditing) return;
      return onEntityClick && onEntityClick(rowData);
    }, [onEntityClick, inlineEditing]);
    useOutsideAlerter(ref, () => {
      if (selectedCell) {
        unselect();
      }
    }, Boolean(selectedCell));
    useEffect(() => {
      const escFunction = (event) => {
        if (event.keyCode === 27) {
          unselect();
        }
      };
      document.addEventListener("keydown", escFunction, false);
      return () => {
        document.removeEventListener("keydown", escFunction, false);
      };
    });
    const select = useCallback((cell) => {
      setSelectedCell(cell);
    }, []);
    const unselect = useCallback(() => {
      setSelectedCell(void 0);
    }, []);
    const onFilterUpdate = useCallback((updatedFilterValues) => {
      setFilterValues?.({
        ...updatedFilterValues,
        ...forceFilter
      });
    }, [forceFilter]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectableTableContext.Provider, { value: {
      setPopupCell,
      select,
      onValueChange,
      size: size2 ?? "m",
      selectedCell
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-full w-full flex flex-col bg-white dark:bg-surface-950", ref, children: /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualTable, { data, columns, cellRenderer, onRowClick: inlineEditing ? void 0 : onEntityClick ? onRowClick : void 0, onEndReached: loadNextPage, onResetPagination: resetPagination, error: dataLoadingError, onColumnResize, rowHeight: getRowHeight(size2), loading: dataLoading, filter: filterValues, onFilterUpdate: setFilterValues ? onFilterUpdate : void 0, sortBy, onSortByUpdate: setSortBy, hoverRow, checkFilterCombination, createFilterField: filterable ? createFilterField : void 0, rowClassName: useCallback((entity) => {
      return highlightedRow?.(entity) ? "bg-surface-100 bg-opacity-75 dark:bg-surface-800 dark:bg-opacity-75" : "";
    }, [highlightedRow]), className: "flex-grow", emptyComponent, endAdornment, AddColumnComponent }) }) });
  },
  () => false
  // equal
);
function createFilterField({
  id: id2,
  filterValue,
  setFilterValue,
  column,
  hidden,
  setHidden
}) {
  if (!column.custom) {
    return null;
  }
  const {
    resolvedProperty
  } = column.custom;
  const isArray2 = resolvedProperty?.dataType === "array";
  const baseProperty2 = isArray2 ? resolvedProperty.of : resolvedProperty;
  if (!baseProperty2) {
    return null;
  }
  if (baseProperty2.dataType === "reference") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ReferenceFilterField, { value: filterValue, setValue: setFilterValue, name: id2, isArray: isArray2, path: baseProperty2.path, title: resolvedProperty?.name, includeId: baseProperty2.includeId, previewProperties: baseProperty2?.previewProperties, hidden, setHidden });
  } else if (baseProperty2.dataType === "number" || baseProperty2.dataType === "string") {
    const name = baseProperty2.name;
    const enumValues = baseProperty2.enumValues ? enumToObjectEntries(baseProperty2.enumValues) : void 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(StringNumberFilterField, { value: filterValue, setValue: setFilterValue, name: id2, dataType: baseProperty2.dataType, isArray: isArray2, enumValues, title: name });
  } else if (baseProperty2.dataType === "boolean") {
    const name = baseProperty2.name;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanFilterField, { value: filterValue, setValue: setFilterValue, name: id2, title: name });
  } else if (baseProperty2.dataType === "date") {
    const title = baseProperty2.name;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DateTimeFilterField, { value: filterValue, setValue: setFilterValue, name: id2, mode: baseProperty2.mode, isArray: isArray2, title });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: `Currently the filter field ${resolvedProperty.dataType} is not supported` });
}
const EntityCollectionTable = function EntityCollectionTable2({
  className,
  style: style2,
  forceFilter,
  actionsStart,
  actions,
  title,
  tableRowActionsBuilder,
  uniqueFieldValidator,
  getPropertyFor,
  onValueChange,
  selectionController,
  highlightedEntities,
  onEntityClick,
  onColumnResize,
  onSizeChanged,
  textSearchEnabled = false,
  hoverRow = true,
  inlineEditing = false,
  additionalFields,
  displayedColumnIds,
  defaultSize,
  properties,
  tableController,
  filterable = true,
  sortable = true,
  endAdornment,
  AddColumnComponent,
  AdditionalHeaderWidget,
  additionalIDHeaderWidget,
  emptyComponent,
  getIdColumnWidth,
  onTextSearchClick,
  textSearchLoading,
  enablePopupIcon
}) {
  const ref = useRef(null);
  const largeLayout = useLargeLayout();
  const selectedEntities = (selectionController?.selectedEntities?.length > 0 ? selectionController?.selectedEntities : highlightedEntities)?.filter(Boolean);
  const context = useFireCMSContext();
  const [size2, setSize] = React__default.useState(defaultSize ?? "m");
  const updateSize = useCallback((size_0) => {
    if (onSizeChanged) onSizeChanged(size_0);
    setSize(size_0);
  }, []);
  const onTextSearch = useCallback((newSearchString) => tableController.setSearchString?.(newSearchString), []);
  const additionalFieldsMap = useMemo(() => {
    return additionalFields ? additionalFields.map((aC) => ({
      [aC.key]: aC
    })).reduce((a2, b) => ({
      ...a2,
      ...b
    }), {}) : {};
  }, [additionalFields]);
  const customFieldValidator = uniqueFieldValidator;
  const propertyCellRenderer = ({
    column,
    columnIndex,
    rowData,
    rowIndex
  }) => {
    const entity = rowData;
    const propertyKey = column.key;
    let disabled = column.custom?.disabled;
    const property2 = getPropertyFor?.({
      propertyKey,
      entity
    }) ?? column.custom.resolvedProperty;
    if (!property2?.disabled) {
      disabled = false;
    }
    if (!property2) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: entity ? /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyTableCell, { readonly: !inlineEditing, align: column.align ?? "left", propertyKey, property: property2, value: entity?.values ? getValueInPath(entity.values, propertyKey) : void 0, customFieldValidator, columnIndex, width: column.width, height: getRowHeight(size2), entity, disabled, enablePopupIcon, path: entity.path }, `property_table_cell_${entity.id}_${propertyKey}`) : renderSkeletonText() });
  };
  const additionalCellRenderer = useCallback(({
    column: column_0,
    rowData: rowData_0,
    width
  }) => {
    const entity_0 = rowData_0;
    const additionalField = additionalFieldsMap[column_0.key];
    const value_0 = additionalField.dependencies ? Object.entries(entity_0.values).filter(([key, value]) => additionalField.dependencies.includes(key)).reduce((a_0, b_0) => ({
      ...a_0,
      ...b_0
    }), {}) : entity_0;
    const Builder = additionalField.Builder;
    if (!Builder && !additionalField.value) {
      throw new Error("When using additional fields you need to provide a Builder or a value");
    }
    const child = Builder ? /* @__PURE__ */ jsxRuntimeExports.jsx(Builder, { entity: entity_0, context }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: additionalField.value?.({
      entity: entity_0,
      context
    })?.toString() });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(EntityTableCell, { width, size: size2, value: value_0, selected: false, disabled: true, align: "left", allowScroll: false, showExpandIcon: false, disabledTooltip: "This column can't be edited directly", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: child }) }, `additional_table_cell_${entity_0.id}_${column_0.key}`);
  }, [size2]);
  const collectionColumns = (() => {
    const columnsResult = propertiesToColumns({
      properties,
      sortable,
      forceFilter,
      AdditionalHeaderWidget
    });
    const additionalTableColumns = additionalFields ? additionalFields.map((additionalField_0) => ({
      key: additionalField_0.key,
      align: "left",
      sortable: false,
      title: additionalField_0.name,
      width: additionalField_0.width ?? 200
    })) : [];
    return [...columnsResult, ...additionalTableColumns];
  })();
  const idColumn = {
    key: "id_ewcfedcswdf3",
    width: getIdColumnWidth?.() ?? (largeLayout ? 160 : 130),
    title: "ID",
    resizable: false,
    frozen: largeLayout,
    headerAlign: "center",
    align: "center",
    AdditionalHeaderWidget: () => additionalIDHeaderWidget
  };
  const columns = [idColumn, ...displayedColumnIds ? displayedColumnIds.map((p2) => {
    return collectionColumns.find((c2) => c2.key === p2.key);
  }).filter(Boolean) : collectionColumns];
  const cellRenderer = useCallback((props) => {
    const column_1 = props.column;
    const columns_0 = props.columns;
    const columnKey = column_1.key;
    try {
      if (props.columnIndex === 0) {
        if (tableRowActionsBuilder) return tableRowActionsBuilder({
          entity: props.rowData,
          size: size2,
          width: column_1.width,
          frozen: column_1.frozen
        });
        else return /* @__PURE__ */ jsxRuntimeExports.jsx(EntityCollectionRowActions, { entity: props.rowData, width: column_1.width, frozen: column_1.frozen, isSelected: false, size: size2 });
      } else if (additionalFieldsMap[columnKey]) {
        return additionalCellRenderer(props);
      } else if (props.columnIndex < columns_0.length + 1) {
        return propertyCellRenderer(props);
      } else {
        throw Error("Internal: columns not mapped properly");
      }
    } catch (e2) {
      console.error("Error rendering cell", e2);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(EntityTableCell, { size: size2, width: column_1.width, saved: false, value: null, align: "left", fullHeight: false, disabled: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView, { error: e2 }) });
    }
  }, [tableRowActionsBuilder, additionalCellRenderer, propertyCellRenderer, size2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref, style: style2, className: cls("h-full w-full flex flex-col bg-white dark:bg-surface-950", className), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionTableToolbar, { onTextSearch: textSearchEnabled ? onTextSearch : void 0, textSearchLoading, onTextSearchClick: textSearchEnabled ? onTextSearchClick : void 0, size: size2, onSizeChanged: updateSize, title, actionsStart, actions, loading: tableController.dataLoading }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectableTable, { columns, size: size2, inlineEditing, cellRenderer, onEntityClick, highlightedRow: (entity_1) => Boolean(selectedEntities?.find((e_0) => e_0.id === entity_1.id && e_0.path === entity_1.path)), tableController, onValueChange, onColumnResize, hoverRow, filterable, emptyComponent, endAdornment, AddColumnComponent })
  ] });
};
function useDataOrder({
  data,
  entitiesDisplayedFirst
}) {
  if (!entitiesDisplayedFirst) return data;
  const displayedFirstId = new Set(entitiesDisplayedFirst.map((e2) => e2.id));
  return [...entitiesDisplayedFirst, ...data.filter((e2) => !displayedFirstId.has(e2.id))];
}
function useDebouncedData(data, deps, timeoutMs = 5e3) {
  const [deferredData, setDeferredData] = React__default.useState(data);
  const dataLength = React__default.useRef(deferredData.length ?? 0);
  const pendingUpdate = React__default.useRef(false);
  const currentDeps = React__default.useRef(deps);
  const haveDepsChanged = !equal(currentDeps.current, deps);
  const immediateUpdate = data.length >= dataLength.current || haveDepsChanged;
  React__default.useEffect(() => {
    const performUpdate = () => {
      if (!equal(deferredData, data)) {
        currentDeps.current = deps;
        dataLength.current = data.length;
        setDeferredData(data);
      }
      pendingUpdate.current = false;
    };
    pendingUpdate.current = true;
    let handler;
    if (immediateUpdate) performUpdate();
    else handler = setTimeout(performUpdate, timeoutMs);
    return () => {
      clearTimeout(handler);
      if (pendingUpdate.current && immediateUpdate) performUpdate();
    };
  }, [data, timeoutMs, deps, immediateUpdate]);
  return immediateUpdate ? data : deferredData;
}
const DEFAULT_PAGE_SIZE = 50;
function useDataSourceEntityCollectionTableController({
  fullPath,
  collection,
  entitiesDisplayedFirst,
  lastDeleteTimestamp,
  forceFilter: forceFilterFromProps
}) {
  const {
    initialFilter,
    initialSort,
    forceFilter: forceFilterFromCollection
  } = collection;
  const [popupCell, setPopupCell] = React__default.useState(void 0);
  const navigation = useNavigationController();
  const dataSource = useDataSource();
  const resolvedPath = useMemo(() => navigation.resolveAliasesFrom(fullPath), [fullPath, navigation.resolveAliasesFrom]);
  const forceFilter = forceFilterFromProps ?? forceFilterFromCollection;
  const paginationEnabled = collection.pagination === void 0 || Boolean(collection.pagination);
  const pageSize = typeof collection.pagination === "number" ? collection.pagination : DEFAULT_PAGE_SIZE;
  const [searchString, setSearchString] = React__default.useState();
  const [itemCount, setItemCount] = React__default.useState(paginationEnabled ? pageSize : void 0);
  const checkFilterCombination = useCallback((filterValues, sortBy) => {
    if (!dataSource.isFilterCombinationValid) return true;
    return dataSource.isFilterCombinationValid({
      path: resolvedPath,
      collection,
      filterValues,
      sortBy
    });
  }, []);
  const initialSortInternal = useMemo(() => {
    if (initialSort && forceFilter && !checkFilterCombination(forceFilter, initialSort)) {
      console.warn("Initial sort is not compatible with the force filter. Ignoring initial sort");
      return void 0;
    }
    return initialSort;
  }, [initialSort, forceFilter]);
  useEffect(() => {
    if (!equal(forceFilter, filterValues_0)) {
      setFilterValues(forceFilter);
    }
  }, [forceFilter]);
  const [filterValues_0, setFilterValues] = React__default.useState(forceFilter ?? initialFilter ?? void 0);
  const [sortBy_0, setSortBy] = React__default.useState(initialSortInternal);
  const sortByProperty = sortBy_0 ? sortBy_0[0] : void 0;
  const currentSort = sortBy_0 ? sortBy_0[1] : void 0;
  const context = useFireCMSContext();
  const [rawData, setRawData] = useState([]);
  const [dataLoading, setDataLoading] = useState(false);
  const [dataLoadingError, setDataLoadingError] = useState();
  const [noMoreToLoad, setNoMoreToLoad] = useState(false);
  const clearFilter = useCallback(() => setFilterValues(forceFilter ?? void 0), [forceFilter]);
  const updateFilterValues = useCallback((updatedFilter) => {
    if (forceFilter) {
      console.warn("Filter is not compatible with the force filter. Ignoring filter");
      return;
    }
    if (updatedFilter && Object.keys(updatedFilter).length === 0) {
      setFilterValues(void 0);
    } else {
      setFilterValues(updatedFilter);
    }
  }, [forceFilter]);
  useEffect(() => {
    setDataLoading(true);
    const onEntitiesUpdate = async (entities) => {
      if (collection.callbacks?.onFetch) {
        try {
          entities = await Promise.all(entities.map((entity) => collection.callbacks.onFetch({
            collection,
            path: resolvedPath,
            entity,
            context
          })));
        } catch (e2) {
          console.error(e2);
        }
      }
      setDataLoading(false);
      setDataLoadingError(void 0);
      setRawData(entities.map((e_0) => ({
        ...e_0
        // values: sanitizeData(e.values, resolvedCollection.properties)
      })));
      setNoMoreToLoad(!itemCount || entities.length < itemCount);
    };
    const onError = (error) => {
      console.error("ERROR", error);
      setDataLoading(false);
      setRawData([]);
      setDataLoadingError(error);
    };
    if (dataSource.listenCollection) {
      return dataSource.listenCollection({
        path: resolvedPath,
        collection,
        onUpdate: onEntitiesUpdate,
        onError,
        searchString,
        filter: filterValues_0,
        limit: itemCount,
        startAfter: void 0,
        orderBy: sortByProperty,
        order: currentSort
      });
    } else {
      dataSource.fetchCollection({
        path: resolvedPath,
        collection,
        searchString,
        filter: filterValues_0,
        limit: itemCount,
        startAfter: void 0,
        orderBy: sortByProperty,
        order: currentSort
      }).then(onEntitiesUpdate).catch(onError);
      return () => {
      };
    }
  }, [resolvedPath, itemCount, currentSort, sortByProperty, filterValues_0, searchString]);
  const orderedData = useDataOrder({
    data: rawData,
    entitiesDisplayedFirst
  });
  const data = useDebouncedData(orderedData, {
    filterValues: filterValues_0,
    sortBy: sortBy_0,
    searchString,
    lastDeleteTimestamp
  });
  return {
    data,
    dataLoading,
    noMoreToLoad,
    dataLoadingError,
    filterValues: filterValues_0,
    setFilterValues: updateFilterValues,
    sortBy: sortBy_0,
    setSortBy,
    searchString,
    setSearchString,
    clearFilter,
    itemCount,
    setItemCount,
    paginationEnabled,
    pageSize,
    checkFilterCombination,
    popupCell,
    setPopupCell
  };
}
function useSelectionController(onSelectionChange) {
  const [selectedEntities, setSelectedEntities] = useState([]);
  const toggleEntitySelection = useCallback((entity, newSelectedState) => {
    let newValue;
    if (newSelectedState === void 0) {
      const isSelected = Boolean(selectedEntities.find((e2) => e2.id === entity.id && e2.path === entity.path));
      if (isSelected) {
        onSelectionChange?.(entity, false);
        newValue = selectedEntities.filter((item) => !(item.id === entity.id && item.path === entity.path));
      } else {
        onSelectionChange?.(entity, true);
        newValue = [...selectedEntities, entity];
      }
    } else {
      if (newSelectedState) {
        onSelectionChange?.(entity, true);
        newValue = [...selectedEntities, entity];
      } else {
        onSelectionChange?.(entity, false);
        newValue = selectedEntities.filter((item_0) => !(item_0.id === entity.id && item_0.path === entity.path));
      }
    }
    setSelectedEntities(newValue);
  }, [selectedEntities]);
  const isEntitySelected = useCallback((entity_0) => {
    return Boolean(selectedEntities.find((e_0) => e_0.id === entity_0.id && e_0.path === entity_0.path));
  }, [selectedEntities]);
  return {
    selectedEntities,
    setSelectedEntities,
    isEntitySelected,
    toggleEntitySelection
  };
}
function useTableSearchHelper(t0) {
  const $ = c_1(33);
  const {
    collection,
    fullPath,
    parentCollectionIds
  } = t0;
  const context = useFireCMSContext();
  const customizationController = useCustomizationController();
  const dataSource = useDataSource();
  const [textSearchLoading, setTextSearchLoading] = useState(false);
  const [textSearchInitialised, setTextSearchInitialised] = useState(false);
  let onTextSearchClick;
  let textSearchEnabled;
  if ($[0] !== collection || $[1] !== context || $[2] !== customizationController.plugins || $[3] !== dataSource || $[4] !== fullPath || $[5] !== parentCollectionIds) {
    textSearchEnabled = Boolean(collection.textSearchEnabled);
    let props;
    let t12;
    if ($[8] !== collection || $[9] !== context || $[10] !== customizationController.plugins || $[11] !== fullPath || $[12] !== parentCollectionIds) {
      props = {
        context,
        path: fullPath,
        databaseId: collection.databaseId,
        collection,
        parentCollectionIds
      };
      t12 = customizationController.plugins?.find((p2) => p2.collectionView?.blockSearch?.(props));
      $[8] = collection;
      $[9] = context;
      $[10] = customizationController.plugins;
      $[11] = fullPath;
      $[12] = parentCollectionIds;
      $[13] = props;
      $[14] = t12;
    } else {
      props = $[13];
      t12 = $[14];
    }
    const searchBlocked = t12;
    let t22;
    if ($[15] !== customizationController.plugins || $[16] !== dataSource?.initTextSearch) {
      t22 = Boolean(dataSource?.initTextSearch) || customizationController.plugins?.find(_temp$h);
      $[15] = customizationController.plugins;
      $[16] = dataSource?.initTextSearch;
      $[17] = t22;
    } else {
      t22 = $[17];
    }
    const addTextSearchClickListener = t22;
    if (addTextSearchClickListener) {
      let t3;
      if ($[18] !== addTextSearchClickListener || $[19] !== collection || $[20] !== context || $[21] !== customizationController.plugins || $[22] !== dataSource || $[23] !== fullPath || $[24] !== parentCollectionIds || $[25] !== props || $[26] !== searchBlocked) {
        t3 = addTextSearchClickListener ? () => {
          setTextSearchLoading(true);
          const promises = [];
          if (dataSource?.initTextSearch && !searchBlocked) {
            promises.push(dataSource.initTextSearch(props));
          }
          if (searchBlocked) {
            customizationController.plugins?.forEach((p_1) => {
              if (p_1.collectionView?.onTextSearchClick) {
                promises.push(p_1.collectionView.onTextSearchClick({
                  context,
                  path: fullPath,
                  collection,
                  parentCollectionIds
                }));
              }
            });
          }
          return Promise.all(promises).then((res) => {
            if (res.every(Boolean)) {
              setTextSearchInitialised(true);
            }
          }).finally(() => setTextSearchLoading(false));
        } : void 0;
        $[18] = addTextSearchClickListener;
        $[19] = collection;
        $[20] = context;
        $[21] = customizationController.plugins;
        $[22] = dataSource;
        $[23] = fullPath;
        $[24] = parentCollectionIds;
        $[25] = props;
        $[26] = searchBlocked;
        $[27] = t3;
      } else {
        t3 = $[27];
      }
      onTextSearchClick = t3;
      customizationController.plugins?.forEach((p_2) => {
        if (!textSearchEnabled) {
          if (p_2.collectionView?.showTextSearchBar) {
            textSearchEnabled = p_2.collectionView.showTextSearchBar({
              context,
              path: fullPath,
              collection,
              parentCollectionIds
            });
          }
        }
      });
    }
    $[0] = collection;
    $[1] = context;
    $[2] = customizationController.plugins;
    $[3] = dataSource;
    $[4] = fullPath;
    $[5] = parentCollectionIds;
    $[6] = textSearchEnabled;
    $[7] = onTextSearchClick;
  } else {
    textSearchEnabled = $[6];
    onTextSearchClick = $[7];
  }
  const t1 = textSearchEnabled;
  let t2;
  if ($[28] !== onTextSearchClick || $[29] !== t1 || $[30] !== textSearchInitialised || $[31] !== textSearchLoading) {
    t2 = {
      textSearchLoading,
      textSearchInitialised,
      onTextSearchClick,
      textSearchEnabled: t1
    };
    $[28] = onTextSearchClick;
    $[29] = t1;
    $[30] = textSearchInitialised;
    $[31] = textSearchLoading;
    $[32] = t2;
  } else {
    t2 = $[32];
  }
  return t2;
}
function _temp$h(p_0) {
  return Boolean(p_0.collectionView?.onTextSearchClick);
}
function DeleteEntityDialog({
  entityOrEntitiesToDelete,
  collection,
  onClose,
  open,
  callbacks,
  onEntityDelete,
  onMultipleEntitiesDelete,
  path
}) {
  const dataSource = useDataSource();
  const customizationController = useCustomizationController();
  const snackbarController = useSnackbarController();
  const [loading, setLoading] = useState(false);
  const context = useFireCMSContext();
  const entityOrEntities = Array.isArray(entityOrEntitiesToDelete) && entityOrEntitiesToDelete.length === 1 ? entityOrEntitiesToDelete[0] : entityOrEntitiesToDelete;
  const multipleEntities = Array.isArray(entityOrEntities);
  const resolvedCollection = useMemo(() => resolveCollection({
    collection,
    path,
    propertyConfigs: customizationController.propertyConfigs
  }), [collection, path]);
  const handleCancel = useCallback(() => {
    onClose();
  }, [onClose]);
  const onDeleteSuccess = useCallback((entity) => {
    console.debug("Deleted", entity);
  }, []);
  const onDeleteFailure = useCallback((entity_0, e2) => {
    snackbarController.open({
      type: "error",
      message: "Error deleting: " + e2?.message
    });
    console.error("Error deleting entity");
    console.error(e2);
  }, [resolvedCollection.name]);
  const onPreDeleteHookError = useCallback((entity_1, e_0) => {
    snackbarController.open({
      type: "error",
      message: "Error before deleting: " + e_0?.message
    });
    console.error(e_0);
  }, [resolvedCollection.name]);
  const onDeleteSuccessHookError = useCallback((entity_2, e_1) => {
    snackbarController.open({
      type: "error",
      message: "Error after deleting: " + e_1?.message
    });
    console.error(e_1);
  }, [resolvedCollection.name]);
  const performDelete = useCallback((entity_3) => deleteEntityWithCallbacks({
    dataSource,
    entity: entity_3,
    collection: resolvedCollection,
    callbacks,
    onDeleteSuccess,
    onDeleteFailure,
    onPreDeleteHookError,
    onDeleteSuccessHookError,
    context
  }), [dataSource, resolvedCollection, callbacks, onDeleteSuccess, onDeleteFailure, onPreDeleteHookError, onDeleteSuccessHookError, context]);
  const handleOk = useCallback(async () => {
    if (entityOrEntities) {
      setLoading(true);
      if (multipleEntities) {
        Promise.all(entityOrEntities.map(performDelete)).then((results) => {
          setLoading(false);
          if (onMultipleEntitiesDelete && entityOrEntities) onMultipleEntitiesDelete(path, entityOrEntities);
          if (results.every(Boolean)) {
            snackbarController.open({
              type: "success",
              message: `${resolvedCollection.name}: multiple deleted`
            });
          } else if (results.some(Boolean)) {
            snackbarController.open({
              type: "warning",
              message: `${resolvedCollection.name}: Some of the entities have been deleted, but not all`
            });
          } else {
            snackbarController.open({
              type: "error",
              message: `${resolvedCollection.name}: Error deleting entities`
            });
          }
          onClose();
        });
      } else {
        performDelete(entityOrEntities).then((success) => {
          setLoading(false);
          if (success) {
            if (onEntityDelete && entityOrEntities) onEntityDelete(path, entityOrEntities);
            snackbarController.open({
              type: "success",
              message: `${resolvedCollection.singularName ?? resolvedCollection.name} deleted`
            });
            onClose();
          }
        });
      }
    }
  }, [entityOrEntities, multipleEntities, performDelete, onMultipleEntitiesDelete, path, onClose, snackbarController, resolvedCollection.name, onEntityDelete]);
  let content;
  if (entityOrEntities && multipleEntities) {
    content = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "Multiple entities" });
  } else {
    const entity_4 = entityOrEntities;
    content = entity_4 ? /* @__PURE__ */ jsxRuntimeExports.jsx(EntityView, { entity: entity_4, collection, path }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  }
  const dialogTitle = multipleEntities ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: resolvedCollection.name }),
    ": Confirm multiple delete?"
  ] }) : `Would you like to delete this ${resolvedCollection.singularName ?? resolvedCollection.name}?`;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { maxWidth: multipleEntities ? "lg" : "2xl", "aria-labelledby": "delete-dialog", open, onOpenChange: (open_0) => !open_0 ? onClose() : void 0, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { id: "delete-dialog-title", children: dialogTitle }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { fullHeight: true, children: !multipleEntities && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4", children: content }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions, { children: [
      loading && /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: "small" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleCancel, disabled: loading, variant: "text", color: "primary", children: "Cancel" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { autoFocus: true, disabled: loading, onClick: handleOk, variant: "filled", color: "primary", children: "Ok" })
    ] })
  ] });
}
function addRecentId(collectionId, id2) {
  const recentIds = getRecentIds(collectionId);
  const newRecentIds = [id2, ...recentIds.filter((i) => i !== id2)];
  if (newRecentIds.length > 5) {
    newRecentIds.pop();
  }
  saveSearchedIdsLocally(collectionId, newRecentIds);
  return newRecentIds;
}
function saveSearchedIdsLocally(collectionId, ids) {
  localStorage.setItem("recent_id_searches::" + collectionId, JSON.stringify(ids));
}
function getRecentIds(collectionId) {
  const stored = localStorage.getItem("recent_id_searches::" + collectionId);
  if (!stored) return [];
  return JSON.parse(stored);
}
const editEntityAction = {
  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(EditIcon, {}),
  name: "Edit",
  collapsed: false,
  onClick({
    entity,
    collection,
    fullPath,
    context,
    highlightEntity,
    unhighlightEntity
  }) {
    highlightEntity?.(entity);
    context.analyticsController?.onAnalyticsEvent?.("entity_click", {
      path: entity.path,
      entityId: entity.id
    });
    if (collection) {
      addRecentId(collection.id, entity.id);
    }
    const path = collection?.collectionGroup ? entity.path : fullPath ?? entity.path;
    context.sideEntityController.open({
      entityId: entity.id,
      path,
      collection,
      updateUrl: true,
      onClose: () => unhighlightEntity?.(entity)
    });
    return Promise.resolve(void 0);
  }
};
const copyEntityAction = {
  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FileCopyIcon, {}),
  name: "Copy",
  onClick({
    entity,
    collection,
    context,
    highlightEntity,
    unhighlightEntity
  }) {
    highlightEntity?.(entity);
    context.analyticsController?.onAnalyticsEvent?.("copy_entity_click", {
      path: entity.path,
      entityId: entity.id
    });
    context.sideEntityController.open({
      entityId: entity.id,
      path: entity.path,
      copy: true,
      collection,
      updateUrl: true,
      onClose: () => unhighlightEntity?.(entity)
    });
    return Promise.resolve(void 0);
  }
};
const archiveEntityAction = {
  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(ArchiveIcon, {}),
  name: "Archive",
  onClick({
    entity,
    collection,
    context: {
      dataSource
    }
  }) {
    return Promise.resolve(void 0);
  }
};
const openWebsiteAction = {
  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(OpenInNewIcon, {}),
  name: "See in website",
  onClick({
    entity,
    collection,
    context
  }) {
    window.open(`https://example.com/${entity.id}`, "_blank");
    return Promise.resolve(void 0);
  }
};
const deleteEntityAction = {
  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteIcon, {}),
  name: "Delete",
  onClick({
    entity,
    fullPath,
    collection,
    context,
    selectionController,
    onCollectionChange,
    sideEntityController
  }) {
    const {
      closeDialog
    } = context.dialogsController.open({
      key: "delete_entity_dialog_" + entity.id,
      Component: ({
        open
      }) => {
        if (!collection || !fullPath) throw new Error("deleteEntityAction: Collection is undefined");
        return /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteEntityDialog, { entityOrEntitiesToDelete: entity, path: fullPath, collection, callbacks: collection.callbacks, open, onEntityDelete: () => {
          context.analyticsController?.onAnalyticsEvent?.("single_entity_deleted", {
            path: fullPath
          });
          selectionController?.setSelectedEntities(selectionController.selectedEntities.filter((e2) => e2.id !== entity.id));
          onCollectionChange?.();
          sideEntityController?.close();
        }, onClose: closeDialog });
      }
    });
    return Promise.resolve(void 0);
  }
};
function ReferenceSelectionTable({
  onSingleEntitySelected,
  onMultipleEntitiesSelected,
  multiselect,
  collection,
  path: pathInput,
  selectedEntityIds: selectedEntityIdsProp,
  description,
  forceFilter,
  maxSelection
}) {
  const sideDialogContext = useSideDialogContext();
  const sideEntityController = useSideEntityController();
  const navigation = useNavigationController();
  const analyticsController = useAnalyticsController();
  const customizationController = useCustomizationController();
  const fullPath = navigation.resolveAliasesFrom(pathInput);
  const dataSource = useDataSource();
  const [entitiesDisplayedFirst, setEntitiesDisplayedFirst] = useState([]);
  const toggleEntitySelection = (entity) => {
    let newValue;
    const selectedEntities = selectionController.selectedEntities;
    analyticsController.onAnalyticsEvent?.("reference_selection_toggle", {
      path: fullPath,
      entityId: entity.id
    });
    if (selectedEntities) {
      if (selectedEntities.map((e2) => e2.id).indexOf(entity.id) > -1) {
        newValue = selectedEntities.filter((item) => item.id !== entity.id);
      } else {
        if (maxSelection && selectedEntities.length >= maxSelection) return;
        newValue = [...selectedEntities, entity];
      }
      selectionController.setSelectedEntities(newValue);
      if (onMultipleEntitiesSelected) onMultipleEntitiesSelected(newValue);
    }
  };
  const selectionController = useSelectionController(toggleEntitySelection);
  useEffect(() => {
    let unmounted = false;
    const selectedEntityIds = selectedEntityIdsProp?.map((id2) => id2?.toString()).filter(Boolean);
    if (selectedEntityIds && collection) {
      Promise.all(selectedEntityIds.map((entityId) => dataSource.fetchEntity({
        path: fullPath,
        entityId,
        collection
      }))).then((entities) => {
        if (!unmounted) {
          const result = entities.filter((e_0) => e_0 !== void 0);
          selectionController.setSelectedEntities(result);
          setEntitiesDisplayedFirst(result);
        }
      });
    } else {
      selectionController.setSelectedEntities([]);
      setEntitiesDisplayedFirst([]);
    }
    return () => {
      unmounted = true;
    };
  }, [dataSource, fullPath, selectedEntityIdsProp, collection, selectionController.setSelectedEntities]);
  const onClear = () => {
    analyticsController.onAnalyticsEvent?.("reference_selection_clear", {
      path: fullPath
    });
    selectionController.setSelectedEntities([]);
    if (!multiselect && onSingleEntitySelected) {
      onSingleEntitySelected(null);
    } else if (onMultipleEntitiesSelected) {
      onMultipleEntitiesSelected([]);
    }
  };
  const onEntityClick = (entity_0) => {
    if (!multiselect && onSingleEntitySelected) {
      analyticsController.onAnalyticsEvent?.("reference_selected_single", {
        path: fullPath,
        entityId: entity_0.id
      });
      onSingleEntitySelected(entity_0);
      sideDialogContext.close(false);
    } else {
      toggleEntitySelection(entity_0);
    }
  };
  const onNewClick = () => {
    analyticsController.onAnalyticsEvent?.("reference_selection_new_entity", {
      path: fullPath
    });
    sideEntityController.open({
      path: fullPath,
      collection,
      updateUrl: true,
      onUpdate: ({
        entity: entity_1
      }) => {
        setEntitiesDisplayedFirst([entity_1, ...entitiesDisplayedFirst]);
        onEntityClick(entity_1);
      },
      closeOnSave: true
    });
  };
  const tableRowActionsBuilder = ({
    entity: entity_2,
    size: size2,
    width,
    frozen
  }) => {
    const selectedEntities_0 = selectionController.selectedEntities;
    const isSelected = selectedEntities_0 && selectedEntities_0.map((e_1) => e_1.id).indexOf(entity_2.id) > -1;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(EntityCollectionRowActions, { width, frozen, entity: entity_2, size: size2, isSelected, selectionEnabled: multiselect, hideId: collection?.hideIdFromCollection, fullPath, selectionController });
  };
  const onDone = useCallback((event) => {
    event.stopPropagation();
    sideDialogContext.close(false);
  }, [sideDialogContext]);
  if (!collection) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView, { error: "Could not find collection with id " + collection });
  }
  const resolvedCollection = useMemo(() => resolveCollection({
    collection,
    path: fullPath,
    values: {},
    propertyConfigs: customizationController.propertyConfigs
  }), [collection, customizationController.propertyConfigs, fullPath]);
  const displayedColumnIds = useColumnIds(resolvedCollection, false);
  const tableController = useDataSourceEntityCollectionTableController({
    fullPath,
    collection,
    entitiesDisplayedFirst,
    forceFilter
  });
  const {
    textSearchLoading,
    textSearchInitialised,
    onTextSearchClick,
    textSearchEnabled
  } = useTableSearchHelper({
    collection,
    fullPath
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col h-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow", children: entitiesDisplayedFirst && /* @__PURE__ */ jsxRuntimeExports.jsx(EntityCollectionTable, { textSearchLoading, onTextSearchClick: textSearchInitialised ? void 0 : onTextSearchClick, textSearchEnabled, displayedColumnIds, onEntityClick, tableController, enablePopupIcon: false, tableRowActionsBuilder, title: /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "subtitle2", className: "flex flex-row gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IconForView, { size: "small", collectionOrView: collection, className: "text-surface-300 dark:text-surface-600" }),
      collection.singularName ? `Select ${collection.singularName}` : `Select from ${collection.name}`
    ] }), defaultSize: collection.defaultSize, properties: resolvedCollection.properties, forceFilter, inlineEditing: false, selectionController, actions: /* @__PURE__ */ jsxRuntimeExports.jsx(ReferenceDialogActions, { collection, path: fullPath, onNewClick, onClear }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions, { translucent: false, children: [
      description && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", className: "flex-grow text-left", children: description }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onDone, color: "primary", variant: "filled", children: "Done" })
    ] })
  ] });
}
function ReferenceDialogActions(t0) {
  const $ = c_1(13);
  const {
    collection,
    path,
    onClear,
    onNewClick
  } = t0;
  const authController = useAuthController();
  const largeLayout = useLargeLayout();
  let t1;
  if ($[0] !== onNewClick) {
    t1 = onNewClick ? (e2) => {
      e2.preventDefault();
      onNewClick();
    } : void 0;
    $[0] = onNewClick;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const onClick = t1;
  let t2;
  if ($[2] !== authController || $[3] !== collection || $[4] !== largeLayout || $[5] !== onClick || $[6] !== path) {
    t2 = canCreateEntity(collection, authController, path, null) && onClick && (largeLayout ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick, startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon, {}), variant: "outlined", color: "primary", children: [
      "Add ",
      collection.singularName ?? collection.name
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick, variant: "outlined", color: "primary", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon, {}) }));
    $[2] = authController;
    $[3] = collection;
    $[4] = largeLayout;
    $[5] = onClick;
    $[6] = path;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  const addButton = t2;
  let t3;
  if ($[8] !== onClear) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onClear, variant: "text", color: "primary", children: "Clear" });
    $[8] = onClear;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  let t4;
  if ($[10] !== addButton || $[11] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t3,
      addButton
    ] });
    $[10] = addButton;
    $[11] = t3;
    $[12] = t4;
  } else {
    t4 = $[12];
  }
  return t4;
}
function toArray(input) {
  return Array.isArray(input) ? input : input ? [input] : [];
}
function NavigationGroup(t0) {
  const $ = c_1(14);
  const {
    children,
    group
  } = t0;
  const userConfigurationPersistence = useUserConfigurationPersistence();
  const t1 = !(userConfigurationPersistence?.collapsedGroups ?? []).includes(group ?? "ungrouped");
  let t2;
  if ($[0] !== group || $[1] !== userConfigurationPersistence) {
    t2 = (expanded) => {
      if (userConfigurationPersistence) {
        if (!expanded) {
          const paths = (userConfigurationPersistence.collapsedGroups ?? []).concat(group ?? "ungrouped");
          userConfigurationPersistence.setCollapsedGroups(paths);
        } else {
          userConfigurationPersistence.setCollapsedGroups((userConfigurationPersistence.collapsedGroups ?? []).filter((g) => g !== (group ?? "ungrouped")));
        }
      }
    };
    $[0] = group;
    $[1] = userConfigurationPersistence;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  let t3;
  if ($[3] !== group) {
    t3 = group?.toUpperCase() ?? "Views".toUpperCase();
    $[3] = group;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { color: "secondary", className: "font-medium ml-1", children: t3 });
    $[5] = t3;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  let t5;
  if ($[7] !== children) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-8", children });
    $[7] = children;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  let t6;
  if ($[9] !== t1 || $[10] !== t2 || $[11] !== t4 || $[12] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandablePanel, { invisible: true, titleClassName: "font-medium text-sm text-surface-600 dark:text-surface-400", innerClassName: "py-4", initiallyExpanded: t1, onExpandedChange: t2, title: t4, children: t5 });
    $[9] = t1;
    $[10] = t2;
    $[11] = t4;
    $[12] = t5;
    $[13] = t6;
  } else {
    t6 = $[13];
  }
  return t6;
}
function NavigationCard(t0) {
  const $ = c_1(23);
  const {
    name,
    description,
    icon,
    actions,
    onClick
  } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = cls("h-full p-4 cursor-pointer min-h-[230px]");
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let t2;
  if ($[1] !== onClick) {
    t2 = () => {
      onClick?.();
    };
    $[1] = onClick;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  let t3;
  if ($[3] !== actions) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-1", onClick: _temp$g, children: actions });
    $[3] = actions;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== icon || $[6] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "h-10 flex items-center w-full justify-between text-surface-300 dark:text-surface-600", children: [
      icon,
      t3
    ] });
    $[5] = icon;
    $[6] = t3;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  let t5;
  if ($[8] !== name) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { gutterBottom: true, variant: "h5", component: "h2", children: name });
    $[8] = name;
    $[9] = t5;
  } else {
    t5 = $[9];
  }
  let t6;
  if ($[10] !== description) {
    t6 = description && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "secondary", component: "div", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Markdown, { source: description, size: "small" }) });
    $[10] = description;
    $[11] = t6;
  } else {
    t6 = $[11];
  }
  let t7;
  if ($[12] !== t4 || $[13] !== t5 || $[14] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-grow w-full", children: [
      t4,
      t5,
      t6
    ] });
    $[12] = t4;
    $[13] = t5;
    $[14] = t6;
    $[15] = t7;
  } else {
    t7 = $[15];
  }
  let t8;
  if ($[16] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = {
      alignSelf: "flex-end"
    };
    $[16] = t8;
  } else {
    t8 = $[16];
  }
  let t9;
  if ($[17] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: t8, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowForwardIcon, { className: "text-primary" }) }) });
    $[17] = t9;
  } else {
    t9 = $[17];
  }
  let t10;
  if ($[18] !== t7) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-start h-full", children: [
      t7,
      t9
    ] });
    $[18] = t7;
    $[19] = t10;
  } else {
    t10 = $[19];
  }
  let t11;
  if ($[20] !== t10 || $[21] !== t2) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { className: t1, onClick: t2, children: t10 });
    $[20] = t10;
    $[21] = t2;
    $[22] = t11;
  } else {
    t11 = $[22];
  }
  return t11;
}
function _temp$g(event) {
  event.preventDefault();
  event.stopPropagation();
}
function SmallNavigationCard(t0) {
  const $ = c_1(10);
  const {
    name,
    url,
    icon
  } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = cls(cardMixin, cardClickableMixin, "cursor-pointer flex flex-row items-center px-4 py-2 text-inherit dark:text-inherit visited:text-inherit visited:dark:text-inherit hover:text-inherit hover:dark:text-inherit ");
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let t2;
  if ($[1] !== name) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { gutterBottom: true, variant: "h5", component: "h2", className: "mb-0 ml-4", children: name });
    $[1] = name;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  let t3;
  if ($[3] !== icon || $[4] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row items-center flex-grow gap-2 ", children: [
      icon,
      t2
    ] });
    $[3] = icon;
    $[4] = t2;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowForwardIcon, { color: "primary" }) });
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  let t5;
  if ($[7] !== t3 || $[8] !== url) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Link$2, { tabIndex: 0, className: t1, to: url, children: [
      t3,
      t4
    ] }) });
    $[7] = t3;
    $[8] = url;
    $[9] = t5;
  } else {
    t5 = $[9];
  }
  return t5;
}
function NavigationCardBinding(t0) {
  const $ = c_1(34);
  const {
    path,
    collection,
    view,
    url,
    name,
    description,
    onClick,
    type
  } = t0;
  const userConfigurationPersistence = useUserConfigurationPersistence();
  const t1 = collection ?? view;
  let t2;
  if ($[0] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(IconForView, { collectionOrView: t1 });
    $[0] = t1;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  const collectionIcon = t2;
  const navigate = useNavigate();
  const context = useFireCMSContext();
  const customizationController = useCustomizationController();
  let t3;
  if ($[2] !== userConfigurationPersistence?.favouritePaths) {
    t3 = userConfigurationPersistence?.favouritePaths ?? [];
    $[2] = userConfigurationPersistence?.favouritePaths;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  let t4;
  if ($[4] !== path || $[5] !== t3) {
    t4 = t3.includes(path);
    $[4] = path;
    $[5] = t3;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  const favourite = t4;
  let t5;
  if ($[7] !== collection || $[8] !== context || $[9] !== customizationController.plugins || $[10] !== favourite || $[11] !== path || $[12] !== userConfigurationPersistence) {
    const actionsArray = userConfigurationPersistence ? [/* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: (e2) => {
      e2.preventDefault();
      e2.stopPropagation();
      if (favourite) {
        userConfigurationPersistence.setFavouritePaths(userConfigurationPersistence.favouritePaths.filter((p2) => p2 !== path));
      } else {
        userConfigurationPersistence.setFavouritePaths([...userConfigurationPersistence.favouritePaths, path]);
      }
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(StarIcon, { size: 18, className: favourite ? "text-secondary" : "text-surface-400 dark:text-surface-500" }) }, "favourite")] : [];
    if (customizationController.plugins && collection) {
      let t62;
      if ($[14] !== collection || $[15] !== context || $[16] !== path) {
        t62 = {
          path,
          collection,
          context
        };
        $[14] = collection;
        $[15] = context;
        $[16] = path;
        $[17] = t62;
      } else {
        t62 = $[17];
      }
      const actionProps = t62;
      customizationController.plugins.forEach((plugin, i) => actionsArray.push(plugin.homePage?.CollectionActions ? /* @__PURE__ */ jsxRuntimeExports.jsx(plugin.homePage.CollectionActions, { ...actionProps, extraProps: plugin.homePage.extraProps }, `actions_${i}`) : null));
    }
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: actionsArray });
    $[7] = collection;
    $[8] = context;
    $[9] = customizationController.plugins;
    $[10] = favourite;
    $[11] = path;
    $[12] = userConfigurationPersistence;
    $[13] = t5;
  } else {
    t5 = $[13];
  }
  const actions = t5;
  if (type === "admin") {
    let t62;
    if ($[18] !== collectionIcon || $[19] !== name || $[20] !== url) {
      t62 = /* @__PURE__ */ jsxRuntimeExports.jsx(SmallNavigationCard, { icon: collectionIcon, name, url });
      $[18] = collectionIcon;
      $[19] = name;
      $[20] = url;
      $[21] = t62;
    } else {
      t62 = $[21];
    }
    return t62;
  }
  let t6;
  if ($[22] !== navigate || $[23] !== onClick || $[24] !== path || $[25] !== url || $[26] !== userConfigurationPersistence) {
    t6 = () => {
      onClick?.();
      navigate(url);
      if (userConfigurationPersistence) {
        userConfigurationPersistence.setRecentlyVisitedPaths([path, ...(userConfigurationPersistence.recentlyVisitedPaths ?? []).filter((p_0) => p_0 !== path)]);
      }
    };
    $[22] = navigate;
    $[23] = onClick;
    $[24] = path;
    $[25] = url;
    $[26] = userConfigurationPersistence;
    $[27] = t6;
  } else {
    t6 = $[27];
  }
  let t7;
  if ($[28] !== actions || $[29] !== collectionIcon || $[30] !== description || $[31] !== name || $[32] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(NavigationCard, { icon: collectionIcon, name, description, actions, onClick: t6 });
    $[28] = actions;
    $[29] = collectionIcon;
    $[30] = description;
    $[31] = name;
    $[32] = t6;
    $[33] = t7;
  } else {
    t7 = $[33];
  }
  return t7;
}
function NavigationChip(t0) {
  const $ = c_1(18);
  const {
    entry
  } = t0;
  const navigate = useNavigate();
  const userConfigurationPersistence = useUserConfigurationPersistence();
  if (!userConfigurationPersistence) {
    return null;
  }
  let t1;
  if ($[0] !== entry.path || $[1] !== userConfigurationPersistence.favouritePaths) {
    t1 = userConfigurationPersistence.favouritePaths.includes(entry.path);
    $[0] = entry.path;
    $[1] = userConfigurationPersistence.favouritePaths;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const favourite = t1;
  let t2;
  if ($[3] !== entry.path || $[4] !== favourite || $[5] !== userConfigurationPersistence) {
    t2 = (e2) => {
      e2.preventDefault();
      e2.stopPropagation();
      if (favourite) {
        userConfigurationPersistence.setFavouritePaths(userConfigurationPersistence.favouritePaths.filter((p2) => p2 !== entry.path));
      } else {
        userConfigurationPersistence.setFavouritePaths([...userConfigurationPersistence.favouritePaths, entry.path]);
      }
    };
    $[3] = entry.path;
    $[4] = favourite;
    $[5] = userConfigurationPersistence;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  const onIconClick = t2;
  let t3;
  if ($[7] !== entry.url || $[8] !== navigate) {
    t3 = () => navigate(entry.url);
    $[7] = entry.url;
    $[8] = navigate;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  const t4 = favourite ? "text-secondary" : "text-surface-400 dark:text-surface-500";
  let t5;
  if ($[10] !== onIconClick || $[11] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(StarIcon, { onClick: onIconClick, size: 18, className: t4 });
    $[10] = onIconClick;
    $[11] = t4;
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  let t6;
  if ($[13] !== entry.name || $[14] !== entry.path || $[15] !== t3 || $[16] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { onClick: t3, icon: t5, children: entry.name }, entry.path);
    $[13] = entry.name;
    $[14] = entry.path;
    $[15] = t3;
    $[16] = t5;
    $[17] = t6;
  } else {
    t6 = $[17];
  }
  return t6;
}
function FavouritesView(t0) {
  const $ = c_1(17);
  const navigationController = useNavigationController();
  const userConfigurationPersistence = useUserConfigurationPersistence();
  if (!userConfigurationPersistence) {
    return null;
  }
  let t1;
  if ($[0] !== userConfigurationPersistence?.favouritePaths) {
    t1 = userConfigurationPersistence?.favouritePaths ?? [];
    $[0] = userConfigurationPersistence?.favouritePaths;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let T0;
  let t2;
  let t3;
  let t4;
  if ($[2] !== navigationController.topLevelNavigation?.navigationEntries || $[3] !== t1) {
    let t52;
    if ($[8] !== navigationController.topLevelNavigation?.navigationEntries) {
      t52 = (path) => navigationController.topLevelNavigation?.navigationEntries.find((entry) => entry.path === path);
      $[8] = navigationController.topLevelNavigation?.navigationEntries;
      $[9] = t52;
    } else {
      t52 = $[9];
    }
    const favouriteCollections = t1.map(t52).filter(Boolean);
    T0 = Collapse;
    t4 = favouriteCollections.length > 0;
    t2 = "flex flex-row flex-wrap gap-2 pb-2 min-h-[32px]";
    t3 = favouriteCollections.map(_temp$f);
    $[2] = navigationController.topLevelNavigation?.navigationEntries;
    $[3] = t1;
    $[4] = T0;
    $[5] = t2;
    $[6] = t3;
    $[7] = t4;
  } else {
    T0 = $[4];
    t2 = $[5];
    t3 = $[6];
    t4 = $[7];
  }
  let t5;
  if ($[10] !== t2 || $[11] !== t3) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t2, children: t3 });
    $[10] = t2;
    $[11] = t3;
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  let t6;
  if ($[13] !== T0 || $[14] !== t4 || $[15] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(T0, { in: t4, children: t5 });
    $[13] = T0;
    $[14] = t4;
    $[15] = t5;
    $[16] = t6;
  } else {
    t6 = $[16];
  }
  return t6;
}
function _temp$f(entry_0) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(NavigationChip, { entry: entry_0 }, entry_0.path);
}
const scrollsMap = {};
function useRestoreScroll() {
  const location = useLocation();
  const containerRef = React__default.useRef(null);
  const [scroll2, setScroll] = React__default.useState(0);
  const [direction2, setDirection] = React__default.useState("down");
  const handleScroll = useCallback(() => {
    if (!containerRef.current || !location.key) return;
    scrollsMap[location.key] = containerRef.current.scrollTop;
    setScroll(containerRef.current.scrollTop);
    setDirection(containerRef.current.scrollTop > scroll2 ? "down" : "up");
  }, [containerRef, location.key, scroll2]);
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;
    container.addEventListener("scroll", handleScroll, {
      passive: true
    });
    return () => {
      if (container) container.removeEventListener("scroll", handleScroll);
    };
  }, [containerRef, handleScroll, location]);
  useEffect(() => {
    if (!containerRef.current || !scrollsMap[location.key]) return;
    containerRef.current.scrollTo({
      top: scrollsMap[location.key],
      behavior: "auto"
    });
  }, [location]);
  return {
    containerRef,
    scroll: scroll2,
    direction: direction2
  };
}
function DefaultHomePage(t0) {
  const $ = c_1(71);
  const {
    additionalActions,
    additionalChildrenStart,
    additionalChildrenEnd
  } = t0;
  const context = useFireCMSContext();
  const customizationController = useCustomizationController();
  const navigationController = useNavigationController();
  const fuse = useRef(null);
  if (!navigationController.topLevelNavigation) {
    throw Error("Navigation not ready in FireCMSHomePage");
  }
  const {
    containerRef,
    direction: direction2
  } = useRestoreScroll();
  const {
    navigationEntries,
    groups
  } = navigationController.topLevelNavigation;
  const [filteredUrls, setFilteredUrls] = useState(null);
  const performingSearch = Boolean(filteredUrls);
  let t1;
  if ($[0] !== filteredUrls || $[1] !== navigationEntries) {
    t1 = filteredUrls ? filteredUrls.map((url) => navigationEntries.find((e2) => e2.url === url)).filter(Boolean) : navigationEntries;
    $[0] = filteredUrls;
    $[1] = navigationEntries;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const filteredNavigationEntries = t1;
  let t2;
  let t3;
  if ($[3] !== navigationEntries) {
    t2 = () => {
      fuse.current = new Fuse(navigationEntries, {
        keys: ["name", "description", "group", "path"]
      });
    };
    t3 = [navigationEntries];
    $[3] = navigationEntries;
    $[4] = t2;
    $[5] = t3;
  } else {
    t2 = $[4];
    t3 = $[5];
  }
  useEffect(t2, t3);
  let t4;
  if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = (value) => {
      if (!value || value === "") {
        setFilteredUrls(null);
      } else {
        const searchResult = fuse.current?.search(value);
        if (searchResult) {
          setFilteredUrls(searchResult.map(_temp$e));
        }
      }
    };
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  const updateSearchResults = t4;
  let T0;
  let additionalPluginChildrenEnd;
  let additionalPluginSections;
  let t10;
  let t11;
  let t12;
  let t13;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  if ($[7] !== additionalActions || $[8] !== additionalChildrenStart || $[9] !== containerRef || $[10] !== context || $[11] !== customizationController.plugins || $[12] !== direction2 || $[13] !== filteredNavigationEntries || $[14] !== filteredUrls || $[15] !== groups || $[16] !== performingSearch) {
    const filteredGroups = filteredUrls ? filteredNavigationEntries.map(_temp2$5) : [];
    const allGroups = filteredUrls ? filteredGroups.filter((group, index2) => filteredGroups.indexOf(group) === index2) : [...groups];
    if (filteredNavigationEntries.filter(_temp3$2).length > 0 || filteredNavigationEntries.length === 0) {
      allGroups.push(void 0);
    }
    let additionalPluginChildrenStart;
    if (customizationController.plugins) {
      let t143;
      if ($[29] !== context || $[30] !== customizationController.plugins) {
        const sectionProps = {
          context
        };
        t143 = customizationController.plugins.filter(_temp4$1).map((plugin_0, i) => {
          const section = plugin_0.homePage.includeSection(sectionProps);
          return /* @__PURE__ */ jsxRuntimeExports.jsx(NavigationGroup, { group: section.title, children: section.children }, `plugin_section_${plugin_0.key}`);
        });
        $[29] = context;
        $[30] = customizationController.plugins;
        $[31] = t143;
      } else {
        t143 = $[31];
      }
      let t153;
      if ($[32] !== t143) {
        t153 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: t143 });
        $[32] = t143;
        $[33] = t153;
      } else {
        t153 = $[33];
      }
      additionalPluginSections = t153;
      let t162;
      if ($[34] !== customizationController.plugins) {
        t162 = customizationController.plugins.filter(_temp5$1).map(_temp6$1);
        $[34] = customizationController.plugins;
        $[35] = t162;
      } else {
        t162 = $[35];
      }
      let t172;
      if ($[36] !== t162) {
        t172 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-2", children: t162 });
        $[36] = t162;
        $[37] = t172;
      } else {
        t172 = $[37];
      }
      additionalPluginChildrenStart = t172;
      let t18;
      if ($[38] !== customizationController.plugins) {
        t18 = customizationController.plugins.filter(_temp7).map(_temp8);
        $[38] = customizationController.plugins;
        $[39] = t18;
      } else {
        t18 = $[39];
      }
      let t19;
      if ($[40] !== t18) {
        t19 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-2", children: t18 });
        $[40] = t18;
        $[41] = t19;
      } else {
        t19 = $[41];
      }
      additionalPluginChildrenEnd = t19;
    }
    t11 = "home_page";
    t12 = containerRef;
    t13 = "py-2 overflow-auto h-full w-full";
    T0 = Container;
    t5 = "6xl";
    const t142 = direction2 === "down" ? -84 : 0;
    let t152;
    if ($[42] !== t142) {
      t152 = {
        top: t142
      };
      $[42] = t142;
      $[43] = t152;
    } else {
      t152 = $[43];
    }
    let t16;
    if ($[44] === Symbol.for("react.memo_cache_sentinel")) {
      t16 = /* @__PURE__ */ jsxRuntimeExports.jsx(SearchBar, { onTextSearch: updateSearchResults, placeholder: "Search collections", large: false, autoFocus: true, innerClassName: "w-full", className: "w-full flex-grow" });
      $[44] = t16;
    } else {
      t16 = $[44];
    }
    if ($[45] !== additionalActions || $[46] !== t152) {
      t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full sticky py-4 transition-all duration-400 ease-in-out top-0 z-10 flex flex-row gap-4", style: t152, children: [
        t16,
        additionalActions
      ] });
      $[45] = additionalActions;
      $[46] = t152;
      $[47] = t6;
    } else {
      t6 = $[47];
    }
    if ($[48] !== performingSearch) {
      t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(FavouritesView, { hidden: performingSearch });
      $[48] = performingSearch;
      $[49] = t7;
    } else {
      t7 = $[49];
    }
    t8 = additionalChildrenStart;
    t9 = additionalPluginChildrenStart;
    let t17;
    if ($[50] !== context || $[51] !== customizationController.plugins || $[52] !== filteredNavigationEntries || $[53] !== performingSearch) {
      t17 = (group_0, index_0) => {
        const AdditionalCards = [];
        const actionProps = {
          group: group_0,
          context
        };
        if (customizationController.plugins) {
          customizationController.plugins.forEach((plugin_5) => {
            if (plugin_5.homePage?.AdditionalCards) {
              AdditionalCards.push(...toArray(plugin_5.homePage?.AdditionalCards));
            }
          });
        }
        const thisGroupCollections = filteredNavigationEntries.filter((entry_0) => entry_0.group === group_0 || !entry_0.group && group_0 === void 0);
        if (thisGroupCollections.length === 0 && (AdditionalCards.length === 0 || performingSearch)) {
          return null;
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(NavigationGroup, { group: group_0, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4", children: [
          thisGroupCollections.map((entry_1) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(NavigationCardBinding, { ...entry_1, onClick: () => {
            let event;
            if (entry_1.type === "collection") {
              event = "home_navigate_to_collection";
            } else {
              if (entry_1.type === "view") {
                event = "home_navigate_to_view";
              } else {
                if (entry_1.type === "admin") {
                  event = "home_navigate_to_admin_view";
                } else {
                  event = "unmapped_event";
                }
              }
            }
            context.analyticsController?.onAnalyticsEvent?.(event, {
              path: entry_1.path
            });
          } }) }, `nav_${entry_1.group}_${entry_1.name}`)),
          group_0?.toLowerCase() !== "admin" && AdditionalCards && AdditionalCards.map((AdditionalCard, i_2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AdditionalCard, { ...actionProps }) }, `nav_${group_0}_add_${i_2}`))
        ] }) }, `plugin_section_${group_0}`);
      };
      $[50] = context;
      $[51] = customizationController.plugins;
      $[52] = filteredNavigationEntries;
      $[53] = performingSearch;
      $[54] = t17;
    } else {
      t17 = $[54];
    }
    t10 = allGroups.map(t17);
    $[7] = additionalActions;
    $[8] = additionalChildrenStart;
    $[9] = containerRef;
    $[10] = context;
    $[11] = customizationController.plugins;
    $[12] = direction2;
    $[13] = filteredNavigationEntries;
    $[14] = filteredUrls;
    $[15] = groups;
    $[16] = performingSearch;
    $[17] = T0;
    $[18] = additionalPluginChildrenEnd;
    $[19] = additionalPluginSections;
    $[20] = t10;
    $[21] = t11;
    $[22] = t12;
    $[23] = t13;
    $[24] = t5;
    $[25] = t6;
    $[26] = t7;
    $[27] = t8;
    $[28] = t9;
  } else {
    T0 = $[17];
    additionalPluginChildrenEnd = $[18];
    additionalPluginSections = $[19];
    t10 = $[20];
    t11 = $[21];
    t12 = $[22];
    t13 = $[23];
    t5 = $[24];
    t6 = $[25];
    t7 = $[26];
    t8 = $[27];
    t9 = $[28];
  }
  let t14;
  if ($[55] !== T0 || $[56] !== additionalChildrenEnd || $[57] !== additionalPluginChildrenEnd || $[58] !== additionalPluginSections || $[59] !== t10 || $[60] !== t5 || $[61] !== t6 || $[62] !== t7 || $[63] !== t8 || $[64] !== t9) {
    t14 = /* @__PURE__ */ jsxRuntimeExports.jsxs(T0, { maxWidth: t5, children: [
      t6,
      t7,
      t8,
      t9,
      t10,
      additionalPluginSections,
      additionalPluginChildrenEnd,
      additionalChildrenEnd
    ] });
    $[55] = T0;
    $[56] = additionalChildrenEnd;
    $[57] = additionalPluginChildrenEnd;
    $[58] = additionalPluginSections;
    $[59] = t10;
    $[60] = t5;
    $[61] = t6;
    $[62] = t7;
    $[63] = t8;
    $[64] = t9;
    $[65] = t14;
  } else {
    t14 = $[65];
  }
  let t15;
  if ($[66] !== t11 || $[67] !== t12 || $[68] !== t13 || $[69] !== t14) {
    t15 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: t11, ref: t12, className: t13, children: t14 });
    $[66] = t11;
    $[67] = t12;
    $[68] = t13;
    $[69] = t14;
    $[70] = t15;
  } else {
    t15 = $[70];
  }
  return t15;
}
function _temp8(plugin_4, i_1) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: plugin_4.homePage.additionalChildrenEnd }, `plugin_children_start_${i_1}`);
}
function _temp7(plugin_3) {
  return plugin_3.homePage?.additionalChildrenEnd;
}
function _temp6$1(plugin_2, i_0) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: plugin_2.homePage.additionalChildrenStart }, `plugin_children_start_${i_0}`);
}
function _temp5$1(plugin_1) {
  return plugin_1.homePage?.additionalChildrenStart;
}
function _temp4$1(plugin) {
  return plugin.homePage?.includeSection;
}
function _temp3$2(e_1) {
  return !e_1.group;
}
function _temp2$5(entry) {
  return entry.group;
}
function _temp$e(e_0) {
  return e_0.item.url;
}
function EntityCollectionViewActions(t0) {
  const $ = c_1(39);
  const {
    collection,
    relativePath,
    parentCollectionIds,
    onNewClick,
    onMultipleDeleteClick,
    selectionEnabled,
    path,
    selectionController,
    tableController,
    collectionEntitiesCount
  } = t0;
  const context = useFireCMSContext();
  const customizationController = useCustomizationController();
  let t1;
  if ($[0] !== customizationController.plugins) {
    t1 = customizationController.plugins ?? [];
    $[0] = customizationController.plugins;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const plugins = t1;
  const authController = useAuthController();
  const largeLayout = useLargeLayout();
  const selectedEntities = selectionController.selectedEntities;
  let t2;
  if ($[2] !== authController || $[3] !== collection || $[4] !== largeLayout || $[5] !== onNewClick || $[6] !== path) {
    t2 = canCreateEntity(collection, authController, path, null) && onNewClick && (largeLayout ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { id: `add_entity_${path}`, onClick: onNewClick, startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon, {}), variant: "filled", color: "primary", children: [
      "Add ",
      collection.singularName ?? collection.name
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { id: `add_entity_${path}`, onClick: onNewClick, variant: "filled", color: "primary", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon, {}) }));
    $[2] = authController;
    $[3] = collection;
    $[4] = largeLayout;
    $[5] = onNewClick;
    $[6] = path;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  const addButton = t2;
  let t3;
  if ($[8] !== authController || $[9] !== collection || $[10] !== path) {
    t3 = canDeleteEntity(collection, authController, path, null);
    $[8] = authController;
    $[9] = collection;
    $[10] = path;
    $[11] = t3;
  } else {
    t3 = $[11];
  }
  const multipleDeleteEnabled = t3;
  let multipleDeleteButton;
  if (selectionEnabled) {
    let t42;
    if ($[12] !== largeLayout || $[13] !== multipleDeleteEnabled || $[14] !== onMultipleDeleteClick || $[15] !== selectedEntities?.length) {
      t42 = largeLayout ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { variant: "text", disabled: !selectedEntities?.length || !multipleDeleteEnabled, startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteIcon, {}), onClick: onMultipleDeleteClick, color: "primary", className: "lg:w-20", children: [
        "(",
        selectedEntities?.length,
        ")"
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { color: "primary", disabled: !selectedEntities?.length || !multipleDeleteEnabled, onClick: onMultipleDeleteClick, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteIcon, {}) });
      $[12] = largeLayout;
      $[13] = multipleDeleteEnabled;
      $[14] = onMultipleDeleteClick;
      $[15] = selectedEntities?.length;
      $[16] = t42;
    } else {
      t42 = $[16];
    }
    const button = t42;
    const t52 = multipleDeleteEnabled ? "Delete" : "You have selected at least one entity you cannot delete";
    let t6;
    if ($[17] !== button || $[18] !== t52) {
      t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: t52, children: button });
      $[17] = button;
      $[18] = t52;
      $[19] = t6;
    } else {
      t6 = $[19];
    }
    multipleDeleteButton = t6;
  }
  let t4;
  if ($[20] !== collection || $[21] !== collectionEntitiesCount || $[22] !== context || $[23] !== parentCollectionIds || $[24] !== path || $[25] !== relativePath || $[26] !== selectionController || $[27] !== tableController) {
    t4 = {
      path,
      relativePath,
      parentCollectionIds,
      collection,
      selectionController,
      context,
      tableController,
      collectionEntitiesCount
    };
    $[20] = collection;
    $[21] = collectionEntitiesCount;
    $[22] = context;
    $[23] = parentCollectionIds;
    $[24] = path;
    $[25] = relativePath;
    $[26] = selectionController;
    $[27] = tableController;
    $[28] = t4;
  } else {
    t4 = $[28];
  }
  const actionProps = t4;
  let actions;
  if ($[29] !== actionProps || $[30] !== collection.Actions || $[31] !== plugins) {
    let t52;
    if ($[33] !== actionProps) {
      t52 = (Action2, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Action2, { ...actionProps }) }, `actions_${i}`);
      $[33] = actionProps;
      $[34] = t52;
    } else {
      t52 = $[34];
    }
    actions = toArray(collection.Actions).map(t52);
    if (plugins) {
      plugins.forEach((plugin, i_0) => {
        if (plugin.collectionView?.CollectionActions) {
          actions.push(...toArray(plugin.collectionView?.CollectionActions).map((Action_0, j) => /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Action_0, { ...actionProps, ...plugin.collectionView?.collectionActionsProps }) }, `plugin_actions_${i_0}_${j}`)));
        }
      });
    }
    $[29] = actionProps;
    $[30] = collection.Actions;
    $[31] = plugins;
    $[32] = actions;
  } else {
    actions = $[32];
  }
  let t5;
  if ($[35] !== actions || $[36] !== addButton || $[37] !== multipleDeleteButton) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      actions,
      multipleDeleteButton,
      addButton
    ] });
    $[35] = actions;
    $[36] = addButton;
    $[37] = multipleDeleteButton;
    $[38] = t5;
  } else {
    t5 = $[38];
  }
  return t5;
}
function useDraggable({
  containerRef,
  innerRef,
  x,
  y,
  onMove
}) {
  let relX = 0;
  let relY = 0;
  const listeningRef = React__default.useRef(false);
  const onMouseDown = (event) => {
    if (event.button !== 0 || !containerRef.current || event.defaultPrevented || event.innerClicked) {
      return;
    }
    const {
      x: x_0,
      y: y_0
    } = containerRef.current.getBoundingClientRect();
    relX = event.screenX - x_0;
    relY = event.screenY - y_0;
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
    document.addEventListener("selectstart", onSelect);
    listeningRef.current = true;
  };
  const onMouseDownInner = (event_0) => {
    event_0.innerClicked = true;
  };
  const onSelect = (event_1) => {
    event_1.preventDefault();
    event_1.stopPropagation();
  };
  const onMouseUp = (event_2) => {
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
    document.removeEventListener("selectstart", onSelect);
    event_2.stopPropagation();
    listeningRef.current = false;
  };
  const onMouseMove = (event_3) => {
    if (event_3.target.localName === "input" || !listeningRef.current) return;
    onMove({
      x: event_3.screenX - relX,
      y: event_3.screenY - relY
    });
    event_3.stopPropagation();
  };
  const update2 = () => {
    if (containerRef.current) {
      containerRef.current.style.top = `${y}px`;
      containerRef.current.style.left = `${x}px`;
    }
  };
  useEffect(() => {
    const current = containerRef.current;
    const innerCurrent = innerRef.current;
    if (!current || !innerCurrent) return;
    if (innerCurrent) innerCurrent.addEventListener("mousedown", onMouseDownInner);
    if (current) current.addEventListener("mousedown", onMouseDown);
    update2();
    return () => {
      if (current) current.removeEventListener("mousedown", onMouseDown);
      if (innerCurrent) innerCurrent.removeEventListener("mousedown", onMouseDownInner);
    };
  });
}
function useWindowSize() {
  const $ = c_1(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {
      width: 0,
      height: 0
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const [size2, setSize] = useState(t0);
  let t1;
  let t2;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => {
      const updateSize = function updateSize2() {
        setSize({
          width: window.innerWidth,
          height: window.innerHeight
        });
      };
      window.addEventListener("resize", updateSize);
      updateSize();
      return () => window.removeEventListener("resize", updateSize);
    };
    t2 = [];
    $[1] = t1;
    $[2] = t2;
  } else {
    t1 = $[1];
    t2 = $[2];
  }
  useLayoutEffect(t1, t2);
  return size2;
}
const ElementResizeListener = ({
  onResize
}) => {
  const rafRef = useRef(0);
  const objectRef = useRef(null);
  const onResizeRef = useRef(onResize);
  onResizeRef.current = onResize;
  const _onResize = useCallback((e2) => {
    if (rafRef.current) {
      cancelAnimationFrame(rafRef.current);
    }
    rafRef.current = requestAnimationFrame(() => {
      onResizeRef.current(e2);
    });
  }, []);
  const onLoad = useCallback(() => {
    const obj = objectRef.current;
    if (obj && obj.contentDocument && obj.contentDocument.defaultView) {
      obj.contentDocument.defaultView.addEventListener("resize", _onResize);
    }
  }, [_onResize]);
  useEffect(() => {
    const obj_0 = objectRef.current;
    return () => {
      if (obj_0 && obj_0.contentDocument && obj_0.contentDocument.defaultView) {
        obj_0.contentDocument.defaultView.removeEventListener("resize", _onResize);
      }
    };
  }, [_onResize]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("object", { onLoad, ref: objectRef, tabIndex: -1, type: "text/html", data: "about:blank", title: "", style: {
    position: "absolute",
    top: 0,
    left: 0,
    height: "100%",
    width: "100%",
    pointerEvents: "none",
    zIndex: -1,
    opacity: 0
  } });
};
function CustomIdField({
  customId,
  entityId,
  status,
  onChange,
  error,
  entity,
  loading
}) {
  const {
    errors
  } = useFormex();
  const disabled = status === "existing" || !customId;
  const idSetAutomatically = status !== "existing" && !customId;
  const enumValues = useMemo(() => {
    if (!customId || typeof customId === "boolean" || customId === "optional") return void 0;
    return enumToObjectEntries(customId);
  }, [customId]);
  const snackbarController = useSnackbarController();
  const {
    copy: copy2
  } = useClipboard({
    onSuccess: (text) => snackbarController.open({
      type: "success",
      message: `Copied ${text}`
    })
  });
  const customizationController = useCustomizationController();
  const fieldProps = {
    label: idSetAutomatically ? "ID is set automatically" : "ID",
    disabled: disabled || loading,
    name: "id",
    value: (entity && status === "existing" ? entity.id : entityId) ?? "",
    endAdornment: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: "small" }) : entity ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Copy", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: (e2) => copy2(entity.id), "aria-label": "copy-id", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ContentCopyIcon, { size: "small" }) }) }),
      customizationController?.entityLinkBuilder && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Open in the console", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { component: "a", href: customizationController.entityLinkBuilder({
        entity
      }), rel: "noopener noreferrer", target: "_blank", onClick: (e_0) => e_0.stopPropagation(), "aria-label": "go-to-datasource", children: /* @__PURE__ */ jsxRuntimeExports.jsx(OpenInNewIcon, { size: "small" }) }) })
    ] }) : void 0
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    enumValues && /* @__PURE__ */ jsxRuntimeExports.jsx(Select, { size: "large", error, fullWidth: true, onValueChange: (v) => onChange(v), ...fieldProps, renderValue: (option) => {
      const enumConfig = enumValues.find((e_1) => e_1.id === option);
      if (!enumConfig) return option;
      return `${enumConfig.id} - ${enumConfig.label}`;
    }, children: enumValues.map((enumConfig_0) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: String(enumConfig_0.id), children: /* @__PURE__ */ jsxRuntimeExports.jsx(EnumValuesChip, { enumKey: enumConfig_0.id, enumValues, size: "medium" }) }, enumConfig_0.id)) }),
    !enumValues && /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { ...fieldProps, error, placeholder: customId === "optional" ? "Autogenerated ID, it can be manually changed" : status === "new" || status === "copy" ? "ID of the new document" : "ID of the document", onChange: (event) => {
      let value = event.target.value;
      if (value) value = value.trim();
      return onChange(value.length ? value : void 0);
    } }),
    errors.id && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", className: "ml-3.5 text-red-500 dark:text-red-500", children: errors.id })
  ] });
}
const ErrorFocus = (t0) => {
  const $ = c_1(6);
  const {
    containerRef
  } = t0;
  const {
    isSubmitting,
    isValidating,
    errors
  } = useFormex();
  let t1;
  let t2;
  if ($[0] !== containerRef || $[1] !== errors || $[2] !== isSubmitting || $[3] !== isValidating) {
    t1 = () => {
      const keys2 = Object.keys(errors);
      if (keys2.length > 0 && isSubmitting && !isValidating) {
        const errorElement = containerRef?.current?.querySelector(`#form_field_${keys2[0]}`);
        if (errorElement && containerRef?.current) {
          const scrollableParent = getScrollableParent(containerRef.current);
          if (scrollableParent) {
            const top2 = errorElement.getBoundingClientRect().top;
            scrollableParent.scrollTo({
              top: scrollableParent.scrollTop + top2 - 196,
              behavior: "smooth"
            });
          }
          const input = errorElement.querySelector("input");
          if (input) {
            input.focus();
          }
        }
      }
    };
    t2 = [isSubmitting, isValidating, errors, containerRef];
    $[0] = containerRef;
    $[1] = errors;
    $[2] = isSubmitting;
    $[3] = isValidating;
    $[4] = t1;
    $[5] = t2;
  } else {
    t1 = $[4];
    t2 = $[5];
  }
  useEffect(t1, t2);
  return null;
};
const isScrollable = (ele) => {
  const hasScrollableContent = ele && ele.scrollHeight > ele.clientHeight;
  const overflowYStyle = ele ? window.getComputedStyle(ele).overflowY : null;
  const isOverflowHidden = overflowYStyle && overflowYStyle.indexOf("hidden") !== -1;
  return hasScrollableContent && !isOverflowHidden;
};
const getScrollableParent = (ele) => {
  return !ele || ele === document.body ? document.body : isScrollable(ele) ? ele : getScrollableParent(ele.parentNode);
};
const MAIN_TAB_VALUE = "main_##Q$SC^#S6";
function EntityEditView(t0) {
  const $ = c_1(13);
  let entityId;
  let props;
  if ($[0] !== t0) {
    ({
      entityId,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = entityId;
    $[2] = props;
  } else {
    entityId = $[1];
    props = $[2];
  }
  let t1;
  if ($[3] !== entityId || $[4] !== props.collection || $[5] !== props.path) {
    t1 = {
      path: props.path,
      entityId,
      collection: props.collection,
      useCache: false
    };
    $[3] = entityId;
    $[4] = props.collection;
    $[5] = props.path;
    $[6] = t1;
  } else {
    t1 = $[6];
  }
  const {
    entity,
    dataLoading
  } = useEntityFetch(t1);
  if (dataLoading) {
    let t22;
    if ($[7] === Symbol.for("react.memo_cache_sentinel")) {
      t22 = /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCenter, {});
      $[7] = t22;
    } else {
      t22 = $[7];
    }
    return t22;
  }
  if (entityId && !entity) {
    console.error(`Entity with id ${entityId} not found in collection ${props.collection.path}`);
  }
  let t2;
  if ($[8] !== dataLoading || $[9] !== entity || $[10] !== entityId || $[11] !== props) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(EntityEditViewInner, { ...props, entityId, entity, dataLoading });
    $[8] = dataLoading;
    $[9] = entity;
    $[10] = entityId;
    $[11] = props;
    $[12] = t2;
  } else {
    t2 = $[12];
  }
  return t2;
}
function EntityEditViewInner({
  path,
  entityId: entityIdProp,
  selectedSubPath: selectedSubPathProp,
  copy: copy2,
  collection,
  parentCollectionIds,
  onValuesAreModified,
  onUpdate,
  onClose,
  entity,
  dataLoading
}) {
  if (collection.customId && collection.formAutoSave) {
    console.warn(`The collection ${collection.path} has customId and formAutoSave enabled. This is not supported and formAutoSave will be ignored`);
  }
  const [saving, setSaving] = useState(false);
  const [valuesToBeSaved, setValuesToBeSaved] = useState(void 0);
  useDebouncedCallback(valuesToBeSaved, () => {
    if (valuesToBeSaved) saveEntity({
      entityId: usedEntity?.id,
      collection,
      path,
      values: valuesToBeSaved,
      closeAfterSave: false
    });
  }, false, 2e3);
  const inputCollection = collection;
  const authController = useAuthController();
  const dataSource = useDataSource();
  const sideDialogContext = useSideDialogContext();
  const sideEntityController = useSideEntityController();
  const snackbarController = useSnackbarController();
  const customizationController = useCustomizationController();
  const context = useFireCMSContext();
  const closeAfterSaveRef = useRef(false);
  const analyticsController = useAnalyticsController();
  const initialResolvedCollection = useMemo(() => resolveCollection({
    collection: inputCollection,
    path,
    values: entity?.values,
    propertyConfigs: customizationController.propertyConfigs
  }), [entity?.values, path, customizationController.propertyConfigs]);
  const initialStatus = copy2 ? "copy" : entityIdProp ? "existing" : "new";
  const [status, setStatus] = useState(initialStatus);
  const mustSetCustomId = (status === "new" || status === "copy") && Boolean(initialResolvedCollection.customId) && initialResolvedCollection.customId !== "optional";
  const initialEntityId = useMemo(() => {
    if (status === "new" || status === "copy") {
      if (mustSetCustomId) {
        return void 0;
      } else {
        return dataSource.generateEntityId(path, collection);
      }
    } else {
      return entityIdProp;
    }
  }, [entityIdProp, status]);
  const [entityId, setEntityId] = React__default.useState(initialEntityId);
  const [entityIdError, setEntityIdError] = React__default.useState(false);
  const [savingError, setSavingError] = React__default.useState();
  const [customIdLoading, setCustomIdLoading] = React__default.useState(false);
  const defaultSelectedView = selectedSubPathProp ?? resolveDefaultSelectedView(collection ? collection.defaultSelectedView : void 0, {
    status,
    entityId
  });
  const [selectedTab, setSelectedTab] = useState(defaultSelectedView ?? MAIN_TAB_VALUE);
  const mainViewVisible = selectedTab === MAIN_TAB_VALUE;
  const subcollections = (collection.subcollections ?? []).filter((c2) => !c2.hideFromNavigation);
  const subcollectionsCount = subcollections?.length ?? 0;
  const customViews = collection.entityViews;
  const customViewsCount = customViews?.length ?? 0;
  const autoSave = collection.formAutoSave && !collection.customId;
  const hasAdditionalViews = customViewsCount > 0 || subcollectionsCount > 0;
  const [usedEntity, setUsedEntity] = useState(entity);
  const [readOnly, setReadOnly] = useState(void 0);
  const baseDataSourceValuesRef = useRef(getDataSourceEntityValues(initialResolvedCollection, status, usedEntity));
  useEffect(() => {
    if (entity) setUsedEntity(entity);
  }, [entity]);
  useEffect(() => {
    if (status === "new") {
      setReadOnly(false);
    } else {
      const editEnabled = usedEntity ? canEditEntity(collection, authController, path, usedEntity ?? null) : false;
      if (usedEntity) setReadOnly(!editEnabled);
    }
  }, [authController, usedEntity, status]);
  const onPreSaveHookError = useCallback((e2) => {
    setSaving(false);
    snackbarController.open({
      type: "error",
      message: "Error before saving: " + e2?.message
    });
    console.error(e2);
  }, [snackbarController]);
  const onSaveSuccessHookError = useCallback((e_0) => {
    setSaving(false);
    snackbarController.open({
      type: "error",
      message: "Error after saving (entity is saved): " + e_0?.message
    });
    console.error(e_0);
  }, [snackbarController]);
  const onSaveSuccess = (updatedEntity, closeAfterSave) => {
    setSaving(false);
    if (!autoSave) snackbarController.open({
      type: "success",
      message: `${collection.singularName ?? collection.name}: Saved correctly`
    });
    setUsedEntity(updatedEntity);
    setStatus("existing");
    onValuesAreModified(false);
    if (onUpdate) onUpdate({
      entity: updatedEntity
    });
    if (closeAfterSave) {
      sideDialogContext.setBlocked(false);
      sideDialogContext.close(true);
      onClose?.();
    } else if (status !== "existing") {
      sideEntityController.replace({
        path,
        entityId: updatedEntity.id,
        selectedSubPath: MAIN_TAB_VALUE === selectedTab ? void 0 : selectedTab,
        updateUrl: true,
        collection
      });
    }
  };
  const onSaveFailure = useCallback((e_1) => {
    setSaving(false);
    snackbarController.open({
      type: "error",
      message: "Error saving: " + e_1?.message
    });
    console.error("Error saving entity", path, entityId);
    console.error(e_1);
  }, [entityId, path, snackbarController]);
  const saveEntity = ({
    values,
    previousValues,
    closeAfterSave: closeAfterSave_0,
    entityId: entityId_0,
    collection: collection_0,
    path: path_0
  }) => {
    setSaving(true);
    return saveEntityWithCallbacks({
      path: path_0,
      entityId: entityId_0,
      values,
      previousValues,
      collection: collection_0,
      status,
      dataSource,
      context,
      onSaveSuccess: (updatedEntity_0) => onSaveSuccess(updatedEntity_0, closeAfterSave_0),
      onSaveFailure,
      onPreSaveHookError,
      onSaveSuccessHookError
    }).then();
  };
  const onSaveEntityRequest = async ({
    collection: collection_1,
    path: path_1,
    entityId: entityId_1,
    values: values_0,
    previousValues: previousValues_0,
    closeAfterSave: closeAfterSave_1,
    autoSave: autoSave_0
  }) => {
    if (!status) return;
    if (autoSave_0) {
      setValuesToBeSaved(values_0);
    } else {
      return saveEntity({
        collection: collection_1,
        path: path_1,
        entityId: entityId_1,
        values: values_0,
        previousValues: previousValues_0,
        closeAfterSave: closeAfterSave_1
      });
    }
  };
  const onSubmit = (values_1, formexController) => {
    if (mustSetCustomId && !entityId) {
      console.error("Missing custom Id");
      setEntityIdError(true);
      formexController.setSubmitting(false);
      return;
    }
    setSavingError(void 0);
    setEntityIdError(false);
    if (status === "existing") {
      if (!entity?.id) throw Error("Form misconfiguration when saving, no id for existing entity");
    } else if (status === "new" || status === "copy") {
      if (inputCollection.customId) {
        if (inputCollection.customId !== "optional" && !entityId) {
          throw Error("Form misconfiguration when saving, entityId should be set");
        }
      }
    } else {
      throw Error("New FormType added, check EntityForm");
    }
    return save(values_1)?.then((_) => {
      formexController.resetForm({
        values: values_1,
        submitCount: 0,
        touched: {}
      });
    }).finally(() => {
      formexController.setSubmitting(false);
    });
  };
  const formex = useCreateFormex({
    initialValues: baseDataSourceValuesRef.current,
    onSubmit,
    validation: (values_2) => {
      return validationSchema?.validate(values_2, {
        abortEarly: false
      }).then(() => {
        return {};
      }).catch((e_2) => {
        return yupToFormErrors(e_2);
      });
    }
  });
  const resolvedCollection = resolveCollection({
    collection: inputCollection,
    path,
    entityId,
    values: formex.values,
    previousValues: formex.initialValues,
    propertyConfigs: customizationController.propertyConfigs
  });
  const lastSavedValues = useRef(entity?.values);
  const save = (values_3) => {
    lastSavedValues.current = values_3;
    return onSaveEntityRequest({
      collection: resolvedCollection,
      path,
      entityId,
      values: values_3,
      previousValues: entity?.values,
      closeAfterSave: closeAfterSaveRef.current,
      autoSave: autoSave ?? false
    }).then((__0) => {
      const eventName = status === "new" ? "new_entity_saved" : status === "copy" ? "entity_copied" : status === "existing" ? "entity_edited" : "unmapped_event";
      analyticsController.onAnalyticsEvent?.(eventName, {
        path
      });
    }).catch((e_3) => {
      console.error(e_3);
      setSavingError(e_3);
    }).finally(() => {
      closeAfterSaveRef.current = false;
    });
  };
  const formContext = {
    // @ts-ignore
    setFieldValue: useCallback(formex.setFieldValue, []),
    values: formex.values,
    collection: resolvedCollection,
    entityId,
    path,
    save,
    formex
  };
  const resolvedEntityViews = customViews ? customViews.map((e_4) => resolveEntityView(e_4, customizationController.entityViews)).filter(Boolean) : [];
  const selectedEntityView = resolvedEntityViews.find((e_5) => e_5.key === selectedTab);
  const shouldShowEntityActions = !autoSave && (selectedTab === MAIN_TAB_VALUE || selectedEntityView?.includeActions);
  const customViewsView = customViews && resolvedEntityViews.map((customView, colIndex) => {
    if (!customView) return null;
    if (selectedTab !== customView.key) return null;
    const Builder = customView.Builder;
    if (!Builder) {
      console.error("customView.Builder is not defined");
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls(defaultBorderMixin, "relative flex-grow w-full h-full overflow-auto "), role: "tabpanel", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Builder, { collection, entity: usedEntity, modifiedValues: formex.values ?? usedEntity?.values, formContext }) }) }, `custom_view_${customView.key}`);
  }).filter(Boolean);
  const globalLoading = dataLoading && !usedEntity || (!usedEntity || readOnly === void 0) && (status === "existing" || status === "copy");
  const loading = globalLoading || saving;
  const subCollectionsViews = subcollections && subcollections.map((subcollection, colIndex_0) => {
    const subcollectionId = subcollection.id ?? subcollection.path;
    const fullPath = usedEntity ? `${path}/${usedEntity?.id}/${removeInitialAndTrailingSlashes(subcollectionId)}` : void 0;
    if (selectedTab !== subcollectionId) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex-grow h-full overflow-auto w-full", role: "tabpanel", children: [
      loading && /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCenter, {}),
      !globalLoading && (usedEntity && fullPath ? /* @__PURE__ */ jsxRuntimeExports.jsx(EntityCollectionView, { fullPath, parentCollectionIds: [...parentCollectionIds, collection.id], isSubCollection: true, ...subcollection }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center w-full h-full p-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "label", children: "You need to save your entity before adding additional collections" }) }))
    ] }, `subcol_${subcollectionId}`);
  }).filter(Boolean);
  const onDiscard = useCallback(() => {
    onValuesAreModified(false);
  }, []);
  const onSideTabClick = (value) => {
    setSelectedTab(value);
    if (status === "existing") {
      sideEntityController.replace({
        path,
        entityId,
        selectedSubPath: value === MAIN_TAB_VALUE ? void 0 : value,
        updateUrl: true,
        collection
      });
    }
  };
  const onIdUpdateError = useCallback((error) => {
    snackbarController.open({
      type: "error",
      message: "Error updating id, check the console"
    });
  }, []);
  const onIdChange = useCallback((id2) => {
    setUsedEntity((prevEntity) => prevEntity ? {
      ...prevEntity,
      id: id2
    } : void 0);
  }, []);
  const pluginActions = [];
  const plugins = customizationController.plugins;
  if (plugins && inputCollection) {
    const actionProps = {
      entityId,
      path,
      status,
      collection: inputCollection,
      context,
      currentEntityId: entityId,
      formContext
    };
    pluginActions.push(...plugins.map((plugin, i) => plugin.form?.Actions ? /* @__PURE__ */ jsxRuntimeExports.jsx(plugin.form.Actions, { ...actionProps }, `actions_${plugin.key}`) : null).filter(Boolean));
  }
  const titlePropertyKey = getEntityTitlePropertyKey(resolvedCollection, customizationController.propertyConfigs);
  const title = formex.values && titlePropertyKey ? getValueInPath(formex.values, titlePropertyKey) : void 0;
  const onIdUpdate = inputCollection.callbacks?.onIdUpdate;
  const doOnIdUpdate = useCallback(async () => {
    if (onIdUpdate && formex.values && (status === "new" || status === "copy")) {
      setCustomIdLoading(true);
      try {
        const updatedId = await onIdUpdate({
          collection: resolvedCollection,
          path,
          entityId,
          values: formex.values,
          context
        });
        setEntityId(updatedId);
      } catch (e_6) {
        onIdUpdateError?.(e_6);
        console.error(e_6);
      }
      setCustomIdLoading(false);
    }
  }, [entityId, formex.values, status]);
  useEffect(() => {
    doOnIdUpdate();
  }, [doOnIdUpdate]);
  const [underlyingChanges, setUnderlyingChanges] = useState({});
  const uniqueFieldValidator = useCallback(({
    name,
    value: value_0,
    property: property2
  }) => dataSource.checkUniqueField(path, name, value_0, entityId, collection), [dataSource, path, entityId]);
  const validationSchema = useMemo(() => entityId ? getYupEntitySchema(entityId, resolvedCollection.properties, uniqueFieldValidator) : void 0, [entityId, resolvedCollection.properties, uniqueFieldValidator]);
  const getActionsForEntity = useCallback(({
    entity: entity_0,
    customEntityActions
  }) => {
    const createEnabled = canCreateEntity(inputCollection, authController, path, null);
    const deleteEnabled = entity_0 ? canDeleteEntity(inputCollection, authController, path, entity_0) : true;
    const actions = [];
    if (createEnabled) actions.push(copyEntityAction);
    if (deleteEnabled) actions.push(deleteEntityAction);
    if (customEntityActions) actions.push(...customEntityActions);
    return actions;
  }, [authController, inputCollection, path]);
  const modified = formex.dirty;
  useEffect(() => {
    if (!autoSave) {
      onValuesAreModified(modified);
    } else {
      if (formex.values && !equal(formex.values, lastSavedValues.current)) {
        save(formex.values);
      }
    }
  }, [modified, formex.values]);
  useEffect(() => {
    if (!autoSave && !formex.isSubmitting && underlyingChanges && entity) {
      Object.entries(underlyingChanges).forEach(([key, value_1]) => {
        const formValue = formex.values[key];
        if (!equal(value_1, formValue) && !formex.touched[key]) {
          console.debug("Updated value from the datasource:", key, value_1);
          formex.setFieldValue(key, value_1 !== void 0 ? value_1 : null);
        }
      });
    }
  }, [formex.isSubmitting, autoSave, underlyingChanges, entity, formex.values, formex.touched, formex.setFieldValue]);
  const formFields = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: getFormFieldKeys(resolvedCollection).map((key_0) => {
    const property_0 = resolvedCollection.properties[key_0];
    if (property_0) {
      const underlyingValueHasChanged = !!underlyingChanges && Object.keys(underlyingChanges).includes(key_0) && formex.touched[key_0];
      const disabled = !autoSave && formex.isSubmitting || isReadOnly(property_0) || Boolean(property_0.disabled);
      const hidden = isHidden(property_0);
      if (hidden) return null;
      const cmsFormFieldProps = {
        propertyKey: key_0,
        disabled,
        property: property_0,
        includeDescription: property_0.description || property_0.longDescription,
        underlyingValueHasChanged: underlyingValueHasChanged && !autoSave,
        context: formContext,
        partOfArray: false,
        minimalistView: false,
        autoFocus: false
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: `form_field_${key_0}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyFieldBinding, { ...cmsFormFieldProps }) }) }, `field_${resolvedCollection.name}_${key_0}`);
    }
    const additionalField = resolvedCollection.additionalFields?.find((f) => f.key === key_0);
    if (additionalField && entity) {
      const Builder_0 = additionalField.Builder;
      if (!Builder_0 && !additionalField.value) {
        throw new Error("When using additional fields you need to provide a Builder or a value");
      }
      const child = Builder_0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Builder_0, { entity, context }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: additionalField.value?.({
        entity,
        context
      })?.toString() });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(LabelWithIconAndTooltip, { propertyKey: key_0, icon: /* @__PURE__ */ jsxRuntimeExports.jsx(NotesIcon, { size: "small" }), title: additionalField.name, className: "text-text-secondary dark:text-text-secondary-dark ml-3.5" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls(paperMixin, "min-h-14 p-4 md:p-6 overflow-x-scroll no-scrollbar"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: child }) })
      ] }, `additional_${key_0}`);
    }
    console.warn(`Property ${key_0} not found in collection ${resolvedCollection.name} in properties or additional fields. Skipping.`);
    return null;
  }).filter(Boolean) });
  const disabled_0 = formex.isSubmitting || !modified && status === "existing";
  const formRef = React__default.useRef(null);
  const entityActions = getActionsForEntity({
    entity,
    customEntityActions: inputCollection.entityActions
  });
  const formActions = entityActions.filter((a2) => a2.includeInForm === void 0 || a2.includeInForm);
  const dialogActions = /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions, { position: "absolute", children: [
    savingError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-right", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { color: "error", children: savingError.message }) }),
    entity && formActions.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow flex overflow-auto no-scrollbar", children: formActions.map((action) => /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { color: "primary", onClick: (event) => {
      event.stopPropagation();
      if (entity) action.onClick({
        entity,
        fullPath: resolvedCollection.path,
        collection: resolvedCollection,
        context,
        sideEntityController
      });
    }, children: action.icon }, action.name)) }),
    formex.isSubmitting && /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: "small" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "text", disabled: disabled_0 || formex.isSubmitting, type: "reset", children: status === "existing" ? "Discard" : "Clear" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { variant: "text", color: "primary", type: "submit", disabled: disabled_0 || formex.isSubmitting, onClick: () => {
      closeAfterSaveRef.current = false;
    }, children: [
      status === "existing" && "Save",
      status === "copy" && "Create copy",
      status === "new" && "Create"
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { variant: "filled", color: "primary", type: "submit", disabled: disabled_0 || formex.isSubmitting, onClick: () => {
      closeAfterSaveRef.current = true;
    }, children: [
      status === "existing" && "Save and close",
      status === "copy" && "Create copy and close",
      status === "new" && "Create and close"
    ] })
  ] });
  function buildForm() {
    let form = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      pluginActions.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls("w-full flex justify-end items-center sticky top-0 right-0 left-0 z-10 bg-opacity-60 bg-surface-accent-200 dark:bg-opacity-60 dark:bg-surface-accent-800 backdrop-blur-md"), children: pluginActions }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pt-12 pb-16 pl-4 sm:px-8 md:px-10", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `w-full py-2 flex flex-col items-start mt-${4 + 8} lg:mt-${8 + 8} mb-8`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { className: "mt-4 flex-grow line-clamp-1 " + inputCollection.hideIdFromForm ? "mb-2" : "mb-0", variant: "h4", children: title ?? inputCollection.singularName ?? inputCollection.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { color: "base", className: "w-full", size: "small", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("code", { className: "text-xs select-all", children: [
            path,
            "/",
            entityId
          ] }) })
        ] }),
        !collection.hideIdFromForm && /* @__PURE__ */ jsxRuntimeExports.jsx(CustomIdField, { customId: inputCollection.customId, entityId, status, onChange: setEntityId, error: entityIdError, loading: customIdLoading, entity }),
        entityId && formContext && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-12 flex flex-col gap-8", ref: formRef, children: [
            formFields,
            /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorFocus, { containerRef: formRef })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-14" })
        ] })
      ] })
    ] });
    if (plugins) {
      plugins.forEach((plugin_0) => {
        if (plugin_0.form?.provider) {
          form = /* @__PURE__ */ jsxRuntimeExports.jsx(plugin_0.form.provider.Component, { status, path, collection, onDiscard, entity: usedEntity, context, formContext, ...plugin_0.form.provider.props, children: form });
        }
      });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: form });
  }
  const entityView = readOnly === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {}) : !readOnly ? buildForm() : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { className: "mt-16 mb-8 mx-8", variant: "h4", children: collection.singularName ?? collection.name }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(EntityView, { className: "px-12", entity: usedEntity, path, collection })
  ] });
  const subcollectionTabs = subcollections && subcollections.map((subcollection_0) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { className: "text-sm min-w-[140px]", value: subcollection_0.id, children: subcollection_0.name }, `entity_detail_collection_tab_${subcollection_0.name}`));
  const customViewTabs = resolvedEntityViews.map((view) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { className: "text-sm min-w-[140px]", value: view.key, children: view.name }, `entity_detail_collection_tab_${view.name}`));
  useEffect(() => {
    if (entityId && onIdChange) onIdChange(entityId);
  }, [entityId, onIdChange]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Formex, { value: formex, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col h-full w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cls(defaultBorderMixin, "no-scrollbar h-16 border-b pl-2 pr-2 pt-1 flex items-end overflow-scroll bg-surface-50 dark:bg-surface-950"), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pb-1 self-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => {
        onClose?.();
        return sideDialogContext.close(false);
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, { size: "small" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow" }),
      globalLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "self-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: "small" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs, { value: selectedTab, onValueChange: (value_2) => {
        onSideTabClick(value_2);
      }, innerClassName: "pl-4 pr-4 pt-0", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { disabled: !hasAdditionalViews, value: MAIN_TAB_VALUE, className: `${!hasAdditionalViews ? "hidden" : ""} text-sm min-w-[140px]`, children: collection.singularName ?? collection.name }),
        customViewTabs,
        subcollectionTabs
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: formex.handleSubmit, onReset: () => {
      formex.resetForm();
      return onDiscard && onDiscard();
    }, noValidate: true, className: "flex-grow h-full flex overflow-auto flex-col w-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { role: "tabpanel", hidden: !mainViewVisible, id: `form_${path}`, className: "relative w-full", children: globalLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCenter, {}) : entityView }),
      customViewsView,
      subCollectionsViews,
      shouldShowEntityActions && dialogActions
    ] })
  ] }) });
}
function getDataSourceEntityValues(initialResolvedCollection, status, entity) {
  const properties = initialResolvedCollection.properties;
  if ((status === "existing" || status === "copy") && entity) {
    return entity.values ?? getDefaultValuesFor(properties);
  } else if (status === "new") {
    return getDefaultValuesFor(properties);
  } else {
    console.error({
      status,
      entity
    });
    throw new Error("Form has not been initialised with the correct parameters");
  }
}
function yupToFormErrors(yupError) {
  let errors = {};
  if (yupError.inner) {
    if (yupError.inner.length === 0) {
      return setIn(errors, yupError.path, yupError.message);
    }
    for (const err of yupError.inner) {
      if (!getIn(errors, err.path)) {
        errors = setIn(errors, err.path, err.message);
      }
    }
  }
  return errors;
}
function PopupFormField(props) {
  const $ = c_1(2);
  if (!props.open) {
    return null;
  }
  let t0;
  if ($[0] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(PopupFormFieldLoading, { ...props });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PopupFormFieldLoading(t0) {
  const $ = c_1(23);
  const {
    tableKey,
    entityId,
    customFieldValidator,
    propertyKey,
    collection: inputCollection,
    path,
    cellRect,
    open,
    onClose,
    onCellValueChange,
    container
  } = t0;
  const dataSource = useDataSource();
  const [entity, setEntity] = useState(void 0);
  let t1;
  if ($[0] !== dataSource || $[1] !== entityId || $[2] !== inputCollection || $[3] !== path) {
    t1 = () => {
      if (entityId && inputCollection) {
        dataSource.fetchEntity({
          path,
          entityId,
          collection: inputCollection
        }).then(setEntity);
      }
    };
    $[0] = dataSource;
    $[1] = entityId;
    $[2] = inputCollection;
    $[3] = path;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  let t2;
  if ($[5] !== entityId || $[6] !== inputCollection) {
    t2 = [entityId, inputCollection];
    $[5] = entityId;
    $[6] = inputCollection;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  useEffect(t1, t2);
  if (!entity) {
    return null;
  }
  let t3;
  if ($[8] !== cellRect || $[9] !== container || $[10] !== customFieldValidator || $[11] !== entityId || $[12] !== inputCollection || $[13] !== onCellValueChange || $[14] !== onClose || $[15] !== open || $[16] !== path || $[17] !== propertyKey || $[18] !== tableKey) {
    t3 = {
      tableKey,
      entityId,
      customFieldValidator,
      propertyKey,
      collection: inputCollection,
      path,
      cellRect,
      open,
      onClose,
      onCellValueChange,
      container
    };
    $[8] = cellRect;
    $[9] = container;
    $[10] = customFieldValidator;
    $[11] = entityId;
    $[12] = inputCollection;
    $[13] = onCellValueChange;
    $[14] = onClose;
    $[15] = open;
    $[16] = path;
    $[17] = propertyKey;
    $[18] = tableKey;
    $[19] = t3;
  } else {
    t3 = $[19];
  }
  let t4;
  if ($[20] !== entity || $[21] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(PopupFormFieldInternal, { ...t3, entity });
    $[20] = entity;
    $[21] = t3;
    $[22] = t4;
  } else {
    t4 = $[22];
  }
  return t4;
}
function PopupFormFieldInternal({
  tableKey,
  entityId,
  customFieldValidator,
  propertyKey,
  collection: inputCollection,
  path,
  cellRect,
  open,
  onClose,
  onCellValueChange,
  container,
  entity
}) {
  const fireCMSContext = useFireCMSContext();
  const customizationController = useCustomizationController();
  const [savingError, setSavingError] = React__default.useState();
  const [popupLocation, setPopupLocation] = useState();
  const collection = inputCollection ? resolveCollection({
    collection: inputCollection,
    path,
    values: entity?.values,
    entityId,
    propertyConfigs: customizationController.propertyConfigs
  }) : void 0;
  const windowSize = useWindowSize();
  const draggableRef = React__default.useRef(null);
  const innerRef = React__default.useRef(null);
  const initialPositionSet = React__default.useRef(false);
  const getInitialLocation = useCallback(() => {
    if (!cellRect) throw Error("getInitialLocation error");
    return {
      x: cellRect.left < windowSize.width - cellRect.right ? cellRect.x + cellRect.width / 2 : cellRect.x - cellRect.width / 2,
      y: cellRect.top < windowSize.height - cellRect.bottom ? cellRect.y + cellRect.height / 2 : cellRect.y - cellRect.height / 2
    };
  }, [cellRect, windowSize.height, windowSize.width]);
  const normalizePosition = useCallback(({
    x,
    y
  }) => {
    const draggableBoundingRect = draggableRef.current?.getBoundingClientRect();
    if (!draggableBoundingRect) throw Error("normalizePosition called before draggableBoundingRect is set");
    return {
      x: Math.max(0, Math.min(x, windowSize.width - draggableBoundingRect.width)),
      y: Math.max(0, Math.min(y, windowSize.height - draggableBoundingRect.height))
    };
  }, [windowSize]);
  const updatePopupLocation = useCallback((position2) => {
    const draggableBoundingRect_0 = draggableRef.current?.getBoundingClientRect();
    if (!cellRect || !draggableBoundingRect_0) return;
    const newPosition = position2 ?? normalizePosition(getInitialLocation());
    if (!popupLocation || newPosition.x !== popupLocation.x || newPosition.y !== popupLocation.y) setPopupLocation(newPosition);
  }, [cellRect, getInitialLocation, normalizePosition, popupLocation]);
  useDraggable({
    containerRef: draggableRef,
    innerRef,
    x: popupLocation?.x,
    y: popupLocation?.y,
    onMove: updatePopupLocation
  });
  useEffect(() => {
    initialPositionSet.current = false;
  }, [propertyKey, entity]);
  useLayoutEffect(() => {
    const draggableBoundingRect_1 = draggableRef.current?.getBoundingClientRect();
    if (!cellRect || !draggableBoundingRect_1 || initialPositionSet.current) return;
    updatePopupLocation();
    initialPositionSet.current = true;
  }, [cellRect, updatePopupLocation, initialPositionSet.current]);
  useLayoutEffect(() => {
    updatePopupLocation(popupLocation);
  }, [windowSize, cellRect]);
  const validationSchema = useMemo(() => {
    if (!collection || !entityId) return;
    return getYupEntitySchema(entityId, propertyKey && collection.properties[propertyKey] ? {
      [propertyKey]: collection.properties[propertyKey]
    } : {}, customFieldValidator);
  }, [collection, entityId, propertyKey, customFieldValidator]);
  const adaptResize = useCallback(() => {
    return updatePopupLocation(popupLocation);
  }, [popupLocation, updatePopupLocation]);
  const saveValue = async (values) => {
    setSavingError(null);
    if (inputCollection && entity && onCellValueChange && propertyKey) {
      return onCellValueChange({
        value: values[propertyKey],
        propertyKey,
        data: entity,
        setError: setSavingError,
        onValueUpdated: () => {
        }
      });
    }
    return Promise.resolve();
  };
  const formex = useCreateFormex({
    initialValues: entity?.values ?? {},
    validation: (values_0) => {
      return validationSchema?.validate(values_0, {
        abortEarly: false
      }).then(() => ({})).catch((e2) => {
        return yupToFormErrors(e2);
      });
    },
    validateOnInitialRender: true,
    onSubmit: (values_1, actions) => {
      saveValue(values_1).then(() => {
        formex.resetForm({
          values: values_1
        });
        onClose();
      }).finally(() => actions.setSubmitting(false));
    }
  });
  const {
    values: values_2,
    isSubmitting,
    setFieldValue,
    handleSubmit
  } = formex;
  const disabled = isSubmitting;
  const formContext = {
    collection,
    entityId,
    values: values_2,
    path,
    setFieldValue,
    save: saveValue,
    formex
  };
  const property2 = propertyKey && getPropertyInPath(collection?.properties ?? {}, propertyKey);
  const fieldProps = propertyKey && property2 ? {
    propertyKey,
    disabled: isSubmitting || isReadOnly(property2) || !!property2.disabled,
    property: property2,
    includeDescription: false,
    underlyingValueHasChanged: false,
    context: formContext,
    partOfArray: false,
    minimalistView: false,
    autoFocus: open
  } : void 0;
  let internalForm = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[700px] max-w-full max-h-[85vh]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, noValidate: true, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-1 p-4 flex flex-col relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: innerRef, className: "cursor-auto", style: {
      cursor: "auto !important"
    }, children: fieldProps && /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyFieldBinding, { ...fieldProps }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "filled", color: "primary", type: "submit", disabled, children: "Save" }) })
  ] }) }, `popup_form_${tableKey}_${entityId}_${propertyKey}`) });
  const plugins = customizationController.plugins;
  if (plugins) {
    plugins.forEach((plugin) => {
      if (plugin.form?.provider) {
        internalForm = /* @__PURE__ */ jsxRuntimeExports.jsx(plugin.form.provider.Component, { status: "existing", path, collection, entity, context: fireCMSContext, currentEntityId: entityId, formContext, ...plugin.form.provider.props, children: internalForm });
      }
    });
  }
  const form = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `text-surface-900 dark:text-white overflow-auto rounded rounded-md bg-white dark:bg-surface-950 ${!open ? "hidden" : ""} cursor-grab max-w-[100vw]`, children: [
    internalForm,
    savingError && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { color: "error", children: savingError.message })
  ] });
  const draggable2 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
    boxShadow: "0 0 0 2px rgba(128,128,128,0.2)"
  }, className: `inline-block fixed z-20 shadow-outline rounded-md bg-white dark:bg-surface-950 ${!open ? "invisible" : "visible"} cursor-grab overflow-visible`, ref: draggableRef, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ElementResizeListener, { onResize: adaptResize }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "overflow-hidden", children: [
      form,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute -top-3.5 -right-3.5 bg-surface-500 rounded-full", style: {
        width: "32px",
        height: "32px"
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { size: "small", onClick: (event) => {
        event.stopPropagation();
        onClose();
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, { className: "text-white", size: "small" }) }) })
    ] })
  ] }, `draggable_${propertyKey}_${entityId}_${open}`);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root, { asChild: true, container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Formex, { value: formex, children: draggable2 }) });
}
function ClearFilterSortButton(t0) {
  const $ = c_1(6);
  const {
    tableController,
    enabled
  } = t0;
  if (!enabled) {
    return null;
  }
  const filterIsSet = !!tableController.filterValues && Object.keys(tableController.filterValues).length > 0;
  const sortIsSet = !!tableController.sortBy && tableController.sortBy.length > 0;
  if ((filterIsSet || sortIsSet) && (tableController.clearFilter || tableController.setSortBy)) {
    let label;
    if (filterIsSet && sortIsSet) {
      label = "Clear filter and sort";
    } else {
      if (filterIsSet) {
        label = "Clear filter";
      } else {
        label = "Clear sort";
      }
    }
    let t1;
    if ($[0] !== tableController) {
      t1 = () => {
        tableController.clearFilter?.();
        tableController.setSortBy?.(void 0);
      };
      $[0] = tableController;
      $[1] = t1;
    } else {
      t1 = $[1];
    }
    let t2;
    if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
      t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(FilterListOffIcon, {});
      $[2] = t2;
    } else {
      t2 = $[2];
    }
    let t3;
    if ($[3] !== label || $[4] !== t1) {
      t3 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { variant: "outlined", className: "h-fit-content", "aria-label": "filter clear", onClick: t1, size: "small", children: [
        t2,
        label
      ] });
      $[3] = label;
      $[4] = t1;
      $[5] = t3;
    } else {
      t3 = $[5];
    }
    return t3;
  }
  return null;
}
function EntityCollectionViewStartActions(t0) {
  const $ = c_1(18);
  const {
    collection,
    relativePath,
    parentCollectionIds,
    path,
    selectionController,
    tableController,
    collectionEntitiesCount
  } = t0;
  const context = useFireCMSContext();
  const customizationController = useCustomizationController();
  let t1;
  if ($[0] !== customizationController.plugins) {
    t1 = customizationController.plugins ?? [];
    $[0] = customizationController.plugins;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const plugins = t1;
  let t2;
  if ($[2] !== collection || $[3] !== collectionEntitiesCount || $[4] !== context || $[5] !== parentCollectionIds || $[6] !== path || $[7] !== relativePath || $[8] !== selectionController || $[9] !== tableController) {
    t2 = {
      path,
      relativePath,
      parentCollectionIds,
      collection,
      selectionController,
      context,
      tableController,
      collectionEntitiesCount
    };
    $[2] = collection;
    $[3] = collectionEntitiesCount;
    $[4] = context;
    $[5] = parentCollectionIds;
    $[6] = path;
    $[7] = relativePath;
    $[8] = selectionController;
    $[9] = tableController;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  const actionProps = t2;
  const t3 = !collection.forceFilter;
  let t4;
  if ($[11] !== t3 || $[12] !== tableController) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(ClearFilterSortButton, { tableController, enabled: t3 }, "clear_filter");
    $[11] = t3;
    $[12] = tableController;
    $[13] = t4;
  } else {
    t4 = $[13];
  }
  let t5;
  if ($[14] !== actionProps || $[15] !== plugins || $[16] !== t4) {
    const actions = [t4];
    if (plugins) {
      plugins.forEach((plugin, i) => {
        if (plugin.collectionView?.CollectionActionsStart) {
          actions.push(...toArray(plugin.collectionView?.CollectionActionsStart).map((Action2, j) => /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Action2, { ...actionProps, ...plugin.collectionView?.collectionActionsStartProps }) }, `plugin_actions_${i}_${j}`)));
        }
      });
    }
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: actions });
    $[14] = actionProps;
    $[15] = plugins;
    $[16] = t4;
    $[17] = t5;
  } else {
    t5 = $[17];
  }
  return t5;
}
const COLLECTION_GROUP_PARENT_ID = "collectionGroupParent";
const EntityCollectionView = React__default.memo(function EntityCollectionView2({
  fullPath: fullPathProp,
  parentCollectionIds,
  isSubCollection,
  className,
  ...collectionProp
}) {
  const context = useFireCMSContext();
  const fullPath = fullPathProp ?? collectionProp.path;
  const dataSource = useDataSource();
  const navigation = useNavigationController();
  const sideEntityController = useSideEntityController();
  const authController = useAuthController();
  const userConfigPersistence = useUserConfigurationPersistence();
  const analyticsController = useAnalyticsController();
  const customizationController = useCustomizationController();
  const containerRef = React__default.useRef(null);
  const collection = useMemo(() => {
    const userOverride = userConfigPersistence?.getCollectionConfig(fullPath);
    return userOverride ? mergeDeep(collectionProp, userOverride) : collectionProp;
  }, [collectionProp, fullPath, userConfigPersistence?.getCollectionConfig]);
  const collectionRef = React__default.useRef(collection);
  useEffect(() => {
    collectionRef.current = collection;
  }, [collection]);
  const canCreateEntities = canCreateEntity(collection, authController, fullPath, null);
  const [highlightedEntity, setHighlightedEntity] = useState(void 0);
  const [deleteEntityClicked, setDeleteEntityClicked] = React__default.useState(void 0);
  const [lastDeleteTimestamp, setLastDeleteTimestamp] = React__default.useState(0);
  const [docsCount, setDocsCount] = useState(0);
  const unselectNavigatedEntity = useCallback(() => {
    const currentSelection = highlightedEntity;
    setTimeout(() => {
      if (currentSelection === highlightedEntity) setHighlightedEntity(void 0);
    }, 2400);
  }, [highlightedEntity]);
  const checkInlineEditing = useCallback((entity) => {
    const collection_0 = collectionRef.current;
    if (!canEditEntity(collection_0, authController, fullPath, entity ?? null)) {
      return false;
    }
    return collection_0.inlineEditing === void 0 || collection_0.inlineEditing;
  }, [authController, fullPath]);
  const selectionEnabled = collection.selectionEnabled === void 0 || collection.selectionEnabled;
  const hoverRow = !checkInlineEditing();
  const [popOverOpen, setPopOverOpen] = useState(false);
  const selectionController = useSelectionController();
  const usedSelectionController = collection.selectionController ?? selectionController;
  const {
    selectedEntities,
    setSelectedEntities
  } = usedSelectionController;
  const tableController = useDataSourceEntityCollectionTableController({
    fullPath,
    collection,
    lastDeleteTimestamp
  });
  const tableKey = React__default.useRef(Math.random().toString(36));
  const popupCell = tableController.popupCell;
  const onPopupClose = useCallback(() => {
    tableController.setPopupCell?.(void 0);
  }, [tableController.setPopupCell]);
  const onEntityClick = useCallback((clickedEntity) => {
    const collection_1 = collectionRef.current;
    setHighlightedEntity(clickedEntity);
    analyticsController.onAnalyticsEvent?.("edit_entity_clicked", {
      path: clickedEntity.path,
      entityId: clickedEntity.id
    });
    return sideEntityController.open({
      entityId: clickedEntity.id,
      path: clickedEntity.path,
      collection: collection_1,
      updateUrl: true,
      onClose: unselectNavigatedEntity
    });
  }, [unselectNavigatedEntity, sideEntityController]);
  const onNewClick = useCallback(() => {
    const collection_2 = collectionRef.current;
    analyticsController.onAnalyticsEvent?.("new_entity_click", {
      path: fullPath
    });
    sideEntityController.open({
      path: fullPath,
      collection: collection_2,
      updateUrl: true,
      onClose: unselectNavigatedEntity
    });
  }, [fullPath, sideEntityController]);
  const onMultipleDeleteClick = () => {
    analyticsController.onAnalyticsEvent?.("multiple_delete_dialog_open", {
      path: fullPath
    });
    setDeleteEntityClicked(selectedEntities);
  };
  const internalOnEntityDelete = (_path, entity_0) => {
    analyticsController.onAnalyticsEvent?.("single_entity_deleted", {
      path: fullPath
    });
    setSelectedEntities((selectedEntities_0) => selectedEntities_0.filter((e2) => e2.id !== entity_0.id));
    setLastDeleteTimestamp(Date.now());
  };
  const internalOnMultipleEntitiesDelete = (_path_0, entities) => {
    analyticsController.onAnalyticsEvent?.("multiple_entities_deleted", {
      path: fullPath
    });
    setSelectedEntities([]);
    setDeleteEntityClicked(void 0);
    setLastDeleteTimestamp(Date.now());
  };
  let AddColumnComponent;
  if (customizationController?.plugins) {
    AddColumnComponent = customizationController.plugins.find((plugin) => plugin.collectionView?.AddColumnComponent)?.collectionView?.AddColumnComponent;
  }
  const onCollectionModifiedForUser = useCallback((path, partialCollection) => {
    if (userConfigPersistence) {
      const currentStoredConfig = userConfigPersistence.getCollectionConfig(path);
      const updatedConfig = mergeDeep(currentStoredConfig, partialCollection);
      userConfigPersistence.onCollectionModified(path, updatedConfig);
    }
  }, [userConfigPersistence]);
  const onColumnResize = useCallback(({
    width,
    key
  }) => {
    const collection_3 = collectionRef.current;
    if (!getPropertyInPath(collection_3.properties, key)) return;
    const localCollection = buildPropertyWidthOverwrite(key, width);
    onCollectionModifiedForUser(fullPath, localCollection);
  }, [onCollectionModifiedForUser, fullPath]);
  const onSizeChanged = useCallback((size2) => {
    if (userConfigPersistence) onCollectionModifiedForUser(fullPath, {
      defaultSize: size2
    });
  }, [onCollectionModifiedForUser, fullPath, userConfigPersistence]);
  const createEnabled = canCreateEntity(collection, authController, fullPath, null);
  const uniqueFieldValidator = useCallback(({
    name,
    value,
    property: property2,
    entityId
  }) => dataSource.checkUniqueField(fullPath, name, value, entityId, collection), [fullPath]);
  const onValueChange = ({
    value: value_0,
    propertyKey,
    onValueUpdated,
    setError,
    data: entity_1
  }) => {
    const updatedValues = setIn({
      ...entity_1.values
    }, propertyKey, value_0);
    const saveProps = {
      path: fullPath,
      entityId: entity_1.id,
      values: updatedValues,
      previousValues: entity_1.values,
      collection,
      status: "existing"
    };
    return saveEntityWithCallbacks({
      ...saveProps,
      collection,
      dataSource,
      context,
      onSaveSuccess: () => {
        setError(void 0);
        onValueUpdated();
      },
      onSaveFailure: (e_0) => {
        console.error("Save failure");
        console.error(e_0);
        setError(e_0);
      }
    });
  };
  const resolvedFullPath = navigation.resolveAliasesFrom(fullPath);
  const resolvedCollection = useMemo(() => resolveCollection({
    collection,
    path: fullPath,
    propertyConfigs: customizationController.propertyConfigs
  }), [collection, fullPath]);
  const getPropertyFor = useCallback(({
    propertyKey: propertyKey_0,
    entity: entity_2
  }) => {
    let propertyOrBuilder = getPropertyInPath(collection.properties, propertyKey_0);
    if (!propertyOrBuilder) {
      propertyOrBuilder = getPropertyInPath(resolvedCollection.properties, propertyKey_0);
    }
    return resolveProperty({
      propertyKey: propertyKey_0,
      propertyOrBuilder,
      path: entity_2.path,
      values: entity_2.values,
      entityId: entity_2.id,
      propertyConfigs: customizationController.propertyConfigs
    });
  }, [collection.properties, customizationController.propertyConfigs, resolvedCollection.properties]);
  const displayedColumnIds = useColumnIds(resolvedCollection, true);
  const additionalFields = useMemo(() => {
    const subcollectionColumns = collection.subcollections?.map((subcollection) => {
      return {
        key: getSubcollectionColumnId(subcollection),
        name: subcollection.name,
        width: 200,
        dependencies: [],
        Builder: ({
          entity: entity_3
        }) => /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { color: "primary", variant: "outlined", startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardTabIcon, { size: "small" }), onClick: (event) => {
          event.stopPropagation();
          sideEntityController.open({
            path: fullPath,
            entityId: entity_3.id,
            selectedSubPath: subcollection.id ?? subcollection.path,
            collection,
            updateUrl: true
          });
        }, children: subcollection.name })
      };
    }) ?? [];
    const collectionGroupParentCollections = collection.collectionGroup ? [{
      key: COLLECTION_GROUP_PARENT_ID,
      name: "Parent entities",
      width: 260,
      dependencies: [],
      Builder: ({
        entity: entity_4
      }) => {
        const collectionsWithPath = navigation.getParentReferencesFromPath(entity_4.path);
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-2 w-full", children: collectionsWithPath.map((reference2) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(ReferencePreview, { reference: reference2, size: "small" }, reference2.path + "/" + reference2.id);
        }) });
      }
    }] : [];
    return [...collection.additionalFields ?? [], ...subcollectionColumns, ...collectionGroupParentCollections];
  }, [collection, fullPath, sideEntityController]);
  const updateLastDeleteTimestamp = useCallback(() => {
    setLastDeleteTimestamp(Date.now());
  }, []);
  const largeLayout = useLargeLayout();
  const getActionsForEntity = ({
    entity: entity_5,
    customEntityActions
  }) => {
    const deleteEnabled = entity_5 ? canDeleteEntity(collection, authController, fullPath, entity_5) : true;
    const actions = [editEntityAction];
    if (createEnabled) actions.push(copyEntityAction);
    if (deleteEnabled) actions.push(deleteEntityAction);
    if (customEntityActions) actions.push(...customEntityActions);
    return actions;
  };
  const getIdColumnWidth = () => {
    const entityActions = getActionsForEntity({});
    const collapsedActions = entityActions.filter((a2) => a2.collapsed !== false);
    const uncollapsedActions = entityActions.filter((a_0) => a_0.collapsed === false);
    const actionsWidth = uncollapsedActions.length * (largeLayout ? 40 : 30);
    return (largeLayout ? 80 + actionsWidth : 70 + actionsWidth) + (collapsedActions.length > 0 ? largeLayout ? 40 : 30 : 0);
  };
  const tableRowActionsBuilder = useCallback(({
    entity: entity_6,
    size: size_0,
    width: width_0,
    frozen
  }) => {
    const isSelected = Boolean(usedSelectionController.selectedEntities.find((e_1) => e_1.id == entity_6.id && e_1.path == entity_6.path));
    const actions_0 = getActionsForEntity({
      entity: entity_6,
      customEntityActions: collection.entityActions
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(EntityCollectionRowActions, { entity: entity_6, width: width_0, frozen, isSelected, selectionEnabled, size: size_0, highlightEntity: setHighlightedEntity, unhighlightEntity: unselectNavigatedEntity, collection, fullPath, actions: actions_0, hideId: collection?.hideIdFromCollection, onCollectionChange: updateLastDeleteTimestamp, selectionController: usedSelectionController });
  }, [updateLastDeleteTimestamp, usedSelectionController]);
  const title = /* @__PURE__ */ jsxRuntimeExports.jsx(Popover, { open: popOverOpen, onOpenChange: setPopOverOpen, enabled: Boolean(collection.description), trigger: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-start", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", className: `leading-none truncate max-w-[160px] lg:max-w-[240px] ${collection.description ? "cursor-pointer" : "cursor-auto"}`, onClick: collection.description ? (e_2) => {
      setPopOverOpen(true);
      e_2.stopPropagation();
    } : void 0, children: `${collection.name}` }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(EntitiesCount, { fullPath, collection, filter: tableController.filterValues, sortBy: tableController.sortBy, onCountChange: setDocsCount })
  ] }), children: collection.description && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-4 text-surface-900 dark:text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Markdown, { source: collection.description }) }) });
  const buildAdditionalHeaderWidget = useCallback(({
    property: property_0,
    propertyKey: propertyKey_1,
    onHover
  }) => {
    const collection_4 = collectionRef.current;
    if (!customizationController.plugins) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: customizationController.plugins.filter((plugin_0) => plugin_0.collectionView?.HeaderAction).map((plugin_1, i) => {
      const HeaderAction = plugin_1.collectionView.HeaderAction;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(HeaderAction, { onHover, propertyKey: propertyKey_1, property: property_0, fullPath, collection: collection_4, tableController, parentCollectionIds: parentCollectionIds ?? [] }, `plugin_header_action_${i}`);
    }) });
  }, [customizationController.plugins, fullPath, parentCollectionIds]);
  const addColumnComponentInternal = AddColumnComponent ? function() {
    if (typeof AddColumnComponent === "function") return /* @__PURE__ */ jsxRuntimeExports.jsx(AddColumnComponent, { fullPath, parentCollectionIds: parentCollectionIds ?? [], collection, tableController });
    return null;
  } : void 0;
  const {
    textSearchLoading,
    textSearchInitialised,
    onTextSearchClick,
    textSearchEnabled
  } = useTableSearchHelper({
    collection,
    fullPath: resolvedFullPath,
    parentCollectionIds
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cls("overflow-hidden h-full w-full rounded-md", className), ref: containerRef, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(EntityCollectionTable, { additionalFields, tableController, enablePopupIcon: true, displayedColumnIds, onSizeChanged, onEntityClick, onColumnResize, onValueChange, tableRowActionsBuilder, uniqueFieldValidator, title, selectionController: usedSelectionController, highlightedEntities: highlightedEntity ? [highlightedEntity] : [], defaultSize: collection.defaultSize, properties: resolvedCollection.properties, getPropertyFor, onTextSearchClick: textSearchInitialised ? void 0 : onTextSearchClick, textSearchLoading, textSearchEnabled, actionsStart: /* @__PURE__ */ jsxRuntimeExports.jsx(EntityCollectionViewStartActions, { parentCollectionIds: parentCollectionIds ?? [], collection, tableController, path: fullPath, relativePath: collection.path, selectionController: usedSelectionController, collectionEntitiesCount: docsCount }), actions: /* @__PURE__ */ jsxRuntimeExports.jsx(EntityCollectionViewActions, { parentCollectionIds: parentCollectionIds ?? [], collection, tableController, onMultipleDeleteClick, onNewClick, path: fullPath, relativePath: collection.path, selectionController: usedSelectionController, selectionEnabled, collectionEntitiesCount: docsCount }), emptyComponent: canCreateEntities && tableController.filterValues === void 0 && tableController.sortBy === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", children: "So empty..." }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { color: "primary", variant: "outlined", onClick: onNewClick, className: "mt-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon, {}),
        "Create your first entity"
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "label", children: "No results with the applied filter/sort" }), hoverRow, inlineEditing: checkInlineEditing(), AdditionalHeaderWidget: buildAdditionalHeaderWidget, AddColumnComponent: addColumnComponentInternal, getIdColumnWidth, additionalIDHeaderWidget: /* @__PURE__ */ jsxRuntimeExports.jsx(EntityIdHeaderWidget, { path: fullPath, collection }) }, `collection_table_${fullPath}`),
    popupCell && /* @__PURE__ */ jsxRuntimeExports.jsx(PopupFormField, { open: Boolean(popupCell), onClose: onPopupClose, cellRect: popupCell?.cellRect, propertyKey: popupCell?.propertyKey, collection, entityId: popupCell.entityId, tableKey: tableKey.current, customFieldValidator: uniqueFieldValidator, path: resolvedFullPath, onCellValueChange: onValueChange, container: containerRef.current }, `popup_form_${popupCell?.propertyKey}_${popupCell?.entityId}`),
    deleteEntityClicked && /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteEntityDialog, { entityOrEntitiesToDelete: deleteEntityClicked, path: fullPath, collection, callbacks: collection.callbacks, open: Boolean(deleteEntityClicked), onEntityDelete: internalOnEntityDelete, onMultipleEntitiesDelete: internalOnMultipleEntitiesDelete, onClose: () => setDeleteEntityClicked(void 0) })
  ] });
}, (a2, b) => {
  return equal(a2.fullPath, b.fullPath) && equal(a2.parentCollectionIds, b.parentCollectionIds) && equal(a2.isSubCollection, b.isSubCollection) && equal(a2.className, b.className) && equal(a2.properties, b.properties) && equal(a2.propertiesOrder, b.propertiesOrder) && equal(a2.hideIdFromCollection, b.hideIdFromCollection) && equal(a2.inlineEditing, b.inlineEditing) && equal(a2.selectionEnabled, b.selectionEnabled) && equal(a2.selectionController, b.selectionController) && equal(a2.Actions, b.Actions) && equal(a2.defaultSize, b.defaultSize) && equal(a2.initialFilter, b.initialFilter) && equal(a2.initialSort, b.initialSort) && equal(a2.textSearchEnabled, b.textSearchEnabled) && equal(a2.additionalFields, b.additionalFields) && equal(a2.sideDialogWidth, b.sideDialogWidth) && equal(a2.forceFilter, b.forceFilter);
});
function EntitiesCount({
  fullPath,
  collection,
  filter,
  sortBy,
  onCountChange
}) {
  const dataSource = useDataSource();
  const navigation = useNavigationController();
  const [count, setCount] = useState(void 0);
  const [error, setError] = useState(void 0);
  const sortByProperty = sortBy ? sortBy[0] : void 0;
  const currentSort = sortBy ? sortBy[1] : void 0;
  const resolvedPath = useMemo(() => navigation.resolveAliasesFrom(fullPath), [fullPath, navigation.resolveAliasesFrom]);
  useEffect(() => {
    if (dataSource.countEntities) dataSource.countEntities({
      path: resolvedPath,
      collection,
      filter,
      orderBy: sortByProperty,
      order: currentSort
    }).then(setCount).catch(setError);
  }, [fullPath, dataSource.countEntities, resolvedPath, collection, filter, sortByProperty, currentSort]);
  useEffect(() => {
    if (onCountChange) {
      setError(void 0);
      onCountChange(count ?? 0);
    }
  }, [onCountChange, count]);
  if (error) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { className: "w-full text-ellipsis block overflow-hidden whitespace-nowrap max-w-xs text-left w-fit-content", variant: "caption", color: "secondary", children: count !== void 0 ? `${count} entities` : /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { className: "w-full max-w-[80px] mt-1" }) });
}
function buildPropertyWidthOverwrite(key, width) {
  if (key.includes(".")) {
    const [parentKey, ...childKey] = key.split(".");
    return {
      properties: {
        [parentKey]: buildPropertyWidthOverwrite(childKey.join("."), width)
      }
    };
  }
  return {
    properties: {
      [key]: {
        columnWidth: width
      }
    }
  };
}
function EntityIdHeaderWidget(t0) {
  const $ = c_1(36);
  const {
    collection,
    path
  } = t0;
  const [openPopup, setOpenPopup] = React__default.useState(false);
  const [searchString, setSearchString] = React__default.useState("");
  let t1;
  if ($[0] !== collection.id) {
    t1 = getRecentIds(collection.id);
    $[0] = collection.id;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const [recentIds, setRecentIds] = React__default.useState(t1);
  const sideEntityController = useSideEntityController();
  const t2 = !openPopup ? "Find by ID" : void 0;
  let t3;
  let t4;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { size: "small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SearchIcon, { size: "small" }) });
    t4 = cls("my-2 rounded-lg bg-surface-50 dark:bg-surface-950 text-surface-900 dark:text-white");
    $[2] = t3;
    $[3] = t4;
  } else {
    t3 = $[2];
    t4 = $[3];
  }
  let t5;
  if ($[4] !== collection || $[5] !== path || $[6] !== searchString || $[7] !== sideEntityController) {
    t5 = (e2) => {
      e2.preventDefault();
      if (!searchString) {
        return;
      }
      setOpenPopup(false);
      setRecentIds(addRecentId(collection.id, searchString.trim()));
      return sideEntityController.open({
        entityId: searchString.trim(),
        path,
        collection,
        updateUrl: true
      });
    };
    $[4] = collection;
    $[5] = path;
    $[6] = searchString;
    $[7] = sideEntityController;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  let t6;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = (e_0) => {
      setSearchString(e_0.target.value);
    };
    $[9] = t6;
  } else {
    t6 = $[9];
  }
  let t7;
  if ($[10] !== openPopup || $[11] !== searchString) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx("input", { autoFocus: openPopup, placeholder: "Find entity by ID", onChange: t6, value: searchString, className: "rounded-lg bg-white dark:bg-surface-800 flex-grow bg-transparent outline-none p-2 " + focusedDisabled });
    $[10] = openPopup;
    $[11] = searchString;
    $[12] = t7;
  } else {
    t7 = $[12];
  }
  const t8 = !searchString.trim();
  let t9;
  if ($[13] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardTabIcon, {});
    $[13] = t9;
  } else {
    t9 = $[13];
  }
  let t10;
  if ($[14] !== t8) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "text", disabled: t8, type: "submit", children: t9 });
    $[14] = t8;
    $[15] = t10;
  } else {
    t10 = $[15];
  }
  let t11;
  if ($[16] !== t10 || $[17] !== t7) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex p-2 w-full gap-2", children: [
      t7,
      t10
    ] });
    $[16] = t10;
    $[17] = t7;
    $[18] = t11;
  } else {
    t11 = $[18];
  }
  let t12;
  if ($[19] !== t11 || $[20] !== t5) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsx("form", { noValidate: true, onSubmit: t5, className: "w-96 max-w-full", children: t11 });
    $[19] = t11;
    $[20] = t5;
    $[21] = t12;
  } else {
    t12 = $[21];
  }
  let t13;
  if ($[22] !== collection || $[23] !== path || $[24] !== recentIds || $[25] !== sideEntityController) {
    t13 = recentIds && recentIds.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-2 p-2", children: recentIds.map((id2) => /* @__PURE__ */ jsxRuntimeExports.jsx(ReferencePreview, { reference: new EntityReference(id2, path), hover: true, onClick: () => {
      setOpenPopup(false);
      sideEntityController.open({
        entityId: id2,
        path,
        collection,
        updateUrl: true
      });
    }, includeEntityLink: false, size: "small" }, id2)) });
    $[22] = collection;
    $[23] = path;
    $[24] = recentIds;
    $[25] = sideEntityController;
    $[26] = t13;
  } else {
    t13 = $[26];
  }
  let t14;
  if ($[27] !== t12 || $[28] !== t13) {
    t14 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t4, children: [
      t12,
      t13
    ] });
    $[27] = t12;
    $[28] = t13;
    $[29] = t14;
  } else {
    t14 = $[29];
  }
  let t15;
  if ($[30] !== openPopup || $[31] !== t14) {
    t15 = /* @__PURE__ */ jsxRuntimeExports.jsx(Popover, { open: openPopup, onOpenChange: setOpenPopup, sideOffset: 0, align: "start", alignOffset: -117, trigger: t3, children: t14 });
    $[30] = openPopup;
    $[31] = t14;
    $[32] = t15;
  } else {
    t15 = $[32];
  }
  let t16;
  if ($[33] !== t15 || $[34] !== t2) {
    t16 = /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: t2, asChild: false, children: t15 });
    $[33] = t15;
    $[34] = t2;
    $[35] = t16;
  } else {
    t16 = $[35];
  }
  return t16;
}
function PropertyConfigBadge(t0) {
  const $ = c_1(6);
  const {
    propertyConfig,
    disabled
  } = t0;
  const classes2 = "h-8 w-8 p-1 rounded-full shadow text-white " + (disabled ? "bg-surface-400 dark:bg-surface-600" : "");
  let t1;
  if ($[0] !== classes2 || $[1] !== disabled || $[2] !== propertyConfig) {
    const defaultPropertyConfig = typeof propertyConfig?.property === "object" ? getDefaultFieldConfig(propertyConfig.property) : void 0;
    const t2 = !disabled ? propertyConfig?.color ?? defaultPropertyConfig?.color ?? "#888" : void 0;
    let t3;
    if ($[4] !== t2) {
      t3 = {
        background: t2
      };
      $[4] = t2;
      $[5] = t3;
    } else {
      t3 = $[5];
    }
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classes2, style: t3, children: propertyConfig?.Icon ? getIconForWidget(propertyConfig, "medium") : getIconForWidget(defaultPropertyConfig, "medium") });
    $[0] = classes2;
    $[1] = disabled;
    $[2] = propertyConfig;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}
function NotFoundPage() {
  const $ = c_1(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-full h-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "m-auto flex items-center flex-col", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", align: "center", gutterBottom: true, children: "Page not found" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { align: "center", gutterBottom: true, children: "This page does not exist or you may not have access to it" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "text", component: Link$2, to: "/", children: "Back to home" })
    ] }) });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
function ConfirmationDialog(t0) {
  const $ = c_1(20);
  const {
    open,
    onAccept,
    onCancel,
    title,
    loading,
    body
  } = t0;
  let t1;
  if ($[0] !== onCancel) {
    t1 = (open_0) => !open_0 ? onCancel() : void 0;
    $[0] = onCancel;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== title) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { variant: "h6", className: "mb-2", children: title });
    $[2] = title;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== body) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { children: body });
    $[4] = body;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] !== onCancel) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "text", onClick: onCancel, autoFocus: true, children: "Cancel" });
    $[6] = onCancel;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  let t5;
  if ($[8] !== loading || $[9] !== onAccept) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingButton, { color: "primary", type: "submit", loading, onClick: onAccept, children: "Ok" });
    $[8] = loading;
    $[9] = onAccept;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  let t6;
  if ($[11] !== t4 || $[12] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions, { children: [
      t4,
      t5
    ] });
    $[11] = t4;
    $[12] = t5;
    $[13] = t6;
  } else {
    t6 = $[13];
  }
  let t7;
  if ($[14] !== open || $[15] !== t1 || $[16] !== t2 || $[17] !== t3 || $[18] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open, onOpenChange: t1, children: [
      t2,
      t3,
      t6
    ] });
    $[14] = open;
    $[15] = t1;
    $[16] = t2;
    $[17] = t3;
    $[18] = t6;
    $[19] = t7;
  } else {
    t7 = $[19];
  }
  return t7;
}
function FireCMSLogo(t0) {
  const $ = c_1(9);
  const {
    width,
    height,
    className,
    style: style2
  } = t0;
  const t1 = width ?? "100%";
  const t2 = height ?? "100%";
  let t3;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsxs("radialGradient", { cx: "28.6213569%", cy: "43.1133328%", fx: "28.6213569%", fy: "43.1133328%", r: "71.5003456%", gradientTransform: "translate(0.286214,0.431133),rotate(3.343450),scale(1.000000,0.996175),translate(-0.286214,-0.431133)", id: "radialGradient-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { stopColor: "#FF5B79", offset: "0%" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { stopColor: "#FA5574", offset: "28.0930803%" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { stopColor: "#EC4C51", offset: "44.7242531%" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { stopColor: "#9543C1", offset: "71.4578165%" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { stopColor: "#3857B3", offset: "100%" })
    ] });
    $[0] = t3;
  } else {
    t3 = $[0];
  }
  let t4;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs("radialGradient", { cx: "53.6205516%", cy: "47.2473036%", fx: "53.6205516%", fy: "47.2473036%", r: "50.8229649%", gradientTransform: "translate(0.536206,0.472473),rotate(90.000000),scale(1.000000,1.206631),translate(-0.536206,-0.472473)", id: "radialGradient-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { stopColor: "#68294F", stopOpacity: "0", offset: "0%" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { stopColor: "#5E2548", stopOpacity: "0.04641108", offset: "75.3503173%" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { stopColor: "#0D060B", stopOpacity: "0.437431709", offset: "100%" })
    ] });
    $[1] = t4;
  } else {
    t4 = $[1];
  }
  let t5;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
      t3,
      t4,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("radialGradient", { cx: "53.8605015%", cy: "48.1990423%", fx: "53.8605015%", fy: "48.1990423%", r: "59.9151549%", gradientTransform: "translate(0.538605,0.481990),rotate(180.000000),scale(1.000000,0.925027),translate(-0.538605,-0.481990)", id: "radialGradient-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { stopColor: "#68294F", stopOpacity: "0", offset: "0%" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { stopColor: "#5E2548", stopOpacity: "0.04641108", offset: "84.0867343%" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { stopColor: "#FF0000", stopOpacity: "0.567324765", offset: "100%" })
      ] })
    ] });
    $[2] = t5;
  } else {
    t5 = $[2];
  }
  let t6;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx("g", { id: "Page-1", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "firecms_logo", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { fill: "url(#radialGradient-1)", cx: "299.5", cy: "299.5", r: "299.5" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { fill: "url(#radialGradient-2)", cx: "299.5", cy: "299.5", r: "299.5" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { fill: "url(#radialGradient-3)", cx: "299.5", cy: "299.5", r: "299.5" })
    ] }) });
    $[3] = t6;
  } else {
    t6 = $[3];
  }
  let t7;
  if ($[4] !== className || $[5] !== style2 || $[6] !== t1 || $[7] !== t2) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: t1, height: t2, viewBox: "0 0 599 599", version: "1.1", style: style2, className, xmlns: "http://www.w3.org/2000/svg", children: [
      t5,
      t6
    ] });
    $[4] = className;
    $[5] = style2;
    $[6] = t1;
    $[7] = t2;
    $[8] = t7;
  } else {
    t7 = $[8];
  }
  return t7;
}
const AppContext = React__default.createContext({
  hasDrawer: false,
  drawerHovered: false,
  drawerOpen: false,
  openDrawer: () => {
    throw new Error("openDrawer not implemented");
  },
  closeDrawer: () => {
    throw new Error("closeDrawer not implemented");
  },
  autoOpenDrawer: false
});
function useApp() {
  return React__default.useContext(AppContext);
}
const DefaultAppBar = function DefaultAppBar2(t0) {
  const $ = c_1(44);
  const {
    title,
    endAdornment,
    startAdornment,
    dropDownActions,
    includeModeToggle: t1,
    className,
    style: style2,
    user: userProp
  } = t0;
  const includeModeToggle = t1 === void 0 ? true : t1;
  const {
    hasDrawer,
    drawerOpen,
    logo
  } = useApp();
  const navigation = useNavigationController();
  const authController = useAuthController();
  const {
    mode,
    toggleMode
  } = useModeController();
  const navigate = useNavigate();
  const largeLayout = useLargeLayout();
  const user = userProp ?? authController.user;
  let avatarComponent;
  if (user) {
    let t22;
    if ($[0] !== user.displayName || $[1] !== user.email) {
      t22 = user?.displayName ? user.displayName[0].toUpperCase() : user?.email ? user.email[0].toUpperCase() : "A";
      $[0] = user.displayName;
      $[1] = user.email;
      $[2] = t22;
    } else {
      t22 = $[2];
    }
    const initial = t22;
    const t32 = user.photoURL ?? void 0;
    let t42;
    if ($[3] !== initial || $[4] !== t32) {
      t42 = /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { src: t32, children: initial });
      $[3] = initial;
      $[4] = t32;
      $[5] = t42;
    } else {
      t42 = $[5];
    }
    avatarComponent = t42;
  } else {
    if (user === void 0 || authController.initialLoading) {
      let t22;
      if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
        t22 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-1 flex justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { className: "w-10 h-10 rounded-full" }) });
        $[6] = t22;
      } else {
        t22 = $[6];
      }
      avatarComponent = t22;
    } else {
      avatarComponent = null;
    }
  }
  const t2 = drawerOpen && largeLayout;
  const t3 = hasDrawer && !(drawerOpen && largeLayout);
  const t4 = drawerOpen && largeLayout;
  let t5;
  if ($[7] !== className || $[8] !== largeLayout || $[9] !== t2 || $[10] !== t3 || $[11] !== t4) {
    t5 = cls("w-full h-16 transition-all ease-in duration-75 absolute top-0 max-w-full overflow-x-auto no-scrollbar", "flex flex-row gap-2 px-4 items-center", {
      "pl-[19rem]": t2,
      "pl-24": t3,
      "z-10": largeLayout,
      "duration-100": t4
    }, className);
    $[7] = className;
    $[8] = largeLayout;
    $[9] = t2;
    $[10] = t3;
    $[11] = t4;
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  let t6;
  if ($[13] !== hasDrawer || $[14] !== logo || $[15] !== navigation || $[16] !== title) {
    t6 = navigation && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mr-8 hidden lg:block", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link$2, { className: "visited:text-inherit visited:dark:text-inherit block", to: navigation?.basePath ?? "/", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row gap-4", children: [
      !hasDrawer && (logo ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: logo, alt: "Logo", className: cls("w-[32px] h-[32px] object-contain") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(FireCMSLogo, { width: "32px", height: "32px" })),
      typeof title === "string" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", noWrap: true, children: title }) : title
    ] }) }) });
    $[13] = hasDrawer;
    $[14] = logo;
    $[15] = navigation;
    $[16] = title;
    $[17] = t6;
  } else {
    t6 = $[17];
  }
  let t7;
  if ($[18] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow" });
    $[18] = t7;
  } else {
    t7 = $[18];
  }
  let t8;
  if ($[19] !== endAdornment) {
    t8 = endAdornment && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: endAdornment });
    $[19] = endAdornment;
    $[20] = t8;
  } else {
    t8 = $[20];
  }
  let t9;
  if ($[21] !== includeModeToggle || $[22] !== mode || $[23] !== toggleMode) {
    t9 = includeModeToggle && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { color: "inherit", "aria-label": "Open drawer", onClick: toggleMode, size: "large", children: mode === "dark" ? /* @__PURE__ */ jsxRuntimeExports.jsx(DarkModeIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(LightModeIcon, {}) });
    $[21] = includeModeToggle;
    $[22] = mode;
    $[23] = toggleMode;
    $[24] = t9;
  } else {
    t9 = $[24];
  }
  let t10;
  if ($[25] !== user) {
    t10 = user && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "px-4 py-2 mb-2", children: [
      user.displayName && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", color: "secondary", children: user.displayName }),
      user.email && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "secondary", children: user.email })
    ] });
    $[25] = user;
    $[26] = t10;
  } else {
    t10 = $[26];
  }
  let t11;
  if ($[27] !== authController || $[28] !== dropDownActions || $[29] !== navigate) {
    t11 = !dropDownActions && /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem, { onClick: async () => {
      await authController.signOut();
      navigate("/");
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(LogoutIcon, {}),
      "Log Out"
    ] });
    $[27] = authController;
    $[28] = dropDownActions;
    $[29] = navigate;
    $[30] = t11;
  } else {
    t11 = $[30];
  }
  let t12;
  if ($[31] !== avatarComponent || $[32] !== dropDownActions || $[33] !== t10 || $[34] !== t11) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Menu, { trigger: avatarComponent, children: [
      t10,
      dropDownActions,
      t11
    ] });
    $[31] = avatarComponent;
    $[32] = dropDownActions;
    $[33] = t10;
    $[34] = t11;
    $[35] = t12;
  } else {
    t12 = $[35];
  }
  let t13;
  if ($[36] !== startAdornment || $[37] !== style2 || $[38] !== t12 || $[39] !== t5 || $[40] !== t6 || $[41] !== t8 || $[42] !== t9) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: style2, className: t5, children: [
      t6,
      startAdornment,
      t7,
      t8,
      t9,
      t12
    ] });
    $[36] = startAdornment;
    $[37] = style2;
    $[38] = t12;
    $[39] = t5;
    $[40] = t6;
    $[41] = t8;
    $[42] = t9;
    $[43] = t13;
  } else {
    t13 = $[43];
  }
  return t13;
};
const buildIdsMap = (value) => value && Array.isArray(value) && value.length > 0 ? value.map((v, index2) => {
  if (!v) return {};
  return {
    [getHashValue(v) + index2]: getRandomId$1()
  };
}).reduce((a2, b) => ({
  ...a2,
  ...b
}), {}) : {};
function ArrayContainer({
  droppableId,
  addLabel,
  value,
  disabled = false,
  buildEntry,
  size: size2 = "medium",
  onInternalIdAdded,
  includeAddButton,
  newDefaultEntry,
  onValueChange,
  className
}) {
  const hasValue = value && Array.isArray(value) && value.length > 0;
  const internalIdsRef = useRef(buildIdsMap(value));
  const [internalIds, setInternalIds] = useState(hasValue ? Object.values(internalIdsRef.current) : []);
  const itemCustomPropsRef = useRef({});
  const updateItemCustomProps = useCallback((internalId, customProps) => {
    itemCustomPropsRef.current[internalId] = customProps;
  }, []);
  useEffect(() => {
    if (hasValue && value && value.length !== internalIds.length) {
      const newInternalIds = value.map((v, index2) => {
        const hashValue = getHashValue(v) + index2;
        if (hashValue in internalIdsRef.current) {
          return internalIdsRef.current[hashValue];
        } else {
          const newInternalId = getRandomId$1();
          internalIdsRef.current[hashValue] = newInternalId;
          return newInternalId;
        }
      });
      setInternalIds(newInternalIds);
    }
  }, [hasValue, internalIds.length, value]);
  const insertInEnd = (e2) => {
    e2.preventDefault();
    if (disabled) return;
    const id2 = getRandomId$1();
    const newIds = [...internalIds, id2];
    if (onInternalIdAdded) onInternalIdAdded(id2);
    setInternalIds(newIds);
    onValueChange([...value ?? [], newDefaultEntry]);
  };
  const remove = (index_0) => {
    const newIds_0 = [...internalIds];
    newIds_0.splice(index_0, 1);
    setInternalIds(newIds_0);
    onValueChange(value.filter((_, i) => i !== index_0));
  };
  const copy2 = (index_1) => {
    const id_0 = getRandomId$1();
    const copyingItem = value[index_1];
    const newIds_1 = [...internalIds.splice(0, index_1 + 1), id_0, ...internalIds.splice(index_1 + 1, internalIds.length - index_1 - 1)];
    if (onInternalIdAdded) onInternalIdAdded(id_0);
    setInternalIds(newIds_1);
    onValueChange([...value.slice(0, index_1 + 1), copyingItem, ...value.slice(index_1 + 1)]);
  };
  const addInIndex = (index_2) => {
    const id_1 = getRandomId$1();
    const newIds_2 = [...internalIds.splice(0, index_2), id_1, ...internalIds.slice(index_2)];
    if (onInternalIdAdded) onInternalIdAdded(id_1);
    setInternalIds(newIds_2);
    onValueChange([...value.slice(0, index_2), newDefaultEntry, ...value.slice(index_2)]);
  };
  const onDragEnd2 = (result) => {
    if (!result.destination) {
      return;
    }
    const sourceIndex = result.source.index;
    const destinationIndex = result.destination.index;
    const newIds_3 = [...internalIds];
    const temp = newIds_3[sourceIndex];
    newIds_3[sourceIndex] = newIds_3[destinationIndex];
    newIds_3[destinationIndex] = temp;
    setInternalIds(newIds_3);
    onValueChange(arrayMove(value, sourceIndex, destinationIndex));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DragDropContext, { onDragEnd: onDragEnd2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectedDroppable$1, { droppableId, renderClone: (provided, snapshot, rubric) => {
    const index_3 = rubric.source.index;
    const internalId_0 = internalIds[index_3];
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayContainerItem, { provided, internalId: internalId_0, index: index_3, size: size2, disabled, buildEntry, remove, copy: copy2, isDragging: snapshot.isDragging, storedProps: itemCustomPropsRef.current[internalId_0], updateItemCustomProps, addInIndex });
  }, children: (droppableProvided, droppableSnapshot) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cls("space-y-1", className), ...droppableProvided.droppableProps, ref: droppableProvided.innerRef, children: [
    hasValue && internalIds.map((internalId_1, index_4) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PublicDraggable, { draggableId: `array_field_${internalId_1}`, isDragDisabled: disabled, index: index_4, children: (provided_0, snapshot_0) => /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayContainerItem, { provided: provided_0, internalId: internalId_1, index: index_4, size: size2, disabled, buildEntry, remove, copy: copy2, isDragging: snapshot_0.isDragging, storedProps: itemCustomPropsRef.current[internalId_1], updateItemCustomProps, addInIndex }) }, `array_field_${internalId_1}`);
    }),
    droppableProvided.placeholder,
    includeAddButton && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "py-4 justify-center text-left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "text", size: size2 === "small" ? "small" : "medium", color: "primary", disabled, startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon, {}), onClick: insertInEnd, children: addLabel ?? "Add" }) })
  ] }) }) });
}
function ArrayContainerItem(t0) {
  const $ = c_1(28);
  const {
    provided,
    index: index2,
    internalId,
    size: size2,
    disabled,
    buildEntry,
    remove,
    addInIndex,
    copy: copy2,
    isDragging: isDragging2,
    storedProps,
    updateItemCustomProps
  } = t0;
  const t1 = provided.innerRef;
  const t2 = provided.draggableProps;
  const t3 = provided.draggableProps.style;
  const t4 = `${!isDragging2 ? "hover:bg-surface-accent-50 dark:hover:bg-surface-800 dark:hover:bg-opacity-20" : ""} rounded-md opacity-100`;
  let t5;
  if ($[0] !== internalId || $[1] !== updateItemCustomProps) {
    t5 = (props) => updateItemCustomProps(internalId, props);
    $[0] = internalId;
    $[1] = updateItemCustomProps;
    $[2] = t5;
  } else {
    t5 = $[2];
  }
  let t6;
  if ($[3] !== buildEntry || $[4] !== index2 || $[5] !== internalId || $[6] !== isDragging2 || $[7] !== storedProps || $[8] !== t5) {
    t6 = buildEntry({
      index: index2,
      internalId,
      isDragging: isDragging2,
      storedProps,
      storeProps: t5
    });
    $[3] = buildEntry;
    $[4] = index2;
    $[5] = internalId;
    $[6] = isDragging2;
    $[7] = storedProps;
    $[8] = t5;
    $[9] = t6;
  } else {
    t6 = $[9];
  }
  let t7;
  if ($[10] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow w-[calc(100%-48px)] text-text-primary dark:text-text-primary-dark", children: t6 });
    $[10] = t6;
    $[11] = t7;
  } else {
    t7 = $[11];
  }
  const t8 = size2 === "small" ? "row" : "column";
  let t9;
  if ($[12] !== addInIndex || $[13] !== copy2 || $[14] !== disabled || $[15] !== index2 || $[16] !== provided || $[17] !== remove || $[18] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayItemOptions, { direction: t8, disabled, remove, index: index2, provided, addInIndex, copy: copy2 });
    $[12] = addInIndex;
    $[13] = copy2;
    $[14] = disabled;
    $[15] = index2;
    $[16] = provided;
    $[17] = remove;
    $[18] = t8;
    $[19] = t9;
  } else {
    t9 = $[19];
  }
  let t10;
  if ($[20] !== t7 || $[21] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start", children: [
      t7,
      t9
    ] });
    $[20] = t7;
    $[21] = t9;
    $[22] = t10;
  } else {
    t10 = $[22];
  }
  let t11;
  if ($[23] !== provided.draggableProps || $[24] !== provided.innerRef || $[25] !== t10 || $[26] !== t4) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: t1, ...t2, style: t3, className: t4, children: t10 });
    $[23] = provided.draggableProps;
    $[24] = provided.innerRef;
    $[25] = t10;
    $[26] = t4;
    $[27] = t11;
  } else {
    t11 = $[27];
  }
  return t11;
}
function ArrayItemOptions({
  direction: direction2,
  disabled,
  remove,
  index: index2,
  provided,
  copy: copy2,
  addInIndex
}) {
  const [menuOpen, setMenuOpen] = useState(false);
  const iconRef = React__default.useRef(null);
  useOutsideAlerter(iconRef, () => setMenuOpen(false));
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `pl-2 pt-1 pb-1 flex ${direction2 === "row" ? "flex-row-reverse" : "flex-col"} items-center`, ref: iconRef, ...provided.dragHandleProps, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip, { delayDuration: 400, open: menuOpen ? false : void 0, side: direction2 === "column" ? "left" : void 0, title: "Drag to move. Click for more options", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { size: "small", disabled, onClick: (e2) => {
      e2.preventDefault();
      setMenuOpen(true);
    }, onDragStart: (e_0) => {
      setMenuOpen(false);
    }, className: `cursor-${disabled ? "inherit" : "grab"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(HandleIcon, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Menu, { portalContainer: iconRef.current, open: menuOpen, trigger: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { tabIndex: -1 }), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem, { dense: true, onClick: (e_1) => {
        setMenuOpen(false);
        remove(index2);
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(RemoveIcon, { size: "small" }),
        "Remove"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem, { dense: true, onClick: () => {
        setMenuOpen(false);
        copy2(index2);
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ContentCopyIcon, { size: "small" }),
        "Copy"
      ] }),
      addInIndex && /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem, { dense: true, onClick: () => {
        setMenuOpen(false);
        addInIndex(index2);
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardArrowUpIcon, { size: "small" }),
        "Add on top"
      ] }),
      addInIndex && /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem, { dense: true, onClick: () => {
        setMenuOpen(false);
        addInIndex(index2 + 1);
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardArrowDownIcon, { size: "small" }),
        "Add below"
      ] })
    ] })
  ] }) });
}
function arrayMove(value, sourceIndex, destinationIndex) {
  const result = Array.from(value);
  const [removed] = result.splice(sourceIndex, 1);
  result.splice(destinationIndex, 0, removed);
  return result;
}
function getRandomId$1() {
  return Math.floor(Math.random() * Math.floor(Number.MAX_SAFE_INTEGER));
}
function ReferenceWidget({
  name,
  multiselect = false,
  path,
  disabled,
  value,
  onReferenceSelected,
  onMultipleReferenceSelected,
  previewProperties,
  forceFilter,
  size: size2,
  className,
  includeId,
  includeEntityLink
}) {
  const navigationController = useNavigationController();
  const collection = useMemo(() => {
    return navigationController.getCollection(path);
  }, [path, navigationController.getCollection]);
  const onSingleEntitySelected = useCallback((entity) => {
    if (disabled) return;
    if (onReferenceSelected) {
      const reference2 = entity ? getReferenceFrom(entity) : null;
      onReferenceSelected?.({
        reference: reference2,
        entity
      });
    }
  }, [disabled, onReferenceSelected]);
  const onMultipleEntitiesSelected = useCallback((entities) => {
    if (disabled) return;
    if (onMultipleReferenceSelected) {
      const references = entities ? entities.map((e2) => getReferenceFrom(e2)) : null;
      onMultipleReferenceSelected({
        references,
        entities
      });
    }
  }, [disabled, onReferenceSelected]);
  const referenceDialogController = useReferenceDialog({
    multiselect,
    path,
    collection,
    onSingleEntitySelected,
    onMultipleEntitiesSelected,
    forceFilter
  });
  useCallback((e_0) => {
    e_0.stopPropagation();
    if (multiselect) {
      onMultipleEntitiesSelected([]);
    } else {
      onSingleEntitySelected(null);
    }
  }, [onReferenceSelected]);
  let child;
  const onEntryClick = () => {
    if (disabled) return;
    referenceDialogController.open();
  };
  if (Array.isArray(value)) {
    child = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-4", children: value.map((ref, index2) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ReferencePreview, { onClick: onEntryClick, reference: ref, disabled, previewProperties, size: size2, includeId, includeEntityLink }, `reference_preview_${index2}`);
    }) });
  } else if (value?.isEntityReference && value?.isEntityReference()) {
    child = /* @__PURE__ */ jsxRuntimeExports.jsx(ReferencePreview, { reference: value, onClick: onEntryClick, disabled, previewProperties, size: size2, includeId, includeEntityLink });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cls("text-sm font-medium", "min-w-80 flex flex-col gap-4", "relative transition-colors duration-200 ease-in rounded font-medium", disabled ? "bg-opacity-50" : "hover:bg-opacity-75", "text-opacity-50 dark:text-white dark:text-opacity-50", className), children: [
    child,
    !value && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "justify-center text-left", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { variant: "outlined", color: "primary", disabled, onClick: onEntryClick, children: [
      "Edit ",
      name
    ] }) })
  ] });
}
const UPDATE_SEARCH_INDEX_WAIT_MS = 220;
function SearchIconsView(t0) {
  const $ = c_1(14);
  const {
    selectedIcon: t1,
    onIconSelected
  } = t0;
  const selectedIcon = t1 === void 0 ? "" : t1;
  const [keys2, setKeys] = React__default.useState(null);
  const [query, setQuery] = React__default.useState("");
  let t2;
  let t3;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = debounce((value) => {
      if (!value || value === "") {
        setKeys(null);
      } else {
        const searchResult = iconsSearch.search(value);
        const limited = searchResult.slice(0, 50);
        setKeys(limited.map(_temp$d));
      }
    }, UPDATE_SEARCH_INDEX_WAIT_MS);
    $[0] = t3;
  } else {
    t3 = $[0];
  }
  t2 = t3;
  const updateSearchResults = t2;
  let t4;
  let t5;
  if ($[1] !== query) {
    t4 = () => {
      updateSearchResults(query);
      return () => {
        updateSearchResults.clear();
      };
    };
    t5 = [query, updateSearchResults];
    $[1] = query;
    $[2] = t4;
    $[3] = t5;
  } else {
    t4 = $[2];
    t5 = $[3];
  }
  React__default.useEffect(t4, t5);
  const icons = keys2 === null ? coolIconKeys : keys2;
  let t6;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(SearchBar, { autoFocus: false, innerClassName: "w-full sticky top-0 z-10", onTextSearch: (value_0) => setQuery(value_0 ?? ""), placeholder: "Search for more icons" });
    $[4] = t6;
  } else {
    t6 = $[4];
  }
  let t7;
  if ($[5] !== icons || $[6] !== onIconSelected || $[7] !== selectedIcon) {
    let t82;
    if ($[9] !== onIconSelected || $[10] !== selectedIcon) {
      t82 = (icon) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: icon, asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { shape: "square", toggled: selectedIcon === icon, onClick: onIconSelected ? () => onIconSelected(icon) : void 0, className: "box-content m-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { iconKey: icon, size: 24 }) }) }, icon);
      $[9] = onIconSelected;
      $[10] = selectedIcon;
      $[11] = t82;
    } else {
      t82 = $[11];
    }
    t7 = icons.map(t82);
    $[5] = icons;
    $[6] = onIconSelected;
    $[7] = selectedIcon;
    $[8] = t7;
  } else {
    t7 = $[8];
  }
  let t8;
  if ($[12] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t6,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex max-w-full flex-wrap mt-4", children: t7 })
    ] });
    $[12] = t7;
    $[13] = t8;
  } else {
    t8 = $[13];
  }
  return t8;
}
function _temp$d(e2) {
  return e2.item.key;
}
function FieldCaption(t0) {
  const $ = c_1(3);
  const {
    error,
    children
  } = t0;
  if (!children) {
    return null;
  }
  const t1 = error ? "error" : "secondary";
  let t2;
  if ($[0] !== children || $[1] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: t1, className: "ml-3.5 mt-0.5", children });
    $[0] = children;
    $[1] = t1;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  return t2;
}
function useReferenceDialog(referenceDialogProps) {
  const $ = c_1(9);
  const navigation = useNavigationController();
  const sideDialogsController = useSideDialogsController();
  let t0;
  if ($[0] !== navigation || $[1] !== referenceDialogProps || $[2] !== sideDialogsController) {
    t0 = () => {
      if (referenceDialogProps.path) {
        let usedCollection = referenceDialogProps.collection;
        if (!usedCollection) {
          usedCollection = navigation.getCollection(referenceDialogProps.path);
        }
        if (!usedCollection) {
          throw Error("Not able to resolve the collection in useReferenceDialog. Make sure a collection is registered in path " + referenceDialogProps.path);
        }
        sideDialogsController.open({
          key: `reference_${referenceDialogProps.path}`,
          component: /* @__PURE__ */ jsxRuntimeExports.jsx(ReferenceSelectionTable, { collection: usedCollection, ...referenceDialogProps }),
          width: "90vw",
          onClose: () => {
            referenceDialogProps.onClose?.();
          }
        });
      } else {
        throw Error("useReferenceDialog: You are trying to open a reference dialog, but have not declared the `path`");
      }
    };
    $[0] = navigation;
    $[1] = referenceDialogProps;
    $[2] = sideDialogsController;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  const open = t0;
  let t1;
  if ($[4] !== sideDialogsController) {
    t1 = () => {
      sideDialogsController.close();
    };
    $[4] = sideDialogsController;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  const close2 = t1;
  let t2;
  if ($[6] !== close2 || $[7] !== open) {
    t2 = {
      open,
      close: close2
    };
    $[6] = close2;
    $[7] = open;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  return t2;
}
const fireCMSLogo = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAASAAAAEgARslrPgAAB9pJREFUWMONl12obVUVx39jzLk+9j7nHq9y1QT1qpcbSIaXQFGs24PQl3HroSQyqHwJFJF6qaceCsqQoJdELHoIC6EeJCSKsi/TFLGozGsKXksljRLxnrP3WmvOOUYPa+19zsmPWpux5pxrzTX///Exx5hb+B/X1y+/nuIlVKF5m0v1YbQ55tIcKTQXFerNQkumOZ1oTiXCqUH8saR+74L8ZIWWux7+7JuuL2/04s5jJyhWQlXV71KtbhCtr1WtD6s0KlrjNBRaEi3JGzpv6bymQ0sn9mwv9otB7Ls7kn9Xo+U7D9z8/xG4+bz3cs35SjE/HEK8NWr8RBOrs+tQUUlEtAYaijRkbxmY0fuMzucsfcbSWnZQtiWxJL3Uid09iH0jIM8/1f+d3/zuS29M4PvHrmG+cZA8dMdjiLfNYrx6owrMVKlVUQkgkeI1iYbBJ3A2WPpKNtnx+UQisy29L0gPDGKfrwkPn2bJPfd/Zo0ZVp0fvOOdnLGxheX+A/Mq3nGwqS8/q645o4psxkgbhFqdSgqVJKIkghgqjuDoWh+dlm1AI0gUC3o4C9d04idbmZ06euQDPPHMj3YJ3HnkrZx98Fys2PFZ1dxxsJkdPbOecaBqmcWGqBVBIkEiKkoQJ5IJJBTbY8aRgBMwjxgVJoJJwDScnYUrOy2PBamfv/CS4zz9zE+IAIfPuQQzPzyrmq9u1e3RM+qWeaipNCCiE4DjbjgF94xZQj2htpjeK84ImqlIUpO9JllgEKgJDFpfOoh8paN8chbOeQ4g/OTq97PdLXSz3fjiVjO7/sx6g804ow41QWuCrjQPBB3bkZQgAkpBJOMojmIEjIgRKV6RpaYIZHGKQlK5OIv0L8bul8eOfsxjDJGD8613z6rmhq1qxkY1o9YKFUFEEED2xqoE1MNoWgPBwQZMl2SrSbQM9NQyUMlA5S3Rlcqd6E50RdRvPMvn9yE8qP9+9WWtQvXxzdic8xrwPaJrUYJGoq4sVBM1Ukuiln4UBipJVJrGoHUhrARB0XMQ/cizbSd61uaZlzUhXjuvWmqt9oOyAmUPEabnkSDV2j0Rp2YgksZdQpoCtRBwAiN4cKYdw4m3pNnbY9Tw4SZUh9tQEda+ld1WpmThgoivU8fYDbgEggRcleiZ6BOoFNRXLQQX1Eelggsgh8GPx6DhWB2iRgkj2OTuVX8dBzJtMx93BAKK4hIwUUSEID4BGspecWTfDwSCw+UxqByJoqPf9+xmYWQg7H3u+5Poyk3o5BZDxRBxxH29fdkF3YcBXKHgF+m+hLxn4OvbnnbPzMkjsm/+f5cXec2ye6ZfpO6+OX7pE8TqPj1zcN/7Zu8CDm44Bu6skrKjuOs0FlxWCJNMYxMOqLlR3DAvsAKaZo6t7+u7r6nhjN/5RKIQKESKhykhjeIINgJi+0m4Fiuns2WKZQybtJ2AfAWzGu/ayt0wz5gXimeKQyKSPI4kiCMhDxSgyLiOiY9kxnW2NVs+1ZeBbAmzhLmtgd0d8z1k1mIUTxQbKD5gnkmuDN6QvCF5TaIie0UmkIU1id3WcfwZHUo61eWB3gayDdOiZR+JXUuMWmcbyGWcny2RzOi8obeWwRsGrxm8JlGPBHCyOJmpJkwkHHs09pnfL1L60KLqtBKZtprhU+lVmSq9+xRsBfOMW6L4QLFM7zWdz+l8Ru8tA+10YKlJIiSxkcC6dQqlmJc/xaHIvTuZT7UpHalFUHEqL6iGsfKtM8FEzMdy7J4oXui9mk5CczpGErtEKgacQUZJE3gSwzw/i+dfx2G7e6IcOPALCXIkakGkYx4iwceyq+uENPp+RSI7DN7Q+5ylb7JgJLH0+XRGbOlRerWJwNgmnOwJ83Tvq/7KX2KZb1nJfnfp5YRoda7hFC/MQyGI7Mteow2E4pHkDT2zyfS758HV4bSjolOjF2PYS4KBbN2L5vmHZ7DpsWQnDsvfLj1+Lwufy9LSO2y5M1Mnik8OEJxAoSJRk7xhoKX3+URiztI3WPgGS2/p1OnE6CcSvRQGH+htQfH07dPSP7Lp9ajcNy+9DnG/oMT67qqZHz/QtGxVyjworQqVCIjiPiaaTD1ttZZ+fTIeCXQ+Y6HCQm0tO5LYpmfHlyy9/1nCPi3ICw/99JbxUHrdvxr6Q4depdhTfeGapVeH+imKxwhv6ZnR+5zeN0aNGU2+ZIPON0cX0LBQYSnGQgsLSSzoWdiCHVvQ2fLP2fMtwf2vDz50K6TpVPxj/sn7Ni5iu9l6Tof+yd78yoWFQ0uvWYvVLK1h6e34B8RnY9DZnIW3LAijxpLYkZ6Fd+z4km3bYcd2WNry8ezppsZ5ZMd2+MfTv3xtjbr9/PfwyoFDzPvtq7I2t+Vq/m6pt4hxThVaojao1CANRkORmkwkiTCI00thKYWOzJJR+6V1JE8/z2JfqGgfW9jLPPLg7a9Xe8frHs7j5MVXESxfmLS5KYXmxhQ3z/a4icQNRFtEGlwjJkoRIamTmIKNTE+it57kw0sF+1ah3CkSXkiPf42Htl+3WL/2+vIFJ6ishJ3QXD1o9dEhVCcGbS7ModUcakwrigaKChkoYmQK2XMp5L8V/F7DfuDePYrEcv8f7npdnDcksEvkg9RewquhuayTcHzQeCyJXpFVD2fRzSxCFtkuwqks8mjB/ujYr9y6k0gs9528503X/w/F3eUgyIBI4wAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0wNS0xMFQxOToyODozMyswMDowMEzeSx4AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMDUtMTBUMTk6Mjg6MzMrMDA6MDA9g/OiAAAARnRFWHRzb2Z0d2FyZQBJbWFnZU1hZ2ljayA2LjcuOC05IDIwMTQtMDUtMTIgUTE2IGh0dHA6Ly93d3cuaW1hZ2VtYWdpY2sub3Jn3IbtAAAAABh0RVh0VGh1bWI6OkRvY3VtZW50OjpQYWdlcwAxp/+7LwAAABh0RVh0VGh1bWI6OkltYWdlOjpoZWlnaHQAMTkyDwByhQAAABd0RVh0VGh1bWI6OkltYWdlOjpXaWR0aAAxOTLTrCEIAAAAGXRFWHRUaHVtYjo6TWltZXR5cGUAaW1hZ2UvcG5nP7JWTgAAABd0RVh0VGh1bWI6Ok1UaW1lADE2MjA2NzQ5MTMk8oswAAAAD3RFWHRUaHVtYjo6U2l6ZQAwQkKUoj7sAAAAVnRFWHRUaHVtYjo6VVJJAGZpbGU6Ly8vbW50bG9nL2Zhdmljb25zLzIwMjEtMDUtMTAvOGIxNDNhYjgwODhkMjBlZThkYmUzOTFhN2NkNmQ3NmQuaWNvLnBuZ9msgG0AAAAASUVORK5CYII=\n";
function useBrowserTitleAndIcon(name, logo) {
  const $ = c_1(4);
  let t0;
  let t1;
  if ($[0] !== logo || $[1] !== name) {
    t0 = () => {
      if (document) {
        document.title = `${name} - FireCMS`;
        let link = document.querySelector("link[rel~='icon']");
        if (!link) {
          link = document.createElement("link");
          link.rel = "icon";
          document.getElementsByTagName("head")[0].appendChild(link);
        }
        link.href = logo ?? fireCMSLogo;
      }
    };
    t1 = [name, logo];
    $[0] = logo;
    $[1] = name;
    $[2] = t0;
    $[3] = t1;
  } else {
    t0 = $[2];
    t1 = $[3];
  }
  useEffect(t0, t1);
}
function getParentReferencesFromPath(props) {
  const {
    path,
    collections = [],
    currentFullPath
  } = props;
  const subpaths = removeInitialAndTrailingSlashes(path).split("/");
  const subpathCombinations = getCollectionPathsCombinations(subpaths);
  const result = [];
  for (let i = 0; i < subpathCombinations.length; i++) {
    const subpathCombination = subpathCombinations[i];
    const collection = collections && collections.find((entry) => entry.id === subpathCombination || entry.path === subpathCombination);
    if (collection) {
      const pathOrAlias = collection.id ?? collection.path;
      const collectionPath = currentFullPath && currentFullPath.length > 0 ? currentFullPath + "/" + pathOrAlias : pathOrAlias;
      const restOfThePath = removeInitialAndTrailingSlashes(removeInitialAndTrailingSlashes(path).replace(subpathCombination, ""));
      const nextSegments = restOfThePath.length > 0 ? restOfThePath.split("/") : [];
      if (nextSegments.length > 0) {
        const entityId = nextSegments[0];
        const fullPath = collectionPath + "/" + entityId;
        result.push(new EntityReference(entityId, collectionPath));
        if (nextSegments.length > 1) {
          const newPath = nextSegments.slice(1).join("/");
          if (!collection) {
            throw Error("collection not found resolving path: " + collection);
          }
          if (collection.subcollections) {
            result.push(...getParentReferencesFromPath({
              path: newPath,
              collections: collection.subcollections,
              currentFullPath: fullPath
            }));
          }
        }
      }
      break;
    }
  }
  return result;
}
const DEFAULT_BASE_PATH = "/";
const DEFAULT_COLLECTION_PATH = "/c";
function useBuildNavigationController(props) {
  const {
    basePath = DEFAULT_BASE_PATH,
    baseCollectionPath = DEFAULT_COLLECTION_PATH,
    authController,
    collections: collectionsProp,
    collectionPermissions,
    views: viewsProp,
    adminViews: adminViewsProp,
    viewsOrder,
    userConfigPersistence,
    dataSourceDelegate,
    injectCollections
  } = props;
  const collectionsRef = useRef();
  const viewsRef = useRef();
  const adminViewsRef = useRef();
  const [initialised, setInitialised] = useState(false);
  const [topLevelNavigation, setTopLevelNavigation] = useState(void 0);
  const [navigationLoading, setNavigationLoading] = useState(true);
  const [navigationLoadingError, setNavigationLoadingError] = useState(void 0);
  const cleanBasePath = removeInitialAndTrailingSlashes(basePath);
  const cleanBaseCollectionPath = removeInitialAndTrailingSlashes(baseCollectionPath);
  const homeUrl = cleanBasePath ? `/${cleanBasePath}` : "/";
  const fullCollectionPath = cleanBasePath ? `/${cleanBasePath}/${cleanBaseCollectionPath}` : `/${cleanBaseCollectionPath}`;
  const buildCMSUrlPath = useCallback((path) => cleanBasePath ? `/${cleanBasePath}/${encodePath(path)}` : `/${encodePath(path)}`, [cleanBasePath]);
  const buildUrlCollectionPath = useCallback((path_0) => `${removeInitialAndTrailingSlashes(baseCollectionPath)}/${encodePath(path_0)}`, [baseCollectionPath]);
  const computeTopNavigation = useCallback((collections, views, adminViews, viewsOrder_0) => {
    let navigationEntries = [...(collections ?? []).map((collection) => !collection.hideFromNavigation ? {
      url: buildUrlCollectionPath(collection.id ?? collection.path),
      type: "collection",
      name: collection.name.trim(),
      path: collection.id ?? collection.path,
      collection,
      description: collection.description?.trim(),
      group: getGroup(collection)
    } : void 0).filter(Boolean), ...(views ?? []).map((view) => !view.hideFromNavigation ? {
      url: buildCMSUrlPath(Array.isArray(view.path) ? view.path[0] : view.path),
      name: view.name.trim(),
      type: "view",
      path: view.path,
      view,
      description: view.description?.trim(),
      group: getGroup(view)
    } : void 0).filter(Boolean), ...(adminViews ?? []).map((view_0) => !view_0.hideFromNavigation ? {
      url: buildCMSUrlPath(Array.isArray(view_0.path) ? view_0.path[0] : view_0.path),
      name: view_0.name.trim(),
      type: "admin",
      path: view_0.path,
      view: view_0,
      description: view_0.description?.trim(),
      group: "Admin"
    } : void 0).filter(Boolean)];
    navigationEntries = navigationEntries.sort((a2, b) => {
      if (a2.group !== "Views" && a2.group !== "Admin" && (b.group === "Views" || b.group === "Admin")) {
        return -1;
      }
      if (b.group !== "Views" && b.group !== "Admin" && (a2.group === "Views" || a2.group === "Admin")) {
        return 1;
      }
      if (a2.group === "Admin" && b.group !== "Admin") {
        return 1;
      }
      if (a2.group !== "Admin" && b.group === "Admin") {
        return -1;
      }
      if (a2.group === "Views" && b.group !== "Views") {
        return -1;
      }
      if (a2.group !== "Views" && b.group === "Views") {
        return 1;
      }
      return 0;
    });
    if (viewsOrder_0) {
      navigationEntries = navigationEntries.sort((a_0, b_0) => {
        const aIndex = viewsOrder_0.indexOf(a_0.path);
        const bIndex = viewsOrder_0.indexOf(b_0.path);
        if (aIndex === -1 && bIndex === -1) {
          return 0;
        }
        if (aIndex === -1) {
          return 1;
        }
        if (bIndex === -1) {
          return -1;
        }
        return aIndex - bIndex;
      });
    }
    const groups = Object.values(navigationEntries).map((e2) => e2.group).filter(Boolean).filter((value, index2, array2) => array2.indexOf(value) === index2);
    return {
      navigationEntries,
      groups
    };
  }, [buildCMSUrlPath, buildUrlCollectionPath]);
  const refreshNavigation = useCallback(async () => {
    if (authController.initialLoading) return;
    console.debug("Refreshing navigation");
    try {
      const [resolvedCollections = [], resolvedViews, resolvedAdminViews = []] = await Promise.all([resolveCollections(collectionsProp, collectionPermissions, authController, dataSourceDelegate, injectCollections), resolveCMSViews(viewsProp, authController, dataSourceDelegate), resolveCMSViews(adminViewsProp, authController, dataSourceDelegate)]);
      let shouldUpdateTopLevelNav = false;
      if (!areCollectionListsEqual(collectionsRef.current ?? [], resolvedCollections)) {
        collectionsRef.current = resolvedCollections;
        console.log("Collections have changed", resolvedCollections);
        shouldUpdateTopLevelNav = true;
      }
      if (collectionsRef.current === void 0) {
        collectionsRef.current = resolvedCollections;
        shouldUpdateTopLevelNav = true;
      }
      if (!equal(viewsRef.current, resolvedViews)) {
        viewsRef.current = resolvedViews;
        shouldUpdateTopLevelNav = true;
      }
      if (!equal(adminViewsRef.current, resolvedAdminViews)) {
        adminViewsRef.current = resolvedAdminViews;
        shouldUpdateTopLevelNav = true;
      }
      const computedTopLevelNav = computeTopNavigation(resolvedCollections, resolvedViews, resolvedAdminViews, viewsOrder);
      if (shouldUpdateTopLevelNav && !equal(topLevelNavigation, computedTopLevelNav)) {
        setTopLevelNavigation(computedTopLevelNav);
      }
    } catch (e_0) {
      console.error(e_0);
      setNavigationLoadingError(e_0);
    }
    if (navigationLoading) setNavigationLoading(false);
    if (!initialised) setInitialised(true);
  }, [collectionsProp, collectionPermissions, authController.user, authController.initialLoading, viewsProp, adminViewsProp, computeTopNavigation, injectCollections]);
  useEffect(() => {
    refreshNavigation();
  }, [refreshNavigation]);
  const getCollection = useCallback((idOrPath, includeUserOverride = false) => {
    const collections_0 = collectionsRef.current;
    if (!collections_0) return void 0;
    const baseCollection = getCollectionByPathOrId(removeInitialAndTrailingSlashes(idOrPath), collections_0);
    const userOverride = includeUserOverride ? userConfigPersistence?.getCollectionConfig(idOrPath) : void 0;
    const overriddenCollection = baseCollection ? mergeDeep(baseCollection, userOverride ?? {}) : void 0;
    let result = overriddenCollection;
    if (overriddenCollection) {
      const subcollections = overriddenCollection.subcollections;
      const callbacks = overriddenCollection.callbacks;
      const permissions = overriddenCollection.permissions;
      result = {
        ...result,
        subcollections: result?.subcollections ?? subcollections,
        callbacks: result?.callbacks ?? callbacks,
        permissions: result?.permissions ?? permissions
      };
    }
    if (!result) return void 0;
    return {
      ...overriddenCollection,
      ...result
    };
  }, [userConfigPersistence]);
  const getCollectionFromPaths = useCallback((pathSegments) => {
    const collections_1 = collectionsRef.current;
    if (collections_1 === void 0) throw Error("getCollectionFromPaths: Collections have not been initialised yet");
    let currentCollections = [...collections_1 ?? []];
    for (let i = 0; i < pathSegments.length; i++) {
      const pathSegment = pathSegments[i];
      const collection_0 = currentCollections.find((c2) => c2.id === pathSegment || c2.path === pathSegment);
      if (!collection_0) return void 0;
      currentCollections = collection_0.subcollections;
      if (i === pathSegments.length - 1) return collection_0;
    }
    return void 0;
  }, []);
  const getCollectionFromIds = useCallback((ids) => {
    const collections_2 = collectionsRef.current;
    if (collections_2 === void 0) throw Error("getCollectionFromIds: Collections have not been initialised yet");
    let currentCollections_0 = [...collections_2 ?? []];
    for (let i_0 = 0; i_0 < ids.length; i_0++) {
      const id2 = ids[i_0];
      const collection_1 = currentCollections_0.find((c_0) => c_0.id === id2);
      if (!collection_1) return void 0;
      currentCollections_0 = collection_1.subcollections;
      if (i_0 === ids.length - 1) return collection_1;
    }
    return void 0;
  }, []);
  const isUrlCollectionPath = useCallback((path_1) => removeInitialAndTrailingSlashes(path_1 + "/").startsWith(removeInitialAndTrailingSlashes(fullCollectionPath) + "/"), [fullCollectionPath]);
  const urlPathToDataPath = useCallback((path_2) => {
    if (path_2.startsWith(fullCollectionPath)) return path_2.replace(fullCollectionPath, "");
    throw Error("Expected path starting with " + fullCollectionPath);
  }, [fullCollectionPath]);
  const buildUrlEditCollectionPath = useCallback(({
    path: path_3
  }) => {
    return `s/edit/${encodePath(path_3)}`;
  }, []);
  const resolveAliasesFrom = useCallback((path_4) => {
    const collections_3 = collectionsRef.current ?? [];
    return resolveCollectionPathIds(path_4, collections_3);
  }, []);
  const getAllParentReferencesForPath = useCallback((path_5) => {
    const collections_4 = collectionsRef.current ?? [];
    return getParentReferencesFromPath({
      path: path_5,
      collections: collections_4
    });
  }, []);
  const getParentCollectionIds = useCallback((path_6) => {
    const strings = path_6.split("/");
    const oddPathSegments = strings.filter((_, i_1) => i_1 % 2 === 0);
    oddPathSegments.pop();
    const result_0 = [];
    for (let i_2 = 1; i_2 <= oddPathSegments.length; i_2++) {
      result_0.push(oddPathSegments.slice(0, i_2));
    }
    return result_0.map((r2) => getCollectionFromPaths(r2)?.id).filter(Boolean);
  }, [getAllParentReferencesForPath]);
  const convertIdsToPaths = useCallback((ids_0) => {
    const collections_5 = collectionsRef.current;
    let currentCollections_1 = collections_5;
    const paths = [];
    for (let i_3 = 0; i_3 < ids_0.length; i_3++) {
      const id_0 = ids_0[i_3];
      const collection_2 = currentCollections_1.find((c_12) => c_12.id === id_0);
      if (!collection_2) throw Error(`Collection with id ${id_0} not found`);
      paths.push(collection_2.path);
      currentCollections_1 = collection_2.subcollections;
    }
    return paths;
  }, [getCollectionFromIds]);
  return {
    collections: collectionsRef.current,
    views: viewsRef.current,
    adminViews: adminViewsRef.current,
    loading: !initialised || navigationLoading,
    navigationLoadingError,
    homeUrl,
    basePath,
    baseCollectionPath,
    initialised,
    getCollection,
    getCollectionFromPaths,
    getCollectionFromIds,
    isUrlCollectionPath,
    urlPathToDataPath,
    buildUrlCollectionPath,
    buildUrlEditCollectionPath,
    buildCMSUrlPath,
    resolveAliasesFrom,
    topLevelNavigation,
    refreshNavigation,
    getParentReferencesFromPath: getAllParentReferencesForPath,
    getParentCollectionIds,
    convertIdsToPaths
  };
}
function getSidePanelKey(path, entityId) {
  if (entityId) return `${removeInitialAndTrailingSlashes(path)}/${removeInitialAndTrailingSlashes(entityId)}`;
  else return removeInitialAndTrailingSlashes(path);
}
function encodePath(input) {
  return encodeURIComponent(removeInitialAndTrailingSlashes(input)).replaceAll("%2F", "/").replaceAll("%23", "#");
}
function filterOutNotAllowedCollections(resolvedCollections, authController) {
  return resolvedCollections.filter((c2) => {
    if (!c2.permissions) return true;
    const resolvedPermissions = resolvePermissions(c2, authController, c2.path, null);
    return resolvedPermissions?.read !== false;
  }).map((c2) => {
    if (!c2.subcollections) return c2;
    return {
      ...c2,
      subcollections: filterOutNotAllowedCollections(c2.subcollections, authController)
    };
  });
}
async function resolveCollections(collections, collectionPermissions, authController, dataSource, injectCollections) {
  let resolvedCollections = [];
  if (typeof collections === "function") {
    resolvedCollections = await collections({
      user: authController.user,
      authController,
      dataSource
    });
  } else if (Array.isArray(collections)) {
    resolvedCollections = collections;
  }
  if (injectCollections) {
    resolvedCollections = injectCollections(resolvedCollections ?? []);
  }
  resolvedCollections = applyPermissionsFunctionIfEmpty(resolvedCollections, collectionPermissions);
  resolvedCollections = filterOutNotAllowedCollections(resolvedCollections, authController);
  return resolvedCollections;
}
async function resolveCMSViews(baseViews, authController, dataSource) {
  let resolvedViews = [];
  if (typeof baseViews === "function") {
    resolvedViews = await baseViews({
      user: authController.user,
      authController,
      dataSource
    });
  } else if (Array.isArray(baseViews)) {
    resolvedViews = baseViews;
  }
  return resolvedViews;
}
function getGroup(collectionOrView) {
  const trimmed = collectionOrView.group?.trim();
  if (!trimmed || trimmed === "") {
    return "Views";
  }
  return trimmed ?? "Views";
}
function areCollectionListsEqual(a2, b) {
  if (a2.length !== b.length) {
    return false;
  }
  const aCopy = [...a2];
  const bCopy = [...b];
  const aSorted = aCopy.sort((x, y) => x.id.localeCompare(y.id));
  const bSorted = bCopy.sort((x, y) => x.id.localeCompare(y.id));
  return aSorted.every((value, index2) => areCollectionsEqual(value, bSorted[index2]));
}
function areCollectionsEqual(a2, b) {
  const {
    subcollections: subcollectionsA,
    ...restA
  } = a2;
  const {
    subcollections: subcollectionsB,
    ...restB
  } = b;
  if (!areCollectionListsEqual(subcollectionsA ?? [], subcollectionsB ?? [])) {
    return false;
  }
  return equal(removeFunctions(restA), removeFunctions(restB));
}
function useBuildLocalConfigurationPersistence() {
  const $ = c_1(15);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const configCache = useRef(t0);
  const getCollectionFromStorage = _temp$c;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (path) => {
      const storageKey_0 = `collection_config::${stripCollectionPath(path)}`;
      if (configCache.current[storageKey_0]) {
        return configCache.current[storageKey_0];
      }
      return getCollectionFromStorage(storageKey_0);
    };
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const getCollectionConfig = t1;
  let t2;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = (path_0, data) => {
      const storageKey_1 = `collection_config::${stripCollectionPath(path_0)}`;
      localStorage.setItem(storageKey_1, JSON.stringify(data));
      const cachedConfig = configCache.current[storageKey_1];
      const newConfig = mergeDeep(cachedConfig ?? getCollectionFromStorage(path_0), data);
      configCache.current[storageKey_1] = mergeDeep(configCache.current[storageKey_1], newConfig);
    };
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  const onCollectionModified = t2;
  let t3;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = [];
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  const [recentlyVisitedPaths, _setRecentlyVisitedPaths] = useState(t3);
  let t4;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = [];
    $[4] = t4;
  } else {
    t4 = $[4];
  }
  const [favouritePaths, _setFavouritePaths] = useState(t4);
  let t5;
  if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = [];
    $[5] = t5;
  } else {
    t5 = $[5];
  }
  const [collapsedGroups, _setCollapsedGroups] = useState(t5);
  let t6;
  let t7;
  if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = () => {
      _setRecentlyVisitedPaths(localStorage.getItem("recently_visited_paths") ? JSON.parse(localStorage.getItem("recently_visited_paths")) : []);
      _setFavouritePaths(localStorage.getItem("favourite_paths") ? JSON.parse(localStorage.getItem("favourite_paths")) : []);
      _setCollapsedGroups(localStorage.getItem("collapsed_groups") ? JSON.parse(localStorage.getItem("collapsed_groups")) : []);
    };
    t7 = [];
    $[6] = t6;
    $[7] = t7;
  } else {
    t6 = $[6];
    t7 = $[7];
  }
  useEffect(t6, t7);
  let t8;
  if ($[8] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = (paths) => {
      localStorage.setItem("recently_visited_paths", JSON.stringify(paths));
      _setRecentlyVisitedPaths(paths);
    };
    $[8] = t8;
  } else {
    t8 = $[8];
  }
  const setRecentlyVisitedPaths = t8;
  let t9;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = (paths_0) => {
      localStorage.setItem("favourite_paths", JSON.stringify(paths_0));
      _setFavouritePaths(paths_0);
    };
    $[9] = t9;
  } else {
    t9 = $[9];
  }
  const setFavouritePaths = t9;
  let t10;
  if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
    t10 = (paths_1) => {
      localStorage.setItem("collapsed_groups", JSON.stringify(paths_1));
      _setCollapsedGroups(paths_1);
    };
    $[10] = t10;
  } else {
    t10 = $[10];
  }
  const setCollapsedGroups = t10;
  let t11;
  if ($[11] !== collapsedGroups || $[12] !== favouritePaths || $[13] !== recentlyVisitedPaths) {
    t11 = {
      onCollectionModified,
      getCollectionConfig,
      recentlyVisitedPaths,
      setRecentlyVisitedPaths,
      favouritePaths,
      setFavouritePaths,
      collapsedGroups,
      setCollapsedGroups
    };
    $[11] = collapsedGroups;
    $[12] = favouritePaths;
    $[13] = recentlyVisitedPaths;
    $[14] = t11;
  } else {
    t11 = $[14];
  }
  return t11;
}
function _temp$c(storageKey) {
  const item = localStorage.getItem(storageKey);
  return item ? JSON.parse(item) : {};
}
function useBuildModeController() {
  const prefersDarkModeQuery = useCallback(() => {
    if (typeof window === "undefined") return false;
    const mediaQueryList = window.matchMedia("(prefers-color-scheme: dark)");
    return mediaQueryList.matches;
  }, []);
  const prefersDarkModeStorage = localStorage.getItem("prefers-dark-mode") != null ? localStorage.getItem("prefers-dark-mode") === "true" : null;
  const prefersDarkMode = prefersDarkModeStorage ?? prefersDarkModeQuery;
  const [mode, setMode] = useState(prefersDarkMode ? "dark" : "light");
  useEffect(() => {
    setMode(prefersDarkMode ? "dark" : "light");
    setDocumentMode(prefersDarkMode ? "dark" : "light");
  }, [prefersDarkMode]);
  const setDarkMode = useCallback(() => {
    setMode("dark");
    setDocumentMode("dark");
  }, []);
  const setLightMode = useCallback(() => {
    setMode("light");
    setDocumentMode("light");
  }, []);
  const setDocumentMode = (mode_0) => {
    document.body.style.setProperty("color-scheme", mode_0);
    document.documentElement.dataset.theme = mode_0;
  };
  const toggleMode = useCallback(() => {
    const prefersDarkModeQueryResult = prefersDarkModeQuery();
    if (mode === "light") {
      if (!prefersDarkModeQueryResult) localStorage.setItem("prefers-dark-mode", "true");
      else localStorage.removeItem("prefers-dark-mode");
      setDarkMode();
    } else {
      if (prefersDarkModeQueryResult) localStorage.setItem("prefers-dark-mode", "false");
      else localStorage.removeItem("prefers-dark-mode");
      setLightMode();
    }
  }, [mode, prefersDarkModeQuery]);
  return {
    mode,
    setMode,
    toggleMode
  };
}
function useValidateAuthenticator(t0) {
  const $ = c_1(17);
  const {
    disabled,
    authController,
    authenticator,
    storageSource,
    dataSourceDelegate
  } = t0;
  const authenticationEnabled = Boolean(authenticator);
  const [authLoading, setAuthLoading] = useState(authenticationEnabled);
  const [notAllowedError, setNotAllowedError] = useState(false);
  const [authVerified, setAuthVerified] = useState(!authenticationEnabled || Boolean(authController.loginSkipped));
  const canAccessMainView = authVerified && (!authenticationEnabled || Boolean(authController.user) || Boolean(authController.loginSkipped)) && !notAllowedError;
  let t1;
  let t2;
  if ($[0] !== authController.loginSkipped) {
    t1 = () => {
      if (authController.loginSkipped) {
        setAuthVerified(true);
      }
    };
    t2 = [authController.loginSkipped];
    $[0] = authController.loginSkipped;
    $[1] = t1;
    $[2] = t2;
  } else {
    t1 = $[1];
    t2 = $[2];
  }
  useEffect(t1, t2);
  const checkedUserRef = useRef();
  let t3;
  if ($[3] !== authController || $[4] !== authenticator || $[5] !== dataSourceDelegate || $[6] !== disabled || $[7] !== storageSource) {
    t3 = async () => {
      if (disabled) {
        return;
      }
      if (authController.initialLoading) {
        return;
      }
      if (!authController.user && !authController.loginSkipped) {
        checkedUserRef.current = void 0;
        setAuthLoading(false);
        setAuthVerified(false);
        return;
      }
      const delegateUser = authController.user;
      if (authenticator instanceof Function && delegateUser && !equal(checkedUserRef.current?.uid, delegateUser.uid)) {
        setAuthLoading(true);
        try {
          const allowed = await authenticator({
            user: delegateUser,
            authController,
            dataSourceDelegate,
            storageSource
          });
          if (!allowed) {
            authController.signOut();
            setNotAllowedError(true);
          }
        } catch (t42) {
          const e2 = t42;
          setNotAllowedError(e2);
          authController.signOut();
        }
        setAuthLoading(false);
        setAuthVerified(true);
        checkedUserRef.current = delegateUser;
      } else {
        setAuthLoading(false);
      }
      if (!authController.initialLoading && !delegateUser) {
        setAuthVerified(true);
      }
    };
    $[3] = authController;
    $[4] = authenticator;
    $[5] = dataSourceDelegate;
    $[6] = disabled;
    $[7] = storageSource;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  const checkAuthentication = t3;
  let t4;
  let t5;
  if ($[9] !== checkAuthentication) {
    t4 = () => {
      checkAuthentication();
    };
    t5 = [checkAuthentication];
    $[9] = checkAuthentication;
    $[10] = t4;
    $[11] = t5;
  } else {
    t4 = $[10];
    t5 = $[11];
  }
  useEffect(t4, t5);
  const t6 = authenticationEnabled && authLoading;
  let t7;
  if ($[12] !== authVerified || $[13] !== canAccessMainView || $[14] !== notAllowedError || $[15] !== t6) {
    t7 = {
      canAccessMainView,
      authLoading: t6,
      notAllowedError,
      authVerified
    };
    $[12] = authVerified;
    $[13] = canAccessMainView;
    $[14] = notAllowedError;
    $[15] = t6;
    $[16] = t7;
  } else {
    t7 = $[16];
  }
  return t7;
}
function EmptyValue() {
  const $ = c_1(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-full bg-surface-200 bg-opacity-30 dark:bg-opacity-20 w-5 h-2 inline-block" });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
function ImagePreview(t0) {
  const $ = c_1(26);
  const {
    size: size2,
    url
  } = t0;
  let t1;
  let t2;
  if ($[0] !== size2) {
    t2 = getThumbnailMeasure(size2);
    $[0] = size2;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  t1 = t2;
  const imageSize = t1;
  if (size2 === "small") {
    const t32 = "tiny_image_preview_" + url;
    let t42;
    if ($[2] !== imageSize) {
      t42 = {
        position: "relative",
        objectFit: "cover",
        width: imageSize,
        height: imageSize,
        maxHeight: "100%"
      };
      $[2] = imageSize;
      $[3] = t42;
    } else {
      t42 = $[3];
    }
    let t52;
    if ($[4] !== t32 || $[5] !== t42 || $[6] !== url) {
      t52 = /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: url, className: "rounded-md", style: t42 }, t32);
      $[4] = t32;
      $[5] = t42;
      $[6] = url;
      $[7] = t52;
    } else {
      t52 = $[7];
    }
    return t52;
  }
  let t3;
  if ($[8] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = {
      maxWidth: "100%",
      maxHeight: "100%"
    };
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  const imageStyle = t3;
  let t4;
  if ($[9] !== imageSize) {
    t4 = {
      width: imageSize,
      height: imageSize
    };
    $[9] = imageSize;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  const t5 = "image_preview_" + url;
  let t6;
  if ($[11] !== url) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: url, className: "rounded-md", style: imageStyle });
    $[11] = url;
    $[12] = t6;
  } else {
    t6 = $[12];
  }
  let t7;
  if ($[13] !== url) {
    t7 = navigator && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { asChild: true, title: "Copy url to clipboard", side: "bottom", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { variant: "filled", size: "small", onClick: (e2) => {
      e2.stopPropagation();
      e2.preventDefault();
      return navigator.clipboard.writeText(url);
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ContentCopyIcon, { className: "text-surface-700 dark:text-surface-300", size: "smallest" }) }) });
    $[13] = url;
    $[14] = t7;
  } else {
    t7 = $[14];
  }
  let t8;
  if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(OpenInNewIcon, { className: "text-surface-700 dark:text-surface-300", size: "smallest" });
    $[15] = t8;
  } else {
    t8 = $[15];
  }
  let t9;
  if ($[16] !== url) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Open image in new tab", side: "bottom", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { className: "invisible group-hover:visible", variant: "filled", component: "a", href: url, rel: "noopener noreferrer", target: "_blank", size: "small", onClick: _temp$b, children: t8 }) });
    $[16] = url;
    $[17] = t9;
  } else {
    t9 = $[17];
  }
  let t10;
  if ($[18] !== t7 || $[19] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row gap-2 absolute bottom-[-4px] right-[-4px] invisible group-hover:visible", children: [
      t7,
      t9
    ] });
    $[18] = t7;
    $[19] = t9;
    $[20] = t10;
  } else {
    t10 = $[20];
  }
  let t11;
  if ($[21] !== t10 || $[22] !== t4 || $[23] !== t5 || $[24] !== t6) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex items-center justify-center max-w-full max-h-full group", style: t4, children: [
      t6,
      t10
    ] }, t5);
    $[21] = t10;
    $[22] = t4;
    $[23] = t5;
    $[24] = t6;
    $[25] = t11;
  } else {
    t11 = $[25];
  }
  return t11;
}
function _temp$b(e_0) {
  return e_0.stopPropagation();
}
function UrlComponentPreview(t0) {
  const $ = c_1(28);
  const {
    url,
    previewType,
    size: size2,
    hint,
    interactive: t1
  } = t0;
  const interactive = t1 === void 0 ? true : t1;
  if (!previewType) {
    if (!url || !url.trim()) {
      let t22;
      if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t22 = /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyValue, {});
        $[0] = t22;
      } else {
        t22 = $[0];
      }
      return t22;
    }
    let t2;
    if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
      t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(OpenInNewIcon, { size: "small" });
      $[1] = t2;
    } else {
      t2 = $[1];
    }
    let t3;
    if ($[2] !== url) {
      t3 = /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { className: "flex gap-4 break-words items-center font-medium text-primary visited:text-primary dark:visited:text-primary dark:text-primary", href: url, rel: "noopener noreferrer", onMouseDown: _temp$a, target: "_blank", children: [
        t2,
        url
      ] });
      $[2] = url;
      $[3] = t3;
    } else {
      t3 = $[3];
    }
    return t3;
  }
  if (previewType === "image") {
    let t2;
    if ($[4] !== size2 || $[5] !== url) {
      t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(ImagePreview, { url, size: size2 });
      $[4] = size2;
      $[5] = url;
      $[6] = t2;
    } else {
      t2 = $[6];
    }
    return t2;
  } else {
    if (previewType === "audio") {
      let t2;
      if ($[7] === Symbol.for("react.memo_cache_sentinel")) {
        t2 = /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: "audio" });
        $[7] = t2;
      } else {
        t2 = $[7];
      }
      let t3;
      if ($[8] !== url) {
        t3 = /* @__PURE__ */ jsxRuntimeExports.jsxs("audio", { controls: true, className: "max-w-100%", src: url, children: [
          "Your browser does not support the",
          t2,
          " element."
        ] });
        $[8] = url;
        $[9] = t3;
      } else {
        t3 = $[9];
      }
      return t3;
    } else {
      if (previewType === "video") {
        let t2;
        if ($[10] !== interactive || $[11] !== size2 || $[12] !== url) {
          t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(VideoPreview, { size: size2, src: url, interactive });
          $[10] = interactive;
          $[11] = size2;
          $[12] = url;
          $[13] = t2;
        } else {
          t2 = $[13];
        }
        return t2;
      } else {
        let t2;
        if ($[14] !== size2) {
          t2 = getThumbnailMeasure(size2);
          $[14] = size2;
          $[15] = t2;
        } else {
          t2 = $[15];
        }
        let t3;
        if ($[16] !== size2) {
          t3 = getThumbnailMeasure(size2);
          $[16] = size2;
          $[17] = t3;
        } else {
          t3 = $[17];
        }
        let t4;
        if ($[18] !== t2 || $[19] !== t3) {
          t4 = {
            width: t2,
            height: t3
          };
          $[18] = t2;
          $[19] = t3;
          $[20] = t4;
        } else {
          t4 = $[20];
        }
        let t5;
        if ($[21] === Symbol.for("react.memo_cache_sentinel")) {
          t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(DescriptionIcon, { className: "text-surface-700 dark:text-surface-300" });
          $[21] = t5;
        } else {
          t5 = $[21];
        }
        let t6;
        if ($[22] !== hint) {
          t6 = hint && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: hint, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { className: "max-w-full truncate rtl text-left", variant: "caption", children: hint }) });
          $[22] = hint;
          $[23] = t6;
        } else {
          t6 = $[23];
        }
        let t7;
        if ($[24] !== t4 || $[25] !== t6 || $[26] !== url) {
          t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: url, rel: "noopener noreferrer", target: "_blank", onClick: _temp2$4, className: "flex flex-col items-center justify-center", style: t4, children: [
            t5,
            t6
          ] });
          $[24] = t4;
          $[25] = t6;
          $[26] = url;
          $[27] = t7;
        } else {
          t7 = $[27];
        }
        return t7;
      }
    }
  }
}
function _temp2$4(e_0) {
  return e_0.stopPropagation();
}
function _temp$a(e2) {
  e2.preventDefault();
}
function VideoPreview(t0) {
  const $ = c_1(13);
  const {
    size: size2,
    src,
    interactive
  } = t0;
  let t1;
  if (size2 === "small") {
    t1 = "140px";
  } else {
    if (size2 === "medium") {
      t1 = "240px";
    } else {
      if (size2 === "large") {
        t1 = "100%";
      } else {
        throw new Error("Invalid size");
      }
    }
  }
  const imageSize = t1;
  let t2;
  if ($[0] !== interactive) {
    t2 = {
      controls: interactive
    };
    $[0] = interactive;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  const videoProps = t2;
  let t3;
  if ($[2] !== imageSize) {
    t3 = {
      position: "relative",
      objectFit: "cover",
      width: imageSize,
      minWidth: "140px",
      maxHeight: "100%"
    };
    $[2] = imageSize;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  const t4 = !interactive;
  let t5;
  if ($[4] !== t4) {
    t5 = cls("max-w-100% rounded", {
      "pointer-events-none": t4
    });
    $[4] = t4;
    $[5] = t5;
  } else {
    t5 = $[5];
  }
  let t6;
  if ($[6] !== src) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src });
    $[6] = src;
    $[7] = t6;
  } else {
    t6 = $[7];
  }
  let t7;
  if ($[8] !== t3 || $[9] !== t5 || $[10] !== t6 || $[11] !== videoProps) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx("video", { style: t3, ...videoProps, className: t5, children: t6 });
    $[8] = t3;
    $[9] = t5;
    $[10] = t6;
    $[11] = videoProps;
    $[12] = t7;
  } else {
    t7 = $[12];
  }
  return t7;
}
function SkeletonPropertyComponent(t0) {
  const $ = c_1(27);
  const {
    property: property2,
    size: size2
  } = t0;
  if (!property2) {
    console.error("No property assigned for skeleton component", property2, size2);
  }
  let content;
  if (property2.dataType === "string") {
    const stringProperty = property2;
    if (stringProperty.url) {
      let t1;
      if ($[0] !== size2 || $[1] !== stringProperty) {
        t1 = renderUrlComponent(stringProperty, size2);
        $[0] = size2;
        $[1] = stringProperty;
        $[2] = t1;
      } else {
        t1 = $[2];
      }
      content = t1;
    } else {
      if (stringProperty.storage) {
        let t1;
        if ($[3] !== size2) {
          t1 = renderSkeletonImageThumbnail(size2);
          $[3] = size2;
          $[4] = t1;
        } else {
          t1 = $[4];
        }
        content = t1;
      } else {
        let t1;
        if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
          t1 = renderSkeletonText();
          $[5] = t1;
        } else {
          t1 = $[5];
        }
        content = t1;
      }
    }
  } else {
    if (property2.dataType === "array") {
      const arrayProperty = property2;
      if (arrayProperty.of) {
        if (Array.isArray(arrayProperty.of)) {
          let t1;
          if ($[6] !== arrayProperty.of) {
            t1 = arrayProperty.of.map(_temp$9);
            $[6] = arrayProperty.of;
            $[7] = t1;
          } else {
            t1 = $[7];
          }
          let t2;
          if ($[8] !== t1) {
            t2 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              t1,
              " "
            ] });
            $[8] = t1;
            $[9] = t2;
          } else {
            t2 = $[9];
          }
          content = t2;
        } else {
          if (arrayProperty.of.dataType === "map" && arrayProperty.of.properties) {
            let t1;
            if ($[10] !== arrayProperty.of.previewProperties || $[11] !== arrayProperty.of.properties || $[12] !== size2) {
              t1 = renderArrayOfMaps(arrayProperty.of.properties, size2, arrayProperty.of.previewProperties);
              $[10] = arrayProperty.of.previewProperties;
              $[11] = arrayProperty.of.properties;
              $[12] = size2;
              $[13] = t1;
            } else {
              t1 = $[13];
            }
            content = t1;
          } else {
            if (arrayProperty.of.dataType === "string") {
              if (arrayProperty.of.enumValues) {
                let t1;
                if ($[14] === Symbol.for("react.memo_cache_sentinel")) {
                  t1 = renderArrayEnumTableCell();
                  $[14] = t1;
                } else {
                  t1 = $[14];
                }
                content = t1;
              } else {
                if (arrayProperty.of.storage) {
                  let t1;
                  if ($[15] !== arrayProperty.of) {
                    t1 = renderGenericArrayCell(arrayProperty.of);
                    $[15] = arrayProperty.of;
                    $[16] = t1;
                  } else {
                    t1 = $[16];
                  }
                  content = t1;
                } else {
                  let t1;
                  if ($[17] === Symbol.for("react.memo_cache_sentinel")) {
                    t1 = renderArrayOfStrings();
                    $[17] = t1;
                  } else {
                    t1 = $[17];
                  }
                  content = t1;
                }
              }
            } else {
              let t1;
              if ($[18] !== arrayProperty.of) {
                t1 = renderGenericArrayCell(arrayProperty.of);
                $[18] = arrayProperty.of;
                $[19] = t1;
              } else {
                t1 = $[19];
              }
              content = t1;
            }
          }
        }
      }
    } else {
      if (property2.dataType === "map") {
        const t1 = property2;
        let t2;
        if ($[20] !== size2 || $[21] !== t1) {
          t2 = renderMap(t1, size2);
          $[20] = size2;
          $[21] = t1;
          $[22] = t2;
        } else {
          t2 = $[22];
        }
        content = t2;
      } else {
        if (property2.dataType === "date") {
          let t1;
          if ($[23] === Symbol.for("react.memo_cache_sentinel")) {
            t1 = renderSkeletonText();
            $[23] = t1;
          } else {
            t1 = $[23];
          }
          content = t1;
        } else {
          if (property2.dataType === "reference") {
            let t1;
            if ($[24] === Symbol.for("react.memo_cache_sentinel")) {
              t1 = renderReference();
              $[24] = t1;
            } else {
              t1 = $[24];
            }
            content = t1;
          } else {
            if (property2.dataType === "boolean") {
              let t1;
              if ($[25] === Symbol.for("react.memo_cache_sentinel")) {
                t1 = renderSkeletonText();
                $[25] = t1;
              } else {
                t1 = $[25];
              }
              content = t1;
            } else {
              let t1;
              if ($[26] === Symbol.for("react.memo_cache_sentinel")) {
                t1 = renderSkeletonText();
                $[26] = t1;
              } else {
                t1 = $[26];
              }
              content = t1;
            }
          }
        }
      }
    }
  }
  return content || null;
}
function _temp$9(p2, i) {
  return renderGenericArrayCell(p2, i);
}
function renderMap(property2, size2) {
  if (!property2.properties) return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  let mapPropertyKeys;
  if (size2 === "large") {
    mapPropertyKeys = Object.keys(property2.properties);
  } else {
    mapPropertyKeys = property2.previewProperties || Object.keys(property2.properties);
    if (size2 === "medium") mapPropertyKeys = mapPropertyKeys.slice(0, 3);
    else if (size2 === "small") mapPropertyKeys = mapPropertyKeys.slice(0, 1);
  }
  if (size2 !== "large") return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full flex flex-col space-y-4", children: mapPropertyKeys.map((key, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: property2.properties && property2.properties[key] && /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonPropertyComponent, { property: property2.properties[key], size: "medium" }) }, `map_${key}`)) });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("table", { className: "table-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: mapPropertyKeys && mapPropertyKeys.map((key, index2) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "border-b last:border-b-0", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "align-top", style: {
        width: "30%"
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-secondary", children: property2.properties[key].name }) }, `table-cell-title--${key}`),
      /* @__PURE__ */ jsxRuntimeExports.jsx("th", { style: {
        width: "70%"
      }, children: property2.properties && property2.properties[key] && /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonPropertyComponent, { property: property2.properties[key], size: "medium" }) }, `table-cell-${key}`)
    ] }, `map_preview_table__${index2}`);
  }) }) });
}
function renderArrayOfMaps(properties, size2, previewProperties) {
  let tableProperties = previewProperties;
  if (!tableProperties || !tableProperties.length) {
    tableProperties = Object.keys(properties);
    if (size2) tableProperties = tableProperties.slice(0, 3);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("table", { className: "table-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: [0, 1, 2].map((value, index2) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("tr", { children: tableProperties && tableProperties.map((key) => /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonPropertyComponent, { property: properties[key], size: "medium" }) }, `table-cell-${key}`)) }, `table_${value}_${index2}`);
  }) }) });
}
function renderArrayOfStrings() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-2", children: [0, 1].map((value, index2) => renderSkeletonText(index2)) });
}
function renderArrayEnumTableCell() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-2", children: [0, 1].map((value, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: renderSkeletonText(index2) })) });
}
function renderGenericArrayCell(property2, index2 = 0) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-2", children: [0, 1].map((value, index22) => /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonPropertyComponent, { property: property2, size: "medium" }, `i_${index22}`) })) }, "array_index_" + index2);
}
function renderSkeletonImageThumbnail(size2) {
  const imageSize = size2 === "small" ? 40 : size2 === "medium" ? 100 : 200;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { width: imageSize, height: imageSize });
}
function renderReference() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { width: 200, height: 100 });
}
function renderUrlComponent(property2, size2 = "large") {
  if (typeof property2.url === "boolean") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
      display: "flex"
    }, children: [
      renderSkeletonIcon(),
      renderSkeletonText()
    ] });
  }
  return renderUrlFile(size2);
}
function renderUrlFile(size2) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-${getThumbnailMeasure(size2)} h-${getThumbnailMeasure(size2)}`, children: renderSkeletonIcon() });
}
function renderSkeletonText(index2, width = 120) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { width }, `skeleton_${index2}`);
}
function renderSkeletonCaptionText(index2) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { height: 20 });
}
function renderSkeletonIcon() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { width: 24, height: 24 });
}
const StorageThumbnail = React__default.memo(StorageThumbnailInternal, areEqual);
function areEqual(prevProps, nextProps) {
  return prevProps.size === nextProps.size && prevProps.storagePathOrDownloadUrl === nextProps.storagePathOrDownloadUrl && prevProps.storeUrl === nextProps.storeUrl && prevProps.interactive === nextProps.interactive;
}
const URL_CACHE = {};
function StorageThumbnailInternal(t0) {
  const $ = c_1(12);
  const {
    interactive,
    storagePathOrDownloadUrl,
    size: size2
  } = t0;
  const [, setError] = React__default.useState(void 0);
  const storage = useStorageSource();
  const [downloadConfig, setDownloadConfig] = React__default.useState(URL_CACHE[storagePathOrDownloadUrl]);
  let t1;
  if ($[0] !== storage || $[1] !== storagePathOrDownloadUrl) {
    t1 = () => {
      if (!storagePathOrDownloadUrl) {
        return;
      }
      let unmounted;
      unmounted = false;
      storage.getDownloadURL(storagePathOrDownloadUrl).then(function(downloadConfig_0) {
        if (!unmounted) {
          setDownloadConfig(downloadConfig_0);
          URL_CACHE[storagePathOrDownloadUrl] = downloadConfig_0;
        }
      }).catch(setError);
      return () => {
        unmounted = true;
      };
    };
    $[0] = storage;
    $[1] = storagePathOrDownloadUrl;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[3] !== storagePathOrDownloadUrl) {
    t2 = [storagePathOrDownloadUrl];
    $[3] = storagePathOrDownloadUrl;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  useEffect(t1, t2);
  if (!storagePathOrDownloadUrl) {
    return null;
  }
  const filetype = downloadConfig?.metadata ? getFiletype(downloadConfig?.metadata.contentType) : void 0;
  const previewType = filetype?.startsWith("image") ? "image" : filetype?.startsWith("video") ? "video" : filetype?.startsWith("audio") ? "audio" : "file";
  if (downloadConfig?.fileNotFound) {
    let t32;
    if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
      t32 = /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView, { error: "File not found" });
      $[5] = t32;
    } else {
      t32 = $[5];
    }
    return t32;
  }
  let t3;
  if ($[6] !== downloadConfig || $[7] !== interactive || $[8] !== previewType || $[9] !== size2 || $[10] !== storagePathOrDownloadUrl) {
    t3 = downloadConfig?.url ? /* @__PURE__ */ jsxRuntimeExports.jsx(UrlComponentPreview, { previewType, url: downloadConfig.url, interactive, size: size2, hint: storagePathOrDownloadUrl }) : renderSkeletonImageThumbnail(size2);
    $[6] = downloadConfig;
    $[7] = interactive;
    $[8] = previewType;
    $[9] = size2;
    $[10] = storagePathOrDownloadUrl;
    $[11] = t3;
  } else {
    t3 = $[11];
  }
  return t3;
}
function getFiletype(input) {
  if (input.startsWith("image")) return "image/*";
  else if (input.startsWith("video")) return "video/*";
  else if (input.startsWith("audio")) return "audio/*";
  else if (input.startsWith("application")) return "application/*";
  else if (input.startsWith("text")) return "text/*";
  else if (input.startsWith("font")) return "font/*";
  else return input;
}
function EnumValuesChip(t0) {
  const $ = c_1(11);
  const {
    enumValues,
    enumKey,
    size: size2,
    className,
    children
  } = t0;
  if (!enumValues) {
    return null;
  }
  let label;
  let t1;
  if ($[0] !== enumKey || $[1] !== enumValues) {
    const enumValuesConfig = enumToObjectEntries(enumValues);
    const enumValue = enumKey !== void 0 ? getLabelOrConfigFrom(enumValuesConfig, enumKey) : void 0;
    label = buildEnumLabel(enumValue);
    t1 = getColorScheme(enumValuesConfig, enumKey);
    $[0] = enumKey;
    $[1] = enumValues;
    $[2] = label;
    $[3] = t1;
  } else {
    label = $[2];
    t1 = $[3];
  }
  const colorScheme = t1;
  const t2 = !label;
  const t3 = !children && (label !== void 0 ? label : String(enumKey));
  let t4;
  if ($[4] !== children || $[5] !== className || $[6] !== colorScheme || $[7] !== size2 || $[8] !== t2 || $[9] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Chip, { className, colorScheme, error: t2, outlined: false, size: size2, children: [
      children,
      t3
    ] });
    $[4] = children;
    $[5] = className;
    $[6] = colorScheme;
    $[7] = size2;
    $[8] = t2;
    $[9] = t3;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  return t4;
}
function StringPropertyPreview(t0) {
  const $ = c_1(20);
  const {
    propertyKey,
    value,
    property: property2,
    size: size2
  } = t0;
  if (property2.enumValues) {
    const enumKey = value;
    let t1;
    if ($[0] !== property2) {
      t1 = resolvePropertyEnum(property2);
      $[0] = property2;
      $[1] = t1;
    } else {
      t1 = $[1];
    }
    const resolvedProperty = t1;
    let t2;
    if ($[2] !== enumKey || $[3] !== resolvedProperty.enumValues || $[4] !== size2) {
      t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(EnumValuesChip, { enumKey, enumValues: resolvedProperty.enumValues, size: size2 });
      $[2] = enumKey;
      $[3] = resolvedProperty.enumValues;
      $[4] = size2;
      $[5] = t2;
    } else {
      t2 = $[5];
    }
    return t2;
  } else {
    if (property2.previewAsTag) {
      const t1 = propertyKey ?? "";
      let t2;
      if ($[6] !== t1) {
        t2 = getColorSchemeForSeed(t1);
        $[6] = t1;
        $[7] = t2;
      } else {
        t2 = $[7];
      }
      const colorScheme = t2;
      let t3;
      if ($[8] !== colorScheme || $[9] !== size2 || $[10] !== value) {
        t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { colorScheme, size: size2, children: value }) });
        $[8] = colorScheme;
        $[9] = size2;
        $[10] = value;
        $[11] = t3;
      } else {
        t3 = $[11];
      }
      return t3;
    } else {
      if (property2.url) {
        const t1 = typeof property2.url === "string" ? property2.url : void 0;
        let t2;
        if ($[12] !== size2 || $[13] !== t1 || $[14] !== value) {
          t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(UrlComponentPreview, { size: size2, url: value, previewType: t1 });
          $[12] = size2;
          $[13] = t1;
          $[14] = value;
          $[15] = t2;
        } else {
          t2 = $[15];
        }
        return t2;
      } else {
        if (!value) {
          let t12;
          if ($[16] === Symbol.for("react.memo_cache_sentinel")) {
            t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
            $[16] = t12;
          } else {
            t12 = $[16];
          }
          return t12;
        }
        let t1;
        if ($[17] !== size2 || $[18] !== value) {
          const lines = value.split("\n");
          t1 = value && value.includes("\n") ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls("overflow-x-scroll", size2 === "small" ? "text-sm" : ""), children: lines.map((str, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(React__default.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: str }),
            index2 !== lines.length - 1 && /* @__PURE__ */ jsxRuntimeExports.jsx("br", {})
          ] }, `string_preview_${index2}`)) }) : size2 === "small" ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm", children: value }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: value });
          $[17] = size2;
          $[18] = value;
          $[19] = t1;
        } else {
          t1 = $[19];
        }
        return t1;
      }
    }
  }
}
function ArrayPropertyPreview(t0) {
  const $ = c_1(12);
  const {
    propertyKey,
    value,
    property: inputProperty,
    size: size2
  } = t0;
  const customizationController = useCustomizationController();
  let t1;
  if ($[0] !== customizationController.propertyConfigs || $[1] !== inputProperty || $[2] !== propertyKey) {
    t1 = resolveArrayProperty({
      propertyKey,
      property: inputProperty,
      propertyConfigs: customizationController.propertyConfigs
    });
    $[0] = customizationController.propertyConfigs;
    $[1] = inputProperty;
    $[2] = propertyKey;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const property2 = t1;
  if (!property2.of) {
    throw Error(`You need to specify an 'of' prop (or specify a custom field) in your array property ${propertyKey}`);
  }
  if (property2.dataType !== "array") {
    throw Error("Picked wrong preview component ArrayPreview");
  }
  const values = value;
  if (!values) {
    return null;
  }
  const childSize = size2 === "medium" ? "medium" : "small";
  let t2;
  if ($[4] !== childSize || $[5] !== property2.of || $[6] !== property2.resolvedProperties || $[7] !== propertyKey || $[8] !== values) {
    t2 = values && values.map((value_0, index2) => {
      const of = property2.resolvedProperties[index2] ?? property2.resolvedProperties[index2] ?? (Array.isArray(property2.of) ? property2.of[index2] : property2.of);
      return of ? /* @__PURE__ */ jsxRuntimeExports.jsx(React__default.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls(defaultBorderMixin, "m-1 border-b last:border-b-0"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyPreview, { propertyKey, value: value_0, property: of, size: childSize }) }) }) }, "preview_array_" + index2) : null;
    });
    $[4] = childSize;
    $[5] = property2.of;
    $[6] = property2.resolvedProperties;
    $[7] = propertyKey;
    $[8] = values;
    $[9] = t2;
  } else {
    t2 = $[9];
  }
  let t3;
  if ($[10] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-2", children: t2 });
    $[10] = t2;
    $[11] = t3;
  } else {
    t3 = $[11];
  }
  return t3;
}
const ReferencePreview = function ReferencePreview2(props) {
  const $ = c_1(10);
  const reference2 = props.reference;
  if (!(typeof reference2 === "object" && "isEntityReference" in reference2 && reference2.isEntityReference())) {
    console.warn("Reference preview received value of type", typeof reference2);
    const t02 = props.onClick;
    const t1 = props.size;
    let t2;
    if ($[0] !== reference2) {
      t2 = JSON.stringify(reference2);
      $[0] = reference2;
      $[1] = t2;
    } else {
      t2 = $[1];
    }
    let t3;
    if ($[2] !== t2) {
      t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView, { error: "Unexpected value. Click to edit", tooltip: t2 });
      $[2] = t2;
      $[3] = t3;
    } else {
      t3 = $[3];
    }
    let t4;
    if ($[4] !== props.onClick || $[5] !== props.size || $[6] !== t3) {
      t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(EntityPreviewContainer, { onClick: t02, size: t1, children: t3 });
      $[4] = props.onClick;
      $[5] = props.size;
      $[6] = t3;
      $[7] = t4;
    } else {
      t4 = $[7];
    }
    return t4;
  }
  let t0;
  if ($[8] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(ReferencePreviewInternal, { ...props });
    $[8] = props;
    $[9] = t0;
  } else {
    t0 = $[9];
  }
  return t0;
};
function ReferencePreviewInternal(t0) {
  const $ = c_1(16);
  const {
    disabled,
    reference: reference2,
    previewProperties,
    size: size2,
    hover,
    onClick,
    includeEntityLink: t1,
    includeId: t2
  } = t0;
  const includeEntityLink = t1 === void 0 ? true : t1;
  const includeId = t2 === void 0 ? true : t2;
  const customizationController = useCustomizationController();
  const navigationController = useNavigationController();
  let t3;
  if ($[0] !== navigationController || $[1] !== reference2.path) {
    t3 = navigationController.getCollection(reference2.path);
    $[0] = navigationController;
    $[1] = reference2.path;
    $[2] = t3;
  } else {
    t3 = $[2];
  }
  const collection = t3;
  if (!collection) {
    if (customizationController.components?.missingReference) {
      let t42;
      if ($[3] !== customizationController.components.missingReference || $[4] !== reference2.path) {
        t42 = /* @__PURE__ */ jsxRuntimeExports.jsx(customizationController.components.missingReference, { path: reference2.path });
        $[3] = customizationController.components.missingReference;
        $[4] = reference2.path;
        $[5] = t42;
      } else {
        t42 = $[5];
      }
      return t42;
    } else {
      throw Error(`Couldn't find the corresponding collection view for the path: ${reference2.path}`);
    }
  }
  let t4;
  if ($[6] !== collection || $[7] !== disabled || $[8] !== hover || $[9] !== includeEntityLink || $[10] !== includeId || $[11] !== onClick || $[12] !== previewProperties || $[13] !== reference2 || $[14] !== size2) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(ReferencePreviewExisting, { reference: reference2, collection, previewProperties, size: size2, disabled, includeEntityLink, includeId, onClick, hover });
    $[6] = collection;
    $[7] = disabled;
    $[8] = hover;
    $[9] = includeEntityLink;
    $[10] = includeId;
    $[11] = onClick;
    $[12] = previewProperties;
    $[13] = reference2;
    $[14] = size2;
    $[15] = t4;
  } else {
    t4 = $[15];
  }
  return t4;
}
function ReferencePreviewExisting(t0) {
  const $ = c_1(35);
  const {
    reference: reference2,
    collection,
    previewProperties,
    size: size2,
    disabled,
    includeEntityLink,
    includeId,
    onClick,
    hover
  } = t0;
  let t1;
  if ($[0] !== collection || $[1] !== reference2.id || $[2] !== reference2.path) {
    t1 = {
      path: reference2.path,
      entityId: reference2.id,
      collection,
      useCache: true
    };
    $[0] = collection;
    $[1] = reference2.id;
    $[2] = reference2.path;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const {
    entity,
    dataLoading
  } = useEntityFetch(t1);
  if (entity) {
    referencesCache.set(reference2.pathWithId, entity);
  }
  let t2;
  if ($[4] !== entity || $[5] !== reference2.pathWithId) {
    t2 = entity ?? referencesCache.get(reference2.pathWithId);
    $[4] = entity;
    $[5] = reference2.pathWithId;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  const usedEntity = t2;
  let body;
  if (!reference2) {
    let t32;
    if ($[7] === Symbol.for("react.memo_cache_sentinel")) {
      t32 = /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView, { error: "Reference not set" });
      $[7] = t32;
    } else {
      t32 = $[7];
    }
    body = t32;
  } else {
    if (usedEntity && !usedEntity.values) {
      let t32;
      if ($[8] !== reference2.path) {
        t32 = /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView, { error: "Reference does not exist", tooltip: reference2.path });
        $[8] = reference2.path;
        $[9] = t32;
      } else {
        t32 = $[9];
      }
      body = t32;
    }
  }
  if (body) {
    const t32 = disabled ? void 0 : onClick;
    const t4 = disabled ? void 0 : hover;
    let t5;
    if ($[10] !== body || $[11] !== size2 || $[12] !== t32 || $[13] !== t4) {
      t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(EntityPreviewContainer, { onClick: t32, hover: t4, size: size2, children: body });
      $[10] = body;
      $[11] = size2;
      $[12] = t32;
      $[13] = t4;
      $[14] = t5;
    } else {
      t5 = $[14];
    }
    return t5;
  }
  if (dataLoading && !usedEntity) {
    const t32 = disabled ? void 0 : onClick;
    const t4 = disabled ? void 0 : hover;
    let t5;
    if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
      t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, {});
      $[15] = t5;
    } else {
      t5 = $[15];
    }
    let t6;
    if ($[16] !== size2 || $[17] !== t32 || $[18] !== t4) {
      t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(EntityPreviewContainer, { onClick: t32, hover: t4, size: size2, children: t5 });
      $[16] = size2;
      $[17] = t32;
      $[18] = t4;
      $[19] = t6;
    } else {
      t6 = $[19];
    }
    return t6;
  }
  if (!usedEntity) {
    const t32 = disabled ? void 0 : onClick;
    const t4 = disabled ? void 0 : hover;
    let t5;
    if ($[20] === Symbol.for("react.memo_cache_sentinel")) {
      t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView, { error: "Entity not found" });
      $[20] = t5;
    } else {
      t5 = $[20];
    }
    let t6;
    if ($[21] !== size2 || $[22] !== t32 || $[23] !== t4) {
      t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(EntityPreviewContainer, { onClick: t32, hover: t4, size: size2, children: t5 });
      $[21] = size2;
      $[22] = t32;
      $[23] = t4;
      $[24] = t6;
    } else {
      t6 = $[24];
    }
    return t6;
  }
  let t3;
  if ($[25] !== collection || $[26] !== disabled || $[27] !== hover || $[28] !== includeEntityLink || $[29] !== includeId || $[30] !== onClick || $[31] !== previewProperties || $[32] !== size2 || $[33] !== usedEntity) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(EntityPreview, { size: size2, previewProperties, disabled, entity: usedEntity, collection, onClick, includeEntityLink, includeId, hover });
    $[25] = collection;
    $[26] = disabled;
    $[27] = hover;
    $[28] = includeEntityLink;
    $[29] = includeId;
    $[30] = onClick;
    $[31] = previewProperties;
    $[32] = size2;
    $[33] = usedEntity;
    $[34] = t3;
  } else {
    t3 = $[34];
  }
  return t3;
}
const referencesCache = /* @__PURE__ */ new Map();
function ArrayOfReferencesPreview(t0) {
  const $ = c_1(11);
  const {
    propertyKey,
    value,
    property: inputProperty,
    size: size2
  } = t0;
  const customizationController = useCustomizationController();
  let t1;
  if ($[0] !== customizationController.propertyConfigs || $[1] !== inputProperty || $[2] !== propertyKey) {
    t1 = resolveArrayProperty({
      propertyKey,
      property: inputProperty,
      propertyConfigs: customizationController.propertyConfigs
    });
    $[0] = customizationController.propertyConfigs;
    $[1] = inputProperty;
    $[2] = propertyKey;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const property2 = t1;
  if (Array.isArray(property2?.of)) {
    throw Error("Using array properties instead of single one in `of` in ArrayProperty");
  }
  if (property2?.dataType !== "array" || !property2.of || property2.of.dataType !== "reference") {
    throw Error("Picked wrong preview component ArrayOfReferencesPreview");
  }
  const childSize = size2 === "medium" ? "medium" : "small";
  let t2;
  if ($[4] !== childSize || $[5] !== property2 || $[6] !== propertyKey || $[7] !== value) {
    t2 = value && value.map((reference2, index2) => {
      const ofProperty = property2.of;
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-1 mb-1 w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReferencePreview, { disabled: !ofProperty.path, previewProperties: ofProperty.previewProperties, size: childSize, reference: reference2, includeId: ofProperty.includeId, includeEntityLink: ofProperty.includeEntityLink }) }, `preview_array_ref_${propertyKey}_${index2}`);
    });
    $[4] = childSize;
    $[5] = property2;
    $[6] = propertyKey;
    $[7] = value;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  let t3;
  if ($[9] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col w-full", children: t2 });
    $[9] = t2;
    $[10] = t3;
  } else {
    t3 = $[10];
  }
  return t3;
}
function ArrayOfStorageComponentsPreview(t0) {
  const $ = c_1(11);
  const {
    propertyKey,
    value,
    property: inputProperty,
    size: size2
  } = t0;
  const customizationController = useCustomizationController();
  let t1;
  if ($[0] !== customizationController.propertyConfigs || $[1] !== inputProperty || $[2] !== propertyKey) {
    t1 = resolveArrayProperty({
      propertyKey,
      property: inputProperty,
      propertyConfigs: customizationController.propertyConfigs
    });
    $[0] = customizationController.propertyConfigs;
    $[1] = inputProperty;
    $[2] = propertyKey;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const property2 = t1;
  if (Array.isArray(property2.of)) {
    throw Error("Using array properties instead of single one in `of` in ArrayProperty");
  }
  if (property2.dataType !== "array" || !property2.of || property2.of.dataType !== "string") {
    throw Error("Picked wrong preview component ArrayOfStorageComponentsPreview");
  }
  const childSize = size2 === "medium" ? "medium" : "small";
  let t2;
  if ($[4] !== childSize || $[5] !== property2.of || $[6] !== propertyKey || $[7] !== value) {
    t2 = value && value.map((v, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyPreview, { propertyKey, value: v, property: property2.of, size: childSize }) }, `preview_array_storage_${propertyKey}_${index2}`));
    $[4] = childSize;
    $[5] = property2.of;
    $[6] = propertyKey;
    $[7] = value;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  let t3;
  if ($[9] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-2", children: t2 });
    $[9] = t2;
    $[10] = t3;
  } else {
    t3 = $[10];
  }
  return t3;
}
function ArrayEnumPreview(t0) {
  const $ = c_1(7);
  const {
    name,
    value,
    enumValues,
    size: size2
  } = t0;
  let t1;
  if ($[0] !== enumValues || $[1] !== name || $[2] !== size2 || $[3] !== value) {
    t1 = value && value.map((enumKey, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(EnumValuesChip, { enumKey, enumValues, size: size2 !== "medium" ? "small" : "medium" }) }, `preview_array_ref_${name}_${index2}`));
    $[0] = enumValues;
    $[1] = name;
    $[2] = size2;
    $[3] = value;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  let t2;
  if ($[5] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-1.5", children: t1 });
    $[5] = t1;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  return t2;
}
function ArrayPropertyEnumPreview(t0) {
  const $ = c_1(5);
  const {
    propertyKey,
    value,
    property: property2,
    size: size2
  } = t0;
  if (property2.dataType !== "array") {
    throw Error("Picked wrong preview component ArrayEnumPreview");
  }
  const ofProperty = property2.of;
  if (!ofProperty.enumValues) {
    throw Error("Picked wrong preview component ArrayEnumPreview");
  }
  if (!value) {
    return null;
  }
  let t1;
  if ($[0] !== ofProperty.enumValues || $[1] !== propertyKey || $[2] !== size2 || $[3] !== value) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayEnumPreview, { name: propertyKey, value, enumValues: ofProperty.enumValues, size: size2 });
    $[0] = ofProperty.enumValues;
    $[1] = propertyKey;
    $[2] = size2;
    $[3] = value;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  return t1;
}
function ArrayOfStringsPreview(t0) {
  const $ = c_1(13);
  const {
    propertyKey,
    value,
    property: inputProperty,
    size: size2
  } = t0;
  const customizationController = useCustomizationController();
  let t1;
  if ($[0] !== customizationController.propertyConfigs || $[1] !== inputProperty || $[2] !== propertyKey) {
    t1 = resolveArrayProperty({
      propertyKey,
      property: inputProperty,
      propertyConfigs: customizationController.propertyConfigs
    });
    $[0] = customizationController.propertyConfigs;
    $[1] = inputProperty;
    $[2] = propertyKey;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const property2 = t1;
  if (Array.isArray(property2.of)) {
    throw Error("Using array properties instead of single one in `of` in ArrayProperty");
  }
  if (!property2.of || property2.dataType !== "array" || property2.of.dataType !== "string") {
    throw Error("Picked wrong preview component ArrayOfStringsPreview");
  }
  if (value && !Array.isArray(value)) {
    const t22 = `Unexpected value: ${value}`;
    let t32;
    if ($[4] !== t22) {
      t32 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t22 });
      $[4] = t22;
      $[5] = t32;
    } else {
      t32 = $[5];
    }
    return t32;
  }
  const stringProperty = property2.of;
  let t2;
  if ($[6] !== propertyKey || $[7] !== size2 || $[8] !== stringProperty || $[9] !== value) {
    t2 = value && value.map((v, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(StringPropertyPreview, { propertyKey, property: stringProperty, value: v, size: size2 }) }) }, `preview_array_strings_${propertyKey}_${index2}`));
    $[6] = propertyKey;
    $[7] = size2;
    $[8] = stringProperty;
    $[9] = value;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  let t3;
  if ($[11] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-2", children: t2 });
    $[11] = t2;
    $[12] = t3;
  } else {
    t3 = $[12];
  }
  return t3;
}
function ArrayOneOfPreview(t0) {
  const $ = c_1(14);
  const {
    propertyKey,
    value,
    property: inputProperty,
    size: size2
  } = t0;
  const customizationController = useCustomizationController();
  let t1;
  if ($[0] !== customizationController.propertyConfigs || $[1] !== inputProperty || $[2] !== propertyKey) {
    t1 = resolveArrayProperty({
      propertyKey,
      property: inputProperty,
      propertyConfigs: customizationController.propertyConfigs
    });
    $[0] = customizationController.propertyConfigs;
    $[1] = inputProperty;
    $[2] = propertyKey;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const property2 = t1;
  if (property2?.dataType !== "array") {
    throw Error("Picked wrong preview component ArrayPreview");
  }
  if (!property2?.oneOf) {
    throw Error(`You need to specify an 'of' or 'oneOf' prop (or specify a custom field) in your array property ${propertyKey}`);
  }
  const values = value;
  if (!values) {
    return null;
  }
  const childSize = size2 === "medium" ? "medium" : "small";
  const typeField = property2.oneOf.typeField ?? DEFAULT_ONE_OF_TYPE;
  const valueField = property2.oneOf.valueField ?? DEFAULT_ONE_OF_VALUE;
  const properties = property2.oneOf.properties;
  let t2;
  if ($[4] !== childSize || $[5] !== properties || $[6] !== property2.resolvedProperties || $[7] !== propertyKey || $[8] !== typeField || $[9] !== valueField || $[10] !== values) {
    t2 = values && values.map((value_0, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(React__default.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls(defaultBorderMixin, "m-1 border-b last:border-b-0 py-2"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: value_0 && /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyPreview, { propertyKey, value: value_0[valueField], property: property2.resolvedProperties[index2] ?? properties[value_0[typeField]], size: childSize }) }) }) }, "preview_array_" + value_0 + "_" + index2));
    $[4] = childSize;
    $[5] = properties;
    $[6] = property2.resolvedProperties;
    $[7] = propertyKey;
    $[8] = typeField;
    $[9] = valueField;
    $[10] = values;
    $[11] = t2;
  } else {
    t2 = $[11];
  }
  let t3;
  if ($[12] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col", children: t2 });
    $[12] = t2;
    $[13] = t3;
  } else {
    t3 = $[13];
  }
  return t3;
}
function MapPropertyPreview(t0) {
  const $ = c_1(12);
  const {
    value,
    property: property2,
    size: size2
  } = t0;
  if (property2.dataType !== "map") {
    throw Error("Picked wrong preview component MapPropertyPreview");
  }
  const mapProperty = property2;
  if (!mapProperty.properties || Object.keys(mapProperty.properties ?? {}).length === 0) {
    let t12;
    if ($[0] !== value) {
      t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(KeyValuePreview, { value });
      $[0] = value;
      $[1] = t12;
    } else {
      t12 = $[1];
    }
    return t12;
  }
  if (!value) {
    return null;
  }
  let t1;
  let t2;
  let t3;
  if ($[2] !== mapProperty.name || $[3] !== mapProperty.properties || $[4] !== size2 || $[5] !== value) {
    t3 = Symbol.for("react.early_return_sentinel");
    bb0: {
      const mapPropertyKeys = Object.keys(mapProperty.properties);
      if (size2 === "small") {
        t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full flex flex-col space-y-1 md:space-y-2", children: mapPropertyKeys.map((key, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyPreview, { propertyKey: key, value: value[key], property: mapProperty.properties[key], size: size2 }) }, "map_preview_" + mapProperty.name + key + index2) }, `map_${key}`)) });
        break bb0;
      }
      t1 = "flex flex-col gap-1 w-full";
      t2 = mapPropertyKeys && mapPropertyKeys.map((key_0, index_0) => {
        const childProperty = mapProperty.properties[key_0];
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cls(defaultBorderMixin, "last:border-b-0 border-b"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row pt-0.5 pb-0.5 gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-w-[140px] w-[25%] py-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", className: "font-mono break-words", color: "secondary", children: childProperty.name }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow max-w-[75%]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: !(childProperty.dataType === "map" || childProperty === "array") && /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyPreview, { propertyKey: key_0, value: value[key_0], property: childProperty, size: size2 }) }) })
          ] }),
          (childProperty.dataType === "map" || childProperty === "array") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls(defaultBorderMixin, "border-l pl-4 ml-2 my-2"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyPreview, { propertyKey: key_0, value: value[key_0], property: childProperty, size: size2 }) })
        ] }, `map_preview_table_${key_0}}`);
      });
    }
    $[2] = mapProperty.name;
    $[3] = mapProperty.properties;
    $[4] = size2;
    $[5] = value;
    $[6] = t1;
    $[7] = t2;
    $[8] = t3;
  } else {
    t1 = $[6];
    t2 = $[7];
    t3 = $[8];
  }
  if (t3 !== Symbol.for("react.early_return_sentinel")) {
    return t3;
  }
  let t4;
  if ($[9] !== t1 || $[10] !== t2) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t1, children: t2 });
    $[9] = t1;
    $[10] = t2;
    $[11] = t4;
  } else {
    t4 = $[11];
  }
  return t4;
}
function KeyValuePreview(t0) {
  const $ = c_1(5);
  const {
    value
  } = t0;
  if (typeof value !== "object") {
    return null;
  }
  if (!value) {
    let t12;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
      t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyValue, {});
      $[0] = t12;
    } else {
      t12 = $[0];
    }
    return t12;
  }
  let t1;
  if ($[1] !== value) {
    t1 = Object.entries(value).map(_temp$8);
    $[1] = value;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[3] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-1 w-full", children: t1 });
    $[3] = t1;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  return t2;
}
function _temp$8(t0) {
  const [key, childValue] = t0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cls(defaultBorderMixin, "last:border-b-0 border-b"), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row pt-0.5 pb-0.5 gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-w-[140px] w-[25%] py-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", className: "font-mono break-words", color: "secondary", children: key }) }, `table-cell-title-${key}-${key}`),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow max-w-[75%]", children: childValue && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: childValue.toString() }) }) })
    ] }),
    typeof childValue === "object" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls(defaultBorderMixin, "border-l pl-4"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(KeyValuePreview, { value: childValue }) })
  ] }, `map_preview_table_${key}}`);
}
function DatePreview(t0) {
  const $ = c_1(6);
  const {
    date: date2
  } = t0;
  const customizationController = useCustomizationController();
  const dateUtilsLocale = customizationController?.locale ? locales[customizationController?.locale] : void 0;
  const dateFormat = customizationController?.dateTimeFormat ?? defaultDateFormat;
  let t1;
  if ($[0] !== date2 || $[1] !== dateFormat || $[2] !== dateUtilsLocale) {
    t1 = date2 ? format(date2, dateFormat, {
      locale: dateUtilsLocale
    }) : "";
    $[0] = date2;
    $[1] = dateFormat;
    $[2] = dateUtilsLocale;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const formattedDate = t1;
  let t2;
  if ($[4] !== formattedDate) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: formattedDate });
    $[4] = formattedDate;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}
function BooleanPreview(t0) {
  const $ = c_1(9);
  const {
    value,
    size: size2,
    property: property2
  } = t0;
  let t1;
  if ($[0] !== size2 || $[1] !== value) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { checked: value, padding: false, size: size2, color: "secondary" });
    $[0] = size2;
    $[1] = value;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[3] !== property2.name || $[4] !== size2) {
    t2 = property2.name && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: cls("text-text-secondary dark:text-text-secondary-dark", size2 === "small" ? "text-sm" : ""), children: property2.name });
    $[3] = property2.name;
    $[4] = size2;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  let t3;
  if ($[6] !== t1 || $[7] !== t2) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row gap-2 items-center", children: [
      t1,
      t2
    ] });
    $[6] = t1;
    $[7] = t2;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  return t3;
}
function NumberPropertyPreview(t0) {
  const $ = c_1(10);
  const {
    value,
    property: property2,
    size: size2
  } = t0;
  if (property2.enumValues) {
    const enumKey = value;
    let t1;
    if ($[0] !== property2.enumValues) {
      t1 = enumToObjectEntries(property2.enumValues);
      $[0] = property2.enumValues;
      $[1] = t1;
    } else {
      t1 = $[1];
    }
    const enumValues = t1;
    if (!enumValues) {
      let t22;
      if ($[2] !== value) {
        t22 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: value });
        $[2] = value;
        $[3] = t22;
      } else {
        t22 = $[3];
      }
      return t22;
    }
    const t2 = size2 !== "medium" ? "small" : "medium";
    let t3;
    if ($[4] !== enumKey || $[5] !== enumValues || $[6] !== t2) {
      t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(EnumValuesChip, { enumKey, enumValues, size: t2 });
      $[4] = enumKey;
      $[5] = enumValues;
      $[6] = t2;
      $[7] = t3;
    } else {
      t3 = $[7];
    }
    return t3;
  } else {
    let t1;
    if ($[8] !== value) {
      t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: value });
      $[8] = value;
      $[9] = t1;
    } else {
      t1 = $[9];
    }
    return t1;
  }
}
const PropertyPreview = React__default.memo(function PropertyPreview2(props) {
  const $ = c_1(29);
  const customizationController = useCustomizationController();
  let content;
  const {
    property: inputProperty,
    propertyKey,
    value,
    size: size2,
    height,
    width,
    interactive
  } = props;
  if ($[0] !== customizationController.propertyConfigs || $[1] !== height || $[2] !== inputProperty || $[3] !== interactive || $[4] !== propertyKey || $[5] !== props || $[6] !== size2 || $[7] !== value || $[8] !== width) {
    const property2 = resolveProperty({
      propertyKey,
      propertyOrBuilder: inputProperty,
      propertyConfigs: customizationController.propertyConfigs
    });
    if (property2 === null) {
      let t02;
      if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
        t02 = /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyValue, {});
        $[10] = t02;
      } else {
        t02 = $[10];
      }
      content = t02;
    } else {
      if (property2.Preview) {
        content = createElement(property2.Preview, {
          propertyKey,
          value,
          property: property2,
          size: size2,
          height,
          width,
          customProps: property2.customProps
        });
      } else {
        if (value === void 0 || value === null) {
          let t02;
          if ($[11] === Symbol.for("react.memo_cache_sentinel")) {
            t02 = /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyValue, {});
            $[11] = t02;
          } else {
            t02 = $[11];
          }
          content = t02;
        } else {
          if (property2.dataType === "string") {
            const stringProperty = property2;
            if (typeof value === "string") {
              if (stringProperty.url) {
                if (typeof stringProperty.url === "boolean") {
                  let t02;
                  if ($[12] !== props.size || $[13] !== value) {
                    t02 = /* @__PURE__ */ jsxRuntimeExports.jsx(UrlComponentPreview, { size: props.size, url: value });
                    $[12] = props.size;
                    $[13] = value;
                    $[14] = t02;
                  } else {
                    t02 = $[14];
                  }
                  content = t02;
                } else {
                  if (typeof stringProperty.url === "string") {
                    content = /* @__PURE__ */ jsxRuntimeExports.jsx(UrlComponentPreview, { size: props.size, url: value, interactive, previewType: stringProperty.url });
                  }
                }
              } else {
                if (stringProperty.markdown) {
                  let t02;
                  if ($[15] !== value) {
                    t02 = /* @__PURE__ */ jsxRuntimeExports.jsx(Markdown, { source: value, size: "small" });
                    $[15] = value;
                    $[16] = t02;
                  } else {
                    t02 = $[16];
                  }
                  content = t02;
                } else {
                  if (stringProperty.storage) {
                    const filePath = stringProperty.storage.previewUrl ? stringProperty.storage.previewUrl(value) : value;
                    const t02 = property2.storage?.storeUrl ?? false;
                    let t1;
                    if ($[17] !== filePath || $[18] !== interactive || $[19] !== props.size || $[20] !== t02) {
                      t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(StorageThumbnail, { interactive, storeUrl: t02, size: props.size, storagePathOrDownloadUrl: filePath });
                      $[17] = filePath;
                      $[18] = interactive;
                      $[19] = props.size;
                      $[20] = t02;
                      $[21] = t1;
                    } else {
                      t1 = $[21];
                    }
                    content = t1;
                  } else {
                    content = /* @__PURE__ */ jsxRuntimeExports.jsx(StringPropertyPreview, { ...props, property: stringProperty, value });
                  }
                }
              }
            } else {
              content = buildWrongValueType(propertyKey, property2.dataType, value);
            }
          } else {
            if (property2.dataType === "array") {
              if (value instanceof Array) {
                const arrayProperty = property2;
                if (!arrayProperty.of && !arrayProperty.oneOf) {
                  throw Error(`You need to specify an 'of' or 'oneOf' prop (or specify a custom field) in your array property ${propertyKey}`);
                }
                if (arrayProperty.of) {
                  if (Array.isArray(arrayProperty.of)) {
                    content = /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayPropertyPreview, { ...props, value, property: property2 });
                  } else {
                    if (arrayProperty.of.dataType === "reference") {
                      content = /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayOfReferencesPreview, { ...props, value, property: property2 });
                    } else {
                      if (arrayProperty.of.dataType === "string") {
                        if (arrayProperty.of.enumValues) {
                          content = /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayPropertyEnumPreview, { ...props, value, property: property2 });
                        } else {
                          if (arrayProperty.of.storage) {
                            content = /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayOfStorageComponentsPreview, { ...props, value, property: property2 });
                          } else {
                            content = /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayOfStringsPreview, { ...props, value, property: property2 });
                          }
                        }
                      } else {
                        if (arrayProperty.of.dataType === "number" && arrayProperty.of.enumValues) {
                          content = /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayPropertyEnumPreview, { ...props, value, property: property2 });
                        } else {
                          content = /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayPropertyPreview, { ...props, value, property: property2 });
                        }
                      }
                    }
                  }
                } else {
                  if (arrayProperty.oneOf) {
                    content = /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayOneOfPreview, { ...props, value, property: property2 });
                  }
                }
              } else {
                content = buildWrongValueType(propertyKey, property2.dataType, value);
              }
            } else {
              if (property2.dataType === "map") {
                if (typeof value === "object") {
                  content = /* @__PURE__ */ jsxRuntimeExports.jsx(MapPropertyPreview, { ...props, property: property2 });
                } else {
                  content = buildWrongValueType(propertyKey, property2.dataType, value);
                }
              } else {
                if (property2.dataType === "date") {
                  if (value instanceof Date) {
                    let t02;
                    if ($[22] !== value) {
                      t02 = /* @__PURE__ */ jsxRuntimeExports.jsx(DatePreview, { date: value });
                      $[22] = value;
                      $[23] = t02;
                    } else {
                      t02 = $[23];
                    }
                    content = t02;
                  } else {
                    content = buildWrongValueType(propertyKey, property2.dataType, value);
                  }
                } else {
                  if (property2.dataType === "reference") {
                    if (typeof property2.path === "string") {
                      if (typeof value === "object" && "isEntityReference" in value && value.isEntityReference()) {
                        content = /* @__PURE__ */ jsxRuntimeExports.jsx(ReferencePreview, { disabled: !property2.path, previewProperties: property2.previewProperties, includeId: property2.includeId, includeEntityLink: property2.includeEntityLink, size: props.size, reference: value });
                      } else {
                        content = buildWrongValueType(propertyKey, property2.dataType, value);
                      }
                    } else {
                      let t02;
                      if ($[24] === Symbol.for("react.memo_cache_sentinel")) {
                        t02 = /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyValue, {});
                        $[24] = t02;
                      } else {
                        t02 = $[24];
                      }
                      content = t02;
                    }
                  } else {
                    if (property2.dataType === "boolean") {
                      if (typeof value === "boolean") {
                        content = /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanPreview, { value, size: size2, property: property2 });
                      } else {
                        content = buildWrongValueType(propertyKey, property2.dataType, value);
                      }
                    } else {
                      if (property2.dataType === "number") {
                        if (typeof value === "number") {
                          content = /* @__PURE__ */ jsxRuntimeExports.jsx(NumberPropertyPreview, { ...props, value, property: property2 });
                        } else {
                          content = buildWrongValueType(propertyKey, property2.dataType, value);
                        }
                      } else {
                        let t02;
                        if ($[25] !== value) {
                          t02 = JSON.stringify(value);
                          $[25] = value;
                          $[26] = t02;
                        } else {
                          t02 = $[26];
                        }
                        content = t02;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    $[0] = customizationController.propertyConfigs;
    $[1] = height;
    $[2] = inputProperty;
    $[3] = interactive;
    $[4] = propertyKey;
    $[5] = props;
    $[6] = size2;
    $[7] = value;
    $[8] = width;
    $[9] = content;
  } else {
    content = $[9];
  }
  let t0;
  if ($[27] !== content) {
    t0 = content === void 0 || content === null || Array.isArray(content) && content.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyValue, {}) : content;
    $[27] = content;
    $[28] = t0;
  } else {
    t0 = $[28];
  }
  return t0;
}, equal);
function buildWrongValueType(name, dataType, value) {
  console.warn(`Unexpected value for property ${name}, of type ${dataType}`, value);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView, { title: "Unexpected value", error: `${JSON.stringify(value)}` });
}
function ArrayOfMapsPreview(t0) {
  const $ = c_1(13);
  const {
    propertyKey,
    value,
    property: inputProperty,
    size: size2
  } = t0;
  const customizationController = useCustomizationController();
  const t1 = customizationController.propertyConfigs;
  let t2;
  let t3;
  let t4;
  if ($[0] !== customizationController.propertyConfigs || $[1] !== inputProperty || $[2] !== propertyKey || $[3] !== size2 || $[4] !== value) {
    t4 = Symbol.for("react.early_return_sentinel");
    bb0: {
      const property2 = resolveArrayProperty({
        propertyKey,
        property: inputProperty,
        propertyConfigs: t1
      });
      if (Array.isArray(property2?.of)) {
        throw Error("Using array properties instead of single one in `of` in ArrayProperty");
      }
      if (property2?.dataType !== "array" || !property2.of || property2.of.dataType !== "map") {
        throw Error("Picked wrong preview component ArrayOfMapsPreview");
      }
      const mapProperty = property2.of;
      const properties = mapProperty.properties;
      if (!properties) {
        throw Error(`You need to specify a 'properties' prop (or specify a custom field) in your map property ${propertyKey}`);
      }
      const values = value;
      const previewProperties = mapProperty.previewProperties;
      if (!values) {
        t4 = null;
        break bb0;
      }
      let mapProperties;
      mapProperties = previewProperties;
      if (!mapProperties || !mapProperties.length) {
        mapProperties = Object.keys(properties);
        if (size2) {
          mapProperties = mapProperties.slice(0, 3);
        }
      }
      t3 = "table-auto text-xs";
      t2 = values && values.map((v, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border-b last:border-b-0 py-2", children: mapProperties && mapProperties.map((key) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "table-cell", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyPreview, { propertyKey: key, value: v[key], property: properties[key], size: "small" }) }) }, `table-cell-${key}`)) }, `table_${v}_${index2}`));
    }
    $[0] = customizationController.propertyConfigs;
    $[1] = inputProperty;
    $[2] = propertyKey;
    $[3] = size2;
    $[4] = value;
    $[5] = t2;
    $[6] = t3;
    $[7] = t4;
  } else {
    t2 = $[5];
    t3 = $[6];
    t4 = $[7];
  }
  if (t4 !== Symbol.for("react.early_return_sentinel")) {
    return t4;
  }
  let t5;
  if ($[8] !== t2) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t2 });
    $[8] = t2;
    $[9] = t5;
  } else {
    t5 = $[9];
  }
  let t6;
  if ($[10] !== t3 || $[11] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t3, children: t5 });
    $[10] = t3;
    $[11] = t5;
    $[12] = t6;
  } else {
    t6 = $[12];
  }
  return t6;
}
const AsyncPreviewComponent = React.memo(function AsyncPreviewComponentInternal(t0) {
  const $ = c_1(6);
  const {
    builder
  } = t0;
  const [loading, setLoading] = useState(true);
  const [result, setResult] = useState(null);
  let t1;
  let t2;
  if ($[0] !== builder) {
    t1 = () => {
      let unmounted;
      unmounted = false;
      builder.then((res) => {
        if (!unmounted) {
          setLoading(false);
          setResult(res);
        }
      }).catch((error) => {
        setLoading(false);
        console.error(error);
      });
      return () => {
        unmounted = true;
      };
    };
    t2 = [builder];
    $[0] = builder;
    $[1] = t1;
    $[2] = t2;
  } else {
    t1 = $[1];
    t2 = $[2];
  }
  useEffect(t1, t2);
  if (loading) {
    let t32;
    if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
      t32 = /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, {});
      $[3] = t32;
    } else {
      t32 = $[3];
    }
    return t32;
  }
  let t3;
  if ($[4] !== result) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, { children: result });
    $[4] = result;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  return t3;
});
function SelectFieldBinding(t0) {
  const $ = c_1(46);
  const {
    propertyKey,
    value,
    setValue,
    error,
    showError,
    disabled,
    property: property2,
    includeDescription,
    size: t1
  } = t0;
  const size2 = t1 === void 0 ? "large" : t1;
  let t2;
  if ($[0] !== property2.enumValues) {
    t2 = property2.enumValues ?? [];
    $[0] = property2.enumValues;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  const enumValues = resolveEnumValues(t2);
  let t3;
  if ($[2] !== property2 || $[3] !== setValue || $[4] !== value) {
    t3 = {
      property: property2,
      value,
      setValue
    };
    $[2] = property2;
    $[3] = setValue;
    $[4] = value;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  useClearRestoreValue(t3);
  let t4;
  if ($[6] !== setValue) {
    t4 = (e2) => {
      e2.stopPropagation();
      e2.preventDefault();
      setValue(null);
    };
    $[6] = setValue;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  const handleClearClick = t4;
  const T0 = Select;
  let t5;
  if ($[8] !== value) {
    t5 = value !== void 0 && value != null ? value.toString() : "";
    $[8] = value;
    $[9] = t5;
  } else {
    t5 = $[9];
  }
  const t6 = true;
  const t7 = "item-aligned";
  let t8;
  if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = cls("w-full");
    $[10] = t8;
  } else {
    t8 = $[10];
  }
  let t9;
  if ($[11] !== property2) {
    t9 = getIconForProperty(property2, "small");
    $[11] = property2;
    $[12] = t9;
  } else {
    t9 = $[12];
  }
  const t10 = property2.validation?.required;
  let t11;
  if ($[13] !== property2.name || $[14] !== t10 || $[15] !== t9) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx(LabelWithIcon, { icon: t9, required: t10, title: property2.name, className: "text-text-secondary dark:text-text-secondary-dark ml-3.5" });
    $[13] = property2.name;
    $[14] = t10;
    $[15] = t9;
    $[16] = t11;
  } else {
    t11 = $[16];
  }
  let t12;
  if ($[17] !== propertyKey || $[18] !== t11) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyIdCopyTooltip, { propertyKey, children: t11 });
    $[17] = propertyKey;
    $[18] = t11;
    $[19] = t12;
  } else {
    t12 = $[19];
  }
  let t13;
  if ($[20] !== handleClearClick || $[21] !== property2.clearable) {
    t13 = property2.clearable && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: handleClearClick, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {}) });
    $[20] = handleClearClick;
    $[21] = property2.clearable;
    $[22] = t13;
  } else {
    t13 = $[22];
  }
  let t14;
  if ($[23] !== property2.dataType || $[24] !== setValue) {
    t14 = (updatedValue) => {
      const newValue = updatedValue ? property2.dataType === "number" ? parseFloat(updatedValue) : updatedValue : null;
      return setValue(newValue);
    };
    $[23] = property2.dataType;
    $[24] = setValue;
    $[25] = t14;
  } else {
    t14 = $[25];
  }
  const t15 = (enumKey) => /* @__PURE__ */ jsxRuntimeExports.jsx(EnumValuesChip, { enumKey, enumValues, size: size2 });
  const t16 = enumValues && enumValues.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: String(option.id), children: /* @__PURE__ */ jsxRuntimeExports.jsx(EnumValuesChip, { enumKey: String(option.id), enumValues, size: size2 }) }, option.id));
  let t17;
  if ($[26] !== T0 || $[27] !== disabled || $[28] !== size2 || $[29] !== t12 || $[30] !== t13 || $[31] !== t14 || $[32] !== t15 || $[33] !== t16 || $[34] !== t5 || $[35] !== t8) {
    t17 = /* @__PURE__ */ jsxRuntimeExports.jsx(T0, { value: t5, disabled, size: size2, fullWidth: t6, position: t7, inputClassName: t8, label: t12, endAdornment: t13, onValueChange: t14, renderValue: t15, children: t16 });
    $[26] = T0;
    $[27] = disabled;
    $[28] = size2;
    $[29] = t12;
    $[30] = t13;
    $[31] = t14;
    $[32] = t15;
    $[33] = t16;
    $[34] = t5;
    $[35] = t8;
    $[36] = t17;
  } else {
    t17 = $[36];
  }
  let t18;
  if ($[37] !== disabled || $[38] !== error || $[39] !== includeDescription || $[40] !== property2 || $[41] !== showError) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldHelperText, { includeDescription, showError, error, disabled, property: property2 });
    $[37] = disabled;
    $[38] = error;
    $[39] = includeDescription;
    $[40] = property2;
    $[41] = showError;
    $[42] = t18;
  } else {
    t18 = $[42];
  }
  let t19;
  if ($[43] !== t17 || $[44] !== t18) {
    t19 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t17,
      t18
    ] });
    $[43] = t17;
    $[44] = t18;
    $[45] = t19;
  } else {
    t19 = $[45];
  }
  return t19;
}
function MultiSelectFieldBinding({
  propertyKey,
  value,
  setValue,
  error,
  showError,
  disabled,
  property: property2,
  includeDescription,
  size: size2 = "medium",
  autoFocus
}) {
  const of = property2.of;
  if (!of) {
    throw Error("Using wrong component ArrayEnumSelect");
  }
  if (Array.isArray(of)) {
    throw Error("Using array properties instead of single one in `of` in ArrayProperty");
  }
  if (of.dataType !== "string" && of.dataType !== "number") {
    throw Error("Field misconfiguration: array field of type string or number");
  }
  const enumValues = enumToObjectEntries(of.enumValues);
  if (!enumValues) {
    console.error(property2);
    throw Error("Field misconfiguration: array field of type string or number needs to have enumValues");
  }
  useClearRestoreValue({
    property: property2,
    value,
    setValue
  });
  const validValue = !!value && Array.isArray(value);
  const renderValue = useCallback((enumKey, list) => {
    const enumValue = enumKey !== void 0 ? getLabelOrConfigFrom(enumValues, enumKey) : void 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(EnumValuesChip, { enumKey, enumValues, size: "medium", children: [
      enumValue?.label ?? enumKey,
      !list && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "ml-1 ring-offset-background rounded-full outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2", onMouseDown: (e2) => {
        e2.preventDefault();
        e2.stopPropagation();
      }, onClick: (e_0) => {
        e_0.preventDefault();
        e_0.stopPropagation();
        setValue(value.filter((v) => v !== enumKey));
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, { size: "smallest" }) })
    ] }, enumKey);
  }, [enumValues, setValue, value]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSelect, { className: "w-full mt-2", size: size2 === "medium" ? "medium" : "small", value: validValue ? value.map((v_0) => v_0.toString()) : [], disabled, modalPopover: true, label: /* @__PURE__ */ jsxRuntimeExports.jsx(LabelWithIconAndTooltip, { propertyKey, icon: getIconForProperty(property2, "small"), required: property2.validation?.required, title: property2.name, className: "text-text-secondary dark:text-text-secondary-dark ml-3.5" }), onValueChange: (updatedValue) => {
      let newValue;
      if (of && of?.dataType === "number") {
        newValue = updatedValue ? updatedValue.map((e_1) => parseFloat(e_1)) : [];
      } else {
        newValue = updatedValue;
      }
      return setValue(newValue);
    }, children: enumValues.map((enumValue_0) => String(enumValue_0.id)).map((enumKey_0) => /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSelectItem, { value: enumKey_0, children: renderValue(enumKey_0, true) }, enumKey_0)) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FieldHelperText, { includeDescription, showError, error, disabled, property: property2 })
  ] });
}
function ArrayOfReferencesFieldBinding({
  propertyKey,
  value,
  error,
  showError,
  disabled,
  isSubmitting,
  minimalistView,
  property: property2,
  includeDescription,
  setValue,
  setFieldValue
}) {
  const ofProperty = property2.of;
  if (ofProperty.dataType !== "reference") {
    throw Error("ArrayOfReferencesField expected a property containing references");
  }
  const expanded = property2.expanded === void 0 ? true : property2.expanded;
  const selectedEntityIds = value && Array.isArray(value) ? value.map((ref) => ref.id) : [];
  useClearRestoreValue({
    property: property2,
    value,
    setValue
  });
  const navigationController = useNavigationController();
  const collection = useMemo(() => {
    return ofProperty.path ? navigationController.getCollection(ofProperty.path) : void 0;
  }, [ofProperty.path]);
  if (!collection) {
    throw Error(`Couldn't find the corresponding collection for the path: ${ofProperty.path}`);
  }
  const onMultipleEntitiesSelected = useCallback((entities) => {
    setValue(entities.map((e2) => getReferenceFrom(e2)));
  }, [setValue]);
  const referenceDialogController = useReferenceDialog({
    multiselect: true,
    path: ofProperty.path,
    collection,
    onMultipleEntitiesSelected,
    selectedEntityIds,
    forceFilter: ofProperty.forceFilter
  });
  const onEntryClick = (e_0) => {
    e_0.preventDefault();
    referenceDialogController.open();
  };
  const buildEntry = useCallback(({
    index: index2,
    internalId,
    storedProps,
    storeProps
  }) => {
    const entryValue = value && value.length > index2 ? value[index2] : void 0;
    if (!entryValue) return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Internal ERROR" });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ReferencePreview, { disabled: !ofProperty.path, previewProperties: ofProperty.previewProperties, size: "medium", onClick: onEntryClick, hover: !disabled, reference: entryValue, includeId: ofProperty.includeId, includeEntityLink: ofProperty.includeEntityLink }, internalId);
  }, [ofProperty.path, ofProperty.previewProperties, value]);
  const title = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(LabelWithIconAndTooltip, { propertyKey, icon: getIconForProperty(property2, "small"), required: property2.validation?.required, title: property2.name, className: "flex flex-grow text-text-secondary dark:text-text-secondary-dark" }),
    Array.isArray(value) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", className: "px-4", children: [
      "(",
      value.length,
      ")"
    ] })
  ] });
  const body = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    !collection && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView, { error: "The specified collection does not exist. Check console" }),
    collection && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "group", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayContainer, { droppableId: propertyKey, value, disabled: isSubmitting, buildEntry, addLabel: property2.name ? "Add reference to " + property2.name : "Add reference", newDefaultEntry: property2.of.defaultValue, onValueChange: (value_0) => setFieldValue(propertyKey, value_0) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { className: "my-4 justify-center text-left", variant: "text", color: "primary", disabled: isSubmitting, onClick: onEntryClick, children: [
        "Edit ",
        property2.name
      ] })
    ] })
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    !minimalistView && /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandablePanel, { titleClassName: fieldBackgroundMixin, innerClassName: cls("px-2 md:px-4 pb-2 md:pb-4 pt-1 md:pt-2", fieldBackgroundMixin), initiallyExpanded: expanded, title, children: body }),
    minimalistView && body,
    /* @__PURE__ */ jsxRuntimeExports.jsx(FieldHelperText, { includeDescription, showError, error, disabled, property: property2 })
  ] });
}
function StorageItemPreview(t0) {
  const $ = c_1(21);
  const {
    name,
    property: property2,
    value,
    onRemove,
    disabled,
    size: size2,
    placeholder: placeholder2,
    className
  } = t0;
  const t1 = size2 === "large" ? "min-w-[220px] min-h-[220px] max-w-[220px]" : "min-w-[118px] min-h-[118px] max-w-[118px]";
  let t2;
  if ($[0] !== className || $[1] !== t1) {
    t2 = cls(paperMixin, "relative m-4 border-box flex items-center justify-center", t1, className);
    $[0] = className;
    $[1] = t1;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  let t3;
  if ($[3] !== disabled || $[4] !== onRemove || $[5] !== placeholder2 || $[6] !== value) {
    t3 = !placeholder2 && !disabled && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute rounded-full -top-2 -right-2 z-10 bg-white dark:bg-surface-900", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { asChild: true, title: "Remove", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { size: "small", onClick: (event) => {
      event.stopPropagation();
      onRemove(value);
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RemoveIcon, { size: "small" }) }) }) });
    $[3] = disabled;
    $[4] = onRemove;
    $[5] = placeholder2;
    $[6] = value;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  let t4;
  if ($[8] !== name || $[9] !== placeholder2 || $[10] !== property2 || $[11] !== size2 || $[12] !== value) {
    t4 = !placeholder2 && value && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyPreview, { propertyKey: name, value, property: property2, interactive: false, size: size2 }) });
    $[8] = name;
    $[9] = placeholder2;
    $[10] = property2;
    $[11] = size2;
    $[12] = value;
    $[13] = t4;
  } else {
    t4 = $[13];
  }
  let t5;
  if ($[14] !== placeholder2) {
    t5 = placeholder2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: _temp$7, className: "flex flex-col items-center justify-center w-full h-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DescriptionIcon, { className: "text-surface-700 dark:text-surface-300" }) });
    $[14] = placeholder2;
    $[15] = t5;
  } else {
    t5 = $[15];
  }
  let t6;
  if ($[16] !== t2 || $[17] !== t3 || $[18] !== t4 || $[19] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t2, children: [
      t3,
      t4,
      t5
    ] });
    $[16] = t2;
    $[17] = t3;
    $[18] = t4;
    $[19] = t5;
    $[20] = t6;
  } else {
    t6 = $[20];
  }
  return t6;
}
function _temp$7(e2) {
  return e2.stopPropagation();
}
const dropZoneClasses = "box-border relative pt-[2px] items-center border border-transparent min-h-[254px] outline-none rounded-md duration-200 ease-[cubic-bezier(0.4,0,0.2,1)] focus:border-primary-solid";
const disabledClasses = "border-dotted-gray";
const nonActiveDropClasses = fieldBackgroundHoverMixin;
const activeDropClasses = "pt-0 border-2 border-solid";
const acceptDropClasses = "transition-colors duration-200 ease-[cubic-bezier(0,0,0.2,1)] border-2 border-solid border-green-500";
const rejectDropClasses = "transition-colors duration-200 ease-[cubic-bezier(0,0,0.2,1)] border-2 border-solid border-red-500";
function StorageUploadFieldBinding(t0) {
  const $ = c_1(46);
  const {
    propertyKey,
    value,
    setValue,
    error,
    showError,
    autoFocus,
    minimalistView,
    property: property2,
    includeDescription,
    context,
    isSubmitting
  } = t0;
  if (!context.entityId) {
    throw new Error("StorageUploadFieldBinding: Entity id is null");
  }
  const storageSource = useStorageSource(context.collection);
  let t1;
  if ($[0] !== isSubmitting || $[1] !== property2) {
    t1 = isReadOnly(property2) || !!property2.disabled || isSubmitting;
    $[0] = isSubmitting;
    $[1] = property2;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const disabled = t1;
  const t2 = disabled ?? false;
  let t3;
  if ($[3] !== context.entityId || $[4] !== context.path || $[5] !== context.values || $[6] !== property2 || $[7] !== propertyKey || $[8] !== setValue || $[9] !== storageSource || $[10] !== t2 || $[11] !== value) {
    t3 = {
      entityValues: context.values,
      entityId: context.entityId,
      path: context.path,
      property: property2,
      propertyKey,
      value,
      storageSource,
      disabled: t2,
      onChange: setValue
    };
    $[3] = context.entityId;
    $[4] = context.path;
    $[5] = context.values;
    $[6] = property2;
    $[7] = propertyKey;
    $[8] = setValue;
    $[9] = storageSource;
    $[10] = t2;
    $[11] = value;
    $[12] = t3;
  } else {
    t3 = $[12];
  }
  const {
    internalValue,
    setInternalValue,
    onFilesAdded,
    storage,
    onFileUploadComplete,
    storagePathBuilder,
    multipleFilesSupported
  } = useStorageUploadController(t3);
  let t4;
  if ($[13] !== property2 || $[14] !== setValue || $[15] !== value) {
    t4 = {
      property: property2,
      value,
      setValue
    };
    $[13] = property2;
    $[14] = setValue;
    $[15] = value;
    $[16] = t4;
  } else {
    t4 = $[16];
  }
  useClearRestoreValue(t4);
  const t5 = property2;
  let t6;
  if ($[17] !== t5) {
    t6 = resolveProperty({
      propertyOrBuilder: t5
    });
    $[17] = t5;
    $[18] = t6;
  } else {
    t6 = $[18];
  }
  const resolvedProperty = t6;
  let t7;
  if ($[19] !== minimalistView || $[20] !== property2 || $[21] !== propertyKey) {
    t7 = !minimalistView && /* @__PURE__ */ jsxRuntimeExports.jsx(LabelWithIconAndTooltip, { propertyKey, icon: getIconForProperty(property2, "small"), required: property2.validation?.required, title: property2.name, className: "text-text-secondary dark:text-text-secondary-dark ml-3.5" });
    $[19] = minimalistView;
    $[20] = property2;
    $[21] = propertyKey;
    $[22] = t7;
  } else {
    t7 = $[22];
  }
  const t8 = disabled ?? false;
  const t9 = autoFocus ?? false;
  let t10;
  if ($[23] !== internalValue || $[24] !== multipleFilesSupported || $[25] !== onFileUploadComplete || $[26] !== onFilesAdded || $[27] !== propertyKey || $[28] !== resolvedProperty || $[29] !== setInternalValue || $[30] !== setValue || $[31] !== storage || $[32] !== storagePathBuilder || $[33] !== t8 || $[34] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(StorageUpload, { value: internalValue, name: propertyKey, disabled: t8, autoFocus: t9, property: resolvedProperty, onChange: setValue, setInternalValue, onFilesAdded, onFileUploadComplete, storagePathBuilder, storage, multipleFilesSupported });
    $[23] = internalValue;
    $[24] = multipleFilesSupported;
    $[25] = onFileUploadComplete;
    $[26] = onFilesAdded;
    $[27] = propertyKey;
    $[28] = resolvedProperty;
    $[29] = setInternalValue;
    $[30] = setValue;
    $[31] = storage;
    $[32] = storagePathBuilder;
    $[33] = t8;
    $[34] = t9;
    $[35] = t10;
  } else {
    t10 = $[35];
  }
  let t11;
  if ($[36] !== disabled || $[37] !== error || $[38] !== includeDescription || $[39] !== property2 || $[40] !== showError) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldHelperText, { includeDescription, showError, error, disabled, property: property2 });
    $[36] = disabled;
    $[37] = error;
    $[38] = includeDescription;
    $[39] = property2;
    $[40] = showError;
    $[41] = t11;
  } else {
    t11 = $[41];
  }
  let t12;
  if ($[42] !== t10 || $[43] !== t11 || $[44] !== t7) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t7,
      t10,
      t11
    ] });
    $[42] = t10;
    $[43] = t11;
    $[44] = t7;
    $[45] = t12;
  } else {
    t12 = $[45];
  }
  return t12;
}
function FileDropComponent(t0) {
  const $ = c_1(62);
  const {
    storage,
    disabled,
    isDraggingOver,
    onFilesAdded,
    multipleFilesSupported,
    droppableProvided,
    autoFocus,
    internalValue,
    property: property2,
    onClear,
    metadata,
    storagePathBuilder,
    onFileUploadComplete,
    size: size2,
    name,
    helpText
  } = t0;
  const snackbarContext = useSnackbarController();
  let t1;
  if ($[0] !== storage.acceptedFiles) {
    t1 = storage.acceptedFiles ? storage.acceptedFiles.map(_temp$6).reduce(_temp2$3, {}) : void 0;
    $[0] = storage.acceptedFiles;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const t2 = disabled || isDraggingOver;
  let t3;
  if ($[2] !== snackbarContext || $[3] !== storage.maxSize) {
    t3 = (fileRejections, event) => {
      for (const fileRejection of fileRejections) {
        for (const error of fileRejection.errors) {
          console.error("Error uploading file: ", error);
          if (error.code === "file-too-large") {
            snackbarContext.open({
              type: "error",
              message: `Error uploading file: File is larger than ${storage.maxSize} bytes`
            });
          } else {
            if (error.code === "file-invalid-type") {
              snackbarContext.open({
                type: "error",
                message: "Error uploading file: File type is not supported"
              });
            }
          }
        }
      }
    };
    $[2] = snackbarContext;
    $[3] = storage.maxSize;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== onFilesAdded || $[6] !== storage.maxSize || $[7] !== t1 || $[8] !== t2 || $[9] !== t3) {
    t4 = {
      accept: t1,
      disabled: t2,
      noDragEventsBubbling: true,
      maxSize: storage.maxSize,
      onDrop: onFilesAdded,
      onDropRejected: t3
    };
    $[5] = onFilesAdded;
    $[6] = storage.maxSize;
    $[7] = t1;
    $[8] = t2;
    $[9] = t3;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  const {
    getRootProps,
    getInputProps,
    isDragActive,
    isDragAccept,
    isDragReject
  } = useDropzone(t4);
  let t5;
  if ($[11] !== getRootProps) {
    t5 = getRootProps();
    $[11] = getRootProps;
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  const t6 = disabled ? fieldBackgroundDisabledMixin : fieldBackgroundHoverMixin;
  const t7 = multipleFilesSupported && internalValue.length ? "" : "flex";
  const t8 = !isDragActive;
  let t9;
  if ($[13] !== disabled || $[14] !== isDragAccept || $[15] !== isDragActive || $[16] !== isDragReject || $[17] !== t6 || $[18] !== t7 || $[19] !== t8) {
    t9 = cls(fieldBackgroundMixin, t6, dropZoneClasses, t7, {
      [nonActiveDropClasses]: t8,
      [activeDropClasses]: isDragActive,
      [rejectDropClasses]: isDragReject,
      [acceptDropClasses]: isDragAccept,
      [disabledClasses]: disabled
    });
    $[13] = disabled;
    $[14] = isDragAccept;
    $[15] = isDragActive;
    $[16] = isDragReject;
    $[17] = t6;
    $[18] = t7;
    $[19] = t8;
    $[20] = t9;
  } else {
    t9 = $[20];
  }
  const t10 = droppableProvided.droppableProps;
  const t11 = droppableProvided.innerRef;
  const t12 = multipleFilesSupported && internalValue.length ? "overflow-auto" : "";
  const t13 = multipleFilesSupported && internalValue.length ? "min-h-[180px]" : "min-h-[250px]";
  let t14;
  if ($[21] !== t12 || $[22] !== t13) {
    t14 = cls("flex items-center p-1 no-scrollbar", t12, t13);
    $[21] = t12;
    $[22] = t13;
    $[23] = t14;
  } else {
    t14 = $[23];
  }
  let t15;
  if ($[24] !== getInputProps) {
    t15 = getInputProps();
    $[24] = getInputProps;
    $[25] = t15;
  } else {
    t15 = $[25];
  }
  let t16;
  if ($[26] !== autoFocus || $[27] !== t15) {
    t16 = /* @__PURE__ */ jsxRuntimeExports.jsx("input", { autoFocus, ...t15 });
    $[26] = autoFocus;
    $[27] = t15;
    $[28] = t16;
  } else {
    t16 = $[28];
  }
  let t17;
  if ($[29] !== disabled || $[30] !== internalValue || $[31] !== metadata || $[32] !== name || $[33] !== onClear || $[34] !== onFileUploadComplete || $[35] !== property2 || $[36] !== size2 || $[37] !== storagePathBuilder) {
    let t182;
    if ($[39] !== disabled || $[40] !== metadata || $[41] !== name || $[42] !== onClear || $[43] !== onFileUploadComplete || $[44] !== property2 || $[45] !== size2 || $[46] !== storagePathBuilder) {
      t182 = (entry, index2) => {
        let child;
        if (entry.storagePathOrDownloadUrl) {
          child = /* @__PURE__ */ jsxRuntimeExports.jsx(StorageItemPreview, { name: `storage_preview_${entry.storagePathOrDownloadUrl}`, property: property2, disabled, value: entry.storagePathOrDownloadUrl, onRemove: onClear, size: entry.size });
        } else {
          if (entry.file) {
            child = /* @__PURE__ */ jsxRuntimeExports.jsx(StorageUploadProgress, { entry, metadata, storagePath: storagePathBuilder(entry.file), onFileUploadComplete, imageSize: size2 === "medium" ? 220 : 118, simple: false });
          }
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(PublicDraggable, { draggableId: `array_field_${name}_${entry.id}`, index: index2, children: (provided, snapshot) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { tabIndex: -1, ref: provided.innerRef, ...provided.draggableProps, ...provided.dragHandleProps, className: cls("rounded-md"), style: {
          ...provided.draggableProps.style
        }, children: child }) }, `array_field_${name}_${entry.id}`);
      };
      $[39] = disabled;
      $[40] = metadata;
      $[41] = name;
      $[42] = onClear;
      $[43] = onFileUploadComplete;
      $[44] = property2;
      $[45] = size2;
      $[46] = storagePathBuilder;
      $[47] = t182;
    } else {
      t182 = $[47];
    }
    t17 = internalValue.map(t182);
    $[29] = disabled;
    $[30] = internalValue;
    $[31] = metadata;
    $[32] = name;
    $[33] = onClear;
    $[34] = onFileUploadComplete;
    $[35] = property2;
    $[36] = size2;
    $[37] = storagePathBuilder;
    $[38] = t17;
  } else {
    t17 = $[38];
  }
  let t18;
  if ($[48] !== droppableProvided.droppableProps || $[49] !== droppableProvided.innerRef || $[50] !== droppableProvided.placeholder || $[51] !== t14 || $[52] !== t16 || $[53] !== t17) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ...t10, ref: t11, className: t14, children: [
      t16,
      t17,
      droppableProvided.placeholder
    ] });
    $[48] = droppableProvided.droppableProps;
    $[49] = droppableProvided.innerRef;
    $[50] = droppableProvided.placeholder;
    $[51] = t14;
    $[52] = t16;
    $[53] = t17;
    $[54] = t18;
  } else {
    t18 = $[54];
  }
  let t19;
  if ($[55] !== helpText) {
    t19 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow min-h-[38px] box-border m-2 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { align: "center", variant: "label", children: helpText }) });
    $[55] = helpText;
    $[56] = t19;
  } else {
    t19 = $[56];
  }
  let t20;
  if ($[57] !== t18 || $[58] !== t19 || $[59] !== t5 || $[60] !== t9) {
    t20 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ...t5, className: t9, children: [
      t18,
      t19
    ] });
    $[57] = t18;
    $[58] = t19;
    $[59] = t5;
    $[60] = t9;
    $[61] = t20;
  } else {
    t20 = $[61];
  }
  return t20;
}
function _temp2$3(a2, b) {
  return {
    ...a2,
    ...b
  };
}
function _temp$6(e2) {
  return {
    [e2]: []
  };
}
function StorageUpload({
  property: property2,
  name,
  value,
  setInternalValue,
  onChange,
  multipleFilesSupported,
  onFileUploadComplete,
  disabled,
  onFilesAdded,
  autoFocus,
  storage,
  storagePathBuilder
}) {
  if (multipleFilesSupported) {
    const arrayProperty = property2;
    if (arrayProperty.of) {
      if (Array.isArray(arrayProperty.of)) {
        throw Error("Storage field using array must be of data type string");
      }
      if (arrayProperty.of.dataType !== "string") {
        throw Error("Storage field using array must be of data type string");
      }
    } else {
      throw Error("Storage field using array must be of data type string");
    }
  }
  const metadata = storage?.metadata;
  const size2 = multipleFilesSupported ? "medium" : "large";
  const moveItem = useCallback((fromIndex, toIndex) => {
    if (!multipleFilesSupported) return;
    const newValue = [...value];
    const item = newValue[fromIndex];
    newValue.splice(fromIndex, 1);
    newValue.splice(toIndex, 0, item);
    setInternalValue(newValue);
    const fieldValue = newValue.filter((e2) => !!e2.storagePathOrDownloadUrl).map((e_0) => e_0.storagePathOrDownloadUrl);
    onChange(fieldValue);
  }, [multipleFilesSupported, onChange, setInternalValue, value]);
  const onDragEnd2 = useCallback((result) => {
    if (!result.destination) {
      return;
    }
    moveItem(result.source.index, result.destination.index);
  }, [moveItem]);
  const onClear = useCallback((clearedStoragePathOrDownloadUrl) => {
    if (multipleFilesSupported) {
      const newValue_0 = value.filter((v) => v.storagePathOrDownloadUrl !== clearedStoragePathOrDownloadUrl);
      onChange(newValue_0.filter((v_0) => !!v_0.storagePathOrDownloadUrl).map((v_1) => v_1.storagePathOrDownloadUrl));
      setInternalValue(newValue_0);
    } else {
      onChange(null);
      setInternalValue([]);
    }
  }, [value, multipleFilesSupported, onChange]);
  const helpText = multipleFilesSupported ? "Drag 'n' drop some files here, or click to select files" : "Drag 'n' drop a file here, or click to select one";
  const renderProperty = multipleFilesSupported ? property2.of : property2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DragDropContext, { onDragEnd: onDragEnd2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectedDroppable$1, { droppableId: `droppable_${name}`, direction: "horizontal", renderClone: (provided, snapshot, rubric) => {
    const entry = value[rubric.source.index];
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: provided.innerRef, ...provided.draggableProps, ...provided.dragHandleProps, style: provided.draggableProps.style, className: "rounded", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StorageItemPreview, { name: `storage_preview_${entry.storagePathOrDownloadUrl}`, placeholder: true, property: renderProperty, disabled: true, value: entry.storagePathOrDownloadUrl, onRemove: onClear, size: entry.size }) });
  }, children: (provided_0, snapshot_0) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FileDropComponent, { storage, disabled, isDraggingOver: snapshot_0.isDraggingOver, droppableProvided: provided_0, onFilesAdded, multipleFilesSupported, autoFocus, internalValue: value, property: renderProperty, onClear, metadata, storagePathBuilder, onFileUploadComplete, size: size2, name, helpText });
  } }) });
}
function TextFieldBinding(t0) {
  const $ = c_1(51);
  const {
    propertyKey,
    value,
    setValue,
    error,
    showError,
    disabled,
    autoFocus,
    property: property2,
    includeDescription,
    size: t1
  } = t0;
  const size2 = t1 === void 0 ? "large" : t1;
  let multiline;
  let url;
  if (property2.dataType === "string") {
    multiline = property2.multiline;
    url = property2.url;
  }
  let t2;
  if ($[0] !== property2 || $[1] !== setValue || $[2] !== value) {
    t2 = {
      property: property2,
      value,
      setValue
    };
    $[0] = property2;
    $[1] = setValue;
    $[2] = value;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  useClearRestoreValue(t2);
  let t3;
  if ($[4] !== setValue) {
    t3 = (e2) => {
      e2.stopPropagation();
      e2.preventDefault();
      setValue(null);
    };
    $[4] = setValue;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  const handleClearClick = t3;
  let inputType;
  let isMultiline;
  let onChange;
  if ($[6] !== multiline || $[7] !== property2.dataType || $[8] !== setValue) {
    onChange = (event) => {
      if (inputType === "number") {
        const numberValue = event.target.value ? parseFloat(event.target.value) : void 0;
        if (numberValue && isNaN(numberValue)) {
          setValue(null);
        } else {
          if (numberValue !== void 0 && numberValue !== null) {
            setValue(numberValue);
          } else {
            setValue(null);
          }
        }
      } else {
        setValue(event.target.value);
      }
    };
    isMultiline = Boolean(multiline);
    inputType = property2.dataType === "number" ? "number" : void 0;
    $[6] = multiline;
    $[7] = property2.dataType;
    $[8] = setValue;
    $[9] = inputType;
    $[10] = isMultiline;
    $[11] = onChange;
  } else {
    inputType = $[9];
    isMultiline = $[10];
    onChange = $[11];
  }
  let t4;
  if ($[12] !== property2) {
    t4 = getIconForProperty(property2, "small");
    $[12] = property2;
    $[13] = t4;
  } else {
    t4 = $[13];
  }
  const t5 = property2.validation?.required;
  let t6;
  if ($[14] !== property2.name || $[15] !== t4 || $[16] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(LabelWithIcon, { icon: t4, required: t5, title: property2.name });
    $[14] = property2.name;
    $[15] = t4;
    $[16] = t5;
    $[17] = t6;
  } else {
    t6 = $[17];
  }
  const t7 = inputType;
  let t8;
  if ($[18] !== handleClearClick || $[19] !== property2.clearable) {
    t8 = property2.clearable && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: handleClearClick, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {}) });
    $[18] = handleClearClick;
    $[19] = property2.clearable;
    $[20] = t8;
  } else {
    t8 = $[20];
  }
  const t9 = showError ? error : void 0;
  const t10 = error ? "text-red-500 dark:text-red-600" : "";
  let t11;
  if ($[21] !== autoFocus || $[22] !== disabled || $[23] !== isMultiline || $[24] !== onChange || $[25] !== size2 || $[26] !== t10 || $[27] !== t6 || $[28] !== t7 || $[29] !== t8 || $[30] !== t9 || $[31] !== value) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { size: size2, value, onChange, autoFocus, label: t6, type: t7, multiline: isMultiline, disabled, endAdornment: t8, error: t9, inputClassName: t10 });
    $[21] = autoFocus;
    $[22] = disabled;
    $[23] = isMultiline;
    $[24] = onChange;
    $[25] = size2;
    $[26] = t10;
    $[27] = t6;
    $[28] = t7;
    $[29] = t8;
    $[30] = t9;
    $[31] = value;
    $[32] = t11;
  } else {
    t11 = $[32];
  }
  let t12;
  if ($[33] !== propertyKey || $[34] !== t11) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyIdCopyTooltip, { propertyKey, children: t11 });
    $[33] = propertyKey;
    $[34] = t11;
    $[35] = t12;
  } else {
    t12 = $[35];
  }
  let t13;
  if ($[36] !== disabled || $[37] !== error || $[38] !== includeDescription || $[39] !== property2 || $[40] !== showError) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldHelperText, { includeDescription, showError, error, disabled, property: property2 });
    $[36] = disabled;
    $[37] = error;
    $[38] = includeDescription;
    $[39] = property2;
    $[40] = showError;
    $[41] = t13;
  } else {
    t13 = $[41];
  }
  let t14;
  if ($[42] !== property2 || $[43] !== size2 || $[44] !== url || $[45] !== value) {
    t14 = url && /* @__PURE__ */ jsxRuntimeExports.jsx(Collapse, { className: "mt-1 ml-1", in: Boolean(value), children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyPreview, { value, property: property2, size: size2 }) });
    $[42] = property2;
    $[43] = size2;
    $[44] = url;
    $[45] = value;
    $[46] = t14;
  } else {
    t14 = $[46];
  }
  let t15;
  if ($[47] !== t12 || $[48] !== t13 || $[49] !== t14) {
    t15 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t12,
      t13,
      t14
    ] });
    $[47] = t12;
    $[48] = t13;
    $[49] = t14;
    $[50] = t15;
  } else {
    t15 = $[50];
  }
  return t15;
}
const SwitchFieldBinding = function SwitchFieldBinding2(t0) {
  const $ = c_1(32);
  const {
    propertyKey,
    value,
    setValue,
    error,
    showError,
    autoFocus,
    disabled,
    size: t1,
    property: property2,
    includeDescription
  } = t0;
  const size2 = t1 === void 0 ? "large" : t1;
  let t2;
  if ($[0] !== property2 || $[1] !== setValue || $[2] !== value) {
    t2 = {
      property: property2,
      value,
      setValue
    };
    $[0] = property2;
    $[1] = setValue;
    $[2] = value;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  useClearRestoreValue(t2);
  let t3;
  if ($[4] !== setValue) {
    t3 = (v) => setValue(v);
    $[4] = setValue;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] !== property2) {
    t4 = getIconForProperty(property2, "small");
    $[6] = property2;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  const t5 = property2.validation?.required;
  let t6;
  if ($[8] !== property2.name || $[9] !== t4 || $[10] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(LabelWithIcon, { icon: t4, required: t5, title: property2.name });
    $[8] = property2.name;
    $[9] = t4;
    $[10] = t5;
    $[11] = t6;
  } else {
    t6 = $[11];
  }
  let t7;
  if ($[12] !== autoFocus || $[13] !== disabled || $[14] !== showError || $[15] !== size2 || $[16] !== t3 || $[17] !== t6 || $[18] !== value) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanSwitchWithLabel, { value, onValueChange: t3, error: showError, label: t6, disabled, autoFocus, size: size2 });
    $[12] = autoFocus;
    $[13] = disabled;
    $[14] = showError;
    $[15] = size2;
    $[16] = t3;
    $[17] = t6;
    $[18] = value;
    $[19] = t7;
  } else {
    t7 = $[19];
  }
  let t8;
  if ($[20] !== propertyKey || $[21] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyIdCopyTooltip, { propertyKey, children: t7 });
    $[20] = propertyKey;
    $[21] = t7;
    $[22] = t8;
  } else {
    t8 = $[22];
  }
  let t9;
  if ($[23] !== disabled || $[24] !== error || $[25] !== includeDescription || $[26] !== property2 || $[27] !== showError) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldHelperText, { includeDescription, showError, error, disabled, property: property2 });
    $[23] = disabled;
    $[24] = error;
    $[25] = includeDescription;
    $[26] = property2;
    $[27] = showError;
    $[28] = t9;
  } else {
    t9 = $[28];
  }
  let t10;
  if ($[29] !== t8 || $[30] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t8,
      t9
    ] });
    $[29] = t8;
    $[30] = t9;
    $[31] = t10;
  } else {
    t10 = $[31];
  }
  return t10;
};
function DateTimeFieldBinding(t0) {
  const $ = c_1(33);
  const {
    propertyKey,
    value,
    setValue,
    error,
    showError,
    disabled,
    property: property2,
    includeDescription
  } = t0;
  const {
    locale
  } = useCustomizationController();
  const internalValue = value || null;
  let t1;
  if ($[0] !== property2 || $[1] !== setValue || $[2] !== value) {
    t1 = {
      property: property2,
      value,
      setValue
    };
    $[0] = property2;
    $[1] = setValue;
    $[2] = value;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  useClearRestoreValue(t1);
  let t2;
  if ($[4] !== setValue) {
    t2 = (dateValue) => setValue(dateValue);
    $[4] = setValue;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const t3 = property2.mode;
  const t4 = property2.clearable;
  let t5;
  if ($[6] !== property2) {
    t5 = getIconForProperty(property2, "small");
    $[6] = property2;
    $[7] = t5;
  } else {
    t5 = $[7];
  }
  const t6 = property2.validation?.required;
  const t7 = showError ? "text-red-500 dark:text-red-500" : "text-text-secondary dark:text-text-secondary-dark";
  let t8;
  if ($[8] !== property2.name || $[9] !== t5 || $[10] !== t6 || $[11] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(LabelWithIcon, { icon: t5, required: t6, className: t7, title: property2.name });
    $[8] = property2.name;
    $[9] = t5;
    $[10] = t6;
    $[11] = t7;
    $[12] = t8;
  } else {
    t8 = $[12];
  }
  let t9;
  if ($[13] !== internalValue || $[14] !== locale || $[15] !== property2.clearable || $[16] !== property2.mode || $[17] !== showError || $[18] !== t2 || $[19] !== t8) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(DateTimeField, { value: internalValue, onChange: t2, size: "large", mode: t3, clearable: t4, locale, error: showError, label: t8 });
    $[13] = internalValue;
    $[14] = locale;
    $[15] = property2.clearable;
    $[16] = property2.mode;
    $[17] = showError;
    $[18] = t2;
    $[19] = t8;
    $[20] = t9;
  } else {
    t9 = $[20];
  }
  let t10;
  if ($[21] !== propertyKey || $[22] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyIdCopyTooltip, { propertyKey, children: t9 });
    $[21] = propertyKey;
    $[22] = t9;
    $[23] = t10;
  } else {
    t10 = $[23];
  }
  let t11;
  if ($[24] !== disabled || $[25] !== error || $[26] !== includeDescription || $[27] !== property2 || $[28] !== showError) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldHelperText, { includeDescription, showError, error, disabled, property: property2 });
    $[24] = disabled;
    $[25] = error;
    $[26] = includeDescription;
    $[27] = property2;
    $[28] = showError;
    $[29] = t11;
  } else {
    t11 = $[29];
  }
  let t12;
  if ($[30] !== t10 || $[31] !== t11) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t10,
      t11
    ] });
    $[30] = t10;
    $[31] = t11;
    $[32] = t12;
  } else {
    t12 = $[32];
  }
  return t12;
}
function ReadOnlyFieldBinding(t0) {
  const $ = c_1(18);
  const {
    propertyKey,
    value,
    error,
    showError,
    minimalistView,
    property: property2,
    includeDescription,
    context
  } = t0;
  if (!context.entityId) {
    throw new Error("ReadOnlyFieldBinding: Entity id is null");
  }
  let t1;
  if ($[0] !== minimalistView || $[1] !== property2 || $[2] !== propertyKey) {
    t1 = !minimalistView && /* @__PURE__ */ jsxRuntimeExports.jsx(LabelWithIconAndTooltip, { propertyKey, icon: getIconForProperty(property2, "small"), required: property2.validation?.required, title: property2.name, className: "text-text-secondary dark:text-text-secondary-dark ml-3.5" });
    $[0] = minimalistView;
    $[1] = property2;
    $[2] = propertyKey;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = cls(paperMixin, "min-h-14 p-4 md:p-6 overflow-x-scroll no-scrollbar");
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  let t3;
  if ($[5] !== property2 || $[6] !== propertyKey || $[7] !== value) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyPreview, { propertyKey, value, property: property2, size: "medium" }) }) });
    $[5] = property2;
    $[6] = propertyKey;
    $[7] = value;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  let t4;
  if ($[9] !== error || $[10] !== includeDescription || $[11] !== property2 || $[12] !== showError) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldHelperText, { includeDescription, showError, error, property: property2 });
    $[9] = error;
    $[10] = includeDescription;
    $[11] = property2;
    $[12] = showError;
    $[13] = t4;
  } else {
    t4 = $[13];
  }
  let t5;
  if ($[14] !== t1 || $[15] !== t3 || $[16] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t1,
      t3,
      t4
    ] });
    $[14] = t1;
    $[15] = t3;
    $[16] = t4;
    $[17] = t5;
  } else {
    t5 = $[17];
  }
  return t5;
}
function ReferenceFieldBinding(props) {
  const $ = c_1(4);
  if (typeof props.property.path !== "string") {
    let t02;
    if ($[0] !== props) {
      t02 = /* @__PURE__ */ jsxRuntimeExports.jsx(ReadOnlyFieldBinding, { ...props });
      $[0] = props;
      $[1] = t02;
    } else {
      t02 = $[1];
    }
    return t02;
  }
  let t0;
  if ($[2] !== props) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(ReferenceFieldBindingInternal, { ...props });
    $[2] = props;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}
function ReferenceFieldBindingInternal({
  propertyKey,
  value,
  setValue,
  error,
  showError,
  isSubmitting,
  disabled,
  minimalistView,
  touched,
  autoFocus,
  property: property2,
  includeDescription,
  size: size2 = "medium"
}) {
  if (!property2.path) {
    throw new Error("Property path is required for ReferenceFieldBinding");
  }
  useClearRestoreValue({
    property: property2,
    value,
    setValue
  });
  const validValue = value && value.isEntityReference && value.isEntityReference();
  const navigationController = useNavigationController();
  const collection = useMemo(() => {
    return property2.path ? navigationController.getCollection(property2.path) : void 0;
  }, [property2.path]);
  if (!collection) {
    throw Error(`Couldn't find the corresponding collection for the path: ${property2.path}`);
  }
  const onSingleEntitySelected = useCallback((e2) => {
    setValue(e2 ? getReferenceFrom(e2) : null);
  }, [setValue]);
  const referenceDialogController = useReferenceDialog({
    multiselect: false,
    path: property2.path,
    collection,
    onSingleEntitySelected,
    selectedEntityIds: validValue ? [value.id] : void 0,
    forceFilter: property2.forceFilter
  });
  const onEntryClick = (e_0) => {
    e_0.preventDefault();
    referenceDialogController.open();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    !minimalistView && /* @__PURE__ */ jsxRuntimeExports.jsx(LabelWithIconAndTooltip, { propertyKey, icon: getIconForProperty(property2, "small"), required: property2.validation?.required, title: property2.name, className: "text-text-secondary dark:text-text-secondary-dark ml-3.5" }),
    !collection && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView, { error: "The specified collection does not exist. Check console" }),
    collection && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      value && /* @__PURE__ */ jsxRuntimeExports.jsx(ReferencePreview, { disabled: !property2.path, previewProperties: property2.previewProperties, hover: !disabled, size: size2, onClick: disabled || isSubmitting ? void 0 : onEntryClick, reference: value, includeEntityLink: property2.includeEntityLink, includeId: property2.includeId }),
      !value && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "justify-center text-left", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(EntityPreviewContainer, { className: cls("px-6 h-16 text-sm font-medium flex items-center gap-6", disabled || isSubmitting ? "text-surface-accent-500" : "cursor-pointer text-surface-accent-700 dark:text-surface-accent-300 hover:bg-surface-accent-50 dark:hover:bg-surface-800 group-hover:bg-surface-accent-50 dark:group-hover:bg-surface-800"), onClick: onEntryClick, size: "medium", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IconForView, { collectionOrView: collection, className: "text-surface-300 dark:text-surface-600" }),
        `Edit ${property2.name}`.toUpperCase()
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FieldHelperText, { includeDescription, showError, error, disabled, property: property2 })
  ] });
}
const PropertyFieldBinding = React__default.memo(PropertyFieldBindingInternal, (a2, b) => {
  if (a2.propertyKey !== b.propertyKey) {
    return false;
  }
  if (a2.index !== b.index) {
    return false;
  }
  if (a2.size !== b.size) {
    return false;
  }
  const aIsBuilder = isPropertyBuilder(a2.property) || a2.property.fromBuilder;
  const bIsBuilder = isPropertyBuilder(b.property) || b.property.fromBuilder;
  const baseCheck = (aIsBuilder === bIsBuilder || equal(a2.property, b.property)) && a2.disabled === b.disabled;
  if (!baseCheck) {
    return false;
  }
  if (shouldPropertyReRender(b.property)) {
    return false;
  }
  return false;
});
function PropertyFieldBindingInternal(t0) {
  const $ = c_1(17);
  const {
    propertyKey,
    property: property2,
    context,
    includeDescription,
    underlyingValueHasChanged,
    disabled: disabledProp,
    partOfArray,
    minimalistView,
    autoFocus,
    index: index2,
    size: size2,
    onPropertyChange
  } = t0;
  const customizationController = useCustomizationController();
  let t1;
  if ($[0] !== autoFocus || $[1] !== context || $[2] !== customizationController.propertyConfigs || $[3] !== disabledProp || $[4] !== includeDescription || $[5] !== index2 || $[6] !== minimalistView || $[7] !== onPropertyChange || $[8] !== partOfArray || $[9] !== property2 || $[10] !== propertyKey || $[11] !== size2 || $[12] !== underlyingValueHasChanged) {
    t1 = (fieldProps) => {
      let Component2;
      const resolvedProperty = resolveProperty({
        propertyKey,
        propertyOrBuilder: property2,
        values: fieldProps.form.values,
        path: context.path,
        entityId: context.entityId,
        propertyConfigs: customizationController.propertyConfigs,
        index: index2
      });
      const disabled = disabledProp || isReadOnly(resolvedProperty) || Boolean(resolvedProperty?.disabled);
      if (resolvedProperty === null || isHidden(resolvedProperty)) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
      } else {
        if (isReadOnly(resolvedProperty)) {
          Component2 = ReadOnlyFieldBinding;
        } else {
          if (resolvedProperty.Field) {
            if (typeof resolvedProperty.Field === "function") {
              Component2 = resolvedProperty.Field;
            }
          } else {
            const propertyConfig = getFieldConfig(resolvedProperty, customizationController.propertyConfigs);
            if (!propertyConfig) {
              console.log("INTERNAL: Could not find field config for property", {
                propertyKey,
                property: property2,
                resolvedProperty,
                fields: customizationController.propertyConfigs,
                propertyConfig
              });
              throw new Error(`INTERNAL: Could not find field config for property ${propertyKey}`);
            }
            const configProperty = resolveProperty({
              propertyKey,
              propertyOrBuilder: propertyConfig.property,
              values: fieldProps.form.values,
              path: context.path,
              entityId: context.entityId,
              propertyConfigs: customizationController.propertyConfigs,
              index: index2
            });
            Component2 = configProperty.Field;
          }
        }
      }
      if (!Component2) {
        console.warn(`No field component found for property ${propertyKey}`);
        console.warn("Property:", property2);
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: `Currently the field ${resolvedProperty.dataType} is not supported` });
      }
      const componentProps = {
        propertyKey,
        property: resolvedProperty,
        includeDescription,
        underlyingValueHasChanged,
        context,
        disabled,
        partOfArray,
        minimalistView,
        autoFocus,
        size: size2,
        onPropertyChange
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(FieldInternal, { Component: Component2, componentProps, formexFieldProps: fieldProps });
    };
    $[0] = autoFocus;
    $[1] = context;
    $[2] = customizationController.propertyConfigs;
    $[3] = disabledProp;
    $[4] = includeDescription;
    $[5] = index2;
    $[6] = minimalistView;
    $[7] = onPropertyChange;
    $[8] = partOfArray;
    $[9] = property2;
    $[10] = propertyKey;
    $[11] = size2;
    $[12] = underlyingValueHasChanged;
    $[13] = t1;
  } else {
    t1 = $[13];
  }
  let t2;
  if ($[14] !== propertyKey || $[15] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: propertyKey, children: t1 }, propertyKey);
    $[14] = propertyKey;
    $[15] = t1;
    $[16] = t2;
  } else {
    t2 = $[16];
  }
  return t2;
}
function FieldInternal({
  Component: Component2,
  componentProps: {
    propertyKey,
    property: property2,
    includeDescription,
    underlyingValueHasChanged,
    partOfArray,
    minimalistView,
    autoFocus,
    context,
    disabled,
    size: size2,
    onPropertyChange
  },
  formexFieldProps
}) {
  const {
    plugins
  } = useCustomizationController();
  const customFieldProps = property2.customProps;
  const value = formexFieldProps.field.value;
  const error = getIn(formexFieldProps.form.errors, propertyKey);
  const touched = getIn(formexFieldProps.form.touched, propertyKey);
  const showError = error && (formexFieldProps.form.submitCount > 0 || property2.validation?.unique) && (!Array.isArray(error) || !!error.filter((e2) => !!e2).length);
  const WrappedComponent = useWrappedComponent({
    path: context.path,
    collection: context.collection,
    propertyKey,
    property: property2,
    Component: Component2,
    plugins
  });
  const UsedComponent = WrappedComponent ?? Component2;
  const isSubmitting = formexFieldProps.form.isSubmitting;
  const setValue = useCallback((value_0, shouldValidate) => {
    formexFieldProps.form.setFieldTouched(propertyKey, true, false);
    formexFieldProps.form.setFieldValue(propertyKey, value_0, shouldValidate);
  }, []);
  const setFieldValue = useCallback((otherPropertyKey, value_1, shouldValidate_0) => {
    formexFieldProps.form.setFieldTouched(propertyKey, true, false);
    formexFieldProps.form.setFieldValue(otherPropertyKey, value_1, shouldValidate_0);
  }, []);
  const cmsFieldProps = {
    propertyKey,
    value,
    setValue,
    setFieldValue,
    error,
    touched,
    showError,
    isSubmitting,
    includeDescription: includeDescription ?? true,
    property: property2,
    disabled: disabled ?? false,
    underlyingValueHasChanged: underlyingValueHasChanged ?? false,
    partOfArray: partOfArray ?? false,
    minimalistView: minimalistView ?? false,
    autoFocus: autoFocus ?? false,
    customProps: customFieldProps,
    context,
    size: size2,
    onPropertyChange
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ErrorBoundary2, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(UsedComponent, { ...cmsFieldProps }),
    underlyingValueHasChanged && !isSubmitting && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", className: "ml-3.5", children: "This value has been updated elsewhere" })
  ] });
}
const shouldPropertyReRender = (property2, plugins) => {
  if (isPropertyBuilder(property2)) {
    return true;
  }
  const defAProperty = property2;
  const rerenderThisProperty = Boolean(defAProperty.Field) || "fromBuilder" in defAProperty && defAProperty.fromBuilder;
  if (defAProperty.dataType === "map" && defAProperty.properties) {
    return rerenderThisProperty || Object.values(defAProperty.properties).some((childProperty) => shouldPropertyReRender(childProperty));
  } else if (defAProperty.dataType === "array" && "resolvedProperties" in defAProperty) {
    return rerenderThisProperty || defAProperty.resolvedProperties?.some((childProperty) => childProperty && shouldPropertyReRender(childProperty));
  } else {
    return rerenderThisProperty;
  }
};
function useWrappedComponent({
  path,
  collection,
  propertyKey,
  property: property2,
  Component: Component2,
  plugins
}) {
  const wrapperRef = useRef((() => {
    let Wrapper = null;
    if (plugins) {
      plugins.forEach((plugin) => {
        const fieldId = getFieldId(property2);
        if (fieldId && plugin.form?.fieldBuilder) {
          const params = {
            fieldConfigId: fieldId,
            propertyKey,
            property: property2,
            Field: Component2,
            plugin,
            path,
            collection
          };
          const enabled = plugin.form?.fieldBuilderEnabled?.(params);
          if (enabled === void 0 || enabled) Wrapper = plugin.form.fieldBuilder(params) || Wrapper;
        }
        if (!fieldId) {
          console.warn("INTERNAL: Field id not found for property", property2);
        }
      });
    }
    return Wrapper;
  })());
  return wrapperRef.current;
}
function MapFieldBinding(t0) {
  const $ = c_1(48);
  const {
    propertyKey,
    value,
    showError,
    error,
    disabled,
    property: property2,
    minimalistView,
    includeDescription,
    underlyingValueHasChanged,
    autoFocus,
    context,
    onPropertyChange
  } = t0;
  const pickOnlySomeKeys = property2.pickOnlySomeKeys || false;
  const expanded = property2.expanded === void 0 ? true : property2.expanded;
  if (!property2.properties) {
    throw Error(`You need to specify a 'properties' prop (or specify a custom field) in your map property ${propertyKey}`);
  }
  let mapProperties;
  if (pickOnlySomeKeys) {
    if (value) {
      let t12;
      if ($[0] !== property2.properties || $[1] !== value) {
        let t22;
        if ($[3] !== property2.properties) {
          t22 = (key) => key in property2.properties;
          $[3] = property2.properties;
          $[4] = t22;
        } else {
          t22 = $[4];
        }
        t12 = pick(property2.properties, ...Object.keys(value).filter(t22));
        $[0] = property2.properties;
        $[1] = value;
        $[2] = t12;
      } else {
        t12 = $[2];
      }
      mapProperties = t12;
    } else {
      let t12;
      if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
        t12 = {};
        $[5] = t12;
      } else {
        t12 = $[5];
      }
      mapProperties = t12;
    }
  } else {
    mapProperties = property2.properties;
  }
  let t1;
  if ($[6] !== autoFocus || $[7] !== context || $[8] !== disabled || $[9] !== includeDescription || $[10] !== mapProperties || $[11] !== onPropertyChange || $[12] !== propertyKey || $[13] !== underlyingValueHasChanged) {
    let t22;
    if ($[15] !== autoFocus || $[16] !== context || $[17] !== disabled || $[18] !== includeDescription || $[19] !== onPropertyChange || $[20] !== propertyKey || $[21] !== underlyingValueHasChanged) {
      t22 = (t32, index2) => {
        const [entryKey, childProperty] = t32;
        const thisDisabled = isReadOnly(childProperty) || Boolean(childProperty.disabled);
        const fieldBindingProps = {
          propertyKey: `${propertyKey}.${entryKey}`,
          disabled: disabled || thisDisabled,
          property: childProperty,
          includeDescription,
          underlyingValueHasChanged,
          context,
          partOfArray: false,
          minimalistView: false,
          autoFocus: autoFocus && index2 === 0,
          onPropertyChange: function(updatedProperty) {
            onPropertyChange?.({
              properties: {
                [entryKey]: updatedProperty
              }
            });
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyFieldBinding, { ...fieldBindingProps }) }) }, `map-${propertyKey}-${index2}`);
      };
      $[15] = autoFocus;
      $[16] = context;
      $[17] = disabled;
      $[18] = includeDescription;
      $[19] = onPropertyChange;
      $[20] = propertyKey;
      $[21] = underlyingValueHasChanged;
      $[22] = t22;
    } else {
      t22 = $[22];
    }
    t1 = Object.entries(mapProperties).filter(_temp$5).map(t22);
    $[6] = autoFocus;
    $[7] = context;
    $[8] = disabled;
    $[9] = includeDescription;
    $[10] = mapProperties;
    $[11] = onPropertyChange;
    $[12] = propertyKey;
    $[13] = underlyingValueHasChanged;
    $[14] = t1;
  } else {
    t1 = $[14];
  }
  let t2;
  if ($[23] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "py-1 flex flex-col space-y-2", children: t1 }) });
    $[23] = t1;
    $[24] = t2;
  } else {
    t2 = $[24];
  }
  const mapFormView = t2;
  let t3;
  if ($[25] !== property2) {
    t3 = getIconForProperty(property2, "small");
    $[25] = property2;
    $[26] = t3;
  } else {
    t3 = $[26];
  }
  const t4 = property2.validation?.required;
  let t5;
  if ($[27] !== property2.name || $[28] !== propertyKey || $[29] !== t3 || $[30] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(LabelWithIconAndTooltip, { propertyKey, icon: t3, required: t4, title: property2.name, className: "text-text-secondary dark:text-text-secondary-dark" });
    $[27] = property2.name;
    $[28] = propertyKey;
    $[29] = t3;
    $[30] = t4;
    $[31] = t5;
  } else {
    t5 = $[31];
  }
  const title = t5;
  let t6;
  if ($[32] !== expanded || $[33] !== mapFormView || $[34] !== minimalistView || $[35] !== onPropertyChange || $[36] !== title) {
    t6 = !minimalistView && /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandablePanel, { initiallyExpanded: expanded, onExpandedChange: (expanded_0) => {
      onPropertyChange?.({
        expanded: expanded_0
      });
    }, innerClassName: "px-2 md:px-4 pb-2 md:pb-4 pt-1 md:pt-2 bg-white dark:bg-surface-900", title, children: mapFormView });
    $[32] = expanded;
    $[33] = mapFormView;
    $[34] = minimalistView;
    $[35] = onPropertyChange;
    $[36] = title;
    $[37] = t6;
  } else {
    t6 = $[37];
  }
  const t7 = minimalistView && mapFormView;
  const t8 = showError ?? false;
  const t9 = error ? typeof error === "string" ? error : "A property of this map has an error" : void 0;
  let t10;
  if ($[38] !== disabled || $[39] !== includeDescription || $[40] !== property2 || $[41] !== t8 || $[42] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldHelperText, { includeDescription, showError: t8, error: t9, disabled, property: property2 });
    $[38] = disabled;
    $[39] = includeDescription;
    $[40] = property2;
    $[41] = t8;
    $[42] = t9;
    $[43] = t10;
  } else {
    t10 = $[43];
  }
  let t11;
  if ($[44] !== t10 || $[45] !== t6 || $[46] !== t7) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs(ErrorBoundary2, { children: [
      t6,
      t7,
      t10
    ] });
    $[44] = t10;
    $[45] = t6;
    $[46] = t7;
    $[47] = t11;
  } else {
    t11 = $[47];
  }
  return t11;
}
function _temp$5(t0) {
  const [, property_0] = t0;
  return !isHidden(property_0);
}
function KeyValueFieldBinding(t0) {
  const $ = c_1(31);
  const {
    propertyKey,
    value,
    showError,
    error,
    disabled,
    property: property2,
    setValue,
    minimalistView,
    includeDescription,
    autoFocus,
    context
  } = t0;
  const expanded = (property2.expanded === void 0 ? true : property2.expanded) || autoFocus;
  if (!property2.keyValue) {
    throw Error(`Your property ${propertyKey} needs to have the 'keyValue' prop in order to use this field binding`);
  }
  let t1;
  if ($[0] !== context.formex.initialValues || $[1] !== propertyKey) {
    t1 = getIn(context.formex.initialValues, propertyKey);
    $[0] = context.formex.initialValues;
    $[1] = propertyKey;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const initialValues = t1;
  const t2 = property2.name ?? propertyKey;
  let t3;
  if ($[3] !== disabled || $[4] !== initialValues || $[5] !== setValue || $[6] !== t2 || $[7] !== value) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(MapEditView, { value, setValue, disabled, initialValue: initialValues, fieldName: t2 });
    $[3] = disabled;
    $[4] = initialValues;
    $[5] = setValue;
    $[6] = t2;
    $[7] = value;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  const mapFormView = t3;
  let t4;
  if ($[9] !== property2) {
    t4 = getIconForProperty(property2, "small");
    $[9] = property2;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  const t5 = property2.validation?.required;
  let t6;
  if ($[11] !== property2.name || $[12] !== propertyKey || $[13] !== t4 || $[14] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(LabelWithIconAndTooltip, { propertyKey, icon: t4, required: t5, title: property2.name, className: "text-text-secondary dark:text-text-secondary-dark" });
    $[11] = property2.name;
    $[12] = propertyKey;
    $[13] = t4;
    $[14] = t5;
    $[15] = t6;
  } else {
    t6 = $[15];
  }
  const title = t6;
  let t7;
  if ($[16] !== expanded || $[17] !== mapFormView || $[18] !== minimalistView || $[19] !== title) {
    t7 = !minimalistView && /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandablePanel, { initiallyExpanded: expanded, title, innerClassName: "px-2 md:px-4 pb-2 md:pb-4 pt-1 md:pt-2", children: mapFormView });
    $[16] = expanded;
    $[17] = mapFormView;
    $[18] = minimalistView;
    $[19] = title;
    $[20] = t7;
  } else {
    t7 = $[20];
  }
  const t8 = minimalistView && mapFormView;
  let t9;
  if ($[21] !== disabled || $[22] !== error || $[23] !== includeDescription || $[24] !== property2 || $[25] !== showError) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldHelperText, { includeDescription, showError, error, disabled, property: property2 });
    $[21] = disabled;
    $[22] = error;
    $[23] = includeDescription;
    $[24] = property2;
    $[25] = showError;
    $[26] = t9;
  } else {
    t9 = $[26];
  }
  let t10;
  if ($[27] !== t7 || $[28] !== t8 || $[29] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t7,
      t8,
      t9
    ] });
    $[27] = t7;
    $[28] = t8;
    $[29] = t9;
    $[30] = t10;
  } else {
    t10 = $[30];
  }
  return t10;
}
function MapEditView({
  value,
  initialValue,
  setValue,
  fieldName,
  disabled
}) {
  const [internalState, setInternalState] = React__default.useState(Object.keys(initialValue ?? {}).map((key) => [getRandomId(), {
    key,
    dataType: getDataType(initialValue?.[key]) ?? "string"
  }]));
  useEffect(() => {
    const currentKeys = internalState.map(([id2, {
      key: key_0
    }]) => key_0);
    const newKeys = Object.entries(value ?? {}).filter(([key_1, v]) => v !== void 0).map(([key_2]) => key_2);
    const keysToAdd = newKeys.filter((key_3) => !currentKeys.includes(key_3));
    const keysToRemove = currentKeys.filter((key_4) => !newKeys.includes(key_4));
    const newRowIds = [...internalState];
    keysToAdd.forEach((key_5) => {
      newRowIds.push([getRandomId(), {
        key: key_5,
        dataType: getDataType(value?.[key_5]) ?? "string"
      }]);
    });
    keysToRemove.forEach((key_6) => {
      const index2 = newRowIds.findIndex(([id_0, {
        key: k
      }]) => k === key_6);
      newRowIds.splice(index2, 1);
    });
    setInternalState(newRowIds);
  }, [value]);
  const updateDataType = (rowId, dataType) => {
    if (!rowId) {
      console.warn("No key selected for data type update");
      return;
    }
    setInternalState(internalState.map((row) => {
      if (row[0] === rowId) {
        return [row[0], {
          key: row[1].key,
          dataType
        }];
      }
      return row;
    }));
    setValue({
      ...value ?? {},
      [internalState.find((row) => row[0] === rowId)?.[1].key ?? ""]: getDefaultValueForDataType(dataType)
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "py-1 flex flex-col gap-1", children: [
    internalState.map(([rowId_0, {
      key: fieldKey,
      dataType: dataType_0
    }], index_0) => {
      const entryValue = fieldKey ? value?.[fieldKey] : "";
      const onFieldKeyChange = (newKey) => {
        setInternalState(internalState.map((currentRowId) => {
          if (currentRowId[0] === rowId_0) {
            return [rowId_0, {
              key: newKey ?? "",
              dataType: currentRowId[1].dataType
            }];
          }
          return currentRowId;
        }));
        if (typeof value === "object" && newKey in value) {
          return;
        }
        const newValue = {
          ...value ?? {}
        };
        if (typeof initialValue === "object" && fieldKey in initialValue) {
          newValue[fieldKey] = void 0;
        } else {
          delete newValue[fieldKey];
        }
        setValue({
          ...newValue,
          [newKey ?? ""]: entryValue
        });
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MapKeyValueRow, { rowId: rowId_0, fieldKey, value: value ?? {}, onDeleteClick: () => {
        const newValue_0 = {
          ...value ?? {}
        };
        if (initialValue && fieldKey in initialValue) {
          newValue_0[fieldKey] = void 0;
        } else {
          delete newValue_0[fieldKey];
        }
        setInternalState(internalState.filter((currentRowId_0) => currentRowId_0[0] !== rowId_0));
        setValue({
          ...newValue_0
        });
      }, onFieldKeyChange, setValue, entryValue, dataType: dataType_0, disabled, updateDataType }, rowId_0);
    }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "text", size: "small", color: "primary", className: "w-full", disabled, startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon, {}), onClick: (e2) => {
      e2.preventDefault();
      setValue({
        ...value ?? {},
        "": null
      });
      setInternalState([...internalState, [getRandomId(), {
        key: "",
        dataType: "string"
      }]]);
    }, children: fieldName ? `Add to ${fieldName}` : "Add" })
  ] });
}
function MapKeyValueRow(t0) {
  const $ = c_1(63);
  const {
    rowId,
    fieldKey,
    value,
    onFieldKeyChange,
    onDeleteClick,
    setValue,
    entryValue,
    dataType,
    updateDataType,
    disabled
  } = t0;
  const {
    locale
  } = useCustomizationController();
  let t1;
  if ($[0] !== disabled || $[1] !== locale || $[2] !== rowId || $[3] !== setValue || $[4] !== value) {
    t1 = function buildInput2(entryValue_0, fieldKey_0, dataType_0) {
      if (dataType_0 === "string" || dataType_0 === "number") {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { placeholder: "value", value: entryValue_0, type: dataType_0 === "number" ? "number" : "text", size: "medium", disabled: disabled || !fieldKey_0, onChange: (event) => {
          if (dataType_0 === "number") {
            const numberValue = event.target.value ? parseFloat(event.target.value) : void 0;
            if (numberValue && isNaN(numberValue)) {
              setValue({
                ...value,
                [fieldKey_0]: null
              });
            } else {
              if (numberValue !== void 0 && numberValue !== null) {
                setValue({
                  ...value,
                  [fieldKey_0]: numberValue
                });
              } else {
                setValue({
                  ...value,
                  [fieldKey_0]: null
                });
              }
            }
          } else {
            setValue({
              ...value,
              [fieldKey_0]: event.target.value
            });
          }
        } }, dataType_0);
      } else {
        if (dataType_0 === "date") {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(DateTimeField, { value: entryValue_0, size: "medium", locale, disabled: disabled || !fieldKey_0, onChange: (date2) => {
            setValue({
              ...value,
              [fieldKey_0]: date2
            });
          } });
        } else {
          if (dataType_0 === "boolean") {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanSwitchWithLabel, { value: entryValue_0, size: "medium", position: "start", disabled: disabled || !fieldKey_0, onValueChange: (newValue) => {
              setValue({
                ...value,
                [fieldKey_0]: newValue
              });
            } });
          } else {
            if (dataType_0 === "array") {
              return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls(defaultBorderMixin, "ml-2 pl-2 border-l border-solid"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayContainer, { value: entryValue_0, newDefaultEntry: "", droppableId: rowId.toString(), addLabel: fieldKey_0 ? `Add to ${fieldKey_0}` : "Add", size: "small", disabled: disabled || !fieldKey_0, includeAddButton: true, onValueChange: (newValue_0) => {
                setValue({
                  ...value,
                  [fieldKey_0]: newValue_0
                });
              }, buildEntry: (t23) => {
                const {
                  index: index2,
                  internalId
                } = t23;
                return /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayKeyValueRow, { index: index2, id: internalId, value: entryValue_0[index2], disabled: disabled || !fieldKey_0, setValue: (newValue_1) => {
                  const newArrayValue = [...entryValue_0];
                  newArrayValue[index2] = newValue_1;
                  setValue({
                    ...value,
                    [fieldKey_0]: newArrayValue
                  });
                } });
              } }) });
            } else {
              if (dataType_0 === "map") {
                return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls(defaultBorderMixin, "ml-2 pl-2 border-l border-solid"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(MapEditView, { value: entryValue_0, fieldName: fieldKey_0, setValue: (updatedValue) => {
                  setValue({
                    ...value,
                    [fieldKey_0]: updatedValue
                  });
                } }) });
              } else {
                return /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", children: `Data type ${dataType_0} not supported yet` });
              }
            }
          }
        }
      }
    };
    $[0] = disabled;
    $[1] = locale;
    $[2] = rowId;
    $[3] = setValue;
    $[4] = value;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  const buildInput = t1;
  let t2;
  if ($[6] !== rowId || $[7] !== updateDataType) {
    t2 = function doUpdateDataType2(dataType_1) {
      updateDataType(rowId, dataType_1);
    };
    $[6] = rowId;
    $[7] = updateDataType;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  const doUpdateDataType = t2;
  let t3;
  if ($[9] !== rowId) {
    t3 = rowId.toString();
    $[9] = rowId;
    $[10] = t3;
  } else {
    t3 = $[10];
  }
  const t4 = disabled || entryValue !== void 0 && entryValue !== null && entryValue !== "";
  let t5;
  if ($[11] !== onFieldKeyChange) {
    t5 = (event_0) => {
      onFieldKeyChange(event_0.target.value);
    };
    $[11] = onFieldKeyChange;
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  let t6;
  if ($[13] !== fieldKey || $[14] !== t4 || $[15] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[300px] max-w-[30%]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { value: fieldKey, placeholder: "key", disabled: t4, size: "medium", onChange: t5 }) });
    $[13] = fieldKey;
    $[14] = t4;
    $[15] = t5;
    $[16] = t6;
  } else {
    t6 = $[16];
  }
  let t7;
  if ($[17] !== buildInput || $[18] !== dataType || $[19] !== entryValue || $[20] !== fieldKey) {
    t7 = dataType !== "map" && dataType !== "array" && buildInput(entryValue, fieldKey, dataType);
    $[17] = buildInput;
    $[18] = dataType;
    $[19] = entryValue;
    $[20] = fieldKey;
    $[21] = t7;
  } else {
    t7 = $[21];
  }
  let t8;
  if ($[22] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow", children: t7 });
    $[22] = t7;
    $[23] = t8;
  } else {
    t8 = $[23];
  }
  let t9;
  if ($[24] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { size: "smallest", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowDropDownIcon, { size: "small" }) });
    $[24] = t9;
  } else {
    t9 = $[24];
  }
  let t10;
  if ($[25] !== doUpdateDataType) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { dense: true, onClick: () => doUpdateDataType("string"), children: "string" });
    $[25] = doUpdateDataType;
    $[26] = t10;
  } else {
    t10 = $[26];
  }
  let t11;
  if ($[27] !== doUpdateDataType) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { dense: true, onClick: () => doUpdateDataType("number"), children: "number" });
    $[27] = doUpdateDataType;
    $[28] = t11;
  } else {
    t11 = $[28];
  }
  let t12;
  if ($[29] !== doUpdateDataType) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { dense: true, onClick: () => doUpdateDataType("boolean"), children: "boolean" });
    $[29] = doUpdateDataType;
    $[30] = t12;
  } else {
    t12 = $[30];
  }
  let t13;
  if ($[31] !== doUpdateDataType) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { dense: true, onClick: () => doUpdateDataType("date"), children: "date" });
    $[31] = doUpdateDataType;
    $[32] = t13;
  } else {
    t13 = $[32];
  }
  let t14;
  if ($[33] !== doUpdateDataType) {
    t14 = /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { dense: true, onClick: () => doUpdateDataType("map"), children: "map" });
    $[33] = doUpdateDataType;
    $[34] = t14;
  } else {
    t14 = $[34];
  }
  let t15;
  if ($[35] !== doUpdateDataType) {
    t15 = /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { dense: true, onClick: () => doUpdateDataType("array"), children: "array" });
    $[35] = doUpdateDataType;
    $[36] = t15;
  } else {
    t15 = $[36];
  }
  let t16;
  if ($[37] !== t10 || $[38] !== t11 || $[39] !== t12 || $[40] !== t13 || $[41] !== t14 || $[42] !== t15) {
    t16 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Menu, { trigger: t9, children: [
      t10,
      t11,
      t12,
      t13,
      t14,
      t15
    ] });
    $[37] = t10;
    $[38] = t11;
    $[39] = t12;
    $[40] = t13;
    $[41] = t14;
    $[42] = t15;
    $[43] = t16;
  } else {
    t16 = $[43];
  }
  let t17;
  if ($[44] === Symbol.for("react.memo_cache_sentinel")) {
    t17 = /* @__PURE__ */ jsxRuntimeExports.jsx(RemoveIcon, { size: "smallest" });
    $[44] = t17;
  } else {
    t17 = $[44];
  }
  let t18;
  if ($[45] !== onDeleteClick) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { "aria-label": "delete", size: "smallest", onClick: onDeleteClick, children: t17 });
    $[45] = onDeleteClick;
    $[46] = t18;
  } else {
    t18 = $[46];
  }
  let t19;
  if ($[47] !== t16 || $[48] !== t18) {
    t19 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
      t16,
      t18
    ] });
    $[47] = t16;
    $[48] = t18;
    $[49] = t19;
  } else {
    t19 = $[49];
  }
  let t20;
  if ($[50] !== t19 || $[51] !== t3 || $[52] !== t6 || $[53] !== t8) {
    t20 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { component: "div", className: "font-mono flex flex-row gap-1", children: [
      t6,
      t8,
      t19
    ] }, t3);
    $[50] = t19;
    $[51] = t3;
    $[52] = t6;
    $[53] = t8;
    $[54] = t20;
  } else {
    t20 = $[54];
  }
  let t21;
  if ($[55] !== buildInput || $[56] !== dataType || $[57] !== entryValue || $[58] !== fieldKey) {
    t21 = (dataType === "map" || dataType === "array") && buildInput(entryValue, fieldKey, dataType);
    $[55] = buildInput;
    $[56] = dataType;
    $[57] = entryValue;
    $[58] = fieldKey;
    $[59] = t21;
  } else {
    t21 = $[59];
  }
  let t22;
  if ($[60] !== t20 || $[61] !== t21) {
    t22 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t20,
      t21
    ] });
    $[60] = t20;
    $[61] = t21;
    $[62] = t22;
  } else {
    t22 = $[62];
  }
  return t22;
}
function ArrayKeyValueRow(t0) {
  const $ = c_1(30);
  const {
    id: id2,
    value,
    setValue
  } = t0;
  const {
    locale
  } = useCustomizationController();
  let t1;
  if ($[0] !== value) {
    t1 = getDataType(value) ?? "string";
    $[0] = value;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const [selectedDataType, setSelectedDataType] = useState(t1);
  let t2;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = function doUpdateDataType2(dataType) {
      setSelectedDataType(dataType);
    };
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  const doUpdateDataType = t2;
  let t3;
  if ($[3] !== locale || $[4] !== setValue) {
    t3 = function buildInput2(entryValue, dataType_0) {
      if (dataType_0 === "string" || dataType_0 === "number") {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { value: entryValue, type: dataType_0 === "number" ? "number" : "text", size: "medium", onChange: (event) => {
          if (dataType_0 === "number") {
            const numberValue = event.target.value ? parseFloat(event.target.value) : void 0;
            if (numberValue && isNaN(numberValue)) {
              setValue(null);
            } else {
              if (numberValue !== void 0 && numberValue !== null) {
                setValue(numberValue);
              } else {
                setValue(null);
              }
            }
          } else {
            setValue(event.target.value);
          }
        } });
      } else {
        if (dataType_0 === "date") {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(DateTimeField, { value: entryValue, size: "medium", locale, onChange: (date2) => {
            setValue(date2);
          } });
        } else {
          if (dataType_0 === "boolean") {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(BooleanSwitchWithLabel, { value: entryValue, size: "small", position: "start", onValueChange: (v) => {
              setValue(v);
            } });
          } else {
            if (dataType_0 === "array") {
              return /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", children: "Arrays of arrays are not supported." });
            } else {
              if (dataType_0 === "map") {
                return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls(defaultBorderMixin, "ml-2 pl-2 border-l border-solid"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(MapEditView, { value: entryValue, setValue: (updatedValue) => {
                  setValue(updatedValue);
                } }) });
              } else {
                return /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", children: `Data type ${dataType_0} not supported yet` });
              }
            }
          }
        }
      }
    };
    $[3] = locale;
    $[4] = setValue;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  const buildInput = t3;
  let t4;
  if ($[6] !== id2) {
    t4 = id2.toString();
    $[6] = id2;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  let t5;
  if ($[8] !== buildInput || $[9] !== selectedDataType || $[10] !== value) {
    t5 = selectedDataType !== "map" && buildInput(value, selectedDataType);
    $[8] = buildInput;
    $[9] = selectedDataType;
    $[10] = value;
    $[11] = t5;
  } else {
    t5 = $[11];
  }
  let t6;
  if ($[12] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow", children: t5 });
    $[12] = t5;
    $[13] = t6;
  } else {
    t6 = $[13];
  }
  let t7;
  if ($[14] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { size: "small", className: "h-7 w-7", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowDropDownIcon, {}) });
    $[14] = t7;
  } else {
    t7 = $[14];
  }
  let t8;
  if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { dense: true, onClick: () => doUpdateDataType("string"), children: "string" });
    $[15] = t8;
  } else {
    t8 = $[15];
  }
  let t9;
  if ($[16] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { dense: true, onClick: () => doUpdateDataType("number"), children: "number" });
    $[16] = t9;
  } else {
    t9 = $[16];
  }
  let t10;
  if ($[17] === Symbol.for("react.memo_cache_sentinel")) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { dense: true, onClick: () => doUpdateDataType("boolean"), children: "boolean" });
    $[17] = t10;
  } else {
    t10 = $[17];
  }
  let t11;
  if ($[18] === Symbol.for("react.memo_cache_sentinel")) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { dense: true, onClick: () => doUpdateDataType("map"), children: "map" });
    $[18] = t11;
  } else {
    t11 = $[18];
  }
  let t12;
  if ($[19] === Symbol.for("react.memo_cache_sentinel")) {
    t12 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Menu, { trigger: t7, children: [
      t8,
      t9,
      t10,
      t11,
      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { dense: true, onClick: () => doUpdateDataType("date"), children: "date" })
    ] });
    $[19] = t12;
  } else {
    t12 = $[19];
  }
  let t13;
  if ($[20] !== t4 || $[21] !== t6) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { component: "div", className: "font-mono flex min-h-12 flex-row gap-1 items-center", children: [
      t6,
      t12
    ] }, t4);
    $[20] = t4;
    $[21] = t6;
    $[22] = t13;
  } else {
    t13 = $[22];
  }
  let t14;
  if ($[23] !== buildInput || $[24] !== selectedDataType || $[25] !== value) {
    t14 = selectedDataType === "map" && buildInput(value, selectedDataType);
    $[23] = buildInput;
    $[24] = selectedDataType;
    $[25] = value;
    $[26] = t14;
  } else {
    t14 = $[26];
  }
  let t15;
  if ($[27] !== t13 || $[28] !== t14) {
    t15 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t13,
      t14
    ] });
    $[27] = t13;
    $[28] = t14;
    $[29] = t15;
  } else {
    t15 = $[29];
  }
  return t15;
}
function getRandomId() {
  return Math.floor(Math.random() * Math.floor(Number.MAX_SAFE_INTEGER));
}
function getDataType(value) {
  if (typeof value === "string" || value === null) {
    return "string";
  } else if (typeof value === "number") {
    return "number";
  } else if (typeof value === "boolean") {
    return "boolean";
  } else if (Array.isArray(value)) {
    return "array";
  } else if (value instanceof Date) {
    return "date";
  } else if (value?.isEntityReference && value?.isEntityReference()) {
    return "reference";
  } else if (value instanceof GeoPoint) {
    return "geopoint";
  } else if (typeof value === "object") {
    return "map";
  }
  return void 0;
}
function RepeatFieldBinding(t0) {
  const $ = c_1(69);
  let context;
  let disabled;
  let error;
  let includeDescription;
  let isSubmitting;
  let minimalistView;
  let property2;
  let propertyKey;
  let resolvedProperties;
  let setFieldValue;
  let setValue;
  let showError;
  let underlyingValueHasChanged;
  let value;
  if ($[0] !== t0) {
    ({
      propertyKey,
      value,
      error,
      showError,
      isSubmitting,
      setValue,
      setFieldValue,
      minimalistView,
      property: property2,
      includeDescription,
      underlyingValueHasChanged,
      context,
      disabled
    } = t0);
    if (!property2.of) {
      throw Error("RepeatFieldBinding misconfiguration. Property `of` not set");
    }
    resolvedProperties = "resolvedProperties" in property2 ? property2.resolvedProperties : void 0;
    if (!resolvedProperties) {
      resolvedProperties = getArrayResolvedProperties({
        propertyValue: value,
        propertyKey,
        property: property2,
        ignoreMissingFields: false
      });
    }
    $[0] = t0;
    $[1] = context;
    $[2] = disabled;
    $[3] = error;
    $[4] = includeDescription;
    $[5] = isSubmitting;
    $[6] = minimalistView;
    $[7] = property2;
    $[8] = propertyKey;
    $[9] = resolvedProperties;
    $[10] = setFieldValue;
    $[11] = setValue;
    $[12] = showError;
    $[13] = underlyingValueHasChanged;
    $[14] = value;
  } else {
    context = $[1];
    disabled = $[2];
    error = $[3];
    includeDescription = $[4];
    isSubmitting = $[5];
    minimalistView = $[6];
    property2 = $[7];
    propertyKey = $[8];
    resolvedProperties = $[9];
    setFieldValue = $[10];
    setValue = $[11];
    showError = $[12];
    underlyingValueHasChanged = $[13];
    value = $[14];
  }
  const expanded = property2.expanded === void 0 ? true : property2.expanded;
  const ofProperty = property2.of;
  const [lastAddedId, setLastAddedId] = useState();
  let t1;
  if ($[15] !== property2 || $[16] !== setValue || $[17] !== value) {
    t1 = {
      property: property2,
      value,
      setValue
    };
    $[15] = property2;
    $[16] = setValue;
    $[17] = value;
    $[18] = t1;
  } else {
    t1 = $[18];
  }
  useClearRestoreValue(t1);
  let t2;
  if ($[19] !== context || $[20] !== disabled || $[21] !== includeDescription || $[22] !== lastAddedId || $[23] !== ofProperty || $[24] !== propertyKey || $[25] !== resolvedProperties || $[26] !== underlyingValueHasChanged) {
    t2 = (t32) => {
      const {
        index: index2,
        internalId,
        storedProps,
        storeProps
      } = t32;
      const childProperty = resolvedProperties[index2] ?? ofProperty;
      const fieldProps = {
        propertyKey: `${propertyKey}.${index2}`,
        disabled,
        property: storedProps ? mergeDeep(childProperty, storedProps) : childProperty,
        onPropertyChange: storeProps,
        includeDescription,
        underlyingValueHasChanged,
        context,
        partOfArray: true,
        minimalistView: false,
        autoFocus: internalId === lastAddedId
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyFieldBinding, { ...fieldProps, index: index2 }) });
    };
    $[19] = context;
    $[20] = disabled;
    $[21] = includeDescription;
    $[22] = lastAddedId;
    $[23] = ofProperty;
    $[24] = propertyKey;
    $[25] = resolvedProperties;
    $[26] = underlyingValueHasChanged;
    $[27] = t2;
  } else {
    t2 = $[27];
  }
  const buildEntry = t2;
  const t3 = property2.name ? "Add entry to " + property2.name : "Add entry";
  const t4 = isSubmitting || Boolean(property2.disabled);
  const t5 = !property2.disabled;
  let t6;
  if ($[28] !== property2.of) {
    t6 = getDefaultValueFor(property2.of);
    $[28] = property2.of;
    $[29] = t6;
  } else {
    t6 = $[29];
  }
  let t7;
  if ($[30] !== propertyKey || $[31] !== setFieldValue) {
    t7 = (value_0) => setFieldValue(propertyKey, value_0);
    $[30] = propertyKey;
    $[31] = setFieldValue;
    $[32] = t7;
  } else {
    t7 = $[32];
  }
  let t8;
  if ($[33] !== buildEntry || $[34] !== propertyKey || $[35] !== t3 || $[36] !== t4 || $[37] !== t5 || $[38] !== t6 || $[39] !== t7 || $[40] !== value) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayContainer, { droppableId: propertyKey, addLabel: t3, value, buildEntry, onInternalIdAdded: setLastAddedId, disabled: t4, includeAddButton: t5, newDefaultEntry: t6, onValueChange: t7 });
    $[33] = buildEntry;
    $[34] = propertyKey;
    $[35] = t3;
    $[36] = t4;
    $[37] = t5;
    $[38] = t6;
    $[39] = t7;
    $[40] = value;
    $[41] = t8;
  } else {
    t8 = $[41];
  }
  const arrayContainer = t8;
  let t9;
  if ($[42] !== property2) {
    t9 = getIconForProperty(property2, "small");
    $[42] = property2;
    $[43] = t9;
  } else {
    t9 = $[43];
  }
  const t10 = property2.validation?.required;
  let t11;
  if ($[44] !== property2.name || $[45] !== propertyKey || $[46] !== t10 || $[47] !== t9) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx(LabelWithIconAndTooltip, { propertyKey, icon: t9, required: t10, title: property2.name, className: "flex flex-grow text-text-secondary dark:text-text-secondary-dark" });
    $[44] = property2.name;
    $[45] = propertyKey;
    $[46] = t10;
    $[47] = t9;
    $[48] = t11;
  } else {
    t11 = $[48];
  }
  let t12;
  if ($[49] !== value) {
    t12 = Array.isArray(value) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", className: "px-4", children: [
      "(",
      value.length,
      ")"
    ] });
    $[49] = value;
    $[50] = t12;
  } else {
    t12 = $[50];
  }
  let t13;
  if ($[51] !== t11 || $[52] !== t12) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t11,
      t12
    ] });
    $[51] = t11;
    $[52] = t12;
    $[53] = t13;
  } else {
    t13 = $[53];
  }
  const title = t13;
  let t14;
  if ($[54] !== arrayContainer || $[55] !== expanded || $[56] !== minimalistView || $[57] !== title) {
    t14 = !minimalistView && /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandablePanel, { initiallyExpanded: expanded, innerClassName: "px-2 md:px-4 pb-2 md:pb-4 pt-1 md:pt-2", title, children: arrayContainer });
    $[54] = arrayContainer;
    $[55] = expanded;
    $[56] = minimalistView;
    $[57] = title;
    $[58] = t14;
  } else {
    t14 = $[58];
  }
  const t15 = minimalistView && arrayContainer;
  const t16 = error ? typeof error === "string" ? error : "A property of this array/repeat has an error" : void 0;
  let t17;
  if ($[59] !== disabled || $[60] !== includeDescription || $[61] !== property2 || $[62] !== showError || $[63] !== t16) {
    t17 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldHelperText, { includeDescription, showError, error: t16, disabled, property: property2 });
    $[59] = disabled;
    $[60] = includeDescription;
    $[61] = property2;
    $[62] = showError;
    $[63] = t16;
    $[64] = t17;
  } else {
    t17 = $[64];
  }
  let t18;
  if ($[65] !== t14 || $[66] !== t15 || $[67] !== t17) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t14,
      t15,
      t17
    ] });
    $[65] = t14;
    $[66] = t15;
    $[67] = t17;
    $[68] = t18;
  } else {
    t18 = $[68];
  }
  return t18;
}
function BlockFieldBinding({
  propertyKey,
  value,
  error,
  showError,
  isSubmitting,
  setValue,
  setFieldValue,
  minimalistView,
  property: property2,
  includeDescription,
  underlyingValueHasChanged,
  context,
  disabled
}) {
  if (!property2.oneOf) throw Error("ArrayOneOfField misconfiguration. Property `oneOf` not set");
  const expanded = property2.expanded === void 0 ? true : property2.expanded;
  useClearRestoreValue({
    property: property2,
    value,
    setValue
  });
  const [lastAddedId, setLastAddedId] = useState();
  const buildEntry = ({
    index: index2,
    internalId,
    storedProps,
    storeProps
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(BlockEntry, { name: `${propertyKey}.${index2}`, index: index2, value: value[index2], typeField: property2.oneOf.typeField ?? DEFAULT_ONE_OF_TYPE, valueField: property2.oneOf.valueField ?? DEFAULT_ONE_OF_VALUE, properties: property2.oneOf.properties, autoFocus: internalId === lastAddedId, context, storeProps, storedProps }, `array_one_of_${internalId}`);
  };
  const title = /* @__PURE__ */ jsxRuntimeExports.jsx(LabelWithIconAndTooltip, { propertyKey, icon: getIconForProperty(property2, "small"), required: property2.validation?.required, title: property2.name, className: "text-text-secondary dark:text-text-secondary-dark" });
  const firstOneOfKey = Object.keys(property2.oneOf.properties)[0];
  const body = /* @__PURE__ */ jsxRuntimeExports.jsx(ArrayContainer, { value, className: "flex flex-col gap-3", droppableId: propertyKey, addLabel: property2.name ? "Add entry to " + property2.name : "Add entry", buildEntry, onInternalIdAdded: setLastAddedId, disabled: isSubmitting || Boolean(property2.disabled), includeAddButton: !property2.disabled, onValueChange: (value_0) => setFieldValue(propertyKey, value_0), newDefaultEntry: {
    [property2.oneOf.typeField ?? DEFAULT_ONE_OF_TYPE]: firstOneOfKey,
    [property2.oneOf.valueField ?? DEFAULT_ONE_OF_VALUE]: getDefaultValueFor(property2.oneOf.properties[firstOneOfKey])
  } });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    !minimalistView && /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandablePanel, { innerClassName: "px-2 md:px-4 pb-2 md:pb-4 pt-1 md:pt-2", initiallyExpanded: expanded, title, children: body }),
    minimalistView && body,
    /* @__PURE__ */ jsxRuntimeExports.jsx(FieldHelperText, { includeDescription, showError, error, disabled, property: property2 })
  ] });
}
function BlockEntry(t0) {
  const $ = c_1(31);
  const {
    name,
    value,
    typeField,
    valueField,
    properties,
    autoFocus,
    context,
    storedProps,
    storeProps
  } = t0;
  const type = value && value[typeField];
  const [typeInternal, setTypeInternal] = useState(type ?? void 0);
  const formex = useFormex();
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [];
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  useEffect(() => {
    if (!type) {
      updateType(Object.keys(properties)[0]);
    }
  }, t1);
  let t2;
  if ($[1] !== type || $[2] !== typeInternal) {
    t2 = () => {
      if (type !== typeInternal) {
        setTypeInternal(type);
      }
    };
    $[1] = type;
    $[2] = typeInternal;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== type) {
    t3 = [type];
    $[4] = type;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  useEffect(t2, t3);
  const propertyInternal = typeInternal ? properties[typeInternal] : void 0;
  let t4;
  if ($[6] !== propertyInternal || $[7] !== storedProps) {
    t4 = storedProps && typeof propertyInternal === "object" ? mergeDeep(propertyInternal, storedProps) : propertyInternal;
    $[6] = propertyInternal;
    $[7] = storedProps;
    $[8] = t4;
  } else {
    t4 = $[8];
  }
  const property2 = t4;
  let t5;
  if ($[9] !== properties) {
    t5 = Object.entries(properties).map(_temp$4);
    $[9] = properties;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  const enumValuesConfigs = t5;
  const typeFieldName = `${name}.${typeField}`;
  const valueFieldName = `${name}.${valueField}`;
  let t6;
  if ($[11] !== autoFocus || $[12] !== context || $[13] !== property2 || $[14] !== storeProps || $[15] !== valueFieldName) {
    t6 = property2 ? {
      propertyKey: valueFieldName,
      property: property2,
      context,
      autoFocus,
      partOfArray: false,
      minimalistView: true,
      onPropertyChange: storeProps
    } : void 0;
    $[11] = autoFocus;
    $[12] = context;
    $[13] = property2;
    $[14] = storeProps;
    $[15] = valueFieldName;
    $[16] = t6;
  } else {
    t6 = $[16];
  }
  const fieldProps = t6;
  const updateType = (newType) => {
    const newSelectedProperty = newType ? properties[newType] : void 0;
    setTypeInternal(newType);
    formex.setFieldTouched(typeFieldName, true);
    formex.setFieldValue(typeFieldName, newType);
    formex.setFieldValue(valueFieldName, newSelectedProperty ? getDefaultValueFor(newSelectedProperty) : null);
  };
  let t7;
  if ($[17] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = cls(paperMixin, "bg-transparent p-2");
    $[17] = t7;
  } else {
    t7 = $[17];
  }
  let t8;
  if ($[18] !== enumValuesConfigs || $[19] !== updateType) {
    t8 = (fieldProps_0) => {
      const value1 = fieldProps_0.field.value !== void 0 && fieldProps_0.field.value !== null ? fieldProps_0.field.value : "";
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Select, { className: "mb-2", placeholder: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", className: "px-4 py-2 font-medium", children: "Type" }), size: "medium", fullWidth: true, position: "item-aligned", value: value1, renderValue: (enumKey) => /* @__PURE__ */ jsxRuntimeExports.jsx(EnumValuesChip, { enumKey, enumValues: enumValuesConfigs, size: "small" }), onValueChange: (value_0) => {
        updateType(value_0);
      }, children: enumValuesConfigs.map((enumConfig) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: String(enumConfig.id), children: /* @__PURE__ */ jsxRuntimeExports.jsx(EnumValuesChip, { enumKey: enumConfig.id, enumValues: enumValuesConfigs, size: "small" }) }, enumConfig.id)) }) });
    };
    $[18] = enumValuesConfigs;
    $[19] = updateType;
    $[20] = t8;
  } else {
    t8 = $[20];
  }
  let t9;
  if ($[21] !== t8 || $[22] !== typeFieldName) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { name: typeFieldName, children: t8 });
    $[21] = t8;
    $[22] = typeFieldName;
    $[23] = t9;
  } else {
    t9 = $[23];
  }
  let t10;
  if ($[24] !== fieldProps || $[25] !== name || $[26] !== typeInternal) {
    t10 = fieldProps && /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyFieldBinding, { ...fieldProps }, `form_control_${name}_${typeInternal}`);
    $[24] = fieldProps;
    $[25] = name;
    $[26] = typeInternal;
    $[27] = t10;
  } else {
    t10 = $[27];
  }
  let t11;
  if ($[28] !== t10 || $[29] !== t9) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t7, children: [
      t9,
      t10
    ] });
    $[28] = t10;
    $[29] = t9;
    $[30] = t11;
  } else {
    t11 = $[30];
  }
  return t11;
}
function _temp$4(t0) {
  const [key, property_0] = t0;
  return {
    id: key,
    label: property_0.name ?? key
  };
}
function MarkdownEditorFieldBinding(t0) {
  const $ = c_1(54);
  const {
    property: property2,
    propertyKey,
    value,
    setValue,
    includeDescription,
    showError,
    error,
    minimalistView,
    context,
    customProps
  } = t0;
  const highlight = customProps?.highlight;
  const editorProps = customProps?.editorProps;
  const storageSource = useStorageSource();
  const storage = property2.storage;
  const entityValues = context.values;
  const entityId = context.entityId;
  const path = context.path;
  const [fieldVersion, setFieldVersion] = useState(0);
  const internalValue = useRef(value);
  let t1;
  if ($[0] !== setValue) {
    t1 = (content) => {
      internalValue.current = content;
      setValue(content);
    };
    $[0] = setValue;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const onContentChange = t1;
  let t2;
  if ($[2] !== fieldVersion || $[3] !== value) {
    t2 = () => {
      if (internalValue.current !== value) {
        internalValue.current = value;
        setFieldVersion(fieldVersion + 1);
      }
    };
    $[2] = fieldVersion;
    $[3] = value;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  let t3;
  if ($[5] !== value) {
    t3 = [value];
    $[5] = value;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  useEffect(t2, t3);
  const t4 = property2;
  let t5;
  if ($[7] !== entityValues || $[8] !== t4) {
    t5 = resolveProperty({
      propertyOrBuilder: t4,
      values: entityValues
    });
    $[7] = entityValues;
    $[8] = t4;
    $[9] = t5;
  } else {
    t5 = $[9];
  }
  const resolvedProperty = t5;
  let t6;
  if ($[10] !== entityId || $[11] !== entityValues || $[12] !== path || $[13] !== propertyKey || $[14] !== resolvedProperty || $[15] !== storage) {
    t6 = async (file) => {
      if (storage?.fileName) {
        const fileName = await resolveStorageFilenameString({
          input: storage.fileName,
          storage,
          values: entityValues,
          entityId,
          path,
          property: resolvedProperty,
          file,
          propertyKey
        });
        if (!fileName || fileName.length === 0) {
          throw Error("You need to return a valid filename");
        }
        return fileName;
      }
      return randomString() + "_" + file.name;
    };
    $[10] = entityId;
    $[11] = entityValues;
    $[12] = path;
    $[13] = propertyKey;
    $[14] = resolvedProperty;
    $[15] = storage;
    $[16] = t6;
  } else {
    t6 = $[16];
  }
  const fileNameBuilder = t6;
  let t7;
  if ($[17] !== entityId || $[18] !== entityValues || $[19] !== path || $[20] !== property2 || $[21] !== propertyKey || $[22] !== storage) {
    t7 = (file_0) => {
      if (!storage) {
        return "/";
      }
      const resolvedProperty_0 = resolveProperty({
        propertyOrBuilder: property2,
        values: entityValues
      });
      return resolveStoragePathString({
        input: storage.storagePath,
        storage,
        values: entityValues,
        entityId,
        path,
        property: resolvedProperty_0,
        file: file_0,
        propertyKey
      }) ?? "/";
    };
    $[17] = entityId;
    $[18] = entityValues;
    $[19] = path;
    $[20] = property2;
    $[21] = propertyKey;
    $[22] = storage;
    $[23] = t7;
  } else {
    t7 = $[23];
  }
  const storagePathBuilder = t7;
  const t8 = context.formex.version + fieldVersion;
  let t9;
  if ($[24] !== fileNameBuilder || $[25] !== storagePathBuilder || $[26] !== storageSource) {
    t9 = async (file_1) => {
      const storagePath = storagePathBuilder(file_1);
      const fileName_0 = await fileNameBuilder(file_1);
      const result = await storageSource.uploadFile({
        file: file_1,
        fileName: fileName_0,
        path: storagePath
      });
      const downloadConfig = await storageSource.getDownloadURL(result.path);
      const url = downloadConfig.url;
      if (!url) {
        throw new Error("Error uploading image");
      }
      return url;
    };
    $[24] = fileNameBuilder;
    $[25] = storagePathBuilder;
    $[26] = storageSource;
    $[27] = t9;
  } else {
    t9 = $[27];
  }
  let t10;
  if ($[28] !== editorProps || $[29] !== highlight || $[30] !== onContentChange || $[31] !== t8 || $[32] !== t9 || $[33] !== value) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(FireCMSEditor, { content: value, onMarkdownContentChange: onContentChange, version: t8, highlight, handleImageUpload: t9, ...editorProps });
    $[28] = editorProps;
    $[29] = highlight;
    $[30] = onContentChange;
    $[31] = t8;
    $[32] = t9;
    $[33] = value;
    $[34] = t10;
  } else {
    t10 = $[34];
  }
  const editor = t10;
  if (minimalistView) {
    return editor;
  }
  let t11;
  if ($[35] !== property2) {
    t11 = getIconForProperty(property2, "small");
    $[35] = property2;
    $[36] = t11;
  } else {
    t11 = $[36];
  }
  const t12 = property2.validation?.required;
  let t13;
  if ($[37] !== property2.name || $[38] !== propertyKey || $[39] !== t11 || $[40] !== t12) {
    t13 = /* @__PURE__ */ jsxRuntimeExports.jsx(LabelWithIconAndTooltip, { propertyKey, icon: t11, required: t12, title: property2.name, className: "text-text-secondary dark:text-text-secondary-dark ml-3.5" });
    $[37] = property2.name;
    $[38] = propertyKey;
    $[39] = t11;
    $[40] = t12;
    $[41] = t13;
  } else {
    t13 = $[41];
  }
  let t14;
  if ($[42] === Symbol.for("react.memo_cache_sentinel")) {
    t14 = cls("rounded-md", fieldBackgroundMixin, fieldBackgroundHoverMixin);
    $[42] = t14;
  } else {
    t14 = $[42];
  }
  let t15;
  if ($[43] !== editor) {
    t15 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t14, children: editor });
    $[43] = editor;
    $[44] = t15;
  } else {
    t15 = $[44];
  }
  let t16;
  if ($[45] !== error || $[46] !== includeDescription || $[47] !== property2 || $[48] !== showError) {
    t16 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldHelperText, { includeDescription, showError, error, property: property2 });
    $[45] = error;
    $[46] = includeDescription;
    $[47] = property2;
    $[48] = showError;
    $[49] = t16;
  } else {
    t16 = $[49];
  }
  let t17;
  if ($[50] !== t13 || $[51] !== t15 || $[52] !== t16) {
    t17 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t13,
      t15,
      t16
    ] });
    $[50] = t13;
    $[51] = t15;
    $[52] = t16;
    $[53] = t17;
  } else {
    t17 = $[53];
  }
  return t17;
}
function ArrayCustomShapedFieldBinding(t0) {
  const $ = c_1(48);
  const {
    propertyKey,
    value,
    error,
    showError,
    setValue,
    minimalistView,
    property: property2,
    includeDescription,
    underlyingValueHasChanged,
    context,
    disabled
  } = t0;
  let resolvedProperties = "resolvedProperties" in property2 ? property2.resolvedProperties : void 0;
  if (!resolvedProperties) {
    let t12;
    if ($[0] !== property2 || $[1] !== propertyKey || $[2] !== value) {
      t12 = getArrayResolvedProperties({
        propertyValue: value,
        propertyKey,
        property: property2,
        ignoreMissingFields: false
      });
      $[0] = property2;
      $[1] = propertyKey;
      $[2] = value;
      $[3] = t12;
    } else {
      t12 = $[3];
    }
    resolvedProperties = t12;
  }
  const expanded = property2.expanded === void 0 ? true : property2.expanded;
  let t1;
  if ($[4] !== property2 || $[5] !== setValue || $[6] !== value) {
    t1 = {
      property: property2,
      value,
      setValue
    };
    $[4] = property2;
    $[5] = setValue;
    $[6] = value;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  useClearRestoreValue(t1);
  let t2;
  if ($[8] !== property2) {
    t2 = getIconForProperty(property2, "small");
    $[8] = property2;
    $[9] = t2;
  } else {
    t2 = $[9];
  }
  const t3 = property2.validation?.required;
  let t4;
  if ($[10] !== property2.name || $[11] !== propertyKey || $[12] !== t2 || $[13] !== t3) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(LabelWithIconAndTooltip, { propertyKey, icon: t2, required: t3, title: property2.name, className: "flex-grow text-text-secondary dark:text-text-secondary-dark" });
    $[10] = property2.name;
    $[11] = propertyKey;
    $[12] = t2;
    $[13] = t3;
    $[14] = t4;
  } else {
    t4 = $[14];
  }
  let t5;
  if ($[15] !== value) {
    t5 = Array.isArray(value) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", className: "px-4", children: [
      "(",
      value.length,
      ")"
    ] });
    $[15] = value;
    $[16] = t5;
  } else {
    t5 = $[16];
  }
  let t6;
  if ($[17] !== t4 || $[18] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t4,
      t5
    ] });
    $[17] = t4;
    $[18] = t5;
    $[19] = t6;
  } else {
    t6 = $[19];
  }
  const title = t6;
  let t7;
  if ($[20] !== context || $[21] !== disabled || $[22] !== includeDescription || $[23] !== propertyKey || $[24] !== resolvedProperties || $[25] !== underlyingValueHasChanged) {
    let t82;
    if ($[27] !== context || $[28] !== disabled || $[29] !== includeDescription || $[30] !== propertyKey || $[31] !== underlyingValueHasChanged) {
      t82 = (childProperty, index2) => {
        const thisDisabled = isReadOnly(childProperty) || Boolean(childProperty.disabled);
        const fieldProps = {
          propertyKey: `${propertyKey}[${index2}]`,
          disabled: disabled || thisDisabled,
          property: childProperty,
          includeDescription,
          underlyingValueHasChanged,
          context,
          partOfArray: true,
          minimalistView: false,
          autoFocus: false
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(PropertyFieldBinding, { ...fieldProps }) }, `custom_shaped_array_${index2}`);
      };
      $[27] = context;
      $[28] = disabled;
      $[29] = includeDescription;
      $[30] = propertyKey;
      $[31] = underlyingValueHasChanged;
      $[32] = t82;
    } else {
      t82 = $[32];
    }
    t7 = resolvedProperties.map(t82);
    $[20] = context;
    $[21] = disabled;
    $[22] = includeDescription;
    $[23] = propertyKey;
    $[24] = resolvedProperties;
    $[25] = underlyingValueHasChanged;
    $[26] = t7;
  } else {
    t7 = $[26];
  }
  const body = t7;
  let t8;
  if ($[33] !== body || $[34] !== expanded || $[35] !== minimalistView || $[36] !== title) {
    t8 = !minimalistView && /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandablePanel, { initiallyExpanded: expanded, title, innerClassName: "px-2 md:px-4 pb-2 md:pb-4 pt-1 md:pt-2", children: body });
    $[33] = body;
    $[34] = expanded;
    $[35] = minimalistView;
    $[36] = title;
    $[37] = t8;
  } else {
    t8 = $[37];
  }
  const t9 = minimalistView && body;
  let t10;
  if ($[38] !== disabled || $[39] !== error || $[40] !== includeDescription || $[41] !== property2 || $[42] !== showError) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx(FieldHelperText, { includeDescription, showError, error, disabled, property: property2 });
    $[38] = disabled;
    $[39] = error;
    $[40] = includeDescription;
    $[41] = property2;
    $[42] = showError;
    $[43] = t10;
  } else {
    t10 = $[43];
  }
  let t11;
  if ($[44] !== t10 || $[45] !== t8 || $[46] !== t9) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      t8,
      t9,
      t10
    ] });
    $[44] = t10;
    $[45] = t8;
    $[46] = t9;
    $[47] = t11;
  } else {
    t11 = $[47];
  }
  return t11;
}
function isDefaultFieldConfigId(id2) {
  return Object.keys(DEFAULT_FIELD_CONFIGS).includes(id2);
}
const DEFAULT_FIELD_CONFIGS = {
  text_field: {
    key: "text_field",
    name: "Text field",
    description: "Simple short text",
    Icon: ShortTextIcon,
    color: "#2d7ff9",
    property: {
      dataType: "string",
      Field: TextFieldBinding
    }
  },
  multiline: {
    key: "multiline",
    name: "Multiline",
    description: "Text with multiple lines",
    Icon: SubjectIcon,
    color: "#2d7ff9",
    property: {
      dataType: "string",
      multiline: true,
      Field: TextFieldBinding
    }
  },
  markdown: {
    key: "markdown",
    name: "Markdown",
    description: "Text with advanced markdown syntax",
    Icon: FormatQuoteIcon,
    color: "#2d7ff9",
    property: {
      dataType: "string",
      markdown: true,
      Field: MarkdownEditorFieldBinding
    }
  },
  url: {
    key: "url",
    name: "Url",
    description: "Text with URL validation",
    Icon: HttpIcon,
    color: "#154fb3",
    property: {
      dataType: "string",
      url: true,
      Field: TextFieldBinding
    }
  },
  email: {
    key: "email",
    name: "Email",
    description: "Text with email validation",
    Icon: MailIcon,
    color: "#154fb3",
    property: {
      dataType: "string",
      email: true,
      Field: TextFieldBinding
    }
  },
  switch: {
    key: "switch",
    name: "Switch",
    description: "Boolean true or false field (or yes or no, 0 or 1...)",
    Icon: FlagIcon,
    color: "#20d9d2",
    property: {
      dataType: "boolean",
      Field: SwitchFieldBinding
    }
  },
  select: {
    key: "select",
    name: "Select/enum",
    description: "Select one text value from within an enumeration",
    Icon: ListIcon,
    color: "#4223c9",
    property: {
      dataType: "string",
      enumValues: [],
      Field: SelectFieldBinding
    }
  },
  multi_select: {
    key: "multi_select",
    name: "Multi select (enum)",
    description: "Select multiple text values from within an enumeration",
    Icon: ListAltIcon,
    color: "#4223c9",
    property: {
      dataType: "array",
      of: {
        dataType: "string",
        enumValues: []
      },
      Field: MultiSelectFieldBinding
    }
  },
  number_input: {
    key: "number_input",
    name: "Number input",
    description: "Simple number field with validation",
    Icon: NumbersIcon,
    color: "#bec920",
    property: {
      dataType: "number",
      Field: TextFieldBinding
    }
  },
  number_select: {
    key: "number_select",
    name: "Number select",
    description: "Select a number value from within an enumeration",
    Icon: FormatListNumberedIcon,
    color: "#bec920",
    property: {
      dataType: "number",
      enumValues: [],
      Field: SelectFieldBinding
    }
  },
  multi_number_select: {
    key: "multi_number_select",
    name: "Multiple number select",
    description: "Select multiple number values from within an enumeration",
    Icon: FormatListNumberedIcon,
    color: "#bec920",
    property: {
      dataType: "array",
      of: {
        dataType: "number",
        enumValues: []
      },
      Field: MultiSelectFieldBinding
    }
  },
  file_upload: {
    key: "file_upload",
    name: "File upload",
    description: "Input for uploading single files",
    Icon: UploadFileIcon,
    color: "#f92d9a",
    property: {
      dataType: "string",
      storage: {
        storagePath: "{path}"
      },
      Field: StorageUploadFieldBinding
    }
  },
  multi_file_upload: {
    key: "multi_file_upload",
    name: "Multiple file upload",
    description: "Input for uploading multiple files",
    Icon: DriveFolderUploadIcon,
    color: "#f92d9a",
    property: {
      dataType: "array",
      of: {
        dataType: "string",
        storage: {
          storagePath: "{path}"
        }
      },
      Field: StorageUploadFieldBinding
    }
  },
  reference: {
    key: "reference",
    name: "Reference",
    description: "The value refers to a different collection",
    Icon: LinkIcon,
    color: "#ff0042",
    property: {
      dataType: "reference",
      Field: ReferenceFieldBinding
    }
  },
  multi_references: {
    key: "multi_references",
    name: "Multiple references",
    description: "Multiple values that refer to a different collection",
    Icon: AddLinkIcon,
    color: "#ff0042",
    property: {
      dataType: "array",
      of: {
        dataType: "reference"
      },
      Field: ArrayOfReferencesFieldBinding
    }
  },
  date_time: {
    key: "date_time",
    name: "Date/time",
    description: "A date time select field",
    Icon: ScheduleIcon,
    color: "#8b46ff",
    property: {
      dataType: "date",
      Field: DateTimeFieldBinding
    }
  },
  group: {
    key: "group",
    name: "Group",
    description: "Group of multiple fields",
    Icon: BallotIcon,
    color: "#ff9408",
    property: {
      dataType: "map",
      properties: {},
      Field: MapFieldBinding
    }
  },
  key_value: {
    key: "key_value",
    name: "Key-value",
    description: "Flexible field that allows the user to add multiple key-value pairs",
    Icon: BallotIcon,
    color: "#ff9408",
    property: {
      dataType: "map",
      keyValue: true,
      Field: KeyValueFieldBinding
    }
  },
  repeat: {
    key: "repeat",
    name: "Repeat/list",
    description: "A field that gets repeated multiple times (e.g. multiple text fields)",
    Icon: RepeatIcon,
    color: "#ff9408",
    property: {
      dataType: "array",
      of: {
        dataType: "string"
      },
      Field: RepeatFieldBinding
    }
  },
  custom_array: {
    key: "custom_array",
    name: "Custom array",
    description: "A field that saved its value as an array of custom objects",
    Icon: RepeatIcon,
    color: "#ff9408",
    property: {
      dataType: "array",
      of: [],
      Field: ArrayCustomShapedFieldBinding
    }
  },
  block: {
    key: "block",
    name: "Block",
    description: "A complex field that allows the user to compose different fields together, with a key/value format",
    Icon: ViewStreamIcon,
    color: "#ff9408",
    property: {
      dataType: "array",
      oneOf: {
        properties: {}
      },
      Field: BlockFieldBinding
    }
  }
};
function getDefaultFieldConfig(property2) {
  const fieldId = getDefaultFieldId(property2);
  if (!fieldId) {
    console.error("No field id found for property", property2);
    return void 0;
  }
  return DEFAULT_FIELD_CONFIGS[fieldId];
}
function getFieldConfig(property2, propertyConfigs) {
  const fieldId = getFieldId(property2);
  const defaultFieldId = getDefaultFieldId(property2);
  if (!defaultFieldId) {
    console.error("No field id found for property", property2);
    return void 0;
  }
  const defaultFieldConfig = DEFAULT_FIELD_CONFIGS[defaultFieldId];
  const customField = fieldId ? propertyConfigs[fieldId] : void 0;
  return mergeDeep(defaultFieldConfig ?? {}, customField ?? {});
}
function getDefaultFieldId(property2) {
  if (property2.dataType === "string") {
    if (property2.multiline) {
      return "multiline";
    } else if (property2.markdown) {
      return "markdown";
    } else if (property2.storage) {
      return "file_upload";
    } else if (property2.url) {
      return "url";
    } else if (property2.email) {
      return "email";
    } else if (property2.enumValues) {
      return "select";
    } else {
      return "text_field";
    }
  } else if (property2.dataType === "number") {
    if (property2.enumValues) {
      return "number_select";
    }
    return "number_input";
  } else if (property2.dataType === "map") {
    if (property2.keyValue) return "key_value";
    return "group";
  } else if (property2.dataType === "array") {
    const of = property2.of;
    const oneOf = property2.oneOf;
    if (oneOf) {
      return "block";
    } else if (Array.isArray(of)) {
      return "custom_array";
    } else if (isPropertyBuilder(of)) {
      return "repeat";
    } else if (of?.dataType === "string" && of.enumValues) {
      return "multi_select";
    } else if (of?.dataType === "number" && of.enumValues) {
      return "multi_number_select";
    } else if (of?.dataType === "string" && of.storage) {
      return "multi_file_upload";
    } else if (of?.dataType === "reference") {
      return "multi_references";
    } else {
      return "repeat";
    }
  } else if (property2.dataType === "boolean") {
    return "switch";
  } else if (property2.dataType === "date") {
    return "date_time";
  } else if (property2.dataType === "reference") {
    return "reference";
  }
  console.error("Unsupported field config mapping", property2);
  return void 0;
}
function getFieldId(property2) {
  if (property2.propertyConfig) return property2.propertyConfig;
  return getDefaultFieldId(property2);
}
const resolveCollection = ({
  collection,
  path,
  entityId,
  values,
  previousValues,
  userConfigPersistence,
  propertyConfigs,
  ignoreMissingFields = false
}) => {
  const collectionOverride = userConfigPersistence?.getCollectionConfig(path);
  const storedProperties = getValueInPath(collectionOverride, "properties");
  const defaultValues = getDefaultValuesFor(collection.properties);
  const usedValues = values ?? defaultValues;
  const usedPreviousValues = previousValues ?? values ?? defaultValues;
  const resolvedProperties = Object.entries(collection.properties).map(([key, propertyOrBuilder]) => {
    const childResolvedProperty = resolveProperty({
      propertyKey: key,
      propertyOrBuilder,
      values: usedValues,
      previousValues: usedPreviousValues,
      path,
      entityId,
      propertyConfigs,
      ignoreMissingFields
    });
    if (!childResolvedProperty) return {};
    return {
      [key]: childResolvedProperty
    };
  }).filter((a2) => a2 !== null).reduce((a2, b) => ({
    ...a2,
    ...b
  }), {});
  const properties = mergeDeep(resolvedProperties, storedProperties);
  const cleanedProperties = Object.entries(properties).filter(([_, property2]) => Boolean(property2?.dataType)).map(([id2, property2]) => ({
    [id2]: property2
  })).reduce((a2, b) => ({
    ...a2,
    ...b
  }), {});
  return {
    ...collection,
    properties: cleanedProperties,
    originalCollection: collection
  };
};
function resolveProperty({
  propertyOrBuilder,
  fromBuilder = false,
  ignoreMissingFields = false,
  ...props
}) {
  if (typeof propertyOrBuilder === "object" && "resolved" in propertyOrBuilder) {
    return propertyOrBuilder;
  }
  let resolvedProperty = null;
  if (!propertyOrBuilder) {
    return null;
  } else if (isPropertyBuilder(propertyOrBuilder)) {
    const path = props.path;
    if (!path) throw Error("Trying to resolve a property builder without specifying the entity path");
    const usedPropertyValue = props.propertyKey ? getIn(props.values, props.propertyKey) : void 0;
    const result = propertyOrBuilder({
      ...props,
      path,
      propertyValue: usedPropertyValue,
      values: props.values ?? {},
      previousValues: props.previousValues ?? props.values ?? {}
    });
    if (!result) {
      return null;
    }
    resolvedProperty = resolveProperty({
      ...props,
      propertyOrBuilder: result,
      fromBuilder: true,
      ignoreMissingFields
    });
  } else {
    const property2 = propertyOrBuilder;
    if (property2.dataType === "map" && property2.properties) {
      const properties = resolveProperties({
        ignoreMissingFields,
        ...props,
        properties: property2.properties
      });
      resolvedProperty = {
        ...property2,
        resolved: true,
        fromBuilder,
        properties
      };
    } else if (property2.dataType === "array") {
      resolvedProperty = resolveArrayProperty({
        property: property2,
        fromBuilder,
        ignoreMissingFields,
        ...props
      });
    } else if ((property2.dataType === "string" || property2.dataType === "number") && property2.enumValues) {
      resolvedProperty = resolvePropertyEnum(property2, fromBuilder);
    }
  }
  if (!resolvedProperty) {
    resolvedProperty = {
      ...propertyOrBuilder,
      resolved: true,
      fromBuilder
    };
  }
  if (resolvedProperty.propertyConfig && !isDefaultFieldConfigId(resolvedProperty.propertyConfig)) {
    const cmsFields = props.propertyConfigs;
    if (!cmsFields && !ignoreMissingFields) {
      throw Error(`Trying to resolve a property with key '${resolvedProperty.propertyConfig}' that inherits from a custom property config but no custom property configs were provided. Use the property 'propertyConfigs' in your app config to provide them`);
    }
    const customField = cmsFields?.[resolvedProperty.propertyConfig];
    if (!customField) {
      console.warn(`Trying to resolve a property with key '${resolvedProperty.propertyConfig}' that inherits from a custom property config but no custom property config with that key was found. Check the 'propertyConfigs' in your app config`);
      console.warn("Available property configs", cmsFields);
      return null;
    }
    if (customField.property) {
      const configPropertyOrBuilder = customField.property;
      if ("propertyConfig" in configPropertyOrBuilder) {
        delete configPropertyOrBuilder.propertyConfig;
      }
      const customFieldProperty = resolveProperty({
        propertyOrBuilder: configPropertyOrBuilder,
        ignoreMissingFields,
        ...props
      });
      if (customFieldProperty) {
        resolvedProperty = mergeDeep(customFieldProperty, resolvedProperty);
      }
    }
  }
  return resolvedProperty ? {
    ...resolvedProperty,
    resolved: true
  } : null;
}
function getArrayResolvedProperties({
  propertyKey,
  propertyValue,
  property: property2,
  ...props
}) {
  const of = property2.of;
  return Array.isArray(propertyValue) ? propertyValue.map((v, index2) => {
    return resolveProperty({
      propertyKey: `${propertyKey}.${index2}`,
      propertyOrBuilder: of,
      ...props,
      index: index2
    });
  }).filter((e2) => Boolean(e2)) : [];
}
function resolveArrayProperty({
  propertyKey,
  property: property2,
  ignoreMissingFields = false,
  ...props
}) {
  const propertyValue = propertyKey ? getIn(props.values, propertyKey) : void 0;
  if (property2.of) {
    if (Array.isArray(property2.of)) {
      return {
        ...property2,
        resolved: true,
        fromBuilder: props.fromBuilder,
        resolvedProperties: property2.of.map((p2, index2) => {
          return resolveProperty({
            propertyKey: `${propertyKey}.${index2}`,
            propertyOrBuilder: p2,
            ignoreMissingFields,
            ...props,
            index: index2
          });
        })
      };
    } else {
      const of = property2.of;
      const resolvedProperties = getArrayResolvedProperties({
        propertyValue,
        propertyKey,
        property: property2,
        ignoreMissingFields,
        ...props
      });
      const ofProperty = resolveProperty({
        propertyOrBuilder: of,
        ignoreMissingFields,
        ...props
      });
      if (!ofProperty && !ignoreMissingFields) throw Error("When using a property builder as the 'of' prop of an ArrayProperty, you must return a valid child property");
      return {
        ...property2,
        resolved: true,
        fromBuilder: props.fromBuilder,
        of: ofProperty,
        resolvedProperties
      };
    }
  } else if (property2.oneOf) {
    const typeField = property2.oneOf?.typeField ?? DEFAULT_ONE_OF_TYPE;
    const resolvedProperties = Array.isArray(propertyValue) ? propertyValue.map((v, index2) => {
      const type = v && v[typeField];
      const childProperty = property2.oneOf?.properties[type];
      if (!type || !childProperty) return null;
      return resolveProperty({
        propertyKey: `${propertyKey}.${index2}`,
        propertyOrBuilder: childProperty,
        ignoreMissingFields,
        ...props
      });
    }).filter((e2) => Boolean(e2)) : [];
    const properties = resolveProperties({
      propertyKey,
      properties: property2.oneOf.properties,
      ignoreMissingFields,
      ...props
    });
    return {
      ...property2,
      resolved: true,
      oneOf: {
        ...property2.oneOf,
        properties
      },
      fromBuilder: props.fromBuilder,
      resolvedProperties
    };
  } else if (!property2.Field) {
    throw Error("The array property needs to declare an 'of' or a 'oneOf' property, or provide a custom `Field`");
  } else {
    return {
      ...property2,
      resolved: true,
      fromBuilder: props.fromBuilder
    };
  }
}
function resolveProperties({
  propertyKey,
  properties,
  ignoreMissingFields,
  ...props
}) {
  return Object.entries(properties).map(([key, property2]) => {
    const childResolvedProperty = resolveProperty({
      propertyKey: propertyKey ? `${propertyKey}.${key}` : void 0,
      propertyOrBuilder: property2,
      ignoreMissingFields,
      ...props
    });
    if (!childResolvedProperty) return {};
    return {
      [key]: childResolvedProperty
    };
  }).filter((a2) => a2 !== null).reduce((a2, b) => ({
    ...a2,
    ...b
  }), {});
}
function resolvePropertyEnum(property2, fromBuilder) {
  if (typeof property2.enumValues === "object") {
    return {
      ...property2,
      resolved: true,
      enumValues: enumToObjectEntries(property2.enumValues)?.filter((value) => value && (value.id || value.id === 0) && value.label) ?? [],
      fromBuilder: fromBuilder ?? false
    };
  }
  return property2;
}
function resolveEnumValues(input) {
  if (typeof input === "object") {
    return Object.entries(input).map(([id2, value]) => typeof value === "string" ? {
      id: id2,
      label: value
    } : value);
  } else if (Array.isArray(input)) {
    return input;
  } else {
    return void 0;
  }
}
function resolveEntityView(entityView, contextEntityViews) {
  if (typeof entityView === "string") {
    return contextEntityViews?.find((entry) => entry.key === entityView);
  } else {
    return entityView;
  }
}
function getNavigationEntriesFromPathInternal(props) {
  const {
    path,
    collections = [],
    currentFullPath
  } = props;
  const subpaths = removeInitialAndTrailingSlashes(path).split("/");
  const subpathCombinations = getCollectionPathsCombinations(subpaths);
  const result = [];
  for (let i = 0; i < subpathCombinations.length; i++) {
    const subpathCombination = subpathCombinations[i];
    const collection = collections && collections.find((entry) => entry.id === subpathCombination || entry.path === subpathCombination);
    if (collection) {
      const pathOrAlias = collection.id ?? collection.path;
      const collectionPath = currentFullPath && currentFullPath.length > 0 ? currentFullPath + "/" + pathOrAlias : pathOrAlias;
      result.push({
        type: "collection",
        path: collectionPath,
        collection
      });
      const restOfThePath = removeInitialAndTrailingSlashes(removeInitialAndTrailingSlashes(path).replace(subpathCombination, ""));
      const nextSegments = restOfThePath.length > 0 ? restOfThePath.split("/") : [];
      if (nextSegments.length > 0) {
        const entityId = nextSegments[0];
        const fullPath = collectionPath + "/" + entityId;
        result.push({
          type: "entity",
          entityId,
          path: collectionPath,
          parentCollection: collection
        });
        if (nextSegments.length > 1) {
          const newPath = nextSegments.slice(1).join("/");
          if (!collection) {
            throw Error("collection not found resolving path: " + collection);
          }
          const entityViews = collection.entityViews;
          const customView = entityViews && entityViews.map((entry) => resolveEntityView(entry, props.contextEntityViews)).filter(Boolean).find((entry) => entry.key === newPath);
          if (customView) {
            const path2 = currentFullPath && currentFullPath.length > 0 ? currentFullPath + "/" + customView.key : customView.key;
            result.push({
              type: "custom_view",
              path: path2,
              view: customView
            });
          } else if (collection.subcollections) {
            result.push(...getNavigationEntriesFromPathInternal({
              path: newPath,
              collections: collection.subcollections,
              currentFullPath: fullPath,
              contextEntityViews: props.contextEntityViews
            }));
          }
        }
      }
      break;
    }
  }
  return result;
}
const CONTAINER_FULL_WIDTH = "100vw";
const ADDITIONAL_TAB_WIDTH = "55vw";
const FORM_CONTAINER_WIDTH = "768px";
function useNavigationUnsavedChangesDialog(when, onSuccess) {
  const $ = c_1(13);
  const [nextLocation, setNextLocation] = React__default.useState();
  const {
    navigator: navigator2
  } = React__default.useContext(NavigationContext$1);
  const navigate = useNavigate();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      setNextLocation(void 0);
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const handleCancel = t0;
  let t1;
  if ($[1] !== navigate || $[2] !== onSuccess) {
    t1 = () => {
      onSuccess();
      setNextLocation(void 0);
      navigate(-1);
    };
    $[1] = navigate;
    $[2] = onSuccess;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const handleOk = t1;
  let t2;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = (t32) => {
      const {
        action,
        location: nextLocation_0,
        retry
      } = t32;
      switch (action) {
        case "REPLACE": {
          retry();
          return;
        }
        case "POP": {
          setNextLocation(nextLocation_0);
        }
      }
    };
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  const blocker = t2;
  let t3;
  let t4;
  if ($[5] !== navigator2 || $[6] !== nextLocation || $[7] !== when) {
    t3 = () => {
      if (!when) {
        return;
      }
      if (nextLocation) {
        return;
      }
      if (!("block" in navigator2)) {
        return;
      }
      const unblock = navigator2.block((tx) => {
        const autoUnblockingTx = {
          ...tx,
          retry() {
            unblock();
            tx.retry();
          }
        };
        blocker(autoUnblockingTx);
      });
      return unblock;
    };
    t4 = [navigator2, blocker, when, nextLocation];
    $[5] = navigator2;
    $[6] = nextLocation;
    $[7] = when;
    $[8] = t3;
    $[9] = t4;
  } else {
    t3 = $[8];
    t4 = $[9];
  }
  React__default.useEffect(t3, t4);
  const t5 = Boolean(nextLocation);
  let t6;
  if ($[10] !== handleOk || $[11] !== t5) {
    t6 = {
      navigationWasBlocked: t5,
      handleCancel,
      handleOk
    };
    $[10] = handleOk;
    $[11] = t5;
    $[12] = t6;
  } else {
    t6 = $[12];
  }
  return t6;
}
function UnsavedChangesDialog(t0) {
  const $ = c_1(20);
  const {
    open,
    handleOk,
    handleCancel,
    body,
    title
  } = t0;
  let t1;
  if ($[0] !== handleCancel) {
    t1 = () => {
      handleCancel();
    };
    $[0] = handleCancel;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== title) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { variant: "h6", children: title });
    $[2] = title;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { children: "Are you sure you want to leave this page?" });
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== body) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { children: [
      body,
      t3
    ] });
    $[5] = body;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  let t5;
  if ($[7] !== handleCancel) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "text", onClick: handleCancel, autoFocus: true, children: " Cancel " });
    $[7] = handleCancel;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  let t6;
  if ($[9] !== handleOk) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleOk, children: " Ok " });
    $[9] = handleOk;
    $[10] = t6;
  } else {
    t6 = $[10];
  }
  let t7;
  if ($[11] !== t5 || $[12] !== t6) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions, { children: [
      t5,
      t6
    ] });
    $[11] = t5;
    $[12] = t6;
    $[13] = t7;
  } else {
    t7 = $[13];
  }
  let t8;
  if ($[14] !== open || $[15] !== t1 || $[16] !== t2 || $[17] !== t4 || $[18] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { onEscapeKeyDown: t1, open, children: [
      t2,
      t4,
      t7
    ] });
    $[14] = open;
    $[15] = t1;
    $[16] = t2;
    $[17] = t4;
    $[18] = t7;
    $[19] = t8;
  } else {
    t8 = $[19];
  }
  return t8;
}
const SideDialogContext = React__default.createContext({
  width: "",
  blocked: false,
  setBlocked: (blocked) => {
  },
  setBlockedNavigationMessage: (message2) => {
  },
  close: () => {
  }
});
const useSideDialogContext = () => {
  return useContext(SideDialogContext);
};
function SideDialogs() {
  const $ = c_1(5);
  const sideDialogsController = useSideDialogsController();
  const sidePanels = sideDialogsController.sidePanels;
  let panels;
  if ($[0] !== sidePanels) {
    panels = [...sidePanels];
    panels.push(void 0);
    $[0] = sidePanels;
    $[1] = panels;
  } else {
    panels = $[1];
  }
  let t0;
  if ($[2] !== panels || $[3] !== sidePanels.length) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: panels.map((panel, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(SideDialogView, { panel, offsetPosition: sidePanels.length - index2 - 1 }, `side_dialog_${index2}`)) });
    $[2] = panels;
    $[3] = sidePanels.length;
    $[4] = t0;
  } else {
    t0 = $[4];
  }
  return t0;
}
function SideDialogView({
  offsetPosition,
  panel
}) {
  const [drawerCloseRequested, setDrawerCloseRequested] = useState(false);
  const [blocked, setBlocked] = useState(false);
  const [blockedNavigationMessage, setBlockedNavigationMessage] = useState();
  const widthRef = React__default.useRef(panel?.width);
  const width = widthRef.current;
  const sideDialogsController = useSideDialogsController();
  const {
    navigationWasBlocked,
    handleOk: handleNavigationOk,
    handleCancel: handleNavigationCancel
  } = useNavigationUnsavedChangesDialog(blocked && !drawerCloseRequested, () => setBlocked(false));
  useEffect(() => {
    if (panel) widthRef.current = panel.width;
  }, [panel]);
  const handleDrawerCloseOk = () => {
    setBlocked(false);
    setDrawerCloseRequested(false);
    sideDialogsController.close();
    panel?.onClose?.();
  };
  const handleDrawerCloseCancel = () => {
    setDrawerCloseRequested(false);
  };
  const onCloseRequest = (force) => {
    if (blocked && !force) {
      setDrawerCloseRequested(true);
    } else {
      sideDialogsController.close();
      panel?.onClose?.();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SideDialogContext.Provider, { value: {
    blocked,
    setBlocked,
    setBlockedNavigationMessage,
    width,
    close: onCloseRequest
  }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Sheet, { open: Boolean(panel), onOpenChange: (open) => !open && onCloseRequest(), title: "Side dialog " + panel?.key, children: [
      panel && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "transform max-w-[100vw] lg:max-w-[95vw] flex flex-col h-full transition-all duration-250 ease-in-out bg-white dark:bg-surface-900 ", style: {
        width: panel.width,
        transform: `translateX(-${offsetPosition * 200}px)`
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: panel.component }) }),
      !panel && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
        width
      } })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(UnsavedChangesDialog, { open: navigationWasBlocked || drawerCloseRequested, handleOk: drawerCloseRequested ? handleDrawerCloseOk : handleNavigationOk, handleCancel: drawerCloseRequested ? handleDrawerCloseCancel : handleNavigationCancel, body: blockedNavigationMessage })
  ] });
}
function EntitySidePanel(props) {
  const {
    blocked,
    setBlocked,
    setBlockedNavigationMessage
  } = useSideDialogContext();
  const navigationController = useNavigationController();
  const parentCollectionIds = useMemo(() => {
    return navigationController.getParentCollectionIds(props.path);
  }, [navigationController, props.path]);
  const collection = useMemo(() => {
    if (!props) return void 0;
    let usedCollection = props.collection;
    const registryCollection = navigationController.getCollection(props.path);
    if (registryCollection) {
      usedCollection = registryCollection;
    }
    if (!usedCollection) {
      console.error("ERROR: No collection found in path `", props.path, "`. Entity id: ", props.entityId);
      throw Error("ERROR: No collection found in path `" + props.path + "`. Make sure you have defined a collection for this path in the root navigation.");
    }
    return usedCollection;
  }, [navigationController, props]);
  useEffect(() => {
    function beforeunload(e2) {
      if (blocked && collection) {
        e2.preventDefault();
        e2.returnValue = `You have unsaved changes in this ${collection.name}. Are you sure you want to leave this page?`;
      }
    }
    if (typeof window !== "undefined") window.addEventListener("beforeunload", beforeunload);
    return () => {
      if (typeof window !== "undefined") window.removeEventListener("beforeunload", beforeunload);
    };
  }, [blocked, collection]);
  const onValuesAreModified = useCallback((modified) => {
    setBlocked(modified);
    setBlockedNavigationMessage(modified ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      " You have unsaved changes in this ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: collection?.singularName ?? collection?.name }),
      "."
    ] }) : void 0);
  }, [collection?.name, setBlocked, setBlockedNavigationMessage]);
  if (!props || !collection) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full" });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(EntityEditView, { ...props, collection, parentCollectionIds, onValuesAreModified }) }) });
}
const NEW_URL_HASH = "new";
function getEntityViewWidth(props, small) {
  if (small) return CONTAINER_FULL_WIDTH;
  const mainViewSelected = !props.selectedSubPath;
  let resolvedWidth;
  if (props.width) {
    resolvedWidth = typeof props.width === "number" ? `${props.width}px` : props.width;
  } else if (props.collection?.sideDialogWidth) {
    resolvedWidth = typeof props.collection.sideDialogWidth === "number" ? `${props.collection.sideDialogWidth}px` : props.collection.sideDialogWidth;
  }
  if (!mainViewSelected) {
    return `calc(${ADDITIONAL_TAB_WIDTH} + ${resolvedWidth ?? FORM_CONTAINER_WIDTH})`;
  } else {
    if (resolvedWidth) {
      return resolvedWidth;
    } else if (!props.collection) {
      return FORM_CONTAINER_WIDTH;
    } else {
      return calculateCollectionDesiredWidth(props.collection);
    }
  }
}
const collectionViewWidthCache = {};
function calculateCollectionDesiredWidth(collection) {
  if (collectionViewWidthCache[collection.id]) {
    return collectionViewWidthCache[collection.id];
  }
  const resolvedCollection = resolveCollection({
    collection,
    path: "__ignored",
    ignoreMissingFields: true
  });
  let result = FORM_CONTAINER_WIDTH;
  if (resolvedCollection?.properties) {
    const values = Object.values(resolvedCollection.properties).map((p2) => getNestedPropertiesDepth(p2));
    const maxDepth = Math.max(...values);
    if (maxDepth < 3) {
      result = FORM_CONTAINER_WIDTH;
    } else {
      result = 768 + 32 * (maxDepth - 2) + "px";
    }
  }
  collectionViewWidthCache[collection.id] = result;
  return result;
}
function getNestedPropertiesDepth(property2, accumulator = 0) {
  if (property2.dataType === "map" && property2.properties) {
    const values = Object.values(property2.properties).flatMap((property22) => getNestedPropertiesDepth(property22, accumulator + 1));
    return Math.max(...values);
  } else if (property2.dataType === "array" && property2.oneOf) {
    return accumulator + 3;
  } else if (property2.dataType === "array" && property2.of) {
    if (Array.isArray(property2.of)) {
      return Math.max(...property2.of.map((p2) => getNestedPropertiesDepth(p2, accumulator + 1)));
    } else {
      return getNestedPropertiesDepth(property2.of, accumulator + 1);
    }
  } else {
    return accumulator + 1;
  }
}
const useBuildSideEntityController = (navigation, sideDialogsController) => {
  const location = useLocation();
  const initialised = useRef(false);
  const smallLayout = !useLargeLayout();
  useEffect(() => {
    if (!navigation.loading && !initialised.current) {
      console.debug("Initialising side entity controller");
      if (navigation.isUrlCollectionPath(location.pathname)) {
        const newFlag = location.hash === `#${NEW_URL_HASH}`;
        const entityOrCollectionPath = navigation.urlPathToDataPath(location.pathname);
        const panelsFromUrl = buildSidePanelsFromUrl(entityOrCollectionPath, navigation.collections ?? [], newFlag);
        for (let i = 0; i < panelsFromUrl.length; i++) {
          const props = panelsFromUrl[i];
          setTimeout(() => {
            if (i === 0) sideDialogsController.replace(propsToSidePanel(props, navigation.buildUrlCollectionPath, navigation.resolveAliasesFrom, smallLayout));
            else sideDialogsController.open(propsToSidePanel(props, navigation.buildUrlCollectionPath, navigation.resolveAliasesFrom, smallLayout));
          }, 1);
        }
      }
      initialised.current = true;
    }
  }, [location, navigation.loading, navigation.isUrlCollectionPath, navigation.buildUrlCollectionPath, navigation.resolveAliasesFrom, sideDialogsController, smallLayout, navigation]);
  useEffect(() => {
    const updatedSidePanels = sideDialogsController.sidePanels.map((sidePanelProps) => {
      if (sidePanelProps.additional) {
        return propsToSidePanel(sidePanelProps.additional, navigation.buildUrlCollectionPath, navigation.resolveAliasesFrom, smallLayout);
      }
      return sidePanelProps;
    });
    sideDialogsController.setSidePanels(updatedSidePanels);
  }, [smallLayout]);
  const close2 = useCallback(() => {
    sideDialogsController.close();
  }, [sideDialogsController]);
  const open = useCallback((props_0) => {
    if (props_0.copy && !props_0.entityId) {
      throw Error("If you want to copy an entity you need to provide an entityId");
    }
    const defaultSelectedView = resolveDefaultSelectedView(props_0.collection ? props_0.collection.defaultSelectedView : void 0, {
      status: props_0.copy ? "copy" : props_0.entityId ? "existing" : "new",
      entityId: props_0.entityId
    });
    sideDialogsController.open(propsToSidePanel({
      selectedSubPath: defaultSelectedView,
      ...props_0
    }, navigation.buildUrlCollectionPath, navigation.resolveAliasesFrom, smallLayout));
  }, [sideDialogsController, navigation.buildUrlCollectionPath, navigation.resolveAliasesFrom, smallLayout]);
  const replace2 = useCallback((props_1) => {
    if (props_1.copy && !props_1.entityId) {
      throw Error("If you want to copy an entity you need to provide an entityId");
    }
    sideDialogsController.replace(propsToSidePanel(props_1, navigation.buildUrlCollectionPath, navigation.resolveAliasesFrom, smallLayout));
  }, [navigation.buildUrlCollectionPath, navigation.resolveAliasesFrom, sideDialogsController, smallLayout]);
  return {
    close: close2,
    open,
    replace: replace2
  };
};
function buildSidePanelsFromUrl(path, collections, newFlag) {
  const navigationViewsForPath = getNavigationEntriesFromPathInternal({
    path,
    collections
  });
  const sidePanels = [];
  let lastCollectionPath = "";
  for (let i = 0; i < navigationViewsForPath.length; i++) {
    const navigationEntry = navigationViewsForPath[i];
    if (navigationEntry.type === "collection") {
      lastCollectionPath = navigationEntry.path;
    }
    if (i > 0) {
      const previousEntry = navigationViewsForPath[i - 1];
      if (navigationEntry.type === "entity") {
        sidePanels.push({
          path: navigationEntry.path,
          entityId: navigationEntry.entityId,
          copy: false,
          width: navigationEntry.parentCollection?.sideDialogWidth
        });
      } else if (navigationEntry.type === "custom_view") {
        if (previousEntry.type === "entity") {
          const lastSidePanel = sidePanels[sidePanels.length - 1];
          if (lastSidePanel) lastSidePanel.selectedSubPath = navigationEntry.view.key;
        }
      } else if (navigationEntry.type === "collection") {
        if (previousEntry.type === "entity") {
          const lastSidePanel = sidePanels[sidePanels.length - 1];
          if (lastSidePanel) lastSidePanel.selectedSubPath = navigationEntry.collection.id ?? navigationEntry.collection.path;
        }
      }
    }
  }
  if (newFlag) {
    sidePanels.push({
      path: lastCollectionPath,
      copy: false
    });
  }
  return sidePanels;
}
const propsToSidePanel = (props, buildUrlCollectionPath, resolveAliasesFrom, smallLayout) => {
  const collectionPath = removeInitialAndTrailingSlashes(props.path);
  const newPath = props.entityId ? buildUrlCollectionPath(`${collectionPath}/${props.entityId}/${props.selectedSubPath || ""}`) : buildUrlCollectionPath(`${collectionPath}#${NEW_URL_HASH}`);
  const resolvedPath = resolveAliasesFrom(props.path);
  const resolvedPanelProps = {
    ...props,
    path: resolvedPath
  };
  const entityViewWidth = getEntityViewWidth(props, smallLayout);
  return {
    key: `${props.path}/${props.entityId}`,
    component: /* @__PURE__ */ jsxRuntimeExports.jsx(EntitySidePanel, { ...resolvedPanelProps }),
    urlPath: newPath,
    parentUrlPath: buildUrlCollectionPath(collectionPath),
    width: entityViewWidth,
    onClose: props.onClose,
    additional: props
  };
};
function useBuildSideDialogsController() {
  const $ = c_1(24);
  const location = useLocation();
  const navigate = useNavigate();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const [sidePanels, setSidePanels] = useState(t0);
  const sidePanelsRef = useRef(sidePanels);
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = {};
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const routesStore = useRef(t1);
  const routesCount = useRef(0);
  let t2;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = (newPanels) => {
      sidePanelsRef.current = newPanels;
      setSidePanels(newPanels);
    };
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  const updateSidePanels = t2;
  let t3;
  if ($[3] !== location.state) {
    t3 = () => {
      const state = location.state;
      const panelKeys = state?.panels ?? [];
      const newPanels_0 = panelKeys.map((key) => routesStore.current[key]).filter(_temp$3);
      if (!equal(sidePanelsRef.current.map(_temp2$2), newPanels_0.map(_temp3$1))) {
        updateSidePanels(newPanels_0);
      }
    };
    $[3] = location.state;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== location) {
    t4 = [location];
    $[5] = location;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  useEffect(t3, t4);
  let t5;
  if ($[7] !== location || $[8] !== navigate || $[9] !== sidePanels) {
    t5 = () => {
      if (sidePanels.length === 0) {
        return;
      }
      const lastSidePanel = sidePanels[sidePanels.length - 1];
      const updatedPanels = [...sidePanels.slice(0, -1)];
      updateSidePanels(updatedPanels);
      if (routesCount.current > 0) {
        if (lastSidePanel.urlPath) {
          navigate(-1);
        }
        routesCount.current = routesCount.current - 1;
      } else {
        if (lastSidePanel.parentUrlPath) {
          const baseLocation = location.state?.base_location ?? location;
          navigate(lastSidePanel.parentUrlPath, {
            replace: true,
            state: {
              base_location: baseLocation,
              panels: updatedPanels.map(_temp4)
            }
          });
        }
      }
    };
    $[7] = location;
    $[8] = navigate;
    $[9] = sidePanels;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  const close2 = t5;
  let t6;
  if ($[11] !== location || $[12] !== navigate || $[13] !== sidePanels) {
    t6 = (panelProps) => {
      const newPanels_1 = Array.isArray(panelProps) ? panelProps : [panelProps];
      newPanels_1.forEach((panel) => {
        routesStore.current[panel.key] = panel;
      });
      routesCount.current = routesCount.current + newPanels_1.length;
      const baseLocation_0 = location.state?.base_location ?? location;
      const updatedPanels_0 = [...sidePanels, ...newPanels_1];
      updateSidePanels(updatedPanels_0);
      newPanels_1.forEach((panel_0) => {
        if (panel_0.urlPath) {
          navigate(panel_0.urlPath, {
            state: {
              base_location: baseLocation_0,
              panels: updatedPanels_0.map(_temp5)
            }
          });
        }
      });
    };
    $[11] = location;
    $[12] = navigate;
    $[13] = sidePanels;
    $[14] = t6;
  } else {
    t6 = $[14];
  }
  const open = t6;
  let t7;
  if ($[15] !== location || $[16] !== navigate || $[17] !== sidePanels) {
    t7 = (panelProps_0) => {
      const newPanels_2 = Array.isArray(panelProps_0) ? panelProps_0 : [panelProps_0];
      newPanels_2.forEach((panel_1) => {
        routesStore.current[panel_1.key] = panel_1;
      });
      const baseLocation_1 = location.state?.base_location ?? location;
      const updatedPanels_1 = [...sidePanels.slice(0, -newPanels_2.length), ...newPanels_2];
      updateSidePanels(updatedPanels_1);
      newPanels_2.forEach((panel_2) => {
        if (panel_2.urlPath) {
          navigate(panel_2.urlPath, {
            replace: true,
            state: {
              base_location: baseLocation_1,
              panels: updatedPanels_1.map(_temp6)
            }
          });
        }
      });
    };
    $[15] = location;
    $[16] = navigate;
    $[17] = sidePanels;
    $[18] = t7;
  } else {
    t7 = $[18];
  }
  const replace2 = t7;
  let t8;
  if ($[19] !== close2 || $[20] !== open || $[21] !== replace2 || $[22] !== sidePanels) {
    t8 = {
      sidePanels,
      setSidePanels: updateSidePanels,
      close: close2,
      open,
      replace: replace2
    };
    $[19] = close2;
    $[20] = open;
    $[21] = replace2;
    $[22] = sidePanels;
    $[23] = t8;
  } else {
    t8 = $[23];
  }
  return t8;
}
function _temp6(p_4) {
  return p_4.key;
}
function _temp5(p_3) {
  return p_3.key;
}
function _temp4(p_2) {
  return p_2.key;
}
function _temp3$1(p_1) {
  return p_1.key;
}
function _temp2$2(p_0) {
  return p_0.key;
}
function _temp$3(p2) {
  return Boolean(p2);
}
function useBuildDataSource({
  delegate,
  propertyConfigs,
  navigationController
}) {
  return {
    /**
     * Fetch entities in a Firestore path
     * @param path
     * @param collection
     * @param filter
     * @param limit
     * @param startAfter
     * @param searchString
     * @param orderBy
     * @param order
     * @return Function to cancel subscription
     * @see useCollectionFetch if you need this functionality implemented as a hook
     * @group Firestore
     */
    fetchCollection: useCallback(({
      path,
      collection,
      filter,
      limit,
      startAfter,
      searchString,
      orderBy,
      order: order2
    }) => {
      const usedDelegate = collection?.overrides?.dataSourceDelegate ?? delegate;
      return usedDelegate.fetchCollection({
        path,
        filter,
        limit,
        startAfter,
        searchString,
        orderBy,
        order: order2,
        collection
      });
    }, [delegate]),
    /**
     * Listen to a entities in a given path
     * @param path
     * @param collection
     * @param onError
     * @param filter
     * @param limit
     * @param startAfter
     * @param searchString
     * @param orderBy
     * @param order
     * @param onUpdate
     * @return Function to cancel subscription
     * @see useCollectionFetch if you need this functionality implemented as a hook
     * @group Firestore
     */
    listenCollection: delegate.listenCollection ? useCallback(({
      path: path_0,
      collection: collectionProp,
      filter: filter_0,
      limit: limit_0,
      startAfter: startAfter_0,
      searchString: searchString_0,
      orderBy: orderBy_0,
      order: order_0,
      onUpdate,
      onError
    }) => {
      const collection_0 = collectionProp ?? navigationController.getCollection(path_0);
      const usedDelegate_0 = collection_0?.overrides?.dataSourceDelegate ?? delegate;
      if (!usedDelegate_0.listenCollection) throw Error("useBuildDataSource delegate not initialised");
      return usedDelegate_0.listenCollection({
        path: path_0,
        filter: filter_0,
        limit: limit_0,
        startAfter: startAfter_0,
        searchString: searchString_0,
        orderBy: orderBy_0,
        order: order_0,
        onUpdate,
        onError,
        collection: collection_0
      });
    }, [delegate, navigationController.getCollection]) : void 0,
    /**
     * Retrieve an entity given a path and a collection
     * @param path
     * @param entityId
     * @param collection
     * @group Firestore
     */
    fetchEntity: useCallback(({
      path: path_1,
      entityId,
      collection: collection_1
    }) => {
      const usedDelegate_1 = collection_1?.overrides?.dataSourceDelegate ?? delegate;
      return usedDelegate_1.fetchEntity({
        path: path_1,
        entityId,
        collection: collection_1
      });
    }, [delegate.fetchEntity]),
    /**
     *
     * @param path
     * @param entityId
     * @param collection
     * @param onUpdate
     * @param onError
     * @return Function to cancel subscription
     * @group Firestore
     */
    listenEntity: delegate.listenEntity ? useCallback(({
      path: path_2,
      entityId: entityId_0,
      collection: collection_2,
      onUpdate: onUpdate_0,
      onError: onError_0
    }) => {
      const usedDelegate_2 = collection_2?.overrides?.dataSourceDelegate ?? delegate;
      if (!usedDelegate_2.listenEntity) throw Error("useBuildDataSource delegate not initialised");
      return usedDelegate_2.listenEntity({
        path: path_2,
        entityId: entityId_0,
        onUpdate: onUpdate_0,
        onError: onError_0,
        collection: collection_2
      });
    }, [delegate.listenEntity]) : void 0,
    /**
     * Save entity to the specified path. Note that Firestore does not allow
     * undefined values.
     * @param path
     * @param entityId
     * @param values
     * @param schemaId
     * @param collection
     * @param status
     * @group Firestore
     */
    saveEntity: useCallback(({
      path: path_3,
      entityId: entityId_1,
      values,
      collection: collectionProp_0,
      status
    }) => {
      const collection_3 = collectionProp_0 ?? navigationController.getCollection(path_3);
      const usedDelegate_3 = collection_3?.overrides?.dataSourceDelegate ?? delegate;
      const resolvedCollection = collection_3 ? resolveCollection({
        collection: collection_3,
        path: path_3,
        entityId: entityId_1,
        propertyConfigs
      }) : void 0;
      const properties = resolvedCollection?.properties;
      const firestoreValues = usedDelegate_3.cmsToDelegateModel(values);
      const updatedValues = properties ? updateDateAutoValues({
        inputValues: firestoreValues,
        properties,
        status,
        timestampNowValue: usedDelegate_3.currentTime?.() ?? /* @__PURE__ */ new Date(),
        setDateToMidnight: usedDelegate_3.setDateToMidnight
      }) : firestoreValues;
      return usedDelegate_3.saveEntity({
        path: path_3,
        collection: collection_3,
        entityId: entityId_1,
        values: updatedValues,
        status
      }).then((res) => {
        return {
          id: res.id,
          path: res.path,
          values: usedDelegate_3.delegateToCMSModel(updatedValues)
        };
      });
    }, [delegate.saveEntity, navigationController.getCollection]),
    /**
     * Delete an entity
     * @param entity
     * @param collection
     * @group Firestore
     */
    deleteEntity: useCallback(({
      entity,
      collection: collection_4
    }) => {
      const usedDelegate_4 = collection_4?.overrides?.dataSourceDelegate ?? delegate;
      return usedDelegate_4.deleteEntity({
        entity,
        collection: collection_4
      });
    }, [delegate.deleteEntity]),
    /**
     * Check if the given property is unique in the given collection
     * @param path Collection path
     * @param name of the property
     * @param value
     * @param property
     * @param entityId
     * @return `true` if there are no other fields besides the given entity
     * @group Firestore
     */
    checkUniqueField: useCallback((path_4, name, value, entityId_2, collection_5) => {
      const usedDelegate_5 = collection_5?.overrides?.dataSourceDelegate ?? delegate;
      return usedDelegate_5.checkUniqueField(path_4, name, value, entityId_2, collection_5);
    }, [delegate.checkUniqueField]),
    generateEntityId: useCallback((path_5, collection_6) => {
      const usedDelegate_6 = collection_6?.overrides?.dataSourceDelegate ?? delegate;
      return usedDelegate_6.generateEntityId(path_5, collection_6);
    }, [delegate.generateEntityId]),
    countEntities: delegate.countEntities ? async ({
      path: path_6,
      collection: collection_7,
      filter: filter_1,
      order: order_1,
      orderBy: orderBy_1
    }) => {
      const usedDelegate_7 = collection_7?.overrides?.dataSourceDelegate ?? delegate;
      return usedDelegate_7.countEntities({
        path: path_6,
        filter: filter_1,
        orderBy: orderBy_1,
        order: order_1,
        collection: collection_7
      });
    } : void 0,
    isFilterCombinationValid: useCallback(({
      path: path_7,
      databaseId,
      filterValues,
      sortBy
    }) => {
      if (!delegate.isFilterCombinationValid) return true;
      return delegate.isFilterCombinationValid({
        path: path_7,
        databaseId,
        filterValues,
        sortBy
      });
    }, [delegate.isFilterCombinationValid]),
    initTextSearch: useCallback(async (props) => {
      const usedDelegate_8 = props.collection?.overrides?.dataSourceDelegate ?? delegate;
      if (!usedDelegate_8.initTextSearch) return false;
      return usedDelegate_8.initTextSearch(props);
    }, [delegate.initTextSearch])
  };
}
const DEFAULT_SERVER = "https://api-drplyi3b6q-ey.a.run.app";
async function makeRequest(authController, dataSourceKey, pluginKeys, apiKey) {
  let idToken;
  try {
    idToken = await authController.getAuthToken();
  } catch (e2) {
    idToken = null;
  }
  return fetch(DEFAULT_SERVER + "/access_log", {
    // mode: "no-cors",
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Basic ${idToken}`
    },
    body: JSON.stringify({
      apiKey,
      email: authController.user?.email ?? null,
      datasource: dataSourceKey,
      plugins: pluginKeys
    })
  }).then(async (res) => {
    return res.json();
  });
}
function useProjectLog(t0) {
  const $ = c_1(11);
  const {
    authController,
    dataSourceDelegate,
    plugins,
    apiKey
  } = t0;
  const [accessResponse, setAccessResponse] = useState(null);
  const accessedUserRef = useRef(null);
  const dataSourceKey = dataSourceDelegate.key;
  let t1;
  if ($[0] !== plugins) {
    t1 = plugins?.map(_temp$2);
    $[0] = plugins;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const pluginKeys = t1;
  let t2;
  if ($[2] !== apiKey || $[3] !== authController || $[4] !== dataSourceKey || $[5] !== pluginKeys) {
    t2 = () => {
      if (authController.user && authController.user.uid !== accessedUserRef.current && !authController.initialLoading) {
        makeRequest(authController, dataSourceKey, pluginKeys, apiKey).then(setAccessResponse);
        accessedUserRef.current = authController.user.uid;
      }
    };
    $[2] = apiKey;
    $[3] = authController;
    $[4] = dataSourceKey;
    $[5] = pluginKeys;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  let t3;
  if ($[7] !== authController || $[8] !== dataSourceKey || $[9] !== pluginKeys) {
    t3 = [authController, dataSourceKey, pluginKeys];
    $[7] = authController;
    $[8] = dataSourceKey;
    $[9] = pluginKeys;
    $[10] = t3;
  } else {
    t3 = $[10];
  }
  useEffect(t2, t3);
  return accessResponse;
}
function _temp$2(plugin) {
  return plugin.key;
}
function FireCMS(props) {
  const {
    children,
    entityLinkBuilder,
    userConfigPersistence,
    dateTimeFormat,
    locale,
    authController,
    storageSource,
    dataSourceDelegate,
    plugins,
    onAnalyticsEvent,
    propertyConfigs,
    entityViews,
    components,
    navigationController,
    apiKey
  } = props;
  const dataSource = useBuildDataSource({
    delegate: dataSourceDelegate,
    propertyConfigs,
    navigationController
  });
  const sideDialogsController = useBuildSideDialogsController();
  const sideEntityController = useBuildSideEntityController(navigationController, sideDialogsController);
  const pluginsLoading = plugins?.some((p2) => p2.loading) ?? false;
  const loading = authController.initialLoading || navigationController.loading || pluginsLoading;
  const customizationController = {
    dateTimeFormat,
    locale,
    entityLinkBuilder,
    plugins,
    entityViews: entityViews ?? [],
    propertyConfigs: propertyConfigs ?? {},
    components
  };
  const analyticsController = useMemo(() => ({
    onAnalyticsEvent
  }), []);
  const accessResponse = useProjectLog({
    apiKey,
    authController,
    dataSourceDelegate,
    plugins
  });
  if (accessResponse?.message) {
    console.warn(accessResponse.message);
  }
  if (navigationController.navigationLoadingError) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CenteredView, { maxWidth: "md", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView, { title: "Error loading navigation", error: navigationController.navigationLoadingError }) });
  }
  if (authController.authError) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CenteredView, { maxWidth: "md", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorView, { title: "Error loading auth", error: authController.authError }) });
  }
  if (accessResponse?.blocked) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(CenteredView, { maxWidth: "md", fullScreen: true, className: "flex flex-col gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", gutterBottom: true, children: "License needed" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { children: [
        "You need a valid license to use FireCMS PRO. Please reach out at ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "mailto:hello@firecms.co", children: "hello@firecms.co" }),
        " for more information."
      ] }),
      accessResponse?.message && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { children: accessResponse?.message })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AnalyticsContext.Provider, { value: analyticsController, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomizationControllerContext.Provider, { value: customizationController, children: /* @__PURE__ */ jsxRuntimeExports.jsx(UserConfigurationPersistenceContext.Provider, { value: userConfigPersistence, children: /* @__PURE__ */ jsxRuntimeExports.jsx(StorageSourceContext.Provider, { value: storageSource, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DataSourceContext.Provider, { value: dataSource, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AuthControllerContext.Provider, { value: authController, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SideDialogsControllerContext.Provider, { value: sideDialogsController, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SideEntityControllerContext.Provider, { value: sideEntityController, children: /* @__PURE__ */ jsxRuntimeExports.jsx(NavigationContext.Provider, { value: navigationController, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogsProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FireCMSInternal, { loading, children }) }) }) }) }) }) }) }) }) }) });
}
function FireCMSInternal(t0) {
  const $ = c_1(7);
  const {
    loading,
    children
  } = t0;
  const context = useFireCMSContext();
  const customizationController = useCustomizationController();
  let childrenResult;
  if ($[0] !== children || $[1] !== context || $[2] !== customizationController.plugins || $[3] !== loading) {
    childrenResult = children({
      context,
      loading
    });
    const plugins = customizationController.plugins;
    if (!loading && plugins) {
      plugins.forEach((plugin) => {
        if (plugin.provider) {
          childrenResult = /* @__PURE__ */ jsxRuntimeExports.jsx(plugin.provider.Component, { ...plugin.provider.props, context, children: childrenResult });
        }
      });
    }
    $[0] = children;
    $[1] = context;
    $[2] = customizationController.plugins;
    $[3] = loading;
    $[4] = childrenResult;
  } else {
    childrenResult = $[4];
  }
  const t1 = childrenResult;
  let t2;
  if ($[5] !== t1) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: t1 });
    $[5] = t1;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  return t2;
}
const DRAWER_WIDTH = 280;
const Scaffold = React__default.memo(function Scaffold2(props) {
  const $ = c_1(46);
  const {
    children,
    autoOpenDrawer,
    logo,
    className,
    style: style2
  } = props;
  let t0;
  if ($[0] !== children) {
    t0 = React__default.Children.toArray(children).filter(_temp$1);
    $[0] = children;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const drawerChildren = t0;
  if (drawerChildren.length > 1) {
    throw Error("Only one Drawer component is allowed in Scaffold");
  }
  let t1;
  if ($[2] !== children) {
    t1 = React__default.Children.toArray(children).filter(_temp2$1);
    $[2] = children;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const appBarChildren = t1;
  if (appBarChildren.length > 1) {
    throw Error("Only one AppBar component is allowed in Scaffold");
  }
  let t2;
  if ($[4] !== children) {
    t2 = React__default.Children.toArray(children).filter(_temp3);
    $[4] = children;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const otherChildren = t2;
  const includeDrawer = drawerChildren.length > 0;
  const largeLayout = useLargeLayout();
  const [drawerOpen, setDrawerOpen] = React__default.useState(false);
  const [onHover, setOnHover] = React__default.useState(false);
  let t3;
  if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = () => setOnHover(true);
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  const setOnHoverTrue = t3;
  let t4;
  if ($[7] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = () => setOnHover(false);
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  const setOnHoverFalse = t4;
  let t5;
  if ($[8] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = () => {
      setDrawerOpen(true);
    };
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  const handleDrawerOpen = t5;
  let t6;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = () => {
      setDrawerOpen(false);
    };
    $[9] = t6;
  } else {
    t6 = $[9];
  }
  const handleDrawerClose = t6;
  const computedDrawerOpen = drawerOpen || Boolean(largeLayout && autoOpenDrawer && onHover);
  const hasAppBar = Boolean(appBarChildren.length > 0);
  let t7;
  if ($[10] !== autoOpenDrawer || $[11] !== computedDrawerOpen || $[12] !== includeDrawer || $[13] !== logo || $[14] !== onHover) {
    t7 = {
      logo,
      hasDrawer: includeDrawer,
      drawerHovered: onHover,
      drawerOpen: computedDrawerOpen,
      closeDrawer: handleDrawerClose,
      openDrawer: handleDrawerOpen,
      autoOpenDrawer
    };
    $[10] = autoOpenDrawer;
    $[11] = computedDrawerOpen;
    $[12] = includeDrawer;
    $[13] = logo;
    $[14] = onHover;
    $[15] = t7;
  } else {
    t7 = $[15];
  }
  let t8;
  if ($[16] !== className) {
    t8 = cls("flex h-screen w-screen bg-surface-50 dark:bg-surface-900 text-surface-900 dark:text-white overflow-hidden", className);
    $[16] = className;
    $[17] = t8;
  } else {
    t8 = $[17];
  }
  let t9;
  if ($[18] !== style2) {
    t9 = {
      paddingTop: "env(safe-area-inset-top)",
      paddingLeft: "env(safe-area-inset-left)",
      paddingRight: "env(safe-area-inset-right)",
      paddingBottom: "env(safe-area-inset-bottom)",
      height: "100dvh",
      ...style2
    };
    $[18] = style2;
    $[19] = t9;
  } else {
    t9 = $[19];
  }
  const t10 = includeDrawer && drawerChildren;
  let t11;
  if ($[20] !== computedDrawerOpen || $[21] !== includeDrawer || $[22] !== onHover || $[23] !== t10) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerWrapper, { displayed: includeDrawer, onMouseEnter: setOnHoverTrue, onMouseMove: setOnHoverTrue, onMouseLeave: setOnHoverFalse, open: computedDrawerOpen, hovered: onHover, setDrawerOpen, children: t10 });
    $[20] = computedDrawerOpen;
    $[21] = includeDrawer;
    $[22] = onHover;
    $[23] = t10;
    $[24] = t11;
  } else {
    t11 = $[24];
  }
  let t12;
  if ($[25] !== hasAppBar) {
    t12 = hasAppBar && /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerHeader, {});
    $[25] = hasAppBar;
    $[26] = t12;
  } else {
    t12 = $[26];
  }
  const t13 = !hasAppBar;
  let t14;
  if ($[27] !== t13) {
    t14 = cls(defaultBorderMixin, "flex-grow overflow-auto lg:m-0 lg:mx-4 lg:mb-4 lg:rounded-lg lg:border lg:border-solid m-0 mt-1", {
      "lg:mt-4": t13
    });
    $[27] = t13;
    $[28] = t14;
  } else {
    t14 = $[28];
  }
  let t15;
  if ($[29] !== otherChildren) {
    t15 = /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: otherChildren });
    $[29] = otherChildren;
    $[30] = t15;
  } else {
    t15 = $[30];
  }
  let t16;
  if ($[31] !== t14 || $[32] !== t15) {
    t16 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t14, children: t15 });
    $[31] = t14;
    $[32] = t15;
    $[33] = t16;
  } else {
    t16 = $[33];
  }
  let t17;
  if ($[34] !== t12 || $[35] !== t16) {
    t17 = /* @__PURE__ */ jsxRuntimeExports.jsxs("main", { className: "flex flex-col flex-grow overflow-auto", children: [
      t12,
      t16
    ] });
    $[34] = t12;
    $[35] = t16;
    $[36] = t17;
  } else {
    t17 = $[36];
  }
  let t18;
  if ($[37] !== appBarChildren || $[38] !== t11 || $[39] !== t17 || $[40] !== t8 || $[41] !== t9) {
    t18 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t8, style: t9, children: [
      appBarChildren,
      t11,
      t17
    ] });
    $[37] = appBarChildren;
    $[38] = t11;
    $[39] = t17;
    $[40] = t8;
    $[41] = t9;
    $[42] = t18;
  } else {
    t18 = $[42];
  }
  let t19;
  if ($[43] !== t18 || $[44] !== t7) {
    t19 = /* @__PURE__ */ jsxRuntimeExports.jsx(AppContext.Provider, { value: t7, children: t18 });
    $[43] = t18;
    $[44] = t7;
    $[45] = t19;
  } else {
    t19 = $[45];
  }
  return t19;
}, equal);
const DrawerHeader = () => {
  const $ = c_1(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col min-h-16" });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
};
function DrawerWrapper(props) {
  const $ = c_1(39);
  const width = !props.displayed ? 0 : props.open ? DRAWER_WIDTH : 72;
  let t0;
  if ($[0] !== width) {
    t0 = {
      width,
      transition: "left 100ms cubic-bezier(0.4, 0, 0.6, 1) 0ms, opacity 100ms cubic-bezier(0.4, 0, 0.6, 1) 0ms, width 100ms cubic-bezier(0.4, 0, 0.6, 1) 0ms"
    };
    $[0] = width;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== props) {
    t1 = !props.open && props.displayed && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Open menu", side: "right", sideOffset: 12, asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-2 fixed top-1 left-2 sm:top-2 sm:left-2 !bg-surface-50 dark:!bg-surface-900 rounded-full w-fit z-20", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { color: "inherit", "aria-label": "Open menu", onClick: () => props.setDrawerOpen(true), size: "large", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuIcon, {}) }) }) });
    $[2] = props;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const t2 = `z-20 absolute right-0 top-4 ${props.open ? "opacity-100" : "opacity-0 invisible"} transition-opacity duration-200 ease-in-out`;
  let t3;
  if ($[4] !== props) {
    t3 = () => props.setDrawerOpen(false);
    $[4] = props;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronLeftIcon, {});
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  let t5;
  if ($[7] !== t3) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { "aria-label": "Close drawer", onClick: t3, children: t4 });
    $[7] = t3;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  let t6;
  if ($[9] !== t2 || $[10] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t2, children: t5 });
    $[9] = t2;
    $[10] = t5;
    $[11] = t6;
  } else {
    t6 = $[11];
  }
  let t7;
  if ($[12] !== props.children) {
    t7 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col h-full", children: props.children });
    $[12] = props.children;
    $[13] = t7;
  } else {
    t7 = $[13];
  }
  let t8;
  if ($[14] !== t0 || $[15] !== t1 || $[16] !== t6 || $[17] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative h-full no-scrollbar overflow-y-auto overflow-x-hidden", style: t0, children: [
      t1,
      t6,
      t7
    ] });
    $[14] = t0;
    $[15] = t1;
    $[16] = t6;
    $[17] = t7;
    $[18] = t8;
  } else {
    t8 = $[18];
  }
  const innerDrawer = t8;
  const largeLayout = useLargeLayout();
  if (!largeLayout) {
    if (!props.displayed) {
      return null;
    }
    let t92;
    if ($[19] !== props) {
      t92 = () => props.setDrawerOpen(true);
      $[19] = props;
      $[20] = t92;
    } else {
      t92 = $[20];
    }
    let t102;
    if ($[21] === Symbol.for("react.memo_cache_sentinel")) {
      t102 = /* @__PURE__ */ jsxRuntimeExports.jsx(MenuIcon, {});
      $[21] = t102;
    } else {
      t102 = $[21];
    }
    let t11;
    if ($[22] !== t92) {
      t11 = /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { color: "inherit", "aria-label": "Open drawer", onClick: t92, size: "large", className: "absolute sm:top-2 sm:left-4 top-1 left-2", children: t102 });
      $[22] = t92;
      $[23] = t11;
    } else {
      t11 = $[23];
    }
    let t12;
    if ($[24] !== innerDrawer || $[25] !== props.open || $[26] !== props.setDrawerOpen) {
      t12 = /* @__PURE__ */ jsxRuntimeExports.jsx(Sheet, { side: "left", transparent: true, open: props.open, onOpenChange: props.setDrawerOpen, title: "Navigation drawer", overlayClassName: "bg-white bg-opacity-80", children: innerDrawer });
      $[24] = innerDrawer;
      $[25] = props.open;
      $[26] = props.setDrawerOpen;
      $[27] = t12;
    } else {
      t12 = $[27];
    }
    let t13;
    if ($[28] !== t11 || $[29] !== t12) {
      t13 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        t11,
        t12
      ] });
      $[28] = t11;
      $[29] = t12;
      $[30] = t13;
    } else {
      t13 = $[30];
    }
    return t13;
  }
  let t9;
  if ($[31] !== width) {
    t9 = {
      width,
      transition: "left 100ms cubic-bezier(0.4, 0, 0.6, 1) 0ms, opacity 100ms cubic-bezier(0.4, 0, 0.6, 1) 0ms, width 100ms cubic-bezier(0.4, 0, 0.6, 1) 0ms"
    };
    $[31] = width;
    $[32] = t9;
  } else {
    t9 = $[32];
  }
  let t10;
  if ($[33] !== innerDrawer || $[34] !== props.onMouseEnter || $[35] !== props.onMouseLeave || $[36] !== props.onMouseMove || $[37] !== t9) {
    t10 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "z-20 relative", onMouseEnter: props.onMouseEnter, onMouseMove: props.onMouseMove, onMouseLeave: props.onMouseLeave, style: t9, children: innerDrawer });
    $[33] = innerDrawer;
    $[34] = props.onMouseEnter;
    $[35] = props.onMouseLeave;
    $[36] = props.onMouseMove;
    $[37] = t9;
    $[38] = t10;
  } else {
    t10 = $[38];
  }
  return t10;
}
function _temp$1(child) {
  return child.type.componentType === "Drawer";
}
function _temp2$1(child_0) {
  return child_0.type.componentType === "AppBar";
}
function _temp3(child_1) {
  return child_1.type.componentType !== "Drawer" && child_1.type.componentType !== "AppBar";
}
function DrawerNavigationItem(t0) {
  const $ = c_1(24);
  const {
    name,
    icon,
    drawerOpen,
    adminMenuOpen,
    tooltipsOpen,
    url,
    onClick
  } = t0;
  let t1;
  if ($[0] !== icon) {
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-text-secondary dark:text-text-secondary-dark", children: icon });
    $[0] = icon;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const iconWrap = t1;
  const t2 = drawerOpen ? "width 150ms ease-in" : void 0;
  let t3;
  if ($[2] !== t2) {
    t3 = {
      width: "100%",
      transition: t2
    };
    $[2] = t2;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  let t4;
  if ($[4] !== drawerOpen) {
    t4 = (t52) => {
      const {
        isActive: isActive2
      } = t52;
      return cls("rounded-lg truncate", "hover:bg-surface-accent-300 hover:bg-opacity-75 dark:hover:bg-surface-accent-800 dark:hover:bg-opacity-75 text-text-primary dark:text-surface-200 hover:text-surface-900 hover:dark:text-white", "flex flex-row items-center mr-8", drawerOpen ? "pl-4 h-12" : "pl-4 h-11", "font-semibold text-xs", isActive2 ? "bg-surface-accent-200 bg-opacity-60 dark:bg-surface-800 dark:bg-opacity-50" : "");
    };
    $[4] = drawerOpen;
    $[5] = t4;
  } else {
    t4 = $[5];
  }
  const t5 = drawerOpen ? "opacity-100" : "opacity-0 hidden";
  let t6;
  if ($[6] !== t5) {
    t6 = cls(t5, "ml-4 font-inherit text-inherit");
    $[6] = t5;
    $[7] = t6;
  } else {
    t6 = $[7];
  }
  let t7;
  if ($[8] !== name) {
    t7 = name.toUpperCase();
    $[8] = name;
    $[9] = t7;
  } else {
    t7 = $[9];
  }
  let t8;
  if ($[10] !== t6 || $[11] !== t7) {
    t8 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t6, children: t7 });
    $[10] = t6;
    $[11] = t7;
    $[12] = t8;
  } else {
    t8 = $[12];
  }
  let t9;
  if ($[13] !== iconWrap || $[14] !== onClick || $[15] !== t3 || $[16] !== t4 || $[17] !== t8 || $[18] !== url) {
    t9 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(NavLink, { onClick, style: t3, className: t4, to: url, children: [
      iconWrap,
      t8
    ] }) });
    $[13] = iconWrap;
    $[14] = onClick;
    $[15] = t3;
    $[16] = t4;
    $[17] = t8;
    $[18] = url;
    $[19] = t9;
  } else {
    t9 = $[19];
  }
  const listItem2 = t9;
  const t10 = drawerOpen || adminMenuOpen ? false : tooltipsOpen;
  let t11;
  if ($[20] !== listItem2 || $[21] !== name || $[22] !== t10) {
    t11 = /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { open: t10, side: "right", title: name, children: listItem2 });
    $[20] = listItem2;
    $[21] = name;
    $[22] = t10;
    $[23] = t11;
  } else {
    t11 = $[23];
  }
  return t11;
}
function DefaultDrawer(t0) {
  const $ = c_1(52);
  const {
    className,
    style: style2
  } = t0;
  const {
    drawerHovered,
    drawerOpen,
    closeDrawer,
    logo
  } = useApp();
  const [adminMenuOpen, setAdminMenuOpen] = React__default.useState(false);
  const analyticsController = useAnalyticsController();
  const navigation = useNavigationController();
  const tooltipsOpen = drawerHovered && !drawerOpen && !adminMenuOpen;
  const largeLayout = useLargeLayout();
  const navigate = useNavigate();
  if (!navigation.topLevelNavigation) {
    throw Error("Navigation not ready in Drawer");
  }
  const {
    navigationEntries,
    groups
  } = navigation.topLevelNavigation;
  let t1;
  if ($[0] !== adminMenuOpen || $[1] !== analyticsController || $[2] !== className || $[3] !== closeDrawer || $[4] !== drawerOpen || $[5] !== groups || $[6] !== largeLayout || $[7] !== logo || $[8] !== navigate || $[9] !== navigationEntries || $[10] !== style2 || $[11] !== tooltipsOpen) {
    const adminViews = navigationEntries.filter(_temp) ?? [];
    let t2;
    let t3;
    let t4;
    let t5;
    let t6;
    let t7;
    if ($[13] !== adminMenuOpen || $[14] !== analyticsController || $[15] !== className || $[16] !== closeDrawer || $[17] !== drawerOpen || $[18] !== groups || $[19] !== largeLayout || $[20] !== logo || $[21] !== navigationEntries || $[22] !== style2 || $[23] !== tooltipsOpen) {
      const groupsWithoutAdmin = groups.filter(_temp2);
      let t82;
      if ($[30] !== drawerOpen) {
        t82 = (group) => {
          if (!drawerOpen) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full" });
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pl-6 pr-8 py-4 flex flex-row items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "secondary", className: "font-medium flex-grow line-clamp-1", children: group ? group.toUpperCase() : "Views".toUpperCase() }) });
        };
        $[30] = drawerOpen;
        $[31] = t82;
      } else {
        t82 = $[31];
      }
      const buildGroupHeader = t82;
      let t9;
      if ($[32] !== analyticsController || $[33] !== closeDrawer || $[34] !== largeLayout) {
        t9 = (view) => {
          const eventName = view.type === "collection" ? "drawer_navigate_to_collection" : view.type === "view" ? "drawer_navigate_to_view" : "unmapped_event";
          analyticsController.onAnalyticsEvent?.(eventName, {
            url: view.url
          });
          if (!largeLayout) {
            closeDrawer();
          }
        };
        $[32] = analyticsController;
        $[33] = closeDrawer;
        $[34] = largeLayout;
        $[35] = t9;
      } else {
        t9 = $[35];
      }
      const onClick = t9;
      if ($[36] !== className) {
        t5 = cls("flex flex-col h-full relative flex-grow w-full", className);
        $[36] = className;
        $[37] = t5;
      } else {
        t5 = $[37];
      }
      t6 = style2;
      if ($[38] !== logo) {
        t7 = /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerLogo, { logo });
        $[38] = logo;
        $[39] = t7;
      } else {
        t7 = $[39];
      }
      t2 = "mt-4 flex-grow overflow-scroll no-scrollbar";
      if ($[40] === Symbol.for("react.memo_cache_sentinel")) {
        t3 = {
          maskImage: "linear-gradient(to bottom, transparent 0, black 20px, black calc(100% - 20px), transparent 100%)"
        };
        $[40] = t3;
      } else {
        t3 = $[40];
      }
      let t10;
      if ($[41] !== adminMenuOpen || $[42] !== buildGroupHeader || $[43] !== drawerOpen || $[44] !== navigationEntries || $[45] !== onClick || $[46] !== tooltipsOpen) {
        t10 = (group_0) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-surface-50 dark:bg-surface-800 dark:bg-opacity-30 my-4 rounded-lg ml-3 mr-1", children: [
          buildGroupHeader(group_0),
          Object.values(navigationEntries).filter((e_0) => e_0.group === group_0).map((view_0, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerNavigationItem, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(IconForView, { collectionOrView: view_0.collection ?? view_0.view, size: "small" }), tooltipsOpen, adminMenuOpen, drawerOpen, onClick: () => onClick(view_0), url: view_0.url, name: view_0.name }, `navigation_${index2}`))
        ] }, `drawer_group_${group_0}`);
        $[41] = adminMenuOpen;
        $[42] = buildGroupHeader;
        $[43] = drawerOpen;
        $[44] = navigationEntries;
        $[45] = onClick;
        $[46] = tooltipsOpen;
        $[47] = t10;
      } else {
        t10 = $[47];
      }
      t4 = groupsWithoutAdmin.map(t10);
      $[13] = adminMenuOpen;
      $[14] = analyticsController;
      $[15] = className;
      $[16] = closeDrawer;
      $[17] = drawerOpen;
      $[18] = groups;
      $[19] = largeLayout;
      $[20] = logo;
      $[21] = navigationEntries;
      $[22] = style2;
      $[23] = tooltipsOpen;
      $[24] = t2;
      $[25] = t3;
      $[26] = t4;
      $[27] = t5;
      $[28] = t6;
      $[29] = t7;
    } else {
      t2 = $[24];
      t3 = $[25];
      t4 = $[26];
      t5 = $[27];
      t6 = $[28];
      t7 = $[29];
    }
    let t8;
    if ($[48] !== t2 || $[49] !== t3 || $[50] !== t4) {
      t8 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: t2, style: t3, children: t4 });
      $[48] = t2;
      $[49] = t3;
      $[50] = t4;
      $[51] = t8;
    } else {
      t8 = $[51];
    }
    t1 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: t5, style: t6, children: [
      t7,
      t8,
      adminViews.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Menu, { side: "right", open: adminMenuOpen, onOpenChange: setAdminMenuOpen, trigger: /* @__PURE__ */ jsxRuntimeExports.jsxs(IconButton, { shape: "square", className: "m-4 text-surface-900 dark:text-white w-fit", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Admin", open: tooltipsOpen, side: "right", sideOffset: 28, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MoreVertIcon, {}) }),
        drawerOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cls(drawerOpen ? "opacity-100" : "opacity-0 hidden", "mx-4 font-inherit text-inherit"), children: "ADMIN" })
      ] }), children: adminViews.map((entry, index_0) => /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem, { onClick: (event) => {
        event.preventDefault();
        navigate(entry.path);
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IconForView, { collectionOrView: entry.view }),
        entry.name
      ] }, `navigation_${index_0}`)) })
    ] }) });
    $[0] = adminMenuOpen;
    $[1] = analyticsController;
    $[2] = className;
    $[3] = closeDrawer;
    $[4] = drawerOpen;
    $[5] = groups;
    $[6] = largeLayout;
    $[7] = logo;
    $[8] = navigate;
    $[9] = navigationEntries;
    $[10] = style2;
    $[11] = tooltipsOpen;
    $[12] = t1;
  } else {
    t1 = $[12];
  }
  return t1;
}
function _temp2(g) {
  return g !== "Admin";
}
function _temp(e2) {
  return e2.type === "admin";
}
function DrawerLogo(t0) {
  const $ = c_1(12);
  const {
    logo
  } = t0;
  const navigation = useNavigationController();
  const {
    drawerOpen
  } = useApp();
  const t1 = drawerOpen ? "32px 144px 0px 24px" : "72px 12px 0px 12px";
  let t2;
  if ($[0] !== t1) {
    t2 = {
      transition: "padding 100ms cubic-bezier(0.4, 0, 0.6, 1) 0ms",
      padding: t1
    };
    $[0] = t1;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  let t3;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = cls("cursor-pointer rounded ml-3 mr-1");
    $[2] = t3;
  } else {
    t3 = $[2];
  }
  let t4;
  if ($[3] !== drawerOpen || $[4] !== logo) {
    t4 = logo ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: logo, alt: "Logo", className: cls("max-w-full max-h-full transition-all", drawerOpen ? "w-[96px] h-[96px]" : "w-[32px] h-[32px]") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(FireCMSLogo, {});
    $[3] = drawerOpen;
    $[4] = logo;
    $[5] = t4;
  } else {
    t4 = $[5];
  }
  let t5;
  if ($[6] !== navigation.basePath || $[7] !== t4) {
    t5 = /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Home", sideOffset: 20, side: "right", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link$2, { className: "block", to: navigation.basePath, children: t4 }) });
    $[6] = navigation.basePath;
    $[7] = t4;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  let t6;
  if ($[9] !== t2 || $[10] !== t5) {
    t6 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: t2, className: t3, children: t5 });
    $[9] = t2;
    $[10] = t5;
    $[11] = t6;
  } else {
    t6 = $[11];
  }
  return t6;
}
const NavigationRoutes = React__default.memo(function NavigationRoutes2({
  homePage = /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultHomePage, {}),
  children
}) {
  const location = useLocation();
  const navigation = useNavigationController();
  if (!navigation) return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  const state = location.state;
  const baseLocation = state && state.base_location ? state.base_location : location;
  const cmsViews = [];
  if (navigation.views) {
    navigation.views.forEach((cmsView) => {
      if (Array.isArray(cmsView.path)) cmsViews.push(...cmsView.path.map((path) => buildCMSViewRoute(path, cmsView)));
      else cmsViews.push(buildCMSViewRoute(cmsView.path, cmsView));
    });
  }
  if (navigation.adminViews) {
    navigation.adminViews.forEach((cmsView_0) => {
      if (Array.isArray(cmsView_0.path)) cmsViews.push(...cmsView_0.path.map((path_0) => buildCMSViewRoute(path_0, cmsView_0)));
      else cmsViews.push(buildCMSViewRoute(cmsView_0.path, cmsView_0));
    });
  }
  const sortedCollections = [...navigation.collections ?? []].sort((a2, b) => b.path.length - a2.path.length);
  const collectionRoutes = sortedCollections.map((collection) => {
    const urlPath = navigation.buildUrlCollectionPath(collection.id ?? collection.path);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: urlPath + "/*", element: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(EntityCollectionView, { isSubCollection: false, parentCollectionIds: [], fullPath: collection.id ?? collection.path, ...collection, Actions: toArray(collection.Actions) }, `collection_view_${collection.id ?? collection.path}`) }) }, `navigation_${collection.id ?? collection.path}`);
  });
  const homeRoute = /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", element: homePage });
  const notFoundRoute = /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "*", element: /* @__PURE__ */ jsxRuntimeExports.jsx(NotFoundPage, {}) });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { location: baseLocation, children: [
    collectionRoutes,
    cmsViews,
    homeRoute,
    notFoundRoute,
    children
  ] });
});
const buildCMSViewRoute = (path, cmsView) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path, element: cmsView.view }, "navigation_view_" + path);
};
function Drawer(t0) {
  const $ = c_1(6);
  const {
    children,
    className,
    style: style2
  } = t0;
  let t1;
  if ($[0] !== children || $[1] !== className || $[2] !== style2) {
    t1 = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultDrawer, { className, style: style2 });
    $[0] = children;
    $[1] = className;
    $[2] = style2;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const usedChildren = t1;
  let t2;
  if ($[4] !== usedChildren) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: usedChildren });
    $[4] = usedChildren;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}
Drawer.componentType = "Drawer";
function AppBar(t0) {
  const $ = c_1(8);
  let children;
  let props;
  if ($[0] !== t0) {
    ({
      children,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = props;
  } else {
    children = $[1];
    props = $[2];
  }
  let t1;
  if ($[3] !== children || $[4] !== props) {
    t1 = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultAppBar, { ...props });
    $[3] = children;
    $[4] = props;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  const usedChildren = t1;
  let t2;
  if ($[6] !== usedChildren) {
    t2 = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: usedChildren });
    $[6] = usedChildren;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  return t2;
}
AppBar.componentType = "AppBar";
export {
  AppBar,
  AppContext,
  ArrayContainer,
  ArrayContainerItem,
  ArrayCustomShapedFieldBinding,
  ArrayEnumPreview,
  ArrayItemOptions,
  ArrayOfMapsPreview,
  ArrayOfReferencesFieldBinding,
  ArrayOfReferencesPreview,
  ArrayOfStorageComponentsPreview,
  ArrayOfStringsPreview,
  ArrayOneOfPreview,
  ArrayPropertyEnumPreview,
  ArrayPropertyPreview,
  AsyncPreviewComponent,
  AuthControllerContext,
  BrowserRouter as B,
  BlockFieldBinding,
  BooleanPreview,
  ConnectedDroppable$1 as C,
  COLLECTION_PATH_SEPARATOR,
  CircularProgressCenter,
  ConfirmationDialog,
  DragDropContext as D,
  DEFAULT_FIELD_CONFIGS,
  DRAWER_WIDTH,
  DatePreview,
  DateTimeFieldBinding,
  DefaultAppBar,
  DefaultDrawer,
  DefaultHomePage,
  Drawer,
  DrawerLogo,
  DrawerNavigationItem,
  EmptyValue,
  EntityCollectionRowActions,
  EntityCollectionTable,
  EntityCollectionView,
  EntityCollectionViewActions,
  EntityReference,
  EntityView,
  EnumValuesChip,
  ErrorBoundary2 as ErrorBoundary,
  ErrorView,
  Formex as F,
  FieldCaption,
  FieldHelperText,
  FireCMS,
  FireCMSLogo,
  GeoPoint,
  IconForView,
  ImagePreview,
  KeyValueFieldBinding,
  KeyValuePreview,
  LabelWithIcon,
  LabelWithIconAndTooltip,
  MapFieldBinding,
  MapPropertyPreview,
  MarkdownEditorFieldBinding,
  ModeControllerContext,
  ModeControllerProvider,
  MultiSelectFieldBinding,
  NavLink as N,
  NavigationCard,
  NavigationCardBinding,
  NavigationGroup,
  NavigationRoutes,
  NotFoundPage,
  NumberPropertyPreview,
  PublicDraggable as P,
  PropertyConfigBadge,
  PropertyFieldBinding,
  PropertyIdCopyTooltip,
  PropertyIdCopyTooltipContent,
  PropertyPreview,
  PropertyTableCell,
  Routes as R,
  ReadOnlyFieldBinding,
  ReferenceFieldBinding,
  ReferencePreview,
  ReferenceSelectionTable,
  ReferenceWidget,
  RepeatFieldBinding,
  Scaffold,
  SearchIconsView,
  SelectFieldBinding,
  SelectableTable,
  SelectableTableContext,
  SideDialogs,
  SkeletonPropertyComponent,
  SmallNavigationCard,
  SnackbarProvider,
  StorageThumbnail,
  StorageThumbnailInternal,
  StorageUploadFieldBinding,
  StringPropertyPreview,
  SwitchFieldBinding,
  TextFieldBinding,
  UrlComponentPreview,
  Vector,
  VirtualTable,
  create$5 as a,
  addInitialSlash,
  applyPermissionsFunctionIfEmpty,
  archiveEntityAction,
  create$1 as b,
  buildAdditionalFieldDelegate,
  buildCollection,
  buildEntityCallbacks,
  buildEnumLabel,
  buildEnumValueConfig,
  buildEnumValues,
  buildFieldConfig,
  buildIdColumn,
  buildProperties,
  buildPropertiesOrBuilder,
  buildProperty,
  create$2 as c,
  canCreateEntity,
  canDeleteEntity,
  canEditEntity,
  copyEntityAction,
  useFormex as d,
  defaultDateFormat,
  deleteEntityAction,
  deleteEntityWithCallbacks,
  useNavigate as e,
  editEntityAction,
  enumToObjectEntries,
  format as f,
  flattenObject,
  fullPathToCollectionSegments,
  getIn as g,
  getArrayResolvedProperties,
  getArrayValuesCount,
  getBracketNotation,
  getCollectionByPathOrId,
  getCollectionPathsCombinations,
  getColorForProperty,
  getColorScheme,
  getColumnKeysForProperty,
  getDefaultFieldConfig,
  getDefaultFieldId,
  getDefaultPropertiesOrder,
  getDefaultValueFor,
  getDefaultValueForDataType,
  getDefaultValuesFor,
  getEntityImagePreviewPropertyKey,
  getEntityPreviewKeys,
  getEntityTitlePropertyKey,
  getFieldConfig,
  getFieldId,
  getFormFieldKeys,
  getHashValue,
  getIcon,
  getIconForProperty,
  getIconForWidget,
  getIdIcon,
  getLabelOrConfigFrom,
  getLastSegment,
  getPropertiesWithPropertiesOrder,
  getPropertyInPath,
  getRandomId$1 as getRandomId,
  getReferenceFrom,
  getResolvedPropertyInPath,
  getSidePanelKey,
  getValueInPath,
  Field as h,
  hydrateRegExp,
  clone as i,
  iconSynonyms,
  iconsSearch,
  isDefaultFieldConfigId,
  isEmptyObject,
  isEnumValueDisabled,
  isHidden,
  isObject,
  isPropertyBuilder,
  isReadOnly,
  isReferenceProperty,
  isValidRegExp,
  Route as j,
  joinCollectionLists,
  useLocation as k,
  locales as l,
  useParams as m,
  makePropertiesEditable,
  makePropertiesNonEditable,
  mergeCollection,
  mergeDeep,
  matchRoutes as n,
  openWebsiteAction,
  pick,
  plural,
  printChanged,
  propertiesToColumns,
  randomColor,
  randomString,
  removeFunctions,
  removeInPath,
  removeInitialAndTrailingSlashes,
  removeInitialSlash,
  removeNulls,
  removePropsIfExisting,
  removeTrailingSlash,
  removeUndefined,
  renderSkeletonCaptionText,
  renderSkeletonIcon,
  renderSkeletonImageThumbnail,
  renderSkeletonText,
  resolveArrayProperty,
  resolveCollection,
  resolveCollectionPathIds,
  resolveDefaultSelectedView,
  resolveEntityView,
  resolveEnumValues,
  resolveNavigationFrom,
  resolvePermissions,
  resolveProperties,
  resolveProperty,
  resolvePropertyEnum,
  resolveStorageFilenameString,
  resolveStoragePathString,
  setIn as s,
  sanitizeData,
  saveEntityWithCallbacks,
  segmentsToStrippedPath,
  serializeRegExp,
  singular,
  slugify,
  sortProperties,
  stripCollectionPath,
  toKebabCase,
  toSnakeCase,
  traverseValueProperty,
  traverseValuesProperties,
  useCreateFormex as u,
  unslugify,
  updateDateAutoValues,
  useApp,
  useAuthController,
  useBrowserTitleAndIcon,
  useBuildLocalConfigurationPersistence,
  useBuildModeController,
  useBuildNavigationController,
  useClearRestoreValue,
  useClipboard,
  useCollectionFetch,
  useColumnIds,
  useCustomizationController,
  useDataSource,
  useDataSourceEntityCollectionTableController,
  useDebouncedCallback,
  useDebouncedData,
  useDialogsController,
  useEntityFetch,
  useFireCMSContext,
  useLargeLayout,
  useModeController,
  useNavigationController,
  useReferenceDialog,
  useResolvedNavigationFrom,
  useSelectableTableController,
  useSelectionController,
  useSideDialogContext,
  useSideDialogsController,
  useSideEntityController,
  useSnackbarController,
  useStorageSource,
  useTableSearchHelper,
  useTraceUpdate,
  useValidateAuthenticator
};
